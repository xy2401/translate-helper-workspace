<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="chapter" id="sA">
            <div class="headl">
               <div class="headr">
                  <h1>§AOT / J语法</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sA.html">§AOT / J语法</a></li>
                  <li><a href="#sA.0">§A.0关键字</a></li>
                  <li><a href="#sA.1">§A.1类定义</a></li>
                  <li><a href="#sA.2">§A.2修饰符</a></li>
                  <li><a href="#sA.3">§A.3方法绑定</a></li>
                  <li><a href="#sA.4">§A.4参数映射</a></li>
                  <li><a href="#sA.5">§A.5声明</a></li>
                  <li><a href="#sA.6">§A.6类型</a></li>
                  <li><a href="#sA.7">§A.7守护谓词</a></li>
                  <li><a href="#sA.8">§A.8优先声明</a></li>
                  <li><a href="#sA.9">§A.9价值相关类型</a></li>
                  <li><a href="#sA.10">§A.10包装和进口</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>符号</h3>
               <p>以下语法规则扩展了<a href="http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html" class="ext">Java语言规范中</a>给出的Java语法。我们采用以斜体字体（例如， <tt><em>ClassDeclaration</em></tt> ）打印非终端符号和以罗马字体（例如， <tt>类</tt> ）打印终端符号的约定。以黑色打印的名称是指原始Java语法中的定义。对象组添加以<strong class="blue">蓝色粗体</strong>打印。对于那些只是向现有规则添加新选项的规则，原始选项由椭圆（ <code>...</code> ）表示。
                  		
               </p>
            </div>
            <div class="sect depth2" id="sA.0">
               <h2 class="sect">§A.0关键字<a class="img" href="sA.html#sA.0" title="永久链接到§A.0关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>OT / J引入的关键字具有不同的范围，这意味着在给定范围之外，这些关键字可用于常规标识符。只有这些名称是无条件的关键词：</p>
               <div class="listing plain"><pre>readonly, team, within</pre></div>
               <div class="sect depth3" id="sA.0.1">
                  <h3 class="sect">§A.0.1Scoped关键字<a class="img" href="sA.html#sA.0.1" title="PermaLinkto§A.0.1Scoped关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>以下名称是OT / J中的关键字，只有当它们出现在团队或角色类中时，即，在关键字<strong class="blue">团队</strong>被识别后：</p>
                  <div class="listing plain"><pre>as, base, callin, playedBy, precedence, tsuper, with, when</pre></div>
                  <p>这些名称只是分别在callin或callout绑定的上下文中的关键字（ <a href="#sA.3" title="§A.3方法绑定" class="sect">§A.3</a> ）：</p>
                  <div class="listing plain"><pre>after, before, replace, get, set</pre></div>
               </div>
               <div class="sect depth3" id="sA.0.2">
                  <h3 class="sect">§A.0.2继承范围的关键字<a class="img" href="sA.html#sA.0.2" title="PermaLinkto§A.0.2继承范围的关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>虽然常规Java类可以自由使用OT / J的作用域关键字（第<a href="#sA.0.1" title="§A.0.1Scoped关键字" class="sect">A.0.1节</a> ），但如果角色类继承了名称为作用域关键字的特性，则会出错。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="sA.0.3">
                  <h3 class="sect">§A.0.3内部名称<a class="img" href="sA.html#sA.0.3" title="PermaLinkto§A.0.3内部名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>编译器和运行时环境生成以前缀<code>_OT$</code>开头的内部方法和字段。在客户端代码中使用任何这些方法和字段是非法的。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="sA.1">
               <h2 class="sect">§A.1类定义<a class="img" href="sA.html#sA.1" title="PermaLinkto§A.1类定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>类定义添加了两个新关键字<code>team</code>和<code>playedBy</code> 。使用这些关键字的类分别称为<strong>团队</strong>和<strong>绑定角色</strong> 。从绑定角色类继承的任何类（通过<code>extends</code>子句或通过隐式继承，参见
                  	<a href="s1.html#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）也是一个受约束的角色类。
                  		
               </p>
               <table class="syntaxrule" id="sA.1.1">
                  <tr>
                     <td class="sect">§A.1.1</td>
                     <td class="rule"><span class="title">ClassDeclaration</span><br><em>[Modifiers]</em> <strong class="blue"><em>[</em> team <em>]</em></strong> class <em>Identifier [</em> extends <em>Type] [</em> implements <em>TypeList]</em><br><span class="indent5"></span> <strong class="blue"><em>[</em> playingBy <em>Type] [Guard]</em></strong> <em>ClassBody</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>playedBy</code>子句（ <strong>绑定角色</strong>类）的类可能不会被声明为静态，并且必须直接包含在具有<code>team</code>修饰符（ <strong>团队</strong>类）的类中。
                     </li>
                     <li>从团队类继承的类也必须具有<code>team</code>修饰符。
                     </li>
                     <li>有守卫的班级（见<a href="s5.html#s5.4" title="§5.4守护谓词" class="sect">§5.4</a> ）必须是团队或角色。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.2">
               <h2 class="sect">§A.2修饰符<a class="img" href="sA.html#sA.2" title="PermaLinkto§A.2修饰符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>方法修饰符的规则添加一个关键字： <code>callin</code> ：</p>
               <table class="syntaxrule" id="sA.2.1">
                  <tr>
                     <td class="sect">§A.2.1</td>
                     <td class="rule"><span class="title">修改</span><br>...<br><strong class="blue">呼唤</strong></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>callin</code>修饰符的方法的类可能不会被声明为static，并且必须直接包含在team类中。
                     </li>
                     <li>具有<code>callin</code>修饰符的方法可能不会出现在显式方法调用中（规则在JLS中应用）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.3">
               <h2 class="sect">§A.3方法绑定<a class="img" href="sA.html#sA.3" title="PermaLinkto§A.3方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>通过方法绑定增强了类体中可声明的项的规则：</p>
               <table class="syntaxrule" id="sA.3.1">
                  <tr>
                     <td class="sect">§A.3.1</td>
                     <td class="rule"><span class="title">ClassBodyDeclaration</span><br>...<br><strong class="blue"><em>CalloutBinding</em></strong><br><strong class="blue"><em>CallinBinding</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.2">
                  <tr>
                     <td class="sect">§A.3.2</td>
                     <td class="rule"><span class="title">CalloutBinding</span><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind MethodSpec CalloutParameterMappings</strong></em><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind CalloutModifier FieldSpec</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.3">
                  <tr>
                     <td class="sect">§A.3.3</td>
                     <td class="rule"><span class="title">Callin绑定</span><br><em>[Identifier</em> ： <em>] [TypeArguments]</em> <strong class="blue"><em>MethodSpec</em> &lt; - <em>CallinModifier MethodSpecs</em><br><span class="indent5"></span> [ <em>Guard</em> ] <em>CallinParameterMappings</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.4">
                  <tr>
                     <td class="sect">§A.3.4</td>
                     <td class="rule"><span class="title">MethodSpec</span><br><em>识别码</em><br><em>ResultType MethodDeclarator</em><br><em>ConstructorDeclarator</em></td>
                  </tr>
               </table>
               <div class="note">请注意， <em>ResultType</em> ， <em>MethodDeclarator</em>和<em>ConstructorDeclarator</em>在Java语言规范的整体语法中不明确。为方便起见，我们参考<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">8.4节中的定义<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">。方法声明</a>和<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8" class="ext">8.8。构造函数</a> Java语言规范的声明。
                  		
               </div>
               <table class="syntaxrule" id="sA.3.5">
                  <tr>
                     <td class="sect">§A.3.5</td>
                     <td class="rule"><span class="title">MethodSpecs</span><br><strong class="blue"><em>MethodSpec [</em> ， <em>MethodSpecs]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.6">
                  <tr>
                     <td class="sect">§A.3.6</td>
                     <td class="rule"><span class="title">CalloutKind</span><br><strong class="blue">- &gt;<br>=&gt;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.7">
                  <tr>
                     <td class="sect">§A.3.7</td>
                     <td class="rule"><span class="title">CallinModifier</span><br><strong class="blue">之前</strong><br><strong class="blue">后</strong><br><strong class="blue">更换</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.8">
                  <tr>
                     <td class="sect">§A.3.8</td>
                     <td class="rule"><span class="title">CalloutModifier</span><br><strong class="blue">得到</strong><br><strong class="blue">组</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.9">
                  <tr>
                     <td class="sect">§A.3.9</td>
                     <td class="rule"><span class="title">的FieldSpec</span><br><em>[类型]标识符</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li><code>CalloutBinding</code>和<code>CallinBinding</code>只能在绑定的角色类中出现。
                     </li>
                     <li><code>CalloutBinding</code>或<code>CallinBinding</code>可能不会为其方法说明符（ <code>MethodDeclarationHead</code> ）混合标识符和完整签名（ <code>MethodSpec</code> ）。
                        					<br>将完整方法签名绑定到字段需要<code>FieldSpec</code>包含<code>Type</code> 。
                     </li>
                     <li>具有<code>CallinBinding</code>修饰符的<code>replace</code>左侧的方法说明符必须引用具有<code>callin</code>修饰符的方法。
                     </li>
                     <li>标注绑定的<code>Modifier</code>只能是<code>public</code> ， <code>protected</code>或<code>private</code>的可见性修饰符之一。短的标注绑定（即没有签名）不得指定可见性修饰符。
                     </li>
                     <li>形状<code>MethodSpec</code> <code>ConstructorDeclarator</code>仅在绑定后的callin右侧合法（参见<a href="s4.html#s4.1.i" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.4">
               <h2 class="sect">§A.4参数映射<a class="img" href="sA.html#sA.4" title="PermaLinkto§A.4参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.4.1">
                  <tr>
                     <td class="sect">§A.4.1</td>
                     <td class="rule"><span class="title">CalloutParameterMappings</span><br><strong class="blue">使用{ <em>CalloutParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.2">
                  <tr>
                     <td class="sect">§A.4.2</td>
                     <td class="rule"><span class="title">CallinParameterMappings</span><br><strong class="blue">与{ <em>CallinParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.3">
                  <tr>
                     <td class="sect">§A.4.3</td>
                     <td class="rule"><span class="title">CalloutParameterMappingList</span><br><strong class="blue"><em>CalloutParameterMapping [</em> ， <em>CalloutParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.4">
                  <tr>
                     <td class="sect">§A.4.4</td>
                     <td class="rule"><span class="title">CallinParameterMappingList</span><br><strong class="blue"><em>CallinParameterMapping [</em> ， <em>CallinParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.5">
                  <tr>
                     <td class="sect">§A.4.5</td>
                     <td class="rule"><span class="title">CalloutParameterMapping</span><br><em>表达式</em> <strong class="blue">- &gt;</strong> <em>标识符</em><br><strong class="blue">结果&lt; -</strong> <em>表达</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.6">
                  <tr>
                     <td class="sect">§A.4.6</td>
                     <td class="rule"><span class="title">CallinParameterMapping</span><br><em>标识符</em> <strong class="blue">&lt; -</strong> <em>表达式</em><br><em>表达</em> <strong class="blue">- &gt;</strong> <strong class="blue">结果</strong></td>
                  </tr>
               </table>
               <div class="note">
                  <h5>注意：</h5>通过定义“;”作为参数映射的一个选项，语法强制执行没有参数映射的方法绑定由“;”终止。此外，带参数映射的方法绑定可以选择性地以“;”结束，在这种情况下，它被解释为空成员声明，遵循相同的模式，Java中的非抽象方法可以选择性地具有尾随“;”。
                  		
               </div>
            </div>
            <div class="sect depth2" id="sA.5">
               <h2 class="sect">§A.5声明<a class="img" href="sA.html#sA.5" title="PermaLink至§A.5声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.5.1">
                  <tr>
                     <td class="sect">§A.5.1</td>
                     <td class="rule"><span class="title">声明</span><br>...<br><em><strong class="blue">内</strong><br><strong class="blue">BaseCall</strong><br><strong class="blue">TSuperCall</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.2">
                  <tr>
                     <td class="sect">§A.5.2</td>
                     <td class="rule"><span class="title">内</span><br><strong class="blue">在</strong> （ <em>表达</em> ） <em>声明中</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.3">
                  <tr>
                     <td class="sect">§A.5.3</td>
                     <td class="rule"><span class="title">BaseCall</span><br><strong class="blue">基地</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">基数</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.4">
                  <tr>
                     <td class="sect">§A.5.4</td>
                     <td class="rule"><span class="title">TSuperCall</span><br><strong class="blue">tsuper</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">tsuper</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>的表达<code>Within</code>结果必须为团队类的一个实例。
                     </li>
                     <li><code>BaseCall</code>的第一种形式可能仅出现在具有<code>callin</code>修饰符的方法的主体中。标识符必须是封闭方法的名称。
                     </li>
                     <li><code>BaseCall</code>的第二种形式可能只出现在绑定角色类的构造函数中。
                     </li>
                     <li><code>TSuperCall</code>的第一种形式可能只出现在角色类的方法中。
                     </li>
                     <li><code>TSuperCall</code>的第二种形式可能只出现在角色类的构造函数中。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.6">
               <h2 class="sect">§A.6类型<a class="img" href="sA.html#sA.6" title="PermaLinkto§A.6类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.6.1">
                  <tr>
                     <td class="sect">§A.6.1</td>
                     <td class="rule"><span class="title">类型</span><br>...<br><strong class="blue"><em>LiftingType</em></strong><br><strong class="blue"><em>AnchoredType</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.2">
                  <tr>
                     <td class="sect">§A.6.2</td>
                     <td class="rule"><span class="title">LiftingType</span><br><em>类型</em> <strong class="blue">为</strong> <em>第一</em> <em>类</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.3">
                  <tr>
                     <td class="sect">§A.6.3</td>
                     <td class="rule"><span class="title">AnchoredType</span><br><strong class="blue"><em>路径</em></strong> 。<em>类型</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.4">
                  <tr>
                     <td class="sect">§A.6.4</td>
                     <td class="rule"><span class="title">路径</span><br><em>识别码</em><br><strong class="blue"><em>路径</em></strong> 。<em>识别码</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.6.a"><span class="title">地点</span><br><code>LiftingType</code>可能仅出现在团队类的方法的参数列表中。
                        				
                     </li>
                     <li id="sA.6.b"><span class="title">角色在范围内</span><br><code>LiftingType</code>的右侧类型必须是直接包含在封闭团队类中的类（该类可以通过<a href="s1.html#s1.3.1.c" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">隐式继承</a>获取<a href="s1.html#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">（§1.3.1。（c））</a> ）。
                        				
                     </li>
                     <li id="sA.6.c"><span class="title">团队路径</span><br><em>注意，不推荐使用§A.6.3/ 4的语法来支持<a href="#sA.9" title="§A.9价值相关类型" class="sect">§A.9</a></em> 。
                        					<br><code>AnchoredType</code>的路径必须引用团队类的实例。必须使用<code>final</code>修饰符声明路径中的每个标识符。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.7">
               <h2 class="sect">§A.7守护谓词<a class="img" href="sA.html#sA.7" title="永久链接到§A.7Guard谓词"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.7.1">
                  <tr>
                     <td class="sect">§A.7.1</td>
                     <td class="rule"><span class="title">守护</span><br><strong class="blue"><em>[</em>基数<em>]</em>何时</strong> （ <em>表达</em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.7.2">
                  <tr>
                     <td class="sect">§A.7.2</td>
                     <td class="rule"><span class="title">MethodDeclaration</span><br>...<br><em>MethodHeader <strong class="blue">[Guard]</strong> MethodBody</em></td>
                  </tr>
               </table>
               <p>其他涉及<em><code>Guard</code></em>规则： <a href="#sA.1.1" title="§A.1.1ClassDeclaration" class="sect">ClassDeclaration（§A.1.1）</a> ， <a href="#sA.3.3" title="§A.3.3Callin绑定" class="sect">CallinBinding（§A.3.3）</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>保护中的<code>Expression</code>必须具有<code>boolean</code>类型。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.8">
               <h2 class="sect">§A.8优先声明<a class="img" href="sA.html#sA.8" title="PermaLinkto§A.8优先声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.8.1">
                  <tr>
                     <td class="sect">§A.8.1</td>
                     <td class="rule"><span class="title">PrecedenceDeclaration</span><br><strong class="blue">优先级[after]</strong> <em>CallinNameList</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.8.2">
                  <tr>
                     <td class="sect">§A.8.2</td>
                     <td class="rule"><span class="title">CallinNameList</span><br><em>名称[，CallinNameList]</em></td>
                  </tr>
               </table>
            </div>
            <div class="sect depth2" id="sA.9">
               <h2 class="sect">§A.9价值相关类型<a class="img" href="sA.html#sA.9" title="PermaLinkto§A.9依赖于值的类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.9.1">
                  <tr>
                     <td class="sect">§A.9.1</td>
                     <td class="rule"><span class="title">TypeParameter</span><br><em>TypeVariable [TypeBound]</em><br><strong class="blue"><em>ReferenceType名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#108850" class="ext">JLS3§4.4</a></p>
               <table class="syntaxrule" id="sA.9.2">
                  <tr>
                     <td class="sect">§A.9.2</td>
                     <td class="rule"><span class="title">ActualTypeArgument</span><br><em>引用类型</em><br><em>通配符</em><br><strong class="blue"><em>@名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#107353" class="ext">JLS3§4.5.1</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.9.a"><span class="title">ActualTypeParameter</span><br><code>ActualTypeArgument</code>形式的<code>@Name</code>只能作为简单名称类型引用的参数出现。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.10">
               <h2 class="sect">§A.10包装和进口<a class="img" href="sA.html#sA.10" title="PermaLinkto§A.10包和导入"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.10.1">
                  <tr>
                     <td class="sect">§A.10.1</td>
                     <td class="rule"><span class="title">PackageDeclaration</span><br>...<br><strong class="blue">团队</strong>包<em>QualifiedName</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.10.2">
                  <tr>
                     <td class="sect">§A.10.2</td>
                     <td class="rule"><span class="title">进口</span><br>...<br><strong>import</strong> <strong class="blue">base</strong> <em>QualifiedName</em> ;</td>
                  </tr>
               </table>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>