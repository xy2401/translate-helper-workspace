<html lang="en-us" dir="ltr" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<meta name="DC.Type" content="reference"></meta>
<meta name="DC.Title" content="Property Accessors"></meta>
<meta name="abstract" content=""></meta>
<meta name="description" content=""></meta>
<meta name="DC.Relation" scheme="URI" content="../reference/oqlsyntax.html"></meta>
<meta name="copyright" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Rights.Owner" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Format" content="XHTML"></meta>
<meta name="DC.Identifier" content="propertyaccessors"></meta>
<meta name="DC.Language" content="en-us"></meta>
<link rel="stylesheet" type="text/css" href="../styles/commonltr.css"></link>
<title>物业配件</title>
</head>
<body id="propertyaccessors" dir="ltr">


	<h1 class="title topictitle1">物业配件</h1>

	
	

	<div class="body refbody"><p class="shortdesc"></p>

		<div class="section"><h2 class="title sectiontitle">访问堆对象的字段</h2>
			
			<p class="p">使用简单的点表示法访问堆对象的属性：</p>

			<p class="p">[&lt;别名&gt;。 ] &lt;field&gt;。 &lt;字段&gt;。&lt;字段&gt;</p>

			<p class="p">可以在<a class="xref" href="oqlsyntaxfrom.html">FROM子句中</a>定义<strong class="ph b">别名</strong> ，以标识当前对象，即SQL类比中的行，OQL语句在其上运行。如果没有别名，则假定该字段是当前对象的字段之一。
				<strong class="ph b">字段</strong>是堆转储中Java对象的属性。使用<a class="xref" href="tipsandtricks.html#oqlcompletion">OQL自动完成</a>或<span class="keyword cmdname">Object Inspector</span>查找<span class="keyword cmdname">对象</span>的可用字段。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">访问Java Bean属性</h2>
			
			<p class="p">[&lt;别名&gt;。 ] @ &lt;属性&gt; ...</p>

			<p class="p">使用@符号，OQL访问Memory Analyzer使用的底层Java对象的属性，以表示堆转储中的对象。通过Bean Introspection解析属性。使用<a class="xref" href="tipsandtricks.html#oqlcompletion">OQL自动完成</a>来查找公共bean名称。下表列出了一些常用的Java属性。
			</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__javabean_prop" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="22.22222222222222%">任何堆对象</td>

					<td valign="top" class="stentry" width="22.22222222222222%"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#method_summary">我反对</a></td>

					<td valign="top" class="stentry" width="22.22222222222222%">OBJECTID</td>

					<td valign="top" class="stentry" width="33.33333333333333%">快照对象的id</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">objectAddress</td>

					<td valign="top" class="stentry">快照对象的地址</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">类</td>

					<td valign="top" class="stentry">这个对象的Java类</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">clazz中</td>

					<td valign="top" class="stentry">这个对象的IClass。另请参见classof（object）。</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">usedHeapSize</td>

					<td valign="top" class="stentry">浅堆大小</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">retainedHeapSize</td>

					<td valign="top" class="stentry">保留堆大小</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">显示名称</td>

					<td valign="top" class="stentry">显示名称</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">类对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#method_summary">iCLASS非</a></td>

					<td valign="top" class="stentry">classLoaderId</td>

					<td valign="top" class="stentry">类加载器的id</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">任何数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IArray.html#method_summary">IArray</a></td>

					<td valign="top" class="stentry">长度</td>

					<td valign="top" class="stentry">数组的长度</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">原始数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#method_summary">IPrimitiveArray</a></td>

					<td valign="top" class="stentry">valueArray</td>

					<td valign="top" class="stentry">数组中的值</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">参考数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObjectArray.html#method_summary">IObjectArray</a></td>

					<td valign="top" class="stentry">referenceArray</td>

					<td valign="top" class="stentry">数组中的对象（作为长值，对象的地址）使用get（）访问特定元素并使用OBJECTS转换为对象。</td>

				</tr>
</table>

		</div>

		<div class="section"><h2 class="title sectiontitle">调用Java方法</h2>
			
			<pre class="pre codeblock">[&lt;别名&gt;。 ] @ &lt;method&gt;（[&lt;expression&gt;，&lt;expression&gt;]）...</pre>

			<p class="p">Adding（）强制OQL将其解释为Java方法调用。通过反射执行调用。下表列出了Memory Analyzer用于表示堆转储中的对象的底层Java对象的一些常见Java方法。
			</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__javabean_prop" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="22.22222222222222%">$ {}快照</td>

					<td valign="top" class="stentry" width="22.22222222222222%"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#method_summary">ISnapshot</a></td>

					<td valign="top" class="stentry" width="22.22222222222222%">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#getClasses()">getClasses（）</a></pre>

					</td>

					<td valign="top" class="stentry" width="33.33333333333333%">所有课程的集合</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#getClassesByName(java.util.regex.Pattern, boolean)">getClassesByName（String name，boolean includeSubClasses）</a></pre>

					</td>

					<td valign="top" class="stentry">一组课程</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">类对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#method_summary">iCLASS非</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#hasSuperClass()">hasSuperClass（）</a></pre>

					</td>

					<td valign="top" class="stentry">如果类具有超类，则结果为true</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#isArrayType()">isArrayType（）</a></pre>

					</td>

					<td valign="top" class="stentry">如果类是数组类型，则结果为true</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">任何堆对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#method_summary">我反对</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#getObjectAddress()">getObjectAddress（）</a></pre>

					</td>

					<td valign="top" class="stentry">快照对象的地址为长整数</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">原始数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#method_summary">IPrimitiveArray</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#getValueAt(int)">getValueAt（int index）</a></pre>

					</td>

					<td valign="top" class="stentry">数组中的值</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">Java原始数组，Java对象数组或Java列表（从反射返回）</td>

					<td valign="top" class="stentry">[]或列表</td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock">get（int index）</pre>

					</td>

					<td valign="top" class="stentry">数组或列表中的值</td>

				</tr>
</table>

		</div>

		<div class="section"><h2 class="title sectiontitle">阵列访问</h2>
			
			<p class="p">Memory Analyzer 1.3或更高版本允许从快照直接访问数组样式和对象数组，以及从反射方法调用获得的Java数组和Java列表。符号是<samp class="ph codeph">[index]</samp> 。索引是从零开始的整数。如果数组为null或索引超出范围，则结果为null。
			</p>

			<p class="p">Memory Analyzer 1.4或更高版本允许使用符号<samp class="ph codeph">[index1：index2]</samp>进行数组范围访问，其中index1和index2包含在内。如果值为负，则将它们视为从数组末尾开始的索引，因此-1表示最后一个条目。这意味着整个数组可以作为<samp class="ph codeph">[0：-1]</samp>的列表进行访问。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从原始数组中读取值（来自堆转储）</h2>
			
			<pre class="pre codeblock">SELECT s [2] FROM int [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s.getValueAt（2）FROM int [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。这将从具有至少3个元素的所有int []数组中读取索引2处元素的值。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从对象数组中读取对象（来自堆转储）</h2>
			
			<pre class="pre codeblock">SELECT s [2] FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。
			<samp class="ph codeph">s [2]</samp>是一个IObject，因此可以访问字段和Java bean属性</p>

			<pre class="pre codeblock">SELECT OBJECTS s [2] FROM java.lang。对象[] s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。<span class="keyword">OBJECTS</span>转换对象以提供树视图而不是表结果。我们不需要<span class="keyword">WHERE</span>子句，因为超出范围的访问返回null并且<span class="keyword">OBJECTS</span>跳过空值。</p>

			<pre class="pre codeblock">SELECT OBJECTS s。@ referenceArray.get（2）FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.1或更高版本。这将读取所有Object []数组中索引2处的元素的长地址，该数组至少包含3个元素并将它们转换为对象。
			</p>

			<pre class="pre codeblock">SELECT OBJECTS s.getReferenceArray（2,1）FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.1或更高版本。它从所有Object []数组开始，从索引2开始读取long [] 1元素数组，这些数组至少包含3个元素，并将这些数组的内容转换为对象。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从Java数组中读取（Memory Analyzer内部对象）</h2>
			
			<pre class="pre codeblock">SELECT s。@GCRoots [2] FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s.get（2）FROM OBJECTS $ {snapshot} s WHERE s。@ GCRoots。@ length&gt; 2</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从Java列表中读取（Memory Analyzer内部对象）</h2>
			
			<pre class="pre codeblock">SELECT s。@ GCRoots.subList（1,3）[1] FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s。@ GCRoots.subList（1,3）.get（1）FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">阅读子阵列</h2>
			
			<pre class="pre codeblock">SELECT s，s.count，s.offset，s.value [s.offset]，s.value [s.offset：（（s.offset + s.count） -  1）]，s.value [s.offset ：（（s.offset + 0） -  1）]，s.value [0：-1] .subList（s.offset，（s.offset + 0）），s.value [s.offset：-1] .subList（0，s.count）FROM java.lang。字符串</pre>

			<p class="p">此方法适用于Memory Analyzer 1.4或更高版本。</p>

			<p class="p">这显示了如何使用<samp class="ph codeph">[0：-1]</samp>将整个数组转换为列表，以及如何使用数组范围<samp class="ph codeph">[offset：offset + count-1]</samp>在<samp class="ph codeph">offset = 0</samp>和<samp class="ph codeph">count = 0</samp>时使用意外结果而不是空列表它给出了整个数组。一旦整个数组转换为列表<samp class="ph codeph">，</samp>使用<samp class="ph codeph">subList（offset，offet + count）</samp>将得到预期的结果。
			</p>

		</div>

		<div class="section"><!--no heading--><h2 class="title sectiontitle">
		</h2>
		
		</div>

		<div class="section"><h2 class="title sectiontitle">内置OQL功能</h2>
			
			<pre class="pre codeblock">&lt;function&gt;（&lt;parameter&gt;）</pre>

			<p class="p">内置功能。</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__oql_functions" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="40%">
						<pre class="pre codeblock">toHex（数字）</pre>

					</td>

					<td valign="top" class="stentry" width="60%">将数字打印为十六进制</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">toString（对象）</pre>

					</td>

					<td valign="top" class="stentry">返回对象的值，例如String的内容等。</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">支配者（对象）</pre>

					</td>

					<td valign="top" class="stentry">物体立即由物体支配</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">outbounds（对象）</pre>

					</td>

					<td valign="top" class="stentry">出境推荐人</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">inbounds（对象）</pre>

					</td>

					<td valign="top" class="stentry">入境推荐人</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">classof（对象）</pre>

					</td>

					<td valign="top" class="stentry">当前对象的类</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">支配者（对象）</pre>

					</td>

					<td valign="top" class="stentry">直接支配者，如果没有，则为-1</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">eval（表达式）</pre>

					</td>

					<td valign="top" class="stentry">（Memory Analyzer 1.4或更高版本中的实验）评估参数并返回它。允许数组/方法访问子选择或表达式的结果可能很有用。
					</td>

				</tr>
</table>


		</div>

	</div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a class="link" href="../reference/oqlsyntax.html">OQL语法</a></div>
</div>
</div>

</body>
</html>