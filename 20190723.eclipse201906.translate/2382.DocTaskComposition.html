<html dir="ltr">

<head>
<title>任务组合（Oomph设置文档）</title>

<link rel="stylesheet" href="../book.css"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Task Composition (Oomph Setup Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>任务组合</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="DocSetupResource.html" title="向后设置资源"><img src="../../images/backward.png" border="0"></a> <a href="DocTaskExecution.html" title="转发到任务执行"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p>通过从可用<a href="DocScope.html" title="Oomph设置文档中的文章">范围</a>收集<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a>列表以准备<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">任务执行</a>来驱动安装和配置过程。
 </p>

<h2><a name="ScopeList"></a> 1范围清单</h2>
<p>在准备收集任务列表时，收集有序<a href="DocScope.html" title="Oomph设置文档中的文章">范围</a>列表。

<a name="ScopeList.scopeList">对于<a href="../user/wizard/DocProjectPage.html" title="Oomph设置文档中的文章">项目页面</a>或<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区中</a>指定的每个<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流</a> ，将重复以下收集范围的过程：<ul>

 <li>访问<a href="../user/wizard/DocProductPage.html" title="Oomph设置文档中的文章">产品页面</a>或<a href="DocScope.html#DocInstallation" title="Oomph设置文档中的章节">安装中</a>选择的<a href="DocScope.html#DocVersion" title="Oomph设置文档中的章节">产品版本</a> 。
 <ul>
 <li>该产品版本的含有添加<a href="DocScope.html#DocProduct" title="Oomph设置文档中的章节">产品</a>的含<a href="DocScope.html#DocProductCatalog" title="Oomph设置文档中的章节">产品目录</a>到列表中。将包含产品的产品版本添加到列表中。将该产品版本本身添加到列表中。
 </li>
 </ul>
 </li>

 <li>访问<a href="../user/wizard/DocProjectPage.html" title="Oomph设置文档中的文章">项目页面</a>或<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区中</a>选择的<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流</a> （如果有）。
 <ul>
 <li>将包含<a href="DocScope.html#DocProject" title="Oomph设置文档中的章节">项目</a>包含<a href="DocScope.html#DocProjectCatalog" title="Oomph设置文档中的章节">项目目录的</a>流添加到列表中。将该流的最外层项目添加到列表中，然后向下遍历嵌套项目直到包含项目的流，将每个项目添加到列表中。将该流本身添加到列表中。
 </li>
 </ul>
 </li>

 <li>将<a href="DocScope.html#DocInstallation" title="Oomph设置文档中的章节">安装</a>添加到列表中。
 </li>

 <li>将<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区</a>添加到列表中。
 </li>

 <li>将<a href="DocScope.html#DocUser" title="Oomph设置文档中的章节">用户</a>添加到列表中。
 </li>
 </ul>
 </a></p>

<a name="ScopeList.scopeVariables">
<p>对于每个范围列表，将收集有序的任务列表。最初，对于列表中的每个范围，引入三个<a href="DocTask.html#DocVariableTask" title="Chapter in Oomph Setup Documentation">变量</a> ，每个<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>用于范围的<a href="DocScope.html.name" title="Oomph设置文档中的部分">名称</a> ， <a href="DocScope.html.label" title="Oomph设置文档中的部分">标签</a>和<a href="DocScope.html.description" title="Oomph设置文档中的部分">描述</a>属性，其中变量名称以<a href="../../javadoc/org/eclipse/oomph/setup/ScopeType.html" title="org.eclipse.oomph.setup中的类"><code>scope type</code></a>为前缀，如下所示：</p><ul>
 <li>
 <code>scope.product.catalog</code>
 </li>
 <li>
  <code>scope.product</code>
 </li>
 <li>
  <code>scope.product.version</code>
 </li>
 <li>
 <code>scope.project.catalog</code>
 </li>
 <li>
 <code>scope.project</code>
 </li>
 <li>
 <code>scope.project.stream</code>
 </li>
 <li>
 <code>scope.installation</code>
 </li>
 <li>
 <code>scope.workspace</code>
 </li>
 <li>
  <code>scope.user</code>
 </li>
 </ul>每个此类变量的值将是范围的该属性的值。如果作用域的标签为<code>null</code> ，则该名称用作标签值，如果作用域的描述为<code>null</code> ，则作用域的标签将用作描述值。此外，对于<code>name</code>变量，对于每个产品，产品版本，项目和项目流，将引入名为suffix <code>.qualifier</code>的附加变量，其中值是范围的<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getQualifiedName()" title="org.eclipse.oomph.setup中的方法。范围"><code>qualified name</code></a> 。例如，Oomph.setup项目的主流的<code>scope.project.stream.name.qualified</code>变量的值是<code>org.eclipse.oomph.master</code>所有这些诱导变量按范围顺序添加到初始收集的列表中任务。
 

<a name="ScopeList.footer">
<p>通过访问每个范围的每个包含任务，将其他任务从有序范围收集到任务列表中，如下所示：</p><ul>
 <li>如果任务已禁用，请忽略该任务。
 </li>
 <li>如果范围列表不包含任何任务的限制，请忽略该任务。
 </li>
 <li>如果任务是<a href="DocTask.html#DocCompoundTask" title="Oomph设置文档中的章节">复合的</a> ，则递归地访问每个复合任务的包含任务。
 </li>
 <li>否则，将任务添加到任务列表中。在其他工作中，收集的任务列表将仅包含叶任务。
 </li>
 </ul>在范围处理结束时，收集的任务列表包含所有每个流的任务，如果没有流，则只包含任务列表。每个任务列表（或一个任务列表）分两个阶段进一步处理。初始阶段分别应用于每个任务列表。然后将每流任务列表连接成单个列表，并将第二阶段应用于该最终组成列表，或者由第二阶段进一步处理该一个任务列表。每个阶段中任务列表的处理大致相同。
 

<h2><a name="TaskList"></a> 2任务列表</h2>
<p>处理任务列表以引发其他任务， <a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖和合并</a>任务，评估和扩展变量以及<a href="DocTask.html.order" title="Oomph设置文档中的部分">重新排序</a>任务。作为<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>的任务列表的成员引起一组初始键，即一组所有变量名。Oomph任务使用EMF建模，因此每个任务实例都知道它对应的EMF类。在初始阶段处理期间，分析任务列表以确定实现列表中所有任务所需的EMF类集。每个EMF类的处理方式如下：</p><ul>
 <li>如果类包含启用注释，则引发<a href="DocTask.html#DocP2Task" title="Oomph设置文档中的章节">p2任务</a> ，即在已安装的产品中安装必要实现的任务，并将这些引发的任务添加到任务列表的头部。
 </li>
 <li>如果类包含变量注释，则引发<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>并将它们添加到任务列表的头部。
 </li>

 <li>访问该类的每个属性，如下所示：<ul>如果属性的类型不是String，则忽略它。
 <li>如果属性同时具有变量注释和变量规则注释，请访问任务列表中该属性类的每个实例，如下所示：<ul>
 <li>如果该实例任务中的属性值不为空，则不需要该规则，因此请忽略该规则。
 </li>
 <li>如果实例任务没有ID，或者它具有ID，但是由ID值组成的键，带有'。'并且附加的属性名称已经在诱导键列表中，不需要该规则，因此请忽略它。
 </li>
 <li>如果尚未针对另一个任务实例引入该规则变量，则为该属性引入规则变量。
 </li>
 </ul>保持从规则变量到其诱导属性的映射。
 </li><li>
 </li>
 </ul></li>
 </ul>在第一阶段的处理结束时，任务列表包括附加的诱导变量和任务。对于最后阶段，组合的任务列表不包含变量，因为它们都已经过评估和扩展，并且已经存在诱导任务。
 

<a name="TaskList.substitutions">
<p>进一步处理如下：</p><ul>
 <li>通过访问每个任务来构建替换映射，即替换的任务到任务映射，如下所示：<ul>
 <li>将任务的<a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖令牌</a>放入令牌到任务映射中，如果令牌到任务映射中已存在该令牌的另一个任务，则访问的任务将替换该另一个任务，因此将其添加到替换映射中。因此，列表中稍后的任务可以覆盖列表中较早的任务。
 </li>然后进一步处理替换映射以遵循替换映射以便表示直接替换。
 </ul>
 </li>
 </ul>
 

<h3><a name="InitialPhase"></a> 2.1初始阶段</h3>
<p>对于初始阶段处理，所有任务都被有效复制，包括复制包含的范围。复制过程将任务 - 任务<a href="DocTaskComposition.html#TaskList.substitutions" title="Oomph设置文档中的部分">替换</a>映射考虑在内，即每个任务在其副本中通过其<a href="DocTask.html.override" title="Oomph设置文档中的部分">合并的覆盖进行</a>逻辑替换。因此，只有最终重写的合并任务仍保留在生成的任务列表副本中，并且对重写和重写任务的所有引用都将引用最终合并的重写。任务列表的进一步处理继续该复制的任务列表。
 </p>
 <p>通过访问任务列表中的每个变量来计算显式键映射，即从变量名到变量的映射。请注意，前面的复制过程将消除重复的变量。然后，初始阶段处理通过使用非空ID属性访问每个任务来进行，如下所示：</p><ul>
 <li>访问任务的EMF类的每个属性，关于通过附加'。'引起的变量名称。以及任务ID属性值的属性名称：<ul>
 <li>如果属性是任务的ID属性，或者该属性不是单值String类型属性，请忽略它。
 </li>
 <li>如果显式键包含诱导变量的名称，则该属性的任务值为空，并且该属性具有变量注释，将该属性的任务值更改为对显式变量的引用。
 </li>
 <li>如果显式键不包含诱导变量名称，则引发一个新变量记录，使其成为显式键，将其添加到任务列表中，并执行以下操作：<ul>
 <li>如果属性的任务值为空，并且属性具有变量注释，则将该属性的任务值更改为对诱导变量的引用。
 </li>
 <li>相反，如果属性的任务值非空，则将诱导变量的值设置为该值，对于空值情况，如果属性具有变量注释，则将该属性的任务值更改为参考到诱导变量。
 </li>
 <li>还为每个属性的规则注释引入规则变量，将它们记录为显式键。
 </li>
 <li>最后，如果属性具有变量注释，并且诱导变量的值是将导致循环评估的自引用，则引入另一个变量，其中诱导变量的名称以属性的显式注释为<code>.explicit</code>后缀，并且还可以更改自引用变量的值以引用该显式变量。
 </li>
 </ul>
 </li>
 </ul>
 </li>
 <li>访问每个任务以处理其所谓的活动注释。这些注释可用于变量，以从其他变量中定义的选项组成一组选择，或从另一个变量的值中引出选择。TODO的例子</li>
 <li>访问每个变量任务以构建键到值映射。分析该映射以确定变量引用，根据此依赖性分析重新排序映射。并在有序映射中展开变量。
 </li>
 <li>根据键值映射扩展所有任务的所有属性的值，但标记为不可扩展的属性除外。例如，不扩展变量本身的name属性。
 </li>
 <li>回想一下，任务的收集有效地<a href="DocTaskComposition.html#ScopeList.footer" title="Oomph设置文档中的部分">忽略了</a> <a href="DocTask.html#DocCompoundTask" title="Oomph设置文档中的章节">复合任务</a> 。但是那些复合任务可以指定<a href="DocTask.html.order" title="Oomph设置文档中的部分">前辈和后继者</a>以及<a href="DocTask.html.restrictions" title="Oomph设置文档中的部分">限制</a> 。因此，这些前身和后继者被扩展为参考叶子任务。此外，由此产生的扩展前辈和后续者以及限制因素都会传播到叶子任务中。
 </li>
 </ul>
 <p>

</p><h3><a name="FinalPhase"></a> 2.2最后阶段</h3>
<p>最后阶段处理任务列表，该列表是从初始阶段生成的任务列表的串联，或者仅是初始阶段已经处理的一个任务列表。因此，它正在使用任务副本，所有变量都已扩展和消除。此阶段的处理通过分析结构重复的任务列表来增强替换映射。然后，它应用这些替换，即覆盖和合并重复任务，从而在进一步处理之前减少任务列表。
 </p>

<h3><a name="Reorder"></a> 2.3重新排序</h3>
<p>任务列表的处理，特别是任务<a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖</a>和合并，会影响任务列表的整体顺序，使其与从作用域收集的原始创作顺序不同。不仅如此，当涉及多个流时， <a href="DocTaskComposition.html#FinalPhase" title="Oomph设置文档中的章节">最终阶段</a>处理正在处理连接列表，其中必须正确地重新排序任务。为了支持这一点，每项任务都具有内在的<a href="DocTask.html.order" title="Oomph设置文档中的部分">优先权</a> ;任务列表主要根据该优先级排序。每个任务还指定<a href="DocTask.html.order" title="Oomph设置文档中的部分">前任和后继者</a> ;对任务列表进行二次排序以尊重诱导的部分顺序。在这两个排序步骤之后，修改列表中的任务以清除前驱者和后继者，然后将前驱者设置为形成一个链，该链引起整个顺序，这正是排序任务列表的最终顺序;这个链排除了变量。这种依赖关系确保处理连接任务列表的最终阶段处理将正确地交织任务（由于优先级排序），同时还遵守多个流的每个流的顺序。
 </p><p>

</p><h3><a name="Filter"></a> 2.4触发过滤</h3>
<p>从任务列表中删除<a href="DocTask.html.excludedTriggers" title="Oomph设置文档中的部分">排除</a>当前<a href="DocTask.html#DocTrigger" title="Oomph设置文档中的章节">触发器的</a>每个任务。请注意，任务列表收集过程收集<b>所有</b>任务，因为会分析任务列表以确定需要为所有可能的触发器安装哪些任务。因此，对于<a href="DocTask.html#DocTrigger.bootstrap" title="Oomph设置文档中的部分">引导程序引导程序</a>触发器，即使是在已安装的产品中运行之前无法执行的任务也会被分析，以确保在安装产品后，需要在该安装中执行的任务，即<a href="DocTask.html#DocTrigger.startup" title="Oomph设置文档中的部分">启动</a>或<a href="DocTask.html#DocTrigger.manual" title="Oomph设置文档中的部分">手动</a>触发器，已正确安装。所有任务的处理也意味着在系统启动时，将在运行安装的产品所需要的所有变量将被<a href="../user/wizard/DocVariablePage.html" title="Oomph设置文档中的文章">提示</a>早，因此在运行安装的产品都已经上市。
 </p>

<h3><a name="Consolidation"></a> 2.5合并</h3>
<p>最终任务列表处理步骤从任务列表中删除所有变量并<a href="DocTask.html.consolidate" title="Oomph设置文档中的部分">合并</a>每个剩余任务。此时，列表中的任务已准备好<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">执行</a> 。
 </p>

<p align="right">
<a href="DocSetupResource.html" title="向后设置资源"><img src="../../images/backward.png" border="0"></a> <a href="DocTaskExecution.html" title="转发到任务执行"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（Loehne，Germany）和其他人。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v2.0条款提供，可从http://www.eclipse.org/legal/epl-v20.html获取。</div>
</a></a></a></body>
</html>