<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>OclAny</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library">
<link rel="prev" href="Map.html" title="Map(K, V)">
<link rel="next" href="OclComparable.html" title="OclComparable">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">OclAny</h1>
<div class="section" title="OclAny">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OclAny"></a>
				<span class="bold"><strong>
					<code class="code">OclAny</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>在收集要素的数量<code class="code">self</code> .essions。OclAny本身就是元类型AnyType的一个实例。
			</p>
<p>UML模型中的所有类都继承OclAny上定义的所有操作。为了避免模型中的属性与从OclAny继承的属性之间的名称冲突，OclAny属性上的所有名称都以'ocl'开头。虽然理论上可能仍然存在名称冲突，但可以避免它们。也可以使用OclAny（类型名称）的限定来显式引用OclAny属性。</p>
<p>OclAny的操作，其中OclAny的实例称为对象。</p>
<p>
				
<span class="bold"><strong>属性</strong></span>
			
</p>
<p>
				
<code class="code">OclInvalid : Bag(OclInvalid[*|?])</code>
			
</p>
<p>
				
<span class="bold"><strong>操作</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>如果<code class="code">self</code>与object2是同一个对象，则为True。中缀运营商。
			</p>
<div class="literallayout">
<p>
<code class="code">post:&nbsp;result&nbsp;=&nbsp;self&nbsp;=&nbsp;object2<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>如果<code class="code">self</code>是与object2不同的对象，则为True。中缀运营商。
			</p>
<div class="literallayout">
<p>
<code class="code">post:&nbsp;result&nbsp;=&nbsp;not&nbsp;(self&nbsp;=&nbsp;object2)<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">oclAsSet() : Set(OclSelf)</code>
			
</p>
<p>返回一个以<code class="code">self</code>为唯一内容的Set，除非<code class="code">self</code>为<code class="code">null</code>在这种情况下返回一个空集，</p>
<p>
				
<code class="code">oclAsType(TT)(type : TT[?]) : TT[1] invalidating</code>
			
</p>
<p>评估<code class="code">self</code> ，其中<code class="code">self</code>是由<code class="code">TT</code>识别的类型。类型<code class="code">TT</code>可以是由OCL或用户元模型定义的任何分类器;如果评估时的实际<code class="code">self</code>类型不符合<code class="code">TT</code> ，则oclAsType操作评估为<code class="code">invalid</code> 。
			</p>
<p>如果<code class="code">self</code>是多重分类的实例，则用于OCL导航的当前分类将更改为<code class="code">TT</code>符合的分类。如果分类不明确，则oclAsType调用的格式不正确。
			</p>
<p>在特征重新定义的情况下，将对象转换为其实际类型的超类型不会访问超类型的特征定义;根据重新定义的语义，重新定义的特征根本不存在于对象中。但是，当转换为超类型时，将抑制由子类型另外定义的任何特征。</p>
<div class="literallayout">
<p>
<code class="code">post&nbsp;IsSelf:&nbsp;result&nbsp;=&nbsp;self<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">oclIsInState(statespec : OclState[?]) : Boolean[1]</code>
			
</p>
<p>如果<code class="code">true</code>处于statepec标识的状态，则求值为<code class="code">self</code> 。
			</p>
<p>
				
<code class="code">oclIsInvalid() : Boolean[1] validating</code>
			
</p>
<p>如果<code class="code">true</code>等于OclInvalid，则求值为<code class="code">self</code> 。
			</p>
<p>
				
<code class="code">oclIsKindOf(type : OclType[?]) : Boolean[1]</code>
			
</p>
<p>计算结果为<code class="code">true</code> ，如果类型<code class="code">self</code>符合<code class="code">type</code> 。也就是说， <code class="code">self</code>是类型<code class="code">type</code>或类型的子<code class="code">type</code> 。
			</p>
<p>
				
<code class="code">oclIsNew() : Boolean[1]</code>
			
</p>
<p>只能在后置条件中使用。如果在执行操作期间创建<code class="code">true</code> （例如，它在预处理时间不存在），则求值为<code class="code">self</code> 。
			</p>
<p>
				
<code class="code">oclIsTypeOf(type : OclType[?]) : Boolean[1]</code>
			
</p>
<p>计算结果为<code class="code">true</code> ，如果<code class="code">self</code>是该类型的<code class="code">type</code> ，但不是一个亚型<code class="code">type</code> 。
			</p>
<p>
				
<code class="code">oclIsUndefined() : Boolean[1] validating</code>
			
</p>
<p>如果<code class="code">true</code>等于<code class="code">self</code>或等于<code class="code">invalid</code>则求值为<code class="code">null</code> 。
			</p>
<p>
				
<code class="code">oclLog() : OclSelf[?]</code>
			
</p>
<p>评估自我，产生包含self的日志消息的副作用。</p>
<p>
				
<code class="code">oclLog(message : String[?]) : OclSelf[?]</code>
			
</p>
<p>评估自我，产生包含消息后跟self的日志消息的副作用。</p>
<p>
				
<code class="code">oclType() : OclSelf[1]</code>
			
</p>
<p>计算<code class="code">self</code>当前是实例的最派生类型。如果<code class="code">self</code>是多重分类类型的实例，则返回是当前分类的最派生类型，该类型在实例传递给OCL时建立，或者由<code class="code">oclAsType()</code>调用重新建立。
			</p>
<p>
				
<code class="code">oclTypes() : Set(OclSelf[*|?])</code>
			
</p>
<p>评估所有最自派的类型，其中<code class="code">self</code>是一个实例。从返回<code class="code">oclTypes()</code>是通常等同于从<code class="code">oclType()</code>除非<code class="code">self</code>是乘法分类类型的一个实例。
			</p>
<p>
				
<code class="code">toString() : String[1]</code>
			
</p>
<p>返回<code class="code">self</code>的字符串表示形式。
			</p>
</div>
</body>
</html>