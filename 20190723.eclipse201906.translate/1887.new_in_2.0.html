<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" gtc:encodedoriginal="PCFET0NUWVBFIEhUTUwgUFVCTElDICItLy9XM0MvL0RURCBIVE1MIDQuMCBUcmFuc2l0aW9uYWwvL0VOIj4=">
<html >
<head>
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/nn.css">
	<title>OTDT 2.0  - 新的和值得注意的</title>
</head>
<body >
<h1>OTDT 2.0  - 新的和值得注意的</h1>
<div class="navigation"><i>自0.7.1发布以来的变化</i></div>
<div style="width:40%;padding:2px;background-color:#707070"><div style="text-align:justify;background-color:#def4fe;padding:3px">请注意，2.0.0版本的里程碑名为0.8.0M <i>x</i> 。版本号的开关在0.8.0M7和2.0.0 RC1之间进行，以准备项目从孵化状态毕业。
</div></div>
<div class="navigation">在此页面上： <!--a href="#metrics">&bull; Metrics Plug-in</a--> <!--a href="#configuration">&bull; Configuration</a--> <a href="#views">•视图/对话框</a> <a href="#assist">•内容辅助</a> <a href="#refactor">•重构</a> <!--a href="#formatting">&bull; Formatting</a>
<a href="#debug">&bull; Run/Debug</a--> <a href="#language">•语言</a> <!--a href="#api">&bull; API</a--> <a href="#compiler">•编译器</a> <!--a href="#otre">&bull; Runtime</a>  
<a href="#otequinox">&bull; OT/Equinox</a-->
</div>
<table cellpadding="10" cellspacing="0" width="100%">
  <colgroup>
  <col width="20%">
  <col width="80%">
  </colgroup>
  <tbody>
<td><!--
  <tr><td colspan="2" id="NAME"><h2>HEADING</h2></td></tr>
  <tr>
    <td><p align="right"><b>DESC</b><br>
        <span class="since">since&nbsp;0.7.1</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/308029">308029</a></p></td>
    <td><p>
    		
    	</p>
    	<p><img alt="TEXT" src="../images/screenshots/NN07/.png"></p>
    	<p></p>
    </td>
  </tr>
  <div class="listbox"><div class="listing"><pre><code class="keyword">public team class</code> <font color="blue">MyTeam</font> {
}</pre></div></div>
-->
  <tr></tr></td><td colspan="2" id="views"><h2>视图和对话框</h2></td>
   <tr>
    <td><p align="right"><b>编译器首选项页面已清理完毕</b><br>
        <span class="since">从0.8.0M5开始</span><br>
        <a class="buglink" title="清理OT / J编译器首选项页面" href="https://bugs.eclipse.org/335739">335739</a></p></td>
    <td><p>随着JDT UI的最新改进，OT / J编译器选项的首选项页面已经过改进。现在，该页面构成了每组问题的可扩展部分。此外，还支持在选项树中进行增量搜索。禁用“范围关键字”的选项显然从未使用过，并已从首选项中删除。
    	</p>
    	<p><img alt="OT / J编译器首选项" src="../images/screenshots/NN08/CompilerPreferences.png"></p>
    	<p></p>
    </td>
   </tr>
  
  <tr><td colspan="2" id="assist"><h2>内容辅助</h2></td></tr>
   <tr>
    <td><p align="right"><b>创建角色方法quickfix</b><br>
        <span class="since">从0.8.0M4开始</span><br>
        <a class="buglink" title="生成缺少替换callin方法的Quickfix方法会生成错误的方法" href="https://bugs.eclipse.org/329988">329988</a></p></td>
    <td><p>如果角色类具有其左侧未解析为现有角色方法的callin绑定，则存在用于创建缺少角色方法的quickfix。从0.8.0M4开始，即使callin绑定没有声明任何签名，这个quickfix也会尊重绑定基本方法的签名（请参阅下面的截图中的<b>int</b>参数并返回）：</p>
    	<p><img alt="创建角色方法Quickfix" src="../images/screenshots/NN08/CreateRoleMethodQuickfix.png"></p>
    	<p></p>
    </td>
   </tr>
  <tr><td colspan="2" id="refactor"><h2>重构</h2></td></tr>
   <tr>
    <td><p align="right"><b>提取角色界面</b><br>
        <span class="since">从0.8.0M6开始</span><br>
        <a class="buglink" title="一个角色的提取接口应该创建一个角色接口" href="https://bugs.eclipse.org/339264">339264</a></p></td>
    <td><p>Extract Interface重构中添加了一个新选项：如果封闭类是角色类，则会出现一个新的复选框：</p>
    	<p><img alt="提取为角色界面复选框" src="../images/screenshots/NN08/ExtractInterface1.png"></p>
    	<p>如果选中此框，则不会将新接口创建为顶级类型（通常由JDT完成），而是作为当前封闭团队的角色接口。</p>
    	<p><img alt="提取为角色界面预览" src="../images/screenshots/NN08/ExtractInterface2.png"></p>
    	<p>重构结果如下所示</p>
    	<p><img alt="提取为角色界面结果" src="../images/screenshots/NN08/ExtractInterface3.png"></p>
    </td>
   </tr>
<td><!--
  <tr><td colspan="2" id="debug"><h2>Run / Debug</h2></td></tr>
  <tr><td colspan="2" id="api"><h2>API</h2></td></tr>
-->
    <tr></tr></td><td colspan="2" id="language"><h2>语言</h2></td>
  <tr>
    <td><p align="right"><b>Java 7支持</b><br>
        <span class="since">自2.0.1RC1起</span><br>
        <a class="buglink" title="升级到Java7" href="https://bugs.eclipse.org/353894">353894</a></p></td>
    <td><p>从2.0.1 RC1开始，OT / J已与Java 7集成，即OT / J编译器还支持<a href="http://www.eclipse.org/jdt/ui/r3_8/Java7news/whats-new-java-7.html">Java 7中引入的</a>所有<a href="http://www.eclipse.org/jdt/ui/r3_8/Java7news/whats-new-java-7.html">新功能</a> 。
    	</p>
    </td>
  </tr>
   <tr>
    <td id="bug326969"><p align="right"><b>优先购买者之间的优先权</b><br>
        <span class="since">从0.8.0M3开始</span><br>
        <a class="buglink" title="[编译器]在不同的tsupers之间实现改变的优先级" href="https://bugs.eclipse.org/326969">326969</a></p></td>
    <td><p>以前， <a class="otjldlink" href="http://www.objectteams.org/def/1.3/s1.html#s1.5.e">OTJLD§1.5（e）的</a>第一句和第二句之间不一致。第一句定义了<code class="keyword">super</code>和<code class="keyword">tsuper</code>之间的一般优先<code class="keyword">tsuper</code> ，它将保持不变。但是，使用此示例演示了不同tsupers之间的优先级：</p><div class="listbox"><div class="listing"><pre><code class="keyword">public team class</code> <font color="blue">Team0</font> {
   <code class="keyword">protected team class</code> <font color="darkblue">InnerTeamA</font> {
       <code class="keyword">protected class</code> <b>Role</b> {
           <code class="keyword">public void</code> rm() { ... }
       }
       <code class="keyword">public void</code> tm() { ... }
   }
   <code class="keyword">protected team class</code> InnerTeamB <code class="keyword">extends</code> <font color="darkblue">InnerTeamA</font> {
       <code class="keyword">protected class</code> <b>Role</b> {
           <code class="keyword">public void</code> rm() { ... }
       }
       <code class="keyword">public void</code> tm() { ... }
   }
}
<code class="keyword">public team class</code> <font color="blue">Team1 <code class="keyword">extends</code> Team0</font> {
   <code class="keyword">protected team class</code> <font color="darkblue">InnerTeamA</font> {
       <code class="keyword">protected class</code> <b>Role</b> {
           <code class="keyword">public void</code> rm() { ... }
       }
       <code class="keyword">public void</code> tm() { ... }
   }
   <code class="keyword">protected team class</code> <font color="darkblue">InnerTeamB</font> <code class="keyword">extends</code> <font color="darkblue">InnerTeamA</font> {
       <font color="green">// details inherited from Team1.InnerTeamA and Team0.InnerTeamB</font>
   }
}
</pre></div></div>在<code>Team1.的实例上调用<code>tm()</code>时<code>Team1.InnerTeamB</code>两个实现是执行的候选者：<ul>
			<li><code>TEAM1。InnerTeamA.tm（）</code></li>
			<li><code>Team0。InnerTeamB.tm()</code> ，</li></ul><a class="otjldlink" href="http://www.objectteams.org/def/1.3/s1.html#s1.5.e">OTJLD§1.5（e）</a> <code>Team0.选择<code>Team0.InnerTeamB</code> 。<br>相应地，在<code>Team1.的实例上调用<code>rm()</code>时<code>Team1.InnerTeamB.R</code>两个实现是执行的候选者：<ul> 
			<li><code>TEAM1。InnerTeamA.Role.rm（）</code></li>
			<li><code>Team0。InnerTeamB.Role.rm()</code> ，</li></ul><a class="otjldlink" href="http://www.objectteams.org/def/1.3/s1.html#s1.5.e">OTJLD§1.5（e）</a>现在选择<code>Team0.InnerTeamB.Role</code> ，与上述一致。
    	
    </td>
  </tr>
   <tr>
    <td id="bug338582"><p align="right"><b>避免角色缓存</b><br>
        <span class="since">从0.8.0M6开始</span><br>
        <a class="buglink" title="通过避免角色缓存来考虑优化" href="https://bugs.eclipse.org/338582">338582</a></p></td>
    <td><p>已经观察到，在团队的内部缓存中维护大量角色可能对程序性能产生重大影响（在一个特定类型的100000个角色中观察到）。在角色身份不相关的情况下，添加了一种新的微调方法。现在可以使用<code>@Instantiation(ALWAYS)</code>标记角色类，这意味着此角色类的每个提升操作将立即创建新的角色实例，而无需咨询角色缓存。实际上，这些角色永远不会存储在任何内部缓存中。请阅读<a href="http://www.objectteams.org/def/1.3/s2.html#s2.3.1.d">OTJLD§2.3.1（d）中</a>讨论的含义。
   		</p>
    </td>
  </tr>
   <tr>
    <td id="bug337413"><p align="right"><b>处理解除问题</b><br>
        <span class="since">自2.0RC1起</span><br>
        <a class="buglink" title="考虑将LiftingFailedException更改为已检查的异常" href="https://bugs.eclipse.org/337413">337413</a></p></td>
    <td><p>每当提升失败时（由于角色绑定歧义或抽象相关角色）， <code>LiftingFailedException</code>从Object Teams运行时抛出<code>LiftingFailedException</code> 。此异常现已更改为已检查的异常，以警告客户端有问题的代码可能出现故障。后果在新的<a class="otjldlink" href="http://www.objectteams.org/def/1.3/s2.html#s2.3.5">OTJLD§2.3.5</a>部分中定义。
   		</p>
   		<p>编译器现在有两种通用方式来表示提升问题：</p><ul>
   			<li>未处理的异常LiftingFailedException</li>
   			<li>不安全的callin映射，因为提升到角色{0}可能会因...而失败</li>
   			</ul>
   			<strong>如果没有给出这些消息，则可以认为提升是安全的。</strong> 
   		
   		<p>提升问题的应用程序代码可以选择不同的策略：</p><ul>
   			<li>避免绑定角色的抽象：<ul><li>添加记录问题的方法体。<br>好处：实际上会检测到意外情况。</li>
   				<li>删除抽象方法并要求客户端转换为特定的角色类型。<br>好处：在提升产生意外结果的情况下，客户现在可以明确地处理潜在的<code>ClassCastException</code> 。</li>
  				</ul></li>
  			<li>声明提升的团队方法可以选择声明<code>LiftingFailedException</code><br>好处：客户端被警告失败的可能性，必须处理意外情况。</li>
			<li>具有不安全提升的Callin绑定可能在特殊情况下通过使用<code>@SuppressWarnings("hidden-lifting-problem")</code><br>好处：角色的所有者必须明确声明他/她知道callin绑定不会因提升问题而触发的可能性。</li>
			<li>修改角色层次结构以避免抽象相关角色和潜在的约束歧义。</li>
			</ul>  					
   		
    </td>
  </tr>
  <tr><td colspan="2" id="compiler"><h2>编译器</h2></td></tr>
  <tr>
    <td><p align="right"><b>写解封装的严重性</b><br>
        <span class="since">从0.8.0M5开始</span><br>
        <a class="buglink" title="在“set”callout-to-field中单独调整解封装的严重性" href="https://bugs.eclipse.org/335523">335523</a></p></td>
    <td><p>当角色使用带有解封装的字段的标注<code class="keyword">set</code> ，这可能被认为比相应的<code class="keyword">get</code>访问更严重。因此，编译器现在支持两种问题的单独可配置性。
    	</p>
    	<p><img alt="标注不同严重程度的字段" src="../images/screenshots/NN08/CalloutToFieldSeverity.png"></p>
    	<p></p>
    </td>
  </tr>
  
<td><!--
  <tr><td colspan="2" id="otre"><h2>Object Teams Runtime Environment</h2></td></tr>
-->
</td></tbody></table>
</body>