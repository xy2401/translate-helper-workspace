<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>树</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingTreeEditors">指定树编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingTreeEditors">指定树编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#tree_description">树的描述</a>
						<ol style="list-style:disc">
							<li>
								<a href="#tree_tools">树工具</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#mappings">树项映射</a>
						<ol style="list-style:disc">
							<li>
								<a href="#item_style">物品风格</a>
							</li>
							<li>
								<a href="#item_tools">物品工具</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>树是一种表示，它为您的数据提供分层视点。它可以以清晰简洁的方式提供大量信息，并且当用户扩展树元素以“挖掘”模型时，可以特别有用地逐步显示关于模型的更多和更详细的信息。</p>
		<p>树木可能是Sirius中最容易定义的表示形式。不要犹豫，定义小树描述，甚至只读，以提供数据的替代和合成视点，如类型层次结构，元素之间的依赖关系等。</p> 
		<img border="0" src="./images/tree_description_editor.png">
<em>
<ul>
<img src="images/tricks.png" style="display:inline;margin:0px;padding:0px"> <em>使用<img src="images/questionMarque.png" style="display:inline;margin:0px;padding:0px">用于访问可用字段工具提示的图标：</em>
<ul>
			<li> 
		<b>Id</b>字段：此元素的标识符。必须是独特的。更改此标识符将破坏引用旧标识符的现有用户模型。</li>
			<li> 
		<b>标签</b>字段：用于向最终用户显示此标签的标签。</li>
			<li> 
		<b>域类</b>字段：节点表示的元素的类型。</li>
			<li> 
		<b>语义候选者表达</b>字段：<ul>
			    <li>预期的返回类型： <code>Collection&lt;EObject&gt;</code>或EObject。</li>
			        <li>可变变量：<ul>
		    		    <li>containerView：ecore。EObject |当前DTreeElement的容器（如果容器不为null，则变量可用）。</li>
			    	    <li>观点：天狼星。DTreeElement |当前的DTreeElement。</li>
				        <li>容器：ecore。EObject | $ containerView的语义目标（如果它是DSemanticDecorator）。</li>
			        </ul>
			    </li>
			    </ul>
			</li>
</ul>
</ul>
</em>
		<p>
			<strong>注意</strong> ：图表中存在的图层，过滤器和映射导入等高级功能目前不适用于树。
		</p>
		<h2 id="tree_description">树的描述</h2>
		<p>与其他类型的Sirius表示类似，通过在<a href="../../Glossary.html#VSM"><em>视点规范模型中</em></a>创建<em>树描述</em>元素及其子元素来配置<em>树</em> 。
		</p>
		<p><em>树描述</em>具有强制<em>Id</em> ，在其所属的视点的上下文中必须是唯一的，并且是可选的<em>Label</em> 。<em>Id</em>在内部用于标识树的类型，并且必须在不同版本的描述中保持稳定（或者它将使用旧<em>Id</em>创建的树不可用）。<em>标签</em>在UI中使用，并且对最终用户可见。它可以在不影响现有表示文件的情况下进行更改。如果未指定<em>Label</em> ，则在UI中使用<em>Id</em> 。</p>
		<p><em>树描述</em>的强制<em>Domain Class</em>属性是由<em>树</em>表示的语义元素的类型。在<em>模型资源管理器中</em> ，最终用户将能够在此类型的语义元素上创建此树的新实例（假设在<em>建模项目中</em>启用了相应的视点）。域类名称的语法可以是基本名称，如<code>Class</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml.Class</code> ，或完全限定的URI，如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Class</code> 。</p>
		<p>默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新树。您可以使用“ <em>前置条件表达式”</em> （在“ <em>高级”</em>类别中可用）来更改此值。如果指定了这样的表达式，则将在用户选择的语义元素的上下文中对其进行求值，并且仅当表达式返回<code>true</code>时，用户才能够在此元素上创建新树。
		</p>
		<p>可以使用<em>Title表达式</em>指定新创建的树的默认标题， <em>Title表达式</em>在创建树的语义元素的上下文中计算，并应返回字符串。如果未指定表达式，则默认标题是树描述的标签（如果未设置<em>Label，</em>则为其<em>ID</em> ），前缀为字符串<code>"new "</code> （例如， <code>new Class Hierarchy</code> ）。
		</p>
		<p>建议将<em>树描述</em>明确地与它将表示的语义元素的元模型相关联。您可以在“ <em>树描述”</em>的“ <em>元模型”</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p>最后， <em>初始化</em>和<em>显示启动</em>标志控制是否在没有用户干预的情况下自动创建和/或打开树实例。如果设置了<em>Initialization</em> ，则当启用包含此树描述的视点时，将在所有兼容的语义元素上自动创建此树描述的实例。如果在set中<em>启动</em>时<em>显示</em> ，那么当打开包含此树描述实例的建模项目时，它们将被打开：如果只存在一个这样的表示，它将自动打开;如果有多个，将出现一个对话框，允许用户选择打开哪一个。
		</p>
		<p>定义树的主要概念是：</p>
		<ul>
			<li>
				<em>树项目</em>映射，描述将出现在此树上的元素，以及它们如何映射到它们所代表的基础语义元素;</li>
			<li>
				<em>样式</em> ，描述这些表示元素的图形外观;</li>
			<li>
				<em>工具</em> ，描述最终用户可以对树及其项目执行的操作及其对相关语义元素的影响。
			</li>
		</ul>
		<h3 id="tree_tools">树工具</h3>
		<p>可以在树编辑器上定义的一些工具直接在顶级<em>Tree Description</em>元素中指定：</p>
		<ul>
			<li>
				<em>创建</em> ：直接包含在<em>树描述</em>中的<em>创建</em>工具用于创建根树项。它们通过主Eclipse工具栏中的组合按钮提供给最终用户。要配置它，只需选择工具将在<em>Mapping</em>属性中创建的树项类型，并使用常规模型操作指定工具的行为。
			</li>
			<li>
				<em>删除工具</em> ：当直接在<em>树描述中</em>定义时， <em>删除工具</em>指定当用户在树的根处（即在编辑器内部而不是在现有树项目上）删除元素时会发生什么。<em>Drag source</em>属性指示工具是否接受从树表示（值<em>树</em> ）， <em>模型资源管理器</em>视图（值<em>模型</em> ）或两者拖动的元素。如果检测到这样的drop并且<em>Precondition的</em>计算结果为<code>true</code> ，则执行drop工具的主体，其中<code>element</code>变量指向被删除的语义元素， <code>newContainer</code>是删除它的语义元素（在这种情况下是树的语义元素）。
				<i>警告</i> ：如果选择“ <em>模型”</em>或“ <em>两者”</em>作为源，则必须准备好工具以接受可在“ <em>模型资源管理器”</em>视图中出现的任何类型的源元素，包括与为工具指定的源映射无关的元素。使用前提条件检查被拖动元素的性质（可通过<code>element</code>变量获得）以禁用工具不支持的工具源元素。
			</li>
			<li>
				<em>树创建</em> ：此工具可用于从现有树项创建（和打开）新树。它将在兼容树项目的“ <em>导航”</em>上下文菜单中供最终用户使用。要配置工具，只需在<em>Mappings</em>属性中选择工具应显示哪些树项（如果需要，可以使用<em>Precondition</em>表达式更精确），并选择使用<em>Tree Description</em>属性创建哪种树。通常，将在由用户调用工具的树项所表示的语义元素上创建新树表示。有时您希望工具出现在一个元素上，但在另一个元素上创建一个表示。在这种情况下，使用“ <em>浏览”表达式</em> （在“ <em>高级”</em>类别中）从所选元素导航到实际应在其中创建新树的元素。最后，在调用工具时，将执行您在工具正文中指定的任何操作;您可以使用它来初始化所表示的模型的内容。
			</li>
			<li>
				<em>树导航</em> ：此工具与前一个工具非常相似。唯一的区别是它允许用户导航到现有树而不是创建新树。如果存在此类工具，则项目上的“ <em>导航”</em>上下文菜单将包含已在所选元素上存在的每个对应树的条目（或使用“ <em>浏览”表达式</em>从所选元素可访问）。您可以指定要在菜单项中使用的<em>导航名称表达式</em> （ <em>高级</em>类别），而不是使用现有树的标题。这有助于更明确地说明当前元素与目标树之间的关系。
			</li>
		</ul>
		<h4 id="tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h2 id="mappings">树项映射</h2>
		<p>树木本质上是递归的。它们的内容使用<em>Tree Item</em>映射的单个概念来指定，该映射可以递归地组成。<em>树描述</em>包含<em>树项目</em>映射，它定义哪些元素将出现在树的顶层，而每个<em>树项目</em>映射可以包含定义其自己的直接内容的子映射。如果元素（树或树项映射）包含多个子映射，则元素的内容将按映射的顺序出现：首先是第一个映射的所有实例，然后是第二个映射的实例，等等。</p>
		<p><em>树项目</em>映射由<em>域类</em> ， <em>语义候选表达式</em>和可选的<em>前提条件表达式</em> （在<em>高级</em>类别中）定义。<em>语义候选表达式</em>指示在语义模型中查找应该由映射表示的元素的位置。表达式在父级语义元素的上下文中进行计算（父级是树本身或父项）。它应该返回一组语义元素。只保留那些作为指定<em>域类</em>实例并且还验证可选<em>Precondition表达式</em>的实例，并将其实际表示为此映射的实例。因此与每个树项关联的语义元素称为项的<em>目标</em>元素。
		</p>
		<p>您可以通过定义<em>关联元素表达式</em> （在<em>高级类别中</em> ）将更多语义元素与项目相关联，该<em>关联元素表达式</em>在目标上下文中进行评估，并且可以返回更多语义元素。目标元素或其中一个关联元素的任何更改都将自动触发树项的刷新。
		</p>
		<p><em>树项目</em>映射可以<em>专门化</em>另一个映射，在这种情况下，它将继承所有未指定显式值的专用映射属性。
		</p>
		<p><em>树项目</em>映射可以<em>重用</em> （参见<em>Imports</em>类别）现有映射（包括其自身）作为子映射。效果与重用的映射创建为父项的子项完全相同。然而，因为映射可以重用自身或其父映射之一，所以这允许创建无限深度的树（或者至少不是先验的有界）。
		</p>
		<p>仅当用户展开父项时，才会延迟创建树项。这意味着如果您定义使用昂贵的操作来创建的子映射，则只有当用户实际“挖掘”树到相应的详细级别时才会支付成本。这也意味着通过重用，您可以创建具有潜在无限深度的树（就像用户选择扩展它们一样深），而不会冒无限循环的风险。但请注意，一旦创建了树项，如果父项折叠，它们就不会消失。只有在用户明确删除它们时才会删除它们。</p>
		<p>树项的实际外观由其<a href="#item_style">样式</a>定义，而其行为由与其关联的<a href="#item_tools">工具</a>定义。
		</p>
		<h3 id="item_style">物品风格</h3>
		<p>项目的外观由相应树项映射中定义的一个或多个<em>Style</em>元素控制。每个树项映射<em>必须只</em>包含一个默认样式（在创建映射本身时自动创建），并且<em>可能</em>包含一个或多个<em>条件样式</em> 。
		</p>
		<p>项目的样式由<em>Label表达式组成</em> ，在项目的语义目标的上下文中进行评估，并且应该返回要为项目显示的文本，以及用于控制字体，样式，颜色（文本和文本）的几个配置属性。它的背景）和项目的图标。为元素<em>显示</em>的默认图标（如果设置了<em>显示图标</em> ）是在项目的目标元素的语义元模型中定义的<em>图标</em> 。您可以使用“ <em>图标路径”</em>属性（在“ <em>高级”</em>类别中）指定其他属性。如果您有多个项目表示同一语义元素的不同方面，从而共享相同的目标，则此功能尤其有用。
		</p>
		<p>
			<em>树项目</em>映射可以有一个或多个<em>条件样式</em> 。它们是具有与上述相同属性的普通样式元素，但包含在定义布尔表达式的<em>条件样式</em>元素中。如果项目映射包含此类样式，则对于映射的每个实例，将首先按其定义的顺序尝试条件样式。使用条件为项目目标返回<code>true</code>的第一个样式（并且不测试其余样式）。如果不应用任何条件样式，则使用默认样式。请注意，由于条件是按照定义的顺序进行测试的，因此您应该从最可能优化性能的顺序对它们进行排序。
		</p>
		<h3 id="item_tools">物品工具</h3>
		<p>树项的行为由与其映射关联的工具定义。应用于树项映射的工具只是在映射本身内创建。他们可以：</p>
		<ul>
			<li>
				<em>创建工具</em> ，用于创建新的树项。映射可以包含几个这样的工具。如果工具的（可选） <em>前提条件</em>适用于实例的目标，它们将出现在映射实例的上下文菜单中。创建工具必须指定它将创建的<em>映射</em>类型。使用所有标准模型操作，在工具的主体中定义创建工具的实际行为。
			</li>
			<li>
				<em>删除工具</em> ，用于删除元素。如果映射没有明确定义删除工具，则<em>删除树项</em>操作的默认行为是从语义模型中删除项的语义<em>目标</em>和所有<em>关联元素</em> 。如果需要特定行为，则必须显式创建“ <em>删除”工具</em>并描述工具主体中的行为。如果要防止删除元素，则必须创建“ <em>删除”工具</em>并将“ <em>前提条件”</em>设置为对不应删除的元素返回<code>false</code> 。
			</li>
			<li>
				<em>直接编辑工具</em> ，用于允许最终用户直接编辑树项的标签（通过双击或按下树项目上的<em>F2</em>或<em>返回</em> ）。它指定了如何解释新标签值以及应用于模型元素的更改。<em>Edit Mask</em>元素（包含在工具中）用于解析用户输入的新标签值，并选择此标签的一部分作为编辑操作主体的输入变量。掩码可以包含<code>{N}</code>形式的子串，其中<em>N</em>是数字。与这些子字符串对应的新标签值的部分将作为名为<code>argN</code>变量提供。例如，使用编辑掩码<code>{0}:{1}</code>和由<code>attr : EString</code>用户输入的输入字符串，工具的主体将执行变量<code>arg0</code>设置为<code>attr␣</code> ， <code>arg1</code>设置为<code>␣EString</code> 。
			</li>
			<li>
				<em>删除工具</em> ：在<em>树项目</em>映射中定义时， <em>删除工具</em>指定当用户将元素放到映射实例上时会发生什么。<em>Drag source</em>属性指示工具是否接受从树表示（值<em>树</em> ）， <em>模型资源管理器</em>视图（值<em>模型</em> ）或两者拖动的元素。如果检测到这样的drop并且<em>Precondition的</em>计算结果为<code>true</code> ，则执行drop工具的主体，其中<code>element</code>变量指向被删除的语义元素， <code>newContainer</code>是删除它的语义元素（在这种情况下是树的语义元素）。
			</li>
			<li>
				<em>弹出菜单</em>用于向与任何树项关联的上下文菜单添加新菜单和操作。
			</li>
		</ul>
	</body>
</html>