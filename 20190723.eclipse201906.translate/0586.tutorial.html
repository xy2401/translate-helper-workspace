<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>教程</title>
		<style type="text/css">
			.info {border: 1px solid #3c78b5;background-color: #D8E4F1;margin: 20px;padding: 0px 6px 0px 6px;}
			.note {border: 1px solid #F0C000;background-color: #FFFFCE;margin: 20px;padding: 0px 6px 0px 6px;}
			.panel {border: 1px solid #ccc;background-color: #FFFFCE;margin: 10px;padding: 0px 6px 0px 6px;}
			.tip {border: 1px solid #090;background-color: #dfd;margin: 20px;padding: 0px 6px 0px 6px;}
			.warning {border: 1px solid #c00;background-color: #fcc;margin: 20px;padding: 0px 6px 0px 6px;}
</style>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/bootstrap.css">
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/custom.css">
	</head>
	<body >
		<h1 id="EMF_Compare_tutorial">EMF比较教程</h1>
		<p>本教程的目的是指导您完成EMF比较的基本机制。本教程的第一部分将向您介绍如何设置环境。第二个将帮助您了解EMF Compare检测到的主要差异。第三部分将向您解释EGit如何与EMF进行互操作比较以比较git存储库中的模型。</p>
		<h2 id="Installation">安装</h2>
		<p>EMF Compare是Eclipse版本系列的一部分。您将在平台的eclipse版本更新中找到所需的一切。您还可以在下载部分的<a href="http://www.eclipse.org/emf/compare/" title="http://www.eclipse.org/emf/compare/">EMF Compare网站</a>上找到更新的版本。
		</p>
		<p>为了安装EMF比较：</p>
		<ul>
			<li>打开安装向导：帮助&gt;“安装新软件..”。</li>
			<li>选择要从中安装EMF Compare的更新站点。在这个例子中，我们使用的是Luna eclipse版本更新站点：<ul>
					<li>
						<a href="http://download.eclipse.org/releases/luna">http://download.eclipse.org/releases/luna</a>
					</li>
				</ul>
			</li>
			<li>检查名为“EMF Compare IDE UI”的功能。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Install.png">
		</p>
		<ul>
			<li>点击下一步。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Install2.png">
		</p>
		<ul>
			<li>点击下一步。</li>
			<li>阅读并接受许可协议的条款。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Install3.png">
		</p>
		<ul>
			<li>点击完成。</li>
			<li>安装完成后，单击“是”以重新启动平台。</li>
		</ul>
		<h2 id="Tutorial">教程</h2>
		<h3 id="Set_up">建立</h3>
		<h4 id="Install_custom_ExtLibrary_plugins">安装自定义ExtLibrary插件</h4>
		<p>本教程基于众所周知的ExtLibrary元模型（可从EMF示例中获得）。但是，为了满足本教程的需要，我们已经定制了这些插件。我们有：</p>
		<ul>
			<li>设置XMI id序列化以创建模型，其中每个元素将具有唯一ID。EMF Compare可以比较具有id的模型和没有id的模型。如果模型中没有可用的ID，则EMF Compare使用启发式来定义两个元素是否匹配。</li>
			<li>删除了extendedLibrary内容类型，以解释如何在平台中进行设置。</li>
			<li>添加了额外的图标，使其看起来更漂亮。</li>
		</ul>
		<h5 id="Import_the_plugins">导入插件</h5>
		<p>这些插件托管在<a href="http://git.eclipse.org/c/emfcompare/org.eclipse.emf.compare.git" title="http://git.eclipse.org/c/emfcompare/org.eclipse.emf.compare.git">EMF Compare存储库中</a> 。要在工作区中导入这些插件，您可以按照<a href="http://wiki.eclipse.org/EGit/User_Guide#Starting_from_existing_Git_Repositories" title="http://wiki.eclipse.org/EGit/User_Guide#Starting_from_existing_Git_Repositories">EGit教程进行操作</a> 。以下是主要步骤：</p>
		<ul>
			<li>使用以下URL克隆EMF比较存储库（有关详细信息，请参阅<a href="http://wiki.eclipse.org/EGit/User_Guide#Cloning_Remote_Repositories" title="http://wiki.eclipse.org/EGit/User_Guide#Cloning_Remote_Repositories">克隆存储库</a> ）：<ul>
					<li>
						<a href="http://git.eclipse.org/gitroot/emfcompare/org.eclipse.emf.compare.git">http://git.eclipse.org/gitroot/emfcompare/org.eclipse.emf.compare.git</a> 
					</li>
				</ul>
			</li>
			<li>将所需的插件导入工作区：<ul>
					<li>打开“Git Repositories”视图（如果尚未打开）：Window&gt;“Show view”&gt;“Other ...”。</li>
					<li>选择“Git存储库”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tutorial_Git_Repo_View.png">
							</dd>
						</dl>
					</li>
					<li>选择EMF Compare存储库的克隆。</li>
					<li>打开上下文菜单，然后单击“Imports Projects ...”<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Import_Project_Wizard.png">
							</dd>
						</dl>
					</li>
					<li>选择“tutorial”文件夹，然后单击“下一步”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Import_Project_Wizard1.png">
							</dd>
						</dl>
					</li>
					<li>检查是否已检查3个必需的插件：<dl>
							<dd>
								<dl>
									<dd>
										<img border="0" src="../images/EMF_Compare_Tuto_Import_Project_Wizard2.png">
									</dd>
								</dl>
							</dd>
						</dl>
					</li>
					<li>单击“完成”。</li>
				</ul>
			</li>
		</ul>
		<p>最后，您的工作空间应如下所示：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Workspace.png">
		</p>
		<h5 id="Launch_runtime_platform">启动运行时平台</h5>
		<p>既然您已在工作区中获得所需，那么您需要创建一个运行时平台。运行时平台基本上是一个基于您当前平台构建的新eclipse平台，其中包含工作区的新插件。为此：</p>
		<ul>
			<li>在工作区中选择一个插件。</li>
			<li>单击工具栏中的播放按钮<img border="0" src="../images/EMF_Compare_Tuto_Run_Button.png"> 。如果工具栏中没有此按钮，则可能需要切换到Java透视图。
			</li>
			<li>选择“Eclipse Application”，然后单击“确定”。<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Runtime_Platform.png">
					</dd>
				</dl>
			</li>
			<li>应该开始一个新的eclipse平台。这是您的运行时平台。</li>
		</ul>
		<p>
			<b>以下所有说明都应在运行时平台上完成。</b> 
		</p>
		<h4 id="Associate_EXTLibrary_models_with_EMF_Compare_Content_type">将EXTLibrary模型与EMF比较内容类型相关联</h4>
		<p>EMF比较编辑器基于内容类型机制。基本上，如果当前资源的Content类型是以下类型之一（或从其中一个继承），则将在比较中使用EMF Compare：</p>
		<ul>
			<li>XMI内容类型</li>
			<li>Ecore内容类型</li>
			<li>EMF比较内容类型</li>
		</ul>
		<p>您还可以使用“内容类型”首选项页面将模型文件与EMF比较内容类型相关联。</p>
		<p>这是本教程的第一步。为此：</p>
		<ul>
			<li>打开首选项页面：Window&gt; Preferences。</li>
			<li>选择“内容类型”首选项页面：常规&gt;内容类型。</li>
			<li>选择EMF比较项目。</li>
			<li>单击“添加...”按钮。</li>
			<li>编写匹配所有extlibrary文件的模式：“* .extlibrary”。</li>
			<li>单击“确定”。</li>
		</ul>
		<p>
			<img border="0" src="../images/Content_Types_Preference_Page.png">
		</p>
		<p>如果您使用的是基本EXTLibrary插件（从示例中导入），则此步骤不是必需的，因为已定义内容类型并且它继承自XMI内容类型。但是，这些插件不会生成ID，因此我们不建议您使用它们。</p>
		<h3 id="Tutorial_2">教程</h3>
		<h4 id="Context">上下文</h4>
		<p>如果您已正确执行上述步骤，则应具有以下环境：</p>
		<ul>
			<li>运行时安装的自定义ExtLibrary元模型</li>
			<li>将.extlibrary文件与EMF比较内容类型相关联</li>
			<li>使用EMF比较默认首选项</li>
		</ul>
		<h4 id="Compare_with_history_.282-way_comparison.29">与历史比较（双向比较）</h4>
		<p>现在一切都已建立，我们将完成EMF Compare检测和处理的所有主要差异。为此，我们将逐步创建库模型。每次我们修改库时，我们都会将它与之前的版本进行比较，以了解EMF Compare如何处理每个差异。</p>
		<h5 id="Create_a_library_model">创建库模型</h5>
		<p>首先，我们需要创建我们的库模型。为此：</p>
		<ul>
			<li>例如，创建一个名为“TutorialModel”的项目。</li>
			<li>创建一个extlibrary模型：<ul>
					<li>单击：文件&gt;新建&gt;其他。</li>
					<li>选择EXTLibrary模型。
						<dl>
							<dd>
								<img border="0" src="../images/Create_Extlibrary_Model.png">
							</dd>
						</dl>
					</li>
					<li>点击下一步。</li>
					<li>例如，将其名称设置为“TutorialModel.extlibrary”。
						<dl>
							<dd>
								<img border="0" src="../images/Create_Extlibrary_Model_Set_Name.png">
							</dd>
						</dl>
					</li>
					<li>点击下一步。</li>
					<li>以root身份选择Library元素。
						<dl>
							<dd>
								<img border="0" src="../images/Create_Extlibrary_Model_Root_Element.png">
							</dd>
						</dl>
					</li>
					<li>点击完成。</li>
				</ul>
			</li>
		</ul>
		<p>您的模型现已打开。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Model_Creation.png">
		</p>
		<h5 id="Create_a_new_book">创建一本新书</h5>
		<p>我们现在要用你的第一本书填满你的图书馆。</p>
		<ul>
			<li>在打开的编辑器中选择库元素（在此示例中为TutorialModel.extlibrary）。</li>
			<li>打开上下文菜单。</li>
			<li>选择“新孩子”&gt;“书籍”。</li>
			<li>保存你的模型。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Creation.png">
		</p>
		<h6 id="Compare_with_previous_version">与以前的版本比较</h6>
		<p>现在我们的库包含一本书，让我们将它与我们模型的先前状态进行比较：</p>
		<ul>
			<li>在项目资源管理器（或包浏览器）视图中选择模型文件。</li>
			<li>打开上下文菜单。</li>
			<li>选择“比较”&gt;“本地历史记录...”。</li>
		</ul>
		<p>
			<img border="0" src="../images/Compare_With_Local_History.png">
		</p>
		<p>历史视图现已开放。</p>
		<p>
			<img border="0" src="../images/Local_History_View.png">
		</p>
		<p>此视图将显示Eclipse为您保存的文件的每个状态。每次保存模型时，都会显示一个新条目。以粗体显示的项目是文件的当前版本。在本教程的第一部分中，您必须将模型的当前版本与其先前版本进行比较。</p>
		<p>为此，请双击粗体条目下方的条目。</p>
		<p>EMF比较编辑器现已打开。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Editor_Tuto_New_Book.png">
		</p>
		<p>这种比较是双向比较。也就是说，比较仅在2个输入之间（文件的当前版本和本地历史记录中的先前版本）。您将在本教程的第二部分中看到，还有一个3向比较。</p>
		<p>我们来看看用户界面。工具栏看起来像这样：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Accept_Reject_Toolbar.png">
		</p>
		<p>当您处于接受/拒绝模式时，将显示此工具栏。当至少一个输入不可写时，该模式被激活。在我们的示例中，您的文件的当前版本可以被修改，而它的先前版本不能（因为它由本地历史记录提供）。在此模式下，您可以接受或拒绝差异。这很明显，但是唯一要修改的资源是模型的当前版本。</p>
		<p>编辑器的顶部填充了“Structure Merge viewer”。在其中，您将找到EMF Compare找到的所有差异的结构化表示。</p>
		<p>在编辑器的底部，您有一个名为“内容查看器”的查看器。此查看器显示输入模型的内容。在左侧，它显示模型当前版本的内容。在右侧，它显示以前版本的内容。</p>
		<p>要全面了解用户界面，请参阅<a href="./../user/user-guide.html#User_Interface_Breakdown" title="。/../user/user-guide.html#User_Interface_Breakdown">用户界面细分</a> 。
		</p>
		<p>现在让我们来看看差异： <img border="0" src="../images/EMF_Compare_Tuto_New_Book_Difference.png">
		</p>
		<p>根据这种差异，您可以找到一些信息：</p>
		<ul>
			<li>“+”叠加图标表示差异是添加（ <a href="./../user/user-guide.html#Signification_of_icons_associated_with_differences" title="./../user/user-guide.html#Signification_of_icons_associated_with_differences">有关</a>更多信息，请参阅<a href="./../user/user-guide.html#Signification_of_icons_associated_with_differences" title="。/../user/user-guide.html#Signification_of_icons_associated_with_differences">与差异关联的图标的含义</a> ）。
			</li>
			<li>括号中的后缀描述了差异的性质和已修改的特征的名称。在这种情况下，差异是功能“Stock”中的添加（修改后的功能不是“书籍”，因为它是派生功能。它是根据“真实”特征“股票”计算的。</li>
		</ul>
		<p>
			<b>在本教程中，除非明确询问，否则不应保存EMF Compare编辑器。目前，如果模型已保存，EMF Compare不允许撤消操作。由于我们将完成所有可能的操作，因此我们将进行大量的撤消操作。</b>
		</p>
		<h6 id="Accept_a_difference">接受差异</h6>
		<p>首先接受我们刚刚创建的修改。为此：</p>
		<ul>
			<li>选择您要接受的差异。
				<ul>
					<li>单击结构合并查看器（顶部查看器）中的差异。双击它以打开与此差异相关的内容合并查看器。</li>
				</ul>
			</li>
			<li>单击“接受”图标<img border="0" src="../images/accept_change.gif"> 。
			</li>
		</ul>
		<p>您的编辑器应如下所示：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Book_Difference_Accepted.png">
		</p>
		<p>差异上出现了一个新的叠加图标。这意味着差异已经合并。您还可以在当前模型版本的内容查看器中注意到该书不再被框架化。这也意味着差异已经合并。</p>
		<h6 id="Reject_a_difference">拒绝差异</h6>
		<p>让我们试着拒绝差异：</p>
		<ul>
			<li>使用键盘快捷键（Ctrl + z）或“文件”菜单（“编辑”&gt;“撤消”）撤消上一操作。</li>
			<li>单击拒绝图标<img border="0" src="../images/reject_change.gif"> 。
			</li>
		</ul>
		<p>您的编辑器应如下所示：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Book_Difference_Rejected.png">
		</p>
		<p>差异图标上的“x”覆盖表示它已被拒绝。在当前模型版本的内容查看器中，该书已经消失。实际上，由于修改已被拒绝，因此使用该对象的先前版本。</p>
		<h5 id="Set_the_name_of_the_book">设置书名</h5>
		<p>我们现在要设置我们刚刚创建的书的名称。这会将属性“Title”的值更改为“Prelude to Foundation”。</p>
		<ul>
			<li>关闭比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>将书名设置为“Prelude to Foundation”。
				<ul>
					<li>选择这本书。</li>
					<li>显示“属性”视图：上下文菜单&gt;显示属性视图。</li>
					<li>填写标题字段。</li>
				</ul>
			</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Setting_Book_Name.png">
		</p>
		<p>现在让我们将它与之前的版本进行比较（参见上一章的解释<a href="#Compare_with_previous_version">与以前的版本比较</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Name_Comparison.png">
		</p>
		<p>根据差异，您会看到叠加层，表明这种差异是一种变化。此差异是功能“标题”上的设置。如果查看当前版本的内容查看器，您将看到该功能的新值，而在之前的版本中，不会显示任何内容。</p>
		<p>如果您接受差异，您会注意到与前一章相同的效果（请参阅<a href="#Accept_a_difference">接受差异</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Name_Accepted.png">
		</p>
		<p>如果您拒绝该差异，则将取消设置该书的名称，因为它尚未在先前版本中设置（请参阅<a href="#Reject_a_difference">拒绝差异</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Name_Rejected.png">
		</p>
		<h5 id="Change_the_category_of_the_book">更改图书的类别</h5>
		<p>我们将定义这本书是一本科幻小说。这会将书籍的“类别”功能的值从其默认值“Mystery”更改为“ScienceFiction”。</p>
		<ul>
			<li>关闭比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>将书的类别更改为ScienceFiction：<ul>
					<li>选择这本书。</li>
					<li>打开属性视图。</li>
					<li>更改“类别”功能的值。</li>
				</ul>
			</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Setting_Book_Category.png">
		</p>
		<p>现在让我们将它与之前的版本进行<a href="#Compare_with_previous_version">比较</a> （参见上一章的解释<a href="#Compare_with_previous_version">与之前的版本比较</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Category_Comparison.png">
		</p>
		<p>在当前版本的内容查看器中，您会看到功能“类别”的新值，而在以前的版本中，将显示默认值。</p>
		<p>接受差异，你明显看到（见<a href="#Accept_a_difference">接受差异</a> ）：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Category_Accepted.png">
		</p>
		<p>拒绝差异以将“类别”功能设置为其默认值（请参阅<a href="#Reject_a_difference">拒绝差异</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Book_Category_Rejected.png">
		</p>
		<h5 id="Fill_the_library_with_employees">向员工填写图书馆</h5>
		<p>为了填补您的图书馆，我们将添加一些员工。</p>
		<ul>
			<li>关闭比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>创建一名员工并将姓氏设置为Chief。</li>
			<li>创建员工并将姓氏设置为Master。</li>
			<li>创建员工并将姓氏设置为Employee。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Fill_Employees.png">
		</p>
		<p>对于此步骤，我们不会与先前版本的模型进行比较。EXTLibrary将人员存储在要素图中。目前，EMF Compare无法正确处理特征映射。功能图比较将集成到下一个Eclipse版本（2015年的Mars）。</p>
		<h5 id="Set_a_manager">设置经理</h5>
		<p>让我们将“员工”的经理设为“酋长”。这会将“员工”的参考“经理”设置为“主管”。</p>
		<ul>
			<li>选择员工“员工”。</li>
			<li>打开“属性”视图。</li>
			<li>使“经理”功能指向“主管”。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Set_Manager_Chief.png">
		</p>
		<p>现在让我们将它与之前的版本进行<a href="#Compare_with_previous_version">比较</a> （参见上一章的解释<a href="#Compare_with_previous_version">与之前的版本比较</a> ）。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Set_Manager_Chief_Comparison.png">
		</p>
		<p>您可以注意到内容查看器中的更改。然而，它与之前的比较略有不同。在内容查看器中，您现在有了一个新的顶部图像。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Top_Image_Reference.png">
		</p>
		<p>这意味着当前差异是非遏制参考。如果您回顾一下<a href="#Compare_with_previous_version">与之前版本</a>的<a href="#Compare_with_previous_version">比较，</a>内容查看器就不一样了，因为所涉及的功能是一个包含引用。
		</p>
		<p>接受这种差异，您将看到与<a href="#Accept_a_difference">接受差异</a>相同的结果类型。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Set_Manager_Chief_Accepted.png">
		</p>
		<p>拒绝这种差异，您将看到与<a href="#Reject_a_difference">拒绝差异</a>相同的结果类型。
		</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Set_Manager_Chief_Rejected.png">
		</p>
		<h5 id="Change_of_manager">经理变更</h5>
		<p>假设“员工”有一份新工作，所以他有一位新经理。我们必须将“Manager”功能从“Chief”更改为“Master”。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>选择员工“员工”。</li>
			<li>将功能“Manager”设置为“Master”。</li>
			<li>保存。</li>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Change_Manager_Master_Comparison.png">
		</p>
		<p>接受更改以将差异标记为已合并。拒绝它将“员工”的经理重置为“酋长”。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Change_Manager_Master_Reject.png">
		</p>
		<h5 id="No_more_manager">没有经理</h5>
		<p>让我们说“员工”已经达到了命令链的顶端。也就是说他没有经理。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>选择员工“员工”。</li>
			<li>取消设置“员工”的“经理”功能。
				<ul>
					<li>打开属性视图。</li>
					<li>选择“经理”字段。</li>
					<li>使用工具栏中的“恢复默认值”按钮。</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Unset_Employee_Manager.png">
		</p>
		<ul>
			<li>保存。</li>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Unset_Employee_Manager_Comparison.png">
		</p>
		<p>区别与<a href="#Set_a_manager">设置经理</a>相反。
		</p>
		<ul>
			<li>接受差异得到：</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Unset_Employee_Manager_Comparison_Accepted.png">
		</p>
		<ul>
			<li>拒绝差异得到：</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Unset_Employee_Manager_Comparison_Rejected.png">
		</p>
		<h5 id="Add_borrowers">添加借款人</h5>
		<p>让我们向公众开放图书馆的大门。我们将把借款人添加到这个图书馆。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>添加一个名为Will Graham的新借款人。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Fill_Borrowers.png">
		</p>
		<p>出于<a href="#Fill_the_library_with_employees">与向员工填写图书馆中</a>解释的相同原因<a href="#Fill_the_library_with_employees">，</a>我们这次不会比较模型。
		</p>
		<h5 id="Borrowing_a_book">借书</h5>
		<p>我们将通过让他借用“基础前奏曲”来使用你新创建的借款人。</p>
		<ul>
			<li>打开模型编辑器。</li>
			<li>选择借款人“格雷厄姆”。</li>
			<li>在“属性”视图中将“Prelude to Foundation”添加到“Borrowed”功能中。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Setting.png">
		</p>
		<ul>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison.png">
		</p>
		<p>在此比较中，您可以注意到两个不同之处<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison_Borrowers_Diff.png">和<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison_Borrowed_Diff.png"> 。
		</p>
		<p>EMF Compare显示两个差异，而您只在模型中进行了一次修改。解释是在EXTlibrary元模型的结构内。如果您查看extlibrary.ecore中的“借用”功能，您会看到EOpposite字段设置为“借用者：借款人”。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison_EOpposite.png">
		</p>
		<p>这意味着每次向借款人添加/删除图书时，EMF都会自动将借阅者添加/删除到图书的“借阅者”功能（反之亦然）。修改一个功能将修改另一个功能。它解释了为什么EMF Compare看到两个不同之处。</p>
		<p>现在您可能想知道当您接受其中一个差异时会发生什么？EMF Compare会给你一个关于这个问题的提示。首先注意后果预览按钮<img border="0" src="../images/EMF_Compare_Tuto_Consequences_Preview_Button.png"> 。它可以将其图标设置为<img border="0" src="../images/accept.gif">用于“接受预览模式”或<img border="0" src="../images/reject.gif">用于“拒绝预览模式”。
		</p>
		<p>当“接受预览模式”被激活时（ <img border="0" src="../images/accept.gif"> ），EMF Compare将帮助您了解接受当前所选差异的后果。我们来试试吧。
		</p>
		<ul>
			<li>激活“接受预览模式”（ <img border="0" src="../images/accept.gif"> ）。
			</li>
			<li>选择“借款人格雷厄姆[借款人补充]”的区别。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison.png">
		</p>
		<p>请注意，“Book of Prelude to Foundation [borrower add]”差异以绿色突出显示。这意味着接受当前差异也会自动接受这种差异。这两个差异由“等价”元素联系在一起，这意味着合并一个元素相当于合并另一个元素。您可以通过选择“Book Prelude to Foundation [borrower add]”而不是“Borrower Graham [借用者添加]”来重现相同的行为。</p>
		<ul>
			<li>接受差异并检查结果。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison_Accepted.png">
		</p>
		<p>两种差异都被接受了。现在让我们试着拒绝差异。</p>
		<ul>
			<li>撤消上一次合并（Ctrl + z）。</li>
			<li>切换到拒绝预览模式（ <img border="0" src="../images/reject.gif"> ）。
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Switch_Reject_Preview_Mode.png">
		</p>
		<ul>
			<li>选择一个区别。
				<ul>
					<li>请注意，其他差异也以绿色突出显示。由于两个差异是“等效的”，两种预览模式都显示出相同的结果。稍后您将在另一个用例中看到每种预览模式都会显示不同的后果。</li>
				</ul>
			</li>
			<li>拒绝差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Graham_Borrows_Book_Comparison_Rejected.png">
		</p>
		<p>这两个差异都被拒绝了。</p>
		<h5 id="Create_a_new_library_branch">创建一个新的库分支</h5>
		<p>现在您的库正在增长，让我们在您的库中创建一个新分支。这个新图书馆将隶属于主要实体，但将拥有独立的生活。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>在主库下创建一个新库。</li>
			<li>在新库中创建一个名为“1984”的新书。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Setting.png">
		</p>
		<ul>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison.png">
		</p>
		<p>EMF Compare仅显示一个差异，而您进行了两次修改。您已创建一个子库和一本书。这两个差异之间必然存在联系......确实没有图书馆，因为它被包含在新图书馆中，所以不可能创建“1984”这本书。为清楚起见，EMF Compare仅显示一个差异并隐藏另一个差异。</p>
		<ul>
			<li>接受差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Accepted.png">
		</p>
		<p>EMF Compare已接受这两种差异。它创造了新的图书馆和新书。相反，让我们试着拒绝这种差异。</p>
		<ul>
			<li>撤消上一个操作（Ctrl + z）。</li>
			<li>拒绝差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Rejected.png">
		</p>
		<p>EMF Compare拒绝这两种差异。</p>
		<p>在某些用例中，显示两个差异可能很有用。例如，如果我们想接受库的创建但拒绝创建该书。为此，您必须使用过滤器按钮（有关详细信息，请参阅<a href="./../user/user-guide.html#Filtering_Differences" title="。/../user/user-guide.html#Filtering_Differences">过滤差异</a> ）。
		</p>
		<ul>
			<li>撤消上一个操作（Ctrl + z）。</li>
			<li>取消激活“Cascading difference”过滤器。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter.png">
		</p>
		<ul>
			<li>点击“否”。它告诉EMF Compare不要记住您对后续比较的选择。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter_Popup.png">
		</p>
		<p>过滤器停用后，您将看到两者之间的差异。现在您可以单独合并每个差异。</p>
		<ul>
			<li>激活“接受预览模式”（ <img border="0" src="../images/accept.gif"> ）。
			</li>
			<li>选择书籍差异“Book 1984 [stock add]”。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter2.png">
		</p>
		<p>请注意，库的差异会突出显示。实际上，合并图书差异必然会合并图书馆的差异。</p>
		<ul>
			<li>切换到“拒绝预览模式”（ <img border="0" src="../images/reject.gif"> ）。
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter3.png">
		</p>
		<p>在此模式下，不会突出显示其他差异。实际上，您可以拒绝创建本书而不拒绝创建库。以相同的方式，在“拒绝预览模式”被激活时选择库差异将突出显示书籍差异。如果库不存在，那么该书也可能不存在。</p>
		<ul>
			<li>激活“拒绝预览模式”（ <img border="0" src="../images/reject.gif"> ）。
			</li>
			<li>选择库差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter_Reject_Mode.png">
		</p>
		<h5 id="Move_a_book">移动一本书</h5>
		<p>为了填补新的图书馆，我们将从主图书馆给它一本书。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>将“Prelude to Foundation”移动到新的分支库（使用拖放）。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Move_Setting.png">
		</p>
		<ul>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Move_Comparison.png">
		</p>
		<p>在这个例子中，我们引入了一种新的变化：“移动元素”。这意味着该元素已存在于先前版本中，但位于不同的位置。在内容查看器中，您可以在模型的当前版本和先前版本中查看此元素的位置。</p>
		<ul>
			<li>接受更改以将差异标记为已合并。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Move_Accepted.png">
		</p>
		<ul>
			<li>撤消上一个操作（Ctrl + z）。</li>
			<li>拒绝差异以将元素移回原始位置。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Move_Rejected.png">
		</p>
		<h5 id="Remove_a_book">删除一本书</h5>
		<p>事故发生后，必须将书籍“1984”从书架上移除。</p>
		<ul>
			<li>关闭EMF比较编辑器（不保存）。</li>
			<li>打开模型编辑器。</li>
			<li>删除“1984”一书。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Remove_Book_Setting.png">
		</p>
		<ul>
			<li>与之前相比。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Remove_Book_Comparison.png">
		</p>
		<p>这种变化与增加相反。</p>
		<ul>
			<li>接受更改以删除该书。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Remove_Book_Accepted.png">
		</p>
		<ul>
			<li>撤消上一个操作（Ctrl + z）。</li>
			<li>拒绝更改以将书籍添加回库中。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Remove_Book_Rejected.png">
		</p>
		<h4 id="Compare_with_repository_.283-way.29">与存储库（3路）比较</h4>
		<h5 id="Set_up_2">建立</h5>
		<p>在本教程的这一部分中，我们将继续构建我们的模型。唯一的区别是我们将为每个新修改创建不同的方案。为此，我们需要一个名为Git的工具。它是一个免费的开源分布式版本控制系统。在Eclipse世界中，我们将讨论<a href="http://www.eclipse.org/jgit/" title="http://www.eclipse.org/jgit/">JGit</a>和<a href="http://www.eclipse.org/egit/" title="http://www.eclipse.org/egit/">EGit</a> 。JGit是Git的java实现。EGit是JGit在Eclipse中的集成。
		</p>
		<p>注意：在继续之前，从借款人“格雷厄姆”的“借用”功能中删除“基础前奏”一书。以下示例假设未设置此关系！</p>
		<h6 id="Create_a_Git_repository">创建一个Git存储库</h6>
		<p>首先，我们需要一个Git存储库。您可以使用现有Git存储库的克隆，也可以创建自己的本地Git存储库。我们为本教程选择了第二个解决方案。</p>
		<ul>
			<li>打开“Git Repositories”视图（如果尚未打开）：Window&gt;“Show view”&gt;“Other ...”。
				<ul>
					<li>选择“Git存储库”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tutorial_Git_Repo_View.png">
							</dd>
						</dl>
					</li>
				</ul>
			</li>
			<li>然后单击新的存储库按钮<img border="0" src="../images/EMF_Compare_Tuto_Create_Git_Repo_Button.png"> 。
			</li>
			<li>设置新存储库的位置。如果提示，请为其命名。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Create_Git_Repo_Wizard.png">
					</dd>
				</dl>
			</li>
			<li>点击完成。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Repository_View.png">
					</dd>
				</dl>
			</li>
		</ul>
		<h6 id="Share_your_model">分享你的模特</h6>
		<p>现在您的存储库已准备就绪。我们把你的模型放进去吧。</p>
		<ul>
			<li>选择包含模型的项目。</li>
			<li>打开上下文菜单：“Team”&gt;“Share project ...”。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Share_Project.png">
					</dd>
				</dl>
			</li>
			<li>选择“Git”，然后单击“下一步”。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Share_Project_Wizard.png">
					</dd>
				</dl>
			</li>
			<li>选择您之前创建的存储库，然后单击“完成”。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Share_Project_Wizard2.png">
					</dd>
				</dl>
			</li>
		</ul>
		<h6 id="Commit_your_changes">提交您的更改</h6>
		<p>您的项目现已移至存储库中。但是你的工作尚未完成。提交模型就像对其进行快照并将其保存以供日后使用（有关详细信息，请参阅<a href="http://wiki.eclipse.org/EGit/User_Guide#Committing_Changes" title="http://wiki.eclipse.org/EGit/User_Guide#Committing_Changes">提交更改</a> ）。为此：</p>
		<ul>
			<li>选择包含模型的项目。</li>
			<li>打开上下文菜单（右键单击）：“Team”&gt;“Commit ...”。</li>
			<li>输入此提交的消息，描述已完成的操作。对于此示例“First commit”。会做。</li>
			<li>选择要提交的文件。在我们的示例中选择所有文件。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_First_Commit.png">
					</dd>
				</dl>
			</li>
			<li>单击提交按钮。</li>
		</ul>
		<p>您的项目刚刚进入您的存储库。我们来看看您的存储库及其历史记录。</p>
		<ul>
			<li>在“Git存储库”视图中选择您的存储库。</li>
			<li>打开“历史记录”视图：<ul>
					<li>右键单击存储库，打开上下文菜单。</li>
					<li>选择“显示”&gt;“历史”</li>
				</ul>
			</li>
		</ul>
		<p>它应该如下所示： <img border="0" src="../images/EMF_Compare_Repository_State1.png">
		</p>
		<p>在“Git存储库”视图中展开存储库树。在其中，您可以在“分支”中看到名为“本地”的文件夹。该文件夹包含Git存储库的所有分支。在此示例中，每个分支将代表模型的方案。您可以注意到您的存储库已经有一个“主”分支。这是您的主要方案。</p>
		<p>在历史记录视图中，您可以看到所有提交的图表。目前唯一可用的条目是您之前提交的第一个提交。为了更好地理解我们将在存储库中进行的更改，我们建议您单击“同步”按钮（ <img border="0" src="../images/EMF_Compare_Tuto_Sync_Button.png"> ）和“显示所有分支”按钮（ <img border="0" src="../images/EMF_Compare_Tuto_Show_All_Branches_Button.png"> ）。这将为您提供存储库的全局点。
		</p>
		<h5 id="Create_Scenario_1">创建场景1</h5>
		<p>让我们创建我们的第一个场景。为此：</p>
		<ul>
			<li>选择“Git Repositories”视图中的分支，该分支将用作新分支的起点。在这种情况下：主人。</li>
			<li>打开上下文菜单：“创建分支...”。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Create_New_Branch.png">
		</p>
		<ul>
			<li>将其名称设置为“Scenario1”。必须选中“Checkout new branch”按钮。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Create_New_Branch_Wizard.png">
		</p>
		<ul>
			<li>点击完成。</li>
		</ul>
		<p>您刚刚创建了一个新方案，它将使用主分支的最后一次提交作为起点。</p>
		<h6 id="Change_the_number_of_pages">更改页数</h6>
		<p>您的存储库中现在有两个分支。让我们修改我们的模型来编写我们的第一个场景。</p>
		<ul>
			<li>打开模型编辑器。</li>
			<li>选择“基础前奏”一书。</li>
			<li>打开“属性”视图。</li>
			<li>将字段“Pages”的值更改为374。</li>
			<li>保存。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario1_Setting.png">
		</p>
		<ul>
			<li>将此模型与存储库中的最后一次提交进行比较：<ul>
					<li>选择您的模型文件。</li>
					<li>打开上下文菜单：“Compare With”&gt;“Head Revision”。</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario1_Comparison.png">
		</p>
		<p>这是模型的当前版本与之前提交的快照之间的比较。我们保存这个版本。为此，我们将承诺。按照<a href="#Commit_your_changes">提交更改中</a>所述的步骤操作：</p>
		<ul>
			<li>选择包含模型的项目。</li>
			<li>打开上下文菜单：Team&gt;“Commit ...”。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario1_Commit.png">
		</p>
		<ul>
			<li>输入提交消息：“将页码设置为374”。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario1_Commit_Message.png">
		</p>
		<ul>
			<li>单击提交。</li>
		</ul>
		<h5 id="Scenario_2:_Conflict">场景2：冲突</h5>
		<p>让我们创建一个不同的场景。按照<a href="#Create_Scenario_1">Create Scenario 1中</a>描述的步骤从master分支创建一个名为“Scenario2”的新方案。
		</p>
		<ul>
			<li>单击“Git Repositories”视图中的master分支。</li>
			<li>打开上下文菜单：“创建分支...”。</li>
			<li>将新分支的名称设置为“Scenario2”。</li>
			<li>点击完成。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Creation.png">
		</p>
		<p>在这种情况下，我们将“Prelude to Foundation”的页数设置为375。</p>
		<ul>
			<li>双击“TutorialModel.extlibrary”刷新模型编辑器。</li>
			<li>将“Prelude to Foundation” <a href="#Change_the_number_of_pages">的页数设置</a>为375（有关详细信息，请参阅<a href="#Change_the_number_of_pages">更改页数</a> ）</li>
			<li>保存。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Setting.png">
					</dd>
				</dl>
			</li>
			<li>提交更改（请参阅<a href="#Commit_your_changes">提交更改</a>以获取更多信息）。
			</li>
			<li>将提交消息设置为“将页码设置为375”。</li>
			<li>将您的模型与“Scenario1”进行比较：<ul>
					<li>选择模型文件。</li>
					<li>打开上下文菜单：“与...比较”&gt;“提交...”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Compare_With_Commit.png">
							</dd>
						</dl>
					</li>
					<li>选择包含“Scenario1”标记的提交。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Compare_With_Commit2.png">
							</dd>
						</dl>
					</li>
				</ul>
			</li>
		</ul>
		<p>您现在应该打开EMF比较编辑器。</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Comparison.png">
		</p>
		<p>首先要理解的是，这种比较是一种三向比较。这意味着EMF Compare使用3个输入来计算差异。第一个（左下角）是模型的本地版本（“Scenario2”）。第二个（右下角）是“Scenario1”中的模型版本。第三个是另外两个版本的共同祖先。历史视图给出了情况的图片。</p>
		<ul>
			<li>查看存储库的历史记录视图。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Common_Ancestor.png">
		</p>
		<p>方案1和2都使用主分支作为起点。这就是它被用作共同祖先的原因。稍后我们将在本教程中看到EMF Compare如何使用第三个输入。您可以通过单击“显示Ancestor窗格”按钮在EMF比较中显示其内容（ <img border="0" src="../images/EMF_Compare_Tuto_Show_Ancestor_Button.png"> ）。
		</p>
		<p>
			<img title="共同祖先2" alt="共同祖先2" border="0" src="../images/EMF_Compare_Tuto_Scenario2_Common_Ancestor2.png">
		</p>
		<ul>
			<li>我们来看看差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Conflict_Differences.png">
		</p>
		<p>您可以注意到一种新的差异：冲突。实际上，在Scenario1中，我们将页数设置为374，而在Scenario2中将页数设置为375。EMF Compare告诉我们它不能同时存在。如果您选择其中一个差异，您将看到另一个以红色突出显示。这意味着如果合并此差异，EMF Compare将无法合并另一个。</p>
		<p>我们现在将看到接受或拒绝每个差异会产生什么影响。</p>
		<ul>
			<li>选择名为“375 [页面已更改]”的差异。</li>
			<li>接受差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Accept_375.png">
		</p>
		<p>在这种情况下，EMF Compare已接受所选差异并拒绝另一个差异，因为它们无法同时被接受。让我们试着拒绝这种差异。</p>
		<ul>
			<li>撤消上一个操作（Ctrl + z）。</li>
			<li>切换到“拒绝预览模式”（ <img border="0" src="../images/reject.gif"> ）。
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Reject_Preview_Mode.png">请注意，没有以红色突出显示。似乎拒绝这种差异对其他差异没有影响。我们来看看。
		</p>
		<ul>
			<li>拒绝名为“375 [页面已更改]”的差异。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario2_Reject_375.png">
		</p>
		<p>在这种情况下，EMF Compare仅拒绝当前差异。当您查看属性的值时，您将看到页面数已设置为100。该值是共同祖先模型中相同属性的值（参见图片“Common Ancestor 2”）。在3方式比较中，您可以接受来自两个输入版本之一的属性版本（场景1或场景2），也可以将版本返回到其共同的祖先值（master）。</p>
		<p>显然，您可以对名为“374 [页面已更改]”的差异执行相同的操作。它会：</p>
		<ul>
			<li>将属性的值设置为374，如果接受，则拒绝其他差异。</li>
			<li>如果拒绝，则将属性的值设置为100。</li>
		</ul>
		<p>请注意，拒绝一个方案后，您仍然需要处理剩余的差异。根据您是接受还是拒绝它，属性的最终值将是共同祖先之一或剩余方案之一。</p>
		<h5 id="Scenario_3:_Pseudo_conflict">场景3：伪冲突</h5>
		<p>在上一章中，您已经了解了EMF Compare如何处理两个场景之间的两个冲突变化。在本章中，我们将看到它如何处理两个在语义上相同的更改。让我们创建第三个场景：</p>
		<ul>
			<li>从主分支<a href="#Create_Scenario_1">创建</a>名为“Scenario3”的新分支（请参阅<a href="#Create_Scenario_1">创建方案1</a>以了解如何创建新方案）。
			</li>
			<li>打开模型编辑器。</li>
			<li>将“Prelude to Foundation”的页数设置为375（有关详细说明，请参阅<a href="#Scenario_2:_Conflict">方案2</a> ）。
			</li>
			<li>保存。</li>
			<li>提交更改（请参阅<a href="#Commit_your_changes">提交更改</a> ）。将提交消息设置为“将页码设置为375”。
			</li>
			<li>将此版本与Scenario2进行比较：<ul>
					<li>选择您的模型文件。</li>
					<li>打开上下文菜单：“与...比较”&gt;“分支，标记或参考...”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario3_Compare_With_Branch.png">
							</dd>
						</dl>
					</li>
					<li>选择“Scenario2”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario3_Compare_With_Scenario2.png">
							</dd>
						</dl>
					</li>
					<li>点击比较。</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Scenario3_Comparison.png">
		</p>
		<p>乍一看似乎没有发现任何差异。这并不奇怪，因为两个输入模型在语义上是相同的。但是你会看到EMF Compare做了一些工作：</p>
		<ul>
			<li>停用“Pseudo Conflict”过滤器。</li>
			<li>处理过滤器弹出窗口。如果要在所有后续比较中默认取消激活“伪冲突”过滤器，请选择“是”。如果您希望仅为当前比较停用它，请选择“否”。您也可以通过选中左下角的复选框询问EMF Compare以记住您的选择。
				<img border="0" src="../images/EMF_Compare_Tuto_New_Library_Comparison_Cascading_Filter_Popup.png">
			</li>
		</ul>
		<p>
			<b>被<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=435051">https://bugs.eclipse.org/bugs/show_bug.cgi?id=435051</a>阻止</b> <img border="0" src="../images/EMF_Compare_Tuto_Scenario3_Pseudo_Conflict_Filter.png">
		</p>
		<p>EMF Compare检测到两个差异。在共同祖先和Scenario2之间检测到第一个差异。在共同祖先和Scenario3之间检测到第二个。然而，EMF Compare很聪明地认为这两个差异是相同的。</p>
		<h5 id="Scenario_4_and_5:_Advanced_conflict">场景4和5：高级冲突</h5>
		<p>既然你已经理解了冲突是如何运作的，那么我们将会产生更复杂的冲突。让我们在一个场景（场景4）中要删除的书和我们将在另一个场景中借用的书（场景5）之间产生冲突。</p>
		<ul>
			<li>从主分支<a href="#Create_Scenario_1">创建</a>名为“Scenario4”的新方案（请参阅<a href="#Create_Scenario_1">创建方案1</a>以了解如何创建新方案）。
			</li>
			<li>删除“基础前奏”一书。</li>
			<li>保存。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario4_Setting.png">
					</dd>
				</dl>
			</li>
			<li>提交消息“删除基础的前奏”（请参阅<a href="#Commit_your_changes">提交更改</a> ）。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario4_Commit.png">
					</dd>
				</dl>
			</li>
			<li>从master创建新方案“Scenario5”（请参阅<a href="#Create_Scenario_1">创建方案1</a>以了解如何创建新方案）。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Branches.png">
					</dd>
				</dl>
			</li>
		</ul>
		<p>在本教程的这个阶段，您的Git存储库应该如下所示。</p>
		<ul>
			<li>让“威尔格雷厄姆”借用“基础前奏”。</li>
			<li>保存。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Setting.png">
					</dd>
				</dl>
			</li>
			<li>提交消息“Will Graham借书”（请参阅<a href="#Commit_your_changes">提交您的更改</a> ）。
			</li>
			<li>将方案5与方案4 <a href="#Scenario_3:_Pseudo_conflict">进行比较</a> （有关详细信息，请参阅<a href="#Scenario_3:_Pseudo_conflict">与分支比较</a> ）。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Comparison.png">
					</dd>
				</dl>
			</li>
		</ul>
		<p>如果您选择每个差异，您将看到：</p>
		<ul>
			<li>“预订基础[股票删除]的前提”不能与其他两个差异合并。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Diff_Dependencies.png">
					</dd>
				</dl>
				<ul>
					<li>接受差异得到：<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Deletion_Accepted.png">
							</dd>
						</dl>
					</li>
					<li>拒绝差异得到：<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Deletion_Rejected.png">
							</dd>
							<dd>拒绝它并不会自动接受其他差异。实际上，您可以阻止删除该书，但仍然希望选择接受或拒绝其他差异。</dd>
						</dl>
					</li>
				</ul>
			</li>
			<li>“借款人格雷厄姆[借款人补充]”和“预订基金会[借来的补充]”是相同的，他们不能与第三个差异合并。
				<dl>
					<dd>
						<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Diff_Dependencies2.png">
					</dd>
				</dl>
				<ul>
					<li>接受其中一个得到：<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Set_Ref_Accepted.png">
							</dd>
						</dl>
					</li>
					<li>拒绝其中一个得到：<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Scenario5_Set_Ref_Rejected.png">
							</dd>
							<dd>同样的结论在这里。您可以拒绝参考设置，但仍想选择如何处理“删除”差异。</dd>
						</dl>
					</li>
				</ul>
			</li>
		</ul>
		<h5 id="Fragment_your_model">分割你的模型</h5>
		<p>假设您想将子库的工作委托给您的同事。要这样做，你想给他一个子库的文件，没有别的。让我们将新的分支库提取到一个新文件中。在本教程的这一部分中，我们将讨论模型（也称为控件）的碎片。以下步骤将向您展示EMF Compare如何对分割在多个文件中的模型做出反应。</p>
		<ul>
			<li>从主分支创建“Scenario6”（请参阅<a href="#Create_Scenario_1">创建方案1</a>以了解如何创建新方案）。
			</li>
			<li>打开模型编辑器。</li>
			<li>控制分支库：<ul>
					<li>选择子库。</li>
					<li>打开上下文菜单：“Control ...”。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Control_Library.png">
							</dd>
						</dl>
					</li>
					<li>设置新目标文件的路径（为方便起见，使用“浏览工作区...”按钮）。
						<dl>
							<dd>
								<img border="0" src="../images/EMF_Compare_Tuto_Control_Library_Set_URI.png">
							</dd>
						</dl>
					</li>
				</ul>
			</li>
			<li>保存（项目中会出现一个新文件）。</li>
			<li>关闭模型编辑器。</li>
			<li>打开模型编辑器（需要重新加载以查看控件装饰器）。</li>
		</ul>
		<p>
			<img border="0" src="../images/EMF_Compare_Tuto_Controled_Model.png">在新模型中，您可以看到已加载了两个资源（NewLibraryFile.extlibrary和TutorialModel.extlibrary）。您还可以注意到子库上的新叠加图标。这意味着此元素存储在另一个文件（资源）中。
		</p>
		<ul>
			<li>与HEAD比较（请参阅<a href="#Change_the_number_of_pages">与HEAD比较</a> ）。
			</li>
		</ul>
		<p>Eclipse要求您切换到“Team Synchronize”透视图，接受。</p>
		<p>
			<b>阻止了<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=435081">https://bugs.eclipse.org/bugs/show_bug.cgi?id=435081</a>
			</b>
		</p>
		<p>
			<i>TODO包含在存储库中 -  Rebase两个分支 - 将您的同事</i> <i>TODO</i> <i>的工作重新定位</i> <i>到存储库中 - 合并两个分支 - 将您的工作与您同事的工作合并</i>
		</p>
	</body>
</html>