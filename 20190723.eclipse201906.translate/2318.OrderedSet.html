<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>OrderedSet（T）</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library"></link>
<link rel="prev" href="OrderedCollection.html" title="OrderedCollection(T)"></link>
<link rel="next" href="Real.html" title="Real"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">OrderedSet（T）</h1>
<div class="section" title="OrderedSet（T）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OrderedSet"></a>
				<span class="bold"><strong>
					<code class="code">OrderedSet(T)</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>OrderedSet是一个Set，其元素是有序的。它不包含重复项。OrderedSet本身是元类型OrderedSetType的一个实例。OrderedSet不是Set的子类型，也不是Sequence的子类型。Sets和OrderedSets的常见超类型是Collection。</p>
<p><a class="link" href="OrderedCollection.html" title="OrderedCollection（T）"><code class="code">OrderedCollection(T)</code></a> ， <a class="link" href="UniqueCollection.html" title="UniqueCollection（T）"><code class="code">UniqueCollection(T)</code></a>
			
</p>
<p>
				
<span class="bold"><strong>操作</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">-(s : UniqueCollection(OclAny)) : OrderedSet(T)</code>优先级： <code class="code">ADDITIVE</code>
			
</p>
<p><code class="code">self</code>的元素，不在s中。
			</p>
<p>
				
<code class="code">append（object：T [？]）：OrderedSet（T）</code>
			
</p>
<p>元素集，由<code class="code">self</code>的所有元素组成，后跟object。
			</p>
<p>
				
<code class="code">appendAll（objects：OrderedCollection（T））：OrderedSet（T）</code>
			
</p>
<p>元素集，由<code class="code">self</code>的所有元素组成，后跟对象。
			</p>
<p>
				
<code class="code">排除（对象：OclAny [？]）：OrderedSet（T）</code>
			
</p>
<p>有序集包含除对象之外的所有<code class="code">self</code>元素。
			</p>
<p>其余元素的顺序不会改变。</p>
<p>
				
<code class="code">excludedAll（objects：Collection（OclAny））：OrderedSet（T）</code>
			
</p>
<p>除了所有对象的出现之外，包含<code class="code">self</code>所有元素的有序集。
			</p>
<p>
				
<code class="code">flatten（T2）（）：OrderedSet（T2）</code>
			
</p>
<p>
				
<code class="code">包括（object：T [？]）：OrderedSet（T）</code>
			
</p>
<p>包含<code class="code">self</code>和object的所有元素的有序集合作为最后一个元素添加（如果尚未存在）。
			</p>
<p>
				
<code class="code">includesAll（objects：Collection（T））：OrderedSet（T）</code>
			
</p>
<p>包含<code class="code">self</code>加上对象的所有元素的有序集合作为最后一个元素添加。
			</p>
<p>
				
<code class="code">insertAt（index：Integer [？]，object：T [？]）：OrderedSet（T）无效</code>
			
</p>
<p>有序集由<code class="code">self</code>组成，对象出现在位置索引处。
			</p>
<p>
				
<code class="code">prepend（object：T [？]）：OrderedSet（T）</code>
			
</p>
<p>由object组成的序列，后跟<code class="code">self</code>的所有元素。
			</p>
<div class="literallayout">
<p>
<code class="code">post IsAtStart：result-&gt; at（1）= object<br>

</code>
</p>
</div>
<p></p>
<div class="literallayout">
<p>
<code class="code">post IsShiftedAlong：Sequence {1..self-&gt; size（）}  - &gt; forAll（index | self-&gt; at at（index）= result-&gt; at at（index + 1））<br>

</code>
</p>
</div>
<p></p>
<div class="literallayout">
<p>
<code class="code">post IsSizePlusOne：result-&gt; size（）= self-&gt; size（）+ 1<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">prependAll（objects：OrderedCollection（T））：OrderedSet（T）</code>
			
</p>
<p>由对象组成的序列，后跟<code class="code">self</code>的所有元素。
			</p>
<p>
				
<code class="code">reverse（）：OrderedSet（T）</code>
			
</p>
<p>具有相同元素但顺序相反的有序元素集。</p>
<p>
				
<code class="code">selectByKind（TT）（类型：TT [？]）：OrderedSet（TT）</code>
			
</p>
<p>
				
<code class="code">selectByType（TT）（类型：TT [？]）：OrderedSet（TT）</code>
			
</p>
<p>
				
<code class="code">subOrderedSet（lower：Integer [？]，upper：Integer [？]）：OrderedSet（T）invalidating</code>
			
</p>
<p><code class="code">self</code>的子集从较低的数字开始，直到并包括元素数字upper。
			</p>
<p>
				
<span class="bold"><strong>迭代</strong></span>
			
</p>
<p>
				
<code class="code">closure（i：T [1] | lambda：Lambda T（）：OrderedSet（T）[？]）：OrderedSet（T）</code>
			
</p>
<p>将物体传递到源集合的每个不同元素的封闭。</p>
<p>
				
<code class="code">收集（V）（i：T [？]| lambda：Lambda T（）：V [？]）：序列（V）</code>
			
</p>
<p>
				
<code class="code">collectNested（V）（i：T [？]| lambda：Lambda T（）：V [？]）：序列（V）</code>
			
</p>
<p>将主体应用于源有序集合的每个成员所产生的元素序列。</p>
<p>
				
<code class="code">拒绝（i：T [？]| lambda：Lambda T（）：Boolean [1]）：OrderedSet（T）</code>
			
</p>
<p>主体为<code class="code">false</code>的源有序集的有序集。
			</p>
<p>
				
<code class="code">选择（i：T [？]| lambda：Lambda T（）：Boolean [1]）：OrderedSet（T）</code>
			
</p>
<p>源的有序集合有序设置哪个机构是<code class="code">true</code>
			
</p>
<p>
				
<code class="code">sortedBy（i：T [？]| lambda：Lambda T（）：OclAny [？]）：OrderedSet（T）</code>
			
</p>
<p>包含源集合的所有元素的有序集中的结果。首先是身体具有最低值的元素，依此类推。正文表达式的类型必须具有&lt;operation defined。&lt;operation必须返回一个布尔值，并且必须是可传递的（即，如果a &lt;b且b &lt;c，则a &lt;c）。</p>
</div>
</body>
</html>