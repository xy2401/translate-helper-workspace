<html lang="zh-Hans" dir="ltr">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content=""></meta>
    <meta name="author" content="Stéphane Bégaudeau"></meta>    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet"></link>
    <link href="../../assets/css/docs.css" rel="stylesheet"></link>
    
    <title>Acceleo</title>
  </head>
  <body dir="ltr">
    <div class="container">
      <header class="jumbotron subhead" id="overview">
        <h1>操作</h1>
        <p class="lead">Acceleo语言中提供的所有操作</p>
        <!--<div class="subnav">
          <ul class="nav nav-pills">
            <li><a href="#oclany">OclAny</a></li>
            <li><a href="#string">String</a></li>
            <li><a href="#number">Number</a></li>
            <li><a href="#boolean">Boolean</a></li>
            <li><a href="#collections">Collections</a></li>
            <li><a href="#sequence">Sequence</a></li>
            <li><a href="#orderedset">Ordered Set</a></li>
            <li><a href="#set">Set</a></li>
            <li><a href="#bag">Bag</a></li>
          </ul>
        </div>-->
      </header>
      
      <section id="example">
        <p>某些示例需要示例模型，因此我们将使用以下模型作为示例。
        </p>
        <img src="../../assets/img/reference/package.png">
      </section>
      
      <section id="oclany">
        <div class="page-header">
          <h1><small>所有模型对象都可以使用</small> OclAny <small>操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>=（elem：OclAny）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（elem：OclAny）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&gt;（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;=（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&gt; =（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>祖先（）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>祖先（oclType：OclType）：序列（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eAllContents（）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eAllContents（oclType：OclType）：序列（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>current（index：Integer）：OclAny</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>current（oclType：OclType）：OclType</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eContainer（oclType：OclType）：OclType</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eContents（oclType：OclType）：序列（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eGet（featureName：String）：OclAny</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eInverse（）：Sequence（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eInverse（oclType：OclType）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>followingSiblings（）：Sequence（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>followingSiblings（oclType：OclType）：Sequence（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty（key：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty（key：String，parameters：Sequence（OclAny））：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty（name：String，key：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty（name：String，key：String，parameters：Sequence（OclAny））：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>invoke（className：String，methodName：String，arguments：Sequence（OclAny））：OclAny</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lineSeparator（）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>oclAsType（oclType：OclType）：OclType</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsInvalid（）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsKindOf（oclType：OclType）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsTypeOf（oclType：OclType）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsUndefined（）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>precedindSiblings（）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>precedingSiblings（oclType：OclType）：Sequence（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>兄弟姐妹（）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>兄弟姐妹（oclType：OclType）：序列（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>toString（）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>+（str：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>=（elem：OclAny）：布尔值</h2>
        <p>如果self等于object，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['first string'='first string'/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['first string'= Sequence {'a'，'b'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（elem：OclAny）：布尔值</h2>
        <p>如果self等于object，则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['first string'&lt;&gt;'first string'/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>['first string'&lt;&gt; Sequence {'a'，'b'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>&lt;（elem：T）：布尔值</h2>
        <p>如果self与object相当且小于object，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['第一个字符串'&lt;'第二个字符串'/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['first string'&lt;'另一个字符串'/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>&gt;（elem：T）：布尔值</h2>
        <p>如果self与object相当且大于object，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['first string'&gt;'second string'/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>['first string'&gt;'另一个字符串'/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>&lt;=（elem：OclAny）：布尔值</h2>
        <p>如果self与object相当且小于或等于object，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['first string'&lt;='second string'/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['first string'&lt;='first string'/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['first string'&lt;='另一个字符串'/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>&gt; =（elem：OclAny）：布尔值</h2>
        <p>如果self与object相当且大于或等于object，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['first string'&gt; =''second string'/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>['first string'&gt; ='first string'/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['first string'&gt; ='另一个字符串'/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>祖先（）：序列（OclAny）</h2>
        <p>返回包含接收器祖先的完整集合的Sequence。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.ancestors（）/]</td>
              <td>序列{First Child Package，Root Package}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>祖先（oclType：OclType）：序列（OclAny）</h2>
        <p>从接收者的祖先集合中返回给定类型的元素作为序列。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。在此示例中，还返回元素根，因为Model是Package的实例。返回的所有元素都是oclIsKindOf（oclType）返回true的祖先。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.ancestors（EPackage）/]</td>
              <td>序列{First Child Package，Root Package}</td>
            </tr>
            <tr>
              <td>[elementOne.ancestors（的EClass）/]</td>
              <td>序列{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eAllContents（）：序列（OclAny）</h2>
        <p>以Sequence的形式返回接收者的整个内容树。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[rootPackage.eAllContents（）/]</td>
              <td>顺序{第一个儿童包，第一个元素，第二个元素，第二个儿童包，第三个儿童包，第三个元素，第四个元素，第五个元素}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eAllContents（oclType：OclType）：序列（OclAny）</h2>
        <p>从接收器的整个内容树中返回给定类型的元素作为Sequence。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[rootPackage.eAllContents（的EClass）/]</td>
              <td>序列{元素一，元素二，元素三，元素四，元素五}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>current（index：Integer）：OclAny</h2>
        <p>返回当前上下文之上的上下文索引排名的值。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[for（anEPackage：EPackage | self.eSubpackages）]<br>[for（anEClass：EClass | anEPackage.eClassifiers-&gt; filter（EClass））]<br>[电流（0）/]<br>[电流（1）/]<br>[电流（2）/]<br>[/对于]<br>[/对于]<br>
              </td>
              <td>表达式“current（0）”返回self，在这种情况下是“anEClass”的当前值。<br>表达式“current（1）”返回“anEPackage”的当前值。<br>表达式“current（2）”在第一个块“for”之前返回“self”的值。<br>
              </td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>current（oclType：OclType）：OclType</h2>
        <p>这将与current（Integer）具有相同的效果，除了它将返回给定类型的第一个上下文（自变量），在当前或之上。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[for（anEPackage：EPackage | self.eSubpackages）]<br>[for（anEClass：EClass | anEPackage.eClassifiers-&gt; filter（EClass））]<br>[电流（的EClass）/]<br>[电流（EPackage）/]<br>[/对于]<br>[/对于]<br>
              </td>
              <td>表达式“current（EClass）”返回“anEClass”的当前值。<br>表达式“current（EPackage）”返回“anEPackage”的当前值。<br>
              </td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eContainer（oclType：OclType）：OclType</h2>
        <p>返回给定类型的第一个祖先，即oclIsKindOf（oclType）求值为true的第一个祖先。返回的元素使用期望的类型键入（因此不需要在其上调用oclAsType（oclType））。
        </p>
        <p>重要提示：Acceleo 2.x的用户应注意，与acceleo 2.x中发生的情况相反，即使self.oclIsKindOf（oclType）为true，此操作也不会返回self。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.eContainer（EPackage）/]</td>
              <td>第一个儿童套餐</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eContents（oclType：OclType）：序列（OclType）</h2>
        <p>返回给定类型的self的直接子节点的序列，即oclIsKindOf（oclType）求值为true的直接子节点。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[firstChildPackage.eContents（的EClass）/]</td>
              <td>序列{元素一，元素二}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eGet（featureName：String）：OclAny</h2>
        <p>这将获取当前Object上名为featureName的功能的值。返回类型也可以是一个集合作为单个值。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.eGet（ '链接'）/]</td>
              <td>元素四</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eInverse（）：Sequence（OclAny）</h2>
        <p>返回引用self的所有对象的序列。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.eInverse（）/]</td>
              <td>序列{第二个孩子包，元素五}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>eInverse（oclType：OclType）：序列（OclAny）</h2>
        <p>从self的反向引用集中返回给定类型的元素。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.eInverse（的EClass）/]</td>
              <td>序列{元素五}</td>
            </tr>
            <tr>
              <td>[elementFour.eInverse（EPackage）/]</td>
              <td>序列{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>followingSiblings（）：Sequence（OclAny）</h2>
        <p>返回一个包含接收者以下兄弟姐妹的完整集合的序列。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[thirdChildPackage.followingSiblings（）/]</td>
              <td>序列{元素四，元素五}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>followingSiblings（oclType：OclType）：Sequence（OclType）</h2>
        <p>从接收者的兄弟姐妹的集合中返回给定类型的元素作为序列。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[thirdChildPackage.followingSiblings（的EClass）/]</td>
              <td>序列{元素四，元素五}</td>
            </tr>
            <tr>
              <td>[thirdChildPackage.followingSiblings（EPackage）/]</td>
              <td>序列{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>getProperty（key：String）：String</h2>
        <p>返回与给定键对应的属性的值。请注意，此操作将“按原样”返回参数化属性（不处理参数）。
        </p>
        <p>我们正在考虑两个文件，a.properties包含：</p>
        <ul>
          <li>abc =这是一个参数化属性：{0}</li>
        </ul>
        <p>和b.properties包含：</p>
        <ul>
          <li>abc =这是一个名称冲突的参数化属性：{0}</li>
          <li>abcd =这是一个标准的属性</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[的getProperty（ 'ABC'）/]</td>
              <td>'这是一个参数化属性：{0}'</td>
            </tr>
            <tr>
              <td>[的getProperty（ 'ABCD'）/]</td>
              <td>'这是一个标准的财产'</td>
            </tr>
            <tr>
              <td>[的getProperty（ 'ABCDE'）/]</td>
              <td>“”</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>getProperty（key：String，parameters：Sequence（OclAny））：String</h2>
        <p>返回与给定键对应的属性的值，其参数替换为给定值（如果有）。
        </p>
        <p>我们正在考虑两个文件，a.properties包含：</p>
        <ul>
          <li>abc =这是一个参数化属性：{0}</li>
        </ul>
        <p>和b.properties包含：</p>
        <ul>
          <li>abc =这是一个名称冲突的参数化属性：{0}</li>
          <li>abcd =这是一个标准的属性</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[getProperty（'abc'，Sequence {'substitution'}）/]</td>
              <td>'这是一个参数化的属性：替换'</td>
            </tr>
            <tr>
              <td>[getProperty（'abc'，Sequence {'substitution'}）/]</td>
              <td>'这是一个参数化属性：{0}'</td>
            </tr>
            <tr>
              <td>[getProperty（'abcd'，Sequence {'substitution'}）/]</td>
              <td>'这是一个标准的财产'</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>getProperty（name：String，key：String）：String</h2>
        <p>从与给定名称对应的属性文件中返回与给定键对应的属性的值。请注意，参数化属性将按原样返回。
        </p>
        <p>我们正在考虑两个文件，a.properties包含：</p>
        <ul>
          <li>abc =这是一个参数化属性：{0}</li>
        </ul>
        <p>和b.properties包含：</p>
        <ul>
          <li>abc =这是一个名称冲突的参数化属性：{0}</li>
          <li>abcd =这是一个标准的属性</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[getProperty（'b.properties'，'abc'）/]</td>
              <td>'名称冲突的参数化属性：{0}'</td>
            </tr>
            <tr>
              <td>[getProperty（'a.properties'，'abcd'）/]</td>
              <td>“”</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>getProperty（name：String，key：String，parameters：Sequence（OclAny））：String</h2>
        <p>从与给定名称对应的属性文件中返回与给定键对应的属性的值，并将其参数替换为给定值（如果有）。
        </p>
        <p>我们正在考虑两个文件，a.properties包含：</p>
        <ul>
          <li>abc =这是一个参数化属性：{0}</li>
        </ul>
        <p>和b.properties包含：</p>
        <ul>
          <li>abc =这是一个名称冲突的参数化属性：{0}</li>
          <li>abcd =这是一个标准的属性</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[getProperty（'b.properties'，'abc'，Sequence {'substitution'}）/]</td>
              <td>'名称冲突的参数化属性：替换'</td>
            </tr>
            <tr>
              <td>[getProperty（'b.properties'，'abc'，Sequence {}）/]</td>
              <td>'名称冲突的参数化属性：{0}'</td>
            </tr>
            <tr>
              <td>[getProperty（'a.properties'，'abcd'，Sequence {'substitution'}）/]</td>
              <td>“”</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>invoke（className：String，methodName：String，arguments：Sequence（OclAny））：OclAny</h2>
        <p>使用给定的参数调用类类的Java方法方法。如果无法以任何方式调用该方法（错误的参数，错误的名称，错误的签名，封装错误，......），这将返回OclInvalid。这仅用于现在调用Java方法。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[调用（'java.lang中。String'，'toUpperCase（）'，Sequence {elementOne.name}）/]</td>
              <td>元素一</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>lineSeparator（）：String</h2>
        <p>返回当前平台的行分隔符（类似于System.getProperty（'line.separator'））或Eclipse属性的行分隔符（如果用户已更改）。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[lineSeparator（）/]</td>
              <td>'\ n'（Unix）或'\ r \ n'（Dos）或'\ r'（Mac Os Classic）</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>oclAsType（oclType：OclType）：OclType</h2>
        <p>如果它是此类型的实例，则返回自我静态类型为typespec。请注意，这不会改变self的运行时值，它只允许访问子类型操作。此操作允许用户将self转换为其他类型。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclAsType（的EClass）/]</td>
              <td>元素一</td>
            </tr>
            <tr>
              <td>[elementOne.oclAsType（EPackage）/]</td>
              <td>无效</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>oclIsInvalid（）：Boolean</h2>
        <p>如果self等于invalid，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsInvalid（）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>oclIsKindOf（oclType：OclType）：Boolean</h2>
        <p>如果self的类型对应于typespec的类型或超类型，则返回true，否则返回false。此操作允许用户检查self的类层次结构，就像Java实例一样。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsKindOf（的EClass）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[elementOne.oclIsKindOf（ENamedElement）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>oclIsTypeOf（oclType：OclType）：Boolean</h2>
        <p>如果self的类型与typespec相同则返回true，否则返回false。此操作允许用户检查自己的确切类类型。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsTypeOf（的EClass）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[elementOne.oclIsTypeOf（ENamedElement）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>oclIsUndefined（）：Boolean</h2>
        <p>如果self等于invalid或null，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsUndefined（）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>precedindSiblings（）：序列（OclAny）</h2>
        <p>返回包含接收者之前兄弟节点的完整集合的Sequence。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.precedingSiblings（）/]</td>
              <td>序列{第三子包，第四元素}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>precedingSiblings（oclType：OclType）：Sequence（OclType）</h2>
        <p>从接收者的前一个兄弟的集合中返回给定类型的元素作为序列。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.precedingSiblings（EPackage）/]</td>
              <td>序列{第三子包}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>兄弟姐妹（）：序列（OclAny）</h2>
        <p>返回包含接收者兄弟姐妹的完整集合的序列。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.siblings（）/]</td>
              <td>序列{第三子包，第五元素}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>兄弟姐妹（oclType：OclType）：序列（OclAny）</h2>
        <p>从接收者的兄弟姐妹的集合中返回给定类型的元素作为序列。返回的序列的元素使用期望的类型键入（因此不需要在序列或其元素上调用oclAsType（oclType））。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.siblings（EPackage）/]</td>
              <td>序列{第三子包}</td>
            </tr>
            <tr>
              <td>[elementFour.siblings（的EClass）/]</td>
              <td>序列{元素五}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>toString（）：String</h2>
        <p>返回接收者的String表示形式。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.toString（）/]</td>
              <td>org.eclipse.emf.ecore.impl。EClassImpl @ 4d06b4（name：Element One）（instanceClassName：null）（abstract：false，interface：false）</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        
        <hr>
        
        <h2>+（str：String）：String</h2>
        <p>返回与给定字符串连接的接收器的字符串表示形式。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[elementOne +'a'/]</td>
              <td>org.eclipse.emf.ecore.impl。EClassImpl @ 4d06b4（name：Element One）（instanceClassName：null）（abstract：false，interface：false）a</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="string">
        <div class="page-header">
          <h1>字符串<small>上的字符串操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>concat（str：String）：String</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>contains（subString：String）：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith（subString：String）：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>equalsIgnoreCase（str：String）：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo standard">
              <td>first（n：Integer）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>index（subString：String）：整数</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>index（subString：String，index：Integer）：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo standard">
              <td>isAlpha（）：Boolean</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>isAlphanum（）：Boolean</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>last（n：Integer）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndex（subString：String）：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndex（subString：String，index：Integer）：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>matches（regex：String）：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>prefix（str：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>replace（subStringRegex：String，replacementRegex：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>replaceAll（subStringRegex：String，replacementRegex：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>size（）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith（subString：String）：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo standard">
              <td>strcmp（str：String）：整数</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>strstr（str：String）：Boolean</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>strtok（str：String，n：Integer）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>substitute（origin：String，replacement：String）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>substituteAll（origin：String，replacement：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>substring（start：Integer）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>substring（start：Integer，end：Integer）：String</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>toInteger（）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenize（）：Sequence（String）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenize（subString：String）：Sequence（String）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenizeLine（）：Sequence（String）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>toLower（）：String</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>toLowerFirst（）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>toReal（）：真实的</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo standard">
              <td>toUpperFirst（）：String</td>
              <td>Acceleo</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>toUpper（）：String</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>trim（）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>+（str：String）：String</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>concat（str：String）：String</h2>
        <p>返回包含“ <i>self</i> ”后跟“ <i>str</i> ”的<i>字符串</i> 。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.concat（' anotherString'）/]</td>
              <td>'aStringanotherString'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>contains（subString：String）：Boolean</h2>
        <p>如果“ <i>self</i> ”包含字符串“ <i>subString</i> ”，则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.contains（' 字符串'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[ 'aString'.contains（' anotherString'）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[ 'aString'.contains（' 字符串“）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>endsWith（subString：String）：Boolean</h2>
        <p>如果“ <i>self</i> ”以字符串“ <i>subString</i> ”结束，则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.endsWith（' 字符串'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[ 'aString'.endsWith（' anotherString'）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[ 'aString'.endsWith（' 字符串“）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>equalsIgnoreCase（str：String）：Boolean</h2>
        <p>返回“ <i>真</i> ”，如果“ <i>自我</i> ”等于字符串<i>“STR”</i>不考虑大小写，否则返回“ <i>假</i> ”。如果两个字符串具有相同的长度并且两个字符串中的相应字符相等而忽略它们的情况，则认为两个字符串是相等的。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.equalsIgnoreCase（' anotherString'）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[ 'aString'.equalsIgnoreCase（' ASTRING'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[ 'aString'.equalsIgnoreCase（' ASTRING'）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>first（n：Integer）：String</h2>
        <p>返回“ <i>自我</i> ”，或“ <i>自我</i> ”的第一个<i>“n”</i>个字符，如果它的大小小于<i>“N”。</i>
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.first（2）/]</td>
              <td>'如'</td>
            </tr>
            <tr>
              <td>['aString'.first（0）/]</td>
              <td>“”</td>
            </tr>
            <tr>
              <td>['aString'.first（-1）/]</td>
              <td><i>无效</i></td>
            </tr>
            <tr>
              <td>['aString'.first（15）/]</td>
              <td>'ASTRING'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>index（subString：String）：整数</h2>
        <p>返回字符串“ <i>串</i> ”的“ <i>自我</i> ”的指数，或<i>“-1”，</i>如果“ <i>自我</i> ”不包含“ <i>串</i> ”的发生。重要说明：字符串索引从1开始。因此，字符串中的最后一个字符的索引等于字符串的长度。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.index（' A'）/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>[ 'aString'.index（' 字符串'）/]</td>
              <td>2</td>
            </tr>
            <tr>
              <td>[ 'aString'.index（' 烨'）/]</td>
              <td>-1</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>index（subString：String，index：Integer）：整数</h2>
        <p>返回字符串“ <i>串</i> ”的“ <i>自我</i> ”的指数，或<i>“-1”，</i>如果“ <i>自我</i> ”不包含“ <i>串</i> ”的发生从给定的“ <i>指数</i> ”开始。重要说明：字符串索引从1开始。因此，字符串中的最后一个字符的索引等于字符串的长度。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.index（'a'，1）/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['aString'.index（'a'，0）/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>['aString'.index（'String'， -  1）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>isAlpha（）：Boolean</h2>
        <p>如果“ <i>self</i> ”仅包含字母字符，则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.isAlpha（）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['aString1'.isAlpha（）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>isAlphanum（）：Boolean</h2>
        <p>如果“ <i>self</i> ”仅包含字母数字字符，则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.isAlphanum（）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['aString1'.isAlphanum（）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>last（n：Integer）：String</h2>
        <p>返回“ <i>自我</i> ”，或“ <i>自我</i> ”的最后<i>“n”</i>个字符，如果它的大小小于<i>“N”。</i>
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.last（1）/]</td>
              <td>'G'</td>
            </tr>
            <tr>
              <td>['aString'.last（0）/]</td>
              <td>“”</td>
            </tr>
            <tr>
              <td>['aString'.last（15）/]</td>
              <td>'ASTRING'</td>
            </tr>
            <tr>
              <td>['aString'.last（-1）/]</td>
              <td><i>无效</i></td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>lastIndex（subString：String）：整数</h2>
        <p>返回字符串“ <i>串</i> ”的“ <i>自我</i> ”的最后一个索引，或<i>“-1”，</i>如果“ <i>自我</i> ”不包含“ <i>串</i> ”的发生。重要说明：字符串索引从1开始。因此，字符串中的最后一个字符的索引等于字符串的长度。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.lastIndex（' I'）/]</td>
              <td>五</td>
            </tr>
            <tr>
              <td>[ 'aString'.lastIndex（' 烨'）/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>[ 'aStringa'.lastIndex（' A'）/]</td>
              <td>8</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>lastIndex（subString：String，index：Integer）：整数</h2>
        <p>返回字符串“ <i>串</i> ”的“ <i>自我</i> ”的最后一个索引，或<i>“-1”，</i>如果“ <i>自我</i> ”不包含“ <i>串</i> ”起来，以给定的“ <i>指数</i> ”的发生。此操作与Java操作“java.lang”具有相同的行为。串＃lastIndex的（java.lang中。String，int）“。重要说明：字符串索引从1开始。因此，字符串中的最后一个字符的索引等于字符串的长度。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aStringa'.lastIndex（'a'，3）/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex（'a'，8）/]</td>
              <td>8</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex（'a'， -  1）/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex（'i'，2）/]</td>
              <td>-1</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>matches（regex：String）：Boolean</h2>
        <p>如果“ <i>self</i> ”匹配给定的正则表达式模式“ <i>regex</i> ”， <i>则</i>返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。使用的正则表达式引擎是运行时JDK的引擎。给定的模式“按原样”传递给java类String的方法匹配。有关正则表达式的更多信息，请参阅JDK API文档。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['characters and spaces'.matches（'[\\ w \\ s] +'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>['characters and spaces'.matches（'[\\ d \\ s] +'）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>prefix（str：String）：String</h2>
        <p>返回以字符串“ <i>str</i> ”为前缀的“ <i>self</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.prefix（' PREFIX'）/]</td>
              <td>'PREFIXaString'</td>
            </tr>
            <tr>
              <td>[ 'aString'.prefix（''）/]</td>
              <td>'ASTRING'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>replace（subStringRegex：String，replacementRegex：String）：String</h2>
        <p>用“ <i>replacementRegex</i> ”字符串<i>替换</i> “ <i>self</i> ”中第一次出现的字符串“ <i>subStringRegex</i> ”，并返回结果字符串。如果不包含“ <i>subStringRegex</i> ”，则返回“ <i>self</i> ”。请注意，“ <i>subStringRegex</i> ”和“ <i>replacementRegex</i> ”都被视为正则表达式。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['replace operation'.replace（'p'，'P'）/]</td>
              <td>'rePlace操作'</td>
            </tr>
            <tr>
              <td>['repla ce operation'.replace（'（\\ w +）\\ s *'，'$ 1'）/]</td>
              <td>'替换操作'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>replaceAll（subStringRegex：String，replacementRegex：String）：String</h2>
        <p>替代品的所有字符串中的“ <i>自我</i> ”的字符串<i>“replacementRegex”，</i>并返回结果字符串<i>“subStringRegex”。</i>如果它不包含“ <i>subStringRegex</i> ”，则返回“ <i>self</i> ”。请注意，“ <i>subStringRegex</i> ”和“ <i>replacementRegex</i> ”都被视为正则表达式。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['replaceAll operation'.replaceAll（'p'，'P'）/]</td>
              <td>'rePlaceAll oPeration'</td>
            </tr>
            <tr>
              <td>['重写所有操作'.replaceAll（'（\\ w +）\\ s *'，'$ 1'）/]</td>
              <td>'ReplaceAllOperation'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>size（）：整数</h2>
        <p>返回组成“ <i>self</i> ”的字符数。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.size（）/]</td>
              <td>7</td>
            </tr>
            <tr>
              <td>[''。尺寸（）/]</td>
              <td>0</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>startsWith（subString：String）：Boolean</h2>
        <p>如果“ <i>self</i> ”以字符串“ <i>subString</i> ”开头，则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.startsWith（' 而aStr'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[ 'aString'.startsWith（' STR“）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[ 'aString'.startsWith（''）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>strcmp（str：String）：整数</h2>
        <p>返回一个负数，零或正数的整数，具体取决于“ <i>str</i> ”是按字母顺序小于，等于还是大于“ <i>self</i> ”。请注意，大写字母位于小写字母之前，因此'AA'更接近'AC'而不是'Ab'。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.strcmp（' 而aStr'）/]</td>
              <td>3</td>
            </tr>
            <tr>
              <td>[ 'aString'.strcmp（' A'）/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>strstr（str：String）：Boolean</h2>
        <p>在“ <i>self</i> ”中搜索字符串“ <i>str</i> ”。如果找到则返回“ <i>true</i> ”，否则返回“ <i>false</i> ”。此操作与“包含”相同。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[ 'aString'.strstr（' 而aStr'）/]</td>
              <td>真正</td>
            </tr>
            <tr>
              <td>[ 'aString'.strstr（' 烨'）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>strtok（str：String，n：Integer）：String</h2>
        <p>将“ <i>self</i> ”分解为一系列标记，每个标记由“ <i>str</i> ”中的任何一个字符分隔，并返回此序列中的下一个元素。当第一次调用strtok时，参数标志应该为“ <i>0</i> ”，并且随后将重置序列“ <i>1</i> ”以便访问下一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['aString'.strtok（'S'，0）/]</td>
              <td>'一个'</td>
            </tr>
            <tr>
              <td>['aString'.strtok（'S'，1）/]</td>
              <td>“特林”</td>
            </tr>
            <tr>
              <td>['aString'.strtok（'s'，0）/]</td>
              <td>'ASTRING'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>substitute（origin：String，replacement：String）：String</h2>
        <p>用字符串“ <i>replacement</i> ” <i>替换</i> “ <i>self</i> ”中的字符串“ <i>origin</i> ”，并返回结果字符串。如果它不包含字符串“ <i>origin</i> ”，则返回“ <i>self</i> ”。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['substitute operation'.substitute（'t'，'T'）/]</td>
              <td>'subsTitute operation'</td>
            </tr>
            <tr>
              <td>['substitute operation'.substitute（'Yop'，'T'）/]</td>
              <td>'替代操作'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>substituteAll（origin：String，replacement：String）：String</h2>
        <p>通过字符串“ <i>replacement</i> ” <i>替换</i> “ <i>self</i> ”中的所有字符串“ <i>origin</i> ”，并返回结果字符串。如果它不包含“ <i>origin</i> ”，则返回“ <i>self</i> ”。与replaceAll操作不同，“ <i>origin</i> ”和“ <i>replacement</i> ”都不被视为正则表达式。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['substituteAll operation'.substituteAll（'t'，'T'）/]</td>
              <td>'subsTiTuTeAll operaTion'</td>
            </tr>
            <tr>
              <td>['substituteAll operation'.substituteAll（'Yop'，'T'）/]</td>
              <td>'替代所有操作'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>substring（start：Integer）：String</h2>
        <p>返回self的子字符串，从startIndex（包括）开始，直到self结束。当startIndex为负，零或大于self的长度时返回Ø。重要说明：字符串索引从1开始。因此，字符串中的最后一个字符的索引等于字符串的长度。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['substring'.substring（1）/]</td>
              <td>“子”</td>
            </tr>
            <tr>
              <td>['substring'.substring（3）/]</td>
              <td>'bstring'</td>
            </tr>
            <tr>
              <td>['substring'.substring（0）/]</td>
              <td>无效</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>substring（start：Integer，end：Index）：String</h2>
        <p>返回一个字符串，其中包含self的所有字符，从索引下部开始，包括索引上部。低和高参数都应该包含在1和self.size（）之间。下限不能大于上限。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['substring'.substring（1,5）/]</td>
              <td>'SUBST'</td>
            </tr>
            <tr>
              <td>['substring'.substring（0,5）/]</td>
              <td>无效</td>
            </tr>
            <tr>
              <td>['substring'.substring（1，'substring'.size（））/]</td>
              <td>“子”</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toInteger（）：整数</h2>
        <p>返回值等于self的整数，如果self不表示整数，则返回Ø。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['5'.toInteger（）/]</td>
              <td>五</td>
            </tr>
            <tr>
              <td>['-1'.toInteger（）/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['five'.toInteger（）/]</td>
              <td>无效</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>tokenize（）：Sequence（String）</h2>
        <p>返回一个字符串序列，其中包含使用所有空格作为标记标记化的原始字符串的所有部分。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['这是一个字符串'.tokenize（）/]</td>
              <td>序列{'this'，'is'，'a'，'string'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>tokenize（subString：String）：Sequence（String）</h2>
        <p>返回一个序列，其中包含self分割的所有部分，其中分隔符由String delim中的字符定义。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['这是一个字符串'.tokenize（'i'）/]</td>
              <td>序列{'th'，'s'，'sa str'，'ng'}</td>
            </tr>
            <tr>
              <td>['这是一个字符串'.tokenize（'o'）/]</td>
              <td>序列{'这是一个字符串'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>tokenizeLine（）：Sequence（String）</h2>
        <p>返回一个序列，其中包含使用行分隔符定义的分隔符分割的self的所有部分。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['这是\ na \ r \ n string'.tokenizeLine（）/]</td>
              <td>序列{'this is'，'a'，'string'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toLower（）：String</h2>
        <p>返回self，所有字符都转换为小写。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['到LoWeR'.toLower（）/]</td>
              <td>'降低'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toLowerFirst（）：String</h2>
        <p>返回self的副本，其第一个字符转换为小写并返回它。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['到LoWeR First'.toLower（）/]</td>
              <td>'LoWeR First'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toReal（）：真实的</h2>
        <p>返回一个等于self的值，如果self不代表一个真值，则返回Ø。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['3.14'.toReal（）/]</td>
              <td>3.14</td>
            </tr>
            <tr>
              <td>['pi'.toReal（）/]</td>
              <td>无效</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toUpperFirst（）：String</h2>
        <p>返回self的副本，其第一个字符转换为大写并返回它。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['to upper first'.toUpperFirst（）/]</td>
              <td>'先上面'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>toUpper（）：String</h2>
        <p>返回self，所有字符都转换为大写。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['to upper'.toUpperFirst（）/]</td>
              <td>'上升'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>trim（）：String</h2>
        <p>删除所有前导和尾随空格字符（制表，空格，换行符......）自我
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['要修剪的文字'.trim（）/]</td>
              <td>'要修剪的文字'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        
        <hr>
        
        <h2>+（str：String）：String</h2>
        <p>用给定的字符串连接self。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>['你好'+'世界'/]</td>
              <td>'你好，世界'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="number">
        <div class="page-header">
          <h1><small>整数和浮点数上可用的</small>数字<small>运算。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>abs（）：数字</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>div（i：Integer）：整数（仅限整数）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>floor（）：数量</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>max（n：Number）：数字</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>min（n：Number）：数字</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>mod（i：Integer）：整数（仅整数）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>round（）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>abs（）：数字</h2>
        <p>如果已经为正数，则返回self，self的绝对值。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[3.14.abs（）/]</td>
              <td>3.14</td>
            </tr>
            <tr>
              <td>[-3.14.abs（）/]</td>
              <td>-3.14</td>
            </tr>
            <tr>
              <td>[ - （3.14.abs（））/]</td>
              <td>-3.14</td>
            </tr>
            <tr>
              <td>[（-3.14）。ABS（）/]</td>
              <td>3.14</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>div（i：Integer）：整数</h2>（仅限整数）<p>返回i的除法的整数商。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[5.div（2）/]</td>
              <td>2</td>
            </tr>
            <tr>
              <td>[5.div（0）/]</td>
              <td>无效</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>floor（）：数量</h2>
        <p>如果它是Real，则返回self的整数部分;如果是Integer，则返回self。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[5.9.floor（）/]</td>
              <td>五</td>
            </tr>
            <tr>
              <td>[3.1.floor（）/]</td>
              <td>3</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>max（n：Number）：数字</h2>
        <p>返回self和n之间的最大数字。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[3.1111.max（3.2）/]</td>
              <td>3.2</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>min（n：Number）：数字</h2>
        <p>返回self和n之间的最小数字。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[3.1111.min（3.2）/]</td>
              <td>3.1111</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>mod（i：Integer）：整数</h2>（仅限整数）<p>返回i的除法的整数余数。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[7.mod（3）/]</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        
        <hr>
        
        <h2>round（）：整数</h2>
        <p>如果它是Real，则返回最接近self的整数;如果是Integer，则返回self。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[5.9.round（）/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="boolean">
        <div class="page-header">
          <h1>布尔值<small>上的布尔运算。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>和（b：布尔值）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>implies（b：Boolean）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>或（b：布尔值）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>not（）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>xor（b：Boolean）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>和（b：布尔值）：布尔值</h2>
        <p>请参阅下表了解结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>真正</th>
              <th>假</th>
            </tr>
          </thead><colgroup><col width="40%"><col width="30%"><col width="30%"></colgroup>
          <tbody>
            <tr>
              <th>真正</th>
              <td>真正</td>
              <td>假</td>
            </tr>
            <tr>
              <th>假</th>
              <td>假</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">回到部分</a>
        
        <hr>
        
        <h2>implies（b：Boolean）：布尔值</h2>
        <p>请参阅下表了解结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>真正</th>
              <th>假</th>
            </tr>
          </thead><colgroup><col width="40%"><col width="30%"><col width="30%"></colgroup>
          <tbody>
            <tr>
              <th>真正</th>
              <td>真正</td>
              <td>假</td>
            </tr>
            <tr>
              <th>假</th>
              <td>真正</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">回到部分</a>
        
        <hr>
        
        <h2>或（b：布尔值）：布尔值</h2>
        <p>请参阅下表了解结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>真正</th>
              <th>假</th>
            </tr>
          </thead><colgroup><col width="40%"><col width="30%"><col width="30%"></colgroup>
          <tbody>
            <tr>
              <th>真正</th>
              <td>真正</td>
              <td>真正</td>
            </tr>
            <tr>
              <th>假</th>
              <td>真正</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">回到部分</a>
        
        <hr>
        
        <h2>not（b：Boolean）：布尔值</h2>
        <p>请参阅下表了解结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>真正</th>
              <th>假</th>
            </tr>
          </thead><colgroup><col width="50%"><col width="50%"></colgroup>
          <tbody>
            <tr>
              <td>假</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">回到部分</a>
        
        <hr>
        
        <h2>xor（b：Boolean）：布尔值</h2>
        <p>请参阅下表了解结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>真正</th>
              <th>假</th>
            </tr>
          </thead><colgroup><col width="40%"><col width="30%"><col width="30%"></colgroup>
          <tbody>
            <tr>
              <th>真正</th>
              <td>假</td>
              <td>真正</td>
            </tr>
            <tr>
              <th>假</th>
              <td>真正</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="collections">
        <div class="page-header">
          <h1>集合上<small>可用的</small>集合<small>操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="acceleo nonstandard">
              <td>addAll（collection：Collection（T））：Collection（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>any（expr：OclExpression）：OclAny</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>asBag（）：包（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>asOrderedSet（）：OrderedSet（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>asSequence（）：序列（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>asSet（）：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>collect（expr：OclExpression）：集合（T2）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>collectNested（expr：OclExpression）：集合（T2）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>count（elem：T）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>排除（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>excludesAll（c：Collection（T））：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>不包括（elem：T）：收藏品（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>exists（expr：OclExpression）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>filter（oclType：OclType）：集合（OclType）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>flatten（）：收藏（T2）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>forAll（expr：OclExpression）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>包括（elem：T）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>includesAll（c：Collection（T））：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>包括（elem：T）：收藏（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>isEmpty（）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>isUnique（expr：OclExpression）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>max（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>薄荷</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>notEmpty（）：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>one（expr：OclExpression）：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>product（c：Collection（T2））：Set（元组（第一个：T，第二个：T2））</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>reject（expr：OclExpression）：集合（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>removeAll（collection：Collection（T））：Collection（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>select（expr：OclExpression）：集合（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>sep（separator：String）：Sequence（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>sep（前缀：String，separator：String，suffix：String）：Sequence（OclAny）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>size（）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>sortedBy（expr：OclExpression）：序列（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>sum（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>addAll（collection：Collection（T））：Collection（T）</h2>
        <p>将给定集合的所有内容添加到当前集合中。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; addAll（Sequence {'d'，'e'，'f'}）/]</td>
              <td>[序列{'a'，'b'，'c'，'d'，'e'，'f'} /]</td>
            </tr>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; addAll（Sequence {'d'，'e'，'f'}）/]</td>
              <td>[OrderedSet {'a'，'b'，'c'，'d'，'e'，'f'} /]</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; addAll（Bag {'d'，'e'，'f'}）/]</td>
              <td>[序列{'a'，'b'，'c'，'f'，'e'，'d'} /]</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; addAll（Set {'d'，'e'，'f'}）/]</td>
              <td>[序列{'a'，'b'，'c'，'f'，'d'，'e'} /]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>any（expr：OclExpression）：OclAny</h2>
        <p>返回self中包含的任何验证条件expr的元素，否则返回null。只要找到验证expr的元素，评估就是快捷方式。请注意，如果多个元素验证expr，则无序集合的结果将是随机的。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'aWord'，'anotherWord'，'yetAnotherWord'}  - &gt; any（s：String | s.startsWith（'another'））/]</td>
              <td>'另一个词'</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>asBag（）：包（T）</h2>
        <p>返回包含self的所有元素的Bag。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; asBag（）/]</td>
              <td>包{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; asBag（）/]</td>
              <td>包{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; asBag（）/]</td>
              <td>包{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt; asBag（）/]</td>
              <td>包{'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>asOrderedSet（）：OrderedSet（T）</h2>
        <p>返回包含self的所有元素的OrderedSet。尽可能保留元素排序。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              </tr><tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; asOrderedSet（）/]</td>
              <td>OrderedSet {'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; asOrderedSet（）/]</td>
              <td>OrderedSet {'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; asOrderedSet（）/]</td>
              <td>OrderedSet {'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt; asOrderedSet（）/]</td>
              <td>OrderedSet {'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>asSequence（）：序列（T）</h2>
        <p>返回包含self的所有元素的Sequence。尽可能保留元素排序。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              </tr><tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; asSequence（）/]</td>
              <td>序列{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; asSequence（）/]</td>
              <td>序列{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; asSequence（）/]</td>
              <td>序列{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt; asSequence（）/]</td>
              <td>序列{'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>asSet（）：Set（T）</h2>
        <p>返回包含self的所有元素的Set。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              </tr><tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; asSet（）/]</td>
              <td>设置{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; asSet（）/]</td>
              <td>设置{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; asSet（）/]</td>
              <td>设置{'a'，'b'，'c'}</td>
            </tr>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt; asSet（）/]</td>
              <td>设置{'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>collect（expr：OclExpression）：集合（T2）</h2>
        <p>返回一个集合，其中包含对self中包含的所有元素应用expr的结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; collect（s：String | s.toUpper（））/]</td>
              <td>[序列{'A'，'B'，'C'} /]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>collectNested（expr：OclExpression）：集合（T2）</h2>
        <p>返回一个集合，其中包含我们应用OclExpression expr的self中包含的所有元素。结果不会扁平化。结果集合的类型取决于self的类型。
        </p>
        <p>示例：出于这些示例的目的，我们在此假设我们有一个带有引用子类的类Person。我们的模型包含两个人，例如person1.children = {'James'，'Jane'}和person2.children = {'John'}。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[self.persons-&gt; collectNested（children.firstname）/]</td>
              <td>[Sequence {Sequence {'James'，'Jane'}，Sequence {'John'}} /]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>count（elem：T）：整数</h2>
        <p>返回对象在集合self中的次数。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'，'d'，'a'}  - &gt; count（'a'）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>排除（elem：T）：布尔值</h2>
        <p>如果object不包含在self中，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;排除（'a'）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;排除（'d'）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>excludesAll（c：Collection（T））：Boolean</h2>
        <p>如果self中不包含c2元素，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; excludesAll（Sequence {'a'，'d'}）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;不包括所有（序列{'d'，'f'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>不包括（elem：T）：收藏品（T）</h2>
        <p>返回一个集合，其中包含self的所有元素减去对象的所有出现。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;不包括（'a'）/]</td>
              <td>序列{'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>exists（expr：OclExpression）：Boolean</h2>
        <p>如果self中至少有一个元素验证条件expr，则返回true，否则返回false。一旦找到一个元素验证expr，评估就会停止。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt;存在（s：String | s.size（）&gt; 1）/]</td>
              <td>假</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'cccc'}  - &gt; exists（s：String | s.size（）&gt; 1）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>filter（oclType：OclType）：集合（OclType）</h2>
        <p>从集合中过滤掉所有不是给定类型或其任何子类型的实例的元素。返回的集合根据类型键入。使select（e | e.oclIsKindOf（oclType））。oclAsType（oclType）更容易编写。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{第一个儿童包，第二个儿童包，第三个元素}  - &gt;过滤器（EClass）/]</td>
              <td>序列{元素三}</td>
            </tr>
            <tr>
              <td>[序列{第一个儿童套餐，第二个儿童套餐，元素三}  - &gt;过滤器（EPackage）/]</td>
              <td>序列{第一个儿童套餐，第二个儿童套餐}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>flatten（）：收藏（T2）</h2>
        <p>返回包含self递归展平的所有元素的集合。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{序列{'a'，'b'，'c'}，序列{'a'}} /]</td>
              <td>序列{'a'，'b'，'c'，'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>forAll（expr：OclExpression）：布尔值</h2>
        <p>如果self中包含的所有元素都验证条件expr，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; forAll（s：String | s.startsWith（'a'））/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>包括（elem：T）：布尔值</h2>
        <p>如果object包含在self中，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;包括（'a'）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>includesAll（c：Collection（T））：Boolean</h2>
        <p>如果c2的所有元素都包含在self中，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; includesAll（Sequence {'a'，'b'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>包括（elem：T）：收藏（T）</h2>
        <p>返回一个集合，其中包含self后跟object的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt;包括（'a'）/]</td>
              <td>序列{'a'，'b'，'c'，'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>isEmpty（）：Boolean</h2>
        <p>如果self为空，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; isEmpty（）/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>isUnique（expr：OclExpression）：Boolean</h2>
        <p>如果self中包含的所有元素都计算为expr的不同值，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'，'a'}  - &gt; isUnique（s：String | s.toUpper（））/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>max（）：T</h2>
        <p>具有self中所有元素的最大值的元素。元素必须是支持max操作的类型。最大操作 - 由元素支持 - 必须采用T类型的一个参数，并且既是关联的又是可交换的。UnlimitedNatural，Integer和Real满足这个条件。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{5,9,2}  - &gt; max（）/]</td>
              <td>9</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>薄荷</h2>
        <p>具有self中所有元素的最小值的元素。元素必须是支持min操作的类型。min操作 - 由元素支持 - 必须采用T类型的一个参数，并且既是关联的又是可交换的。UnlimitedNatural，Integer和Real满足这个条件。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{5,9,2}  - &gt; min（）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>notEmpty（）：Boolean</h2>
        <p>如果self包含至少一个元素，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; notEmpty（）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>one（expr：OclExpression）：布尔值</h2>
        <p>如果self中只包含一个验证条件expr的元素，则返回true，否则返回false。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; one（s：String | s.startsWith（'z'））/]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>product（c：Collection（T2））：Set（元组（第一个：T，第二个：T2））</h2>
        <p>返回一组元组，表示使用c2的self的笛卡尔积。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'}  - &gt;产品（序列{1,2}）/]</td>
              <td>设置{Tuple {'a'，1}，Tuple {'b'，1}，Tuple {'b'，2}，Tuple {'a'，2}}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>reject（expr：OclExpression）：集合（T）</h2>
        <p>返回包含self的所有元素的集合，但验证OclExpression expr的除外。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; reject（s：String | s.startsWith（'b'））/]</td>
              <td>序列{'a'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>removeAll（collection：Collection（T））：Collection（T）</h2>
        <p>从当前集合中删除给定集合的所有内容。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; removeAll（Sequence {'b'，'c'}）/]</td>
              <td>序列{“一个”}</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; removeAll（Bag {'b'，'c'}）/]</td>
              <td>序列{“一个”}</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; removeAll（OrderedSet {'b'，'c'}）/]</td>
              <td>序列{“一个”}</td>
            </tr>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; removeAll（Set {'b'，'c'}）/]</td>
              <td>序列{“一个”}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>select（expr：OclExpression）：集合（T）</h2>
        <p>返回一个包含self的所有元素的集合，用于验证OclExpression expr。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; select（s：String | not s.startsWith（'a'））/]</td>
              <td>序列{'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>sep（分隔符：字符串）：集合（OclAny）</h2>
        <p>返回源集合中的所有元素，这些元素由由String分隔符组成的元素分隔。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt; sep（'哈哈'）/]</td>
              <td>序列{'a'，'haha'，'b'，'haha'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>sep（前缀：String，separator：String，suffix：String）：Collection（OclAny）</h2>
        <p>返回源集合中的所有元素，这些元素由一个由String分隔符组成的元素分隔，前缀作为集合的第一个元素，后缀作为集合的最新元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; sep（'prefix'，'haha'，'suffix'）/]</td>
              <td>序列{'前缀'，'a'，'哈哈'，'b'，'哈哈'，'c'，'后缀'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>size（）：整数</h2>
        <p>返回self中包含的元素数。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; size（）/]</td>
              <td>3</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>sortedBy（expr：OclExpression）：序列（T）</h2>
        <p>返回一个有序集合，其中包含根据OclExpression expr自排序的所有元素。这可以在所有类型的集合上使用，但除了返回OrderedSet的OrderedSet之外，它总是会产生一个Sequence类型的结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'aaaa'，'bb'，'ccc'}  - &gt; sortedBy（s：String | s.size（））/]</td>
              <td>序列{'bb'，'ccc'，'aaaa'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        
        <hr>
        
        <h2>sum（）：T</h2>
        <p>在自我中添加所有元素。元素必须是支持+操作的类型。+操作必须采用类型T的一个参数并且都是关联的：（a + b）c = a（b + c），并且可交换：a + b = b + a。UnlimitedNatural，Integer和Real满足这个条件。如果+运算不是关联的和可交换的，则和表达式不是很好，这可能在评估期间导致不可预测的结果。如果实现能够检测到缺乏关联性或可交换性，则实现可能会绕过评估并返回无效结果。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{1,2,3}  - &gt; sum（）/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="sequence">
        <div class="page-header">
          <h1>序列上<small>可用的</small>序列<small>操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>=（seq：Sequence（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（seq：Sequence（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>追加（elem：T）：序列（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>at（index：Integer）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>drop（n：Integer）：序列（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>dropRight（n：Integer）：序列（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith（subCollection：OrderedSet（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith（subCollection：Sequence（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>first（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>indexOf（elem：T）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice（subCollection：OrderedSet（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice（subCollection：Sequence（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>insertAt（index：Integer，elem：T）：Sequence（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>last（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOf（elem：T）：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice（subCollection：OrderedSet（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice（subCollection：Sequence（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>前置（elem：T）：序列（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>reverse（）：序列（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith（subCollection：OrderedSet（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith（subCollection：Sequence（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>subSequence（startIndex：Integer，endIndex：Integer）：Sequence（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>联合（c：序列（T））：序列（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>=（seq：Sequence（T））：布尔值</h2>
        <p>如果self包含与seq完全相同的对象，则返回true，顺序与seq中的顺序完全相同。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'} =序列{'a'，'b'，'c'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（seq：Sequence（T））：布尔值</h2>
        <p>如果self不包含与seq相同的对象，或者这些对象的顺序与seq中的顺序不同，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'} &lt;&gt;序列{'a'，'b'，'c'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>追加（elem：T）：序列（T）</h2>
        <p>返回一个Sequence，其中包含self后跟object的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}。追加（'d'）/]</td>
              <td>序列{'a'，'b'，'c'，'d'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>at（index：Integer）：T</h2>
        <p>返回索引位置的self元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt; at（1）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>drop（n：Integer）：序列（T）</h2>
        <p>删除n个第一个元素后返回集合。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[序列{'a'，'b'，'c'}  - &gt; drop（2）/]</td>
              <td>'C'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>dropRight（n：Integer）：序列（T）</h2>
        <p>删除n个最新元素后返回集合。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; dropRight（2）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>endsWith（subCollection：OrderedSet（T））：Boolean</h2>
        <p>指示自我集合是否以给定的子集合结束。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; endsWith（OrderedSet {'b'，'c'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>endsWith（subCollection：Sequence（T））：Boolean</h2>
        <p>指示自我集合是否以给定的子集合结束。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; endsWith（Sequence {'b'，'c'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>first（）：T</h2>
        <p>返回序列的第一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; first（）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>indexOf（elem：T）：整数</h2>
        <p>返回序列self中对象的位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; indexOf（'a'）/]</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>indexOfSlice（subCollection：Sequence（T））：整数</h2>
        <p>返回序列self中子集合的位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; indexOfSlice（Sequence {'b'，'c'}）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>indexOfSlice（subCollection：OrderedSet（T））：整数</h2>
        <p>返回序列self中子集合的位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; indexOfSlice（OrderedSet {'b'，'c'}）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>insertAt（index：Integer，elem：T）：Sequence（T）</h2>
        <p>返回包含self的Sequence，其中对象插入索引位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; insertAt（1，'z'）/]</td>
              <td>序列{'z'，'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>last（）：T</h2>
        <p>返回self的最后一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; last（）/]</td>
              <td>'C'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOf（elem：T）：整数</h2>
        <p>返回序列self中对象elem的最后位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'，'a'}  - &gt; lastIndexOf（'a'）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOfSlice（subCollection：Sequence（T））：整数</h2>
        <p>返回序列self中子集合的最后位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'，'b'，'c'}  - &gt; lastIndexOfSlice（Sequence {'b'，'c'}）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOfSlice（subCollection：OrderedSet（T））：整数</h2>
        <p>返回序列self中子集合的最后位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'，'b'，'c'}  - &gt; lastIndexOfSlice（OrderedSet {'b'，'c'}）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>前置（elem：T）：序列（T）</h2>
        <p>返回包含对象的Sequence，后跟self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; prepend（'z'）/]</td>
              <td>序列{'z'，'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>reverse（）：序列（T）</h2>
        <p>反转集合的顺序：最后一个元素成为第一个元素，反之亦然。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; reverse（）/]</td>
              <td>序列{'c'，'b'，'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>startsWith（subCollection：Sequence（T））：Boolean</h2>
        <p>如果self以给定的子集合开始，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; startsWith（Sequence {'a'，'b'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>startsWith（subCollection：OrderedSet（T））：Boolean</h2>
        <p>如果self以给定的子集合开始，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; startsWith（OrderedSet {'a'，'b'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>subSequence（startIndex：Integer，endIndex：Integer）：Sequence（T）</h2>
        <p>返回包含位置'startIndex'和'endIndex'之间的所有self元素的Sequence。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; subSequence {1,2} /]</td>
              <td>序列{'a'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        
        <hr>
        
        <h2>联合（c：序列（T））：序列（T）</h2>
        <p>返回一个Sequence，其中包含self的所有元素，后跟seq的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Sequence {'a'，'b'，'c'}  - &gt; union（Sequence {'d'，'e'}）/]</td>
              <td>序列{'a'，'b'，'c'，'d'，'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="orderedset">
        <div class="page-header">
          <h1>有序集上<small>可用的</small>有序集<small>操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>=（c：Set（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>=（c：OrderedSet（T））：Boolean</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（c：Set（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（c：Set（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>- （c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>append（elem：T）：OrderedSet（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>at（index：Integer）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>drop（n：Integer）：OrderedSet（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>dropRight（n：Integer）：OrderedSet（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith（subCollection：OrderedSet（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith（subCollection：Sequence（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>first（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>indexOf（elem：T）：整数</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice（subCollection：OrderedSet（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice（subCollection：Sequence（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>insertAt（index：Integer，elem：T）：OrderedSet（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交叉点（c：Bag（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交集（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>last（）：T</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOf（elem：T）：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice（subCollection：OrderedSet（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice（subCollection：Sequence（T））：整数</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>prepend（elem：T）：OrderedSet（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>reverse（）：OrderedSet（T）</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith（subCollection：OrderedSet（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith（subCollection：Sequence（T））：Boolean</td>
              <td>Acceleo</td>
              <td>没有</td>
            </tr>
            <tr class="ocl standard">
              <td>subOrderedSet（startIndex：Integer，endIndex：Integer）：OrderedSet（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>symmetricDifference（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>联合（c：Bag（T））：Bag（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>union（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>=（c：Set（T））：布尔值</h2>
        <p>如果self包含与set相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'} =设置{'a'，'b'，'c'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>=（c：OrderedSet（T））：Boolean</h2>
        <p>如果self包含与orderedset相同的对象，则返回true，而不管元素排序如何。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'} = OrderedSet {'a'，'b'，'c'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（c：Set（T））：布尔值</h2>
        <p>如果self不包含与set相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'} &lt;&gt;设置{'a'，'b'，'c'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（c：Set（T））：布尔值</h2>
        <p>如果self不包含与orderedset相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'} &lt;&gt; OrderedSet {'a'，'b'，'c'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>- （c：Set（T））：Set（T）</h2>
        <p>返回一个包含self的所有元素减去c的所有元素的Set。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - 设置{'a'，'c'} /]</td>
              <td>OrderedSet { 'B'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>append（elem：T）：OrderedSet（T）</h2>
        <p>返回一个OrderedSet，其中包含self后跟object的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt;追加（'d'）/]</td>
              <td>OrderedSet {'a'，'b'，'c'，'d'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>at（index：Integer）：T</h2>
        <p>返回位于集合中位置索引处的self元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; at（1）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>drop（n：Integer）：OrderedSet（T）</h2>
        <p>返回一个有序集，其中包含self的所有元素减去n个第一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; drop（2）/]</td>
              <td>OrderedSet { 'C'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>dropRight（n：Integer）：OrderedSet（T）</h2>
        <p>返回一个有序集，其中包含self的所有元素减去n个最后元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; dropRight（2）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>endsWith（subCollection：OrderedSet（T））：Boolean</h2>
        <p>指示self是否以给定的子集合结束。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; endsWith（OrderedSet {'b'，'c'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>endsWith（subCollection：Sequence（T））：Boolean</h2>
        <p>指示self是否以给定的子集合结束。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; endsWith（Sequence {'b'，'c'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>first（）：T</h2>
        <p>返回self的第一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; first（）/]</td>
              <td>'一个'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>indexOf（elem：T）：整数</h2>
        <p>返回elem在self中的位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; indexOf（'b'）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>indexOfSlice（subCollection：OrderedSet（T））：整数</h2>
        <p>返回self中子集的索引。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; indexOfSlice（OrderedSet {'b'，'c'}）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>indexOfSlice（subCollection：Sequence（T））：整数</h2>
        <p>返回self中子集的索引。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; indexOfSlice（Sequence {'b'，'c'}）/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>insertAt（index：Integer，elem：T）：OrderedSet（T）</h2>
        <p>返回包含self的OrderedSet，其中对象插入索引位置。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; insertAt（1，'z'）/]</td>
              <td>OrderedSet {'z'，'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>交叉点（c：Bag（T））：Set（T）</h2>
        <p>返回一个Set，其中包含c所包含的self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt;交集（Bag {'a'，'b'}）/]</td>
              <td>设置{'a'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>交集（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含c所包含的self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt;交集（设置{'a'，'b'}）/]</td>
              <td>设置{'a'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>last（）：T</h2>
        <p>返回self的最后一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; last（）/]</td>
              <td>'C'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOf（elem：T）：整数</h2>
        <p>返回self中elem的最后一个索引。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'，'b'}  - &gt; lastIndexOf（'b'）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOfSlice（subCollection：OrderedSet（T））：整数</h2>
        <p>返回self中给定子集合的最后一个索引。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'，'b'，'c'}  - &gt; lastIndexOfSlice（OrderedSet {'b'，'c'}）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>lastIndexOfSlice（subCollection：Sequence（T））：整数</h2>
        <p>返回self中给定子集合的最后一个索引。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'，'b'，'c'}  - &gt; lastIndexOfSlice（Sequence {'b'，'c'}）/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>prepend（elem：T）：OrderedSet（T）</h2>
        <p>返回包含对象的OrderedSet，后跟self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; prepend（'z'）/]</td>
              <td>OrderedSet {'z'，'a'，'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2reverse(): orderedset(t)<="" /h2="">
        <p>返回自反转，第一个元素成为最后一个元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; reverse（）/]</td>
              <td>OrderedSet {'c'，'b'，'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>startsWith（subCollection：OrderedSet（T））：Boolean</h2>
        <p>指示self是否以给定的子集合开头。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; startsWith（OrderedSet {'a'，'b'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>startsWith（subCollection：Sequence（T））：Boolean</h2>
        <p>指示self是否以给定的子集合开头。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; startsWith（Sequence {'a'，'b'}）/]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>subOrderedSet（startIndex：Integer，endIndex：Integer）：OrderedSet（T）</h2>
        <p>返回包含位置startIndex和endIndex之间的self的所有元素的OrderedSet。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; subOrderedSet（1,2）/]</td>
              <td>OrderedSet {'a'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>symmetricDifference（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含self和set中不存在的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; symmetricDifference（Set {'a'}）/]</td>
              <td>设置{'b'，'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>联合（c：Bag（T））：Bag（T）</h2>
        <p>返回一个Bag，其中包含self的所有元素，后跟bag的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; union（Bag {'d'，'e'}）/]</td>
              <td>包{'a'，'b'，'c'，'d'，'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        
        <hr>
        
        <h2>union（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含self的所有元素，后跟set的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet {'a'，'b'，'c'}  - &gt; union（设置{'d'，'e'}）/]</td>
              <td>设置{'a'，'b'，'c'，'d'，'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">回到部分</a>
        <br>
        <br>
      </h2reverse():></section>
      
      <section id="set">
        <div class="page-header">
          <h1><small>在集上设置可用的操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>=（c：Set（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（c：Set（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>- （c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交叉点（c：Bag（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交集（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>symmetricDifference（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>联合（c：Bag（T））：Bag（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>union（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>=（c：Set（T））：布尔值</h2>
        <p>如果self包含与c相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'} =设置{'b'，'c'，'a'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（c：Set（T））：布尔值</h2>
        <p>如果self不包含与c相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'} &lt;&gt;设置{'b'，'c'，'a'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>- （c：Set（T））：Set（T）</h2>
        <p>返回一个包含self的所有元素减去set的所有元素的Set。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - 设置{'a'} /]</td>
              <td>设置{'c'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>交叉点（c：Bag（T））：Set（T）</h2>
        <p>返回一个Set，其中包含c中也包含的self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt;交集（Bag {'a'}）/]</td>
              <td>设置{ 'A'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>交集（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含c中也包含的self的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt;交集（设置{'a'}）/]</td>
              <td>设置{ 'A'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>symmetricDifference（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含self和set中不存在的所有元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; symmetricDifference（设置{'b'，'c'，'d'}）/]</td>
              <td>设置{'a'，'d'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>联合（c：Bag（T））：Bag（T）</h2>
        <p>返回包含self的所有元素和bag的所有元素的Bag。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; union（Bag {'a'}）/]</td>
              <td>包{'a'，'a'，'c'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        
        <hr>
        
        <h2>union（c：Set（T））：Set（T）</h2>
        <p>如果self包含与set相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[设置{'a'，'b'，'c'}  - &gt; union（设置{'d'}）/]</td>
              <td>设置{'d'，'b'，'c'，'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">回到部分</a>
        <br>
        <br>
      </section>
      
      <section id="bag">
        <div class="page-header">
          <h1>袋子<small>上的袋子操作。</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>手术</th>
              <th>起源</th>
              <th>标准</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>=（c：Bag（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt;（c：Bag（T））：布尔值</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交叉口（c：Bag（T））：Bag（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>交集（c：Set（T））：Set（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>联合（c：Bag（T））：Bag（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
            <tr class="ocl standard">
              <td>联合（c：Set（T））：Bag（T）</td>
              <td>OCL</td>
              <td>是</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">回到顶部</a>
        <hr>
        
        <h2>=（c：Bag（T））：布尔值</h2>
        <p>如果self包含相同数量的bag相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Bag {'a'，'b'，'c'} = Bag {'c'，'b'，'a'} /]</td>
              <td>真正</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">回到部分</a>
        
        <hr>
        
        <h2>&lt;&gt;（c：Bag（T））：布尔值</h2>
        <p>如果self不包含与bag相同的对象，则返回true。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Bag {'a'，'b'，'c'} &lt;&gt; Bag {'b'，'a'，'c'} /]</td>
              <td>假</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">回到部分</a>
        
        <hr>
        
        <h2>交叉口（c：Bag（T））：Bag（T）</h2>
        <p>返回一个包含自包含的所有self元素的Bag。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt;十字路口（Bag {'a'}）/]</td>
              <td>袋{“一个”}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">回到部分</a>
        
        <hr>
        
        <h2>交集（c：Set（T））：Set（T）</h2>
        <p>返回一个Set，其中包含self所包含的所有self元素。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt;交集（设置{'a'}）/]</td>
              <td>设置{ 'A'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">回到部分</a>
        
        <hr>
        
        <h2>联合（c：Bag（T））：Bag（T）</h2>
        <p>返回包含self的所有元素和bag的所有元素的Bag。
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>表达</th>
              <th>结果</th>
            </tr>
          </thead><colgroup><col width="60%"><col width="40%"></colgroup>
          <tbody>
            <tr>
              <td>[Bag {'a'，'b'，'c'}  - &gt; union（Bag {'a'，'d'}）/]</td>
              <td>包{'a'，'d'，'c'，'a'，'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">回到部分</a>
        
        <br>
        <br>
      </section>
      
      <footer class="footer">
        <p>这些指南中的材料是版权所有（c）2008,2012 Obeo。该材料可在Eclipse Public License v1.0下获得</p>
      </footer>
    </div>
  </body>
</html>