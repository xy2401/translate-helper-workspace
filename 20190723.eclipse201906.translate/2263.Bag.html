<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>袋（T）</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library"></link>
<link rel="prev" href="StandardLibrary.html" title="The OCL Standard Library"></link>
<link rel="next" href="Boolean.html" title="Boolean"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">袋（T）</h1>
<div class="section" title="袋（T）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Bag"></a>
				<span class="bold"><strong>
					<code class="code">Bag(T)</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>包是一个允许重复的集合。也就是说，一个物体可以多次成为袋子的元素。袋子中的元素没有定义排序。Bag本身就是元型BagType的一个实例。</p>
<p>conformsTo <a class="link" href="Collection.html" title="集合（T）"><code class="code">Collection(T)</code></a>
			
</p>
<p>
				
<span class="bold"><strong>操作</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>如果<code class="code">self</code>和bag包含相同的元素，则相同，则为真。
			</p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">排除（对象：OclAny [？]）：Bag（T）</code>
			
</p>
<p>包含除了所有对象之外的所有<code class="code">self</code>元素的包。
			</p>
<p>
				
<code class="code">excludedAll（objects：Collection（OclAny））：Bag（T）</code>
			
</p>
<p>包含所有<code class="code">self</code>元素的包，除了所有对象的出现。
			</p>
<p>
				
<code class="code">压扁（T2）（）：袋（T2）</code>
			
</p>
<p>重新定义Collection操作。如果元素类型不是集合类型，则会生成与<code class="code">self</code>相同的包。如果元素类型是集合类型，则结果是包含<code class="code">self</code>的所有递归展平元素的所有元素的包。
			</p>
<p>
				
<code class="code">包括（物体：T [？]）：袋（T）</code>
			
</p>
<p>包含<code class="code">self</code>加上对象的所有元素的包。
			</p>
<p>
				
<code class="code">包括所有（对象：Collection（T））：Bag（T）</code>
			
</p>
<p>包含<code class="code">self</code>和物体的所有元素的包。
			</p>
<p>
				
<code class="code">selectByKind（TT）（类型：TT [？]）：Bag（TT）</code>
			
</p>
<p>
				
<code class="code">selectByType（TT）（类型：TT [？]）：Bag（TT）</code>
			
</p>
<p>
				
<span class="bold"><strong>迭代</strong></span>
			
</p>
<p>
				
<code class="code">闭包（i：T [1] | lambda：Lambda T（）：Set（T）[？]）：Set（T）</code>
			
</p>
<p>将物体传递到源集合的每个不同元素的封闭。</p>
<p>
				
<code class="code">收集（V）（i：T [？]| lambda：Lambda T（）：V [？]）：Bag（V）</code>
			
</p>
<p>
				
<code class="code">collectNested（V）（i：T [？]| lambda：Lambda T（）：V [？]）：Bag（V）</code>
			
</p>
<p>通过将body应用于源无序集合的每个成员而产生的元素包。</p>
<p>
				
<code class="code">拒绝（i：T [？]| lambda：Lambda T（）：Boolean [1]）：Bag（T）</code>
			
</p>
<p>身体<code class="code">false</code>的源袋的子袋。
			</p>
<div class="literallayout">
<p>
<code class="code">self-&gt; reject（iterator | body）= self-&gt; select（iterator | not body）<br>

</code>
</p>
</div>
<p></p>
<p>。</p>
<p>
				
<code class="code">选择（i：T [？]| lambda：Lambda T（）：Boolean [1]）：Bag（T）</code>
			
</p>
<p>身体成<code class="code">true</code>源袋的子袋。
			</p>
<div class="literallayout">
<p>
<code class="code">self-&gt; select（iterator | body）=<br>self-&gt; iterate（迭代器;结果：Bag（T）= Bag {} |<br>如果身体然后结果 - &gt;包括（迭代器）<br>否则结果<br>万一）<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">sortedBy（i：T [？]| lambda：Lambda T（）：OclAny [？]）：序列（T）</code>
			
</p>
<p>包含源集合的所有元素的Sequence中的结果。首先是身体具有最低值的元素，依此类推。正文表达式的类型必须具有&lt;operation defined。&lt;operation必须返回一个布尔值并且必须是可传递的（即，如果a &lt;b且b &lt;c则a &lt;c）。</p>
</div>
</body>
</html>