<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>袋（T）</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library">
<link rel="prev" href="StandardLibrary.html" title="The OCL Standard Library">
<link rel="next" href="Boolean.html" title="Boolean">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">袋（T）</h1>
<div class="section" title="袋（T）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Bag"></a>
				<span class="bold"><strong>
					<code class="code">Bag(T)</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>包是一个允许重复的集合。也就是说，一个物体可以多次成为袋子的元素。袋子中的元素没有定义排序。Bag本身就是元型BagType的一个实例。</p>
<p>conformsTo <a class="link" href="Collection.html" title="集合（T）"><code class="code">Collection(T)</code></a>
			
</p>
<p>
				
<span class="bold"><strong>操作</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>如果<code class="code">self</code>和bag包含相同的元素，则相同，则为真。
			</p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">excluding(object : OclAny[?]) : Bag(T)</code>
			
</p>
<p>包含除了所有对象之外的所有<code class="code">self</code>元素的包。
			</p>
<p>
				
<code class="code">excludingAll(objects : Collection(OclAny)) : Bag(T)</code>
			
</p>
<p>包含所有<code class="code">self</code>元素的包，除了所有对象的出现。
			</p>
<p>
				
<code class="code">flatten(T2)() : Bag(T2)</code>
			
</p>
<p>重新定义Collection操作。如果元素类型不是集合类型，则会生成与<code class="code">self</code>相同的包。如果元素类型是集合类型，则结果是包含<code class="code">self</code>的所有递归展平元素的所有元素的包。
			</p>
<p>
				
<code class="code">including(object : T[?]) : Bag(T)</code>
			
</p>
<p>包含<code class="code">self</code>加上对象的所有元素的包。
			</p>
<p>
				
<code class="code">includingAll(objects : Collection(T)) : Bag(T)</code>
			
</p>
<p>包含<code class="code">self</code>和物体的所有元素的包。
			</p>
<p>
				
<code class="code">selectByKind(TT)(type : TT[?]) : Bag(TT)</code>
			
</p>
<p>
				
<code class="code">selectByType(TT)(type : TT[?]) : Bag(TT)</code>
			
</p>
<p>
				
<span class="bold"><strong>迭代</strong></span>
			
</p>
<p>
				
<code class="code">closure(i : T[1] | lambda : Lambda T() : Set(T)[?]) : Set(T)</code>
			
</p>
<p>将物体传递到源集合的每个不同元素的封闭。</p>
<p>
				
<code class="code">collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)</code>
			
</p>
<p>
				
<code class="code">collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)</code>
			
</p>
<p>通过将body应用于源无序集合的每个成员而产生的元素包。</p>
<p>
				
<code class="code">reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Bag(T)</code>
			
</p>
<p>身体<code class="code">false</code>的源袋的子袋。
			</p>
<div class="literallayout">
<p>
<code class="code">self-&gt;reject(iterator&nbsp;|&nbsp;body)&nbsp;=&nbsp;self-&gt;select(iterator&nbsp;|&nbsp;not&nbsp;body)<br>

</code>
</p>
</div>
<p></p>
<p>。</p>
<p>
				
<code class="code">select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Bag(T)</code>
			
</p>
<p>身体成<code class="code">true</code>源袋的子袋。
			</p>
<div class="literallayout">
<p>
<code class="code">self-&gt;select(iterator&nbsp;|&nbsp;body)&nbsp;=<br>
self-&gt;iterate(iterator;&nbsp;result&nbsp;:&nbsp;Bag(T)&nbsp;=&nbsp;Bag{}&nbsp;|<br>
if&nbsp;body&nbsp;then&nbsp;result-&gt;including(iterator)<br>
else&nbsp;result<br>
endif)<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : Sequence(T)</code>
			
</p>
<p>包含源集合的所有元素的Sequence中的结果。首先是身体具有最低值的元素，依此类推。正文表达式的类型必须具有&lt;operation defined。&lt;operation必须返回一个布尔值并且必须是可传递的（即，如果a &lt;b且b &lt;c则a &lt;c）。</p>
</div>
</body>
</html>