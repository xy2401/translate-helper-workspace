<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>GEF MVC开发人员文档</title>
		<link type="text/css" rel="stylesheet" href="../../book.css">
	</head>
	<body >
		<p>
			<em>非维基读者注意：本文档是从GEF@github.com维基生成的 - 如果您有更正或补充，如果您可以将它们贡献给<a href="https://github.com/eclipse/gef/wiki/MVC" target="doc_external">原始维基页面，</a>那将非常棒</em> 。
		</p>
		<h2 id="introduction">介绍</h2>
		<p><span style="color:#05124e"><a href="MVC.html">MVC</a></span>组件支持基于模型 - 视图 - 控制器架构构建图形应用程序。它由两个模块内部组成，这两个模块提供特定于JavaFX的抽象（ <strong><a href="MVC.html#mvcfx">MVC.FX</a></strong> ）和相关的Eclipse UI集成（ <strong><a href="MVC.html#mvcfxui">MVC.FX.UI</a></strong> ）。此外，还有部署的<a href="https://github.com/eclipse/gef/wiki/MVC-Logo-Example#logo-example-standalone-eclipse-ui-web" title="wikilink" target="doc_external">MVC徽标示例</a> 。
		</p>
		<p>
			<img alt="" border="0" src="images/mvc/components.mvc.jpeg">
		</p>
		<hr>
		<h2 id="mvc-fx">MVC.FX</h2>
		<ul>
			<li>
				<strong>功能：org.eclipse.gef.mvc.fx</strong>
			</li>
			<li>
				<strong>bundle：org.eclipse.gef.mvc.fx</strong>
			</li>
		</ul>
		<p>正如其名称所示， <a href="MVC.html">MVC</a>的<a href="MVC.html#mvcfx">MVC.FX</a>模块提供了一个模型 - 视图 - 控制器架构，可用于构建图形编辑器和视图。它与<a href="http://docs.oracle.com/javase/8/javase-clienttechnologies.htm" target="doc_external">JavaFX</a>绑定，但提供独立于Eclipse UI的抽象和实现。</p>
		<p>在<a href="https://www.eclipse.org/gef/gef_mvc/index.php" target="doc_external">GEF（MVC）3.x的</a>良好传统中，'控制器'被称为“部件”，而这里使用术语“可视部件”而不是“编辑部件”来描述MVC框架不限于编辑一个人。因此，图形应用程序由一个或多个<em>查看</em> <em>器</em>组成，其中每个<em>查看器</em> （ <a href="MVC.html#iviewer">IViewer</a> ）由一组<em>可视部件</em> （ <a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ）填充，该<em>部件</em>控制在查看器控件内呈现的视觉效果。负责控制可视化内容的那些<em>视觉部分</em>被称为<em>内容部分</em> （ <a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a> ）。它们伴随着<em>反馈部分</em> （ <a href="MVC.html#ifeedbackpart-abstractfeedbackpart">IFeedbackPart</a> ）和<em>处理部分</em> （ <a href="MVC.html#ihandlepart-abstracthandlepart">IHandlePart</a> ），它们不控制可视化内容，而是反馈或处理用户交互所需的视觉效果。所有可视部分都按层次结构排列（类似于视觉效果的层次结构），这些部分以“根部分”（ <a href="MVC.html#irootpart-layeredrootpart">IRootPart</a> ）为根。
		</p>
		<p>除了建立层次结构的<em>父子</em>关系之外， <em>视觉部分</em>还可以通过<em>锚定 - 锚定</em>关系彼此相关。也就是说，放置在层级内的任意位置的<em>视觉部分</em>可以<em>锚定</em>在另一个<em>锚固</em>部分上。由于视觉部分层次结构必须与视觉层次结构相对应，因此当控制放置在视觉层次结构中任意位置的视觉效果的部件必须彼此相关时，此机制非常有用。在通常将视觉组织成图层的图形应用程序中，它可以用于更新反馈或句柄。通过在底层（ <em>锚定</em> ）目标<em>内容</em> <em>部分</em>上明确地锚定<em>反馈部分</em> ， <em>反馈部分</em>尤其获得必要的钩子以监听<em>内容部分</em>视觉的变化（例如，位置变化）并相应地更新其自己的反馈视觉。
		</p>
		<p>用户交互包括一个或多个（交错）手势，例如，基于鼠标的按压 - 拖动 - 释放手势，或基于触摸的捏扩展手势。
			<em>因此，手势</em> （ <a href="MVC.html#igesture-abstractgesture">IGesture</a> ）用于与观看者内部的部分交互。每个手势包括由用户经由单个输入设备产生的连续的相关事件序列（虽然鼠标事件可以包含关于按下的修改键的信息，但是按键释放手势被认为在概念上是独立的）。启动交互的手势负责确定可以处理交互的相应目标部分。交互的处理不是由目标部分直接执行，而是由绑定到它的<em>Handler</em> （ <a href="MVC.html#ihandler-abstracthandler">IHandler</a> ）执行。处理程序是一种（被动）策略，它封装了由事务操作执行的某种可撤销逻辑，最终可能由所谓的策略构造。交互中涉及的所有手势都会考虑到这一点，因为它们通过评估其支持的处理程序来定位目标部件，并与这些处理程序而不是部件本身进行交互。在鼠标事件的情况下，处理程序分辨率通过命中测试来执行，而对于键盘交互，则考虑相应的“焦点”部分。默认情况下，启动手势将识别交互处理程序，并且交错手势将其事件转发给此/这些处理程序，以防它/它们能够处理交互。处理程序因此可以处理多个（交错）手势（例如，在拖动鼠标的同时按下按键）。
		</p>
		<p>对交互的响应被封装到（复合）操作中，该操作在交互期间在本地执行以向用户指示“实时”反馈。主动处理器可以直接处理对交互的响应，例如通过提供操纵观看者状态的操作（例如，当目标部分被点击时改变当前选择），或者它可以将其委托给某些<em>策略</em> （ <a href="MVC.html#ipolicy-abstractpolicy">IPolicy</a> ）。它们也附加到部件上并封装某些“共享”逻辑。结束交互的手势负责在单个（可撤销）事务中执行（复合）操作。由于交互可以跨越多个观看者（例如，拖放操作），因此手势被绑定到<em>域</em> （ <a href="MVC.html#idomain-historicizingdomain">IDomain</a> ），该<em>域</em>也构成图形应用程序的所有观看者。<em>域</em>维护全局操作历史记录和设施以初始化和提交事务。
			<br>
		</p>
		<p>可以作为交互的结果操纵的观看者状态（例如，当前选择）通过专用模型（例如， <a href="MVC.html#selectionmodel">SelectionModel</a> ）来表示，其被绑定到每个观看者。随着对观看者状态以及可视化内容的改变，也可能导致必要的观看者更新，行为（ <a href="MVC.html#ibehavior-abstractbehavior">IBehavior</a> ）可能被绑定到类似于策略的部分。与策略相反，行为本身就是活跃的，也就是说，他们将主动监听变化（例如新添加的内容）并执行某些操作。行为还负责根据需要创建和处理各个<em>可视部分</em> （例如，由于选择模型的改变而更新选择反馈）。与策略相反，行为执行的反应不会在操作历史中执行，因此不可撤消。
		</p>
		<hr><div id="MVC.FX:Root"></div>
		<h3 id="root">{根}</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfx:root">{Root}</a>包中包含Guice模块（ <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject。模块</a> ）具有<a href="MVC.html#mvcfx">MVC.FX的</a>默认绑定。</p>
		<h4 id="mvcfxbundle">MvcFxBundle</h4>
		<p><code>MvcFxBundle</code>是MVC.FX包的bundle激活器。
		</p>
		<h4 id="mvcfxmodule">MvcFxModule</h4>
		<p><code>MvcFxModule</code>定义了注册某些默认绑定的方法，这些绑定可以通过子类进行细化（覆盖）。它还定义了一些（空）钩子方法，用于子类应该定义的绑定。
		</p>
		<hr><div id="MVC.FX:Behaviors"></div>
		<h3 id="behaviors">行为</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.mvc.fx.behaviors</strong>
			</li>
		</ul>
		<p><a href="MVC#MVC.FX:behaviors">Behaviors</a>包包含<a href="MVC.html#ibehavior-abstractbehavior">IBehavior</a>和<a href="MVC.html#ibehavior-abstractbehavior">AbstractBehavior</a>定义，以及各种<a href="MVC.html#ibehavior-abstractbehavior">IBehavior</a>实现。
		</p>
		<h4 id="ibehavior-abstractbehavior">IBehavior，AbstractBehavior</h4>
		<p><code>IBehavior</code>绑定到<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ，称为行为的<em>主机</em> 。它主动监听影响其主机的更改（通常是像<a href="MVC.html#selectionmodel">SelectionModel</a>这样的查看器模型），并对这些更改封装（不可撤消）反应，如显示或隐藏反馈或句柄。该<a href="MVC.html#selectionbehavior">SelectionBehavior</a>例如监听的变化<a href="MVC.html#selectionmodel">selectionModel的</a>和产生（或删除）选择反馈和在其宿主选择或取消选择的情况下处理。为了支持正确注册侦听器， <code>IBehavior</code>扩展了<a href="Common.html#iactivatable">org.eclipse.gef.common.activate。IActivatable</a> ，因此只要主机本身被激活/停用，它就被主机激活/停用。因此，可以分别在激活和去激活期间执行对侦听器的注册和取消注册。
		</p>
		<p><code>IBehavior</code>类似于<a href="MVC.html#ipolicy-abstractpolicy">IPolicy</a> ，因为它绑定到<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> 。但是，政策本身并不活跃（它们总是从外部调用）。此外， <code>IBehavior</code>的响应并不意味着是可<code>IBehavior</code> ，而<a href="MVC.html#ipolicy-abstractpolicy">IPolicy</a>的响应是。
		</p>
		<p>该<code>AbstractBehavior</code>处理激活和失活，并提供方法来添加/删除反馈和处理使用部分<a href="MVC.html#ifeedbackpartfactory">IFeedbackPartFactory</a>和<a href="MVC.html#ihandlepartfactory">IHandlePartFactory</a>的的<a href="MVC.html#iviewer">IViewer</a> 。
		</p>
		<h4 id="connectionclickableareabehavior">ConnectionClickableAreaBehavior</h4>
		<p><code>ConnectionClickableAreaBehavior</code>控制连接的曲线节点（不可见）可点击区域的大小，具体取决于缩放级别。即使缩放级别非常低，也可以“点击”连接。
		</p>
		<h4 id="contentbehavior-contentpartpool">ContentBehavior，ContentPartPool</h4>
		<p>从概念上讲，内容部分表现出观众内容对其可视化的“投影”。它们是递归创建的，从查看者的contents属性引用的那些内容元素开始。通过提供相应的钩子方法（getContentChildrenUnmodifiable（）和getContentAnchoragesUnmodifiable（）），每个内容部分指示要为哪些子内容元素创建附加内容部分，以及将其附加到哪些内容部分。<code>ContentBehavior</code>侦听内容更改（在查看器内容属性以及所有内容部件的内容子项和锚点上）以启动内容同步。在内容同步期间，针对当前内容对象检查当前存在的内容部分，以便根据需要创建或移除内容部分，并且通过钩子方法从内容推断出相应的父子关系和锚定锚定关系。内容部分。
		</p>
		<p>删除的内容部分存储在<code>ContentPartPool</code> ，以便在以后需要时可以重复使用，而不必重新创建。
		</p>
		<h4 id="focusbehavior">FocusBehavior</h4>
		<p><code>FocusBehavior</code>正在侦听<a href="MVC.html#focusmodel">FocusModel</a>更改并将它们传输到JavaFX。</p>
		<h4 id="gridbehavior">GridBehavior</h4>
		<p><code>GridBehavior</code>正在侦听<a href="MVC.html#gridmodel">GridModel</a>更改，以便将这些更改应用于<a href="MVC.html#iviewer">IViewer</a>的GridLayout。
		</p>
		<h4 id="hoverbehavior-hoverintentbehavior">HoverBehavior，HoverIntentBehavior</h4>
		<p><code>HoverBehavior</code>和<code>HoverIntentBehavior</code>对<a href="MVC.html#hovermodel">HoverModel</a>更改做出反应。它们连接到<a href="MVC.html#irootpart-layeredrootpart">IRootPart</a> ，并将处理瞬态悬停（鼠标移动到视觉上）和意图悬停（鼠标停留在视觉上）的反馈和句柄的创建。通常， <code>HoverBehavior</code>将关注反馈的创建，而句柄则由<code>HoverIntentBehavior</code>创建。
		</p>
		<h4 id="revealprimaryselectionbehavior">RevealPrimarySelectionBehavior</h4>
		<p><code>SelectionBehavior</code>对<a href="MVC.html#selectionmodel">SelectionModel</a>更改做出反应。<code>RevealPrimarySelectionBehavior</code>确保主要选定的部分在查看器的视口中可视化。
		</p>
		<h4 id="selectionbehavior">SelectionBehavior</h4>
		<p><code>SelectionBehavior</code>对<a href="MVC.html#selectionmodel">SelectionModel</a>更改做出反应。选择零件时，它会生成反馈/句柄。
		</p>
		<h4 id="snappingbehavior">SnappingBehavior</h4>
		<p><code>SnappingBehavior</code>侦听<a href="MVC.html#snappingmodel">SnappingModel</a>更改并生成“对齐”反馈。
		</p>
		<hr><div id="MVC.FX:Domain"></div>
		<h3 id="domain">域</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.domain</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfx:domain">Domain</a>包中包含<a href="MVC.html#idomain-historicizingdomain">IDomain</a>抽象和相关的默认实现。
		</p>
		<h4 id="idomain-historicizingdomain">IDomain，HistoricizingDomain</h4>
		<p><code>IDomain</code>表示图形应用程序的集合状态，即它由所有<a href="MVC.html#iviewer">IViewers</a>和<a href="MVC.html#igesture-abstractgesture">IGesture组成</a> 。此外， <code>IDomain</code>提供了执行（可<code>IDomain</code> ）事务的方法，手势/处理程序使用这些事务来更改应用程序的状态。
		</p>
		<p><code>HistoricizingDomain</code>是内部使用<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html" target="doc_external">org.eclipse.core.commands.operations的IDomain的默认实现<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html" target="doc_external">。IOperationHistory</a>和<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoContext.html" target="doc_external">org.eclipse.core.commands.operations。IUndoContext</a>实现可撤销的</a>事务。
		</p>
		<hr><div id="MVC.FX:Gestures"></div>
		<h3 id="gestures">手势</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.gestures</strong>
			</li>
		</ul>
		<p><a href="MVC#mvc.fx:gestures">Gestures</a>包中包含<a href="MVC.html#igesture-abstractgesture">IGesture</a>抽象及其相关的<a href="MVC.html#igesture-abstractgesture">AbstractGesture</a>实现。
		</p>
		<h4 id="igesture-abstractgesture">IGesture，AbstractGesture</h4>
		<p><code>IGesture</code>将输入事件委托给相应的（交互） <a href="MVC.html#ihandler-abstracthandler">IHandler</a> ，它实际上负责处理交互。交互通常由多个手势组成，因此手势可能是交错的。虽然每个手势都维护一个活动处理程序列表，但默认情况下，手势通过首先检查已经运行的手势的活动处理程序来解析处理程序。所有那些也可以处理新手势的处理程序（即它们实现标记接口）也将被新手势视为活动处理程序。如果已经以这种方式解析了至少一个活动处理程序，则不会解析其他处理程序。否则，通过初始手势解析新场景的活动处理程序。
		</p>
		<h4 id="clickdraggesture">ClickDragGesture</h4>
		<p><code>ClickDragGesture</code>为鼠标单击和拖动交互注册侦听器。目标<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>是通过搜索可视化部分层次结构来确定的，从控制视觉的部分开始，该部分被按下，直到找到分别支持至少一个<a href="MVC.html#ionclickhandler">IOnClickHandler</a>或<a href="MVC.html#iondraghandler">IOnDragHandler的部分</a> 。
		</p>
		<h4 id="hovergesture">HoverGesture</h4>
		<p><code>HoverGesture</code>为鼠标悬停交互注册侦听器，即用于视觉效果的鼠标输入和鼠标退出事件。目标<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>是通过搜索可视部件层次结构来确定的，从控制视觉的部分开始，该部分被悬停，直到找到支持至少一个<a href="MVC.html#ionhoverhandler">IOnHoverHandler的部件</a> 。HoverGesture还支持“悬停意图”，即将鼠标悬停在视觉上并保持静止一段时间，默认情况下用于添加/删除悬停（意图）手柄。
		</p>
		<h4 id="pinchspreadgesture">PinchSpreadGesture</h4>
		<p><code>PinchSpreadGesture</code>为侦听<code>PinchSpreadGesture</code>注册触摸捏合/扩展手势交互， <code>PinchSpreadGesture</code>两个手指分开或将它们组合在一起（许多触摸显示器上的默认缩放手势）。目标<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>是通过搜索可视化部分层次结构来确定的，从控制视觉的部分开始，触摸该部分，直到找到支持至少一个<a href="MVC.html#ionpinchspreadhandler">IOnPinchSpreadHandler的部分</a> 。
		</p>
		<h4 id="rotategesture">RotateGesture</h4>
		<p><code>RotateGesture</code>为触摸旋转手势交互注册侦听器， <code>RotateGesture</code>两个手指彼此移动（或者将一个手指移动到另一个手指周围）。目标<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>是通过搜索可视部件层次结构来确定的，从控制被触摸的视觉的部分开始，直到找到支持至少一个<a href="MVC.html#ionrotatehandler">IOnRotateHandler的部件</a> 。
		</p>
		<h4 id="scrollgesture">ScrollGesture</h4>
		<p><code>ScrollGesture</code>为滚动交互注册侦听器，可以是鼠标滚轮滚动，也可以是滚动滚动，即向上或向下拖动两根手指。目标<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>是通过搜索可视部件层次结构来确定的，从控制视觉的部分开始，滚动或触摸，直到找到支持至少一个<a href="MVC.html#ionscrollhandler">IOnScrollHandler的部件</a> 。
		</p>
		<h4 id="typestrokegesture">TypeStrokeGesture</h4>
		<p><code>TypeStrokeGesture</code>为键盘交互注册侦听器。在解析<a href="MVC.html#iontypehandler">IOnTypeHandler</a>和<a href="MVC.html#ionstrokehandler">IOnStrokeHandler时</a> ，控制当前焦点图形的内容部分将用作起始点（它应该对应于<a href="MVC.html#focusmodel">FocusModel</a>的当前焦点部分，因为焦点图形与其同步）。
		</p>
		<hr><div id="MVC.FX:Handlers"></div>
		<h3 id="handlers">处理程序</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.handlers</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfx:handlers">Handlers</a>包中包含各种支持手势的<a href="MVC.html#ihandler-abstracthandler">IHandler</a>抽象以及相关的默认实现。
		</p>
		<h4 id="ihandler-abstracthandler">IHandler，AbstractHandler</h4>
		<p><code>IHandler</code>交互手势的响应封装到事务操作中。可以直接构建操作，或者可以为此目的使用策略。
		</p>
		<h4 id="ionclickhandler">IOnClickHandler</h4>
		<p><code>IOnClickHandler</code>在鼠标单击事件时调用<a href="MVC.html#clickdraggesture">IOnClickHandler</a> 。您可以将其用作任何<a href="MVC.html#ivisualpart-abstractvisualpart">需要</a>鼠标单击交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="iondraghandler">IOnDragHandler</h4>
		<p><code>IOnDragHandler</code>在鼠标按下 - 拖动 - 释放手势期间调用<a href="MVC.html#clickdraggesture">IOnDragHandler</a> 。您可以将其用作任何<a href="MVC.html#ivisualpart-abstractvisualpart">需要</a>鼠标拖动交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="ionhoverhandler">IOnHoverHandler</h4>
		<p><code>IOnHoverHandler</code>在鼠标悬停时调用<a href="MVC.html#hovergesture">IOnHoverHandler</a> 。您可以将其用作任何<a href="MVC.html#ivisualpart-abstractvisualpart">需要</a>鼠标悬停交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="ionpinchspreadhandler">IOnPinchSpreadHandler</h4>
		<p><code>IOnPinchSpreadHandler</code>在捏合/扩展触摸手势期间调用<a href="MVC.html#pinchspreadgesture">IOnPinchSpreadHandler</a> 。您可以将其用作任何<a href="MVC.html#ivisualpart-abstractvisualpart">需要</a>捏合/扩散触摸交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="ionrotatehandler">IOnRotateHandler</h4>
		<p><code>IOnRotateHandler</code>在旋转触摸手势期间调用<a href="MVC.html#rotategesture">IOnRotateHandler</a> 。您可以将其用作任何<a href="MVC.html#ivisualpart-abstractvisualpart">需要</a>旋转触摸交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="ionscrollhandler">IOnScrollHandler</h4>
		<p>一个<code>IOnScrollHandler</code>是在鼠标滚轮滚动或通过触摸滚动手势期间调用<a href="MVC.html#scrollgesture">ScrollGesture</a> 。您可以将其用作任何需要滚动交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="ionstrokehandler">IOnStrokeHandler</h4>
		<p>按下<code>IOnStrokeHandler</code>按键并释放<a href="MVC.html#typestrokegesture">IOnStrokeHandler</a> 。您可以将其用作任何需要键盘交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="iontypehandler">IOnTypeHandler</h4>
		<p>按下<code>IOnTypeHandler</code>时按下并释放<a href="MVC.html#typestrokegesture">IOnTypeHandler</a> 。您可以将其用作任何需要键盘交互的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>上的适配器。
		</p>
		<h4 id="bendfirstanchorageonsegmenthandledraghandler">BendFirstAnchorageOnSegmentHandleDragHandler</h4>
		<p>所述<code>BendFirstAnchorageOnSegmentHandleDragHandler</code>是<a href="MVC.html#iondraghandler">IOnDragHandler</a>可以应用到<a href="MVC.html#abstracthandlepart-abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">SegmentHandlePart</a>弯曲主机的第一锚固，即操纵<a href="FX.html#connection">org.eclipse.gef.fx.nodes。连接</a>主机<a href="MVC.html#abstracthandlepart-abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">SegmentHandlePart</a>的第一个锚点的视觉效果。它使用第一个锚点的<a href="MVC.html#bendconnectionpolicy">BendConnectionPolicy</a> 。
		</p>
		<h4 id="bendonsegmentdraghandler">BendOnSegmentDragHandler</h4>
		<p><code>BendOnSegmentDragHandler</code>是一个<a href="MVC.html#iondraghandler">IOnDragHandler</a> ，可用于使用正交的<a href="FX.html#iconnectionrouter-straightrouter-orthogonalrouter">org.eclipse.gef.fx.nodes拖动<a href="FX.html#connection">Connection的</a>各个段<a href="FX.html#iconnectionrouter-straightrouter-orthogonalrouter">。OrthogonalRouter</a> 。它基于其主机的<a href="MVC.html#bendconnectionpolicy">BendConnectionPolicy</a> 。
		</p>
		<h4 id="deleteselectedontypehandler">DeleteSelectedOnTypeHandler</h4>
		<p><code>DeleteSelectedOnTypeHandler</code>是一个<a href="MVC.html#iontypepolicy">IOnTypePolicy</a> ，在按下&lt;Delete&gt;&gt;键时删除所选部分。
		</p>
		<h4 id="focusandselectonclickhandler">FocusAndSelectOnClickHandler</h4>
		<p><code>FocusAndSelectOnClickHandler</code>是一个<a href="MVC.html#ionclickhandler">IOnClickHandler</a> ，可在鼠标单击时<a href="MVC.html#ionclickhandler">聚焦</a>并选择主机部件。它操纵<a href="MVC.html#focusmodel">FocusModel</a>和<a href="MVC.html#selectionmodel">SelectionModel</a> 。
		</p>
		<h4 id="hoveronhoverhandler">HoverOnHoverHandler</h4>
		<p><code>HoverOnHoverHandler</code>是一个<a href="MVC.html#ionhoverhandler">IOnHoverHandler</a> ，它在鼠标悬停时悬停主机部分。它操纵<a href="MVC.html#hovermodel">HoverModel</a> 。
		</p>
		<h4 id="marqueeondraghandler">MarqueeOnDragHandler</h4>
		<p><code>MarqueeOnDragHandler</code>是一个<a href="MVC.html#iondraghandler">IOnDragHandler</a> ，可用于跨越使用鼠标拖动覆盖多个部分的选取框选择区域。它操纵<a href="MVC.html#selectionmodel">SelectionModel</a> 。
		</p>
		<h4 id="panonstrokehandler">PanOnStrokeHandler</h4>
		<p><code>PanOnStrokeHandler</code>是一个<a href="MVC.html#iontypehandler">IOnTypeHandler</a> ，用于更改<a href="FX.html#infinitecanvas">org.eclipse.gef.fx.nodes的滚动偏移量<a href="FX.html#infinitecanvas">。InfiniteCanvas</a>内容的<a href="MVC.html#infinitecanvasviewer">InfiniteCanvasViewer</a>在箭头按键。它基于<a href="MVC.html#changeviewportpolicy">IRootPart</a>的<a href="MVC.html#irootpart-layeredrootpart">ChangeViewportPolicy</a> 。
		</p>
		<h4 id="panorzoomonscrollhandler">PanOrZoomOnScrollHandler</h4>
		<p><code>PanOrZoomOnScrollHandler</code>更改<a href="FX.html#infinitecanvas">org.eclipse.gef.fx.nodes的滚动偏移或缩放级别<a href="FX.html#infinitecanvas">。InfiniteCanvas</a>内容的<a href="MVC.html#infinitecanvasviewer">InfiniteCanvasViewer</a>在鼠标/触摸滚动事件。它基于<a href="MVC.html#changeviewportpolicy">IRootPart</a>的<a href="MVC.html#irootpart-layeredrootpart">ChangeViewportPolicy</a> 。
		</p>
		<h4 id="resizetransformselectedonhandledraghandler">ResizeTransformSelectedOnHandleDragHandler</h4>
		<p>所述<code>ResizeTransformSelectedOnHandleDragHandler</code>是<a href="MVC.html#iondraghandler">IOnDragHandler</a>可应用于<a href="MVC.html#abstracthandlepart-abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">SegmentHandlePart</a>调整大小和重新定位其上鼠标拖动主机的第一锚固。它基于所选部件的<a href="MVC.html#resizepolicy">ResizePolicy</a>和<a href="MVC.html#transformpolicy">TransformPolicy</a> 。
		</p>
		<h4 id="resizetranslatefirstanchorageonhandledraghandler">ResizeTranslateFirstAnchorageOnHandleDragHandler</h4>
		<p>所述<code>ResizeTranslageFirstAnchorageOnHandleDragHandler</code>是<a href="MVC.html#iondraghandler">IOnDragHandler</a>的是，可以被应用到<a href="MVC.html#abstracthandlepart-abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">SegmentHandlePart</a>来调整和变换视觉其主机的第一锚固对鼠标拖拽。它基于主机第一个锚点的<a href="MVC.html#resizepolicy">ResizePolicy</a>和<a href="MVC.html#transformpolicy">TransformPolicy</a> 。
		</p>
		<h4 id="rotateselectedonhandledraghandler">RotateSelectedOnHandleDragHandler</h4>
		<p>所述<code>RotateSelectedOnHandleDragPolicy</code>是<a href="MVC.html#ifxondragpolicy">IFXOnDragPolicy</a>的是，可以被应用到<a href="MVC.html#abstracthandlepart-abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">SegmentHandlePart</a>到所选择的部分上鼠标拖动旋转。它基于所选部件的<a href="MVC.html#transformpolicy">TransformPolicy</a> 。
		</p>
		<h4 id="rotateselectedonrotatehandler">RotateSelectedOnRotateHandler</h4>
		<p><code>RotateSelectedOnRotateHandler</code>是一个<a href="MVC.html#ionrotatehandler">IOnRotateHandler</a> ，它使用触摸旋转手势旋转所选部件。它基于所选部件的<a href="MVC.html#transformpolicy">TransformPolicy</a> 。
		</p>
		<h4 id="selectallontypehandler">SelectAllOnTypeHandler</h4>
		<p><code>SelectAllOnTypeHandler</code>是一个<a href="MVC.html#iontypehandler">IOnTypeHandler</a> ，用于选择查看器的所有内容部分。
		</p>
		<h4 id="selectfocusedontypehandler">SelectFocusedOnTypeHandler</h4>
		<p><code>SelectFocusedOnTypeHandler</code>是一个<a href="MVC.html#iontypehandler">IOnTypeHandler</a> ，用于选择/取消选择（select）键类型上的焦点元素。它操纵<a href="MVC.html#focusmodel">FocusModel</a> 。
		</p>
		<h4 id="translateselectedondraghandler">TranslateSelectedOnDragHandler</h4>
		<p><code>TranslateSelectedOnDragHandler</code>是一个<a href="MVC.html#iondraghandler">IOnDragHandler</a> ，用于在使用鼠标拖动时重定位主机视觉效果。它基于其主机的<a href="MVC.html#transformpolicy">TransformPolicy</a> 。
		</p>
		<h4 id="traversefocusontypehandler">TraverseFocusOnTypeHandler</h4>
		<p><code>TraverseFocusOnTypeHandler</code>是一个<a href="MVC.html#iontypehandler">IOnTypeHandler</a> ，它遍历（tab）键类型上的焦点元素。它操纵<a href="MVC.html#focusmodel">FocusModel</a> 。
		</p>
		<h4 id="zoomonpinchspreadhandler">ZoomOnPinchSpreadHandler</h4>
		<p><code>ZoomOnPinchSpreadHandler</code>是一个<a href="MVC.html#ionpinchspreadhandler">IOnPinchSpreadHandler</a> ，它可以在触摸捏合/展开手势时更改内容<a href="MVC.html#infinitecanvasviewer">InfiniteCanvasViewer</a>的<a href="FX.html#infinitecanvas">InfiniteCanvas</a>的缩放比例。它基于其主机的<a href="MVC.html#changeviewportpolicy">ChangeViewportPolicy</a> 。
		</p>
		<hr><div id="MVC.FX:Models"></div>
		<h3 id="models">楷模</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.models</strong>
			</li>
		</ul>
		<p><a href="MVC#MVC.FX:models">Models</a>包包含所有查看器模型，即构成查看器状态的数据。
		</p>
		<h4 id="focusmodel">FocusModel</h4>
		<p><code>FocusModel</code>存储具有键盘焦点的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ，即将接收所有键盘输入的部分。
		</p>
		<h4 id="gridmodel">GridModel</h4>
		<p><code>GridModel</code>存储查看器的背景网格设置：</p>
		<ul>
			<li>
				<em>show-grid</em> ， <code>true</code>或<code>false</code> ，表示是否显示网格。
			</li>
			<li>
				<em>zoom-grid</em> ， <code>true</code>或<code>false</code> ，表示是否缩放网格。
			</li>
			<li>
				<em>grid-cell-width</em> ， <code>Double</code> ，指定网格单元格的宽度。
			</li>
			<li>
				<em>grid-cell-height</em> ， <code>Double</code> ，指定网格单元格的高度。
			</li>
		</ul>
		<h4 id="hovermodel">HoverModel</h4>
		<p><code>HoverModel</code>存储当前悬停的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> 。
		</p>
		<h4 id="selectionmodel">selectionModel设置</h4>
		<p><code>SelectionModel</code>存储所有当前选定的<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a> 。
		</p>
		<h4 id="snappingmodel">SnappingModel</h4>
		<p><code>SnappingModel</code>存储所有当前可用的捕捉位置，用于指示对齐反馈。
		</p>
		<hr><div id="MVC.FX:Operations"></div>
		<h3 id="operations">操作</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.mvc.fx.operations</strong>
			</li>
		</ul>
		<p>该<a href="MVC.html#mvcfx:operations">业务</a>包中包含的所有<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoableOperation.html" target="doc_external">IUndoableOperation</a>实现贡献的<a href="MVC.html#mvcfx">MVC.FX</a> 。</p>
		<h4 id="itransactionaloperation">ITransactionalOperation</h4>
		<p><code>ITransactionalOperation</code>是<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoableOperation.html" target="doc_external">org.eclipse.core.commands.operations的特化。IUndoableOperation</a> 。
		</p>
		<p>可以通过isContentRelevant（）查询<code>ITransactionalOperation</code>以查找更改的内容相关性。这允许过滤掉操作历史中的非内容相关操作。此外， <code>ITransactionalOperation</code>应该可以安全地防止重复执行。这是必需的，因为它们在交互期间连续执行以指示“实时反馈”。因此，execute（）和redo（）应始终将给定的“当前”状态转换为专用的“最终”状态，而undo（）应始终将“当前”状态转换回“初始”状态（当操作为创建）。执行完成后，只有实际产生影响的<code>ITransactionalOperation</code>才会添加到操作历史记录中。提供了一个isNoop（）回调来比较'initial'和'final'状态以便做出决定。
		</p>
		<h4 id="abstractcompositeoperation-forwardundocompositeoperation-reverseundocompositeoperation">AbstractCompositeOperation，ForwardUndoCompositeOperation，ReverseUndoCompositeOperation</h4>
		<p><code>AbstractCompositeOperation</code>是两个具体的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ICompositeOperation.html" target="doc_external">org.eclipse.core.commands.operations的基类<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ICompositeOperation.html" target="doc_external">。ICompositeOperation</a>实现：</p>
		<ul>
			<li><code>ForwardUndoCompositeOperation</code>是一个特定的<a href="MVC.html#abstractcompositeoperation-forwardundocompositeoperation-reverseundocompositeoperation">AbstractCompositeOperation</a> 。它将按照它们添加到复合操作的顺序<code>execute()</code> ， <code>redo()</code>和<code>undo()</code>操作。
			</li>
			<li><code>ReverseUndoCompositeOperation</code>是一个特定的<a href="MVC.html#abstractcompositeoperation-forwardundocompositeoperation-reverseundocompositeoperation">AbstractCompositeOperation</a> 。它将按照它们被添加到复合操作的顺序<code>execute()</code>和<code>redo()</code>操作，但是它将以相反的顺序<code>undo()</code>它的操作。
			</li>
		</ul>
		<h4 id="addcontentchildoperation">AddContentChildOperation</h4>
		<p><code>AddContentChildOperation</code>可用于将内容子项添加到<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a> 。它依赖于<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a>的<code>addContentChild()</code>方法来实现这一点。
		</p>
		<p>此操作是<a href="MVC.html#removecontentchildoperation">RemoveContentChildOperation</a>的对应操作。
		</p>
		<h4 id="attachtocontentanchorageoperation">AttachToContentAnchorageOperation</h4>
		<p><code>AttachToContentAnchorageOperation</code>可用于将<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a>附加到内容锚点。它依赖于<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a>的<code>attachToContentAnchorage()</code>方法来实现这一点。
		</p>
		<p>此操作是<a href="MVC.html#detachfromcontentanchorageoperation">DetachFromContentAnchorageOperation</a>的对应操作。
		</p>
		<h4 id="bendvisualoperation">BendVisualOperation</h4>
		<p><code>BendVisualOperation</code>可用于操纵构成<a href="FX.html#connection">Connection</a>的点，即其起点，航点和终点。在操作起点或终点时，它还会在适用时将其连接到鼠标下的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> 。
		</p>
		<h4 id="bendcontentoperation">BendContentOperation</h4>
		<p><code>BendContentOperation</code>允许弯曲<a href="MVC.html#ibendablecontentpart">BendableContentPart</a>的内容。
		</p>
		<h4 id="changecontentsoperation">ChangeContentsOperation</h4>
		<p><code>ChangeContentsOperation</code>允许交换<a href="MVC.html#contentmodel">ContentModel</a>保留的内容。
		</p>
		<h4 id="changefocusoperation">ChangeFocusOperation</h4>
		<p><code>ChangeFocusOperation</code>可用于通过操作<a href="MVC.html#focusmodel">FocusModel</a>来设置当前聚焦的部分。
		</p>
		<h4 id="changeselectionoperation">ChangeSelectionOperation</h4>
		<p><code>ChangeSelectionOperation</code>可用于通过操作<a href="MVC.html#selectionmodel">SelectionModel</a>来设置当前选定的part8s。
		</p>
		<h4 id="changeviewportoperation">ChangeViewportOperation</h4>
		<p><code>ChangeViewportOperation</code>可用于操作内容<a href="MVC.html#infinitecanvasviewer">FXViewer</a>的<a href="FX.html#infinitecanvas">InfiniteCanvas</a> ，即滚动偏移和内容转换。
		</p>
		<h4 id="deselectoperation">DeselectOperation</h4>
		<p><code>DeselectOperation</code>可用于通过操作<a href="MVC.html#selectionmodel">SelectionModel</a>来清除当前选定的零件。
		</p>
		<h4 id="detachfromcontentanchorageoperation">DetachFromContentAnchorageOperation</h4>
		<p><code>DetachFromContentAnchorageOperation</code>可用于从内容锚点分离<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a> 。它依赖于<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a>的<code>detachFromContentAnchorage()</code>方法来实现这一目的。
		</p>
		<p>此操作是<a href="MVC.html#attachtocontentanchorageoperation">AttachToContentAnchorageOperation</a>的对应<a href="MVC.html#attachtocontentanchorageoperation">项</a> 。
		</p>
		<h4 id="removecontentchildoperation">RemoveContentChildOperation</h4>
		<p><code>RemoveContentChildOperation</code>可用于从<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart中</a>删除内容子<a href="MVC.html#icontentpart-abstractcontentpart">项</a> 。它依赖于<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a>的<code>removeContentChild()</code>方法来实现这一点。
		</p>
		<p>此操作是<a href="MVC.html#addcontentchildoperation">AddContentChildOperation</a>的对应操作。
		</p>
		<h4 id="resizecontentoperation">ResizeContentOperation</h4>
		<p><code>ResizeContentOperation</code>允许调整<a href="MVC.html#iresizablecontentpart">ResizableContentPart</a>的内容。
		</p>
		<h4 id="resizeoperation">ResizeOperation</h4>
		<p><code>ResizeOperation</code>可用于调整<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/Node.html" target="doc_external">javafx.scene的大小<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/Node.html" target="doc_external">。节点</a> 。
		</p>
		<h4 id="revealoperation">RevealOperation</h4>
		<p>该<code>RevealOperation</code>可以用来揭示一个<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>在其<a href="MVC.html#iviewer">IViewer</a> 。
		</p>
		<h4 id="selectoperation">SelectOperation</h4>
		<p><code>SelectOperation</code>可用于通过操纵<a href="MVC.html#selectionmodel">SelectionModel</a>来操纵当前选定的零件。
		</p>
		<h4 id="setrefreshvisualoperation">SetRefreshVisualOperation</h4>
		<p><code>SetRefreshVisualOperation</code>可用于启用/禁用特定<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>的<code>#refreshVisual()</code>方法。
		</p>
		<h4 id="transformcontentoperation">TransformContentOperation</h4>
		<p><code>TransformContentOperation</code>可用于转换<a href="MVC.html#itransformablecontentpart">ITransformableContentPart</a>的内容。
		</p>
		<h4 id="transformvisualoperation">TransformVisualOperation</h4>
		<p><code>TransformVisualOperation</code>可用于操纵与<a href="MVC.html#itransformablecontentpart">ITransformableContentPart</a>关联的视觉效果。
		</p>
		<hr><div id="MVC.FX:Parts"></div>
		<h3 id="parts">部分</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.parts</strong>
			</li>
		</ul>
		<p><a href="MVC#MVC.FX:parts">Parts</a>包包含与模型 - 视图 - 控制器体系结构中的控制器（也称为<em>部件</em> ）相关的所有抽象。这包括<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart</a> ， <a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ，IFeedbackPart， <a href="MVC.html#ihandlepart-abstracthandlepart">IHandlePart</a>和<a href="MVC.html#irootpart-layeredrootpart">IRootPart</a>抽象及相关实现。
		</p>
		<h4 id="ivisualpart-abstractvisualpart">IVisualPart，AbstractVisualPart</h4>
		<p><code>IVisualPart</code>接口是控制器对象的主要<a href="MVC.html#mvcfx">MVC.FX</a>抽象，因此，控制可视化并处理用户交互。视觉部分按层次结构组织，即每个部分（根部分除外）与父部分相关联，并且可以控制多个子部分。除了父子关系之外，视觉部分可以是锚定 - 锚定关系的一部分，其与层次结构无关，即锚定和锚定可以位于层次结构内的任意位置。
		</p>
		<p>视觉部分是可适应的，因此您可以调整策略和行为（如果需要，还可以调整其他任何内容）。这是用户交互的组成部分，因为手势会将输入事件委托给控制事件目标（可视）的可视部分的相应策略。视觉部件也是可激活的。在激活/停用期间，它们将激活/停用其适配器。</p>
		<p>此外， <code>IVisualPart</code>公开了以下可观察属性：</p>
		<ul>
			<li>
				<code>"active"</code> ：此视觉部分已激活/停用。
			</li>
			<li>
				<code>"adapters"</code> ：此可视部分的适配器（策略，行为等）发生了变化。
			</li>
			<li>
				<code>"parent"</code> ：此视觉部分的父级已更改。
			</li>
			<li>
				<code>"children"</code> ：这个视觉部分的孩子们改变了。
			</li>
			<li>
				<code>"anchorages"</code> ：这个视觉部分的锚地发生了变化。
			</li>
			<li>
				<code>"anchoreds"</code> ：这个视觉部分的锚定发生了变化。
			</li>
		</ul>
		<h4 id="irootpart-layeredrootpart">IRootPart，LayeredRootPart</h4>
		<p>该<code>IRootPart</code>接口是一个专业化<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>接口。恰好有一个<code>IRootPart</code>每<a href="MVC.html#iviewer">IViewer</a> 。它包含所有<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a> ， <a href="MVC.html#ifeedbackpart-abstractfeedbackpart">IFeedbackParts</a>和<a href="MVC.html#ihandlepart-abstracthandlepart">IHandleParts</a>作为子项并管理根视觉效果。
		</p>
		<p><code>LayeredRootPart</code>是默认实现，它提供内容层，反馈层和句柄层，其中显示相应部分的视觉效果。反馈层在内容层之上，并且句柄层在反馈层之上。
		</p>
		<h4 id="icontentpart-abstractcontentpart">IContentPart，AbstractContentPart</h4>
		<p><code>IContentPart</code>接口是<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>接口的特化。内容部分绑定到内容模型元素，即它们提供到模型的链接，并允许通过<code>addContentChild()</code> ， <code>removeContentChild()</code> ， <code>attachToContentAnchorage()</code>和<code>detachFromContentAnchorage()</code> 。
		</p>
		<h4 id="itransformablecontentpart">ITransformableContentPart</h4>
		<p><code>ITransformableContentPart</code>接口由<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>实现， <a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>支持其内容的转换。这例如用于保持翻译操作。
		</p>
		<h4 id="iresizablecontentpart">IResizableContentPart</h4>
		<p><code>IResizableContentPart</code>接口由<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>实现， <a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>支持调整其内容的大小。这例如用于持续调整大小操作。
		</p>
		<h4 id="ibendablecontentpart">IBendableContentPart</h4>
		<p><code>IBendableContentPart</code>接口由<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>实现， <a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>支持其内容的弯曲（即插入或移动弯曲点）。这例如用于保持弯曲操作。
		</p>
		<h4 id="icontentpartfactory">IContentPartFactory</h4>
		<p><code>IContentPartFactory</code>接口是<code>IContentPartFactory</code>中默认机制的<a href="MVC.html#mvcfx">一部分</a> ：它在<a href="MVC.html#contentbehavior-contentpartpool">ContentBehavior</a>内的内容同步期间用于创建新的内容部分。因此，如果要使用此默认机制，则必须提供适合您的内容模型的<code>IContentPartFactory</code> 。
		</p>
		<h4 id="ifeedbackpart-abstractfeedbackpart">IFeedbackPart，AbstractFeedbackPart</h4>
		<p><code>IFeedbackPart</code>接口是<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>接口的特化。反馈部分用于在交互期间向用户提供视觉反馈。它们通常呈现在内容部分之上。
		</p>
		<h4 id="focusfeedbackpart-hoverfeedbackpart-selectionfeedbackpart-selectionlinkfeedbackpart-snappingfeedbackpart">FocusFeedbackPart，HoverFeedbackPart，SelectionFeedbackPart，SelectionLinkFeedbackPart，SnappingFeedbackPart</h4>
		<p>
			<code>FocusFeedbackPart</code> ， <code>HoverFeedbackPart</code> ， <code>SelectionFeedbackPart</code> ， <code>SelectionLinkFeedbackPart</code>和<code>SnappingFeedbackPart</code>是用于默认反馈的具体反馈部分实现。
		</p>
		<h4 id="ifeedbackpartfactory-defaultfocusfeedbackpartfactory-defaulthoverfeedbackpartfactory-defaultselectionfeedbackpartfactory-defaultsnappingfeedbackpartfactory">IFeedbackPartFactory，DefaultFocusFeedbackPartFactory，DefaultHoverFeedbackPartFactory，DefaultSelectionFeedbackPartFactory，DefaultSnappingFeedbackPartFactory</h4>
		<p><code>IFeedbackPartFactory</code>接口是<code>IFeedbackPartFactory</code>中默认机制的<a href="MVC.html#mvcfx">一部分</a> ：它用于在默认行为中创建反馈部分，即响应鼠标悬停或选择更改。
		</p>
		<p><code>DefaultFocusFeedbackPartFactory</code> ， <code>DefaultHoverFeedbackPartFactory</code> ， <code>DefaultSelectionFeedbackPartFactory</code>和<code>DefaultSnappingFeedbackPartFactory</code>使用<code>FocusFeedbackPart</code> ， <code>HoverFeedbackPart</code> ， <code>SelectionFeedbackPart</code> ， <code>SelectionLinkFeedbackPart</code>和<code>SnappingFeedbackPart</code>来生成反馈。
		</p>
		<h4 id="ihandlepart-abstracthandlepart">IHandlePart，AbstractHandlePart</h4>
		<p><code>IHandlePart</code>接口是<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>接口的特化。手柄部件用于视觉手柄，可用于交互，即操纵元件。它们通常呈现在反馈部分之上。
		</p>
		<h4 id="abstractsegmenthandlepart-circlesegmenthandlepart-rectanglesegmenthandlepart-squaresegmenthandlepart">AbstractSegmentHandlePart，CircleSegmentHandlePart，RectangleSegmentHandlePart，SquareSegmentHandlePart</h4>
		<p><code>AbstractSegmentHandlePart</code>是<code>AbstractHandlePart</code> ，它绑定到poly-bezier手柄几何体的一段，由BezierCurves数组表示。段索引标识该段（0,1,2，...）。段参数指定该句柄部分在段上的位置（0 =开始，0.5 =中，1 =结束）。
		</p>
		<p><code>CircleSegmentHandlePart</code>是<code>AbstractSegmentHandlePart</code> ，它使用<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/shape/Circle.html" target="doc_external">javafx.scene.shape。圆形</a>手柄可视化。
		</p>
		<p><code>RectangleSegmentHandlePart</code>是<code>AbstractSegmentHandlePart</code> ，它使用<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/shape/Rectangle.html" target="doc_external">javafx.scene.shape。用于手柄可视化的矩形</a> 。
		</p>
		<h4 id="ihandlepartfactory-defaulthoverintenthandlepartfactory-defaultselectionhandlepartfactory">IHandlePartFactory，DefaultHoverIntentHandlePartFactory，DefaultSelectionHandlePartFactory</h4>
		<p><code>IHandlePartFactory</code>接口是<code>IHandlePartFactory</code>中默认机制的<a href="MVC.html#mvcfx">一部分</a> ：它用于在默认行为中创建句柄部分，即响应鼠标悬停或选择更改。
		</p>
		<p>如果关联的几何提供程序绑定为悬停/选定部件上的适配器，则<code>DefaultHoverIntentHandlePartFactory</code>和<code>DefaultSelectionHandlePartFactory</code>使用<code>CircleSegmentHandlePart</code> ， <code>RectangleSegmentHandlePart</code>和<code>SquareSegmentHandlePart</code>生成句柄。
		</p>
		<h4 id="partutils">PartUtils</h4>
		<p>在处理可视部件时， <code>PartUtils</code>类是实用程序方法的集合。
		</p>
		<hr><div id="MVC.FX:Policies"></div>
		<h3 id="policies">政策</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.policies</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfx:policies">Policies</a>包包含<a href="MVC.html#ipolicy-abstractpolicy">IPolicy</a>抽象，相关的抽象基础实现（ <a href="MVC.html#ipolicy-abstractpolicy">AbstractPolicy</a> ）和具体的基础实现。
		</p>
		<h4 id="ipolicy-abstractpolicy">IPolicy，AbstractPolicy</h4>
		<p><code>IPolicy</code>绑定到<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ，称为策略的<em>主机</em> 。所有策略都是事务性的，即其他策略或处理程序可以使用它来实际执行视觉或语义操作（例如，创建模型元素）。它必须将要执行的操作封装为<a href="MVC.html#itransactionaloperation">ITransactionalOperation</a> 。
		</p>
		<p><code>IPolicy</code>类似于<a href="MVC.html#ibehavior-abstractbehavior">IBehavior</a> ，因为它绑定到<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> 。但是，行为本身是活跃的（它们主动监听变化），而策略总是从外部调用（它们是被动的）。此外， <code>IPolicy</code>的响应意味着是可<code>IPolicy</code> ，而<a href="MVC.html#ibehavior-abstractbehavior">IBehavior</a>的响应则不是。
		</p>
		<p><code>AbstractPolicy</code>是执行可撤消更改的所有策略的基类。提供<code>init()</code> ， <code>commit()</code>和<code>rollback()</code> ，它包含一个可撤销的事务。
		</p>
		<h4 id="bendconnectionpolicy">BendConnectionPolicy</h4>
		<p><code>BendConnectionPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，可用于操作构成<a href="FX.html#connection">org.eclipse.gef.fx.nodes的点<a href="FX.html#connection">。连接</a> ，即其起点，航点和终点。在移动一个点时，策略会处理：</p>
		<ul>
			<li>删除重叠的邻居点。</li>
			<li>重新添加临时删除的邻居点。</li>
			<li>适用时，将点重新连接到鼠标下的<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> 。
			</li>
		</ul>
		<p>默认情况下， <code>BendConnectionPolicy</code>只能应用于使用<a href="FX.html#connection">org.eclipse.gef.fx.nodes的 <a href="MVC.html#ivisualpart-abstractvisualpart">IVisualParts</a> <a href="FX.html#connection">。连接</a>作为他们的视觉。这可以通过子类化和重写相应的<code>#getConnection()</code>方法来调整。
		</p>
		<h4 id="contentpolicy">ContentPolicy</h4>
		<p><code>ContentPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy，</a>用于处理内容更改，即添加/删除内容子项，以及附加/分离内容锚点。因此，它可以用于检索执行所需内容更改的操作。
		</p>
		<h4 id="creationpolicy">creationPolicy的</h4>
		<p><code>CreationPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，它使用<a href="MVC.html#contentpolicy">ContentPolicy</a>处理新内容对象的创建。因此，它可以用于检索执行所需创建的操作。
		</p>
		<h4 id="deletionpolicy">DeletionPolicy</h4>
		<p><code>DeletionPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，它使用<a href="MVC.html#contentpolicy">ContentPolicy</a>处理现有内容对象的删除。因此，它可以用于检索执行所需删除的操作。
		</p>
		<h4 id="focustraversalpolicy">FocusTraversalPolicy</h4>
		<p><code>FocusTraversalPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，它支持根据已定义但可交换的策略更改焦点部分。
		</p>
		<h4 id="resizepolicy">ResizePolicy</h4>
		<p><code>ResizePolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，支持<a href="MVC.html#iresizablecontentpart">IResizableContentParts的</a>内容大小调整。
		</p>
		<h4 id="transformpolicy">TransformPolicy</h4>
		<p><code>TransformPolicy</code>是一个<a href="MVC.html#abstractpolicy">AbstractPolicy</a> ，支持<a href="MVC.html#itransformablecontentpart">ITransformableContentParts的</a>内容转换。
		</p>
		<h4 id="viewportpolicy">ViewportPolicy</h4>
		<p><code>ViewportPolicy</code>是一个事务策略，可用于操作<a href="FX.html#infinitecanvas">org.eclipse.gef.fx.nodes。InfiniteCanvas</a>内容<a href="MVC.html#infinitecanvasviewer">InfiniteCanvasViewer</a> 。
		</p>
		<hr><div id="MVC.FX:Providers"></div>
		<h3 id="providers">供应商</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.providers</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfx:providers">Providers</a>包提供了许多<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Provider.html" target="doc_external">com.google.inject。提供者</a>或类似的接口，由几种机制使用：</p>
		<ul>
			<li>
				<a href="MVC.html#ibendablecontentpart">IBendableContentPart</a>使用<code>IAnchorProvider</code>来查找<a href="FX.html#ianchor-abstractanchor-anchorkey">org.eclipse.gef.fx.anchors。IAnchor</a>用于<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a> ，其中包含<a href="FX.html#connection">org.eclipse.gef.fx.nodes的一个点<a href="FX.html#connection">。连接</a>可以被附接。
			</li>
			<li>
				<a href="MVC.html#itransformablecontentpart">ITransformableContentPart</a>使用<code>Provider&lt;Affine&gt;</code>来转换<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>的视觉<a href="MVC.html#ivisualpart-abstractvisualpart">效果</a> 。
			</li>
			<li>
				<a href="MVC.html#defaultfocusfeedbackpartfactory-defaulthoverfeebackpartfactory-defaultselectionfeedbackpartfactory">DefaultFocusFeedbackPartFactory，DefaultHoverFeebackPartFactory，DefaultSelectionFeedbackPartFactory</a>和<a href="MVC.html#defaulthoverintenthandlepartfactory-defaultselectionhandlepartfactory">DefaultHoverIntentHandlePartFactory，DefaultSelectionHandlePartFactory</a>使用<code>Provider&lt;IGeometry&gt;</code>来确定反馈的位置和形状并处理视觉效果。
			</li>
		</ul>
		<h4 id="ianchorprovider-defaultanchorprovider">IAnchorProvider，DefaultAnchorProvider</h4>
		<p><code>DefaultAnchorProvider</code>为给定（锚定） <a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>提供锚点。
		</p>
		<h4 id="transformprovider">TransformProvider</h4>
		<p><code>TransformProvider</code>添加了一个<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/transform/Affine.html" target="doc_external">javafx.scene.transform。仿射</a>变换器的视觉部分，它被绑定为适配器。它还允许访问该<a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/transform/Affine.html" target="doc_external">javafx.scene.transform。仿射</a> ，由几个（事务）策略用于执行转换。
		</p>
		<h4 id="geometricoutlineprovider-geometricboundsprovider-shapeoutlineprovider-shapeboundsprovider">GeometricOutlineProvider，GeometricBoundsProvider，ShapeOutlineProvider，ShapeBoundsProvider</h4>
		<p><code>GeometricOutlineProvider</code>和<code>GeometricBoundsProvider</code>返回核心几何以及它们作为适配器绑定到的部分的视觉的相关边界。
		</p>
		<p><code>ShapeOutlineProvider</code>和<code>ShapeBoundsProvider</code>对视觉（形状）轮廓和边界也是如此。
		</p>
		<h4 id="isnappinglocationprovider-boundssnappinglocationprovider-centersnappinglocationprovider-topleftsnappinglocationprovider">ISnappingLocationProvider，BoundsSnappingLocationProvider，CenterSnappingLocationProvider，TopLeftSnappingLocationProvider</h4>
		<p><code>ISnappingLocationProvider</code>提供对齐反馈的捕捉位置。<code>BoundsSnappingLocationProvider</code> ， <code>CenterSnappingLocationProvider</code>和<code>TopLeftSnappingLocationProvider</code>提供不同的默认行为。
		</p>
		<hr><div id="MVC.FX:Viewer"></div>
		<h3 id="viewer">查看器</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.viewer</strong>
			</li>
		</ul>
		<p><a href="MVC#MVC.FX:viewer">Viewer</a>包包含<a href="MVC.html#iviewer">IViewer</a>抽象和相关的默认实现。
		</p>
		<h4 id="iviewer">IViewer</h4>
		<p><code>IViewer</code>是<a href="MVC.html#ivisualpart-abstractvisualpart">IVisualPart</a>层次结构的容器，并提供指向<a href="MVC.html#idomain-historicizingdomain">IDomain</a>的链接。
		</p>
		<h4 id="infinitecanvasviewer">InfiniteCanvasViewer</h4>
		<p><code>InfiniteCanvasViewer</code>是一个提供<a href="FX.html#infinitecanvas">org.eclipse.gef.fx.nodes的<a href="MVC.html#iviewer">IViewer</a>实现<a href="FX.html#infinitecanvas">。InfiniteCanvas</a>作为其可视控件， <a href="MVC.html#irootpart-layeredrootpart">IRootPart为其</a>添加了相应的顶级子级。
		</p>
		<hr>
		<h2 id="mvc-fx-ui">MVC.FX.UI</h2>
		<ul>
			<li>
				<strong>功能：org.eclipse.gef.mvc.fx.ui</strong>
			</li>
			<li>
				<strong>bundle：org.eclipse.gef.mvc.fx.ui</strong>
			</li>
		</ul>
		<p><a href="MVC.html">MVC</a>的<a href="MVC.html#mvcfxui">MVC.FX.UI</a>模块提供了与Eclipse UI集成的方面：</p>
		<ul>
			<li>绑定Eclipse Workbench的操作历史记录。</li>
			<li>一个<a href="MVC.html#undoablepropertysheetpage-undoablepropertysheetentry">UndoablePropertySheetPage，</a>用于贡献Eclipse的“属性”视图。
			</li>
			<li>
				<em> </em>
			</li>
		</ul><div id="MVC.FX.UI:Root"></div>
		<h3 id="root2">{根}</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.ui</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfxui:root">{Root}</a>包中包含一个绑定<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">org.eclipse.jface.viewers的Guice模块<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">。ISelectionProvider</a>并处理FXCanvas的构造以呈现JavaFX场景图。
		</p>
		<h4 id="mvcfxuimodule">MvcFxUiModule</h4>
		<p><code>MvcFxUiModule</code>包含Eclipse集成的绑定。目前，只有<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html" target="doc_external">org.eclipse.core.commands.operations的绑定<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html" target="doc_external">。IOperationHistory</a> Eclipse工作台的设置，使得在一个的上下文中执行的操作<a href="MVC.html#idomain-historicizingdomain">IDomain</a>是可撤消/重做从Eclipse UI。</p>
		<hr><div id="MVC.FX.UI:Actions"></div>
		<h3 id="actions">操作</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.mvc.fx.ui.actions</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfxui:actions">Actions</a>包包含特定的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IAction.html" target="doc_external">org.eclipse.jface.action。IAction</a>和<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionItem.html" target="doc_external">org.eclipse.jface.action。用于删除，滚动和缩放的ContributionItem</a>实现，以及特定的相关<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionGroup.html" target="doc_external">org.eclipse.ui.actions。ActionGroups</a> 。
		</p>
		<h4 id="abstractvieweraction-abstractviewercontributionitem">AbstractViewerAction，AbstractViewerContributionItem</h4>
		<p><code>AbstractViewerAction</code>和<code>AbstractViewerContributionItem</code>是JFace <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Action.html" target="doc_external">org.eclipse.jface.action的扩展<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Action.html" target="doc_external">。Action</a>和<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionItem.html" target="doc_external">org.eclipse.jface.action。ContributionItem</a> ，使它们成为IAdaptable。绑定到IViewer。
		</p>
		<h4 id="abstractvieweractiongroup">AbstractViewerActionGroup</h4>
		<p><code>AbstractViewerActionGroup</code>是<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionGroup.html" target="doc_external">org.eclipse.ui.actions的扩展<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionGroup.html" target="doc_external">。ActionGroup</a> ，可以对AbstractViewerActions和AbstractViewerContributionsItems进行分组。
		</p>
		<h4 id="deleteaction">DeleteAction</h4>
		<p>该<code>DeleteAction</code>处理基于选择的删除<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>在内容查看器。
		</p>
		<h4 id="selectallaction">SelectAllAction</h4>
		<p><code>SelectAllAction</code>处理内容查看器中所有<a href="MVC.html#icontentpart-abstractcontentpart">IContentPart的</a>选择。
		</p>
		<h4 id="abstractzoomaction-zoominaction-zoomoutaction-zoomresetaction-zoomcombocontributionitem-zoomscalecontributionitem-zoomactiongroup">AbstractZoomAction，ZoomInAction，ZoomOutAction，ZoomResetAction，ZoomComboContributionItem，ZoomScaleContributionItem，ZoomActionGroup</h4>
		<p><code>AbstractZoomAction</code>是一个抽象基础实现，用于与缩放内容查看器相关的所有操作。
			<code>ZoomInAction</code> ， <code>ZoomOutAction</code>和<code>ZoomResetAction</code>提供基于它的具体实现。<code>ZoomComboContributionItem</code>和<code>ZoomScaleContributionItem</code>提供SWT组合和缩放以调整缩放级别。<code>ZoomActionGroup</code>将不同的与缩放相关的操作和贡献项组合到一个操作组中。
		</p>
		<h4 id="abstractscrollaction-scrollbottomleftaction-scrollbottomrightaction-scrollcenteraction-scrolltopleftaction-scrolltoprightaction-scrollactiongroup">AbstractScrollAction，ScrollBottomLeftAction，ScrollBottomRightAction，ScrollCenterAction，ScrollTopLeftAction，ScrollTopRightAction，ScrollActionGroup</h4>
		<p><code>AbstractScrollAction</code>是一个抽象基础实现，用于与滚动内容查看器视口相关的所有操作。
			<code>ScrollBottomLeftAction</code> ， <code>ScrollBottomRightAction</code> ， <code>ScrollCenterAction</code> ， <code>ScrollTopLeftAction</code>和<code>ScrollTopRightAction</code>提供基于它的具体实现。<code>ScrollActionGroup</code>将不同的滚动相关操作组合到一个操作组中。
		</p>
		<hr><div id="MVC.FX.UI:Parts"></div>
		<h3 id="parts2">部分</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.mvc.fx.ui.parts</strong>
			</li>
		</ul>
		<p><a href="MVC.html#mvcfxui:parts">Parts</a>包中包含特定的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ViewPart.html" target="doc_external">org.eclipse.ui.part。ViewPart</a>和<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/EditorPart.html" target="doc_external">org.eclipse.ui.part。包含FXCanvas的EditorPart</a>实现。
		</p><small>这个包中与JavaFX无关的类将被移动到[MVC.UI]（MVC＃mvcfxui）模块，如Bugzilla [\＃469478]（https://bugs.eclipse.org/bugs/show_bug.cgi？ ID = 469478）。</small>
		<h4 id="iselectionproviderfactory">ISelectionProviderFactory</h4>
		<p><code>ISelectionProviderFactory</code>接口可用于实现创建<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">org.eclipse.jface.viewers的工厂<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">。给定<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.IWorkbenchPart.html" target="doc_external">org.eclipse.ui的 ISelectionProvider</a> <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.IWorkbenchPart.html" target="doc_external">。IWorkbenchPart</a> 。它用于辅助注射。
		</p>
		<h4 id="contentselectionprovider">ContentSelectionProvider</h4>
		<p><code>ContentSelectionProvider</code>是<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">org.eclipse.jface.viewers的一个实现<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.jface.viewers.ISelectionProvider.html" target="doc_external">。ISelectionProvider</a>接口，提供当前所选<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a>的内容元素， <a href="MVC.html#icontentpart-abstractcontentpart">并可</a>根据其内容元素选择<a href="MVC.html#icontentpart-abstractcontentpart">IContentParts</a> 。
		</p>
		<h4 id="idirtystateprovider-idirtystateproviderfactory">IDirtyStateProvider，IDirtyStateProviderFactory</h4>
		<p><code>IDirtyStateProvider</code>定义了一个接口，AbstractFXEditor可以使用该接口来确定和标记编辑器状态。<code>IDirtyStateProviderFactory</code>可用于为给定的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.IWorkbenchPart.html" target="doc_external">org.eclipse.ui创建<code>IDirtyStateProvider</code> <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.IWorkbenchPart.html" target="doc_external">。IWorkbenchPart</a> 。它用于辅助注射。
		</p>
		<h4 id="historybaseddirtystateprovider">HistoryBasedDirtyStateProvider</h4>
		<p>依赖于IOperationHistory的特定IDirtyStateProvider。</p>
		<h4 id="abstractfxeditor">AbstractFXEditor</h4>
		<p><code>AbstractFXEditor</code>是一个<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.part.EditorPart.html" target="doc_external">org.eclipse.ui.part。EditorPart</a>扩展，可用于将基于<a href="MVC.html#mvcfx">MVC.FX</a>的编辑器嵌入到Eclipse UI中。</p>
		<h4 id="fxeditoractionbarcontributor">FXEditorActionBarContributor</h4>
		<p><code>FXEditorActionBarContributor</code>是一个<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.part.EditorActionBarContributor.html" target="doc_external">org.eclipse.ui.part。EditorActionBarContributor</a>扩展，它允许对应的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.part.IEditorPart.html" target="doc_external">org.eclipse.ui.part的undo / redo操作组<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.part.IEditorPart.html" target="doc_external">。IEditorPart</a>有助于操作栏。
		</p>
		<h4 id="abstractfxview">AbstractFXView</h4>
		<p><code>AbstractFXView</code>是一个<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ViewPart.html" target="doc_external">org.eclipse.ui.part。ViewPart</a>扩展，可用于将基于<a href="MVC.html#mvcfx">MVC.FX</a>的查看器嵌入到Eclipse UI中。</p>
		<hr><div id="MVC.FX.UI:Properties"></div>
		<h3 id="properties">属性</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.mvc.fx.ui.properties</strong>
			</li>
		</ul>
		<p><a href="MVC.html#properties">Properties</a>包提供了将与JavaFX相关的单元格编辑器集成到Eclipse“属性”视图中的支持。
		</p>
		<h4 id="ipropertysheetpagefactory">IPropertySheetPageFactory</h4>
		<p><code>IPropertySheetPageFactory</code>接口允许实现工厂来创建<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySheetPage.html" target="doc_external">org.eclipse.ui.views.properties。用于<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart.html" target="doc_external">org.eclipse.ui的 IPropertySheetPage</a> <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart.html" target="doc_external">。IWorkbenchPart</a> 。
		</p>
		<h4 id="undoablepropertysheetpage-undoablepropertysheetentry">UndoablePropertySheetPage，UndoablePropertySheetEntry</h4>
		<p><code>UndoablePropertySheetPage</code>是一个<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org.eclipse.ui.views.properties.PropertySheetPage.html" target="doc_external">org.eclipse.ui.views.properties。PropertySheetPage</a>扩展，允许执行属性值的撤消/重做更改，以防查看器/编辑器处于非活动状态。
		</p>
		<p><code>UndoablePropertySheetEntry</code>为对<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySource.html" target="doc_external">org.eclipse.ui.views.properties所做的更改提供撤消支持<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySource.html" target="doc_external">。Eclipse的“属性”视图中的IPropertySource</a> 。客户端可以构造<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheetPage.html" target="doc_external">org.eclipse.ui.views.properties。PropertySheetPage</a>并使用此类作为根条目。对该页面上显示的属性源所做的所有更改都将使用提供的<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html" target="doc_external">org.eclipse.core.commands.operations完成。IOperationHistory</a> 。
		</p>
		<h4 id="setpropertyvalueoperation">SetPropertyValueOperation</h4>
		<p><code>SetPropertyValueOperation</code>可用于设置或重置属性的值。它由<a href="MVC.html#undoablepropertysheetpage-undoablepropertysheetentry">UndoablePropertySheetEntry使用</a> 。
		</p>
		<h4 id="fxpaintpropertydescriptor">FXPaintPropertyDescriptor</h4>
		<p><code>FXPaintPropertyDescriptor</code>是一个属性描述符，它集成了<a href="FX.html#fxpaintlabelprovider">org.eclipse.gef.fx.jface。FXPaintLabelProvider</a>和<a href="FX.html#fxpaintcelleditor">org.eclipse.gef.fx.jface。FXPaintCellEditor</a> 。
		</p>
		<hr>
		<h2 id="migration-from-gef4-mvc-1-x-to-gef-mvc-5-x">从GEF4 MVC 1.x迁移到GEF MVC 5.x.</h2>
		<p>在重写GEF 3.x MVC时，我们最初非常注意从JavaFX特定方面（MVC.FX）中分离通用的，独立于渲染工具包的概念（MVC）。背后的动机是为JavaFX之外的其他渲染工具包启用通用概念的潜在重用。事实证明，这不是一个明智的决定，这就是我们在开发GEF MVC 5.x时将MVC与MVC.FX（和MVC.UI与MVC.FX.UI）合并的原因。结果，删除了几个间接，并合并了几个实现类。用于区分JavaFX特定实现与核心抽象的'FX'前缀也被删除。因此，大多数迁移包括丢弃类型参数和调整名称。</p>
		<hr>
		<h2 id="migration-from-gef-mvc-3-x-to-gef4-mvc-1-x">从GEF（MVC）3.x迁移到GEF4 MVC 1.x.</h2>
		<p>
			<a href="MVC.html">MVC</a>完全是从头开始编写的。虽然已经从GEF（MVC）3.x转移了一些经过验证的概念，但已经重新设计了中心概念和机制。最显着的差异是：</p>
		<ul>
			<li>更多的模块化，分离出Eclipse Workbench UI依赖关系：虽然GEF（MVC）3.x提供了一个捆绑包（具有Eclipse UI依赖关系），但<a href="MVC.html">MVC</a>清楚地将这些依赖关系分离为<a href="MVC.html#mvcui">MVC.UI</a>和<a href="MVC.html#mvcfxui">MVC.FX.UI</a>包，以便独立的图形应用程序可以单独基于<a href="MVC.html#mvcfx">MVC.FX</a>和<a href="MVC.html#mvcfx">MVC.FX</a>实现。此外，渲染工具包独立抽象（由提供<a href="MVC.html#mvcfx">MVC.FX</a> ）现在清楚地渲染工具包分离（即JavaFX的）特定具体化（通过提供<a href="MVC.html#mvcfx">MVC.FX</a> 。</li>
			<li>使用JavaFX而不是SWT / Draw2d。</li>
			<li>整个适配器模式的使用：虽然GEF（MVC）3.x仅使用Eclipse Platform为Eclipse Workbench UI集成任务提供适应性模式（例如与属性视图集成），但在<a href="MVC.html">MVC中</a>密集使用此机制来配置完整的图形应用程序。也就是说，工具和观看者适应于领域，观看者模型和根部分适合于观看者，策略和行为适合于视觉部分。
			</li>
			<li>依赖注入的用法</li>
			<li>自己的视觉部件用于反馈和处理（与“轻量级”反馈相比）</li>
			<li>策略分离（被动，由工具调用）和行为（主动，监听变化）</li>
			<li>交互策略的分离（由工具直接调用，与交互相关）和事务策略（由交互策略调用，实现内容操作）</li>
			<li>没有自己的事务逻辑的纯交互基于手势的工具（与单片'选择工具'相比）：与GEF（MVC）3.x相比，其中工具专用于某些语义操作（创建，选择等），工具现在非常愚蠢，专注于交互手势（点击/拖动，滚动等），并将所有交互转发到相应的交互策略。虽然这些工具提供了事务上下文（即它通过域打开和关闭相应的操作，以便由于交互而执行的所有操作可以一起撤消），但它们不会将基于手势的交互转换为语义操作他们自己。这个责任仅在于交互策略。因此，GEF（MVC）3.x应用程序专门使用其中一个默认工具来添加不同的语义行为，现在可以通过注册不同的交互策略来实现，这种交互策略更加轻量级。</li>
		</ul>
	</body>
</html>