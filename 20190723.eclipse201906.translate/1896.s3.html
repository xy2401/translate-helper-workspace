<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s2.html" rel="prev">&lt;&lt;§2角色绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s4.html" rel="next">§4Callin绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="chapter" id="s3">
            <div class="headl">
               <div class="headr">
                  <h1>§3标注绑定</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s3.html">§3标注绑定</a></li>
                  <li><a href="#s3.1">§3.1标注方法绑定</a></li>
                  <li><a href="#s3.2">§3.2标注参数映射</a></li>
                  <li><a href="#s3.3">§3.3升降</a></li>
                  <li><a href="#s3.4">§3.4覆盖访问限制</a></li>
                  <li><a href="#s3.5">§3.5标注字段</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>标注绑定的概念</h3>
               <div class="line"></div>
               <div class="term">标注绑定</div>
               <div class="termdesc">callout绑定声明对角色对象的方法调用可以被<strong>转发</strong>到相关基础对象的基本方法<em>（角色对象“调出”到基础）</em> 。
               </div>
               <div class="line"></div>
               <div class="term">陈述完整性</div>
               <div class="termdesc">即使角色类没有实现所有需要的方法，但是将一些方法转发到它的基础，也必须在角色内声明这些方法。其次，除非通过callout绑定显式声明，否则不会发生转发。
               </div>
               <div class="line"></div>
               <div class="term">预期/提供</div>
               <div class="termdesc">callout绑定将角色类的<strong>预期</strong>方法（此处需要但未实现）绑定到基类的<strong>提供</strong>方法。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s3.1">
               <h2 class="sect">§3.1标注方法绑定<a class="img" href="s3.html#s3.1" title="PermaLinkto§3.1Callout方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§3</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="syntax">→语法§A.3.2</a></div>
               <p>角色类可以通过声明<strong>标注</strong>绑定来获取其任何（预期）方法的实现。
                  		
               </p>
               <div class="subsect depth3" id="s3.1.a">
                  <h4 class="subsect">（a） <span class="title">先决条件：类绑定</span><a class="img" href="s3.html#s3.1.a" title="PermaLink到（a）先决条件：类绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callout绑定要求封闭类是根据<a href="s2.html#s2.1" title="§2.1播放了关系" class="sect">§2.1</a>绑定到基类的角色类。但是，如果角色涉及基类循环（参见<a href="s2.html#s2.1.2.b" title="§2.1.2.(b) Cycles" class="sect">§2.1.2。（b）</a> ），则<a href="s2.html#s2.1.2.b" title="§2.1.2。（b）周期" class="sect">不允许调用绑定</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.b">
                  <h4 class="subsect">（b） <span class="title">定义</span><a class="img" href="s3.html#s3.1.b" title="永久链接到（b）定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callout绑定将抽象角色方法（“预期方法”）映射到具体的基本方法（“提供的方法”）。它可能出现在允许使用功能声明的任何位置的角色类中。它表示为</p>
                  <div class="listing plain"><pre><i>expected_method_designator</i> <b>-&gt;</b> <i>provided_method_designator;</i></pre></div>
                  <p>结果是，对角色方法的任何调用都将使用提供的基本方法转发到关联的基础对象。
                     			
                  </p>
                  <h5 class="listing">示例代码（标注）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>team</b> <b>class</b> Company {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>class</b> Employee <b>playedBy</b> Person {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>abstract</b> String getIdentification();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>    <span class="comment">// callout binding see below...</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s3.1.c">
                  <h4 class="subsect">（c） <span class="title">各种方法指示符</span><a class="img" href="s3.html#s3.1.c" title="PermaLink to（c）各种方法指示符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>方法指示符可以是方法名称</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">4</td>
                           <td><pre>getIdentification <em>-&gt;</em> getName;</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p><strong>或</strong>完整的方法签名，包括参数声明和返回类型声明，但不包括任何修饰符和声明的异常。
                     			
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">4</td>
                           <td><pre>String getIdentification() <em>-&gt;</em> String getName();</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>功效：</h5>
                     <ul>
                        <li>第4行声明了角色方法<code>getIdentification()</code>的标注绑定，为第3行中定义的抽象方法提供了实现。
                        </li>
                        <li>结合第2行中的角色绑定，这具有以下效果：</li>
                        <li>对<code>Employee.getIdentification</code>任何调用都将转发给方法<code>Person.getName</code> 。
                        </li>
                     </ul>
                  </div>
                  <p>标注绑定的两端必须使用相同类型的指示符，即，具有和不具有签名的指示符可以不混合。
                     	    <br>每个方法指示符必须唯一地选择一个方法。如果方法指示符包含签名，则此签名必须与现有方法的签名完全匹配，即，不对此匹配应用隐式转换。如果涉及重载，则<em>必须</em>使用签名来消除歧义。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.d">
                  <h4 class="subsect">（d） <span class="title">继承角色方法声明</span><a class="img" href="s3.html#s3.1.d" title="PermaLink to（d）角色方法声明的继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由callout绑定的role方法可以在与绑定相同的类中声明，也可以从超类或超级接口继承。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.e">
                  <h4 class="subsect">（e） <span class="title">标注覆盖</span><a class="img" href="s3.html#s3.1.e" title="永久链接到（e）标注覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果继承的角色方法是具体的，则关于此方法的callout绑定必须使用标记“ <code>=&gt;</code> ”而不是“ <code>-&gt;</code> ”，以声明此绑定覆盖现有实现。
                     	    <br>对抽象方法使用“ <code>=&gt;</code> ”运算符是一个错误。
                     		<br>callout-bind与绑定在同一个类中实现的方法也是一个错误（并且无论如何都没用）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.f">
                  <h4 class="subsect">（f） <span class="title">标注绑定的继承</span><a class="img" href="s3.html#s3.1.f" title="PermaLink to（f）callout绑定的继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>Callout绑定沿着显式和隐式继承继承。可以使用“ <code>=&gt;</code> ”覆盖继承的标注绑定。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.g">
                  <h4 class="subsect">（g） <span class="title">重复绑定</span><a class="img" href="s3.html#s3.1.g" title="PermaLink到（g）重复绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色类对同一角色方法具有多个标注绑定，则会出错。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.h">
                  <h4 class="subsect">（h） <span class="title">宣布例外</span><a class="img" href="s3.html#s3.1.h" title="PermaLink到（h）声明的例外"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果要由<strong>callout</strong>绑定的基本方法在其<code>throws</code>子句中声明未由相应的角色方法声明的任何异常，则会出错。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.i">
                  <h4 class="subsect">（i） <span class="title">速记定义</span><a class="img" href="s3.html#s3.1.i" title="PermaLink（i）速记定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>其方法指示符指定完整方法签名的callout绑定不需要现有的角色方法。如果没有找到与这种callout绑定的预期方法匹配的角色方法，则隐式生成新方法。如果绑定的基本方法是静态的，则新方法是静态的，并且它声明与绑定的基本方法相同的异常。
                     			
                  </p>
                  <p>速记标注可以选择声明<strong>可见性修饰符</strong> ，否则生成的方法将继承绑定基础方法的可见性修饰符。没有设置其他修饰符。如果标注覆盖了继承的方法或标注，则它不得降低继承的方法/标注的可见性。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.j">
                  <h4 class="subsect">（j） <span class="title">推断标注</span><a class="img" href="s3.html#s3.1.j" title="PermaLink到（j）推断的标注"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果非抽象角色类继承抽象方法，则编译器会尝试推断出用于实现抽象方法的标注绑定。同样，如果无法解析角色类中的自调用，编译器会尝试推断出一个callout来解析自调用。<br>推断搜索绑定基类中的方法，使其成为可能</p>
                  <ol>
                     <li>两种方法都有相同的名称</li>
                     <li>两种方法都有相同数量的参数</li>
                     <li>abstract role方法的每个参数都直接与base方法的相应参数兼容，或者使用装箱/拆箱或降低。
                     </li>
                  </ol>
                  <p>从界面推断出的标注具有<code>public</code>可见性，从自我呼叫推断出的标注具有<code>private</code>可见性。
                     
                  </p>
                  <p>默认推断的标注绑定被禁用，即编译器必须将这些绑定报告为错误。但是，编译器应该允许配置报告以仅生成警告（可以使用<code>@SuppressWarnings("inferredcallout")</code>注释来抑制），或者完全忽略诊断。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.1.k">
                  <h4 class="subsect">（k） <span class="title">标注通用方法</span><a class="img" href="s3.html#s3.1.k" title="PermaLink to（k）Callout to generic method"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在提到通用基本方法时</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre>&lt;T&gt; T bm(T a)</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>标注绑定可以传播方法的通用性，如</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">2</td>
                           <td><pre>&lt;T&gt; T rm(T a) <b>-&gt;</b> T bm(T a);</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>或者它可以提供类型参数的有效替换，如</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">2</td>
                           <td><pre>String rm(String a) <b>-&gt;</b> String bm(String a);</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>callout绑定要么将实现附加到先前声明的方法，要么将转发方法添加到角色类<a href="#s3.1.i" title="§3.1.(i) Shorthand definition" class="sect">（</a>上面的<a href="#s3.1.i" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a> ）。除此实现外，callout-bound方法与常规方法没有区别。
                  		
               </p>
               <p>当我们说，callout绑定定义<strong>转发</strong>这意味着控制被传递给基础对象。相反，通过<strong>委托</strong>语义控制<em>将</em>保留在角色对象中，从而从角色开始再次调度自调用。自己的标注绑定不支持委派。但是，结合使用callin绑定的方法覆盖（参见<a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ），可以轻松实现委派的效果。
                  		
               </p>
            </div>
            <div class="sect depth2" id="s3.2">
               <h2 class="sect">§3.2标注参数映射<a class="img" href="s3.html#s3.2" title="PermaLink至§3.2Sallout参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§3</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.4.1" title="§A.4.1CalloutParameterMappings" class="syntax">→语法§A.4.1</a></div>
               <div class="subsect depth3" id="s3.2.a">
                  <h4 class="subsect">（a） <span class="title">与条款</span><a class="img" href="s3.html#s3.2.a" title="PermaLink到（a）with子句"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callout绑定中的方法指示符是签名（不仅仅是方法名称），则可以使用<code>with{...}</code>子子句映射参数和返回值。仅当封闭角色是类而不是接口时，才会发生参数映射。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.2.b">
                  <h4 class="subsect">（b） <span class="title">映射一个参数</span><a class="img" href="s3.html#s3.2.b" title="PermaLink到（b）映射一个参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>对于提供的基本方法的每个参数，只有一个参数映射定义，实际将哪个值传递给基本方法。Callout参数映射具有以下形式：</p>
                  <div class="listing plain"><pre><i>expression</i> <b>-&gt;</b> <i>base_method_parameter_name</i></pre></div>
               </div>
               <div class="subsect depth3" id="s3.2.c">
                  <h4 class="subsect">（c） <span class="title">结果映射</span><a class="img" href="s3.html#s3.2.c" title="PermaLink到（c）结果映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callout方法的返回值可以由结果映射提供：</p>
                  <div class="listing plain"><pre>result <b>&lt;-</b> <i>expression</i></pre></div>
                  <p>结果映射的右侧表达式可以使用特殊标识符<code>result</code>来引用base方法返回的值。
                     		<br>在使用参数映射进行绑定的方法中，使用<code>result</code>作为常规方法参数的名称是错误的。
                     			
                  </p>
                  <h5 class="listing">示例代码（标注参数映射）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre>Integer absoluteValue(Integer integer) <b>-&gt;</b> <b>int</b> abs(<b>int</b> i) <em><b>with</b> {</em></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  integer.intValue() <b>-&gt;</b> i,</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <em>result</em> <b>&lt;-</b> <b>new</b> Integer(<em>result</em>)</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre><em>}</em></pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s3.2.d">
                  <h4 class="subsect">（d） <span class="title">可见名称</span><a class="img" href="s3.html#s3.2.d" title="永久链接到（d）可见名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>出现在参数映射表达式中的每个标识符必须是：</p>
                  <ul>
                     <li>角色实例范围内可见的功能。</li>
                     <li>角色方法的参数（用于参数映射）。</li>
                     <li>特殊名称<code>result</code> （用于结果映射）。
                     </li>
                     <li>在结果映射中，也可以使用特殊名称<code>base</code>来引用绑定的基本实例（前提是绑定的方法不是静态的）。
                     </li>
                  </ul>
                  <p>基本方法参数的名称（即映射后的名称）仅在<a href="#s3.2.b" title="§3.2。（b）映射一个参数" class="sect">§3.2。（b）中</a>给出的位置是合法的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.2.e">
                  <h4 class="subsect">（e） <span class="title">隐式参数映射</span><a class="img" href="s3.html#s3.2.e" title="PermaLink到（e）隐式参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果应省略参数映射，则必须满足以下条件：</p>
                  <ol>
                     <li>角色方法的每个方法参数必须符合基本方法的相应参数， <em>并且</em></li>
                     <li>基本方法的结果类型必须符合角色方法的结果类型。
                     </li>
                  </ol>
                  <p>这里的一致性包括翻译多态性（参见<a href="#s3.3.d" title="§3.3。（d）打字规则" class="sect">§3.3。（d）</a> ）。
                     		<br>没有参数映射的参数对应由声明顺序而不是名称确定。
                     	    <br>但是，可以隐式执行两项调整：</p>
                  <ul>
                     <li>如果角色方法具有比基本方法更多的参数，则可以静默忽略未使用的尾随参数。
                     </li>
                     <li>如果role方法返回<code>void</code> ，则可以静默忽略base方法的任何结果。
                     </li>
                  </ul>
               </div>
               <h5 class="listing">示例代码（带参数映射的标注）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>public</b> <b>abstract</b> <b>class</b> Role1 {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>abstract</b> <b>void</b> payEuro(float euro);</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>    <b>abstract</b> float earnEuro();</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>    <b>void</b> idle(<b>int</b> seconds) { <span class="comment">/* do nothing */</span> };</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  Role1 boss, worker = <span class="comment">// initialization omitted</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>  <b>public</b> <b>void</b> transaction () {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>    boss.payEuro(worker.earnEuro());</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>    boss.idle(123);</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre><b>public</b> <b>class</b> Staff { <span class="comment">// a base class </span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>  <b>public</b> <b>void</b> payDM (float dm) { … };</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>  <b>public</b> float earnDM () { … };</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">16</td>
                        <td><pre>  <b>public</b> <b>int</b> doze() { … };</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">17</td>
                        <td><pre>  <span class="comment">// other methods omitted</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">18</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">19</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> MySubTeam <b>extends</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">20</td>
                        <td><pre>  <b>public</b> <b>class</b> Role1 <b>playedBy</b> Staff {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">21</td>
                        <td><pre>    <b>void</b> payEuro(float euro) <b>-&gt;</b> <b>void</b> payDM(float dm) <b>with</b> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">22</td>
                        <td><pre>      euro * 1.95583f <b>-&gt;</b> dm</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">23</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">24</td>
                        <td><pre>    float earnEuro() <b>-&gt;</b> float earnDM () <b>with</b> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">25</td>
                        <td><pre>      result <b>&lt;-</b> result / 1.95583f</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">26</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">27</td>
                        <td><pre>    idle <b>=&gt;</b> doze; <span class="comment">// override existing implementation of idle()</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">28</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">29</td>
                        <td><pre>  <b>void</b> doit() {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">三十</td>
                        <td><pre>    transaction();</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">31</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">32</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <ul>
                     <li>类<code>MyTeamA</code>是声明性完整的，可以进行类型检查，因为它只使用在此上下文中可见或声明的方法。但是， <code>MyTeamA.Role1</code>不能被实例化，因为它是抽象的。
                     </li>
                     <li>第30行具有调用<code>transaction</code>的正常效果。
                     </li>
                     <li>执行<code>transaction</code> ，使用方法<code>earnDM()</code> （第24行中的绑定声明<code>worker.earnEuro()</code>将<code>worker.earnEuro()</code>的调用转发到相应的基础对象。结果由“ <code>result / 1.95583f</code> ”（第25行）转换。
                     </li>
                     <li>在同一个<code>transaction</code>执行中，使用方法<code>payDM()</code> （第21行中的绑定声明<code>boss.payEuro()</code>将<code>boss.payEuro()</code>的调用转发到相应的基础对象。参数<code>euro</code>由“ <code>euro * 1.95583f</code> ”（第22行）转换。
                     </li>
                     <li>方法<code>idle</code>被转发到<code>doze</code>而没有任何参数映射。这需要<code>doze</code>以具有符合<code>idle</code>签名的签名。在这种情况下，将忽略角色参数和基本结果。<br>使用<code>=&gt;</code>运算符，此绑定将覆盖现有的<code>idle</code>实现。
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="s3.3">
               <h2 class="sect">§3.3升降<a class="img" href="s3.html#s3.3" title="PermaLinkto§3.3提升和降低"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§3</a></span></h2>
               <p>（基本定义见<a href="s2.html#s2.2" title="§2.2降低" class="sect">§2.2</a>和<a href="s2.html#s2.3" title="§2.3提升" class="sect">§2.3</a> ）</p>
               <div class="subsect depth3" id="s3.3.a">
                  <h4 class="subsect">（a） <span class="title">呼叫目标翻译</span><a class="img" href="s3.html#s3.3.a" title="永久链接到（a）呼叫目标翻译"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由于callout绑定而调用基本方法首先<strong>降低</strong>角色对象以获得有效的调用目标。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.3.b">
                  <h4 class="subsect">（b） <span class="title">参数翻译</span><a class="img" href="s3.html#s3.3.b" title="PermaLink to（b）参数转换"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果基本方法声明了相应的基本类型参数，则将角色对象作为参数传递给callout方法会隐式<strong>降低</strong>此参数。
                     	    <br>不能提升标注参数。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.3.c">
                  <h4 class="subsect">（c） <span class="title">结果翻译</span><a class="img" href="s3.html#s3.3.c" title="PermaLink到（c）结果翻译"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>从callout方法返回基础对象时，其中role方法将结果声明为角色类，此对象将隐式<strong>提升</strong>为适当的角色。
                     	    <br>降低标注绑定的结果是不可能的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.3.d">
                  <h4 class="subsect">（d） <span class="title">打字规则</span><a class="img" href="s3.html#s3.3.d" title="永久链接到（d）键入规则"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果左侧符合右侧，则通过参数映射（由参数位置隐式或由<code>with</code>子句显式）可以<strong>很好地键入</strong></p>
                  <ul>
                     <li>类型相等</li>
                     <li>隐式原始类型转换</li>
                     <li>亚型多态性</li>
                     <li>翻译多态性，这里： <em>降低</em> ，</li>
                     <li><em>或者</em>通过上述的组合。
                     </li>
                  </ul>
                  <p>如果右侧的值根据上面给出的规则符合左侧，则结果映射（由<code>with</code>子句隐式或显式）是良好类型的，除了这里的转换多态性应用<em>提升</em>而不是降低。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.3.e">
                  <h4 class="subsect">（e） <span class="title">角色阵列</span><a class="img" href="s3.html#s3.3.e" title="PermaLink到（e）角色数组"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>对于作为参数<a href="s2.html#s2.2.e" title="§2.2.(e) Lowering of arrays" class="sect">§2.2</a>的角色数组<a href="s2.html#s2.2.e" title="§2.2。（e）降低阵列" class="sect">。（e）相应地</a>适用。对于数组，作为返回值<a href="s2.html#s2.3.d" title="§2.3。（d）提升阵列" class="sect">§2.3。（d）</a>适用。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s3.4">
               <h2 class="sect">§3.4覆盖访问限制<a class="img" href="s3.html#s3.4" title="PermaLinkto§3.4覆盖访问限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§3</a></span></h2>
               <p>与普通访问限制相反，方法绑定可以引用隐藏的基本方法。这个概念与封装相反，因此称为解<strong>封装</strong> 。
                  <br>在这些位置可能会发生解封装：</p>
               <ul>
                  <li><code>playedBy</code>声明（见<a href="s2.html#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）</li>
                  <li>基础构造函数调用（参见<a href="s2.html#s2.4.2.b" title="§2.4.2。（b）约束角色" class="sect">§2.4.2。（b）</a> ）。
                  </li>
                  <li>标注绑定（见下）</li>
                  <li>标注字段（见<a href="#s3.5.e" title="§3.5。（e）访问控制" class="sect">§3.5。（e）</a> ）</li>
                  <li>callin方法中的基本调用（参见<a href="s4.html#s4.6" title="§4.6覆盖访问限制" class="sect">§4.6</a> ）</li>
               </ul>
               <div class="subsect depth3" id="s3.4.a">
                  <h4 class="subsect">（a） <span class="title">标注无法访问的基本方法</span><a class="img" href="s3.html#s3.4.a" title="永久链接到（a）标注不可访问的基本方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>通过<strong>callout</strong>绑定，无论访问修饰符如何，都可以访问基类的方法。方法绑定是程序中唯一可以提及其他方法无法访问的方法。根据角色方法的声明，在角色端访问callout方法由常规机制控制。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.4.b">
                  <h4 class="subsect">（b） <span class="title">密封以解封</span><a class="img" href="s3.html#s3.4.b" title="永久链接到（b）密封解封装"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以“密封”基础包，其重新建立标准Java可见性规则。
                     		<br>密封是通过Jar文件的相应功能实现的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.4.c">
                  <h4 class="subsect">（c） <span class="title">警告级别</span><a class="img" href="s3.html#s3.4.c" title="永久链接到（c）警告级别"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>编译器应发出任何解封装信号。如果编译器支持配置警告，这可以用于让用户选择（a）忽略基类解封装，（b）将其视为警告或甚至（c）将其视为错误（参见<a href="s2.html#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）。
                     		<br>可选地，批处理编译器可以支持关于解封装的三个级别的详细程度：</p>
                  <table border="1">
                     <tr>
                        <td rowspan="1" colspan="1"><tt>-nodecapsulation</tt></td>
                        <td rowspan="1" colspan="1">没有警告。</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><em>默认</em></td>
                        <td rowspan="1" colspan="1">仅在覆盖访问限制时发出警告。</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><tt>-decapsulation</tt></td>
                        <td rowspan="1" colspan="1">包含绑定和隐藏基本方法的详细消息。</td>
                     </tr>
                  </table>
               </div>
               <div class="subsect depth3" id="s3.4.d">
                  <h4 class="subsect">（d） <span class="title">超级班的私人方法</span><a class="img" href="s3.html#s3.4.d" title="PermaLink to（d）超类的私有方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callout绑定应绑定到私有基本方法，则必须使用<code>playedBy</code>在当前角色类绑定到<code>playedBy</code>类中定义该方法。即，对于私人方法<a href="#s3.1.d" title="§3.1。（d）角色方法声明的继承" class="sect">§3.1。（d）</a>不成立。
                     <br>私有基础领域也是如此（见下文）。
                     <br>如果私有基本特征必须确实是标注绑定，则必须定义由定义私有特征的确切基类播放的角色类。然后可以将绑定到子基类的另一个角色定义为第一个角色的子类。它将继承callout绑定，通过它可以访问所需的功能。
                     			
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>public</b> <b>class</b> SuperBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <em><b>private</b> <b>int</b> secret;</em></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre><b>public</b> <b>class</b> SubBase <b>extends</b> SuperBase  { <span class="comment">/* details omitted */</span> }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  <b>protected</b> <b>class</b> SuperRole <b>playedBy</b> SuperBase {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>    <b>int</b> steal() <b>-&gt;</b> <b>get</b> <b>int</b> <em>secret</em>; <span class="comment">// <span class="green"><strong>OK</strong></span></span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>  <b>protected</b> <b>class</b> SubRole <b>extends</b> SuperRole <b>playedBy</b> SubBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>    <b>int</b> steal() <b>-&gt;</b> <b>get</b> <b>int</b> <em>secret</em>; <span class="comment">// <span class="error"><strong>illegal!</strong></span></span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s3.5">
               <h2 class="sect">§3.5标注字段<a class="img" href="s3.html#s3.5" title="PermaLinkto§3.5Callout to field"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§3</a></span></h2>
               <p>还可以使用标注绑定使基类的字段可访问。
                  		
               </p>
               <div class="subsect depth3" id="s3.5.a">
                  <h4 class="subsect">（a） <span class="title">语法</span><a class="img" href="s3.html#s3.5.a" title="PermaLink到（a）语法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>使用其中一个callout修饰符<code>get</code>或<code>set</code>一个角色方法可以绑定到角色基类的一个字段：</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre>getValue <b>-&gt;</b> <em>get</em> value;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>setValue <b>-&gt;</b> <em>set</em> value;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre><b>int</b> getValue() <b>-&gt;</b> <em>get</em> <b>int</b> value;</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>其中<code>getValue</code> ， <code>setValue</code>是适当签名的抽象角色方法， <code>value</code>是绑定基类的字段。
                     	    <br>也可以使用更长的语法（参见上面第3行），它使用完整的签名。对于左侧<a href="#s3.1.c" title="§3.1。（c）各种方法指示符" class="sect">§3.1。（c）</a>适用，对于右侧，此较长版本将字段类型添加到字段名称之前。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.b">
                  <h4 class="subsect">（b） <span class="title">兼容性</span><a class="img" href="s3.html#s3.5.b" title="PermaLink（b）兼容性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>与修饰符<code>get</code>绑定的角色方法应该没有参数（它<em>可以</em>具有任意参数，这些参数被静默忽略）并且应该具有与基本字段兼容的返回类型。返回void的role方法将忽略给定的值，因此根本没有任何影响，这将由编译器警告发出信号。
                     <br>与修饰符<code>set</code>绑定的角色方法必须具有与基本字段类型兼容的第一个参数（其他参数 - 如果存在 - 将被静默忽略），并且不得声明返回类型。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.c">
                  <h4 class="subsect">（c） <span class="title">价值绘图</span><a class="img" href="s3.html#s3.5.c" title="PermaLink到（c）值映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以映射值，类似于纯方法绑定中的参数映射（第<a href="#s3.2" title="§3.2标注参数映射" class="sect">3.2节</a> ）。这种映射可用于建立上述要求的兼容性。
                     		<br>在<code>get</code>和<code>set</code>绑定中，基本侧值由字段的名称表示（下面的第2行和第4行）。
                     			
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre>Integer getValue()       -&gt;	<em>get</em> <b>int</b> val</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <em>with</em> { result           &lt;-	<b>new</b> Integer(val) }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre><b>void</b> setValue(Integer i) -&gt;	<em>set</em> <b>int</b> val</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <em>with</em> { i.intValue()     -&gt;	val }</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s3.5.d">
                  <h4 class="subsect">（d） <span class="title">效果</span><a class="img" href="s3.html#s3.5.d" title="永久链接到（d）效果"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>将角色方法的callout绑定到基本字段会为此角色方法生成一个实现，通过该实现，它充当相关基础对象的给定字段的getter或setter。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.e">
                  <h4 class="subsect">（e） <span class="title">访问控制</span><a class="img" href="s3.html#s3.5.e" title="永久链接到（e）访问控制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>为了访问否则不可见的字段，解<a href="#s3.4" title="§3.4 Overriding access restrictions" class="sect">封装</a>规则<a href="#s3.4" title="§3.4覆盖访问限制" class="sect">（§3.4）相应地</a>适用。
                     		<br>回想一下，根据<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#40898" class="ext">JLS§8.3，</a>字段可能隐藏在给定基类的子类中。因此，知道对字段的标注将始终访问在定义标注的角色类的确切基类中可见的字段是相关的。这对于访问私有字段尤其重要。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.f">
                  <h4 class="subsect">（f） <span class="title">速记定义</span><a class="img" href="s3.html#s3.5.f" title="PermaLink到（f）速记定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>正如在<a href="#s3.1.i" title="§3.1.(i) Shorthand definition" class="sect">§3.1</a>中<a href="#s3.1.i" title="§3.1。（i）速记定义" class="sect">那样。（i）</a>简写定义允许引入一个没有事先抽象声明的callout字段访问方法。这要求callout字段绑定指定类型，如上面<a href="#s3.5.a" title="§3.5。（a）语法" class="sect">§3.5。（a）的</a>第3行。如果绑定的基本字段是静态的，则生成的访问方法是静态的。
                     			
                  </p>
                  <p>对字段的简写标注可以选择声明<strong>可见性修饰符</strong> ，否则生成的方法将继承绑定基本字段的可见性修饰符。没有设置其他修饰符。如果字段的标注覆盖了继承的方法或标注，则它不能降低继承的方法/标注的可见性。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.g">
                  <h4 class="subsect">（g） <span class="title">标注覆盖</span><a class="img" href="s3.html#s3.5.g" title="PermaLink到（g）标注覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>与方法调用类似，当且仅当使用token <code>=&gt;</code>而不是<code>-&gt;</code> callout to field可以覆盖现有的角色方法（参见<a href="#s3.1.e" title="§3.1。（e）标注覆盖" class="sect">§3.1。（e）</a>和<a href="#s3.1.f" title="§3.1。（f）标注绑定的继承" class="sect">§3.1。（f）</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s3.5.h">
                  <h4 class="subsect">（h） <span class="title">推断标注</span><a class="img" href="s3.html#s3.5.h" title="永久链接到（h）推断出的标注"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果绑定角色类的体内的语句或表达式使用一个简单的名称或限定名称<code>this</code>不能使用普通的规则来解决，编译器可以推断使用标注，而不是到现场，考虑到的一个领域必需的名称可以在角色的声明的基类中找到。
                     
                  </p>
                  <p>如果已明确声明了对字段的标注，则将其用于其他未解析的名称，当且仅当：</p>
                  <ul>
                     <li>callout声明一个角色方法名称，它是根据setter的“set”构造的，或者是getter的“get”加上带有首字母的字段名，</li>
                     <li>callout引用的基本字段具有所需的名称，和</li>
                     <li>callout kind（set / get）将未解析名称的应用程序与赋值（set）的左侧或表达式（get）相匹配。
                     </li>
                  </ul>
                  <p>如果未找到匹配的字段标注，则编译器会自动生成一个具有<code>private</code>可见性的标注。
                     
                  </p>
                  <p>如果已经推断出字段的标注，则直接调用根据上述规则形成的隐式生成的标注访问器是错误的。
                     
                  </p>
                  <p>默认推断的标注绑定被禁用，即编译器必须将这些绑定报告为错误。但是，编译器应该允许配置报告以仅生成警告（可以使用<code>@SuppressWarnings("inferredcallout")</code>注释来抑制），或者完全忽略诊断。另见<a href="#s3.1.j" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a> 。
                     
                  </p>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s2.html" rel="prev">&lt;&lt;§2角色绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s4.html" rel="next">§4Callin绑定&gt;&gt;</a></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>