<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>创建元模型绑定</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="ProgrammersGuide.html" title="Classic Ecore/UML Programmers Guide">
<link rel="prev" href="Persistence.html" title="OCL Persistence">
<link rel="next" href="ImpactAnalyzer.html" title="Incrementally Re-Evaluating OCL Expressions Using the Impact Analyzer">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">创建元模型绑定</h1>
<div class="section" title="创建元模型绑定">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="AdvancedMetamodelBindings"></a>创建元模型绑定</h2>
</div>
</div>
</div>
<p>Eclipse OCL组件提供了OCL抽象语法模型的通用规范，以及两个流行的Eclipse元模型的绑定：Ecore和UML。OCL API的用户同样可以为其元模型创建绑定，以将OCL与其建模语言集成。</p>
<p><a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Environment.html" target="_new"><code class="code">Environment</code></a>接口有一个带有几个参数的泛型类型签名，表示OCL所需的元模型构造，它借用了UML，EMOF以及它所针对的其他元模型。该接口的Javadoc定义了映射，并且在整个OCL API中始终使用相同的类型参数名称。</p>
<p>
				
</p>
<div class="mediaobject">
<img src="images/5180-bindings.png"></div>
<p>
			
</p>
<p>要提供元模型绑定，客户端必须提供以下接口的实现：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
						
<code class="code">Environment</code>和<code class="code">EnvironmentFactory</code> ，为泛型类型参数提供合适的替换。请注意，并非所有这些都是实际需要的;例如，Ecore没有<code class="code">State</code>的概念，所以它只是替代了<code class="code">EObject</code>
					
</p>
</li>
<li class="listitem">
<p>
						
<code class="code">EvaluationEnvironment</code>用于访问模型的运行时实例的属性</p>
</li>
<li class="listitem">
<p>
						
<code class="code">UMLReflection</code>的反思模型（所述目标元模型的实例）</p>
</li>
<li class="listitem">
<p>
						
<code class="code">OCLStandardLibrary</code> ，提供实现OCL标准库类型的元模型的<code class="code">Classifier</code>元类的实例</p>
</li>
<li class="listitem">
<p>
						
<code class="code">OCLFactory</code> ，为抽象语法模型的所有元类提供工厂</p>
</li>
</ul>
</div>
<p>上面的最后一项还需要元模型绑定提供抽象语法模型（完整地）的具体专门化，其混合在UML <code class="code">Classifier</code>和<code class="code">TypedElement</code>元类的目标元模型的对应<code class="code">TypedElement</code> 。前者需要提供OCL <code class="code">Types</code>中元<code class="code">Types</code>与目标元模型类型系统的兼容性。后者是OCL <code class="code">Expressions</code>包中的元类与目标元模型的类型元素的兼容性所必需的。
			</p>
<div class="section" title="OCL抽象语法模型">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLAbstractSyntaxModel"></a> OCL抽象语法模型</h3>
</div>
</div>
</div>
<p>下图总结了OCL <code class="code">Types</code>包的元类：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5180-ocltypes.png"></div>
<p>
				
</p>
<p>下图总结了OCL <code class="code">Expressions</code>包的调用表达式元类：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5180-callexp.png"></div>
<p>
				
</p>
<p>下图总结了OCL <code class="code">Expressions</code>包的文字表达式元类：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5180-literalexp.png"></div>
<p>
				
</p>
<p>下图总结了OCL <code class="code">Expressions</code>包的其余元类：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5180-miscexp.png"></div>
<p>
				
</p>
</div>
</div>
</body>
</html>