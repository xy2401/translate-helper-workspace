<html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s1.3.1.j.html" rel="prev">&lt;&lt;§1.3.1。（j）覆盖和兼容性</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a> &gt; <a class="nav" href="s1.3.html" rel="section">§1.3角色类的</a> <a class="nav" href="s1.3.1.html" rel="section">获取和隐式继承</a> &gt; <a class="nav" href="s1.3.1.html" rel="section">§1.3.1</a> <a class="nav" href="s1.3.html" rel="section">角色类的</a> <a class="nav" href="s1.3.1.html" rel="section">获取和隐式继承</a></div>
         <div class="subsect depth4" id="s1.3.1.k">
            <h4 class="subsect">§1.3.1。（k） <span class="title">协变返回类型</span><a class="img" href="s1.3.1.k.html" title="PermaLink到（k）协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
            <p>给定一组<code>T1</code>与两个角色<code>R1</code>和<code>R2</code> ，其中<code>R2</code>明确地从继承<code>R1</code> ，两个角色定义一个方法<code>m</code>返回某种类型的<code>A</code> 。还给出了一个<code>T1</code> ， <code>T2</code>的子团队，其中<code>T2.R1</code>使用协变返回类型<code>B</code> （ <code>A</code>子类型）覆盖<code>m</code> ：</p>
            <div class="listing plain"><pre>    <b>公共</b> <b>团队</b> <b>类</b> T1 { <b>protected</b> <b>abstract</b> <b>class</b> R1 { <b>abstract</b> A m（）; } <b>protected</b> <b>class</b> R2 <b>扩展</b> R1 {A m（）{ <b>return</b> <b>new</b> A（）; <b>public</b> <b>team</b> <b>class</b> T2 <b>扩展</b> T1 { <b>protected</b> <b>class</b> R1 {@Override B m（）{ <b>return</b> <b>new</b> B（）; } <span class="error">//此声明呈现<b>类</b> T2。R2非法</span> }}</pre></div>
            <p>在这种情况下角色<code>T2.除非还使用至少为<code>B</code>的返回类型覆盖<code>m</code> ，否则R2</code>将是非法的。注意，实际错误发生在隐式继承的方法<code>T2.R2.m</code>在源代码中不可见，甚至是<code>T2.不需要在源代码中明确提及R2</code> 。编译器应将此标记为团队级别的不兼容性，因为团队必须以一致的方式专门化继承的角色。
               				
            </p>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s1.3.1.j.html" rel="prev">&lt;&lt;§1.3.1。（j）覆盖和兼容性</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a> &gt; <a class="nav" href="s1.3.html" rel="section">§1.3角色类的</a> <a class="nav" href="s1.3.1.html" rel="section">获取和隐式继承</a> &gt; <a class="nav" href="s1.3.1.html" rel="section">§1.3.1</a> <a class="nav" href="s1.3.html" rel="section">角色类的</a> <a class="nav" href="s1.3.1.html" rel="section">获取和隐式继承</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>