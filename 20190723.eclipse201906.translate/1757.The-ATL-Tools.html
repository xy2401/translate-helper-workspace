<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>ATL用户指南 -  ATL工具</title>
		<link type="text/css" rel="stylesheet" href="book.css"/>
	</head>
	<body>
<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">ATL工具</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="The-ATL-Language.html" title="ATL语言">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">ATL语言</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table><hr>
		<h1 id="The_ATL_Tools">ATL工具</h1>
		<p>本节提供了ATL工具的完整描述，然后旨在解释它们的用法。</p>
		<h2 id="Perspectives">展望</h2>
		<p>在Eclipse中，透视的概念指的是工作台配置，其被安排以优化对特定任务的处理。工作台通常由几个子窗口（称为视图）和工具包组成。ATL与两个特定的视角相关联：主要的ATL透视图和ATL Debug透视图，它们分别专门用于ATL转换的设计和调试。切换到ATL以及Eclipse平台上可用的其他视角，可以通过工作台右上角的拇指索引中的透视按钮，或通过在透视图菜单中选择透视图来实现。 （ <i>菜单栏 - &gt;窗口 - &gt;打开透视图 - &gt;其他...</i> ）。
		</p>
		<h3 id="ATL_perspective">ATL的观点</h3>
		<p>ATL视角是ATL发展的主要视角。它提供了创建ATL项目，ATL转换文件和ATL启动配置所需的所有功能。该透视图还包括专用于ATL文件的文本编辑器。ATL透视图由七个不同的视图组成：导航器，编辑器，大纲，控制台，错误日志，属性和问题视图。以下是ATL视角下的ATL项目的屏幕截图。</p>
		<p>
			<img border="0" src="images/ATL_perspective.png">
		</p>
		<p>在其默认配置中，ATL透视图在窗口左侧显示“导航器”视图。编辑器视图位于窗口的顶部中间部分，而“大纲”视图位于透视图的左上部分。最后，剩余的四个视图（问题，属性，错误日志和控制台）共享透视图的底部。请注意，只需双击视图标题即可在整个透视图中显示给定视图。通过再次双击视图标题，可以返回到原始透视配置。ATL透视图的不同视图将在以下小节中详细说明。</p>
		<h4 id="Navigator">航海家</h4>
		<p>除了浏览工作台的内容外，Navigator视图还对其包含的不同包含元素提供了许多上下文操作。上下文操作列表（取决于所选元素的类型）显示在通过右键单击给定元素获得的上下文菜单中。</p>
		<p>“导航器”视图中可用的有趣上下文操作包括：</p>
		<ul>
			<li>在Navigator根目录下创建一个新的ATL项目（ <i>New-&gt; ATL Project</i> ）;</li>
			<li>从ATL项目创建新的ATL文件（ <i>New-&gt; ATL File</i> ）;</li>
			<li>从ATL项目创建目录（ <i>New-&gt; Other ...-&gt; Simple-&gt; Folder</i> ）;</li>
			<li>运行/调试ATL文件（ <i>运行方式 - &gt;运行.../ Debug As-&gt; Debug</i> ）;</li>
			<li>使用ATL编辑器打开ATL文件（ <i>打开方式 - &gt; ATL编辑器</i> ）。由于ATL Editor是ATL文件的默认编辑器，因此只需双击ATL文件即可启动它。</li>
			<li>使用Sample Ecore Model Editor（ <i>Open With-&gt; Sample Ecore Model Editor</i> ）打开Ecore文件。Sample Ecore Model Editor是Ecore文件的默认编辑器。因此，可以通过双击Ecore文件来启动它;</li>
		</ul>
		<p>请注意，从“导航器”视图打开的文件内容将通过所选编辑器显示在“编辑器”视图中。</p>
		<h4 id="Editors">编者</h4>
		<p>Eclipse有助于开发强大的源编辑器。因此，除了Eclipse和EMF框架提供的默认编辑器之外，还实现了一个ATL编辑器，以便简化ATL转换的输入。此编辑器是<i>.atl</i>文件的默认编辑器。它执行语法突出显示，显示已定义断点的位置，还执行运行时解析，编译和错误检测。ATL编辑器强调了在编译时检测到的问题。有关这些问题的详细信息显示在“ <a href="The-ATL-Tools.html#Problems">问题”视图中</a> 。这些详细信息包括检测到的问题类型（错误，警告或样式），问题的文本描述以及编译文件中此问题的定位（行号和列号）。请注意，保存包含语法正确的ATL程序的ATL文件的修改会触发此文件的编译，从而生成新的ASM汇编程序文件。汇编程序文件的扩展名为<i>.asm，</i>并包含相应ATL文件的已编译代码。
		</p>
		<p>请注意，在通过ATL编辑器编辑ATL文件时，会在“ <a href="The-ATL-Tools.html#Outline">大纲”视图中</a>同时显示ATL转换的<a href="The-ATL-Tools.html#Outline">大纲</a> 。
		</p>
		<h4 id="Outline">大纲</h4>
		<p>Outline视图旨在为ATL开发人员提供编辑器视图中正在编辑的文件的结构元素的概述。为此，必须将“大纲”视图与“编辑器”视图的活动选项卡同步。</p>
		<p>在ATL文件的范围内，“大纲”视图显示当前编辑的转换的结构。从ATL编辑器视图添加新结构元素（如规则或帮助程序操作）的代码将自动导致在“大纲”视图中进行相应的添加（最迟在保存文件时）。此外，ATL编辑器和“大纲”视图的游标始终指向相同的结构元素，如下图所示。因此，如果光标在其中一个（ATL编辑器或大纲）中移动，则另一个视图将相应地替换其自己的光标。</p>
		<p>有关在“大纲”视图中选择的转换元素的详细信息将显示在“属性”视图中。</p>
		<p>在ATL转换的范围内，Outline视图还允许在转换代码中定位新断点。通过选择上下文菜单的<i>Add breakpoint</i>选项，可以从Outline视图的选定元素实现新断点的定义。“大纲”视图中定义的断点将在“ <a href="The-ATL-Tools.html#ATL_Debug_perspective">ATL调试”透视</a>图中的“断点”视图中列出。它们通过绿点在ATL编辑器中标记。
		</p>
		<h4 id="Problems">问题</h4>
		<p>Problems视图旨在显示在当前编辑的文件中检测到的问题（通常是一些语法错误）。在当前ATL工具当前实现的范围内，该视图主要用于ATL文件的编辑。因此，它显示在编译时（在保存编辑文件时）在ATL程序中检测到的问题列表。</p>
		<p>Problems视图当前显示ATL转换范围中的两种主要问题：</p>
		<ul>
			<li>针对无效的ATL语句引发的错误问题（例如，声明两个具有相同名称的模型）;</li>
			<li>针对可能是错误源的有效ATL语句引发的警告问题（例如，声明隐藏已存在变量的变量）。</li>
		</ul>
		<p>对于每个检测到的问题，“问题”视图将显示其类型（错误或警告），简短说明消息以及问题的本地化（按行和列号）。请注意，相应的问题也直接在“编辑器”视图中进行了本地化。</p>
		<h4 id="Error_Log">错误日志</h4>
		<p>错误日志视图旨在显示和记录Eclipse常规错误。它对ATL开发人员没有特别用处，因为ATL错误显示在Console视图中。</p>
		<h4 id="Console">安慰</h4>
		<p>Console视图显示可以从ATL代码写入的消息，例如使用字符串操作<a href="The-ATL-Language.html#String_data_type_operations" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃String_data_type_operations">''println（）''</a> 。它还显示执行错误的ATL程序可能引发的错误消息。请注意，这些显示的错误消息可能会在尝试识别错误的ATL转换中的错误时提供有用的信息。
		</p>
		<h3 id="ATL_Debug_perspective">ATL Debug透视图</h3>
		<p>ATL Debug透视图专门用于调试ATL转换。它为ATL开发人员提供了一套通常的调试工具：</p>
		<ul>
			<li>断点的定位;</li>
			<li>逐步转换执行;</li>
			<li>运行转换到下一个断点;</li>
			<li>显示变量值;</li>
			<li>等等...</li>
		</ul>
		<p>本节重点介绍ATL Debug透视图的组织以及作为此透视图一部分的不同视图的角色。有关透视图提供的调试工具的详细说明，请参阅<a href="The-ATL-Tools.html#Debugging_ATL">调试ATL部分</a> 。ATL Debug透视图分为七个不同的视图：Debug，Variables，Breakpoints，Editors，Outline，Console和Tasks视图。以下是ATL Debug透视图的屏幕截图。
		</p>
		<p>
			<img border="0" src="images/ATL_Debug_perspective.png">
		</p>
		<p>在其默认配置中，ATL Debug透视图在窗口的左上方显示Debug视图。“变量”和“断点”视图共享窗口的右上角。编辑器视图显示在左中侧，而“大纲”视图位于中间右侧。最后，Console和Tasks视图共享透视图的底部。</p>
		<h4 id="Debug">调试</h4>
		<p>Debug视图提供有关当前正在调试的转换的操作堆栈状态的信息。为此，它以根元素的形式显示当前在调试模式下运行的ATL程序列表。对于其中每个程序，它都会显示正在运行的线程列表。请注意，ATL转换在单个线程中执行。在此线程的范围内，Debug视图显示被调用操作的堆栈。</p>
		<p>在上一个<a href="The-ATL-Tools.html#ATL_Debug_perspective">屏幕截图中</a> ，Debug视图提供有关Author2Person转换的单个ATL执行的信息。执行线程的调用堆栈包含三个操作。当前正在执行的操作是_applyAuthor（）。此操作已由内部_exec（）_操作调用，该操作本身已由操作main（）调用。
		</p>
		<p>Debug视图还为常见的调试操作（Resume，Terminate，Step Into，Step Over，Step return等）提供了有用的快捷方式。这些快捷方式在视图标题栏的右侧提供为按钮。它们的使用在专用于<a href="The-ATL-Tools.html#Debugging_ATL">ATL程序调试</a>的部分中进一步描述。
		</p>
		<h4 id="Variables">变量</h4>
		<p>如先前<a href="The-ATL-Tools.html#ATL_Debug_perspective">所示</a> ，变量视图分为两个不同的部分。视图的顶部显示从“调试”视图中当前选择的操作可见的变量值。此视图提供了浏览这些可见变量的参考属性的可能性。通过这种方式，可以访问在当前操作的范围内不直接可见但是由一些当前可见的模型元素指向的模型元素的值。
		</p>
		<p>Variables视图的底部部分使ATL开发人员可以在可见变量集上指定和执行请求。</p>
		<h4 id="Breakpoints">断点</h4>
		<p>“断点”视图显示当前正在执行的转换中定义的断点列表。该视图使得可以在定义的断点中选择活动断点的子集。它还提供了许多专用于断点管理的快捷方式。这些快捷方式在Breakpoints视图的标题栏右侧提供为按钮。</p>
		<h2 id="Programming_ATL">编程ATL</h2>
		<p>本节旨在通过提供的ATL IDE介绍设计的不同步骤和ATL转换的编程。执行ATL转换显然需要ATL转换文件，还需要源和目标元模型以及此转换的源模型。</p>
		<p>设计ATL转换过程的第一步是创建一个ATL项目。源和目标元模型可以从不同的源导入。因此，主要任务在于设计ATL转换本身。</p>
		<h3 id="Creating_an_ATL_project">创建一个ATL项目</h3>
		<p>设计新ATL转换的第一步是在ATL项目下定位。如果没有ATL项目，则第一步需要创建一个新的空ATL项目（ <i>New-&gt; ATL Project</i> ）。
		</p>
		<p>此操作将触发ATL Project Creator窗口的显示，其中必须输入要创建的项目的名称。在此阶段，建议为项目提供合理的名称，例如通过连接源元模型名称，字符“2”和目标元模型名称（例如Author2Person）。然后按“完成”按钮验证ATL项目创建。</p>
		<p>对于每个创建的项目，Eclipse在Navigator视图中创建一个项目文件夹。双击视图中的项目项，即可打开新生成的项目。它最初包含.project文件。此文件包含与项目相关的Eclipse元数据。</p>
		<h3 id="Content_assist">内容辅助</h3>
		<p>完成目的是规则，帮助器，从，到，执行，使用部分的基本模板。您还可以访问EMF元模型信息（来自其nsURI或相对路径）。</p>
		<h4 id="Usage">用法</h4>
		<p>要使模型元素完成，您必须在文件顶部放置一些信息：</p>
		<ul>
			<li>
				<i>' -  @nsURI</i> '：给定元模型的nsURI，如果要从EMF注册表加载元模型，</li>
			<li>
				<i>' -  @path</i> '：给定元模型的路径，如果要从ecore文件动态加载元模型。
			</li>
		</ul>
		<p>仅支持EMF元模型。您必须指定文件到工作区的相对路径。</p>
		<p>这是UML2AnyMM转换的顶部：</p>
		<pre>-- @path AnyMM=/AnyProject/AnyFolder/AnyMM.ecore
-- @nsURI UML=http://www.eclipse.org/uml2/2.1.0/UML
</pre>
		<pre>module Class2Relational;
create OUT : AnyMM from IN : UML;
</pre>
		<pre>-- ...transformation helpers and rules
</pre>
		<p>使用Ctrl +空格键触发完成，或者在某些内容辅助可用的上下文中键入空格时触发完成。</p>
		<h4 id="Since_ATL_3.1_2">自ATL 3.1起</h4>
		<p>要在完成时包含库提案，还需要其他标记信息：<br>

			<i>' -  @lib</i> '：库的路径，相对于工作空间（对于元模型路径）。
		</p>
		<h3 id="Creating_an_ATL_file">创建ATL文件</h3>
		<p>ATL IDE提供专用于创建ATL文件的特定向导。鼓励初学ATL开发人员使用该向导创建新的ATL文件。实验开发人员可能会发现向导工具过于复杂，无法创建非常简单的转换。在这种情况下，他们可能更喜欢从头开始创建他们的ATL文件。以下小节将介绍这两个过程。</p>
		<h4 id="The_ATL_File_Wizard">ATL文件向导</h4>
		<p>通过在上下文菜单中选择<i>New-&gt; ATL File</i>条目，从Navigator视图启动ATL文件向导。请注意，该命令也可以从Eclipse菜单栏的“文件”菜单中获得。此命令触发显示ATL文件向导窗口：</p>
		<p>
			<img border="0" src="images/ATL_new_file2.PNG">
		</p>
		<p>ATL文件向导可以指定要创建的模块的名称，文件将包含的ATL单元的类型（ATL模块，查询或库），源和目标模型的名称以及元模型变量以及ATL程序运行所需的库的名称。从这些数据中，向导生成ATL文件，其<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language＃Header_section">头部分</a>对应于提供的信息。
		</p>
		<p>您可以选择设置元模型URI或路径，以便直接将内容辅助激活到生成的文件中。</p>
		<p>“生成配置”复选框生成启动配置，您只需设置模型路径（以及缺少元模型路径）。</p>
		<h4 id="Creating_an_ATL_file_from_scratch">从头开始创建ATL文件</h4>
		<p>对于ATL开发人员来说，可以自己从头开始编辑他们的ATL文件。为此，第一步是创建一个空的通用文件。要创建的文件的命名应遵循上一节中提出的约定。此外，此处必须将文件与<i>.atl</i>扩展名明确关联。
		</p>
		<p>创建ATL文件后，开发人员必须手动编辑ATL文件的<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language＃Header_section">标题部分</a> 。请注意，从头开始编辑ATL标头时，仍然必须遵守对声明的模型和元模型变量命名的约束。
		</p>
		<h3 id="Compiling_an_ATL_file">编译ATL文件</h3>
		<p>ATL文件的编译对应于其关联的ASM文件的更新。只有在考虑的ATL程序在语法上正确时，才能执行此编译。在ATL IDE的范围内，编译策略基于默认的Eclipse编译策略：当编辑的ATL文件保存<b>到ATL项目</b> （或任何配置了ATL性质的项目）时，编译将在后台自动执行。
		</p>
		<h3 id="Setting_up_an_ATL_run_launch_configuration">设置ATL运行启动配置</h3>
		<p>首先执行ATL转换需要设置转换启动配置。ATL启动配置旨在恢复执行ATL转换所需的所有信息。此信息包括转换中涉及的文件的路径（例如，ATL文件，还包括模型，元模型和库文件）。</p>
		<h4 id="The_ATL_Configuration_tab">ATL配置选项卡</h4>
		<p>ATL配置选项卡允许指定启动配置的路径和URI。字段是从指定的ATL模块预先计算的，但可以使用“修改”部分添加新的字段。</p>
		<p>
			<img border="0" src="images/ATL_launch1.PNG">
		</p>
		<h4 id="The_Advanced_tab">“高级”选项卡</h4>
		<p>“高级”选项卡允许配置：</p>
		<ul>
			<li>模块叠加，通过使用添加/删除按钮添加叠加模块</li>
			<li>转换启动器（ATL虚拟机）</li>
			<li>启动器参数。为每个启动器计算此部分，因为它们不提供相同的选项</li>
		</ul>
		<p>
			<img border="0" src="images/ATL_launch2.PNG">
		</p>
		<h4 id="The_Common_tab">Common选项卡</h4>
		<p>Common选项卡为ATL开发人员提供配置设计转换的执行环境。Common选项卡分为四个块： <i>另存为</i> ， <i>在收藏夹菜单中显示</i> ， <i>控制台编码</i>和<i>标准输入和输出</i> 。以下是运行ATL启动配置向导的Common选项卡的屏幕截图。
		</p>
		<p>
			<img border="0" src="images/ATL_launch3.PNG">
		</p>
		<ul>
			<li>“ <i>另存为”</i>部分允许指定是否必须将启动配置数据另存为本地文件或共享文件。作为本地文件，启动配置仅在启动配置窗口中可用。启动配置也可以保存到文件中以便共享。选择此选项时，开发人员必须指定启动配置文件的路径（该文件必须保存在当前项目中）。保存为共享文件时，启动的配置文件将显示在指定位置。此文件是XML文件，具有.launch文件扩展名的已考虑转换的名称。因此，将启动配置保存在当前示例的范围内将触发创建文件<i>Author2Person.launch</i> 。
			</li>
		</ul>
		<ul>
			<li>“ <i>收藏夹”</i>菜单部分中的“ <i>显示”</i>使ATL开发人员可以通过选择是否希望设计的启动配置的快捷方式显示在“运行”和/或“调试”菜单中来自定义透视图。
			</li>
		</ul>
		<ul>
			<li><i>控制台编码</i>部分允许选择<i>控制台</i>的编码类型，转换将用于标准输入和输出。
			</li>
		</ul>
		<ul>
			<li>下一节将介绍这些标准输入和输出。它为开发人员提供了为ATL程序选择输入和输出设施的可能性。在此范围内，可以分配控制台（默认选项）和/或文件。开发人员还可以选择分配控制台和文件，或者相反，不为转换提供标准输入/输出设施。请注意，在将文件指定为标准输出时，开发人员可以选择将连续转换执行的结果附加到输出文件。</li>
		</ul>
		<ul>
			<li>“ <i>公共”</i>选项卡中定义的最后一个选项可以选择是否必须在后台执行ATL程序（默认选项）。
			</li>
		</ul>
		<h3 id="Module_superimposition">模块叠加</h3>
		<h4 id="Description">描述</h4>
		<p>虽然ATL转换模块和查询通常由它们自己运行，即一次一个转换模块或查询，但也可以将多个转换模块叠加在彼此之上。最终结果是一个转换模块，它包含所有转换规则和所有帮助程序的并集，转换模块可以从下面的转换模块覆盖规则和帮助程序。下面是一个典型的叠加用例示例：UML2Copy的转换规则<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Copy.atl?view=markup">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Copy.atl?view=markup</a> module在必要时由UML2Profiles <a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Profiles.atl?view=markup">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Profiles.atl?view=markup</a>模块重复使用和覆盖。
		</p>
		<p>
			<img border="0" src="images/ATL_Superimposition-example.png">
		</p>
		<p>UML2Copy转换模块包含它必须复制的每个元类实例的转换规则。这相当于整个UML2元模型的约200条规则<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/metamodels/UML.ecore?view=markup">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/metamodels/UML.ecore?view=markup</a> 。</p>
		<p>任何细化转换基本上都需要复制所有元类实例，除了少数精炼的元类实例。UML2Profiles转换模块将配置文件应用于“uml :: Model”实例，前提是它尚未应用。所有其他元素都应该被复制。</p>
		<p>为此，UML2Profiles模块叠加在UML2Copy模块上。它会覆盖“模型”规则，该规则通过检查我们要应用的配置文件是否已应用的版本来复制每个“uml :: Model”实例。它还引入了一个新规则“ModelProfile”，它检查我们要应用的配置文件是否尚未应用，然后应用配置文件。生成的转换包含上图中尚未完成的所有规则。</p>
		<p>请注意，叠加是一个加载时间结构：没有真正的转换模块表示将多个模块叠加在一起的结果。相反，几个模块简单地加载在彼此之上，覆盖现有规则并添加新规则。</p>
		<h4 id="Usage_2">用法</h4>
		<p>ATL Superimposition在Eclipse“Run ...”对话框中配置，确切地说是在Advanced选项卡中。您还可以使用AM3 Ant脚本中的Superimposition。可以在<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-instantmessenger-model/outmodels/common/build.xml?rev=5633&amp;view=markup">此处</a>找到示例Ant脚本（请参阅“profiles”宏）。
		</p>
		<p>另请参阅<a href="http://wiki.eclipse.org/ATL_FAQ#What.27s_this_ATL_feature_called_.22superimposition.22.3F" title="ATL FAQ#What.27s_this_ATL_feature_called_.22superimposition.22.3F">关于叠加</a>的<a href="http://wiki.eclipse.org/ATL_FAQ#What.27s_this_ATL_feature_called_.22superimposition.22.3F" title="ATL FAQ＃What.27s_this_ATL_feature_called_.22superimposition.22.3F">ATL FAQ条目</a> 。
		</p>
		<p>注意：在“高级”选项卡中添加叠加模块时，它们会覆盖“ATL主配置”选项卡中指定的“主”模块。</p>
		<h3 id="Running_an_ATL_launch_configuration">运行ATL启动配置</h3>
		<p>一旦正确完成了转换的启动配置，就可以根据需要多次运行，而无需对配置进行任何更改。为了运行设计的ATL转换，开发人员只需返回配置<i>运行</i>窗口，在ATL Transformation文件夹（左栏）中选择创建的转换，然后单击Run按钮。运行现有ATL启动配置的另一个选项是为此配置定义快捷方式。这可以通过在“收藏夹”菜单部分的“显示”中选择“运行”选项，从ATL运行启动配置的“常用”选项卡中实现。
		</p>
		<h2 id="ATL_ant_tasks">ATL蚂蚁任务</h2>
		<p>本节描述了ATL的<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/?root=Modeling_Project">org.eclipse.m2m.atl.core.ant</a>插件提供的<a href="http://en.wikipedia.org/wiki/Apache_Ant">ant</a>任务。有关标准ant任务的文档可以在<a href="http://ant.apache.org/manual/">ant手册中</a>找到。
		</p>
		<p><a href="http://ant-contrib.sourceforge.net/">ant-contrib</a>提供了其他任务，并在其<a href="http://ant-contrib.sourceforge.net/ant-contrib/manual/tasks/index.html">手册中进行了说明</a> 。使用ant-contrib需要<a href="http://ant-contrib.sourceforge.net/ant-contrib/manual/#install">安装它</a> 。
		</p>
		<p>ATL ant任务对以下内容很有用：</p>
		<ul>
			<li>链转换</li>
			<li>将ATL集成到现有的工具套件中</li>
			<li>访问精确的转换参数（喷射器，提取器，模型工厂）</li>
		</ul>
		<h3 id="Task_atl.loadModel">任务atl.loadModel</h3>
		<p>此任务（在<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/LoadModelTask.java?root=Modeling_Project&amp;view=markup">LoadModelTask</a>类中<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/LoadModelTask.java?root=Modeling_Project&amp;view=markup">实现</a> ）用于加载带有注入器的模型。该模型可以是终端模型或元模型。MOF特殊名称在上下文中是元变量模型。
		</p>
		<h4 id="Parameters_specified_as_attributes">参数指定为属性</h4>
		<p>atl.loadModel可以具有以下参数：</p>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
				<td>默认值</td>
			</tr>
			<tr>
				<td>名称</td>
				<td>Ant项目中模型的名称。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>元模型</td>
				<td>元模型的名称。此名称必须等于atl.loadModel加载的先前模型名称或metametamodel特殊名称％....如果此名称等于MOF，则采用元变量模型。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>要加载的模型文件的路径。它可以相对于当前目录（包含Ant文件的目录）。如果是绝对的，则“/”根目录是当前工作空间。</td>
				<td rowspan="2">是（只有路径和nsUri之一）</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>nsURI</td>
				<td>要从EMF包注册表加载的元模型的名称空间URI。</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>modelHandler</td>
				<td>用于加载模型的模型处理程序名称（EMF，UML2或任何其他已安装的模型）。此参数仅由Regular-VM使用</td>
				<td>没有</td>
				<td>EMF</td>
			</tr>
			<tr>
				<td>厂</td>
				<td>用于加载模型的模型工厂名称。此参数仅由EMF特定的VM使用</td>
				<td>没有</td>
				<td>EMF</td>
			</tr>
		</table>
		<h4 id="Parameters_specified_as_nested_elements">指定为嵌套元素的参数</h4>
		<p>有时，能够通过扩展<a href="http://wiki.eclipse.org/ATL/Developer_Guide#Core">ATL Core</a>的注入器加载模型很有意思。您需要使用在定义时指定的进样器名称。此示例显示如何将ATL文件作为ATL模型加载：</p>
		<pre>&lt;!-- load ATL metamodel -->
&lt;atl.loadModel modelHandler="EMF" name="ATL" metamodel="MOF" path="metamodels/ATL.ecore" />
</pre>
		<pre>&lt;atl.loadModel name="myATL" metamodel="ATL" path="inputs/MySample.atl">
 &lt;injector name="ATL" />
&lt;/atl.loadModel>
</pre>
		<h4 id="Examples_4">例子</h4>
		<p>使用EMF加载元模型（和Ecore作为元模型）：</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="News" metamodel="MOF" path="metamodel/News.ecore" />
</pre>
		<p>相当于</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="News" metamodel="%EMF" path="metamodels/News.ecore" />
</pre>
		<p>加载符合先前加载的元模型的终端模型：</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="SampleNews" metamodel="News" path="models/MyInput-News.xmi" />
</pre>
		<h3 id="Task_atl.saveModel">任务atl.saveModel</h3>
		<p>此任务（在<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/SaveModelTask.java?root=Modeling_Project&amp;view=markup">SaveModelTask</a>类中<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/SaveModelTask.java?root=Modeling_Project&amp;view=markup">实现</a> ）用于保存模型，可选择使用提取器。可以保存任何模型：终端模型，元模型或元模型。
		</p>
		<p>atl.saveModel可以包含以下参数：</p>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
				<td>默认值</td>
			</tr>
			<tr>
				<td>模型</td>
				<td>Ant项目中模型的名称。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>要保存的模型文件的路径。它可以相对于当前目录（包含Ant文件的目录）。如果是绝对的，则“/”根目录是当前工作空间。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>派生</td>
				<td>将保存的文件设置为“派生”</td>
				<td>没有</td>
				<td>真正</td>
			</tr>
			<tr>
				<td>厂</td>
				<td>用于保存模型的模型工厂名称。此参数仅由EMF特定的VM使用</td>
				<td>没有</td>
				<td>EMF</td>
			</tr>
		</table>
		<p>保存以前加载的新闻元模型：</p>
		<pre>&lt;atl.saveModel model="News" path="outputs/NewsMM.ecore" />
</pre>
		<p>您可以看到model属性与先前atl.loadModel任务的name属性相同。加载后，模型将通过此属性名称进行标识。因此，您应该避免为两个不同的模型指定相同的名称。每次发生时，您的先前模型都会被覆盖。</p>
		<p>有时，使用提取器保存模型很有意思。例如，如果你有一个符合ATL的模型（即ATL源代码的模型），使用ATL提取器将其保存为.atl文件会很有趣：</p>
		<pre>&lt;atl.saveModel model="myATL" path="outputs/SavingMySample.atl">
 &lt;extractor name="ATL"/>
&lt;/atl.saveModel>
</pre>
		<h3 id="Task_atl.launch">任务atl.launch</h3>
		<p>此任务的目的（在类<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/ATLModelTransformationTask.java?root=Modeling_Project&amp;view=markup">ATLModelTransformationTask中</a>实现）是执行ATL转换。转换使用的模型由其名称引用，使用<a href="The-ATL-Tools.html#Task_atl.loadModel">atl.loadModel</a>任务（name属性）定义。
		</p>
		<h4 id="Parameters_specified_as_attributes_2">参数指定为属性</h4>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
				<td>默认值</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>要编译的ATL转换的路径（.asm）</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>精制</td>
				<td>布尔值，用于确定转换是否为精炼转换</td>
				<td>没有</td>
				<td>假</td>
			</tr>
		</table>
		<p>在此任务中，您必须绑定ATL模块标头中的每个模型。有三种嵌套参数：</p>
		<ul>
			<li>
				用于源模型的<b>inmodel</b></li>
			<li>
				目标模型的<b>outmodel</b></li>
			<li>
				源/目标模型的<b>inoutmodel</b> （精炼模式）</li>
			<li>
				<b>库</b>库助手</li>
		</ul>
		<p>例如，如果您有此模块标题：</p>
		<pre>module Families2Persons;
create OUT : Persons from IN : Families;
uses myLib;
</pre>
		<p>您必须创建一个inModel参数（对于IN），一个outModel（对于OUT）和一个库（对于myLib）。例如：</p>
		<pre>&lt;atl.launch path="ATLFiles/MyTransformation.asm">
 &lt;inmodel name="IN" model="..."/>			
 &lt;outmodel name="OUT" model="..." metamodel="Persons"/>
 &lt;library name="strings" path="lib/mylib.atl" />
&lt;/atl.launch>
</pre>
		<p>每个参数的名称必须与模块头中的名称完全相同（区分大小写）。对于inmodel参数，model属性指的是先前加载的模型的名称，例如atl.loadModel。outmodel的属性模型不会引用已加载的模型，因为它尚未创建。后面应该使用此属性的值作为atl.saveModel任务的标识符。</p>
		<p>每个嵌套参数的每个属性在此汇总：</p>
		<h4 id="Parameters_specified_as_nested_elements_2">指定为嵌套元素的参数</h4>
		<h5 id="inmodel">inmodel</h5>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
			</tr>
			<tr>
				<td>名称</td>
				<td>ATL模块头中的模型名称。</td>
				<td>是</td>
			</tr>
			<tr>
				<td>模型</td>
				<td>先前加载的模型的名称。</td>
				<td>是</td>
			</tr>
		</table>
		<h5 id="outmodel">outmodel</h5>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
				<td>默认值</td>
			</tr>
			<tr>
				<td>名称</td>
				<td>ATL模块头中的模型名称。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>模型</td>
				<td>先前加载的模型的名称。</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>元模型</td>
				<td>加载时指定的当前模型的元模型的名称</td>
				<td>是</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>输出文件的名称（主要用于文件扩展名，EMF使用它来确定正确的工厂）。</td>
				<td>没有</td>
				<td>没有</td>
			</tr>
			<tr>
				<td>modelHandler</td>
				<td>用于创建模型的模型处理程序名称（EMF，UML2或任何其他已安装的模型）。此参数仅由Regular-VM使用</td>
				<td>没有</td>
				<td>EMF</td>
			</tr>
			<tr>
				<td>厂</td>
				<td>用于创建模型的模型工厂名称。此参数仅由EMF特定的VM使用</td>
				<td>没有</td>
				<td>EMF</td>
			</tr>
		</table>
		<h5 id="superimpose">叠加</h5>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>ATL模块的路径叠加。</td>
				<td>是</td>
			</tr>
		</table>
		<h5 id="library">图书馆</h5>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
			</tr>
			<tr>
				<td>名称</td>
				<td>ATL模块头中的库名称。</td>
				<td>是</td>
			</tr>
			<tr>
				<td>路径</td>
				<td>ATL库文件的路径。</td>
				<td>是</td>
			</tr>
		</table>
		<h5 id="option">选项</h5>
		<table border="1">
			<tr>
				<th>属性</th>
				<td>描述</td>
				<td>需要</td>
			</tr>
			<tr>
				<td>名称</td>
				<td>选项名称。</td>
				<td>是</td>
			</tr>
			<tr>
				<td>值</td>
				<td>在name属性中指定名称的选项的值。</td>
				<td>是</td>
			</tr>
		</table>
		<p>选项传递给ATL虚拟机。可用选项定义如下：</p>
		<ul>
			<li>
				<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ui.vm/plugin.xml?root=Modeling_Project&amp;view=markup">这里</a>是Regular-VM</li>
			<li>
				<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.engine.emfvm/plugin.xml?root=Modeling_Project&amp;view=markup">这里</a>是EMF特定的VM</li>
		</ul>
		<p>（请参阅org.eclipse.m2m.atl.core.launcher扩展中的选项）</p>
		<h4 id="Launcher_configuration">启动器配置</h4>
		<p>要选择要使用的启动程序（即特定于EMF的VM或常规VM），必须将其指定为ant项目中的属性。默认选择EMF特定的VM。例如，要使用常规VM：</p>
		<pre>&lt;?xml version="1.0"?>
&lt;project name="test.types" default="run" basedir=".">
    &lt;property name="atl.launcher" value="Regular VM (with debugger)"/>
    ...
&lt;/project>
</pre>
		<h4 id="Making_ATL_transformations_chains_without_intermediate_serialization">使ATL转换链没有中间序列化</h4>
		<p>假设您有两个转换A2B和B2C链。A2B将符合A的模型转换为符合B的模型.B2C将符合B的模型转换为符合C的模型。我们只想序列化符合C的模型，但没有符合B的中间模型。解决方案是它可以直接作为B2C转换的输入传递，如下所示：</p>
		<p>加载元模型：</p>
		<pre>&lt;atl.loadModel metamodel="%EMF" name="A" path="..."/> 
&lt;atl.loadModel metamodel="%EMF" name="B" path="..."/>
&lt;atl.loadModel metamodel="%EMF" name="C" path="..."/>
</pre>
		<p>加载源模型：</p>
		<pre>&lt;atl.loadModel metamodel="A" name="myModel-A" path="..."/> &amp;lt;!-- "-A" is here not to forget that myModel is conforming to metamodel "A", but you can give any name -->
</pre>
		<p>第一次转型：</p>
		<pre>&lt;atl.launch path="...">
 &amp;lt;!--
 the header of the executed transformation is:
 module myModule1;
 create TargetM : TargetMM from SourceM : SourceMM;
 -->
 &lt;inmodel name="SourceM" model="myModel-A"/>			
 &lt;outmodel name="'''TargetM'''" model="'''myModel-B'''" metamodel="B"/>
&lt;/atl.launch >
</pre>
		<p>第二次转型：</p>
		<pre>&lt;atl.launch path="...">
 &amp;lt;!--
 the header of the executed transformation is:
 module myModule2;
 create TargetM : TargetMM from SourceM : SourceMM;
 -->
 &lt;inmodel name="'''SourceM'''" model="'''myModel-B'''"/>			
 &lt;outmodel name="TargetM" model="myModel-C" metamodel="C"/>
&lt;/atl.launch >
</pre>
		<p>请注意，myModel-B可用于第二次转换，就好像它已被atl.loadModel调用加载一样。</p>
		<p>仅序列化第二个转换的输出（模型myModel-C）</p>
		<pre>&lt;atl.saveModel model="myModel-C" path="..." />
</pre>
		<h4 id="Examples_5">例子</h4>
		<p>炼油改造（完全可用<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/examples/org.eclipse.m2m.atl.examples.public2private/?root=Modeling_Project">在这里</a> ），具体的EMF-VM推出：</p>
		<pre>&lt;?xml version="1.0"?>
&lt;project name="Public2Private" default="run" basedir=".">
	&lt;property name="samplePath" value="../model/sample.uml" />
</pre>
		<pre>	&lt;target name="run">
		&lt;atl.loadModel name="UML" metamodel="MOF" nsUri="http://www.eclipse.org/uml2/2.1.0/UML" />
		&lt;atl.loadModel name="sample" metamodel="UML" path="${samplePath}" />
</pre>
		<pre>		&lt;atl.launch path="../transformation/public2private.asm" refining="true">
			&lt;inoutmodel model="sample" name="IN" />
		&lt;/atl.launch>
</pre>
		<pre>		&lt;atl.saveModel model="sample" path="${samplePath}" />
	&lt;/target>
&lt;/project>
</pre>
		<h3 id="Mapping_with_AM3_ant_tasks">使用AM3 ant任务进行映射</h3>
		<p>Ant任务已添加到ATL，以提供与<a href="http://wiki.eclipse.org/AM3_Ant_Tasks">AM3 ant任务</a>相同的支持，适用于ATL3.0.x API。以下是AM3和ATL任务之间的映射和更改列表：</p>
		<ul>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.loadModel">am3.loadModel</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.loadModel">atl.loadModel</a>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.saveModel">am3.saveModel</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.saveModel">atl.saveModel</a>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.atl">am3.atl</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.launch">atl.launch</a>
				<ul>
					<li>allowInterModelReferences参数不再存在，必须作为选项传递：</li>
				</ul>
			</li>
		</ul>
		<pre>&lt;atl.launch path="test.asm">
    &lt;option name="allowInterModelReferences" value="true"/>
    &lt;inmodel model="sample" name="IN" />
    ...
&lt;/atl.launch>
</pre>
		<ul>
			<li>
				<ul>
					<li>在atl.launch任务中，您不需要添加元模型作为输入模型（将被忽略）</li>
				</ul>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.query">am3.query</a> - &gt;不可用。您可以使用atl.launch任务运行查询</li>
		</ul>
		<p>注意：AM3注入器/提取器（如XML，KM3）未嵌入到ATL中</p>
		<h3 id="Launching_an_Ant_file_with_ATL_tasks_in_an_Eclipse_workbench">在Eclipse工作台中启动带有ATL任务的Ant文件</h3>
		<p>定义Ant文件后，右键单击该文件：</p>
		<ul>
			<li>选择Run As&gt; Ant Build |</li>
		</ul>
		<ul>
			<li>转到JRE选项卡</li>
		</ul>
		<ul>
			<li>选择“在与工作区相同的JRE中运行”</li>
		</ul>
		<p>
			<img border="0" src="images/AM3AntTasks_JreTab.jpg">
		</p>
		<h2 id="ATL_Plugins">ATL插件</h2>
		<p>ATL插件向导有助于实现ATL程序化启动。该实用程序首先要求转换参数（元模型，库路径，转换模块路径）：</p>
		<p>
			<img border="0" src="images/ATL_plugin_wizard.png">
		</p>
		<p>然后将生成一个新的插件，嵌入：</p>
		<ul>
			<li>转换模块和库</li>
			<li>包含URI，atl文件路径的propery文件</li>
			<li>允许以编程方式启动ATL转换的Java类</li>
		</ul>
		<p>
			<img border="0" src="images/ATL_plugin_wizard_result.png">
		</p>
		<p>最后，您将能够使用生成的main启动转换，或将启动器类集成到现有应用程序中。要将转换用作独立应用程序，您可以使用Eclipse Java导出选项：</p>
		<p>
			<img border="0" src="images/ATL_plugin_wizard_result_export.png">
		</p>
		<p>这将产生一个包含所有必需的ATL，Eclipse和EMF库的.jar。</p>
		<h2 id="Debugging_ATL">调试ATL</h2>
		<p>本节旨在介绍ATL IDE提供的调试工具。因此，ATL开发环境为ATL开发人员提供了专用的ATL Debug透视图。此透视图为开发人员提供了最常见的调试工具，包括逐步转换执行，运行转换到下一个断点，显示变量内容等。此外，ATL IDE使开发人员可以随时了解当前正在执行的ATL指令通过突出显示ATL编辑器中的相应代码。</p>
		<p>ATL调试操作可从ATL Debug透视图获得。对于Java程序，调试ATL转换意味着在调试模式下执行此转换。这假设开发人员为转换创建ATL调试启动配置。调试执行模式及其关联的调试操作由执行此调试启动配置触发。</p>
		<h3 id="Managing_breakpoints">管理断点</h3>
		<p>ATL调试模式可以在任何类型的ATL单元中定义断点，包括从其他ATL单元导入的库。必须通过Outline视图定位这些断点，该视图可从ATL和ATL Debug透视图中获得。请注意，“大纲”视图仅显示使用ATL编辑器编辑的ATL单元的结构。</p>
		<h4 id="Setting.2FRemoving_breakpoints">设置/删除断点</h4>
		<p>在ATL IDE的范围内，ATL程序中断点的设置只能通过Outline视图来实现。请记住，Outline视图显示当前使用ATL编辑器编辑的ATL文件的结构（事实上，它显示与编辑的ATL文件对应的ATL模型）。通过在所选元素的上下文菜单中选择“ <i>添加断点”</i>条目，可以在ATL结构元素的级别定义新断点。这在下一个屏幕截图中说明，其中断点位于NavigationOrAttributeCallExp元素的级别。请注意，在“大纲”视图中选择的元素对应的代码同时在ATL编辑器视图中突出显示。
		</p>
		<p>Outline视图当前允许开发人员将断点与ATL程序的任何类型的结构元素相关联。但是，定位新断点仅对与执行指令关联的结构元素有意义。构成断点相关目标的结构元素大致对应于ATL引擎评估的OCL表达式。这意味着诸如MatchedRule（或CalledRule）元素，Helper元素或InPattern和OutPattern元素之类的转换元素不应与断点相关联。请注意，Outline视图允许为这些元素定义断点，但在程序调试期间将忽略它们。</p>
		<p>定义的断点显示在ATL编辑器视图的左列中。下面的屏幕截图说明了这一点，其中先前定位到NavigationOrAttributeCallExp元素上的断点由ATL编辑器左栏中的蓝色圆圈进行了本地化。虽然ATL编辑器显示已定义断点的位置，但它无法处理它们。这必须通过ATL Debug透视图的Breakpoints视图来实现。</p>
		<p>只能从ATL Debug透视图的Breakpoints视图中删除定义的断点。该视图使得可以在定义的断点之间选择多个断点。可以使用“删除选择断点”按钮删除这些断点。</p>
		<p>请注意，从断点列表中选择断点时（在“断点”视图中），上下文菜单中也可以使用断点删除操作。</p>
		<h4 id="Activating.2FDeactivating_breakpoints">激活/取消激活断点</h4>
		<p>Breakpoints视图还提供激活和停用已定义断点的可能性。在调试ATL转换时，不会考虑停用的断点。此工具可以忽略某些已定义的断点而无需删除它们。</p>
		<p>断点激活/取消激活仅可从与断点列表元素关联的上下文菜单中获得。请注意，作为断点设置和删除，可以在调试ATL程序之前或期间执行激活/取消激活。</p>
		<h4 id="Limitations_2">限制</h4>
		<p>除了Outline视图允许在不相关的位置定义断点之外，当编译ATL文件时，ATL开发环境目前在更新已定义断点的位置时提供的支持很少（默认的ATL编译策略是在保存时编译文件） ）。因此，一旦编译了定义了断点的ATL文件，定义的断点就会指向所考虑的程序文件中的不相关位置。在调试ATL单元时，这可能由内部错误实现。</p>
		<h3 id="Creating_an_ATL_Debug_launch_configuration">创建ATL调试启动配置</h3>
		<p>对于运行模式，首先在调试模式下执行ATL转换需要设置ATL Debug启动配置。通过在Navigator视图中选择ATL文件并选择其上下文菜单的<i>“Debug As-&gt; Debug ...”</i>条目，可以从Navigator视图创建新的ATL调试启动配置。请注意，通过选择Debug菜单的<i>Debug ...</i>条目，也可以从Eclipse菜单栏启动此调试启动配置向导。
		</p>
		<p>ATL程序共享运行和调试模式的通用启动配置。这有两个后果。首先，这意味着一旦配置了ATL单元的运行启动配置，就不需要创建专用于调试模式的新启动配置。第二个结果是两种启动配置必须以相同的方式<a href="The-ATL-Tools.html#Setting_up_an_ATL_run_launch_configuration">配置</a> （反汇编模式选项除外，见下文）。
		</p>
		<p>启动配置的“ATL配置”选项卡中提供的“反汇编”模式选项在运行模式下无效。但是，在调试模式下，此选项使开发人员可以从其字节码调试ATL单元（例如，与ATL程序关联的ASM文件包含）。此调试模式主要是为ATL语言的开发人员提供的，不在本手册的范围之内。</p>
		<h3 id="Running_an_ATL_Debug_launch_configuration">运行ATL Debug启动配置</h3>
		<p>执行ATL调试启动配置遵循与ATL运行启动配置相同的方案：从配置调试窗口，开发人员只需在ATL Transformation文件夹（左栏）中选择转换，然后单击Debug按钮。</p>
		<p>至于运行模式，还有另一个选项，它包括为此配置定义调试快捷方式。这可以通过在“收藏夹菜单”部分的“显示”中选择“调试”选项，从ATL启动配置的“ <a href="The-ATL-Tools.html#The_Common_tab">公共”选项卡</a>中实现。
		</p>
		<h3 id="Debugging_actions">调试操作</h3>
		<p>在调试程序时，开发人员习惯于提供一组标准的调试操作。在ATL IDE的范围内，ATL Debug透视图的Debug视图提供了主要调试操作的快捷方式。在调试转换时，也可以从Eclipse菜单栏的“运行”菜单以及当前线程或其内容的上下文菜单中访问调试操作：</p>
		<p>
			<img border="0" src="images/ATL_debug_actions.png">
		</p>
		<ul>
			<li><i>Resume</i>操作会触发调试转换的执行，直到下一个断点。不执行断点的程序将执行到终止。
			</li>
		</ul>
		<ul>
			<li><i>Step Over</i>操作是一步一步的操作。激活此操作会触发当前指令的执行。请注意，如果此指令是操作调用（Outline视图中OperationCallExp类型的元素），则调试器将跳过调用操作的执行。以相同的方式，如果当前指令是当前执行的操作的最后一个，则调试器将恢复到调用操作。
			</li>
		</ul>
		<ul>
			<li><i>Step Into</i>行动是另一个循序渐进的行动。触发到表达式调用指令，它跳转到被调用操作的主体（例如第一条指令）。请注意，当调用非操作调用的指令时，此Step Into操作的行为方式与<i>Step Over</i>操作相同。
			</li>
		</ul>
		<ul>
			<li>最后一步一步的操作是<i>Step Return</i>操作。此操作将恢复执行当前操作被调用的点的转换执行。从助手，属性或被调用规则触发，步骤返回操作将恢复为调用用户代码。从源模式元素触发，操作将恢复到生成的主操作<i>__exec __（）</i> ，该操作将依次调用下一个<i>__match</i>操作或第一个<i>__exec</i>操作。最后，从目标模式元素触发，操作将恢复到生成的主操作<i>__exec __（）</i> ，该操作将依次调用下一个<i>__exec</i>操作或运行到程序终止。请注意，从细胞操作的最后一条指令调用，此操作的行为方式与之前的操作相同。
			</li>
		</ul>
		<ul>
			<li>“ <i>终止”和“删除”</i>操作终止正在调试的转换，并将其从“调试”视图中删除。
			</li>
		</ul>
		<ul>
			<li>“ <i>删除所有已终止的启动”</i>操作将从“调试”视图中删除所有已终止的转换。如果视图不包含已终止的转换，则此操作不可用。
			</li>
		</ul>
		<p>最后，虽然在调试透视图中可用，但<i>Disconnect</i>和<i>Terminate</i>操作当前不起作用。
		</p>
		<h3 id="Displaying_variables_values">显示变量值</h3>
		<p>在ATL Debug透视图的范围内，Variables视图旨在为开发人员提供在执行转换期间观察ATL变量内容的便捷方法。为此，“变量”视图显示当前执行上下文中可见的所有变量。请注意，无论考虑执行上下文，都定义变量self。</p>
		<p>在帮助器的上下文中，可见变量对应于辅助参数，通过let指令引入的局部变量以及在集合迭代表达式范围内使用的迭代器变量。这里的变量self对应于声明上下文的元素。除参数外，可见变量集在ATL属性的范围内类似。</p>
		<p>在转换执行的<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language＃Default_mode_execution_semantics">匹配阶段</a> ，匹配规则的上下文中可见的变量包括源模式元素变量以及可以在源模式元素表达式的范围内声明的变量和迭代器。在初始化阶段，这组可见变量将更改为规则使用部分中声明的规则局部变量，源和目标模式元素变量以及在已执行表达式中声明的变量/迭代器。
		</p>
		<p>
			<img border="0" src="images/ATL_navigate_debug_variables.png">
		</p>
		<p>在此示例中，已在规则Author的目标模式元素的第一个绑定上设置断点（在“编辑器”视图的左列中可见）。Debug视图指示当前正在执行的操作（例如，操作<i>__applyAuthor（）</i> ）对应于规则Author的初始化阶段（ <i>__ apply</i>前缀与规则初始化阶段相关联）。回到编辑器视图，可以识别以绿色突出显示的当前指令：这里对应于对规则目标模式元素<i>的姓氏</i>绑定中的变量<i>a''</i>的评估。
		</p>
		<p>“ <i>变量”</i>视图可以导航在此上下文中可见的变量的内容。变量a对应于当前由规则匹配的源模型元素。变量<i>p''对应于当前初始化的目标模式模型元素。请注意，在此阶段，由于未完成姓氏绑定的执行，因此该变量的唯一初始化属性是“name”</i> 。变量<i>self</i>在这里指向ATL模块。最后，在转换初始化阶段出现的变量链接对应于ATL引擎内部变量，开发人员可以忽略它。虽然在所考虑的示例中未示出，但是变量视图使得能够导航集合变量的内容。它还可以使用这些元素定义的引用来导航源，并在某些时候导航目标模型元素。
		</p>
		<p></p><div style="display:none">=另见=</div>
<div style="display:none">* <a href="ATL User Guide.html#Introduction" title="ATL / ___ ATLPAGENAME ____-_简介">简介</a>
</div>
<div style="display:none">* <a href="Installation.html#Installation" title="ATL / ___ ATLPAGENAME ____-_安装">安装</a>
</div>
<div style="display:none">* <a href="Overview-of-the-Atlas-Transformation-Language.html#Overview_of_the_Atlas_Transformation_Language" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language">Atlas转换语言概述</a>
</div>
<div style="display:none">* <a href="The-ATL-Language.html#The_ATL_Language" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language">ATL语言</a>
</div>
		<hr>
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="The-ATL-Language.html" title="ATL语言">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="ATL User Guide.html" title="ATL用户指南">
						<img alt="ATL用户指南" border="0" src="images/images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">ATL语言</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table>
	</body>
</html>