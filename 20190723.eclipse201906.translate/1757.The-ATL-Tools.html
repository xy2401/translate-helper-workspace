<html ><head></head><body ><?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; ? gtc:encodedoriginal="PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0ndXRmLTgnID8-"><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" gtc:encodedoriginal="PCFET0NUWVBFIGh0bWwgUFVCTElDICItLy9XM0MvL0RURCBYSFRNTCAxLjAgVHJhbnNpdGlvbmFsLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXRyYW5zaXRpb25hbC5kdGQiPg==">
<html xmlns="http://www.w3.org/1999/xhtml" gtc:encodedoriginal="PGh0bWwgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPg==">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" gtc:encodedoriginal="PG1ldGEgaHR0cC1lcXVpdj0iQ29udGVudC1UeXBlIiBjb250ZW50PSJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgiLz4="/>
		<title>ATL User Guide - The ATL Tools</title>
		<link type="text/css" rel="stylesheet" href="book.css" gtc:encodedoriginal="PGxpbmsgdHlwZT0idGV4dC9jc3MiIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iYm9vay5jc3MiLz4="/>
	</head>
	<body>
		<table class="navigation" style="width: 100%;" border="0" summary="navigation" gtc:encodedoriginal="PHRhYmxlIGNsYXNzPSJuYXZpZ2F0aW9uIiBzdHlsZT0id2lkdGg6IDEwMCU7IiBib3JkZXI9IjAiIHN1bW1hcnk9Im5hdmlnYXRpb24iPg==">
			<tr>
				<th style="width: 100%" align="center" colspan="3" gtc:encodedoriginal="PHRoIHN0eWxlPSJ3aWR0aDogMTAwJSIgYWxpZ249ImNlbnRlciIgY29sc3Bhbj0iMyI-">The ATL Tools</th>
			</tr>
			<tr>
				<td style="width: 20%" align="left" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogMjAlIiBhbGlnbj0ibGVmdCI-">
					<a href="The-ATL-Language.html" title="The ATL Language" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1MYW5ndWFnZS5odG1sIiB0aXRsZT0iVGhlIEFUTCBMYW5ndWFnZSI-">
						<img alt="Previous" border="0" src="images/images/prev.gif" gtc:encodedoriginal="PGltZyBhbHQ9IlByZXZpb3VzIiBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL2ltYWdlcy9wcmV2LmdpZiIvPg=="/>
					</a>
				</td>
				<td style="width: 60%" align="center" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogNjAlIiBhbGlnbj0iY2VudGVyIj4="></td>
				<td style="width: 20%" align="right" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogMjAlIiBhbGlnbj0icmlnaHQiPg==">
					<a href="Updating-This-Document.html" title="Updating This Document" gtc:encodedoriginal="PGEgaHJlZj0iVXBkYXRpbmctVGhpcy1Eb2N1bWVudC5odG1sIiB0aXRsZT0iVXBkYXRpbmcgVGhpcyBEb2N1bWVudCI-">
						<img alt="Next" border="0" src="images/images/next.gif" gtc:encodedoriginal="PGltZyBhbHQ9Ik5leHQiIGJvcmRlcj0iMCIgc3JjPSJpbWFnZXMvaW1hZ2VzL25leHQuZ2lmIi8-"/>
					</a>
				</td>
			</tr>
			<tr>
				<td style="width: 20%" align="left" valign="top" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogMjAlIiBhbGlnbj0ibGVmdCIgdmFsaWduPSJ0b3AiPg==">The ATL Language</td>
				<td style="width: 60%" align="center" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogNjAlIiBhbGlnbj0iY2VudGVyIj4="></td>
				<td style="width: 20%" align="right" valign="top" gtc:encodedoriginal="PHRkIHN0eWxlPSJ3aWR0aDogMjAlIiBhbGlnbj0icmlnaHQiIHZhbGlnbj0idG9wIj4=">Updating This Document</td>
			</tr>
		</table><hr/>
		<h1 id="The_ATL_Tools" gtc:encodedoriginal="PGgxIGlkPSJUaGVfQVRMX1Rvb2xzIj4=">The ATL Tools</h1>
		<p>This section provide a complete description of the ATL Tools, then aims to explain their usage.</p>
		<h2 id="Perspectives" gtc:encodedoriginal="PGgyIGlkPSJQZXJzcGVjdGl2ZXMiPg==">Perspectives</h2>
		<p>In Eclipse, the notion of perspective refers to a workbench configuration that is arranged in order to optimise the handling of a certain task. A workbench is usually composed of several subwindows (called views) and toolkits.
			ATL is associated with of two specific perspectives: the main ATL perspective and the ATL Debug perspective, which are respectively dedicated to the design and the debugging of ATL transformations.
			Switching to the ATL, as well as to the other perspectives available on the Eclipse platform, can be achieved by either the perspective buttons available in the thumb index on the top right hand side of your workbench, or by selecting a perspective within the perspectives menu (
			<i>Menu bar->Window->Open perspective->Other...</i>).
		</p>
		<h3 id="ATL_perspective" gtc:encodedoriginal="PGgzIGlkPSJBVExfcGVyc3BlY3RpdmUiPg==">ATL perspective</h3>
		<p>The ATL perspective is the main perspective for ATL development. It provides all the required features for the creation of ATL projects, ATL transformation files and ATL launch configurations. The perspective also includes a textual editor dedicated to ATL files.
			The ATL perspective is composed of seven different views: the Navigator, the Editors, the Outline, the Console, the Error Log, the Properties and the Problems views. Here is a screenshot of an ATL project under the ATL perspective.</p>
		<p>
			<img border="0" src="images/ATL_perspective.png" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9wZXJzcGVjdGl2ZS5wbmciLz4="/>
		</p>
		<p>In its default configuration, the ATL perspective displays the Navigator view on the left side of the window. The Editors view is situated in the top middle part of the windows, whereas the Outline view is positioned on the top left part of the perspective. Finally, the four remaining views (Problems, Properties, Error Log and Console) share the bottom part of the perspective. Note that it is possible to display a given view in the whole perspective by simply double-clicking onto the view title. Moving back to the original perspective configuration is achieved by double-clicking again onto the view title.
			The different views of the ATL perspective are detailed in the following subsections.</p>
		<h4 id="Navigator" gtc:encodedoriginal="PGg0IGlkPSJOYXZpZ2F0b3IiPg==">Navigator</h4>
		<p>Besides browsing the content of the workbench, the Navigator view provides a number of contextual actions on the different contained element it contains. The list of contextual actions, which depends on the type of the selected element, is displayed in a contextual menu obtained by right-clicking on a given element.</p>
		<p>Interesting contextual actions available in the Navigator view include:</p>
		<ul>
			<li>Creating a new ATL project at the Navigator root (
				<i>New->ATL Project</i>);
			</li>
			<li>Creating a new ATL file from an ATL project (
				<i>New->ATL File</i>);
			</li>
			<li>Creating a directory from an ATL project (
				<i>New->Other...->Simple->Folder</i>);
			</li>
			<li>Running/debugging an ATL file (
				<i>Run As->Run.../Debug As->Debug</i>);
			</li>
			<li>Open an ATL file with the ATL Editor (
				<i>Open With->ATL Editor</i>). Since ATL Editor is the default editor for ATL file, it is launched by a simple double-click on the ATL file;
			</li>
			<li>Open an Ecore file with the Sample Ecore Model Editor (
				<i>Open With->Sample Ecore Model Editor</i>). The Sample Ecore Model Editor is the default editor for Ecore files. As a consequence, it can be launched by double-clicking on an Ecore file;
			</li>
		</ul>
		<p>Note that the content of the files opened from the Navigator view is displayed within the Editors view by means of the selected editor.</p>
		<h4 id="Editors" gtc:encodedoriginal="PGg0IGlkPSJFZGl0b3JzIj4=">Editors</h4>
		<p>Eclipse facilitates the development of powerful source editors. Thus, besides the default editors provided by Eclipse and by the EMF framework, an ATL editor has been implemented in order to ease the typing of ATL transformations. This editor is the default editor for 
			<i>.atl</i> files. It performs syntax highlighting, displays the position of defined breakpoints, but also performs runtime parsing, compilation and error detection. The problems that are detected at compile-time are underlined by the ATL Editor. Details about these problems are displayed in the 
			<a href="The-ATL-Tools.html#Problems" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI1Byb2JsZW1zIj4=">Problems view</a>. These details include the type of detected problem (Error, Warning or Style), a textual description of the problem and the positioning of this problem (line and column numbers) in the compiled file. Note that saving modifications of an ATL file that contains a syntactically correct ATL program triggers the compilation of this file, and thus the generation of a new ASM assembler file. An assembler file has the extension 
			<i>.asm</i> and contains the compiled code of the corresponding ATL file.
		</p>
		<p>Note that, when editing an ATL file by means of the ATL Editor, an outline of the ATL transformation is simultaneously displayed within the 
			<a href="The-ATL-Tools.html#Outline" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI091dGxpbmUiPg==">Outline view</a>.
		</p>
		<h4 id="Outline" gtc:encodedoriginal="PGg0IGlkPSJPdXRsaW5lIj4=">Outline</h4>
		<p>The Outline view aims to provide ATL developers with an overview of the structural elements of the file being edited in the Editors view. To this end, the Outline view has to be synchronized with the active tab of the Editors view. </p>
		<p>In the scope of an ATL file, the Outline view displays the structure of the currently edited transformation. Adding, from the ATL Editor view, the code for a new structural element such as a rule or a helper operation will automatically lead to a corresponding addition in the Outline view (at latest when the file is saved). Furthermore, cursors of the ATL Editor and the Outline view always point to the same structural element, as illustrated in the following picture. As a consequence, if the cursor is moved in one of them (either the ATL Editor or the Outline), the other view will replace its own cursor correspondingly.</p>
		<p>Details about the transformation element selected in the Outline view are displayed in the Properties view.</p>
		<p>In the scope of an ATL transformation, the Outline view also enables to position new breakpoints in the transformation code. The definition of a new breakpoint is achieved, from a selected element of the Outline view, by selecting the 
			<i>Add breakpoint</i> option of the contextual menu. The breakpoints defined within the Outline view will be listed in the Breakpoints view available in the 
			<a href="The-ATL-Tools.html#ATL_Debug_perspective" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI0FUTF9EZWJ1Z19wZXJzcGVjdGl2ZSI-">ATL Debug perspective</a>. They are marked in the ATL Editor by means of green points.
		</p>
		<h4 id="Problems" gtc:encodedoriginal="PGg0IGlkPSJQcm9ibGVtcyI-">Problems</h4>
		<p>The Problems view aims to display the problems (typically some syntax errors) that have been detected within the currently edited file. In the scope of the current ATL tools current implementation, this view is mainly useful for the edition of ATL files. It therefore displays the list of problems that have been detected in an ATL program at compile-time (when the edited file is saved).</p>
		<p>The Problems view currently displays two main kinds of Problems in the scope of an ATL transformation:</p>
		<ul>
			<li>Error problems, which are raised for invalid ATL statements (for instance, declaring two models with the same name);</li>
			<li>Warning problems, which are raised for valid ATL statements that may be source of errors (for instance, declaring a variable that hides an already existing variable).</li>
		</ul>
		<p>For each detected problem, the Problems view displays its type (Error or Warning), a short explanation message and the localisation (in terms of line and column number) of the Problem. Note that the corresponding problems are also directly localised in the Editors view.</p>
		<h4 id="Error_Log" gtc:encodedoriginal="PGg0IGlkPSJFcnJvcl9Mb2ciPg==">Error Log</h4>
		<p>The Error Log view aims to display and log the Eclipse general errors. It is of no particular use for ATL developers, as ATL errors are displayed in the Console view.</p>
		<h4 id="Console" gtc:encodedoriginal="PGg0IGlkPSJDb25zb2xlIj4=">Console</h4>
		<p>The Console view displays the messages that may be written from the ATL code, using for instance the string operation 
			<a href="The-ATL-Language.html#String_data_type_operations" title="ATL/___ATLPAGENAME____-_The_ATL_Language#String_data_type_operations" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1MYW5ndWFnZS5odG1sI1N0cmluZ19kYXRhX3R5cGVfb3BlcmF0aW9ucyIgdGl0bGU9IkFUTC9fX19BVExQQUdFTkFNRV9fX18tX1RoZV9BVExfTGFuZ3VhZ2UjU3RyaW5nX2RhdGFfdHlwZV9vcGVyYXRpb25zIj4=">''println()''</a>. It also displays the error messages that may be raised by the execution of incorrect ATL programs. Note that these displayed error messages may provide useful information while trying to identify errors within faulty ATL transformations.
		</p>
		<h3 id="ATL_Debug_perspective" gtc:encodedoriginal="PGgzIGlkPSJBVExfRGVidWdfcGVyc3BlY3RpdmUiPg==">ATL Debug perspective</h3>
		<p>The ATL Debug perspective is dedicated to the debugging of ATL transformations. It provides ATL developers with the usual set of debugging facilities:</p>
		<ul>
			<li>positioning of breakpoints;</li>
			<li>step-by-step transformation execution;</li>
			<li>running transformation to the next breakpoint;</li>
			<li>display of variables values;</li>
			<li>etc...</li>
		</ul>
		<p>This section focuses on the organisation of the ATL Debug perspective and the role of the different views that are part of this perspective. For a detailed description of the debugging facilities offered by the perspective, refer to the 
			<a href="The-ATL-Tools.html#Debugging_ATL" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI0RlYnVnZ2luZ19BVEwiPg==">Debugging ATL section</a>.
			The ATL Debug perspective is structured into seven distinct views: the Debug, the Variables, the Breakpoints, the Editors, the Outline, the Console and the Tasks views. Here is a screenshot of the ATL Debug perspective.
		</p>
		<p>
			<img border="0" src="images/ATL_Debug_perspective.png" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9EZWJ1Z19wZXJzcGVjdGl2ZS5wbmciLz4="/>
		</p>
		<p>In its default configuration, the ATL Debug perspective displays the Debug view on the top left side of the window. The Variables and the Breakpoints views share the top right side of the window. The Editors view is displayed on the middle left side, whereas the Outline view is positioned on the middle right side. Finally, the Console and the Tasks view share the bottom part of the perspective.</p>
		<h4 id="Debug" gtc:encodedoriginal="PGg0IGlkPSJEZWJ1ZyI-">Debug</h4>
		<p>The Debug view provides information on the state of operation stack of the transformation currently being debugged. For this purpose, it displays, as root elements, the list of ATL program currently running in debug mode. For each of these programs, it displays the list of running threads. Note here that an ATL transformation is executed within a single thread. In the scope of this thread, the Debug view displays the stack of called operations.</p>
		<p>In the previous 
			<a href="The-ATL-Tools.html#ATL_Debug_perspective" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI0FUTF9EZWJ1Z19wZXJzcGVjdGl2ZSI-">screenshot</a>, the Debug view provides information on a single ATL execution of the Author2Person transformation. The call stack of the executed thread contains three operations. The operation currently being executed is _applyAuthor(). This operation has been called by the internal _exec()_ operation which has been itself called by the operation main().
		</p>
		<p>The Debug view also provides useful shortcuts for the common debugging operations (Resume, Terminate, Step Into, Step Over, Step return, etc.). These shortcuts are provides as buttons on the right of the view title bar. Their use is further described in the section dedicated to the 
			<a href="The-ATL-Tools.html#Debugging_ATL" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI0RlYnVnZ2luZ19BVEwiPg==">debugging of ATL programs</a>.
		</p>
		<h4 id="Variables" gtc:encodedoriginal="PGg0IGlkPSJWYXJpYWJsZXMiPg==">Variables</h4>
		<p>As previously 
			<a href="The-ATL-Tools.html#ATL_Debug_perspective" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI0FUTF9EZWJ1Z19wZXJzcGVjdGl2ZSI-">illustrated</a>, the Variables view is divided into two distinct parts. The top part of the view displays the values of the variables that are visible from the operation currently being selected in the Debug view. This view offers the possibility to browse the reference properties of these visible variables. By this mean, it is possible to access to the value of model elements that are not directly visible in the scope of the current operation, but that are pointed by some of the currently visible model elements.
		</p>
		<p>The bottom part of the Variables view makes it possible for ATL developers to specify and execute requests onto the set of visible variables.</p>
		<h4 id="Breakpoints" gtc:encodedoriginal="PGg0IGlkPSJCcmVha3BvaW50cyI-">Breakpoints</h4>
		<p>The Breakpoints view displays the list of the breakpoints that are currently defined in the transformation being executed. This view makes it possible to select, among defined breakpoints, a subset of active breakpoints. It also provides a number of shortcuts dedicated to the management of breakpoints. These shortcuts are provided as buttons on the right of the title bar of the Breakpoints view.</p>
		<h2 id="Programming_ATL" gtc:encodedoriginal="PGgyIGlkPSJQcm9ncmFtbWluZ19BVEwiPg==">Programming ATL</h2>
		<p>This section aims to present the different steps of the design and the programming of an ATL transformation with the provided ATL IDE. Executing an ATL transformation obviously requires an ATL transformation file, but also the source and target metamodels as well as the source models of this transformation.</p>
		<p>The first step in the process of designing an ATL transformation is to create an ATL project. Source and target metamodels can be imported from different sources. The main task therefore consists in designing the ATL transformation in itself.</p>
		<h3 id="Creating_an_ATL_project" gtc:encodedoriginal="PGgzIGlkPSJDcmVhdGluZ19hbl9BVExfcHJvamVjdCI-">Creating an ATL project</h3>
		<p>The first step in the design of a new ATL transformation is to be positioned under an ATL project. If no ATL project already exists, this first step requires creating a new empty ATL project (
			<i>New->ATL Project</i>).
		</p>
		<p>This operation triggers the apparition of the ATL Project Creator window in which the name of the project to be created has to be entered. At this stage, it is advised to give the project a sensible name, for instance by concatenating the source metamodel name, the character "2" and the target metamodel name (such as Author2Person). The ATL project creation is then validated by pushing the Finish button.</p>
		<p>For each created project, Eclipse creates a project folder in the Navigator view. A newly generated project can be opened by double-clicking onto the project item in the view. It initially contains a .project file. This file contains the Eclipse metadata that are relative to the project.</p>
		<h3 id="Content_assist" gtc:encodedoriginal="PGgzIGlkPSJDb250ZW50X2Fzc2lzdCI-">Content assist</h3>
		<p>Completion purposes basic templates for rule, helper, from, to, do, using sections.
			You can also access EMF metamodels informations (from their nsURI, or a relative path).</p>
		<h4 id="Usage" gtc:encodedoriginal="PGg0IGlkPSJVc2FnZSI-">Usage</h4>
		<p>To make model elements completion available, you have to put some information on the top of the file :</p>
		<ul>
			<li>
				<i>'-- @nsURI</i>' : the nsURI for a given metamodel, if you want to load a metamodel from the EMF registry,
			</li>
			<li>
				<i>'-- @path</i>' : the path of a given metamodel, if you want to dynamically load a metamodel from an ecore file.
			</li>
		</ul>
		<p>Only EMF metamodels are supported. You must specify the relative path of the file into the workspace.</p>
		<p>Here is the top of an UML2AnyMM transformation :</p>
		<pre>-- @path AnyMM=/AnyProject/AnyFolder/AnyMM.ecore
-- @nsURI UML=http://www.eclipse.org/uml2/2.1.0/UML
</pre>
		<pre>module Class2Relational;
create OUT : AnyMM from IN : UML;
</pre>
		<pre>-- ...transformation helpers and rules
</pre>
		<p>Completion is triggered with the Ctrl + space keys, or when typing a space in a context where some content assist is available.</p>
		<h4 id="Since_ATL_3.1_2" gtc:encodedoriginal="PGg0IGlkPSJTaW5jZV9BVExfMy4xXzIiPg==">Since ATL 3.1</h4>
		<p>To include libraries proposals in the completion, an additional tag information is required:
			<br/>

			<i>'-- @lib</i>' : the path of a library, relative to the workpace (as for metamodel paths).
		</p>
		<h3 id="Creating_an_ATL_file" gtc:encodedoriginal="PGgzIGlkPSJDcmVhdGluZ19hbl9BVExfZmlsZSI-">Creating an ATL file</h3>
		<p>The ATL IDE provides a specific wizard dedicated to the creation of ATL files. Beginner ATL developers are encouraged to use this wizard to create new ATL files. Experimented developers may find the wizard tool too complex for the creation of very simple transformations. In this case, they may prefer to create their ATL files from scratch. Both procedures are described in the following subsections.</p>
		<h4 id="The_ATL_File_Wizard" gtc:encodedoriginal="PGg0IGlkPSJUaGVfQVRMX0ZpbGVfV2l6YXJkIj4=">The ATL File Wizard</h4>
		<p>The ATL File Wizard is launch, from the Navigator view, by selecting the 
			<i>New->ATL File</i> entry in the contextual menu. Note that is command is also available from the File menu of the Eclipse menu bar. This command triggers the apparition the ATL File Wizard window:
		</p>
		<p>
			<img border="0" src="images/ATL_new_file2.PNG" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9uZXdfZmlsZTIuUE5HIi8-"/>
		</p>
		<p>The ATL File Wizard makes it possible to specify the name of the module to be created, the type of the ATL unit that will be contained by the file (an ATL module, query or library), the name of the source and target model and metamodel variables as well as the name of the libraries that will be required for the ATL program to run. From these data, the wizard generates the ATL file with the 
			<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section" title="ATL/___ATLPAGENAME____-_Overview_of_the_Atlas_Transformation_Language#Header_section" gtc:encodedoriginal="PGEgaHJlZj0iT3ZlcnZpZXctb2YtdGhlLUF0bGFzLVRyYW5zZm9ybWF0aW9uLUxhbmd1YWdlLmh0bWwjSGVhZGVyX3NlY3Rpb24iIHRpdGxlPSJBVEwvX19fQVRMUEFHRU5BTUVfX19fLV9PdmVydmlld19vZl90aGVfQXRsYXNfVHJhbnNmb3JtYXRpb25fTGFuZ3VhZ2UjSGVhZGVyX3NlY3Rpb24iPg==">header section</a> that corresponds to the provided information.
		</p>
		<p>You can optionally set the metamodels URIs or paths in order to directly activate content assist into the generated file.</p>
		<p>The "Generate configuration" checkbox generates a launch configuration where you just need to set model paths (and missing metamodels paths).</p>
		<h4 id="Creating_an_ATL_file_from_scratch" gtc:encodedoriginal="PGg0IGlkPSJDcmVhdGluZ19hbl9BVExfZmlsZV9mcm9tX3NjcmF0Y2giPg==">Creating an ATL file from scratch</h4>
		<p>It is possible, for ATL developers, to edit their ATL files from scratch by themselves. To this end, the first step is to create an empty generic file. The naming of the file to be created should follow the conventions proposed in the previous section. Moreover, the file must here be explicitly associated with the 
			<i>.atl</i> extension.
		</p>
		<p>Once the ATL file has been created, the developer has to manually edit the 
			<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section" title="ATL/___ATLPAGENAME____-_Overview_of_the_Atlas_Transformation_Language#Header_section" gtc:encodedoriginal="PGEgaHJlZj0iT3ZlcnZpZXctb2YtdGhlLUF0bGFzLVRyYW5zZm9ybWF0aW9uLUxhbmd1YWdlLmh0bWwjSGVhZGVyX3NlY3Rpb24iIHRpdGxlPSJBVEwvX19fQVRMUEFHRU5BTUVfX19fLV9PdmVydmlld19vZl90aGVfQXRsYXNfVHJhbnNmb3JtYXRpb25fTGFuZ3VhZ2UjSGVhZGVyX3NlY3Rpb24iPg==">header section</a> of the ATL file. Note that the constraints on the naming of the declared model and metamodel variables still have to be respected when editing an ATL header from scratch.
		</p>
		<h3 id="Compiling_an_ATL_file" gtc:encodedoriginal="PGgzIGlkPSJDb21waWxpbmdfYW5fQVRMX2ZpbGUiPg==">Compiling an ATL file</h3>
		<p>The compilation of an ATL file corresponds to the update of its associated ASM file. This compilation can only be performed if the considered ATL program is syntactically correct. In the scope of the ATL IDE, the compilation policy is based on the default Eclipse compilation policy: compilation is automatically performed in the background when an edited ATL file is saved 
			<b>into an ATL Project</b> (or any project configured with the ATL nature).
		</p>
		<h3 id="Setting_up_an_ATL_run_launch_configuration" gtc:encodedoriginal="PGgzIGlkPSJTZXR0aW5nX3VwX2FuX0FUTF9ydW5fbGF1bmNoX2NvbmZpZ3VyYXRpb24iPg==">Setting up an ATL run launch configuration</h3>
		<p>Executing an ATL transformation first requires setting up a transformation launch configuration. An ATL launch configuration aims to resume all the information that is required to execute an ATL transformation. This information includes the paths of the file involved in the transformation (e.g. the ATL file, but also the model, metamodel and library files).</p>
		<h4 id="The_ATL_Configuration_tab" gtc:encodedoriginal="PGg0IGlkPSJUaGVfQVRMX0NvbmZpZ3VyYXRpb25fdGFiIj4=">The ATL Configuration tab</h4>
		<p>The ATL configuration tab allow to specify the paths and URIs of the launch configuration. Fields are precomputed from the specified ATL module, but new ones can be added using the "Modify" section.</p>
		<p>
			<img border="0" src="images/ATL_launch1.PNG" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9sYXVuY2gxLlBORyIvPg=="/>
		</p>
		<h4 id="The_Advanced_tab" gtc:encodedoriginal="PGg0IGlkPSJUaGVfQWR2YW5jZWRfdGFiIj4=">The Advanced tab</h4>
		<p>The Advanced tab allow to configure:</p>
		<ul>
			<li>module superimposition, by adding superimposed module using Add/Remove buttons</li>
			<li>the transformation launcher (the ATL Virtual Machine)</li>
			<li>the launcher parameters. This part is computed for each launcher, as they don't provide same options</li>
		</ul>
		<p>
			<img border="0" src="images/ATL_launch2.PNG" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9sYXVuY2gyLlBORyIvPg=="/>
		</p>
		<h4 id="The_Common_tab" gtc:encodedoriginal="PGg0IGlkPSJUaGVfQ29tbW9uX3RhYiI-">The Common tab</h4>
		<p>The Common tab offers the ATL developer to configure the execution environment of the designed transformation. The Common tab is divided in four blocks: 
			<i>Save as</i>, 
			<i>Display in favorites menu</i>, 
			<i>Console Encoding</i>, and 
			<i>Standard Input and Output</i>. Here is a screenshot of the Common tab of the run ATL launch configuration wizard.
		</p>
		<p>
			<img border="0" src="images/ATL_launch3.PNG" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9sYXVuY2gzLlBORyIvPg=="/>
		</p>
		<ul>
			<li>The 
				<i>Save as</i> section enables to specify whether the launch configuration data have to be saved as a local or a shared file. As a local file, the launch configuration will only be available through the launch configuration window. The launch configuration can also be saved into a file in order to be shared. When selecting this option, the developer has to specify the path to the launch configuration file (the file has to be saved within the current project). When saved as a shared file, the launched configuration file appears at the specified location. This file, which is an XML file, has the name of the considered transformation with the .launch file extension. Thus, saving the launch configuration in the scope of the current example will trigger the creation of the file 
				<i>Author2Person.launch</i>.
			</li>
		</ul>
		<ul>
			<li>The 
				<i>Display in favorites</i> menu section enables ATL developers to customize the perspective by choosing whether they want a shortcut to the designed launch configuration to appear in the Run and/or Debug menus.
			</li>
		</ul>
		<ul>
			<li>The 
				<i>Console Encoding</i> section enables to select the encoding type of the Console that will be used by the transformation for standard inputs and outputs.
			</li>
		</ul>
		<ul>
			<li>Next section deals with these standard inputs and outputs. It provides developers with the possibility to select the input and output facilities for the ATL program. In this scope, it is possible to allocate a console (default option) and/or a file. The developer can also choose to allocate both a console and a file or, at the opposite, to provide no standard input/output facilities to the transformation. Note that, when specifying a file as standard output, the developer can choose to append the results of the successive transformation executions to the output file.</li>
		</ul>
		<ul>
			<li>The last option defined in the 
				<i>Common</i> tab enables to select whether the ATL program has to be executed in background (default option) or not.
			</li>
		</ul>
		<h3 id="Module_superimposition" gtc:encodedoriginal="PGgzIGlkPSJNb2R1bGVfc3VwZXJpbXBvc2l0aW9uIj4=">Module superimposition</h3>
		<h4 id="Description" gtc:encodedoriginal="PGg0IGlkPSJEZXNjcmlwdGlvbiI-">Description</h4>
		<p>While ATL transformation modules and queries are normally run by themselves, that is one transformation module or query at a time, it is also possible to superimpose several transformation modules on top of eachother. The end result is a transformation module that contains the union of all transformation rules and all helpers, where it is possible for a transformation module to override rules and helpers from the transformation modules underneath. Below is an example of a typical use case for superimposition: the transformation rules of the UML2Copy 
			<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Copy.atl?view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3NzZWwudnViLmFjLmJlL3ZpZXdjdnMvdmlld2N2cy5weS9VTUwyQ2FzZVN0dWRpZXMvdW1sMmNzLXRyYW5zZm9ybWF0aW9ucy9VTUwyQ29weS5hdGw_dmlldz1tYXJrdXAiPg==">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Copy.atl?view=markup</a> module are reused and overridden where necessary by the UML2Profiles 
			<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Profiles.atl?view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3NzZWwudnViLmFjLmJlL3ZpZXdjdnMvdmlld2N2cy5weS9VTUwyQ2FzZVN0dWRpZXMvdW1sMmNzLXRyYW5zZm9ybWF0aW9ucy9VTUwyUHJvZmlsZXMuYXRsP3ZpZXc9bWFya3VwIj4=">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/UML2Profiles.atl?view=markup</a> module.
		</p>
		<p>
			<img border="0" src="images/ATL_Superimposition-example.png" gtc:encodedoriginal="PGltZyBib3JkZXI9IjAiIHNyYz0iaW1hZ2VzL0FUTF9TdXBlcmltcG9zaXRpb24tZXhhbXBsZS5wbmciLz4="/>
		</p>
		<p>The UML2Copy transformation module includes a transformation rule for every meta-class instance it must copy. This amounts to approximately 200 rules for the entire UML2 meta-model 
			<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/metamodels/UML.ecore?view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3NzZWwudnViLmFjLmJlL3ZpZXdjdnMvdmlld2N2cy5weS9VTUwyQ2FzZVN0dWRpZXMvdW1sMmNzLXRyYW5zZm9ybWF0aW9ucy9tZXRhbW9kZWxzL1VNTC5lY29yZT92aWV3PW1hcmt1cCI-">http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-transformations/metamodels/UML.ecore?view=markup</a>. 
		</p>
		<p>Any refinement transformation basically needs to copy all meta-class instances, except for the few meta-class instances that are refined. The UML2Profiles transformation module applies a profile to the "uml::Model" instance, provided it was not yet applied. All other elements should just be copied. </p>
		<p>To achieve this, the UML2Profiles module is superimposed on the UML2Copy module. It overrides the "Model" rule, which copies each "uml::Model" instance, by a version that checks that the profile we want to apply has already been applied. It also introduces a new rule "ModelProfile", which checks that the profile we want to apply has not been applied and then applies the profile. The resulting transformation contains all rules from the above figure that have not been striked through. </p>
		<p>Note that superimposition is a load-time construct: there is no real transformation module that represents the result of superimposing several modules on top of eachother. Instead, several modules are simply loaded on top of eachother, overriding existing rules and adding new rules.</p>
		<h4 id="Usage_2" gtc:encodedoriginal="PGg0IGlkPSJVc2FnZV8yIj4=">Usage</h4>
		<p>ATL Superimposition is configured in the Eclipse "Run..." dialog, in the Advanced tab to be exact. You can also use Superimposition from AM3 Ant scripts. An example Ant script can be found 
			<a href="http://ssel.vub.ac.be/viewcvs/viewcvs.py/UML2CaseStudies/uml2cs-instantmessenger-model/outmodels/common/build.xml?rev=5633&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3NzZWwudnViLmFjLmJlL3ZpZXdjdnMvdmlld2N2cy5weS9VTUwyQ2FzZVN0dWRpZXMvdW1sMmNzLWluc3RhbnRtZXNzZW5nZXItbW9kZWwvb3V0bW9kZWxzL2NvbW1vbi9idWlsZC54bWw_cmV2PTU2MzMmYW1wO3ZpZXc9bWFya3VwIj4=">here</a> (see the "profiles" macro).
		</p>
		<p>See also the 
			<a href="http://wiki.eclipse.org/ATL_FAQ#What.27s_this_ATL_feature_called_.22superimposition.22.3F" title="ATL FAQ#What.27s_this_ATL_feature_called_.22superimposition.22.3F" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3dpa2kuZWNsaXBzZS5vcmcvQVRMX0ZBUSNXaGF0LjI3c190aGlzX0FUTF9mZWF0dXJlX2NhbGxlZF8uMjJzdXBlcmltcG9zaXRpb24uMjIuM0YiIHRpdGxlPSJBVEwgRkFRI1doYXQuMjdzX3RoaXNfQVRMX2ZlYXR1cmVfY2FsbGVkXy4yMnN1cGVyaW1wb3NpdGlvbi4yMi4zRiI-">ATL FAQ entry on Superimposition</a>.
		</p>
		<p>NOTE: when adding superimposed modules in the Advanced tab, they override the "main" module specified in the ATL Main Configuration Tab.</p>
		<h3 id="Running_an_ATL_launch_configuration" gtc:encodedoriginal="PGgzIGlkPSJSdW5uaW5nX2FuX0FUTF9sYXVuY2hfY29uZmlndXJhdGlvbiI-">Running an ATL launch configuration</h3>
		<p>Once the launch configuration of a transformation has been correctly fulfilled, it can be run as many times as needed without requiring any change to the configuration. In order to the run a designed ATL transformation, the developer just has to go back to the configuration 
			<i>Run</i> window, to select the created transformation in the ATL Transformation folder (on the left column) and click on the Run button.
			The other option for running an existing ATL launch configuration is to define shortcuts for this configuration. This could be achieved from the Common tab of the ATL run launch configuration by selecting the Run option within the Display in favourites menu section.
		</p>
		<h2 id="ATL_ant_tasks" gtc:encodedoriginal="PGgyIGlkPSJBVExfYW50X3Rhc2tzIj4=">ATL ant tasks</h2>
		<p>This section describes the 
			<a href="http://en.wikipedia.org/wiki/Apache_Ant" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BcGFjaGVfQW50Ij4=">ant</a> tasks provided by the 
			<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/?root=Modeling_Project" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuY29yZS5hbnQvP3Jvb3Q9TW9kZWxpbmdfUHJvamVjdCI-">org.eclipse.m2m.atl.core.ant</a> plugin of ATL.
			Documentation for the standard ant tasks can be found in the 
			<a href="http://ant.apache.org/manual/" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2FudC5hcGFjaGUub3JnL21hbnVhbC8iPg==">ant manual</a>.
		</p>
		<p>Additional tasks are available from 
			<a href="http://ant-contrib.sourceforge.net/" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2FudC1jb250cmliLnNvdXJjZWZvcmdlLm5ldC8iPg==">ant-contrib</a> and documented in its 
			<a href="http://ant-contrib.sourceforge.net/ant-contrib/manual/tasks/index.html" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2FudC1jb250cmliLnNvdXJjZWZvcmdlLm5ldC9hbnQtY29udHJpYi9tYW51YWwvdGFza3MvaW5kZXguaHRtbCI-">manual</a>.
			Using ant-contrib requires 
			<a href="http://ant-contrib.sourceforge.net/ant-contrib/manual/#install" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2FudC1jb250cmliLnNvdXJjZWZvcmdlLm5ldC9hbnQtY29udHJpYi9tYW51YWwvI2luc3RhbGwiPg==">installing it</a>.
		</p>
		<p>ATL ant tasks are useful to:</p>
		<ul>
			<li>chain transformations</li>
			<li>integrate ATL into an existing suite of tools</li>
			<li>access accurate transformations parameters (injectors, extractors, model factories)</li>
		</ul>
		<h3 id="Task_atl.loadModel" gtc:encodedoriginal="PGgzIGlkPSJUYXNrX2F0bC5sb2FkTW9kZWwiPg==">Task atl.loadModel</h3>
		<p>This task (implemented in class 
			<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/LoadModelTask.java?root=Modeling_Project&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuY29yZS5hbnQvc3JjX2FudC9vcmcvZWNsaXBzZS9tMm0vYXRsL2NvcmUvYW50L3Rhc2tzL0xvYWRNb2RlbFRhc2suamF2YT9yb290PU1vZGVsaW5nX1Byb2plY3QmYW1wO3ZpZXc9bWFya3VwIj4=">LoadModelTask</a>) is used to load a model with injectors. This model may be a terminal model or a metamodel. MOF special name is contextually the metametamodel.
		</p>
		<h4 id="Parameters_specified_as_attributes" gtc:encodedoriginal="PGg0IGlkPSJQYXJhbWV0ZXJzX3NwZWNpZmllZF9hc19hdHRyaWJ1dGVzIj4=">Parameters specified as attributes</h4>
		<p>The atl.loadModel can have the following parameters:</p>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
				<td>Default value</td>
			</tr>
			<tr>
				<td>name</td>
				<td>The name of the model in the Ant project.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>metamodel</td>
				<td>The name of the metamodel. This name must be equal to a previous model name loaded by atl.loadModel or to metametamodel special name %.... If this name equals MOF, the metametamodel is taken.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>path</td>
				<td>The path to the file of the model to load. It can be relative to the current directory (the one containing the Ant file). If absolute, the '/' root directory is the current workspace.</td>
				<td rowspan="2" gtc:encodedoriginal="PHRkIHJvd3NwYW49IjIiPg==">Yes (only one of path and nsUri)</td>
				<td>None</td>
			</tr>
			<tr>
				<td>nsURI</td>
				<td>The namespace URI of a metamodel to load from the EMF package registry.</td>
				<td>None</td>
			</tr>
			<tr>
				<td>modelHandler</td>
				<td>The model handler name to use for loading the model (EMF, UML2 or any other installed one). This parameter is only used by the Regular-VM</td>
				<td>No</td>
				<td>EMF</td>
			</tr>
			<tr>
				<td>factory</td>
				<td>The model factory name to use for loading the model. This parameter is only used by the EMF-specific VM</td>
				<td>No</td>
				<td>EMF</td>
			</tr>
		</table>
		<h4 id="Parameters_specified_as_nested_elements" gtc:encodedoriginal="PGg0IGlkPSJQYXJhbWV0ZXJzX3NwZWNpZmllZF9hc19uZXN0ZWRfZWxlbWVudHMiPg==">Parameters specified as nested elements</h4>
		<p>Sometimes, it is interesting to be able to load a model through an injector which extends the 
			<a href="http://wiki.eclipse.org/ATL/Developer_Guide#Core" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3dpa2kuZWNsaXBzZS5vcmcvQVRML0RldmVsb3Blcl9HdWlkZSNDb3JlIj4=">ATL Core</a>. You need to use the injector name you specified when defining it. This sample shows how to load an ATL file as an ATL model:
		</p>
		<pre>&lt;!-- load ATL metamodel -->
&lt;atl.loadModel modelHandler="EMF" name="ATL" metamodel="MOF" path="metamodels/ATL.ecore" />
</pre>
		<pre>&lt;atl.loadModel name="myATL" metamodel="ATL" path="inputs/MySample.atl">
 &lt;injector name="ATL" />
&lt;/atl.loadModel>
</pre>
		<h4 id="Examples_4" gtc:encodedoriginal="PGg0IGlkPSJFeGFtcGxlc180Ij4=">Examples</h4>
		<p>Loading of a metamodel with EMF (and Ecore as metametamodel):</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="News" metamodel="MOF" path="metamodel/News.ecore" />
</pre>
		<p>Equivalent to</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="News" metamodel="%EMF" path="metamodels/News.ecore" />
</pre>
		<p>Loading of a terminal model conforming to the previously loaded metamodel:</p>
		<pre>&lt;atl.loadModel modelHandler="EMF" name="SampleNews" metamodel="News" path="models/MyInput-News.xmi" />
</pre>
		<h3 id="Task_atl.saveModel" gtc:encodedoriginal="PGgzIGlkPSJUYXNrX2F0bC5zYXZlTW9kZWwiPg==">Task atl.saveModel</h3>
		<p>This task (implemented in class 
			<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/SaveModelTask.java?root=Modeling_Project&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuY29yZS5hbnQvc3JjX2FudC9vcmcvZWNsaXBzZS9tMm0vYXRsL2NvcmUvYW50L3Rhc2tzL1NhdmVNb2RlbFRhc2suamF2YT9yb290PU1vZGVsaW5nX1Byb2plY3QmYW1wO3ZpZXc9bWFya3VwIj4=">SaveModelTask</a>) is used to save a model, optionally with extractors. It is possible to save any model: terminal models, metamodels or metametamodels.
		</p>
		<p>The atl.saveModel can have the following parameters:</p>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
				<td>Default value</td>
			</tr>
			<tr>
				<td>model</td>
				<td>The name of the model in the Ant project.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>path</td>
				<td>The path to the file of the model to save. It can be relative to the current directory (the one containing the Ant file). If absolute, the '/' root directory is the current workspace.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>derived</td>
				<td>Sets saved file to "derived"</td>
				<td>No</td>
				<td>true</td>
			</tr>
			<tr>
				<td>factory</td>
				<td>The model factory name to use for saving the model. This parameter is only used by the EMF-specific VM</td>
				<td>No</td>
				<td>EMF</td>
			</tr>
		</table>
		<p>Saving of the previously loaded News metamodel:</p>
		<pre>&lt;atl.saveModel model="News" path="outputs/NewsMM.ecore" />
</pre>
		<p>You can see that the model attribute is the same as the name attribute of the previous atl.loadModel tasks. Once they are loaded, models are identified by this attribute name. Thus, you should avoid giving the same name for two different models. Each time it occurs, your previous model is overwritten.</p>
		<p>Sometimes, it is interesting to save a model with an extractor. For instance, if you have a model conforming to ATL (i.e. a model of an ATL source code), it can be interesting to use the ATL extractor to save it as a .atl file:</p>
		<pre>&lt;atl.saveModel model="myATL" path="outputs/SavingMySample.atl">
 &lt;extractor name="ATL"/>
&lt;/atl.saveModel>
</pre>
		<h3 id="Task_atl.launch" gtc:encodedoriginal="PGgzIGlkPSJUYXNrX2F0bC5sYXVuY2giPg==">Task atl.launch</h3>
		<p>The purpose of this task (implemented in class 
			<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ant/src_ant/org/eclipse/m2m/atl/core/ant/tasks/ATLModelTransformationTask.java?root=Modeling_Project&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuY29yZS5hbnQvc3JjX2FudC9vcmcvZWNsaXBzZS9tMm0vYXRsL2NvcmUvYW50L3Rhc2tzL0FUTE1vZGVsVHJhbnNmb3JtYXRpb25UYXNrLmphdmE_cm9vdD1Nb2RlbGluZ19Qcm9qZWN0JmFtcDt2aWV3PW1hcmt1cCI-">ATLModelTransformationTask</a>) is to execute an ATL transformation. The models used by a transformation are referenced by their name as defined at with the 
			<a href="The-ATL-Tools.html#Task_atl.loadModel" gtc:encodedoriginal="PGEgaHJlZj0iVGhlLUFUTC1Ub29scy5odG1sI1Rhc2tfYXRsLmxvYWRNb2RlbCI-">atl.loadModel</a> task (name attribute).
		</p>
		<h4 id="Parameters_specified_as_attributes_2" gtc:encodedoriginal="PGg0IGlkPSJQYXJhbWV0ZXJzX3NwZWNpZmllZF9hc19hdHRyaWJ1dGVzXzIiPg==">Parameters specified as attributes</h4>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
				<td>Default value</td>
			</tr>
			<tr>
				<td>path</td>
				<td>Path of the compiled ATL transformation to run (.asm)</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>refining</td>
				<td>Boolean value that determines whether or not the transformation is a refining one</td>
				<td>No</td>
				<td>false</td>
			</tr>
		</table>
		<p>Within this task, you have to bind every model from the header of your ATL module. There is three kinds of nested parameters: </p>
		<ul>
			<li>
				<b>inmodel</b> for source models
			</li>
			<li>
				<b>outmodel</b> for target models 
			</li>
			<li>
				<b>inoutmodel</b> for source/target models (refining mode)
			</li>
			<li>
				<b>library</b> for helpers library
			</li>
		</ul>
		<p>For instance, if you have this module header:</p>
		<pre>module Families2Persons;
create OUT : Persons from IN : Families;
uses myLib;
</pre>
		<p>You have to create one inModel parameter (for IN), one outModel (for OUT) and one library (for myLib). For instance:</p>
		<pre>&lt;atl.launch path="ATLFiles/MyTransformation.asm">
 &lt;inmodel name="IN" model="..."/>			
 &lt;outmodel name="OUT" model="..." metamodel="Persons"/>
 &lt;library name="strings" path="lib/mylib.atl" />
&lt;/atl.launch>
</pre>
		<p>Each parameter has a name that MUST be exactly the same as in the module header (case sensitive). For inmodel parameters, model attribute refers to a name of a previously loaded model with atl.loadModel for instance. The attribute model of outmodel do NOT refer a loaded model as it has not been yet created. The value of this attribute should be used latter as an identifier for the atl.saveModel task.</p>
		<p>Every attributes for each nested parameters are summed here:</p>
		<h4 id="Parameters_specified_as_nested_elements_2" gtc:encodedoriginal="PGg0IGlkPSJQYXJhbWV0ZXJzX3NwZWNpZmllZF9hc19uZXN0ZWRfZWxlbWVudHNfMiI-">Parameters specified as nested elements</h4>
		<h5 id="inmodel" gtc:encodedoriginal="PGg1IGlkPSJpbm1vZGVsIj4=">inmodel</h5>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
			</tr>
			<tr>
				<td>name</td>
				<td>The name of the model in ATL module header.</td>
				<td>Yes</td>
			</tr>
			<tr>
				<td>model</td>
				<td>The name of a model previously loaded.</td>
				<td>Yes</td>
			</tr>
		</table>
		<h5 id="outmodel" gtc:encodedoriginal="PGg1IGlkPSJvdXRtb2RlbCI-">outmodel</h5>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
				<td>Default value</td>
			</tr>
			<tr>
				<td>name</td>
				<td>The name of the model in ATL module header.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>model</td>
				<td>The name of a model previously loaded.</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>metamodel</td>
				<td>The name of the metamodel of the current model as it has been specified when loading</td>
				<td>Yes</td>
				<td>None</td>
			</tr>
			<tr>
				<td>path</td>
				<td>Name of the output file (mainly needed for filename extension and EMF uses this to determine the correct factory).</td>
				<td>No</td>
				<td>None</td>
			</tr>
			<tr>
				<td>modelHandler</td>
				<td>The model handler name to use for creating the model (EMF, UML2 or any other installed one). This parameter is only used by the Regular-VM</td>
				<td>No</td>
				<td>EMF</td>
			</tr>
			<tr>
				<td>factory</td>
				<td>The model factory name to use for creating the model. This parameter is only used by the EMF-specific VM</td>
				<td>No</td>
				<td>EMF</td>
			</tr>
		</table>
		<h5 id="superimpose" gtc:encodedoriginal="PGg1IGlkPSJzdXBlcmltcG9zZSI-">superimpose</h5>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
			</tr>
			<tr>
				<td>path</td>
				<td>The path of the ATL module to superimpose.</td>
				<td>Yes</td>
			</tr>
		</table>
		<h5 id="library" gtc:encodedoriginal="PGg1IGlkPSJsaWJyYXJ5Ij4=">library</h5>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
			</tr>
			<tr>
				<td>name</td>
				<td>The name of the library in ATL module header.</td>
				<td>Yes</td>
			</tr>
			<tr>
				<td>path</td>
				<td>The path to the ATL library file.</td>
				<td>Yes</td>
			</tr>
		</table>
		<h5 id="option" gtc:encodedoriginal="PGg1IGlkPSJvcHRpb24iPg==">option</h5>
		<table border="1" gtc:encodedoriginal="PHRhYmxlIGJvcmRlcj0iMSI-">
			<tr>
				<th>Attribute</th>
				<td>Description</td>
				<td>Required</td>
			</tr>
			<tr>
				<td>name</td>
				<td>The option name.</td>
				<td>Yes</td>
			</tr>
			<tr>
				<td>value</td>
				<td>The value of the option of which the name is specified in the name attribute.</td>
				<td>Yes</td>
			</tr>
		</table>
		<p>Options are passed to the ATL Virtual Machine. Available options are defined:</p>
		<ul>
			<li>
				<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ui.vm/plugin.xml?root=Modeling_Project&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuY29yZS51aS52bS9wbHVnaW4ueG1sP3Jvb3Q9TW9kZWxpbmdfUHJvamVjdCZhbXA7dmlldz1tYXJrdXAiPg==">here</a> for the Regular-VM
			</li>
			<li>
				<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.engine.emfvm/plugin.xml?root=Modeling_Project&amp;view=markup" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL2Rldi5lY2xpcHNlLm9yZy92aWV3Y3ZzL2luZGV4LmNnaS9vcmcuZWNsaXBzZS5tMm0vb3JnLmVjbGlwc2UubTJtLmF0bC9wbHVnaW5zL29yZy5lY2xpcHNlLm0ybS5hdGwuZW5naW5lLmVtZnZtL3BsdWdpbi54bWw_cm9vdD1Nb2RlbGluZ19Qcm9qZWN0JmFtcDt2aWV3PW1hcmt1cCI-">here</a> for the EMF-specific VM
			</li>
		</ul>
		<p>(see options into the org.eclipse.m2m.atl.core.launcher extension)</p>
		<h4 id="Launcher_configuration" gtc:encodedoriginal="PGg0IGlkPSJMYXVuY2hlcl9jb25maWd1cmF0aW9uIj4=">Launcher configuration</h4>
		<p>To choose the launcher you want to use (i.e. EMF-specific VM or Regular VM) you have to specify it as a property in the ant project. EMF-specific VM is selected by default. For instance, to use Regular VM instead:</p>
		<pre>&lt;?xml version="1.0"?> &lt;project name =“test.types”default =“run”basedir =“。”&gt; &lt;property name =“atl.launcher”value =“Regular VM（with debugger）”/&gt; ...&lt;/项目&gt;<h4 id="Making_ATL_transformations_chains_without_intermediate_serialization">使ATL转换链没有中间序列化</h4>
		<p>假设您有两个转换A2B和B2C链。A2B将符合A的模型转换为符合B的模型.B2C将符合B的模型转换为符合C的模型。我们只想序列化符合C的模型，但没有符合B的中间模型。解决方案是它可以直接作为B2C转换的输入传递，如下所示：</p>
		<p>加载元模型：</p>
		<pre>&lt;atl.loadModel metamodel =“％EMF”name =“A”path =“...”/&gt; &lt;atl.loadModel metamodel =“％EMF”name =“B”path =“...”/&gt; &lt;atl .loadModel metamodel =“％EMF”name =“C”path =“...”/&gt;</pre>
		<p>加载源模型：</p>
		<pre>&lt;atl.loadModel metamodel =“A”name =“myModel-A”path =“...”/&gt;＆lt;！ - “ -  A”在这里不要忘记myModel符合元模型“A”，但是你可以给任何名字 - &gt;</pre>
		<p>第一次转型：</p>
		<pre>&lt;atl.launch path =“...”&gt;＆lt;！ - 执行转换的标题是：module myModule1;从SourceM创建TargetM：TargetMM：SourceMM; - &gt; &lt;inmodel name =“SourceM”model =“myModel-A”/&gt; &lt;outmodel name =“''''TargetM'''”model =“'''myModel-B'''”metamodel =“B” /&gt; &lt;/atl.launch&gt;</pre>
		<p>第二次转型：</p>
		<pre>&lt;atl.launch path =“...”&gt;＆lt;！ - 执行转换的标题是：module myModule2;从SourceM创建TargetM：TargetMM：SourceMM; - &gt; &lt;inmodel name =“''''SourceM'''”model =“'''myModel-B'''”/&gt; &lt;outmodel name =“TargetM”model =“myModel-C”metamodel =“C” /&gt; &lt;/atl.launch&gt;</pre>
		<p>请注意，myModel-B可用于第二次转换，就好像它已被atl.loadModel调用加载一样。</p>
		<p>仅序列化第二个转换的输出（模型myModel-C）</p>
		<pre>&lt;atl.saveModel model =“myModel-C”path =“...”/&gt;</pre>
		<h4 id="Examples_5">例子</h4>
		<p>炼油改造（完全可用<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/examples/org.eclipse.m2m.atl.examples.public2private/?root=Modeling_Project">在这里</a> ），具体的EMF-VM推出：</p>
		<pre>&lt;？xml版本=“1.0”？&gt; &lt;project name =“Public2Private”default =“run”basedir =“。”&gt; &lt;property name =“samplePath”value =“../ model / sample.uml”/&gt;</pre>
		<pre>&lt;target name =“run”&gt; &lt;atl.loadModel name =“UML”metamodel =“MOF”nsUri =“http://www.eclipse.org/uml2/2.1.0/UML”/&gt; &lt;atl.loadModel name =“sample”metamodel =“UML”path =“$ {samplePath}”/&gt;</pre>
		<pre>&lt;atl.launch path =“../ transformation / public2private.asm”refining =“true”&gt; &lt;inoutmodel model =“sample”name =“IN”/&gt; &lt;/atl.launch&gt;</pre>
		<pre>&lt;atl.saveModel model =“sample”path =“$ {samplePath}”/&gt; &lt;/ target&gt; &lt;/ project&gt;</pre>
		<h3 id="Mapping_with_AM3_ant_tasks">使用AM3 ant任务进行映射</h3>
		<p>Ant任务已添加到ATL，以提供与<a href="http://wiki.eclipse.org/AM3_Ant_Tasks">AM3 ant任务</a>相同的支持，适用于ATL3.0.x API。以下是AM3和ATL任务之间的映射和更改列表：</p>
		<ul>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.loadModel">am3.loadModel</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.loadModel">atl.loadModel</a>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.saveModel">am3.saveModel</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.saveModel">atl.saveModel</a>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.atl">am3.atl</a> - &gt; <a href="The-ATL-Tools.html#Task_atl.launch">atl.launch</a>
				<ul>
					<li>allowInterModelReferences参数不再存在，必须作为选项传递：</li>
				</ul>
			</li>
		</ul>
		<pre>&lt;atl.launch path =“test.asm”&gt; &lt;option name =“allowInterModelReferences”value =“true”/&gt; &lt;inmodel model =“sample”name =“IN”/&gt; ...&lt;/atl.launch&gt;</pre>
		<ul>
			<li>
				<ul>
					<li>在atl.launch任务中，您不需要添加元模型作为输入模型（将被忽略）</li>
				</ul>
			</li>
			<li>
				<a href="http://wiki.eclipse.org/AM3_Ant_Tasks#Task_am3.query">am3.query</a> - &gt;不可用。您可以使用atl.launch任务运行查询</li>
		</ul>
		<p>注意：AM3注入器/提取器（如XML，KM3）未嵌入到ATL中</p>
		<h3 id="Launching_an_Ant_file_with_ATL_tasks_in_an_Eclipse_workbench">在Eclipse工作台中启动带有ATL任务的Ant文件</h3>
		<p>定义Ant文件后，右键单击该文件：</p>
		<ul>
			<li>选择Run As&gt; Ant Build |</li>
		</ul>
		<ul>
			<li>转到JRE选项卡</li>
		</ul>
		<ul>
			<li>选择“在与工作区相同的JRE中运行”</li>
		</ul>
		<p>
			<img border="0" src="images/AM3AntTasks_JreTab.jpg">
		</p>
		<h2 id="ATL_Plugins">ATL插件</h2>
		<p>ATL插件向导有助于实现ATL程序化启动。该实用程序首先要求转换参数（元模型，库路径，转换模块路径）：</p>
		<p>
			<img border="0" src="images/ATL_plugin_wizard.png">
		</p>
		<p>然后将生成一个新的插件，嵌入：</p>
		<ul>
			<li>转换模块和库</li>
			<li>包含URI，atl文件路径的propery文件</li>
			<li>允许以编程方式启动ATL转换的Java类</li>
		</ul>
		<p>
			<img border="0" src="images/ATL_plugin_wizard_result.png">
		</p>
		<p>最后，您将能够使用生成的main启动转换，或将启动器类集成到现有应用程序中。要将转换用作独立应用程序，您可以使用Eclipse Java导出选项：</p>
		<p>
			<img border="0" src="images/ATL_plugin_wizard_result_export.png">
		</p>
		<p>这将产生一个包含所有必需的ATL，Eclipse和EMF库的.jar。</p>
		<h2 id="Debugging_ATL">调试ATL</h2>
		<p>本节旨在介绍ATL IDE提供的调试工具。因此，ATL开发环境为ATL开发人员提供了专用的ATL Debug透视图。此透视图为开发人员提供了最常见的调试工具，包括逐步转换执行，运行转换到下一个断点，显示变量内容等。此外，ATL IDE使开发人员可以随时了解当前正在执行的ATL指令通过突出显示ATL编辑器中的相应代码。</p>
		<p>ATL调试操作可从ATL Debug透视图获得。对于Java程序，调试ATL转换意味着在调试模式下执行此转换。这假设开发人员为转换创建ATL调试启动配置。调试执行模式及其关联的调试操作由执行此调试启动配置触发。</p>
		<h3 id="Managing_breakpoints">管理断点</h3>
		<p>ATL调试模式可以在任何类型的ATL单元中定义断点，包括从其他ATL单元导入的库。必须通过Outline视图定位这些断点，该视图可从ATL和ATL Debug透视图中获得。请注意，“大纲”视图仅显示使用ATL编辑器编辑的ATL单元的结构。</p>
		<h4 id="Setting.2FRemoving_breakpoints">设置/删除断点</h4>
		<p>在ATL IDE的范围内，ATL程序中断点的设置只能通过Outline视图来实现。请记住，Outline视图显示当前使用ATL编辑器编辑的ATL文件的结构（事实上，它显示与编辑的ATL文件对应的ATL模型）。通过在所选元素的上下文菜单中选择“ <i>添加断点”</i>条目，可以在ATL结构元素的级别定义新断点。这在下一个屏幕截图中说明，其中断点位于NavigationOrAttributeCallExp元素的级别。请注意，在“大纲”视图中选择的元素对应的代码同时在ATL编辑器视图中突出显示。
		</p>
		<p>Outline视图当前允许开发人员将断点与ATL程序的任何类型的结构元素相关联。但是，定位新断点仅对与执行指令关联的结构元素有意义。构成断点相关目标的结构元素大致对应于ATL引擎评估的OCL表达式。这意味着诸如MatchedRule（或CalledRule）元素，Helper元素或InPattern和OutPattern元素之类的转换元素不应与断点相关联。请注意，Outline视图允许为这些元素定义断点，但在程序调试期间将忽略它们。</p>
		<p>定义的断点显示在ATL编辑器视图的左列中。下面的屏幕截图说明了这一点，其中先前定位到NavigationOrAttributeCallExp元素上的断点由ATL编辑器左栏中的蓝色圆圈进行了本地化。虽然ATL编辑器显示已定义断点的位置，但它无法处理它们。这必须通过ATL Debug透视图的Breakpoints视图来实现。</p>
		<p>只能从ATL Debug透视图的Breakpoints视图中删除定义的断点。该视图使得可以在定义的断点之间选择多个断点。可以使用“删除选择断点”按钮删除这些断点。</p>
		<p>请注意，从断点列表中选择断点时（在“断点”视图中），上下文菜单中也可以使用断点删除操作。</p>
		<h4 id="Activating.2FDeactivating_breakpoints">激活/取消激活断点</h4>
		<p>Breakpoints视图还提供激活和停用已定义断点的可能性。在调试ATL转换时，不会考虑停用的断点。此工具可以忽略某些已定义的断点而无需删除它们。</p>
		<p>断点激活/取消激活仅可从与断点列表元素关联的上下文菜单中获得。请注意，作为断点设置和删除，可以在调试ATL程序之前或期间执行激活/取消激活。</p>
		<h4 id="Limitations_2">限制</h4>
		<p>除了Outline视图允许在不相关的位置定义断点之外，当编译ATL文件时，ATL开发环境目前在更新已定义断点的位置时提供的支持很少（默认的ATL编译策略是在保存时编译文件） ）。因此，一旦编译了定义了断点的ATL文件，定义的断点就会指向所考虑的程序文件中的不相关位置。在调试ATL单元时，这可能由内部错误实现。</p>
		<h3 id="Creating_an_ATL_Debug_launch_configuration">创建ATL调试启动配置</h3>
		<p>对于运行模式，首先在调试模式下执行ATL转换需要设置ATL Debug启动配置。通过在Navigator视图中选择ATL文件并选择其上下文菜单的<i>“Debug As-&gt; Debug ...”</i>条目，可以从Navigator视图创建新的ATL调试启动配置。请注意，通过选择Debug菜单的<i>Debug ...</i>条目，也可以从Eclipse菜单栏启动此调试启动配置向导。
		</p>
		<p>ATL程序共享运行和调试模式的通用启动配置。这有两个后果。首先，这意味着一旦配置了ATL单元的运行启动配置，就不需要创建专用于调试模式的新启动配置。第二个结果是两种启动配置必须以相同的方式<a href="The-ATL-Tools.html#Setting_up_an_ATL_run_launch_configuration">配置</a> （反汇编模式选项除外，见下文）。
		</p>
		<p>启动配置的“ATL配置”选项卡中提供的“反汇编”模式选项在运行模式下无效。但是，在调试模式下，此选项使开发人员可以从其字节码调试ATL单元（例如，与ATL程序关联的ASM文件包含）。此调试模式主要是为ATL语言的开发人员提供的，不在本手册的范围之内。</p>
		<h3 id="Running_an_ATL_Debug_launch_configuration">运行ATL Debug启动配置</h3>
		<p>执行ATL调试启动配置遵循与ATL运行启动配置相同的方案：从配置调试窗口，开发人员只需在ATL Transformation文件夹（左栏）中选择转换，然后单击Debug按钮。</p>
		<p>至于运行模式，还有另一个选项，它包括为此配置定义调试快捷方式。这可以通过在“收藏夹菜单”部分的“显示”中选择“调试”选项，从ATL启动配置的“ <a href="The-ATL-Tools.html#The_Common_tab">公共”选项卡</a>中实现。
		</p>
		<h3 id="Debugging_actions">调试操作</h3>
		<p>在调试程序时，开发人员习惯于提供一组标准的调试操作。在ATL IDE的范围内，ATL Debug透视图的Debug视图提供了主要调试操作的快捷方式。在调试转换时，也可以从Eclipse菜单栏的“运行”菜单以及当前线程或其内容的上下文菜单中访问调试操作：</p>
		<p>
			<img border="0" src="images/ATL_debug_actions.png">
		</p>
		<ul>
			<li><i>Resume</i>操作会触发调试转换的执行，直到下一个断点。不执行断点的程序将执行到终止。
			</li>
		</ul>
		<ul>
			<li><i>Step Over</i>操作是一步一步的操作。激活此操作会触发当前指令的执行。请注意，如果此指令是操作调用（Outline视图中OperationCallExp类型的元素），则调试器将跳过调用操作的执行。以相同的方式，如果当前指令是当前执行的操作中的最后一个，则调试器将恢复到调用操作。
			</li>
		</ul>
		<ul>
			<li><i>Step Into</i>行动是另一个循序渐进的行动。触发到表达式调用指令，它跳转到被调用操作的主体（例如第一条指令）。请注意，当调用非操作调用的指令时，此Step Into操作的行为方式与<i>Step Over</i>操作相同。
			</li>
		</ul>
		<ul>
			<li>最后一步一步的操作是<i>Step Return</i>操作。此操作将恢复执行当前操作被调用的点的转换执行。从助手，属性或被调用规则触发，步骤返回操作将恢复为调用用户代码。从源模式元素触发，操作将恢复到生成的主操作<i>__exec __（）</i> ，该操作将依次调用下一个<i>__match</i>操作或第一个<i>__exec</i>操作。最后，从目标模式元素触发，操作将恢复到生成的主操作<i>__exec __（）</i> ，该操作将依次调用下一个<i>__exec</i>操作或运行到程序终止。请注意，从细胞操作的最后一条指令调用，此操作的行为方式与之前的操作相同。
			</li>
		</ul>
		<ul>
			<li>“ <i>终止”和“删除”</i>操作终止正在调试的转换，并将其从“调试”视图中删除。
			</li>
		</ul>
		<ul>
			<li>“ <i>删除所有已终止的启动”</i>操作将从“调试”视图中删除所有已终止的转换。如果视图不包含已终止的转换，则此操作不可用。
			</li>
		</ul>
		<p>最后，虽然在调试透视图中可用，但<i>Disconnect</i>和<i>Terminate</i>操作当前不起作用。
		</p>
		<h3 id="Displaying_variables_values">显示变量值</h3>
		<p>在ATL Debug透视图的范围内，Variables视图旨在为开发人员提供在执行转换期间观察ATL变量内容的便捷方法。为此，“变量”视图显示当前执行上下文中可见的所有变量。请注意，无论考虑执行上下文，都定义变量self。</p>
		<p>在帮助器的上下文中，可见变量对应于辅助参数，通过let指令引入的局部变量以及在集合迭代表达式范围内使用的迭代器变量。这里的变量self对应于声明上下文的元素。除参数外，可见变量集在ATL属性的范围内类似。</p>
		<p>在转换执行的<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language＃Default_mode_execution_semantics">匹配阶段</a> ，匹配规则的上下文中可见的变量包括源模式元素变量以及可以在源模式元素表达式的范围内声明的变量和迭代器。在初始化阶段，这组可见变量将更改为规则使用部分中声明的规则局部变量，源和目标模式元素变量以及在已执行表达式中声明的变量/迭代器。
		</p>
		<p>
			<img border="0" src="images/ATL_navigate_debug_variables.png">
		</p>
		<p>在此示例中，已在规则Author的目标模式元素的第一个绑定上设置断点（在“编辑器”视图的左列中可见）。Debug视图指示当前正在执行的操作（例如，操作<i>__applyAuthor（）</i> ）对应于规则Author的初始化阶段（ <i>__ apply</i>前缀与规则初始化阶段相关联）。回到编辑器视图，可以识别以绿色突出显示的当前指令：这里对应于对规则目标模式元素<i>的姓氏</i>绑定中的变量<i>a''</i>的评估。
		</p>
		<p>“ <i>变量”</i>视图可以导航在此上下文中可见的变量的内容。变量a对应于当前由规则匹配的源模型元素。变量<i>p''对应于当前初始化的目标模式模型元素。请注意，在此阶段，由于未完成姓氏绑定的执行，因此该变量的唯一初始化属性是“name”</i> 。变量<i>self</i>在这里指向ATL模块。最后，在转换初始化阶段出现的变量链接对应于ATL引擎内部变量，并且开发人员可以忽略。虽然在所考虑的示例中未示出，但是变量视图使得能够导航集合变量的内容。它还可以使用这些元素定义的引用来导航源，并在某些时候导航目标模型元素。
		</p>
		<p></p><div style="display:none">=另见=</div>
<div style="display:none">* <a href="ATL User Guide.html#Introduction" title="ATL / ___ ATLPAGENAME ____-_简介">简介</a>
</div>
<div style="display:none">* <a href="Installation.html#Installation" title="ATL / ___ ATLPAGENAME ____-_安装">安装</a>
</div>
<div style="display:none">* <a href="Overview-of-the-Atlas-Transformation-Language.html#Overview_of_the_Atlas_Transformation_Language" title="ATL / ___ ATLPAGENAME ____-_ Overview_of_the_Atlas_Transformation_Language">Atlas转换语言概述</a>
</div>
<div style="display:none">* <a href="The-ATL-Language.html#The_ATL_Language" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language">ATL语言</a>
</div>
		<hr>
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="The-ATL-Language.html" title="ATL语言">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="ATL User Guide.html" title="ATL用户指南">
						<img alt="ATL用户指南" border="0" src="images/images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">ATL语言</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table>
	
</body></html>