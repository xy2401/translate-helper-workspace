<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>序列（T）</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library"></link>
<link rel="prev" href="Real.html" title="Real"></link>
<link rel="next" href="Set.html" title="Set(T)"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">序列（T）</h1>
<div class="section" title="序列（T）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Sequence"></a>
				<span class="bold"><strong>
					<code class="code">Sequence(T)</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>序列是元素排序的集合。元素可以是序列的一部分不止一次。Sequence本身是元类型SequenceType的一个实例。句子不是Bag的子类型。Sentence and Bags的常见超类型是Collection。</p>
<p><a class="link" href="OrderedCollection.html" title="OrderedCollection（T）"><code class="code">OrderedCollection(T)</code></a>
			
</p>
<p>
				
<span class="bold"><strong>操作</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>如果<code class="code">self</code>包含与s相同的元素，则为True。
			</p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>优先级： <code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">append（object：T [？]）：Sequence（T）</code>
			
</p>
<p>元素序列，由<code class="code">self</code>的所有元素组成，后跟object。
			</p>
<p>
				
<code class="code">appendAll（objects：OrderedCollection（T））：Sequence（T）</code>
			
</p>
<p>元素序列，由<code class="code">self</code>的所有元素组成，后跟对象。
			</p>
<p>
				
<code class="code">排除（对象：OclAny [？]）：序列（T）</code>
			
</p>
<p>除了所有出现的对象之外，包含<code class="code">self</code>所有元素的序列。
			</p>
<p>其余元素的顺序不会改变。</p>
<p>
				
<code class="code">excludedAll（objects：Collection（OclAny））：Sequence（T）</code>
			
</p>
<p>包含所有<code class="code">self</code>元素的序列，除了所有出现的所有对象。
			</p>
<p>
				
<code class="code">flatten（T2）（）：序列（T2）</code>
			
</p>
<p>重新定义Collection操作。如果元素类型不是集合类型，则会产生与<code class="code">self</code>相同的序列。如果元素类型是集合类型，则结果是包含<code class="code">self</code>的所有递归展平元素的所有元素的序列。元素的顺序是部分的。
			</p>
<p>
				
<code class="code">包括（对象：T [？]）：序列（T）</code>
			
</p>
<p>包含<code class="code">self</code>和object的所有元素的序列作为最后一个元素添加。
			</p>
<p>
				
<code class="code">includesAll（objects：Collection（T））：Sequence（T）</code>
			
</p>
<p>包含<code class="code">self</code>和对象的所有元素的序列作为最后元素添加。
			</p>
<p>
				
<code class="code">insertAt（index：Integer [？]，object：T [？]）：Sequence（T）invalidating</code>
			
</p>
<p>由<code class="code">self</code>和对象插入位置索引组成的序列。
			</p>
<p>
				
<code class="code">prepend（object：T [？]）：Sequence（T）</code>
			
</p>
<p>由object组成的序列，后跟<code class="code">self</code>的所有元素。
			</p>
<p>
				
<code class="code">prependAll（objects：OrderedCollection（T））：Sequence（T）</code>
			
</p>
<p>由对象组成的序列，后跟<code class="code">self</code>的所有元素。
			</p>
<p>
				
<code class="code">reverse（）：序列（T）</code>
			
</p>
<p>序列包含相同的元素但顺序相反。</p>
<p>
				
<code class="code">selectByKind（TT）（类型：TT [？]）：序列（TT）</code>
			
</p>
<p>
				
<code class="code">selectByType（TT）（类型：TT [？]）：序列（TT）</code>
			
</p>
<p>
				
<code class="code">subSequence（lower：Integer [？]，upper：Integer [？]）：Sequence（T）invalidating</code>
			
</p>
<p><code class="code">self</code>的子序列从数字较低开始，直到并包括元素编号upper。
			</p>
<p>
				
<span class="bold"><strong>迭代</strong></span>
			
</p>
<p>
				
<code class="code">closure（i：T [1] | lambda：Lambda T（）：OrderedSet（T）[？]）：OrderedSet（T）</code>
			
</p>
<p>将物体传递到源集合的每个不同元素的封闭。</p>
<p>
				
<code class="code">收集（V）（i：T [？]| lambda：Lambda T（）：V [？]）：序列（V）</code>
			
</p>
<p>
				
<code class="code">collectNested（V）（i：T [？]| lambda：Lambda T（）：V [？]）：序列（V）</code>
			
</p>
<p>将主体应用于源有序集合的每个成员所产生的元素序列。</p>
<p>
				
<code class="code">拒绝（i：T [？]| lambda：Lambda T（）：Boolean [1]）：Sequence（T）</code>
			
</p>
<p>body序列的子序列为<code class="code">false</code> 。
			</p>
<p>
				
<code class="code">选择（i：T [？]| lambda：Lambda T（）：Boolean [1]）：Sequence（T）</code>
			
</p>
<p>主体为<code class="code">true</code>源序列的子序列。
			</p>
<p>
				
<code class="code">sortedBy（i：T [？]| lambda：Lambda T（）：OclAny [？]）：序列（T）</code>
			
</p>
<p>包含源集合的所有元素的Sequence中的结果。首先是身体具有最低值的元素，依此类推。正文表达式的类型必须具有&lt;operation defined。&lt;operation必须返回一个布尔值并且必须是可传递的（即，如果a &lt;b且b &lt;c则a &lt;c）。</p>
</div>
</body>
</html>