<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="sB.1.html" rel="prev">&lt;&lt;§B.1版本之间的段落发生了变化</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
         <div class="sect depth2" id="sB.2">
            <h2 class="sect">§B.2版本之间的增加<a class="img" href="sB.2.html" title="PermaLinkto§B.2版本之间的增加"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="subsect depth3" id="sB.2.1">
               <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.2.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字</strong><p>使现有功能显式化并为外化角色引入新的限定类文字。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断出的标注</strong><p>新功能。
                        				
                     </p>
                  </li>
                  <li><a href="s4.6.a.html" title="§4.6。（a）超级班的私人方法" class="sect">§4.6。（a）</a> ： <strong>来自超级类的Callin绑定私有方法</strong><p>添加了必要的限制。
                        				
                     </p>
                  </li>
                  <li><a href="s4.9.html" title="§4.9Callin继承" class="sect">§4.9</a> ： <strong>Callin继承</strong><p>澄清了指定不充分或解释不充分的问题，具体而言：</p>
                     <ul>
                        <li>callin绑定对遗传或被覆盖的基本方法的影响（ <a href="s4.9.1.html" title="§4.9.1基础侧继承" class="sect">§4.9.1</a> ）。
                        </li>
                        <li>callin绑定和基本方法与协变返回类型的<a href="s4.9.3.html" title="§4.9.3 Covariant return types" class="sect">相互作用</a> （ <a href="s4.9.3.html" title="§4.9.3协变返回类型" class="sect">§4.9.3</a> ）</li>
                     </ul>
                  </li>
                  <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ： <strong>通用替换绑定</strong><p>通过使用类型参数调整<a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）中</a>引入的替换绑定的类型安全性，并具有所需的灵活性。
                        				
                     </p>
                  </li>
                  <li><a href="s7.2.b.html" title="§7.2。（b）受限阵列" class="sect">§7.2。（b）</a> ： <strong>受限制的阵列</strong><p>添加了必要的限制。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.2">
               <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.2.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.2.h.html" title="§1.2.2。（h）外化创作" class="sect">§1.2.2。（h）</a> ： <strong>外化创作</strong><p>使用值参数和更改的标题添加了替代语法。</p>
                  </li>
                  <li><a href="s1.2.5.f.html" title="§1.2.5。（f）进口角色档案" class="sect">§1.2.5。（f）</a> ： <strong>角色文件中的导入</strong><p>添加了缺少的规则，用于定义角色文件中的导入效果。</p>
                  </li>
                  <li><a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">§1.3.1。（c）</a> ： <strong>@</strong> <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">Override</a> <strong>角色注释</strong><p>常规的<code>@Override</code>注释（Java≥5）也已扩展为适用于角色类。
					
                     </p>
                  </li>
                  <li><a href="s1.3.1.k.html" title="§1.3.1。（k）协变返回类型" class="sect">§1.3.1。（k）</a> ： <strong>协变返回类型</strong><p>在存在隐式和显式继承的情况下协变返回类型的必要约束。
                        					
                     </p>
                  </li>
                  <li><a href="s2.1.2.c.html" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ： <strong>绑定到最终基类</strong><p>已经补充说，绑定到最终基类现在也被视为解封装。
                        					
                     </p>
                  </li>
                  <li><a href="s2.2.f.html" title="§2.2。（f）模糊降低" class="sect">§2.2。（f）</a> ： <strong>模糊降低</strong><p>添加了一个诊断来检测可能意图降低但由于声明的类型是<code>java.lang.而失败的情况<code>java.lang.Object</code> ，这使得潜在的降低翻译变得不必要并且因此是模糊的。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.2.e.html" title="§2.3.2。（e）通用宣布解除" class="sect">§2.3.2。（e）</a> ： <strong>通用声明提升</strong><p>支持将不相关的基类型传递到声明提升的相同方法中。
                        					
                     </p>
                  </li>
                  <li><a href="s2.6.g.html" title="§2.6。（g）通过基准参考进行解封装" class="sect">§2.6。（g）</a> ： <strong>通过基准参考进行解封装</strong><p>将解封装扩展到两个以上的位置。
                        					
                     </p>
                  </li>
                  <li><a href="s4.3.f.html" title="§4.3。（f）基本超级电话" class="sect">§4.3。（f）</a> ： <strong>基本超级呼叫</strong><p>支持base直接调用绑定基本方法的超级版本，从而绕过精确绑定的基本方法以及与此基本方法或其超级版本相关的任何其他callins。
                        					
                     </p>
                  </li>
                  <li><a href="s5.4.b.html" title="§5.4。（b）无副作用" class="sect">§5.4。（b）</a> ： <strong>守卫谓词的副作用</strong><p>将有关未来功能的先前注释迁移到常规段落。</p>
                  </li>
                  <li><a href="s5.4.c.html" title="§5.4。（c）例外情况" class="sect">§5.4。（c）</a> ： <strong>守卫谓词的例外情况</strong><p>澄清从保护谓词抛出的异常的影响。</p>
                  </li>
                  <li><strong>§6.2</strong> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ： <strong>LiftingVetoException</strong><p>添加了大部分内部<code>LiftingVetoException</code>文档以及它如何在客户端代码中实际使用。
                        				    
                     </p>
                  </li>
                  <li><a href="s6.2.e.html" title="§6.2。（e）角色迁移" class="sect">§6.2。（e）</a> ： <strong>角色迁移</strong><p>添加了两个接口，以将迁移功能添加到角色类。
                        				    
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.3">
               <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.2.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a> ：将<strong>角色绑定到基接口</strong><p><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a>中提到的实施限制已被大部分删除。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.1.d.html" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> ： <strong>微调角色实例化</strong><p>已经定义了注释用于修改提升的语义以便提高性能。此外，还添加了一个新的部分作为<a href="s6.3.html" title="§6.3注释" class="sect">§6.3，</a>以总结本文档中定义的注释类型。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ： <strong>解除问题的后果</strong><p>在<a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a>澄清了<code>LiftingFailedException</code> （ <code>LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）确实是一个经过检查的异常之后，又添加了一个子节来定义这种异常在各种程序情况下的后果。
                        					
                     </p>
                  </li>
                  <li><a href="s3.1.k.html" title="§3.1。（k）通用方法的标注" class="sect">§3.1。（k）</a> ： <strong>通用方法的标注</strong><p>添加了关于callout绑定如何引用泛型基本方法的规则。
                        					
                     </p>
                  </li>
                  <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>Callin以“不可授予的”角色进行约束</strong><p>现在甚至可以在“unliftable”角色中定义Callin绑定。
                        	
                     </p>
                  </li>
                  <li><a href="s4.1.h.html" title="§4.1。（h）封闭类的方法" class="sect">§4.1。（h）</a> ： <strong>绑定团队方法</strong><p>callin绑定<code>before</code>和<code>after</code>现在也可以绑定到封闭类的方法。
                        	
                     </p>
                  </li>
                  <li><a href="s4.8.d.html" title="§4.8。（d）多个优先权陈述" class="sect">§4.8。（d）</a> ： <strong>合并优先声明时的顺序</strong><p>阐明了如何合并多个优先级声明，这是未指定的，因为C3算法需要有序输入，但未指定此顺序。
                        					
                     </p>
                  </li>
                  <li><a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ： <strong>在callin绑定中传播类型参数</strong><p>除了捕获协变返回类型之外，callin绑定还可以声明类型参数，以便将通用性从其基本方法传播到角色方法。
                        	
                     </p>
                  </li>
                  <li><a href="s5.3.d.html" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> ： <strong>配置隐式激活</strong><p>添加了用于配置隐式团队激活的机制。默认值已更改为不应用隐式激活。<a href="s5.3.html" title="§5.3隐式团队激活" class="sect">§5.3中</a>也增加了相应的注释</p>
                  </li>
                  <li><a href="s9.2.1.a.html" title="§9.2.1。（a）实例约束类型参数" class="sect">§9.2.1。（a）</a> ： <strong>实例约束类型参数</strong><p>类型锚现在也可以应用于类型参数，从而在类型参数上表达一种新的约束。
                        	
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.4">
               <h4 class="subsect">（4） <span class="title">OTJLD 1.3之后</span><a class="img" href="sB.2.4.html" title="PermaLink至（4）OTJLD 1.3之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s4.1.i.html" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ： <strong>致电建设者</strong><p>绑定后的callin现在也可以应用于基类的构造函数。
                        					
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="sB.1.html" rel="prev">&lt;&lt;§B.1版本之间的段落发生了变化</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>