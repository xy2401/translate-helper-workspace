<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>解析OCL文档</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="PivotProgrammersGuide.html" title="Unified or Pivot Programmers Guide">
<link rel="prev" href="PivotEvaluatingConstraints.html" title="Evaluating Constraints and Queries">
<link rel="next" href="PivotMetamodels.html" title="OCL Relationship to Metamodels">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">解析OCL文档</h1>
<div class="section" title="解析OCL文档">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="PivotParsingDocuments"></a>解析OCL文档</h2>
</div>
</div>
</div>
<p>正如我们在<a class="link" href="PivotParsingConstraints.html" title="解析约束和查询">Parsing Constraints和Queries</a>主题中看到的那样， <a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/utilities/OCL.html" target="_new"><code class="code">OCL</code></a> Facade提供了一个API，用于将嵌入在模型中的OCL表达式解析为约束。
			</p>
<p>OCL规范定义了一个完整的OCL文本文档，通过提供许多互补的约束和表达式，可以用它来完成UML（或Ecore）元模型。在这种情况下，上下文声明的具体语法指示约束的上下文，等同于它们在模型中的位置。</p>
<p>例如，请考虑以下完整OCL文档：</p>
<p>
				
</p>
<div class="mediaobject">
<img src="images/6320-extlibrary.png"></div>
<p>

				
<a class="ulink" href="../references/6320-extlibrary.ocl" target="_new">[剪切和粘贴文本]</a>
			
</p>
<div class="section" title="OCL输入">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLInput2"></a> OCL输入</h3>
</div>
</div>
</div>
<p>Pivot绑定提供UML对齐表示，因此可以解析完整OCL文档以提供与从UML或Ecore元模型派生的资源类似的资源。<code class="code">Root</code>包含一个包含<code class="code">Package</code>和<code class="code">Class</code> es的<code class="code">Model</code> 。来自完整OCL文档的补充资源独立于完成的元模型的类似结构的补充资源。
				</p>
<p>数据透视表绑定使用带有UML对齐输出的Xtext解析器。因此，输入文本由URI指定，并由Xtext解析器加载以创建具体语法资源。然后，可以将其转换为Pivot Abstract Syntax Resource。抽象语法资源具有传统的模型，包，类，操作层次结构，以便为约束提供连贯的组合上下文。</p>
<p>独立互补和补充资源要素内合并<code class="code">CompleteClass</code> ES和<code class="code">CompletePackage</code>的第<code class="code">CompleteModel</code>的OCL门面背后的管理。
				</p>
<p>因此，有两个名为<span class="bold"><strong>Library的</strong></span> <code class="code">Class</code>对象，每个Resource对应一个。对象是不同的，因为它们属于不同的资源，可以单独序列化，并且只要它们看起来与使用反射访问的OCL表达式不同。但是它们在逻辑上合并，并且<code class="code">CompleteEnvironment</code>提供实用程序方法，允许将多个对象作为合并对象进行访问。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>Ecore绑定提供了一个<code class="code">OCLInput</code>类来监督OCL源文本，解析文档的结果是<code class="code">List&lt;Constraint&gt;</code> 。页。
					</p>
</blockquote>
</div>
<p>完整OCL文档是具有关联文本工具的文本资源。<code class="code">OCL</code>外观提供了一个API，用于从给定的<code class="code">URI</code>加载资源。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6320-parsing.png"></div>
<p>

					
<a class="ulink" href="../references/6320-parsing.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
<div class="section" title="遍历约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TraversingtheConstraints"></a>遍历约束</h3>
</div>
</div>
</div>
<p>解析的resurce可以与其他EMF资源相同的方式遍历。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6320-traversing.png"></div>
<p>

					
<a class="ulink" href="../references/6320-traversing.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
<div class="section" title="访问约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="AccessingtheConstraints2"></a>访问约束</h3>
</div>
</div>
</div>
<p>完整OCL文档的内容有助于整合所有贡献的<code class="code">CompleteModel</code> 。因此，可以像在主元模型中定义的那样使用贡献。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6320-accessing.png"></div>
<p>

					
<a class="ulink" href="../references/6320-accessing.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
<div class="section" title="使用约束来验证模型">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="UsingtheConstraintstoValidateaModel"></a>使用约束来验证模型</h3>
</div>
</div>
</div>
<p>标准EMF验证利用一个的<code class="code">EValidatorRegistry</code>该URI映射的的<code class="code">EPackage</code>到派生<code class="code">EValidator</code>提供appilcable到约束<code class="code">EPackage</code> 。如果我们想要利用Complete OCL文档中定义的其他约束，我们必须扩展底层的<code class="code">EValidator</code> 。<code class="code">ComposedValidator</code>允许<code class="code">ComposedValidator</code>多个<code class="code">EValidator</code>并表现为单个<code class="code">EValidator</code> 。
					<code class="code">ComposedEValidator.install()</code>用最初只包含替换的<code class="code">EValidator</code>的复合替换单个<code class="code">EValidator</code> 。<code class="code">CompleteOCLEObjectValidator</code>提供给定<code class="code">uri</code>和<code class="code">EPackage</code>的附加验证。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6320-validating.png"></div>
<p>

					
<a class="ulink" href="../references/6320-validating.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>标准<code class="code">Diagnostician</code>不直接支持<code class="code">Resource</code>验证。

					<code class="code">MyDiagnostician</code>弥补了这一不足，并提供了<code class="code">SubstitutionLabelProvider</code> ，可在OCL诊断中提供稍好的标签。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6320-diagnostician.png"></div>
<p>

					
<a class="ulink" href="../references/6320-diagnostician.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>这些示例的源代码可以在model / parsingDocumentsExample.ocl中的org.eclipse.ocl.examples.xtext.tests插件和src / org / eclipse / ocl / examples / test / xtext / PivotDocumentationExamples.java中找到。</p>
</div>
</div>
</body>
</html>