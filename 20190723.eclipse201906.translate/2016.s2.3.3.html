<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s2.3.2.html" rel="prev">&lt;&lt;§2.3.2宣布解除</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.3.4.html" rel="next">§2.3.4绑定含糊不清&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a> &gt; <a class="nav" href="s2.3.html" rel="section">§2.3提升</a></div>
         <div class="sect depth3" id="s2.3.3">
            <h3 class="sect">§2.3.3智能提升<a class="img" href="s2.3.3.html" title="PermaLinkto§2.3.3智能提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h3>
            <p>在角色和基类是某些继承层次结构（ <code>extends</code> ）的一部分的情况下，在提升期间选择适当的角色类涉及以下规则：</p>
            <div class="subsect depth4" id="s2.3.3.a">
               <h4 class="subsect">（a） <span class="title">静态调整</span><a class="img" href="s2.3.3.a.html" title="永久链接到（a）静态调整"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果一个基类<code>B</code>应该被提升到一个没有绑定到（ <code>R</code> ） <code>playedBy</code>的角色类<code>B</code> ，但是如果一个<code>R</code>的子类 - 比如<code>R2</code> - 被绑定到<code>B</code> ，则提升是静态设置为使用<code>R2</code> ，最通用的子类与<code>R</code>或其超类型之一绑定的<code>B</code>
                  				
               </p>
               <div class="note">
                  <h5>限制：</h5>此步骤不适用于<code>replace</code> callin绑定的参数映射（ <a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ）。
                  				
               </div>
            </div>
            <div class="subsect depth4" id="s2.3.3.b">
               <h4 class="subsect">（b） <span class="title">动态选择角色类</span><a class="img" href="s2.3.3.b.html" title="PermaLink to（b）动态选择角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在运行时，还会考虑基础对象的动态类型：提升总是尝试使用绑定到基础对象的确切类的角色类。提升考虑了由<code>playedBy</code>绑定的所有角色基对，使得角色类是所需（静态声明的）角色类型的子类，并且基类是基础对象的动态类型的超类。
                  			<br>从那些可能的对中，选择最具体的基类。如果将多个角色类绑定到此基类，则会选择这些类中最具体的类。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s2.3.3.c">
               <h4 class="subsect">（c） <span class="title">团队作为封闭的世界</span><a class="img" href="s2.3.3.c.html" title="永久链接到（c）团队作为封闭的世界"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在上面的分析中，所有角色库对都在编译时执行。从下面可以看出，团队类只有在知道所有包含的角色类时才能编译，并且在没有团队的情况下永远不能编译角色类。
                  			<br>分析包括从超级团队继承的所有角色及其绑定。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s2.3.3.d">
               <h4 class="subsect">（d） <span class="title">选择，无论抽象性如何</span><a class="img" href="s2.3.3.d.html" title="永久链接到（d）选择，无论抽象性如何"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>智能提升不受角色类抽象性的影响。有关抽象角色类的效果，请参见<a href="s2.5.html" title="§2.5摘要角色" class="sect">§2.5</a> 。
                  				
               </p>
            </div>
            <h5>复杂的例子：</h5>
            <p><img src="../images/smart_lifting_small.png" alt="智能提升的例子"></p>
            <table border="2" width="80%">
               <colgroup span="1">
                  <col align="left" span="1">
                  <col align="left" span="1">
               </colgroup>
               <tr>
                  <th rowspan="1" colspan="1">角色类</th>
                  <th rowspan="1" colspan="1">基类</th>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">R1级</td>
                  <td rowspan="1" colspan="1"> </td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">class R2扩展了R1 playingBy B2</td>
                  <td rowspan="1" colspan="1">B2级</td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">R3类延伸R2 <em>/ *继承：playingBy B2 * /</em></td>
                  <td rowspan="1" colspan="1">B3级延伸B2</td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">R4级延伸R3播放B4</td>
                  <td rowspan="1" colspan="1">B4类扩展了B3</td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">类R5扩展R4 <em>/ *继承：playingBy B4 * /</em></td>
                  <td rowspan="1" colspan="1"> </td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1"> </td>
                  <td rowspan="1" colspan="1">B6类扩展了B4</td>
               </tr>
               <tr>
                  <td rowspan="1" colspan="1">R7级延伸R5 playBy B7</td>
                  <td rowspan="1" colspan="1">B7类扩展了B6</td>
               </tr>
            </table>
            <div class="codecomment">
               <ul>
                  <li>如果声明需要将<code>B3</code>提升到<code>R1</code>则静态细化以使用<code>R2</code> ，因为这是最通用的类，声明绑定到超级<code>B3</code> 。
                     					
                  </li>
                  <li>如果相同情况下的动态基类型为<code>B6</code> ，则三个步骤选择适当的角色：<ol>
                        <li>通过搜索所有的<code>playedBy</code>子句（包括那些被继承的子句），以下角色库对是候选者：<br><code>(R2,B2), (R3,B2), (R4,B4)</code>和<code>(R5,B4)</code> 。
                        </li>
                        <li>从这些对中选择含有最特定碱基<code>B4</code>两个。
                        </li>
                        <li>这使<code>R4</code>和<code>R5</code>成为候选角色，最终选择最具体的<code>R5</code> 。
                        </li>
                     </ol>
                  </li>
               </ul>
            </div>
            <p>如果给出了所涉及的基类和角色类的继承层次结构（如上图所示），则可以将智能提升算法改写为以下“图形”规则：<br></p>
            <div class="note">从动态基类型（示例中的<code>B6</code> ）开始向上移动继承关系，直到到达绑定到由指向基类（ <code>B4</code> ）的«playingBy»箭头指示的角色类的基类。此角色类必须符合所请求的角色类型。沿此箭头切换到角色一侧（ <code>R4</code> ）。现在向下移动角色继承层次结构，只要子角色不会细化playingBy关系（由另一个«playingBy»箭头指示）。您通过这种方式达到的最低角色（ <code>R5</code> ）是智能提升所选择的角色类型。
               			
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s2.3.2.html" rel="prev">&lt;&lt;§2.3.2宣布解除</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.3.4.html" rel="next">§2.3.4绑定含糊不清&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a> &gt; <a class="nav" href="s2.3.html" rel="section">§2.3提升</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>