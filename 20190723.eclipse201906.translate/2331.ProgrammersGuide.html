<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>经典Ecore / UML程序员指南</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="index.html" title="OCL Documentation">
<link rel="prev" href="OCLInterpreterExample.html" title="OCL Interpreter Example">
<link rel="next" href="EvaluatingConstraints.html" title="Evaluating Constraints and Queries">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">经典Ecore / UML程序员指南</h1>
<div class="chapter" title="经典Ecore / UML程序员指南">
<div class="titlepage">
<div>
<div>
<h2 class="title">
<a name="ProgrammersGuide"></a>经典Ecore / UML程序员指南</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt>
<span class="section"><a href="ProgrammersGuide.html#ParsingConstraints">解析约束和查询</a></span>
</dt>
<dt>
<span class="section"><a href="EvaluatingConstraints.html">评估约束和查询</a></span>
</dt>
<dt>
<span class="section"><a href="ParsingDocuments.html">解析OCL文档</a></span>
</dt>
<dt>
<span class="section"><a href="TargetMetamodels.html">OCL与元模型的关系</a></span>
</dt>
<dt>
<span class="section"><a href="ContentAssistSupport.html">内容辅助支持</a></span>
</dt>
<dt>
<span class="section"><a href="AbstractSyntax.html">OCL抽象语法模型</a></span>
</dt>
<dt>
<span class="section"><a href="CustomizingtheEnvironment.html">自定义环境</a></span>
</dt>
<dt>
<span class="section"><a href="Persistence.html">OCL持久性</a></span>
</dt>
<dt>
<span class="section"><a href="AdvancedMetamodelBindings.html">创建元模型绑定</a></span>
</dt>
<dt>
<span class="section"><a href="ImpactAnalyzer.html">使用Impact Analyzer逐步重新评估OCL表达式</a></span>
</dt>
<dt>
<span class="section"><a href="Delegates.html">代表</a></span>
</dt>
<dt>
<span class="section"><a href="Standalone.html">Ecore / UML独立配置</a></span>
</dt>
</dl>
</div>
<p>Ecore / UML程序员指南描述了可以从Java程序中使用Eclipse OCL的Ecore或UML绑定的方式。</p>
<p>自Eclipse OCL 1.0.0（Callisto）以来，Ecore绑定已经可用。UML绑定在1.1.0（Europa）中添加。两者都将在必要时保留。新的UML对齐的Pivot绑定的示例质量原型首先在3.1.0（Indigo）中提供。Pivot结合成为6.0.0（Mars）中的首选结合。Pivot绑定在单独的<a class="link" href="PivotProgrammersGuide.html" title="Unified或Pivot程序员指南">Pivot程序员指南中</a>描述。
		</p>
<p>OCL解析器/解释器为基于EMF的元模型和模型提供了<a class="ulink" href="http://www.omg.org/spec/OCL" target="_new">对象约束语言2.4</a>规范的实现。它提供OCL约束和查询解析和评估，基于模型的验证，并为文本编辑器中的内容辅助提供基础结构。
		</p>
<p>当前版本支持以下功能：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>分类器不变约束</p>
</li>
<li class="listitem">
<p>操作前提条件和后置条件约束和身体状况</p>
</li>
<li class="listitem">
<p>属性约束（初始值和派生）</p>
</li>
<li class="listitem">
<p>属性和操作定义（def：表达式）</p>
</li>
<li class="listitem">
<p>包上下文声明</p>
</li>
<li class="listitem">
<p>基本价值观和类型</p>
</li>
<li class="listitem">
<p>集合类型</p>
</li>
<li class="listitem">
<p>属性和关联的导航结束</p>
</li>
<li class="listitem">
<p>操作调用</p>
</li>
<li class="listitem">
<p>迭代表达式（所有标准迭代器）</p>
</li>
<li class="listitem">
<p>让表达</p>
</li>
<li class="listitem">
<p>如果表达</p>
</li>
<li class="listitem">
<p>元组</p>
</li>
<li class="listitem">
<p>消息表达式，包括未指定的值</p>
</li>
<li class="listitem">
<p>OCL预定义的操作：allInstances（），oclIsKindOf（），oclIsTypeOf（），oclAsType（），oclIsNew（）</p>
</li>
<li class="listitem">
<p>非法名称的转义语法：类型，操作，属性等与OCL保留字对应的名称可以使用前导下划线（'_'）以标准方式转义。此外，包含空格或制表符的名称可以通过用双引号括起来进行转义（'“';这是非标准的）。例如， <code class="code">self.ownedRule-&gt;forAll(c : Constraint | c._context = self)</code>
				
</p>
</li>
</ul>
</div>
<p>解析器支持上述结构进行解析和评估，但oclIsNew（）操作和消息表达式除外。Ecore和UML模型都支持以上所有功能。UML默认支持以下内容（解析和评估）：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>不可导航关联的导航结束（包括该关联拥有的那些）</p>
</li>
<li class="listitem">
<p>合格的协会结束导航</p>
</li>
<li class="listitem">
<p>导航到关联类，包括源限定符</p>
</li>
<li class="listitem">
<p>OCL预定义的操作：oclIsInState（）</p>
</li>
</ul>
</div>
<p>除OCL规范外，还提供以下功能：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>字符串大小写转换操作：toUpper（），toLower（）</p>
</li>
<li class="listitem">
<p>支持比较（&lt;，&lt;=等）和排序符合类型的任何java <code class="code">Comparable</code></p>
</li>
<li class="listitem">
<p>关联的传递闭包：closure（expr：OCLExpression）迭代器</p>
</li>
<li class="listitem">
<p>使用<code class="code">Property.oppositeRoleName</code>注释在前向引用上使用源<code class="code">http://schema.omg.org/spec/MOF/2.0/emof.xml</code>导出Ecore模型中指定的引用的“隐藏”对立，生成<code class="code">OppositePropertyCallExp</code>表达式</p>
</li>
</ul>
</div>
<p>OCL实现在插件中定义，以便在Eclipse中进行部署，但与EMF的情况一样，它也可以单独使用。插件因此被分区：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl</code> ：核心解析，评估和内容辅助服务。OCL抽象语法模型和环境API的定义。这些API是通用的，独立于任何特定的元模型（尽管使用Ecore / EMF作为元元模型）。
				</p>
</li>
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl.ecore</code> ：Ecore元模型环境的实现，将通用环境和AST API绑定到Ecore语言。为使用OCL约束和针对Ecore模型的查询提供支持。
				</p>
</li>
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl.uml</code> ：UML元模型环境的实现，将通用环境和AST API绑定到UML语言。为使用针对UML模型的OCL提供支持。
				</p>
</li>
</ul>
</div>
<p>请参阅<a class="link" href="OCLInterpreterTutorial.html" title="使用经典OCL">OCL口译员教程</a>以查看代码示例。
		</p>
<div class="section" title="解析约束和查询">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="ParsingConstraints"></a>解析约束和查询</h2>
</div>
</div>
</div>
<p>OCL解析器提供了两个用于解析约束和查询表达式的API。<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html" target="_new"><code class="code">OCLHelper</code></a>接口主要用于解析嵌入在模型中的约束和查询表达式，例如Ecore或UML模型。<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html" target="_new"><code class="code">OCL</code></a>类充当解析API的主要入口点，但也实现了对<a class="link" href="ParsingDocuments.html" title="解析OCL文档">OCL文档</a>的解析，例如从文本文件中解析。在这两种情况下， <code class="code">Environment</code>概念都至关重要。
			</p>
<div class="section" title="OCL环境">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLEnvironment"></a> OCL环境</h3>
</div>
</div>
</div>
<p>下图显示了<code class="code">Environment</code> API的核心，OCL解析器的客户端与之交互：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-environment.png"></div>
<p>
				
</p>
<p><a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html" target="_new"><code class="code">OCL</code></a>类是泛型类型;它的类型参数表示OCL在OMG规范的UML / MOF系列中使用的元模型的各种元类。例如， <code class="code">&lt;C&gt;</code>表示分类器概念， <code class="code">&lt;O&gt;</code>操作概念等。有关映射的详细信息，请参阅<a class="link" href="TargetMetamodels.html" title="OCL Relationship to Metamodels">OCL支持</a>的<a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">元模型</a>的讨论。在整个OCL API中始终使用相同类型的参数名称来表示相同的元类。
				</p>
<p><code class="code">OCL</code>类定义自治OCL解析和评估环境的实例。它具有由<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/EnvironmentFactory.html" target="_new"><code class="code">EnvironmentFactory</code></a>实现为特定的基于EMF的元模型创建的单个根<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Environment.html" target="_new"><code class="code">Environment</code></a> 。从概念上讲，OCL环境包括要与所有约束以及为了制定约束而定义的附加操作和属性（通过OCL）一起约束的模型。
				</p>
<p>
					
<code class="code">Environment</code>的巢。通常根环境具有在模型中没有相关性的元素，或者其可对应于一些<code class="code">Package</code>中提供默认名称空间（称为包上下文）。或者，它可以包含一个或多个定义包命名空间的嵌套环境。包上下文包含一个或多个分类器上下文，而这些上下文又可以包含操作和/或属性上下文。虽然包上下文的目的主要是帮助查找命名模型元素，但分类器，操作和属性上下文具有更深层的含义。
				</p>
<p>分类器上下文定义OCL约束和查询中的<code class="code">self</code>变量的类型。就其本身而言，它是上下文分类器的不变约束的上下文。另外，作为操作和属性约束的父上下文，它指示应用操作或属性约束的上下文的分类器;这可能是定义这些特征的分类器，或者它可以从一些更通用的分类器继承它们。
				</p>
<p><code class="code">Environment</code>可以包含OCL表达式可以引用的命名<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/expressions/Variable.html" target="_new"><code class="code">Variable</code></a> 。其中最常见的是<code class="code">self</code> 。其他包括在操作上下文的情况下由操作（及其<code class="code">result</code> ）定义的参数。OCL API甚至允许客户端在代码中添加变量来定义“全局”名称。
				</p>
</div>
<div class="section" title="创建OCL环境">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CreatinganOCLEnvironment"></a>创建OCL环境</h3>
</div>
</div>
</div>
<p><code class="code">OCL</code>类上的静态工厂方法用于创建实例。在加载该模型时（通常在编辑器中的某些<code class="code">ResourceSet</code>中）重复使用相同的OCL实例来对模型上的约束和查询进行所有解析和评估是一种很好的做法。使用Ecore <a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">元模型</a>的共享环境工厂，我们可以创建一个适合在任何Ecore模型上解析OCL约束并在模型实例上评估它们的OCL环境：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-creating.png"></div>
<p>

					
<a class="ulink" href="../references/5110-creating.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p><code class="code">OCL</code>泛型类型签名中的几个类型参数主要在OCL API中很有用。我们把它们留在这里作为通配符。
				</p>
</div>
<div class="section" title="OCL助手">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLHelper"></a> OCL助手</h3>
</div>
</div>
</div>
<p>在OCL实例中，我们可以创建一个辅助对象，用于解析约束和其他操作/属性定义。此<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html" target="_new"><code class="code">OCLHelper</code></a>存储OCL模板元类的所有实例（例如<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/types/CollectionType.html" target="_new"><code class="code">CollectionType(T)</code></a>和<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/types/TupleType.html" target="_new"><code class="code">TupleType</code></a>以及在创建它的<code class="code">OCL</code>的根环境中的其他操作/属性定义。这可确保所有这些构造都可用于后续解析。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-oclhelper.png"></div>
<p> 
				
</p>
<p><code class="code">OCLHelper</code>主要用于解析模型中嵌入的约束和查询表达式，为此提供以下API：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">createQuery()</code> ：解析查询表达式</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createConstraint()</code> ：解析给定<code class="code">ConstraintKind</code>
						
</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createInvariant()</code> ：不变约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createPrecondition()</code> ：前置条件约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createPostcondition()</code> ：后置条件约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createBodyCondition()</code> ：方便身体状况</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createInitialValueExpression()</code> ：属性初始值的便利</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createDerivedValueExpression()</code> ：属性派生值的便利</p>
</li>
<li class="listitem">
<p>
							
<code class="code">defineOperation()</code> ：其他操作定义的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">defineAttribute()</code> ：其他属性定义的便利性</p>
</li>
</ul>
</div>
<p>不同类型的约束需要不同的上下文环境。<code class="code">setContext()</code> ， <code class="code">setOperationContext()</code>和<code class="code">setAttributeContext()</code>方法<code class="code">Environment@s in the host @OCL</code>实例的根环境中创建适当的嵌套<code class="code">Environment@s in the host @OCL</code> 。
				</p>
<p>解析查询表达式的结果是<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/expressions/OCLExpression.html" target="_new"><code class="code">OCLExpression</code></a> ，它是<a class="link" href="AbstractSyntax.html" title="OCL抽象语法模型">抽象语法模型的</a>一个实例。解析约束的结果是由<code class="code">OCL</code>的<a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">目标元模型</a>定义的<code class="code">Constraint</code>元类的实例。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-context.png"></div>
<p>

					
<a class="ulink" href="../references/5110-context.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>Ecore没有定义<code class="code">Constraint</code>元类，因此Ecore的OCL <a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">绑定</a>提供了一个。
				</p>
</div>
<div class="section" title="操作和属性上下文">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OperationandAttributeContexts"></a>操作和属性上下文</h3>
</div>
</div>
</div>
<p>在对操作或属性的约束的情况下，上下文由两个元素组成：约束操作/属性和要应用约束的上下文中的分类器。这解释了分类器定义对继承特征的约束的可能性。作为示例，请考虑Ecore元模型中的<code class="code">EModelElement::getEAnnotation(EString)</code>操作和<code class="code">EReference::eReferenceType</code>属性。这些可以限制如下：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-define.png"></div>
<p>

					
<a class="ulink" href="../references/5110-define.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
</div>
</div>
</body>
</html>