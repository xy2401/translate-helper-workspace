<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>表</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css">
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css">
	</head>
	<body >
		<h1 id="SpecifyingTableEditors">指定表编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingTableEditors">指定表编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#edition_tables">版表</a>
						<ol style="list-style:disc">
							<li>
								<a href="#table_tools">表工具</a>
							</li>
							<li>
								<a href="#line_mappings">线映射</a>
							</li>
							<li>
								<a href="#feature_column_mapping">特征列映射</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#cross_tables">交叉表</a>
						<ol style="list-style:disc">
							<li>
								<a href="#cross_table_tools">表工具</a>
							</li>
							<li>
								<a href="#element_column_mapping">元素列映射</a>
							</li>
							<li>
								<a href="#intersection_mapping">交点映射</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>Sirius支持两种表格建模器的定义：</p>
		<ul>
			<li>
				<em>版本表</em>是经典表格，其中每一行代表一个元素，每一列（来自固定集合）代表元素的某些（可能计算的）属性。行可以包含子行（递归地）来表示子元素，最终用户可以随意展开/折叠它们。如果您指定相应的工具，用户可以创建新行并删除现有行。
			</li>
			<li>
				<em>交叉表</em>略有不同，经过优化，以类似矩阵的方式表示元素之间的关系。行和列都表示元素，如果它们之间存在某种关系，则每个调用在交叉点。交叉表也支持子行，但不支持子列。但是，如果指定了正确的工具，则除了行之外，用户还可以创建和/或删除列。
			</li>
		</ul>
		<p>这两种表共享很多元素。本文档将重点介绍最常用的<a href="#edition_tables">编辑表</a> 。<a href="#cross_tables">关于交叉表</a>的<a href="#cross_tables">部分</a>根据它们与编辑表的不同来描述它们。
		</p> 
		<img border="0" src="./images/table_description_editor.png">
<em>
<ul>
<img src="images/tricks.png" style="display:inline;margin:0px;padding:0px"> <em>使用<img src="images/questionMarque.png" style="display:inline;margin:0px;padding:0px">用于访问可用字段工具提示的图标：</em>
<ul>
			<li> 
		<b>Id</b>字段：此元素的标识符。必须是独特的。更改此标识符将破坏引用旧标识符的现有用户模型。</li>
			<li> 
		<b>标签</b>字段：用于向最终用户显示此标签的标签。</li>
			<li> 
		<b>域类</b>字段：节点表示的元素的类型。</li>
			<li> 
		<b>Semantic Candidates Expression</b>字段：在创建图形元素之前限制要考虑的元素列表。如果未设置，则将浏览会话中的所有语义模型，并且验证前提条件表达式的给定类型的任何元素将导致创建图形元素。如果设置此属性，则仅考虑表达式求值返回的元素。</li>
</ul>
</ul>
</em>
		<p>
			<strong>注意</strong> ：图表中存在的图层，过滤器和映射导入等高级功能目前不适用于表。
		</p>
		<h2 id="edition_tables">版表</h2>
		<p>通过创建<em>版本表描述</em>元素（在<em>视点内</em> ）及其子元素（描述行，列和工具）来配置<em>版本表</em> 。
			<em>版本表描述</em>类似于其他表示描述元素。
		</p>
		<p>强制<em>Domain Class</em>属性是由表表示的语义元素的类型。在<em>模型资源管理器中</em> ，最终用户将能够在此类型的语义元素上创建此表的新实例（假设在<em>建模项目中</em>启用了相应的视点）。域类名称的语法可以是基本名称，如<code>Class</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml.Class</code> ，或完全限定的URI，如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Class</code> 。</p>
		<p>默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新表。您可以使用“ <em>前置条件表达式”</em> （在“ <em>高级”</em>类别中可用）来更改此值。如果指定了这样的表达式，则将在用户选择的语义元素的上下文中对其进行求值，并且仅当表达式返回<code>true</code>时，用户才能够在此元素上创建新表。
		</p>
		<p>可以使用<em>Title表达式</em> （ <em>Advanced</em> category）指定新创建的表的默认标题，该<em>表达式</em>在创建表的语义元素的上下文中进行评估，并应返回一个字符串。如果未指定表达式，则默认标题是表描述的标签（如果未设置<em>标签，</em>则为其<em>ID</em> ），前缀为字符串<code>"new "</code> （例如， <code>new Package Contents</code> ）。
		</p>
		<p>建议将<em>版本表描述</em>明确地与它将表示的语义元素的元模型相关联。您可以在<em>Edition Table Description</em>的<em>Metamodels</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p><em>启动</em>标志<em>上</em>的<em>初始化</em>和<em>显示</em>控制是否在没有用户干预的情况下自动创建和/或打开表实例。如果设置了<em>Initialization</em> ，则当启用包含此表描述的视点时，将在所有兼容的语义元素上自动创建此表描述的实例。如果在set中<em>启动</em>时<em>显示</em> ，那么当打开包含此表描述实例的建模项目时，它们将被打开：如果只存在一个这样的表示，它将自动打开;如果有多个，将出现一个对话框，允许用户选择打开哪一个。
		</p>
		<p>最后， <em>初始标题列宽</em> （ <em>高级</em>类别）特定于表描述（版本表和交叉表）。它可用于指定表格最左侧列的默认大小（以像素为单位），其中包含每行所代表的元素的标签。如果值为0（默认值），则将在创建表时从初始内容计算列宽。对于版本表，如果值为-1，则隐藏标题列。在交叉表的情况下，-1值具有与0值相同的行为。
		</p>
		<h3 id="table_tools">表工具</h3>
		<p>适用于整个表的一些工具直接在<em>版本表描述</em>中指定：</p>
		<ul>
			<li>
				<em>表示创建工具</em> ：这些工具（Sirius支持的每种表示形式之一）可用于从现有表元素创建（和打开）新表示。它将在兼容表元素的<em>Navigate</em>上下文菜单中供最终用户使用。要配置工具，只需在<em>Mappings</em>属性中选择工具应显示的哪些行（如果需要，可以使用<em>Precondition</em>表达式更精确），并选择应使用<em>Representation Description</em>属性创建的<em>表示类型</em> （在实践中， <em>图表描述</em> ， <em>表描述</em>或<em>树描述之一</em>取决于工具）。通常，将在由用户调用该工具的树项所表示的语义元素上创建新表示。有时您希望工具出现在一个元素上，但在另一个元素上创建一个表示。在这种情况下，使用“ <em>浏览”表达式</em> （在“ <em>高级”</em>类别中）从所选元素导航到实际应创建新表示的元素。最后，在调用工具时，将执行您在工具正文中指定的任何操作;您可以使用它来初始化所表示的模型的内容。
			</li>
			<li>
				<em>表示导航工具</em> ：这些工具（Sirius支持的每种表示形式的工具）与之前的工具非常相似。唯一的区别是它们允许用户导航到现有的表示而不是创建新的表示。如果存在此类工具，则元素上的“ <em>导航”</em>上下文菜单将包含已在所选元素上存在的每个对应表示的条目（或者可以使用“ <em>浏览”表达式</em>从所选元素访问）。您可以指定要在菜单项中使用的<em>导航名称表达式</em> （ <em>高级</em>类别），而不是使用现有表示的标题。这有助于更明确地说明当前元素与目标树之间的关系。
			</li>
			<li>
				直接包含在<em>表描述</em>中的<em>行创建工具</em>用于创建根表行。它们通过主Eclipse工具栏中的组合按钮提供给最终用户。要配置它，只需选择工具将在<em>Mapping</em>属性中创建的行类型，并使用常规模型操作指定工具的行为。
			</li>
		</ul>
		<h4 id="tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h3 id="line_mappings">线映射</h3>
		<p>将出现在表中的行（及其在子行中的组织）由<em>表描述</em>元素内的<em>行</em>映射元素定义。<em>表描述</em>包含<em>行</em>映射，它定义哪些元素将显示为表的顶级行，而每个<em>行</em>映射可以包含定义其自己的直接子行的子映射。如果元素（表或行映射）包含多个子映射，则元素的内容将按映射的顺序出现：首先是第一个映射的所有实例，然后是第二个映射的实例，等等。</p>
		<p><em>线</em>映射由<em>域类</em>和<em>语义候选表达式定义</em> 。<em>语义候选表达式</em>指示在语义模型中查找应该由映射表示的元素的位置。表达式在父语义元素的上下文中进行计算（父表是表本身或父行）。它应该返回一组语义元素。只保留那些属于指定<em>域类</em>的实例，并将其实际表示为此映射的实例。因此与每一行相关联的语义元素称为行的<em>目标</em>元素。
		</p>
		<p>您可以通过定义<em>关联元素表达式</em> （在<em>高级类别中</em> ）将更多语义元素关联到一行，该<em>关联元素表达式</em>在目标上下文中进行评估，并且可以返回更多语义元素。目标元素或其中一个关联元素的任何更改都将自动触发该行的刷新。
		</p>
		<p><em>标题标签表达式</em> （在<em>标签</em>类别中）在行的目标上下文中进行评估，并且应该返回标题列（在表的左侧）中为该行显示的文本。
		</p>
		<p><em>线</em>映射可以<em>重用子线</em> （参见<em>导入</em>类别），包括其自身，作为子映射。效果与将重用的映射创建为子节点（如果父节点）的效果完全相同。但是，因为映射可以重用自身或其父映射之一，所以这允许创建无限深度的表（或者至少不是先验的有界）。“ <em>在映射中重用”</em>属性是“ <em>重用子行”</em>的对称：它显示哪些行映射将此一行重用为子行。
		</p>
		<h4 id="line_style">线条样式</h4>
		<p>您可以在线条映射内创建<em>样式</em>元素，以设置此行上所有单元格的默认样式（请注意，此样式会覆盖列映射一个）。
		</p>
		<p><em>Foreground Style</em>元素可用于设置字体大小，字体样式（例如斜体）和文本颜色。<em>背景样式</em>可用于设置背景颜色。两者都是可选的。
		</p>
		<p>您还可以为前景指定<em>条件样式</em> 。每个都是包含在谓词表达式中的正常前景样式（在行的语义元素的上下文中计算）。如果指定了条件样式，则按顺序测试它们的条件，并使用匹配的第一个条件。如果未定义条件样式，则应用<em>前景样式</em> （或默认值）。
		</p>
		<h4 id="line_tools">线工具</h4>
		<p>可以在线映射内创建两种工具（并应用于该映射的所有实例）。</p>
		<ul>
			<li>
				<em>创建线工具</em>用于创建新线。映射可以包含几个这样的工具。如果工具的（可选） <em>前提条件</em>适用于实例的目标，它们将出现在映射实例的上下文菜单中。创建工具必须指定它将创建的<em>映射</em>类型。使用所有标准模型操作，在工具的主体中定义创建工具的实际行为。
			</li>
			<li>
				<em>删除行工具</em> ，用于删除元素。如果行映射未明确定义删除工具，则<em>删除行</em>操作的默认行为是从语义模型中删除行的语义<em>目标</em>和所有<em>关联元素</em> 。如果需要特定行为，则必须显式创建“ <em>删除行工具”</em>并描述工具主体中的行为。如果要防止删除元素，则必须创建“ <em>删除行工具”</em>并将“ <em>前提条件”</em>设置为对不应删除的元素返回<code>false</code> 。
			</li>
		</ul>
		<h3 id="feature_column_mapping">特征列映射</h3>
		<p>将出现在编辑表中的<em>列</em>由“ <em>表描述”</em>元素内的“ <em>特征列”</em>映射元素定义。它们被命名为<em>Feature Column</em>映射，因为它们通常表示由表的行表示的元素的属性（可能是计算的），并且还将它们与<a href="#cross_tables">交叉表</a>中出现的列类型区分开来。
		</p>
		<p><em>特征列</em>映射由其<em>特征名称</em>定义，该<em>特征名称</em>通常应该是表格行中出现的元素的有效特征（属性或参考）的名称。如果一行表示语义元素<em>S1，</em>但您希望某些列显示可从<em>S1</em>而不是<em>S1</em>本身到达的元素的属性，则可以使用在<em>S1</em>的上下文中评估的<em>要素父表达式</em> （ <em>高级</em>类别）。应该返回一个元素<em>S2</em> 。
			<em>S2</em>将被视为该交叉点处的单元的<em>目标</em>元素而不是<em>S1</em> 。
		</p>
		<p>您可以使用“ <em>高级”</em>类别中的“ <em>关联元素”表达式</em>将更多语义元素与映射<em>关联</em> 。表达式将在单元格的目标语义元素的上下文中进行评估。
		</p>
		<p><em>标签表达式</em>用于计算要在每个单元格中显示的文本。在其目标语义元素的上下文中评估每个单元格。如果为EClass没有公共EStructuralFeatures（继承或具有相同名称）的元素计算文本，则可以使用<code>*</code>作为<em>功能名称</em>在单元创建期间跳过功能名称验证。
		</p>
		<p>在表格中，默认情况下，单元格的内容是可编辑的。即使没有指定直接编辑工具，Sirius也会尝试根据列所代表的要素类型（由<em>功能名称</em>定义）来解释用户输入的文本。例如，如果列表示布尔属性，则Sirius将正确解释字符串<code>"true"</code>和<code>"false"</code>并在用户编辑单元格时相应地设置值。您可以通过提供<em>Can Edit</em>表达式来禁用此行为，该表达式在每个单独单元格的语义元素的上下文中进行评估。如果该单元格不可编辑，则应返回<code>false</code> 。
		</p>
		<p>最后， <em>标题标签表达式</em>用于计算列本身的标题，并在表的目标语义元素的上下文中进行评估， <em>初始宽度</em> （如果设置为非零值）用作初始宽度列。
		</p>
		<h4 id="column_styles">列样式</h4>
		<p>列可以包含样式定义，以设置这些列上所有单元格的样式。但是，这些样式可以被样式覆盖，这些样式可能存在于此列单元格的行映射中。样式定义元素（包括对条件样式的支持）与与行映射关联的样式相同。有关更多详细信息，请参阅<a href="#line_style">相应部分</a> 。
		</p>
		<h4 id="column_tools">列工具</h4>
		<p>列当前只能定义<em>标签编辑</em>工具，该工具将应用于列的所有单元格。它像所有编辑一样工作<em>编辑蒙版</em>元素（包含在工具中）用于解析用户输入的新标签的值，并选择此标签的一部分作为编辑操作主体的输入变量。掩码可以包含<code>{N}</code>形式的子串，其中<em>N</em>是数字。与这些子字符串对应的新标签值的部分将作为名为<code>argN</code>变量提供。例如，使用编辑掩码<code>{0}:{1}</code>和由<code>attr : EString</code>用户输入的输入字符串，工具的主体将执行变量<code>arg0</code>设置为<code>attr&#9251;</code> ， <code>arg1</code>设置为<code>&#9251;EString</code> 。
		</p>
		<h2 id="cross_tables">交叉表</h2>
		<p>
			<em>交叉表</em>与版本表略有不同。它们经过优化，以类似矩阵的方式表示元素之间的关系。行和列都表示元素，如果它们之间存在某种关系，则每个调用在交叉点。交叉表也支持子行，但不支持子列。但是，如果指定了正确的工具，则除了行之外，用户还可以创建和/或删除列。
		</p>
		<p>使用“ <em>交叉表描述”</em>元素指定<em>交叉表</em> ，该元素与“ <a href="#edition_tables"><em>版本表描述”</em></a>元素完全相同。差异出现在它们可以包含的元素类型中。
		</p>
		<h3 id="cross_table_tools">表工具</h3>
		<p>交叉表可以包含与编辑表相同的工具（有关详细信息，请参阅<a href="#table_tools">相应的部分</a> ）。此外，它们可以包含“ <em>创建列工具”</em> ，其行为与“ <em>创建行”</em>工具完全相同，只是它们适用于“ <a href="#element_column_mapping"><em>元素列”</em>映射</a> （请参阅下文），并用于在表中创建新列。
		</p>
		<h4 id="cross_table_tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h3 id="element_column_mapping">元素列映射</h3>
		<p>在交叉表中，列表示元素而不是元素的属性（与编辑表的情况一样）。列集由一个或多个<em>元素列</em>映射定义。它们与<a href="#line_mappings">行映射</a>几乎完全相同，除了：</p>
		<ul>
			<li>它们不能嵌套（没有像子行那样的“子列”），因此也不能“重用”列映射;</li>
			<li>它们可以具有<em>初始宽度</em> （在“ <em>高级”</em>类别中设置）。
			</li>
		</ul>
		<p>
			<em>元素列</em>映射可以包含“ <em>创建列工具”</em>和“ <em>删除列工具”</em> ，这些<em>工具</em>的指定和行为方式与<em>创建行</em>和<em>删除行</em> <a href="#line_tools">工具</a>类似， <a href="#line_tools">用于行映射</a> 。
		</p>
		<p>它们还可以包含样式定义（包括条件样式），它们适用于列中的所有单元格（除非被交集映射或行映射（如果有）覆盖）。</p>
		<h3 id="intersection_mapping">交点映射</h3>
		<p>交叉表中的行和元素列映射定义表中将显示哪些行和列，但不定义单元格的内容。这由<em>交叉点</em>映射定义。“ <em>线条映射”</em>和“ <em>列映射”</em>属性指示映射描述的单元格。在单元格的目标语义元素的上下文中评估的<em>标签表达式</em>应返回要在单元格中显示的文本，而“ <em>可编辑”</em>表达式指示最终用户是否<em>可以编辑</em>单元格的值。
		</p>
		<p>交集映射有两种略有不同的用例，它们使用剩余属性的不同子集：</p>
		<ol>
			<li>交点，表示一行上的元素与列上的元素之间的关系。例如，如果行和列都表示UML类，那么这可能是类与它继承的类之间的“超类”引用;</li>
			<li>表示语义元素（而不仅仅是关系）的交集，它本身与行上的元素和列上的元素相关。要继续使用UML示例，这将用于表示UML关联，它们是表示类之间关系的完整对象。</li>
		</ol>
		<p>如果您熟悉它，这类似于Sirius图中的<em>基于</em> <em>关系的边</em>和<em>基于元素的边</em> 。
		</p>
		<p>在第一种情况下（“基于关系的交集”），单元格的语义元素将是单元格行的语义元素。要配置这样的交集，您必须只设置<em>列查找器表达式</em> ：从行的语义目标元素，它应该返回单元格应该出现的列的语义元素。
		</p>
		<p>通过在“ <em>基于</em> <em>域的”类别中</em>设置“ <em>使用域类”</em>标志来启用第二个用例（“基于元素的交集”）。然后，您必须指出将由单元格表示的元素的<em>Domain Class</em> ，以及<em>Semantic Candidates Expression</em> 。表达式将在整个表的语义元素的上下文中进行计算，并应返回应由单元格表示的所有元素（ <em>Domain类的</em>实例）。这些元素将是单元格的语义目标元素。您可以使用<em>前置表达式</em>和<em>关联元素表达式</em> （ <em>高级</em>类别），其语义与其他映射相同。最后，您必须同时设置<em>Column Finder Expression</em> （ <em>常规</em>类别）和<em>Line Finder Expression</em> （ <em>基于域的</em>类别）：它们都将在单元格的语义元素的上下文中进行评估，并且应该返回列和行的语义元素应该出现交叉点。在我们的示例中，这些表达式是从<em>Association</em>元素中查找<em>关联</em>的源类和目标类的表达式。
		</p>
		<h4 id="intersection_mapping_style">交叉风格</h4>
		<p><em>交点</em>映射可以包含样式元素，包括条件样式。如果它们存在，则它们将覆盖相应列映射或线映射上设置的任何样式。
		</p>
		<h4 id="intersection_mapping_tools">交叉口工具</h4>
		<p>交叉点映射可以包含两种工具：</p>
		<ul>
			<li>
				<em>标签编辑</em>工具是标准的“直接编辑”工具，允许最终用户编辑单元格的标签。您可以在工具主体中指定模型中的实际更改。
			</li>
			<li>
				当用户编辑最初为空的单元格时，将使用“ <em>创建单元格工具”</em> ，其中行和列没有关系（或元素相关）。它被定义为<em>标签编辑</em>工具（带有<em>编辑掩码变量</em>以获取用户输入的文本），但它不应编辑现有关系，而应创建关系（例如，将列中的类添加为超类到线上的那个）或与线和列相关的元素（例如创建一个链接类的<em>关联</em> ）。
			</li>
		</ul>
	</body>
</html>