<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>图</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css">
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css">
	</head>
	<body >
		<h1 id="SpecifyingDiagramEditors">指定图编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingDiagramEditors">指定图编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#diagram_description">图说明</a>
						<ol style="list-style:disc">
							<li>
								<a href="#layout">布局配置</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#layers_graphical_elements">图层和图形元素</a>
						<ol style="list-style:disc">
							<li>
								<a href="#layers">图层</a>
							</li>
							<li>
								<a href="#graphical_elements">图形元素和映射</a>
							</li>
							<li>
								<a href="#nodes">节点</a>
							</li>
							<li>
								<a href="#containers">集装箱</a>
							</li>
							<li>
								<a href="#bordered_nodes">有边界的节点</a>
							</li>
							<li>
								<a href="#edges">边缘</a>
							</li>
							<li>
								<a href="#decorations">饰</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#styling">造型</a>
						<ol style="list-style:disc">
							<li>
								<a href="#conditional_styles">条件样式</a>
							</li>
							<li>
								<a href="#label_style">标签属性</a>
							</li>
							<li>
								<a href="#size">尺寸属性</a>
							</li>
							<li>
								<a href="#colors">颜色</a>
							</li>
							<li>
								<a href="#authorizedsides">授权双方</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#tools">工具</a>
						<ol style="list-style:disc">
							<li>
								<a href="#tools_organization">工具组织</a>
							</li>
							<li>
								<a href="#tools_specification">工具规范</a>
							</li>
							<li>
								<a href="#tools_reference">工具参考</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#filters">过滤器</a>
						<ol style="list-style:disc">
							<li>
								<a href="#mapping_filter">映射过滤器</a>
							</li>
							<li>
								<a href="#variable_filter">可变过滤器</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#validation">验证规则</a>
					</li>
					<li>
						<a href="#extensibility">图表可扩展性功能</a>
						<ol style="list-style:disc">
							<li>
								<a href="#diagram_extension">图表扩展</a>
							</li>
							<li>
								<a href="#mapping_imports">映射导入</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#customization">图表样式自定义</a>
						<ol style="list-style:disc">
							<li>
								<a href="#enum_customization">样式自定义Enumerator属性</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>Sirius支持复杂图形建模器的定义，支持许多功能，如过滤器，图层，拖放，复杂样式等。</p>
		<p>图表支持几种图形构造：简单节点，容器（可以包含其他节点或容器），列表，边界节点（出现在其他元素一侧的节点，通常表示端口），以及所有这些节点之间的边缘。每种元素都支持丰富的可能样式（形状和颜色）。</p>
		<p>天狼星图的说明符，您对如何在你的语义模型的元素使用由天狼星提供的结构<em>代表</em> ，以及它们是如何<em>表现</em>的完全控制。特别地，这意味着图上所示的图形元素的结构（哪个元素包含它们，它们如何连接）不必与所表示的语义模型的“物理”结构相匹配。这两者是完全去相关的，您可以选择以从各种观点来看有意义的方式表示您的语义模型。
		</p>
		<h2 id="diagram_description">图说明</h2>
		<p>通过创建<em>Diagram Description</em>元素（在<em>Viewpoint内</em> ）及其子元素（描述图层，图形元素和工具）来配置图表。
		</p>
		<p>与<a href="../../Glossary.html#VSM"><em>VSM中的</em></a>许多元素一样， <em>图表描述</em>具有强制<em>Id</em> ，在图表规范的修订版本中应该是唯一且稳定的，以及用于表示目的的可选<em>标签</em> （即，它是最终用户可见的名称）。如果未指定<em>Label</em> ，则使用<em>Id</em>进行演示。请注意，更改<em>Id</em>将破坏使用以前版本创建的现有图表;更改<em>标签</em>是安全的。
		</p>
		<p>必需的<em>Domain Class</em>属性是由图表表示的语义元素的类型。在<em>模型资源管理器中</em> ，最终用户将能够在此类型的语义元素上创建此图的新实例（假设在<em>建模项目中</em>启用了相应的视点）。域类名的语法可以是基本名称，如<code>Package</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml::Package</code> ，或者像<code>http://www.eclipse.org/uml2/3.0.0/UML#//Package</code>的完全限定URI <code>http://www.eclipse.org/uml2/3.0.0/UML#//Package</code> 。</p>
		<p>默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新图表。您可以使用<em>Precondition Expression</em>来更改此设置。如果指定了这样的表达式，则将在用户选择的语义元素的上下文中对其进行求值，并且仅当表达式返回<code>true</code>时，用户才能够在该元素上创建新图表。
		</p>
		<p>可以使用<em>Title表达式</em> （ <em>Advanced</em> category）指定新创建的图表的默认标题，该<em>表达式</em>在创建图表的语义元素的上下文中进行评估，并应返回一个字符串。如果未指定表达式，则默认标题是图表描述的标签（如果未设置<em>标签，</em>则为其<em>ID</em> ），前缀为字符串<code>"new "</code> （例如， <code>new Package Contents</code> ）。
		</p>
		<p>建议将<em>图描述</em>明确地与它将表示的语义元素的元模型相关联。您可以在<em>图描述</em>的<em>Metamodels</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p><em>启动</em>标志<em>上</em>的<em>初始化</em>和<em>显示</em>控制是否在没有用户干预的情况下自动创建和/或打开图表实例。如果设置了<em>Initialization</em> ，则当启用包含此图描述的视点时，将在所有兼容的语义元素上自动创建此图描述的实例。如果设置<em>了启动</em>时<em>显示</em> ，那么当打开包含此图描述实例的建模项目时，它们将被打开：如果只存在一个这样的表示，它将自动打开;如果有多个，将出现一个对话框，允许用户选择打开哪一个。
			<strong>警告</strong> ：然后<em>初始化</em>标志会对性能产生负面影响：如果在给定图表上设置，则当用户启用定义此图表的视点时，Sirius将尝试查找语义模型中可能存在的所有元素。可以创建这样的图表。这可能需要很长时间才能使用大型语义模型。
		</p>
		<p>如果设置了<em>Enable Popup Bars</em>标志，那么当最终用户将鼠标指针停留在图表（或图表元素）上一小段时间时，会出现一个<em>弹出栏</em> ，其中包含可应用于此的所有工具的快捷按钮上下文。创建元素而不去调色板选择工具会很有用，但如果弹出栏中有太多工具可用，它也会在视觉上分散注意力。
		</p>
		<p>默认情况下，图表以白色背景显示。在<em>图描述</em>的<em>背景</em>属性部分中，您可以添加一种预定义的系统颜色，也可以添加自己在<em>用户调色板中</em>定义的系统颜色。有关<em>用户调色板的</em>动态颜色和计算颜色的更多详细信息，请参阅<a href="../general/Colors.html">颜色颜色的常规部分</a> 。请注意，例如，当因模型更改而重新计算动态/计算颜色时，将刷新背景颜色。
		</p>
		<p><em>图描述</em>的内容主要由<a href="#graphical_elements">图形元素映射</a> ，按<a href="#layers">层</a>组织及其相关<a href="#tools">工具组成</a> 。此外，它还可以包含<a href="#validation">验证规则</a> ， <a href="#filters">过滤器</a>和<a href="#layout">布局配置</a>信息。
		</p>
		<p>请注意， <em>窗口标题</em>标签和<em>消息</em>标签是可<a href="../general/Specifying_Viewpoints.html#translatable_messages"><em>翻译消息</em></a> ，因此可以进行本地化。
		</p>
		<h3 id="layout">布局配置</h3>
		<p>Sirius提供了一个默认算法来执行图表上所有图形元素的自动布局（不包括<a href="../../user/diagrams/Diagrams.html#diagram_element_pinning">固定元素</a> ）。如果默认算法不符合您的需要，您可以直接在VSM内配置一些参数或请求备用算法（目前只有一个）。</p>
		<p><em>复合布局</em>允许用户指定元素之间的<code>padding</code>和默认算法的<code>direction</code> 。
		</p>
		<p><em>有序树布局</em>使人们可以将节点<em>布局</em>为有序树。应指定为每个节点检索子节点的方式。
		</p>
		<p>注意：这些布局算法仅管理由边连接的节点，其他节点像往常一样从左到右布置。</p>
		<p>如果您已经安装了与Sirius的ELK集成，则可以使用其他布局算法。如果您需要有关这些算法的详细信息，请参阅<a href="https://www.eclipse.org/elk/reference/algorithms.html">ELK文档</a> 。除了核心算法之外，所有这些算法都将布局元素从布局中排除，并缩短边界节点之间的边缘。
		</p>
		<p>如果您需要超越它，您可以以编程方式提供自己的布局算法（有关详细信息，请参阅<a href="../../developer/Sirius Developer Manual.html">开发人员文档</a> ）。
		</p>
		<h2 id="layers_graphical_elements">图层和图形元素</h2>
		<p>本节介绍如何指定应在图表中显示的图形元素以及如何组织它们。</p>
		<h3 id="layers">图层</h3>
		<p>Sirius图上的所有图形元素和工具都是<em>图层的</em>一部分。每个图表都<em>必须</em>具有默认图层（始终启用），以及最终用户可以在可选标记值后启用或禁用的零个或多个<em>附加图层</em> 。请注意，默认图层是在创建图表时创建的。启用图层后，还会启用它定义的所有图形元素和工具。
		</p>
		<p>在不同层中定义的元素可以交互并引用它们自己。例如，可以定义在不同层中定义的元素之间的边缘（连接）类型;只有在启用了所有相关图层时，边才会可见：定义源图形元素的图层，目标图形元素图层元素和边缘图层元素。</p>
		<p>图层直接在<em>Diagram Description</em>元素中定义。您必须只有一个<em>默认图层</em> （其名称无关紧要），以及您需要的多个<em>附加图层</em> 。
		</p>
		<ul>
			<li>其他图层具有<em>可选</em>标志（默认情况下未设置），用于指定最终用户是否可以禁用其他图层（如果为true）。
			</li>
			<li><em>默认情况下为Active</em>标记，如果设置（默认情况下未设置），则当用户创建此类型的新图表时，将自动启用该图层。在未设置可选标志的情况下，该标志无效，该层变为必需，并且最终用户无法禁用。
			</li>
		</ul>
		<p>可选图层的<em>标签</em> （如果未设置标签，则为<em>ID</em> ），可在图表标签栏中的用户可用的下拉菜单中使用，他们可以从中启用或禁用它们。此菜单中不显示强制图层。<em>图层</em>可以<em>包含</em>图形元素和工具定义（如下所述），但它们也可以<em>重用</em>使用“ <em>高级”</em>类别中的“ <em>重用工具”</em>和“ <em>重用映射”</em>在其他图层中定义的工具和映射（图形元素定义）。如果层<em>L1</em>重用在另一层<em>L2中</em>定义的元素，则每当启用<em>L1</em>时将启用这些元素，即使<em>L2</em>不是。但是，如果启用了<em>L1</em>和<em>L2</em> ，则元素仅启用一次（即图形元素对于<em>L1</em>不出现一次，对<em>L2</em>出现一次）。
		</p>
		<h4 id="Transientlayer">瞬态层</h4>
		<p>瞬态图层是仅包含<em>装饰描述</em>和/或工具的图层。
			<br>应用瞬态图层时， <strong>永远不会</strong>修改图表。工具显示在调色板中，装饰在打开的编辑器中刷新。
		</p>
		<p>请注意， <em>默认激活</em>标志对瞬态层具有不同的含义。如果设置<em>了默认</em>设置，则当用户<strong>打开</strong>图表时（而不是特别是在创建新图表时），将自动启用瞬态图层。
		</p>
		<h3 id="graphical_elements">图形元素和映射</h3>
		<p>本节介绍Sirius图表支持的各种图形元素，以及通过<em>映射</em>概念在VSM中指定它们的一般原则。
		</p>
		<p>
			<strong>图形词汇。</strong> Sirius图表可以包含几种不同类型的图形元素，这些图形元素在<em>Layer</em>元素中描述。这些是：</p>
		<ul>
			<li>
				不包含其他元素的元素的<em>节点</em> ;</li>
			<li>
				<em>容器</em>可以含有其它元素，包括其他容器元件;</li>
			<li>
				<em>列出容器</em> （或仅<em>列表</em> ），这是一种特殊的容器。它们将直接子元素显示为文本项的垂直列表（带有可选图标）。列表容器不是递归的。
			</li>
			<li>
				<em>Region Container</em> ，是一种特殊的容器。他们将直接子容器呈现为垂直或水平堆叠的隔间，也称为天狼星<em>区域</em> 。区域容器不是递归的，不能将节点包含为直接子节点。
			</li>
			<li>
				<em>Region</em> ，这是一种特殊的容器。它们是容器的隔间，垂直或水平地组织其父Region容器的配置。它们是<em>容器</em>或<em>列表容器，</em>但它们本身不能是Region容器。
			</li>
			<li>
				<em>边界节点</em>与普通节点类似，但它们不是直接出现在图表上或容器内部，而是放置在另一个元素（节点，容器，列表，区域容器但不是区域）的边界上。这对于表示通信端口之类的东西很有用。
			</li>
			<li>最后， <em>边缘</em>是源元素和目标元素之间的连接。源和目标元素可以是上面提到的任何其他类型的图形元素。边缘（但不是两者）的源或目标也可以是另一边缘。
			</li>
		</ul>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Node.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Container.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_List_Container.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Bordered_Node.png">
				</td>
			</tr>
			<tr>
				<th>节点</th>
				<th>集装箱</th>
				<th>列出容器</th>
				<th>BorderedNodes</th>
			</tr>
		</table>
		<p id="mappings">
			<strong>映射。</strong> 使用<em>映射</em>的概念（例如，用于描述一种节点的<em>节点</em>映射）来描述所有这些图形元素。映射是在VSM内部定义的元素，其标识语义模型中的元素的子集并将图形表示与它们相关联：它将语义元素<em>映射</em>到某些图形符号上。在运行时，每个活动映射（即在启用的层中定义）将在图上生成零个或多个图形元素，具体取决于当前与映射定义匹配的语义元素的数量。在默认功能模式下，每当语义模型更改时，Sirius将根据活动映射自动重新计算应在图表上显示哪些图形元素，并创建或删除必要的元素。
		</p>
		<p>你可以（节点，容器，边...）按照你想要的图中的<em>观点</em>认为，一个集图中定义为如何在语义模型的概念<em>投射</em>到天狼星提供的图形语言描述映射的代表。
		</p>
		<p>
			<strong>映射定义。</strong> 所有不同类型的图形元素的映射描述共享相同的共同原则：</p>
		<ul>
			<li>使用映射配置属性的组合来选择语义模型的一些元素（见下文）。这些元素称为<em>目标</em> ，每个元素都有一个代表它的此类型的图形图元素。
			</li>
			<li>这些图元素中的每一个还与一组<em>语义元素</em>相关联：模型元素在逻辑上组合在一起并包括节点的所有语义相关信息。默认情况下，节点的唯一语义元素是其目标，但这可以被覆盖。如果元模型是细粒度的并且描述具有一组相互关联的模型元素的单个逻辑实体，则这是有用的：图形元素将表示单个<em>目标</em> （主要语义元素），但您也可以关联到它是其他语义相关的元素。
			</li>
			<li>映射的图形方面由<em>样式</em>定义。Sirius提供了丰富的可能样式，本文档稍后将对其进行描述。
			</li>
			<li>最后，图形元素的行为（如何创建它，它如何响应其标签的编辑，拖放操作等）由与映射相关联的<em>工具</em>定义。
			</li>
		</ul>
		<p>每个映射都在VSM的<em>上下文</em>中定义：直接在层内或在另一个映射内。在运行时，相应的<em>上下文元素</em>将（分别）是图本身的目标语义元素，或父映射的实例的目标。此上下文元素用作起点，以确定应在图上创建映射的哪些实例：</p>
		<ol>
			<li>首先，从上下文元素开始评估映射的<em>语义候选表达式</em> 。它应该在语义模型中返回一组（可能是空的）元素。
			</li>
			<li>然后使用映射中指定的<em>域类</em>过滤此候选列表：仅保留作为指定类的实例的候选。
			</li>
			<li>最后，对剩余候选者中的每一个评估映射的可选<em>前提条件表达式</em> （在<em>高级</em>类别中）。它应该返回一个布尔值。仅保留谓词返回真值的候选者，并且实际上将在图上生成图形元素，该元素作为其语义目标。
			</li>
		</ol>
		<p>在指定图表时，应牢记这种评估顺序。特别是，为了避免性能问题，您应该：</p>
		<ul>
			<li>使用<em>语义候选表达式</em>限制模型元素的数量。
			</li>
			<li>避免在<em>Semantic Candidates Expression中</em>测试实例类型（在过滤<em>Domain Class</em>时无论如何都会这样做）。
			</li>
			<li>使用<em>域类中</em>最具体的类型。
			</li>
			<li>避免在<em>Precondition Expression中进行</em>导航和长时间计算。
			</li>
		</ul>
		<p>
			<strong>相关语义元素。</strong> 要将更多语义元素与图形元素（而不仅仅是其语义目标）相关联，您可以指定“ <em>关联元素表达式”</em> （在“ <em>高级”</em>类别中）。它将在语义目标的上下文中针对映射的每个实例进行评估，并且应该返回一组语义元素。当选择图形元素时，最终用户可以在“ <em>属性”</em>视图中看到这些元素，并且对其中一个元素的任何更改都将触发图形元素的刷新。这意味着如果您使用除目标之外的其他元素的属性来计算元素的标签或条件样式（例如），则应确保这些其他元素出现在<em>关联元素中</em> ，否则标签或样式将无法正确刷新什么时候修改元素。
		</p>
		<p>
			<strong>同步。</strong> 所有映射都具有<em>Synchronization</em>参数（在<em>Advanced</em>类别中），该参数控制何时在图上创建映射实例。可能的值是：</p>
		<ul>
			<li>
				<em>同步</em> ：这意味着当Sirius刷新图表时（自动或由于用户的显式<em>刷新</em>操作），它将确保图中为每个兼容的语义目标元素确切存在一个映射实例（由映射的属性）。在此模式下，如果创建了与映射兼容的新语义元素（即使通过对另一个表示的操作或语义模型文件的更改），相应的图形元素也将自动显示在图表上。对称地，如果从模型中删除其中一个映射实例的语义元素，则图形元素（视图）将自动消失。
			</li>
			<li>
				<em>未同步</em> ：在此模式下，只有在工具明确请求时才会创建和删除映射的图形实例（使用“ <em>创建视图”</em>和“ <em>删除视图”</em>操作）。这意味着如果创建了与映射兼容的新语义元素，则默认情况下相应的视图不会出现在图表上。对称地，如果从模型中删除其中一个映射实例的语义元素，则图形元素（视图）不会自动消失，但会在其上显示红叉以表示它代表不再存在的元素。显式<em>刷新</em>操作会删除这些过时的图形元素，但不会创建新的图形元素。如果您希望用户决定他想要查看的大型语义模型的哪些部分，则此模式非常有用：将映射设置为“未<em>同步”</em>并创建特定工具，以允许用户逐步显示他感兴趣的模型部分。
			</li>
			<li>
				<em>不同步</em> ：这是默认值。此模式类似于<em>Synchronized</em> be default，但为最终用户提供了一些控制：如果他们将整个图表置于非<em>同步模式</em> （使用图中的上下文菜单），则所有图表的不可<em>同步</em>的映射将表现得像它们一样<em>不同步</em> 。如果用户禁用“非<em>同步”</em>模式，它们将返回“ <em>同步”</em>行为。
			</li>
		</ul>
		<p>
			<strong>映射导入。</strong> 映射导入是一种功能，可用于<em>专门化</em> （修改）在其他位置（在其他层，其他图形表示或其他视点中）定义的映射。它适用于节点，容器和边缘。虽然它可以在常规图表描述中使用，但它的主要用例是在定义<a href="#diagram_extension">图表扩展时</a> ，因此映射导入在<a href="#mapping_imports">它们自己的部分</a>中描述。
		</p>
		<h3 id="nodes">节点</h3>
		<p><em>节点</em>映射用于以图形方式将模型元素表示为原子元素，即不能包含其他元素的元素。
			<em>节点</em>映射可以直接出现在图层描述中，在这种情况下，节点将直接显示在图表上，或者显示在另一个元素（例如容器）内部。在另一个元素内定义的节点映射可以是<em>子节点映射</em> ，在这种情况下它将出现在其父节点（必须是容器）内，或者是<em>边界节点映射</em> ，在这种情况下它将出现在边界上其父级（可以是容器或节点，包括另一个边界节点）。边界节点映射对于表示端口很有用。
		</p>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Node.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Container.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_List_Container.png">
				</td>
				<td>
					<img border="0" src="images/styles/Graphical_Vocabulary_Bordered_Node.png">
				</td>
			</tr>
			<tr>
				<th>图上的节点</th>
				<th>容器中的节点</th>
				<th>容器中的节点显示为列表</th>
				<th>边界上的节点</th>
			</tr>
		</table>
		<p>一个节点的映射的定义如下所述的一般规则<a href="#mappings">以上</a> ，以确定节点针对其应被创建的语义元素。<em>节点</em>映射配置的<em>行为</em>类别中提供的所有属性允许您查看适用于此映射的VSM中其他位置定义的所有各种工具。
		</p>
		<p>节点不能包含子节点，但它可以具有<em>边界节点</em> ，这些节点在节点映射（ <em>新图元素&gt;边界节点</em> ）内定义。您还可以<em>使用</em> “ <em>导入”</em>类别中的“ <em>重用的边界节点映射”</em>属性<em>重用</em> VSM中其他位置定义的<em>节点映射</em> 。运行时的效果与在<em>节点</em>映射中创建等效的“ <em>边界节点”</em>映射的效果相同。
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>边界节点导入<br></div>
		
		<h4 id="node_styles">节点样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括条件样式。本节仅介绍节点特有的方面。
		</p>
		<p>对于节点，您可以使用以下样式：</p>
		<ul>
			<li>
				<em>方形</em> ， <em>菱形</em> ， <em>椭圆形</em>显示基本形状。
			</li>
			<li>
				<em>Basic Shape</em>表示具有运行时提供的预定义形状的节点。
			</li>
			<li>
				<em>注意</em>将节点表示为具有一个折角的正方形。
			</li>
			<li>
				<em>计</em>到显示仪表，例如进度指示器。
			</li>
			<li>
				<em>图像</em>以表示与图像（从工作区或从插件中）的节点。
			</li>
			<li>
				当没有任何预定义样式符合您的需要时，可以使用<em>自定义样式</em> 。自定义样式使用Java实现，并使用<code>org.eclipse.sirius.diagram.ui.styleConfigurationProvider</code>扩展点。
			</li>
		</ul>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Node_Style_Basic_Square.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Basic_Stroke.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Basic_Triangle.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Basic_Dot.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Basic_Ring.png">
				</td>
			</tr>
			<tr>
				<th>基本形状广场</th>
				<th>基本形状描边</th>
				<th>基本形状三角形</th>
				<th>基本形状点</th>
				<th>基本形状环</th>
			</tr>
		</table>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Node_Style_Square.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Diamond.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Ellipse.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Note.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Gauge.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Image.png">
				</td>
				<td>
					<img border="0" src="images/styles/Node_Style_Custom.png">
				</td>
			</tr>
			<tr>
				<th>广场</th>
				<th>钻石</th>
				<th>椭圆</th>
				<th>注意</th>
				<th>规</th>
				<th>图片</th>
				<th>习惯</th>
			</tr>
		</table>
		<p>用于配置各种样式的大多数属性都是不言自明的。有关一般性讨论，请参阅下面的<a href="#styling">样式</a>部分。您还可以在编辑器中的每个属性的“问号”图标上查看可直接使用的工具提示。
		</p>
		<p>
			<strong>仪表风格。</strong> 仪表样式比其他样式更复杂，值得具体描述。它用于将节点表示为（一组）仪表，可用作例如进度指示器。
		</p>
		<p>	
			<img border="0" src="images/styles/mini_Node_Gauge_Vertical.jpg">
			<br>	
			<img border="0" src="images/styles/mini_Node_Gauge_Horizontal.jpg">
			<br>	
			<img border="0" src="images/styles/mini_Node_Gauge_Square.jpg">
		</p>
		<p>除了标签，尺寸和颜色的标准样式属性之外，仪表还有一个<em>Alignment</em>属性（在<em>Advanced</em>类别中），它指示各个仪表的布局方式：</p>
		<ul>
			<li>
				<code>VERTICAL</code>仪表从顶部到底部垂直对齐。
			</li>
			<li>
				<code>HORIZONTAL</code>仪表水平对齐，从左到右。
			</li>
			<li>
				<code>SQUARE</code>仪表对齐方形，可能不完整。仪表从左到右依次添加，并从上到下添加线条。
			</li>
		</ul>
		<p>您可以使用颜色子元素指定仪表复合材料的边框颜色。</p>
		<p>仪表复合材料需要一个或多个<strong>仪表部分</strong> ，它代表一个单独的仪表。每个<em>Gauge Section</em>都有<em>Label</em> ， <em>Min</em>和<em>Max Value Expression</em>以及<em>Value Expression</em> 。仪表部分的大小取决于<em>值表达式</em>在<em>Min</em> （该部分不可见）和<em>Max</em> （该部分占用所有可用空间）之间的位置。您可以使用颜色子元素指定每个规格部分的前景色和背景色。
			<a href="../general/Colors.html#interpolated_colors">插值颜色</a>特别适用于仪表部分。
		</p>
		<h4 id="node_tools">节点工具</h4>
		<p>有关如何定义工具的一般介绍，请参阅<a href="#tools">工具</a>部分。本节仅介绍特定于节点的工具。
		</p>
		<p>
			<strong>节点创建。</strong> 唯一特定于节点映射的工具类型是<em>节点创建</em>工具，用于创建新节点。这些工作与所有其他创建工具一样。您只需指定此工具可以创建的<em>节点映射</em> ，并使用所有标准<a href="../general/Model_Operations.html">模型操作</a>在<em>Begin</em>元素内指定工具的行为。
		</p>
		<p>默认情况下，您的节点创建工具将在所有图形元素上可用，这些元素可以包含您在工具中指定的<em>节点映射</em>的实例，如果用户尝试在不兼容的类型上应用该工具，则会看到“禁止”的符号元素。您可以指定一个<em>前提条件</em> ，禁止在通常允许的某些元素上应用该工具。前提条件在用户放置鼠标的<em>视图元素</em>的上下文中进行评估。如果返回false值，则禁止该工具的应用程序。对称地，您可以指定工具应适用的<em>Extra Mappings</em> （ <em>高级</em>部分），即使这些映射不能包含您将创建的类型的节点。在这种情况下，该工具创建的节点实际上将出现在图表的其他位置，但它通常可以帮助用户单击相关元素。
		</p>
		<h3 id="containers">集装箱</h3>
		<p><em>Container</em>映射用于以图形方式将模型元素表示为容器，其可以包含子元素（包括其他容器，递归）。容器也可以具有<em>边界节点</em> ，其与普通节点类似，但出现在容器的边界上，例如表示端口。
			<em>容器</em>映射可以直接出现在图层描述中，在这种情况下，容器将直接显示在图表上，或者显示在另一个容器映射中。
		</p>
		<p>
			<img border="0" src="images/styles/Containers_on_diagram_or_another_container.png">
		</p>
		<p>一个容器映射的定义如下所述的一般规则<a href="#mappings">以上</a> ，以确定其中的容器应被创建的语义元素。<em>Container</em>映射配置的<em>Behavior</em>类别中提供的所有属性允许您查看适用于此映射的VSM中其他位置定义的所有各种工具。
		</p>
		<p>容器可以包含<em>子容器</em> ， <em>子节点</em>和<em>边界节点</em> ，所有这些都在容器映射（ <em>新图元素&gt;容器</em> ， <em>子节点</em>和<em>边界节点</em> ）内定义。您还可以<em>使用</em> “ <em>导入”</em>类别中的相应“ <em>重用X映射”</em>属性，在这三个角色中的任何一个中<em>重用</em> VSM中其他位置定义的节点和容器映射。运行时的效果与在容器映射中创建等效映射的效果相同。
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>边界节点导入，子节点导入和容器导入。
			<br></div>
		
		<p id="list_containers">
			<strong>列表</strong>容器通过在映射配置中将<em>Children Presentation</em>属性设置为<em>List</em> ，可以为容器启用特殊的“列表模式”。列表容器以特殊方式表示，其中仅考虑其直接子元素（仅节点）的标签并将其呈现在垂直列表中。当表示为列表时，仅考虑容器的一些样式属性（标签文本，工具提示，颜色）。对于列表项本身，仅使用标签文本。
		</p>
		<p>
			<img border="0" src="images/styles/List_container_with_items.png">
		</p>
		<p id="compartments">
			<strong>隔离专区</strong>通过在映射配置中将<em>Children Presentation</em>属性设置为<em>Horizontal Stack</em>或<em>Vertical Stack</em> ，可以为容器启用特殊的“隔离专区模式”。区域容器将其子容器和列表显示为垂直或水平组织的隔离专区。它们按照映射顺序和每个映射的语义候选表达式评估结果进行排序。Region的样式的边框样式属性用于指定隔离专区分隔符。Region容器或Region映射的其他样式属性照常使用。
		</p>
		<p>
			<img border="0" src="images/styles/Containers_with_compartments.png">
		</p>
		<p>
			<em>警告：</em> Sirius 3.0.0中引入了隔离专区功能。虽然可靠地工作，但它有一些限制，但您可以依靠改进的VSM验证来确保您在支持的模式下使用它。已知限制：</p>
		<ul>
			<li>Region容器和Region映射仅支持渐变和图像样式。</li>
			<li>区域上禁用“显示/隐藏”，“隐藏”过滤器功能（可以为隔离专区内容创建隐藏过滤器，但不能创建隔离专区）。支持显示/隐藏标签功能。</li>
			<li>禁用区域的移动和拖放。重新排序区域可以通过重新排序它们的语义元素来完成。</li>
			<li>隔离专区的大小调整可能会在未来的版本中发展。当前行为是在相邻区域之间重新分配空间，并且当区域容器从顶部/底部调整为垂直堆栈并且左/右调整为水平堆栈时调整第一个/最后一个区域的大小。</li>
			<li>隔离专区始终被视为自动调整大小（创建时间除外，它不包含任何区域）。</li>
			<li>在Sirius 3.1.0中引入了定义混合两个堆栈方向的复杂或递归堆栈区域的能力作为<em>实验</em>配置。某些与布局相关的操作可能会产生意外结果。这些限制仅涉及视觉方面，不存在破坏基础模型的风险。
			</li>
		</ul>
		<h4 id="container_styles">集装箱样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括条件样式。本节仅介绍容器特有的方面。
		</p>
		<p>对于容器，您可以使用以下样式：</p>
		<ul>
			<li>
				<em>渐变</em>将容器显示为填充两种颜色之间渐变的矩形（如果渐变中的两种颜色相同，则为平面矩形）。
			</li>
			<li>
				<em>平行四边形</em>将容器表示为平行四边形。
			</li>
			<li>
				<em>图像</em>中使用自定义图像（从工作区或从插件中）。
			</li>
		</ul>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Container_Style_Gradient.png">
				</td>
				<td>
					<img border="0" src="images/styles/Container_Style_Parallelogram.png">
				</td>
				<td>
					<img border="0" src="images/styles/Container_Style_Image.png">
				</td>
			</tr>
			<tr>
				<th>梯度</th>
				<th>平行四边形</th>
				<th>图片</th>
			</tr>
		</table>
		<h5 id="DefaultSize">默认大小</h5>
		<p>您可以通过指定“高级”选项卡中提供的宽度和高度计算表达式，在创建时指定“ <em>渐变”</em>和“ <em>平行四边形”</em>样式的默认大小。当其边界<em>自动调整</em>大小时，此默认大小也将用于确定容器最小大小。
		</p>
		<p>用于配置各种样式的大多数属性都是不言自明的。有关一般性讨论，请参阅下面的<a href="#styling">样式</a>部分。您还可以在编辑器中的每个属性的“问号”图标上查看可直接使用的工具提示。
		</p>
		<h6 id="compartments_layout">特定的隔间布局</h6>
		<p>由于隔间的布局特异性，这种容器有特定的规则：</p>
		<ul>
			<li>建议将“ <code>Width Computation Expression</code>和“ <code>Height Computation Expression</code> ”设置为“-1”。隔间的大小预计将根据其区域计算。
			</li>
			<li>出于同样的原因， <code>Width Computation Expression</code>对于同一垂直隔室的每个区域应该是相同的（水平隔室的相同<code>Height Computation Expression</code> ）。如果它们不相同，则使用最大值。
			</li>
			<li>为隔离专区定义<code>Width Computation Expression</code>和<code>Height Computation Expression</code> ，将在创建时使用它们。如果最终用户通过绘制一个矩形进行创建（而不是仅仅单击图表），则会产生相同的效果。为第一个区域创建保留此维度。创建第一个区域后，隔间被视为自动调整大小。第二区域创建调整隔间的大小（在隔间的堆叠方向上）。
			</li>
		</ul>
		<p>根据VSM配置的一些布局结果的示例：</p>
		<ul>
			<li>第一个例子：<ul>
					<li>具有水平堆叠并且<code>Width Computation Expression</code>和<code>Height Computation Expression</code>隔室等于10。
					</li>
					<li>具有<code>Width Computation Expression</code>和<code>Height Computation Expression</code>等于5。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/compartmentsLayout-Creation1.png">
			<br>1-创建隔间：隔间的大小为100x100像素。如果最终用户在创建时绘制了一个100x100像素的矩形，结果将是相同的。
			<br>2-创建第一个区域：第一个区域使用隔离区的自由尺寸。隔间保持其大小。
			<br>3-创建第二区域：第二区域使用第一区域的高度（最高于VSM中定义的50个像素）并且具有50个像素的宽度。隔间的宽度增加。
		</p>
		<ul>
			<li>第二个例子：<ul>
					<li>具有水平堆叠并且<code>Width Computation Expression</code>和<code>Height Computation Expression</code>隔室等于10。
					</li>
					<li>具有<code>Width Computation Expression</code>和<code>Height Computation Expression</code>等于15。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/compartmentsLayout-Creation2.png">
			<br>第一步和第二步是相同的。但第三个是不同的。第二区域的宽度为150像素，高度为150像素（高于第一区域）。隔室在两个方向上都增加。
		</p>
		<ul>
			<li>第三个例子：<ul>
					<li>具有水平堆栈并且<code>Width Computation Expression</code>和<code>Height Computation Expression</code>隔室等于-1。
					</li>
					<li>具有<code>Width Computation Expression</code>和<code>Height Computation Expression</code>等于5。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/compartmentsLayout-Creation3.png">
			<br>1-创建隔间：隔间是自动调整大小并适合标题。
			<br>2-创建第一个区域：第一个区域使用隔间的宽度（最高于VSM中定义的50个像素），高度为50个像素。隔间的高度增加。
			<br>3-创建第二区域：第二区域具有50×50像素的大小。隔室在两个方向上都增加。
		</p>
		<h4 id="container_tools">容器工具</h4>
		<p>有关如何定义工具的一般介绍，请参阅<a href="#tools">工具</a>部分。本节仅介绍特定于容器的工具。
		</p>
		<p>
			<strong>容器创建。</strong> 这些工具用于创建新容器。它们像所有其他创建工具一样工作。您只需指定此工具可以创建的<em>Container Mappings</em> ，并使用所有标准<a href="../general/Model_Operations.html">模型操作</a>在<em>Begin</em>元素内指定工具的行为。
		</p>
		<p>默认情况下，容器创建工具将在所有图形元素上可用，这些图形元素可以包含您在工具中指定的<em>容器映射</em>的实例，如果用户尝试在不兼容的类型上应用该工具，则会看到“禁止”符号元素。您可以指定一个<em>前提条件</em> ，禁止在通常允许的某些元素上应用该工具。前提条件在用户放置鼠标的<em>视图元素</em>的上下文中进行评估。如果返回false值，则禁止该工具的应用程序。对称地，您可以指定工具应适用的<em>Extra Mappings</em> （ <em>高级</em>部分），即使这些映射不能包含您将创建的类型的容器。在这种情况下，该工具创建的容器实际上将显示在图表的其他位置，但它通常可以帮助用户单击相关元素。
		</p>
		<p>
			<strong>容器删除</strong>您可以将<em>容器删除</em>描述与容器映射关联，以对<em>拖放</em>操作进行响应。<em>Drag Source</em>属性指示您是否要对来自Sirius表示的图形元素，从另一个Eclipse视图（例如，从<em>Model Explorer</em> ）拖动的语义模型元素做出反应，或者两者都有。<em>Containers</em>属性指示此工具适用于哪种drop容器映射。<em>Mappings</em>属性指示当<em>Drag Source</em>为<em>Representation</em>或<em>Both</em>时，可以将哪些图形元素放入指定的容器中。工具的主体（ <a href="../general/Model_Operations.html">模型操作</a> ）指定在将元素放入容器时如何反应。
		</p>
		<p>
			<i>警告</i> ：如果选择“ <em>模型”</em>或“ <em>两者”</em>作为源，则必须准备好工具以接受可在“ <em>模型资源管理器”</em>视图中出现的任何类型的源元素，包括与为工具指定的源映射无关的元素。使用前提条件检查被拖动元素的性质（可通过<code>element</code>变量获得）以禁用工具不支持的工具源元素。
		</p>
		<p>从Eclipse视图中拖放工作空间资源（文件，文件夹...）时，会执行一些转换以简化操作规范。根据丢弃的资源，根操作中的<code>element</code>变量内容将不同：</p>
		<ul>
			<li>可加载模型：将加载模型并将其添加到会话的语义资源中。模型的根内容将设置为<code>element</code>变量值。
			</li>
			<li>文件：将创建<code>DFile</code>实例并将其设置为<code>element</code>变量值。
			</li>
			<li>文件夹：将创建<code>DFolder</code>实例并将其设置为<code>element</code>变量值。对于文件夹包含的每个资源，将创建<code>DResource</code>实例。
			</li>
			<li>项目：将创建一个<code>DProject</code>实例并将其设置为<code>element</code>变量值。对于文件夹包含的每个资源，将创建<code>DResource</code>实例。
			</li>
		</ul>
		<p>
			<code>DFile</code> ， <code>DFolder</code> ， <code>DProject</code>是实例<code>DResource</code> 。<code>DResource</code>实例具有<strong>名称</strong>和<strong>路径</strong> 。路径是资源的绝对位置。
			<br>
			<code>DFolder</code> ， <code>DProject</code>是实例<code>DResourceContainer</code> 。<code>DResourceContainer</code>实例具有<strong>成员</strong> ，这些<strong>成员</strong>是<code>DResource</code>实例。
		</p>
		<h3 id="bordered_nodes">有边界的节点</h3>
		<p>使用普通<a href="#nodes">节点映射</a>指定边界节点。它们可以出现在节点映射内（包括边界节点的其他节点映射）和容器映射。它们可以具有与普通节点映射相关的相同样式和工具（尽管它们通常应保持较小以避免奇怪的图形效果）。
		</p>
		<h3 id="edges">边缘</h3>
		<p>边用于定义图元素之间的连接。有两种边缘，使用不同的映射定义：</p>
		<ul>
			<li>
				<em>基于关系的边</em>用于表示模型元素（如包含或引用（包括计算引用））之间的关系。UML中的一个示例是继承关系，它由类及其超类之间的引用表示。这些将使用基于关系的边缘建模。
			</li>
			<li>
				当存在语义模型元素（而不仅仅是引用）来表示关系本身时，使用<em>基于元素的边缘</em> 。UML中的一个例子是两个类<em>A</em>和<em>B</em>之间的关联：它不是由<em>A</em>到<em>B</em>之间的引用表示，而是由显式的<em>Association</em>模型元素表示，它本身引用<em>A</em>和<em>B.</em>这种关联将使用<em>关联</em>元素上的基于域的边缘来建模。
			</li>
		</ul>
		<h4 id="relation_based_edges">基于关系的边缘</h4>
		<p>要指定基于<em>关系的边</em> ，必须填充“ <em>源映射”</em>和“ <em>目标映射”</em>属性。它们指示边缘将从哪种图形元素开始以及它们采用何种元素。两个属性都可以包含多个映射，一些映射可以同时显示为源和目标。请注意，可能有源边<em>或</em>目标是另一边的边，但不是两者。
		</p>
		<p>您还必须指定<em>目标查找器表达式</em> 。它将在潜在源的语义目标元素（由<em>Source Mappings</em>定义）的上下文中进行评估，并应返回目标元素的语义元素以与源连接。表达式可以返回零元素，以指示没有从此元素开始的边。
		</p>
		<p>边缘（此映射的实例）将出现在图中的每对图形元素<em>E1</em>和<em>E2之间</em> ，其中：</p>
		<ul>
			<li>
				<em>E1</em>的映射在<em>Source Mappings中</em> 。
			</li>
			<li>
				<em>E2</em>的映射在<em>Target Mappings中</em> 。
			</li>
			<li>（可选） <em>前提条件表达式</em> （ <em>高级</em>类别）对于<em>E1</em>的语义元素返回true。
			</li>
			<li><em>E2</em>的语义元素出现在<em>E1</em>语义元素上下文中评估<em>Target Finder Expression</em>的结果中。
			</li>
		</ul>
		<p>因为基于关系的边缘不代表实际的语义元素而是元素之间的关系，因此它自己的语义元素与其源代码相同。</p>
		<p>
			<strong>路径。</strong> 边缘仅存在于一个源和一个目标元素之间。有时，这样的边缘只是遍历许多元素的更复杂<em>路径的</em>一部分。您可以使用“ <em>路径”</em>类别中的属性突出显示此类复杂路径。
			<em>路径映射</em>应该是<em>路径所</em>考虑的映射列表，并且<em>路径表达式</em>应该按照应该遍历的顺序返回边缘路径应该经过的语义元素列表。
		</p>
		<h4 id="element_based_edges">基于元素的边缘</h4>
		<p>
			<em>基于元素的边缘</em>配置很像节点和容器。您必须指定<em>域类</em> ， <em>语义候选表达式</em>和（可选） <em>前置条件表达式</em>以选择边缘将表示的语义元素。此外，您必须指定：</p>
		<ul>
			<li>“ <em>源映射”</em>和“ <em>目标映射”</em>属性，用于指示边缘将从哪种图形元素开始以及它们将采用何种元素。两个属性都可以包含多个映射，一些映射可以同时显示为源和目标。请注意，可能有源边<em>或</em>目标是另一边的边，但不是两者。
			</li>
			<li>将在边缘的语义元素的上下文中评估的<em>源查找器表达式</em>和<em>目标查找器表达式</em>应返回边连接的实际元素。
			</li>
		</ul>
		<p>边缘（此映射的实例）将出现在图中的每对图形元素<em>E1</em>和<em>E2之间</em> ，其中：</p>
		<ul>
			<li>
				<em>E1</em>的映射在<em>Source Mappings中</em> 。
			</li>
			<li>
				<em>E2</em>的映射在<em>Target Mappings中</em> 。
			</li>
			<li>存在由<em>域类</em>和<em>语义候选表达式</em>选择的语义元素， <em>源查找器表达式</em>返回<em>E1</em>并且<em>目标查找器表达式</em>返回<em>E2</em> 。
			</li>
		</ul>
		<p>
			<strong>路径。</strong> 边缘仅存在于一个源和一个目标元素之间。有时，这样的边缘只是遍历许多元素的更复杂<em>路径的</em>一部分。您可以使用“ <em>路径”</em>类别中的属性突出显示此类复杂路径。
			<em>路径映射</em>应该是<em>路径所</em>考虑的映射列表，并且<em>路径表达式</em>应该按照应该遍历的顺序返回边缘路径应该经过的语义元素列表。
		</p>
		<h4 id="edges_styles">边缘样式</h4>
		<p>两种类型的边（基于关系和基于元素）共享相同的样式类型。它支持条件样式，就像其他映射一样。</p>
		<p>您可以指定线条样式（ <em>实</em>线， <em>短划线</em> ， <em>点</em>或<em>点</em> <em>划线</em> ），颜色，宽度（使用<em>高级类别中</em>的<em>尺寸计算表达式</em> ）和可选装饰（如箭头）放置在端点上边缘。
		</p>
		<p><em>路由样式</em>可以是以下之一：</p>
		<ul>
			<li>
				<em>直线</em> ：使用直线段绘制边缘。创建时，只有一个段直接连接源元素和目标元素，除非源和目标是相同的元素。最终用户可以创建和删除子段，并移动弯曲点。
			</li>
			<li>
				<em>曼哈顿</em> ：仅使用垂直和水平线段绘制边缘。否则它类似于<em>Straight</em> 。
			</li>
			<li>
				<em>树</em> ：这种风格可以看作是<em>曼哈顿</em>的特殊情况，总是有两个垂直的部分和一个横向的部分。如果一个图形元素用作使用此样式的多个边的源，则它们的第一个垂直线段（树的主干）将合并，并且它们的水平线段将全部显示为单个线。
			</li>
		</ul>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/styles/Edge_Style_Straight.png">
				</td>
				<td>
					<img border="0" src="images/styles/Edge_Style_Manhattan.png">
				</td>
				<td>
					<img border="0" src="images/styles/Edge_Style_Tree.png">
				</td>
			</tr>
			<tr>
				<th>直行</th>
				<th>曼哈顿</th>
				<th>树</th>
			</tr>
		</table>
		<p>请注意，最终用户可以单独更改边的路由样式，与您在VSM中设置的默认样式无关。</p>
		<p>
			<strong>边缘标签。</strong> 边缘可以有零到三个标签。默认情况下，它们有一个放置在其中心的单个。您可以删除它和/或添加要在边缘的开头（靠近源）或结束（靠近目标）显示的标签。在所有情况下，配置<a href="#label_style">与所有标签</a>的配置<a href="#label_style">相同</a> 。请注意，如果<em>直接编辑</em>工具与边缘映射关联，则当前只有中心标签（如果存在）是可<em>编辑的</em> 。
		</p>
		<p>
			<strong>边缘折叠。</strong> 从边缘的一端开始，能够隐藏另一端的元素通常是有用的。例如，当使用edge和edge来表示元素之间的某种包含关系时，您希望隐藏元素的“内容”以专注于图的其余部分。您可以允许最终用户在边缘映射上设置<em>折叠样式</em> （在“ <em>高级”</em>类别中）。当“ <em>折叠样式”</em>设置为“ <em>源”</em>或“ <em>目标”时</em> ，边缘源或目标上的元素（节点或容器）的左上角会有一个小的“ - ”符号。如果用户单击它，则该元素为源（相应目标）的此映射的边缘实例将折叠：边缘和它们在另一侧连接的元素将从视图中消失。行为是递归的：如果隐藏的元素使用这种边缘连接到其他元素，那么它们也将被隐藏。当元素折叠时，“ - ”符号变为“+”符号，可用于展开边缘。这在表示元素树时非常有用：如果启用折叠，用户只需单击一下即可隐藏或显示元素的完整子层次结构。
		</p>
		<p>
			<strong id="edgecentering">边缘居中。</strong> 边缘源和边缘目标不是系统地朝向节点的中心，取决于最终用户创建或移动边缘的位置。您可以指定边缘端（源，目标或两者）始终居中。“ <em>居中源映射”</em>和“ <em>居中目标映射”</em> （在边缘样式说明高级属性选项卡中）允许您选择源或目标将居中的映射。“ <em>结束居中”</em>部分（在同一高级选项卡上）允许您针对任何边缘源/目标映射推广此行为。请注意，最终用户可以通过边缘样式<em>居中</em>属性自定义此行为。
		</p>
		<p>
			<img border="0" src="images/styles/Edge_Style_Centering.png"> 
			<br>第一条边，最高边，朝向节点的中心</p>
		<h4 id="bracket_edge_style">支架边缘样式</h4>
		<p>支架边缘图设计为从节点侧的中间到另一个节点侧的中间。用户可以移动主段并旋转图形（水平 - &gt;垂直或垂直 - &gt;水平）。</p>
		<p>	
			<img border="0" src="images/styles/Edge_Style_bracketStyle.png">
		</p>
		<p>可选装饰（如箭头）将放在主要段的端点上。</p>
		<p>有关其他属性，请参阅“ <a href="#edges_styles">边缘样式”</a>部分。
		</p>
		<h4 id="edge_tools">边缘工具</h4>
		<p>有关如何定义工具的一般介绍，请参阅<a href="#tools">工具</a>部分。本节仅介绍特定于边缘的工具。
		</p>
		<p>
			<strong>边缘创建。</strong> 此工具用于创建新边。它们像所有其他创建工具一样工作。您只需指定此工具可以创建的<em>边缘映射</em> ，并使用所有标准<a href="../general/Model_Operations.html">模型操作</a>在<em>Begin</em>元素内指定工具的行为。工具的主体将在新边缘的源的语义元素的上下文中执行。
		</p>
		<p>因为边有两端，所以它们的创建要求用户指定源元素和目标元素。默认情况下，可能的源是为此类边缘指定的<em>源映射</em>之一的所有实例（对于可能的目标，类似）。您可以使用“ <em>连接启动前置条件”</em> （resp。
			<em>连接完成前提条件</em> ）禁止使用（相应）某个元素的工具。
		</p>
		<p>
			<em>连接启动前提条件</em>表达式可以使用以下变量来允许/禁止首次单击以创建连接：</p>
		<ul>
			<li>
				<code>preSourceView</code> ：第一次点击时指向的图形元素。
			</li>
			<li>
				<code>preSource</code> ：第一次点击时指向的语义元素。
			</li>
			<li>
				<code>diagram</code> ：当前图。
			</li>
			<li>
				<code>container</code> ：图的语义元素。
			</li>
		</ul>
		<p>
			<em>连接完成前提条件</em>表达式可以使用以下变量来允许/禁止第二次单击以创建连接：</p>
		<ul>
			<li>
				<code>preSourceView</code> ：第一次点击时指向的图形元素。
			</li>
			<li>
				<code>preSource</code> ：第一次点击时指向的语义元素。
			</li>
			<li>
				<code>preTargetView</code> ：第二次单击时指向的图形元素。
			</li>
			<li>
				<code>preTarget</code> ：第二次单击时指向的语义元素。
			</li>
			<li>
				<code>diagram</code> ：当前图。
			</li>
			<li>
				<code>container</code> ：图的语义元素。
			</li>
		</ul>
		<p>相反，您可以指定<em>额外源映射</em>和<em>额外目标映射</em> （ <em>高级</em>类别），用户可以选择其作为“虚拟”源和目标，即使工具创建的真实边缘不在这些元素之间。
		</p>
		<p>
			<strong>重新连接边缘。</strong> “ <em>重新连接边缘”</em>工具用于允许最终用户通过将相应的末端移动到另一个图形元素来更改边缘的源和/或目标。如果指定了一个工具来处理用户的重新连接尝试，那么将使用所有适当的信息调用它，以便它可以执行相应的语义更改。除了指示工具支持的边缘类型的<em>Mappings</em>属性之外，还必须指定一个<em>重新连接类型</em> ：可以编写工具以仅支持重新连接源端，目标端或两者。处理这两种情况的工具编写起来很复杂，因此建议尽可能编写两个单独的工具：一个用于处理源重新连接，另一个用于目标重新连接。
		</p>
		<p>在用户想要重新连接的边缘的目标语义元素上评估工具的主体，并使用以下变量来描述重新连接：</p>
		<ul>
			<li>
				<code>source</code> ：重新连接之前指向的语义元素。
			</li>
			<li>
				<code>target</code> ：重新连接后指向的语义元素。
			</li>
			<li>
				<code>sourceView</code> ：重新连接之前指向的图形元素。
			</li>
			<li>
				<code>targetView</code> ：重新连接后指向的图形元素。
			</li>
			<li>
				<code>otherEnd</code> ：重新连接期间未更改的边缘端（图形元素）</li>
			<li>
				<code>edgeView</code> ：图形重新连接后的Edge</li>
			<li>
				<code>diagram</code> ：当前图。
			</li>
			<li>
				<code>element</code> ：当前边缘的语义元素。
			</li>
		</ul>
		<p>以下是在具体案例中显示此变量值的说明。在重新连接之前：</p>
		<p>	
			<img border="0" src="./images/references/reconnect/ReconnectTool_Before.png">
		</p>
		<p>重新连接后：</p>
		<p>	
			<img border="0" src="./images/references/reconnect/ReconnectTool_After.png">
		</p>
		<ul>
			<li><code>sourceView</code>是图形节点“A”。
			</li>
			<li><code>targetView</code>是图形节点“B”。
			</li>
			<li><code>otherEnd</code>是图形节点“C”，在重新连接期间没有改变。
			</li>
			<li>
				<code>edgeView.sourceNode</code>是图形节点“C”。
			</li>
			<li>
				<code>edgeView.targetNode</code>是图形节点'B'。
			</li>
		</ul>
		<p>对于语义，我们将认为我们代表“Box”，链接意味着“包含在”中：</p>
		<ul>
			<li><code>source</code>是方框'A'。
			</li>
			<li><code>target</code>是方框'B'。
			</li>
			<li>
				<code>element</code>是“C”和“A”之间的“包含”链接。
			</li>
		</ul>
		<h3 id="decorations">饰</h3>
		<p>装饰可用于向图表元素添加小图形注释。它们直接在图层内定义，它们可以是<em>基于映射的装饰</em> ， <em>基于语义的装饰</em>或<em>通用装饰</em> 。
		</p>
		<p>
			<strong>基于映射的装饰</strong>具有可应用的<em>映射</em>列表。
			<br> 
			<img border="0" src="./images/mappingBasedDecoration.png">
		</p>
		<p>
			<strong>基于语义的装饰</strong>具有<em>域类，</em>并且将应用于具有该类的实例作为其语义元素的所有图形元素，无论用于表示它们的映射是什么。
			<br> 
			<img border="0" src="./images/semanticBasedDecoration.png">
		</p>
		<p>
			<strong>通用装饰</strong>仅基于<em>前置条件表达式，</em>以了解它是否适用于当前图形元素。
		</p>
		<p><em>前提条件表达式</em>在候选语义元素的上下文中进行评估，候选语义元素是当前图形元素的语义元素（即<em>DSemanticDecorator.target</em> ）。如果表达式返回true，则将显示装饰器。
		</p>
		<h4 id="Decorationdisplay">装饰展示</h4>
		<p><em>装饰描述</em>有一个<em>位置</em> ，指示装饰器的放置位置。可以在四个角（NORTH_WEST，NORTH_EAST，SOUTH_WEST和SOUTH_EAST）中选择位置，每个边界框边（NORTH，SOUTH，WEST和EAST）的中间和CENTER位置。
		</p>
		<img align="center" border="0" src="./images/decoration_positions.png">
		<p>可以在同一<em>位置</em>指定许多装饰。为了管理它，根据<em>分布方向，</em>沿着边界框的边界从它们定义的位置显示装饰。
		</p>
		<ul>
			<li>对于角落装饰，可以在垂直或水平方向之间进行选择。</li>
			<li>对于NORTH，SOUTH和CENTER位置，方向仅从左到右水平。</li>
			<li>对于WEST和EAST位置，方向仅从上到下垂直。</li>
		</ul>
		<p>装饰示例： <img align="center" border="0" src="./images/decoration_example.png">
		</p>
		<p>默认情况下，装饰和图形边框之间的边距为2像素。
			<br>当节点包含边界节点时，节点装饰将从边框移位以避免与边界节点重叠<br>边框节点的装饰示例： <img align="center" border="0" src="./images/decoration_borderNode.png">
		</p>
		<p>装饰图标使用<em>Image Expression</em>进行定义， <em>Image Expression</em>是InterpretedExpression。
			<em>图像表达</em>可能是：</p>
		<ul>
			<li>图像的路径，可以是工作空间的绝对或相对。工作空间路径示例： <em>/org.eclipse.sirius.tests.sample.component.design/images/square16x16.png</em>
			</li>
			<li>一个表达式，提供图像的路径</li>
			<li>提供<code>org.eclipse.swt.graphics.实例的表达式<code>org.eclipse.swt.graphics.Image</code>提供商必须定义图像缓存以优化内存消耗和性能。目前，没有释放缓存的机制。
			</li>
			<li>一个提供<code>org.eclipse.draw2d.实例的表达式<code>org.eclipse.draw2d.IFigure</code> 。数字生命周期由Sirius管理。
			</li>
		</ul>
		<p><em>装饰描述</em>有一个<em>TooltipExpression</em> ，可能是：</p>
		<ul>
			<li>固定的工具提示字符串</li>
			<li>提供工具提示字符串的表达式</li>
			<li>一个提供<code>org.eclipse.draw2d.实例的表达式<code>org.eclipse.draw2d.IFigure</code> 。数字生命周期由Sirius管理。
			</li>
		</ul>
		<p>装饰工具提示示例： <img align="center" border="0" src="./images/decoration_tooltip_example.png">
		</p>
		<p>有时，根据图形元素大小，装饰用<em>列表装饰</em>表示， <em>列表装饰</em>是包含三个点的16×16像素帧。<em>列表装饰</em>的工具提示显示为线条，包含的装饰及其工具提示。
			<br>有时，图形元素大小可能太小而无法显示所有装饰而不重叠。在这种情况下，装饰将被收集到一个称为<em>列表装饰的装饰中</em> 。此<em>列表装饰</em>用包含三个点的16x16像素帧表示。<em>列表装饰</em>的工具提示以线条的形式显示包含的装饰及其工具提示。
		</p>
		<p>列表装饰示例： <img align="center" border="0" src="./images/decoration_group_example.png">
		</p>
		<p>列表修饰的工具提示示例： <img align="center" border="0" src="./images/decoration_group_tooltip_example.png">
		</p>
		<h4 id="Decorationdisplayupdate">装修展示更新</h4>
		<p>装饰可以手动和自动刷新。</p>
		<ul>
			<li>手动，当用户单击图工具栏中的刷新按钮时。</li>
			<li>自动，根据语义变化时：<ul>
					<li><code>DDiagramElement</code> （ <code>DSemanticDecorator_Target</code>功能）的<em>目标语义元素</em>已更改，</li>
					<li><code>DDiagramElement</code> （ <code>DRepresentationElement_SemanticElements</code>功能）的<em>语义元素</em>已更改。它们在映射上使用<em>关联元素表达式</em>定义。这意味着定义装饰的说明符不能添加专用于装饰的新“语义元素”，这些元素将被用于自动刷新。
					</li>
				</ul>
			</li>
		</ul>
		<h2 id="styling">造型</h2>
		<p>样式定义图元素的图形外观。Sirius支持丰富的可能样式集，包括可以根据底层模型元素的当前状态动态更改的条件样式。每个映射必须定义至少一个样式在图上可见。</p>
		<h3 id="conditional_styles">条件样式</h3>
		<p>条件样式可以支持单个映射的不同图形方面。用于呈现元素的实际样式是根据模型元素的当前状态动态确定的。</p>
		<p>要使用条件样式，必须首先创建一个非条件样式，这将是默认样式。然后，您可以将一个或多个条件样式作为兄弟节点添加到默认样式。每个条件样式都与指定为谓词的条件相关联。如果映射上存在条件样式，则在映射描述中按照它们的出现顺序测试它们的条件。选择条件为<strong>真的</strong>第一个。如果没有条件样式条件为真，则使用默认样式。
		</p>
		<ul>
			<li>注意：条件样式规则有一个例外：</li>
		</ul>
		<p>如果用户使用WorkspaceImage样式定制了一个Node（通过“将样式设置为工作空间图像”操作），那么如果通过VSM计算新样式（例如通过条件样式设备），则此新样式将不会覆盖WorkspaceImage样式以保留最后一次自定义（请参阅<a href="../../user/diagrams/Diagrams.html#styleCustomizations"><em>样式自定义</em></a> ）。
		</p>
		<h3 id="label_style">标签属性</h3>
		<p>样式的责任之一是描述将要显示的标签以及它们的格式。可以使用以下属性：</p>
		<ul>
			<li>
				<em>Label Expression</em>用于计算描述元素的标签文本。它在语义目标元素的上下文中进行评估。
			</li>
			<li>
				<em>标签位置</em>用于设置标签相对于节点的位置（此属性不适用于容器和边缘）。标签可以放在节点的<em>边界</em> （外部），可以在节点的边界或<em>节点</em>本身中自由移动。
			</li>
			<li>
				<em>标签大小</em>表示要在点中使用的字体大小。
			</li>
			<li>
				<em>标签格式</em>用于指定字体样式属性（ <em>粗体</em>和/或<em>斜体</em>和/或<em>下划线</em>和/或<em>穿透</em> ）。
			</li>
			<li>
				<em>Label Alignment</em>用于定位在节点内的标签以指定它们的对齐方式（请注意，并非所有样式都支持所有对齐值）。对于节点，此属性仅在<strong>Label position</strong>设置为<strong>node时应用</strong> （否则，标签可由用户自由移动）。对于容器，它仅适用于容器的标签本身，而不适用于其内容。此属性不适用于边（同样，其标签可由用户自由移动）和列表项。
			</li>
			<li>
				<em>标签边框样式</em> （仅适用于<em>渐变容器样式</em> ）：说明符可以在列表中选择标签边框样式。因此，将在标签周围绘制或不绘制边框，这可能会影响子内容窗格配置。
			</li>
			<li>
				<em>显示图标</em>表示元素的图标是否应该可见。如果设置，则使用的图标是与目标元素的类型相关联的图标，并在标签的左侧呈现。请注意，最终用户始终可以使用<em>标签图标</em>首选项（ <em>窗口</em> / <em>首选项</em> / <em>天狼星</em> / <em>天狼星图</em> / <em>外观</em> ）隐藏此类图标。
			</li>
			<li>
				<em>默认情况下隐藏标签</em> （不适用于边缘）用于在创建元素时配置标签可见性。
			</li>
		</ul>
		<p>虽然不是标签属性的严格组成部分，但可以为大多数样式设置<em>工具提示表达式</em> ，并用于计算用户将鼠标悬停在元素上时显示的可选工具提示的文本。它可以看作是默认情况下不可见的备用<em>标签表达式</em> ，并且可以仅在用户请求时显示元素的其他详细信息，以避免图表上的视觉混乱。
		</p>
		<h3 id="size">尺寸属性</h3>
		<p>大多数样式可以控制图形元素的大小。下面描述的属性并非适用于所有样式，但是当它们具有相同的含义时（除非特殊情况指定）：</p>
		<ul>
			<li>
				<em>允许调整大小</em> ：您可以决定是否允许最终用户<em>水平</em>和/或<em>垂直</em>调整图形元素的大小。大多数样式默认允许在两个方向上调整大小。
			</li>
			<li>可以明确指定初始<em>宽度</em>和<em>高度</em> 。值0表示没有明确的宽度或高度。初始值将取自样式的默认值或<em>大小计算表达式（</em>如果指定）。
			</li>
			<li>
				<em>大小计算表达式</em> ：用于动态计算图形元素大小的表达式。它在目标元素的上下文中进行计算，并应返回一个整数。
			</li>
			<li>
				<em>边框大小计算表达式</em> ：用于动态计算图形元素<em>边框大小</em>的表达式。它在目标元素的上下文中进行评估，并应返回<em>以像素为单位</em>的边框大小。
			</li>
		</ul>
		<h3 id="colors">颜色</h3>
		<p>每当您必须为样式指定颜色时，您可以使用任何一种预定义的系统颜色或您在<em>用户调色板中</em>自己定义的<em>颜色</em> 。调色板直接在<em>Viewpoint</em>元素内创建，其颜色可以由任何表示使用，而不仅仅是图表。有关详细信息，请参阅<a href="../general/Colors.html">颜色的常规部分</a> 。
		</p>
		<h3 id="authorizedsides">授权双方</h3>
		<p>默认情况下，边界节点可以位于其父节点的任何一侧。可以限制边界节点授权方。因此，最终用户将无法在禁止侧创建或移动边界节点。可以在边界节点样式的高级选项卡中指定授权方：<br>
			<img border="0" src="images/styles/authorizedSides.png">
		</p>
		<h2 id="tools">工具</h2>
		<p>工具用于定义建模者的行为。一些工具将出现在图表的调色板中（例如，用于创建新节点的工具），而其他工具将在用户执行某些操作时自动调用（例如，当用户从图中删除元素时触发的删除工具）。</p>
		<h3 id="tools_organization">工具组织</h3>
		<p>工具在<em>工具部分</em>中定义， <em>工具部分</em>直接显示在图层内。如果在附加图层内定义了工具，则仅在启用相应图层时才会启用该工具。
		</p>
		<p>图层中的顶级<em>工具部分</em>仅用于将工具定义与映射定义分开，并且不会影响工具的显示方式。但是，如果在这些顶级部分（ <em>新工具...&gt;部分</em> ）中创建子部分，并且这些部分包含显示在调色板中的工具，则子部分将用于对相应的工具进行分组。调色板中的可扩展部分。您还可以创建<em>组</em> （ <em>新工具...&gt;组</em> ），其行为类似于调色板中的组合框：组中定义的工具中，只有一个是活动的（并且可见）。
		</p>
		<p>工具部分可以具有<em>重用工具</em> ，这些<em>工具</em>在别处定义（包括在另一层中，甚至来自不同的表示）。它们的出现和行为就好像它们是在重用它们的部分中定义的一样。
		</p>
		<p><em>Group Extension</em>元素（在工具部分中定义）允许您在其他地方定义的现有<em>Group中</em>添加工具。例如，它可用于将附加层中定义的工具合并到默认层中定义的一组工具中。您必须选择要扩展的现有<em>组</em> ，并且组扩展中声明的任何工具都将通过“group”属性添加到目标组中。
		</p>
		<p>请注意，工具部分标签和工具标签是可<a href="../general/Specifying_Viewpoints.html#translatable_messages"><em>翻译消息</em></a> ，因此可以进行本地化。
		</p>
		<p>
			<i>警告</i> ：可以在图层外的图形描述下直接定义ToolSection。不鼓励在图层外定义工具部分，这就是删除此操作的原因。之前创建的工具部分仍然存在，但您应将其移动到默认图层，因为将来可能会删除它。
		</p>
		<h3 id="tools_specification">工具规范</h3>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>研究这个的确切语义并完成描述。
			<br></div>
		
		<h3 id="tools_reference">工具参考</h3>
		<p>在本节中，我们将描述图表中可用的各种工具。</p>
		<h4 id="node_creation">节点创建</h4>
		<p>请参阅<a href="#node_tools">特定</a>于<a href="#node_tools">节点的工具部分中的说明</a> 。
		</p>
		<h4 id="container_creation">容器创建</h4>
		<p>请参阅<a href="#container_tools">特定</a>于<a href="#container_tools">容器的工具部分中的说明</a> 。
		</p>
		<h4 id="edge_creation">边缘创建</h4>
		<p>请参阅<a href="#edge_tools">边缘特定工具部分中的说明</a> 。
		</p>
		<h4 id="container_drop">容器掉落</h4>
		<p>请参阅<a href="#container_tools">特定</a>于<a href="#container_tools">容器的工具部分中的说明</a> 。
		</p>
		<h4 id="reconnect_edge">重新连接边缘</h4>
		<p>请参阅<a href="#edge_tools">边缘特定工具部分中的说明</a> 。
		</p>
		<h4 id="paste_description">糊</h4>
		<p>粘贴工具旨在定义操作，将通过<em>copiedElement</em>变量访问的给定复制语义元素粘贴到语义粘贴接收器中，可通过<em>容器</em>变量访问。<em>copiedView</em>和<em>containerView</em>变量引用相应的图形元素。<em>Containers</em>属性指示此工具应用的映射。
		</p>
		<p>它的语义目标是复制的语义元素。如果复制的元素是非基于域的元素（例如，关系边缘），则语义元素是原始元素，除非它是由也被选择的基于域的元素的目标。未复制语义目标时，该工具将接收空复制元素。</p>
		<p>
			<strong>警告</strong> ：仅当粘贴接收器上未定义工具时才使用通用行为。否则，将选择具有前提条件评估为真的第一个工具，如果所有已定义的工具都具有错误前提条件，则将禁用粘贴操作。
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>描述根本不清楚。
			<br></div>
		
		<h4 id="delete_tool">删除元素</h4>
		<p>如果不将<em>删除</em>工具与映射关联，则用户删除图形元素时的默认删除行为是从语义模型中删除目标语义元素和所有关联的语义元素。如果您想要一个不同的行为，或者如果您想禁止删除某些元素，则必须设置一个显式的<em>删除</em>工具。当用户选择“ <em>从模型中删除”</em>操作时（从上下文菜单，从选项卡栏或使用<em>Delete</em>键），将调用删除工具。<em>元素</em>变量将被设置为要删除的主要语义目标元素（不包括任何关联的语义元素），而<em>elementView</em>和<em>containerView会</em>告诉您正在删除哪个图形视图以及它在哪个上下文中。
		</p>
		<p>如果要完全禁用某些元素的删除，可以创建一个<em>删除</em>工具，该工具<em>不对</em>这些元素执行任何操作，或者，如果可能，设置工具的<em>前提条件</em>以对这些元素返回<em>false</em> 。设置前置条件通常是首选，因为它会在UI（标签栏和上下文菜单）中将<em>删除</em>操作标记为已禁用，而用户无法调用任何无效的工具，但不起作用。但请注意，每次用户选择和元素时，都会评估<em>Precondition</em> ，以决定是否应在UI中启用删除操作。评估复杂的前提条件会对建模者的感知性能产生负面影响。
		</p>
		<h4 id="direct_edit">直接编辑标签</h4>
		<p><em>直接编辑标签</em>工具用于允许用户直接编辑表示元素的标签。它指定了如何解释新标签值以及应用于模型元素的更改。用户可以使用<em>F2</em>快捷方式，通过慢速双击调用它，或者在选择标签时直接开始键入一些文本。
		</p>
		<p>如果要在编辑期间显示不同的标签，可以使用<code>input label expression</code> 。在调用直接编辑期间评估此表达式，并将其显示给最终用户，而不是标准标签（在映射样式中定义）。
			<br>例如，您可以在编辑期间显示具有构造型， <code>&lt;&lt;utility&gt;&gt; Math</code>的类，并仅显示类名<code>Math</code> 。
		</p>
		<p>在“ <em>直接编辑标签”</em>工具中，您<em>必须</em>指定“ <em>编辑蒙版变量”</em>元素。掩码用于解析用户输入的新标签的值，并选择此标签的一部分作为编辑操作主体的输入变量。掩码可以包含<code>{N}</code>形式的子串，其中<code>N</code>是数字。与这些子字符串对应的新标签值的部分将在直接编辑操作的主体中作为变量名称<code>argN</code> （字符串）提供。默认掩码为<code>{0}</code> ，这意味着用户输入的整个文本将通过变量<code>arg0</code> 。
		</p>
		<p>
			<em>注意：</em>边缘最多可以有三个不同的标签（一个在中心，一个在每个末端），但是目前如果<em>直接编辑</em>工具与<em>边缘</em>映射相关联，则只能<em>编辑</em>中心标签（如果存在）。在未来版本中可能会取消此限制。
		</p>
		<h4 id="selection_wizard">选择向导</h4>
		<p>此工具可用于打开向导对话框，要求用户选择一个或多个模型元素。然后，在用户选择的元素的上下文中执行工具的主体。</p>
		<p>选择工具后，用户必须首先选择图表元素作为工具的目标。然后会打开一个对话框，其中包含要选择的候选元素列表。使用您在工具描述中指定的表达式从目标计算列表。</p>
		<p><em>窗口标题</em> ， <em>图标路径</em> ， <em>Windows图像路径</em>和<em>消息</em>可用于自定义选择窗口的外观。
		</p>
		<p><em>Candidates Expression</em>应该返回一个元素列表，用户可以从中选择变量的值。默认情况下，这些候选人以列表形式呈现。您还可以启用<em>树</em>模式以<em>树</em>形式显示元素。在这种情况下，您必须指定一个<em>根表达式</em> ，它将提供要在对话框中显示为树项的第一级的元素，以及一个<em>子表达式</em> ，它将从根元素递归地评估每个候选项，以构建一个树可能的价值观。请注意， <em>Root Expression</em>和<em>Children Expression</em>提供了必须包含在<em>Candidates Expression</em>元素中的元素。
			<br>最后，您可以设置<em>Multiple</em>标志以允许用户选择多个候选项而不是单个候选项。
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>如果选择了多个元素，工具主体的执行环境是什么？
			<br></div>
		
		<p>
			<img border="0" src="images/styles/Selection_Tool.png">
		</p>
		<p>请注意， <em>窗口标题</em>标签和<em>消息</em>标签是可<a href="../general/Specifying_Viewpoints.html#translatable_messages"><em>翻译消息</em></a> ，因此可以进行本地化。
		</p>
		<h4 id="pane_based_selection_wizard">基于窗格的选择向导</h4>
		<p>在<em>面板的选择的向导</em>是非常相似的<a href="#selection_wizard">选择向导</a> 。它仅在选择窗口的显示方面有所不同。基于窗格的向导提供了两个面板：左侧是所有候选对象，它们对应于基本<em>选择向导</em>的内容。右边是当前选择。用户具有用于将候选者从左侧面板添加或移除到右侧的按钮的按钮。<em>Pre Selected Candidates Expression</em>可用于定义右侧面板的初始内容。
		</p>
		<p></p><div style="display:none">
			<br>
			<strong>TODO</strong>如果选择了多个元素，工具主体的执行环境是什么？
			<br></div>
		
		<p>
			<img border="0" src="images/styles/Pane-Based_Selection_Tool.png">
		</p>
		<p>请注意， <em>窗口标题</em>标签， <em>消息</em>标签， <em>值选择消息</em>标签和<em>选定值消息</em>标签是可<a href="../general/Specifying_Viewpoints.html#translatable_messages"><em>翻译消息</em></a> ，因此可以进行本地化。
		</p>
		<h4 id="representation_creation">表示创作</h4>
		<p>Sirius支持的每种方言都定义了一种工具，可用于使用此方言创建新的表示。它们是（使用默认支持的方言）： <em>图表创建</em>描述， <em>表创建</em>描述和<em>树创建</em>描述。
		</p>
		<p>这些工具（Sirius支持的每种表示形式之一）可用于从现有图表元素创建（和打开）新表示。它们将在兼容图表元素的“ <em>导航”</em>上下文菜单中供最终用户使用。要配置工具，只需在<em>Mappings</em>属性中选择工具应显示哪些元素（如果需要，可以使用<em>Precondition</em>表达式更精确），并选择应使用<em>Representation Description</em>属性创建的<em>表示</em> （在实践中） ， <em>图表描述</em> ， <em>表描述</em>或<em>树描述之一，</em>取决于工具）。通常，新表示将在由用户调用该工具的图元素表示的语义元素上创建。有时您希望工具出现在一个元素上，但在另一个元素上创建一个表示。在这种情况下，使用“ <em>浏览”表达式</em> （在“ <em>高级”</em>类别中）从所选元素导航到实际应创建新表示的元素。<em>标题表达式</em> （ <em>高级</em>类别）可用于设置新创建的表示的标题。最后，在调用工具时，将执行您在工具正文中指定的任何操作;您可以使用它来初始化所表示的模型的内容。
		</p>
		<h4 id="representation_navigation">表示导航</h4>
		<p>Sirius支持的每种方言都定义了一种工具，可用于导航到该方言的现有表示。它们是（使用默认支持的方言）： <em>图导航</em>描述， <em>表导航</em>描述和<em>树导航</em>描述。
		</p>
		<p>这些工具与<a href="#representation_creation">表示创建工具</a>非常相似。唯一的区别是它们允许用户导航到现有的表示而不是创建新的表示。如果存在此类工具，则元素上的“ <em>导航”</em>上下文菜单将包含已在所选元素上存在的每个对应表示的条目（或者可以使用“ <em>浏览”表达式</em>从所选元素访问）。您可以指定要在菜单项中使用的<em>导航名称表达式</em> （ <em>高级</em>类别），而不是使用现有表示的标题。这有助于更明确地说明当前元素与目标树之间的关系。
		</p>
		<h4 id="double_click_tool">双击</h4>
		<p>此工具用于在用户双击元素时触发操作。<em>Mappings</em>属性指示此工具适用的元素类型。
		</p>
		<p>在工具主体内部， <em>elementView</em>变量引用用户双击的图形元素，而<em>元素</em>变量表示其语义目标元素。
		</p>
		<h4 id="generic_tool">通用工具</h4>
		<p>此通用工具用于提供调色板条目，该条目可以执行内部工具语言中描述的任何代码，包括例如调用外部Java操作。</p>
		<p>在工具主体内部， <em>elementView</em>变量引用用户调用工具的图形元素，而<em>元素</em>变量表示其语义目标元素。
		</p>
		<h4 id="popup_menu">弹出菜单</h4>
		<p>此工具可用于在上下文菜单中定义条目，该条目可包含“ <a href="#operation_action"><em>操作操作”</em></a>和“ <a href="#external_java_action"><em>外部Java操作”</em></a>工具。打开菜单时可见的哪些取决于这些操作的前提条件，因此可以根据当前选择的元素激活或不激活这些操作。可以使用“ <a href="#group"><em>组菜单”</em></a>对操作进行分组。
		</p>
		<h4 id="group">组菜单</h4>
		<p>在图形上，每个<em>组菜单</em>由几个菜单和/或动作之间的水平线分隔：<br>
			<img border="0" src="images/groupSeparator.png">
		</p>
		<p>该组有一个<em>id</em> 。此id可以是现有组的id。在这种情况下，此组中定义的所有菜单和操作都将添加到现有组中。
			<br>该组还有一个<em>位置URI</em> 。这是一个URI规范，用于定义将添加组的插入点。URI的格式由两个基本部分组成：</p>
		<ul>
			<li>方案：“菜单”，“tabbar”之一。指示用于处理贡献的管理器的类型。</li>
			<li>Id：这是现有菜单或标签栏菜单的ID。</li>
		</ul>
		<p>目前，无法在特定现有组之后或之前添加组。它被添加到具有相应<em>id</em>的菜单的末尾。
			<br>对于菜单方案，以下章节详细介绍了现有组和菜单的ID（在现有菜单或组中添加新操作或组）。
			<br>对于tabbar sheme，只能使用新组完成“选择”菜单。要使用的完整位置URI是“tabbar：selectMenu”。要在同一组存在操作中添加操作，必须对声明的组使用id“selectGroup”。
		</p>
		<p>以下是一些例子：</p>
		<ul>
			<li>在主上下文菜单的末尾定义新组：位置URI是“menu”或“menu：root”。</li>
		</ul>
		<p>
			<img border="0" src="images/groupAtEndOfContextualMenu.png">
		</p>
		<ul>
			<li>在现有菜单的末尾定义新组：位置URI是“menu：idOfExistingMenu”，例如“menu：editMenu”。</li>
		</ul>
		<p>
			<img border="0" src="images/groupAtEndOfExistingMenu.png">
		</p>
		<ul>
			<li>在现有组中添加操作或菜单：位置URI是“menu：idOfExistingMenu”，组的ID是现有组的ID，例如“locationURI = menu：editMenu”和“id = copyGroup”。</li>
		</ul>
		<p>
			<img border="0" src="images/groupUsingAnExistingGroup.png">
		</p>
		<ul>
			<li>选择了DDiagramElement的特定情况，要在layoutGroup的layoutGroup中添加动作，必须使用此描述（groupsURI为空白）：</li>
		</ul>
		<p>
			<img border="0" src="images/groupUsingAnExistingGroupOfLayoutMenu.png">
		</p>
		<ul>
			<li>选择了DDiagram的特定情况，要在布局菜单的myArrangeGroup中添加动作，必须使用此描述（groupsURI为空白）：</li>
		</ul>
		<p>
			<img border="0" src="images/groupUsingAnExistingGroupOfDDiagramLayoutMenu.png">
		</p>
		<ul>
			<li>在新菜单中定义新组：位置URI必须为空。
				<em>GroupMenu</em>在<em>PopupMenu</em>下明确定义。
			</li>
		</ul>
		<p>
			<img border="0" src="images/newGroupInNewMenu.png">
		</p>
		<ul>
			<li>在标签栏的“全选”下拉菜单中添加一个组：位置URI为“tabbar：selectMenu”。只有选择菜单可用于标签栏。</li>
		</ul>
		<p>
			<img border="0" src="images/groupInTabbar.png">
		</p>
		<p>
			<em>注意：</em>如果您的VSM位于运行时环境工作空间中以进行VSM的动态开发，则更改不会系统地反映在菜单中。可能需要更改选择（重建菜单）。
		</p>
		<h5 id="Idofexistingmenusandgroups">现有菜单和组的ID</h5>
		<p>本章列出了Sirius图表示中现有菜单和组的ID。它必须用于位置URI或<em>组菜单</em>的ID。
		</p>
		<p>
			<b>图元素的上下文菜单</b> 
		</p>
		<p>
			<img border="0" src="images/siriusDefaultDiagramElementContextualMenu.png">
		</p>
		<p>相应的ID：</p>
		<ul>
			<li>菜单新（id = popup.new）<ul>
					<li>组createRepresentationGroup</li>
				</ul>
			</li>
			<li>菜单打开（id = popup.open）<ul>
					<li>组openRepresentationGroup</li>
				</ul>
			</li>
			<li>组editGroup<ul>
					<li>菜单编辑（id = editMenu）<ul>
							<li>组copyGroup</li>
							<li>组copyFormatGroup</li>
							<li>组deleteFromGroup</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>组filterFormatGroup<ul>
					<li>菜单<del>显示隐藏</del> （id = org.eclipse.sirius.diagram.ui.popup.hideReveal）：不可用，因为它是由Sirius提供的</li>
					<li>菜单格式（id = formatMenu）<ul>
							<li>组fontFillLineGroup<ul>
									<li>菜单行宽（id = lineWidthMenu）</li>
									<li>菜单行类型（id = lineTypeMenu）</li>
									<li>菜单箭头类型（id = arrowTypeMenu）</li>
								</ul>
							</li>
							<li>集团杂项集团<ul>
									<li>菜单布局（id = arrangeMenu）：这是一个特定的情况，此菜单稍后在格式菜单之前移动。
										<ul>
											<li>集团安排集团</li>
											<li>组pinGroup</li>
										</ul>
									</li>
									<li>菜单对齐（id = alignMenu）<ul>
											<li>组alignHorizontalGroup</li>
											<li>组alignVerticalGroup</li>
										</ul>
									</li>
									<li>菜单分发（id = distributeMenu）<ul>
											<li>组distributeHorizontalGroup</li>
											<li>group distributeVerticalGroup</li>
										</ul>
									</li>
									<li>菜单文本对齐（id = textAlignmentMenu）<ul>
											<li>组textAlignmentGroup</li>
										</ul>
									</li>
									<li>菜单顺序（id = zorderMenu）<ul>
											<li>组zorderGroup</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>组sizeGroup</li>
							<li>组applyAppearanceGroup</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>组添加（最后的默认组）</li>
		</ul>
		<p>
			<b>图的上下文菜单</b> 
		</p>
		<p>
			<img border="0" src="images/siriusDefaultDiagramContextualMenu.png">
		</p>
		<p>相应的ID：</p>
		<ul>
			<li>组editGroup<ul>
					<li>菜单编辑（id = editMenu）<ul>
							<li>组copyGroup</li>
							<li>组copyFormatGroup</li>
							<li>组deleteFromGroup</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>组filterFormatGroup<ul>
					<li>菜单选择（id = selectMenu）<ul>
							<li>组selectGroup</li>
						</ul>
					</li>
					<li>菜单布局（id = arrangeMenu）：这是一个特定的情况，此菜单稍后在格式菜单之前移动。
						<ul>
							<li>将myArrangeGroup分组</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>组org.eclipse.sirius.diagram.ui.popup.otherActions：不可用，因为它是由Sirius贡献的</li>
			<li>组添加（最后的默认组）</li>
		</ul>
		<h4 id="operation_action">行动动作</h4>
		<p>此工具可用于定义将在上下文菜单中显示为条目的操作（或在<em>弹出菜单</em>元素内定义的子菜单中）。调用时，将使用<em>views</em>变量执行操作的主体，该变量引用在图上选择的所有表示元素。
		</p>
		<h4 id="external_java_action">外部Java动作</h4>
		<p><em>外部Java操作</em>工具只是在上下文菜单中创建一个菜单项，它直接调用您可以定义的任何<a href="../general/Model_Operations.html#external_java_action">外部Java操作</a> 。
		</p>
		<h4 id="request_description">请求</h4>
		<p>此工具仅供高级用途使用。它需要理解和扩展GMF，即Sirius用于显示图表的图形框架。<em>请求</em>描述工具将在调色板中提供项目，并且当在图形元素上调用时，它将向相应的编辑部分发送GMF请求。要发送的请求的<em>类型</em>在<em>Type</em>属性中指定为固定字符串。目标编辑部分应具有能够理解并响应请求的编辑策略。</p>
		<p></p><div style="display:none">
			<br>H4（#behavior_tool）。行为工具<br>
			<strong>TODO</strong>明白这完全是什么，并决定我们是否要保留它。如果我们保留它，请记录下来。
			<br></div>
		
		<h2 id="filters">过滤器</h2>
		<p>图表可以定义任意数量的过滤器，用户可以动态启用或禁用这些过滤器以显示或隐藏图表的某些元素。过滤器在三个要点上与图层不同：</p>
		<ul>
			<li>它们更精细，它们可以根据各自的特征有选择地隐藏或显示元素，而图层可以激活或停用整个映射类型。</li>
			<li>它们纯粹是图形化的：即使某些表示元素在用户视图中隐藏，它们仍然存在;</li>
			<li>他们没有与工具的链接，他们无法显示或隐藏工具。</li>
		</ul>
		<p>要向图中添加过滤<em>器</em> ，请在<em>Diagram Description</em>元素内创建<em>Composite Filter</em> ，指定其<em>Name</em> （固定字符串），并在其中添加一个或多个<em>Mapping Filter</em>或<em>Variable Filter</em>元素。
		</p>
		<h3 id="mapping_filter">映射过滤器</h3>
		<p>映射过滤器适用于某些映射的所有元素实例，并可根据可配置条件过滤其中一些映射过滤器。</p>
		<p><em>映射过滤器</em>的<em>Filter Kind</em>属性可以是<code>HIDE</code> ，它将从视图中完全删除元素，或者<code>COLLAPSE</code> ，它将其大小最小<code>COLLAPSE</code> 4×4像素的小透明方块。折叠模式很有用，因为在折叠元素时，使用过滤元素作为源或目标的边仍然可见，而在隐藏元素时它们会消失。
		</p>
		<p><em>Mappings</em>属性指示过滤器将应用的映射列表。
		</p>
		<p>将在指定映射的每个实例的目标语义元素的上下文中评估<em>语义条件表达式</em> 。如果元素应该保持可见，它应该返回<strong>true</strong> ，如果应该隐藏/折叠它应该返回<strong>false</strong> 。
		</p>
		<p><em>视图条件表达式</em>类似于<em>语义条件表达式</em> ，但是在指定映射的每个实例的<em>视图元素</em>的上下文中进行评估。view元素是Sirius用来表示图形元素的模型元素。使用这些表达式需要了解Sirius使用的视图模型的结构。
		</p>
		<p>两个表达式都是可选的如果未指定，则过滤器将不起作用。如果同时指定了两者，则只隐藏/折叠两个表达式都返回<strong>false</strong>的元素。
		</p>
		<p>每当刷新图表时（在默认的<em>自动刷新</em>模式下，只要语义模型发生更改），就会评估所有活动过滤器的表达式，而不仅仅是在用户启用过滤器时。这意味着如果活动过滤器执行复杂测试，它们会对性能产生很大影响，因此在编写条件表达式时请记住这一点。
		</p>
		<h3 id="variable_filter">可变过滤器</h3>
		<p><em>变量过滤器</em>类似于<em>映射过滤器</em> ，除了不使用映射列表来选择要过滤的候选元素，所有表示的元素都是候选元素，但可以使用语义条件表达式进行过滤。
			<br>在该表达式中，说明符可以使用在变量过滤器中定义的变量。
		</p>
		<ul>
			<li>选择模型元素变量：它会打开一个对话框，用户可以从中选择一组EObject。对话框的配置使用与<a href="#selection_wizard">选择向导</a>工具相同的属性和语义。有关详细信息，请参阅其文档。
			</li>
			<li>键入的变量：请参见<a href="#filter_with_typed_variable">使用类型变量的过滤器</a> 
			</li>
		</ul>
		<h4 id="filter_with_typed_variable">使用类型变量进行过滤</h4>
		<p>Typed Variable是一个变量，其值类型是由说明符选择的<em>EDataType</em> ，并且在应用变量过滤器时由用户填充该值。
			<br>解释的表达式允许定义默认值。
		</p>
		<p>
			<img border="0" src="images/typedVariable_PropertyView.png">
		</p>
		<p>当用户应用带有类型变量的变量过滤器时，会显示一个对话框以允许用户输入值。
			<br>在提示所有“ <em>选择模型元素”</em>向导后，将提示此对话框。
			<br>它包含与变量过滤器下的类型变量数一样多的行。
			<br>用户文档在问号上显示为工具提示。
			<br>默认值是VSM上定义的解释表达式的结果。</p>
		<p>
			<img border="0" src="images/dialog_TypedVariableValue.png">
		</p>
		<p>
			<strong>EDataType类实例化</strong>
		</p>
		<p>请注意，无论变量类型是什么，该字段都是文本字段。</p>
		<p>为了使EDataType类可实例化，用户给出的值应遵循依赖于EMF机制如何触发的规则。
			<br>如果EDataType的EFactory未重载，则与EDataType对应的类必须具有带String参数的构造函数。在实例化时，字符串参数将是用户输入的字符串。例如，此字符串参数将转换为类构造函数中的右侧数据。
			<br>在上述构造函数中完成的操作也可以重载EDataType类EFactory。
		</p>
		<p>例：<br>如果您的类表示具有int类型的两个字段x和y的点坐标，则用户输入的字符串可以是<em lang="integer">[integer]</em> 。可以通过<em>用户文档</em>向用户提供此类信息
		</p>
		<h2 id="validation">验证规则</h2>
		<p>图表描述可以定义自定义验证规则，这些规则仅在启动此图表实例的验证时应用（使用上下文菜单中的<em>验证</em>操作）。要定义验证规则，必须首先在图中创建<em>Validation</em>元素，然后添加一个或多个<em>语义验证规则</em>或<em>视图验证规则</em> 。两种规则都是相似的，但语义规则检查底层语义模型的结构，视图验证规则可以检查表示本身的结构。违反规则时，图表上将出现有问题的元素和“ <em>问题”</em>视图中的标记。
		</p>
		<p>每个规则都有一个<em>Level</em> ，表示违反时的严重程度。它可以是<em>信息</em> ， <em>警告</em>或<em>错误</em> 。它还具有计算的<em>Message</em>表达式（在checked元素的上下文中计算），以向用户提供检测到的问题的解释。语义验证规则必须指定<em>目标类</em> ，并将在语义模型中检查该类的所有实例。查看验证规则而不是作为其应用的映射的<em>目标</em>列表。
		</p>
		<p>在规则内部，您必须定义一个或多个<em>Audit</em> ，它使用<em>Audit Expression</em>执行实际检查。将在要检查的每个（语义或图形）元素上计算表达式，如果违反规则，则必须返回<em>false</em> 。如果规则包含多个审核，则在其中至少有一个检测到问题时会触发该审核。
		</p>
		<p>您还可以在规则中定义一个或多个<em>修复</em> 。违反规则时，如果它定义了修订，则相应标记的上下文菜单中的最终用户可以使用这些修订。每个修复程序都有一个名称和一个正文。使用任何可用的<a href="../general/Model_Operations.html">模型操作</a> ，以与工具主体相同的方式定义主体。如果可能，它应该在模型中执行任何所需的更改以修复验证规则检测到的问题。
		</p>
		<h2 id="extensibility">图表可扩展性功能</h2>
		<p>Sirius特别支持扩展和优化图表描述和映射，而无需修改原始图表。当启用定义它们的视点时，将透明地应用扩展，并在禁用视点时将其删除。</p>
		<p>例如，如果基本视点<em>V1</em>定义了图表描述<em>D</em> ，则可以定义单独的视点<em>V2</em> （甚至可以从不同的插件内部定义，您不需要访问<em>V1</em>的源），并在<em>V2中</em>定义扩展<em>DE</em>到<em>D.</em>当用户仅启用<em>V1时</em> ，他们会看到<em>V1中</em>定义的<em>D.</em>当它们启用<em>V1</em>和<em>V2时</em> ， <em>D</em>由<em>DE</em>自动扩展。</p>
		<p>请注意，给定的图表类型可以同时通过多个扩展进行扩展。但是，如果多个扩展尝试重新定义基本图中定义的元素（而不是仅添加新元素），则不会指定结果。</p>
		<h3 id="diagram_extension">图表扩展</h3>
		<p><em>图表扩展</em>直接在<em>Viewpoint</em>元素中定义，它必须使用<em>Viewpoint URI</em>和<em>Representation Name</em>属性精确指定它扩展的图表描述（ <em>Name</em>属性是扩展本身的名称）。
		</p>
		<p><em>Viewpoint URI</em>指示扩展图定义在哪个视点中。它具有以下语法： <code>viewpoint:/pluginId/ViewpointName</code> ，其中<code>pluginId</code>是定义视点的Eclipse插件的标识符， <code>ViewpointName</code>是<code>ViewpointName</code>的名称。请注意，该插件所贡献的所有VSM中定义的所有视点中的名称必须唯一。
		</p>
		<p><em>表示名称</em>只是要扩展的图表的标识符（ <em>Id</em>字段），它在指定的视点内定义。
		</p>
		<p>如果<em>图表扩展</em>支持未在扩展图中表示的元素类型，则它可以指定它所代表的语义元素的<em>元模型</em> 。在<em>图表扩展中</em> ，您可以定义<a href="#validation">验证规则</a> ， <a href="#filters">过滤器</a>和其他<a href="#layers">图层</a> 。当扩展被启用时（即，当它被定义的视点和它扩展的视点都被启用时），扩展中定义的元素将被合并（添加）到基础图的定义中，就像它们已经直接在基础图。
		</p>
		<p>图表扩展的最简单用例是使用新的图形元素，工具，过滤器和验证规则简单地<em>扩充</em>基础图。但是，您也可以使用<em>Mapping Import</em>的概念来<em>修改</em>某些基本图的映射的定义。
			<em>映射导入</em>实际上与图扩展无关，并且可以在常规图描述中使用，因为它们的语义是根据层激活定义的，但它们的主要用例是使用图扩展时。
		</p>
		<p>您可以在<em>Viewpoint URI</em>和<em>Representation Name</em>字段中使用正则表达式。这允许使用一个<em>图表扩展</em>来扩展几个图表。您应该仅使用正则表达式来定义仅包含<a href="#customization">样式自</a>定义的<em>图表扩展</em> 。
			<br>如果这些字段至少包含以下字符之一，则这些字段被视为正则表达式：“*”，“[”，“]”，“（”，“）”或“？”。
		</p>
		<h3 id="mapping_imports">映射导入</h3>
		<p>映射导入用于<em>专门化</em> （修改）在其他位置（在其他层，其他图形表示或其他视点中）定义的映射。此功能仅适用于图表类型表示。
		</p>
		<p>例如，如果层<em>L1</em>定义映射<em>M1</em>并且另一层<em>L2</em>定义导入<em>M1</em>的映射导入<em>M2</em> ，则<em>M2</em>可以覆盖/重载<em>M1的</em>一些特征，如更具体的“语义候选表达”或条件样式考虑到其他具体方面。当仅激活<em>L1时</em> ，应用<em>M1</em>的正常定义。如果<em>L2</em>也被激活，则应用<em>M2</em>而不是<em>M1</em> ， <em>M2中</em>的过载特征替换<em>M1</em>的那些，并且添加新定义的特征或子元素。
		</p>
		<p>您可以定义<em>节点映射导入</em> ， <em>容器映射导入</em>或<em>边缘映射导入</em> 。他们都以同样的方式行事。对于每个，您必须指定<em>导入的映射</em> （通常来自您正在扩展的图表中或在同一图表中定义的另一个层）。映射导入具有普通映射的所有属性，但是当您在映射导入中为属性设置显式值时：</p>
		<ul>
			<li>如果它是属性（例如， <em>语义候选表达式</em> ），则映射导入中定义的值将覆盖导入的映射中定义的值。
			</li>
			<li>如果它是引用（例如， <em>节点映射导入</em>上的<em>重用的边界节点映射</em> ），则<em>映射导入中</em>定义的值将<em>添加</em>到导入的映射中定义的值。
			</li>
		</ul>
		<p>两个特定于导入映射的参数可以更改此最后一个行为：</p>
		<ul>
			<li>如果设置了<em>Inherits Ancestor Filters</em>标志，则应用于导入的映射的<a href="#mapping_filter">映射过滤器</a>也将应用于导入本身。但是，如果你<strong>不想</strong>继承这些过滤器，你可以取消选中<em>继承祖先过滤</em>标志。在这种情况下，只有明确针对导入映射的映射过滤器才会应用于它。
			</li>
			<li>如果设置了<em>Hide Sub-Mappings</em>标志，那么当导入映射处于活动状态时，只会考虑它明确定义的子映射（包括边界节点映射）。这与使用导入映射和导入映射中定义的子映射的标准行为不同。例如，这意味着如果导入的映射定义了边界节点映射，则映射导入可以使用此标志<em>隐藏</em>这些边界节点，而不是定义其自己的任何边界节点映射。
			</li>
		</ul>
		<h2 id="customization">图表样式自定义</h2>
		<p>图元素支持条件样式，可用于根据某些任意条件完全更改元素的外观。但是，当您只想自定义元素样式的特定方面（例如单个颜色）时，定义完整的条件样式可能很麻烦。使用<em>样式自定义</em>元素可以实现更细粒度的样式<em>自定义</em> 。
		</p>
		<p>要使用此功能，必须首先在图层内创建<em>样式自定义</em>元素（从“ <em>新建自定义...”</em>上下文子菜单）。图层中只能存在一个这样的元素，它可以作为图层定义的所有样式自定义的容器。在<em>样式自定义</em>内部，您可以定义任意数量的单独<em>样式自定义</em>元素，每个元素重新分组一组实际自定义，可以是<em>属性自定义（通过表达式）</em>或<em>属性自定义（通过选择）</em> 。两种工作原理相同，您必须定义：</p>
		<ul>
			<li>要使用“ <em>应用于”</em>属性进行自定义的样式元素。如果自定义应该应用于不同的样式元素或应用于给定元素的不同样式（例如，默认和部分或全部条件样式），则可以指定多个样式。
			</li>
			<li>要使用“ <em>属性名称”</em>字段进行自定义的功能（您可以使用<em>Ctrl + Space</em>完成查看可能值的列表，具体取决于您在“ <em>应用于”中</em>选择的元素）。
			</li>
			<li>最后是为该功能设置的值。对于引用（ <em>属性自定义（通过选择）</em> ），您必须从组合框中的可用选项中选择实际值。对于属性（ <em>属性自定义（通过表达式）</em> ），使用在其自定义样式的语义元素的上下文中计算的解释表达式计算该值。
			</li>
			<li>“ <strong>全部应用”</strong>选项提供了为图表中可用的所有样式自定义功能的可能性。该选项可以避免您制作要自定义的所有样式的详尽列表。您还可以使用Viewpoint URI和Representation Name字段中的正则表达式使您的自定义可用于多个表示（有关详细信息，请参阅<a href="#diagram_extension">图表扩展说明</a> ）。
			</li>
		</ul>
		<p><em>样式定制</em>可以定义谓词表达式以控制它是否应该应用。如果已定义，则在语义元素的上下文中计算表达式，以确定是否应该应用自定义。如果未定义表达式，则将应用自定义。如果一个<em>类型的自定义</em>适用于给定的元件，该元件通常具有<em>基本样式</em>将通过在<em>样式定制</em>定义，如果它们是与基本样式兼容应用所有<em>属性定制</em> （由表达，并通过引用）进行修改。
		</p>
		<p><em>样式自定义</em>组还可以包含<em>样式自定义重用</em>元素。这些可用于重用在不同上下文中定义的自定义（使用<em>Reuse</em>属性指定），并将它们应用于其他元素（使用<em>Applied On</em>属性指定）。它们的行为就好像它们是在<em>Style Customization中</em>本地<em>定义的</em> ，没有前提条件。
		</p>
		<h3 id="enum_customization">样式自定义Enumerator属性</h3>
		<p>要自定义Enumerator类型的属性，值表达式必须返回Enumerator的实例。以下是值表达式的一些示例：</p>
		<ul>
			<li>sourceArrow属性的示例（种类<code>EdgeArrows</code> ）：<ul>
					<li>
						<code>AQL：图:: EdgeArrows :: FillDiamond</code>
					</li>
					<li>
						<code>aql:'FillDiamond'</code>或<code>FillDiamond</code>也可以使用，但不建议使用Enumerator实例的文字值。
					</li>
				</ul>
			</li>
			<li>labelFormat属性的示例（类型为<code>EList&lt;FontFormat&gt;</code> ）：<ul>
					<li>
						<code>aql:viewpoint::FontFormat::bold</code>以<code>aql:viewpoint::FontFormat::bold</code>设置标签</li>
					<li>
						<code>aql:OrderedSet{viewpoint::FontFormat::bold, viewpoint::FontFormat::italic}</code>以粗体和斜体设置标签</li>
					<li>
						<code>service:fontFormatBold()</code> ，服务类似</li>
				</ul>
			</li>
		</ul>
		<pre>public FontFormat fontFormatBold(EObject any) {
        return FontFormat.BOLD_LITERAL;
    }
</pre>
	</body>
</html>