<html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.2.html" rel="next">§B.2版本之间的增加&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
         <div class="sect depth2" id="sB.1">
            <h2 class="sect">§B.1版本之间的段落发生了变化<a class="img" href="sB.1.html" title="PermaLinkto§B.1版本之间的段落发生了变化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="subsect depth3" id="sB.1.1">
               <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.1.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s3.2.a.html" title="§3.2。（a）with clause" class="sect">§3.2。（a）</a> ： <strong>参数映射</strong><p>禁止角色接口中的参数映射。
                        			
                     </p>
                  </li>
                  <li><a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ： <strong>替换绑定</strong><p>禁止不安全地使用多态和原始类型转换。
                        			
                     </p>
                  </li>
                  <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法的签名</strong><p>使两个方法通用，以便可以使用返回值而无需进行转换。
                        				
                     </p>
                  </li>
                  <li><a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ：受<strong>限制的角色</strong><p>改进的解释。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.2">
               <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.1.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.1.e.html" title="§1.2.1。（e）角色特征" class="sect">§1.2.1。（e）</a> ： <strong>角色特征的可见性</strong><p>添加了澄清说明角色可以始终访问其封闭团队有权访问的所有功能。
                        				
                     </p>
                  </li>
                  <li><a href="s2.1.2.e.html" title="§2.1.2。（e）没有自由类型参数" class="sect">§2.1.2。（e）</a> ： <strong>通用角色/基础</strong><p>放宽了有关通用绑定角色的规则。这种变化也包含了先前在<a href="s4.1.b.html" title="§4.1.(b) Prerequisite: Class binding" class="sect">§4.1中</a>的具体限制<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">。（b）</a> 。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.i.html" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a>和<a href="s3.5.f.html" title="§3.5。（f）速记定义" class="sect">§3.5。（f）</a> ： <strong>速记标注的可见性</strong><p>由速记标注绑定定义的角色方法现在可以指定可见性修饰符（另请参见<a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ），否则它将继承其绑定基本方法/字段的可见性修饰符。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断标注的可见性</strong><p>推断为标注绑定的角色方法是<code>public</code> （通过接口推断）或从自我调用/字段访问推断的<code>private</code> 。
                        				
                     </p>
                  </li>
                  <li><a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>没有明确使用推断的字段</strong><p>已添加澄清说明，无法显式调用为推断的字段调用生成的访问器方法。
                        				
                     </p>
                  </li>
                  <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>没有通用角色的callin</strong><p>已经明确规定，通用角色无法定义callin绑定。
                        				
                     </p>
                  </li>
                  <li><a href="s4.2.d.html" title="§4.2。（d）Callin方法" class="sect">§4.2。（d）</a> ： <strong>Callin方法</strong><p>稍微改写并扩展规则以明确表示使用第二级callin绑定确实可以拦截callin方法。
                        				
                     </p>
                  </li>
                  <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法<code>getAllRoles</code></strong><p>更高精度：仅回答<em>绑定</em>角色。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.3">
               <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.1.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字的语法</strong><p>以前，不支持语法<code>R&lt;@t&gt;.class</code> 。此限制已被删除。
                        					
                     </p>
                  </li>
                  <li><a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ： <strong>团队扩展非团队类</strong><p>以前， <code>org.objectteams.Team</code>是所有团队课程的超级班级。因此，团队无法扩展非团队类。通过引入所有团队的新超类型，界面<code>org.objectteams. ，已经消除了这一限制<code>org.objectteams.ITeam</code> 。当成员被移动到新界面时，此更改也会影响<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中的</a>某些段落。
                        					
                     </p>
                  </li>
                  <li><a href="s1.5.e.html" title="§1.5。（e）不同超级之间的优先权" class="sect">§1.5。（e）</a> ： <strong>不同隐式超级之间的优先权</strong><p>纠正了不同超级中优先级规则的不一致性：主要规则一直是隐式继承比显式继承更强，但是，对于不同隐式超级中的优先级，定义了不同的规则。<br>这已被改变，使得不同的隐<em>式</em>超级优先于其封闭团队的优先级，使得来自<em>隐式</em>超级团队的角色与来自<em>显式</em>超级团队的角色更紧密相关。
                        					
                     </p>
                  </li>
                  <li><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）</a> ： <strong>放宽了对基类循环的规则</strong><p><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）中</a>定义的基类循环不再是错误，而是可配置警告。但是，在存在基类循环的情况下，不允许调用（第<a href="s2.4.2.html" title="§2.4.2 Role creation via a regular constructor" class="sect">3.1节</a> <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">（a）</a> ）和基本构造函数调用（第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2节</a> ）。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ： <strong>更改了角色绑定歧义的处理</strong><p>明确的绑定歧义不再是（可抑制的）编译器错误，而是由声明<code>org.objectteams.的需要发出信号<code>org.objectteams.LiftingFailedException</code> 。通过这种方式，诊断可以从团队中非常不特定的位置移动到那些在运行时可能因提升失败而受到影响的应用程序。虽然通常不建议忽略任何<code>LiftingFailedException</code>但在<a href="s2.3.4.b.html" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4。（b）中</a>提到的一些<a href="s2.3.4.b.html" title="§2.3.4。（b）明确的歧义" class="sect">极端</a>情况下，捕获此异常仍然有意义。
                        					
                     </p>
                  </li>
                  <li><a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ： <strong>进一步限制callin绑定后的结果映射</strong><p>澄清<code>after</code> callin绑定<code>after</code>无法使用<code>-&gt;</code>标记来映射结果值。
                        					
                     </p>
                  </li>
                  <li><a href="s4.8.a.html" title="§4.8。（a）优先权声明" class="sect">§4.8。（a）</a> ： <strong>影响callin绑定<code>after</code>优先声明。</strong><p>虽然以前优先声明的效果不明确，但已经定义优先声明中元素的顺序会影响它们的<em>优先级，</em>类似于<a href="s5.1.html" title="§5.1团队激活的影响" class="sect">§5.1</a> 。这意味着与先前的实现相比， <code>after</code>绑定的执行顺序现在是颠倒的。为了在程序中可视化，现在必须使用关键字<code>after</code>标记后绑定的优先声明。
                        					
                     </p>
                  </li>
                  <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ， <a href="s4.10.a.html" title="§4.10。（a）新鲜型参数" class="sect">§4.10。（a）</a> ： <strong>通用的callin绑定</strong><p><a href="s4.10.e.html" title="§4.10.(e) Propagating type parameters" class="sect">稍作</a>修改，为新段落<a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）留出</a>空间。
                     </p>
                  </li>
                  <li><a href="s5.4.1.a.html" title="§5.4.1。（a）方法绑定警卫" class="sect">§5.4.1。（a）</a> ： <strong>定期装订守卫的范围</strong><p>在常规方法绑定防护中删除了关于特殊标识符<code>result</code>的错误句子。由于在评估保护之前应用了参数映射，因此可以通过结果映射（ <a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ）访问结果值。此外，这句话实际上混淆了基础和角色方面。
                        	
                     </p>
                  </li>
                  <li><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ， <a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="sect">§A.3.3</a> ： <strong>语法：泛型方法绑定</strong><p>方法绑定中可能的类型参数的位置已经明确。</p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.4">
               <h4 class="subsect">（4） <span class="title">在OTJLD 1.3和OTJLD 1.4之间</span><a class="img" href="sB.1.4.html" title="PermaLink to（4）OTJLD 1.3和OTJLD 1.4之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ： <strong>没有按需基础进口</strong><p>已经澄清，基础进口不能是按需进口（使用通配符） <code>.*</code> ）。
                        					
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.2.html" rel="next">§B.2版本之间的增加&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html>