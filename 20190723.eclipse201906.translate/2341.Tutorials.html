<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>教程</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="index.html" title="OCL Documentation">
<link rel="prev" href="UnlimitedNatural.html" title="UnlimitedNatural">
<link rel="next" href="CompleteOCLTutorial.html" title="Complete OCL tutorial">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">教程</h1>
<div class="chapter" title="教程">
<div class="titlepage">
<div>
<div>
<h2 class="title">
<a name="Tutorials"></a>教程</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt>
<span class="section"><a href="Tutorials.html#OCLinEcoreTutorial">OCLinEcore教程</a></span>
</dt>
<dt>
<span class="section"><a href="CompleteOCLTutorial.html">完成OCL教程</a></span>
</dt>
<dt>
<span class="section"><a href="SafeNavigationTutorial.html">安全导航教程</a></span>
</dt>
<dt>
<span class="section"><a href="CodeGenerationTutorial.html">代码生成教程</a></span>
</dt>
<dt>
<span class="section"><a href="DebuggerTutorial.html">调试器教程</a></span>
</dt>
<dt>
<span class="section"><a href="ValidationTutorial.html">验证教程</a></span>
</dt>
<dt>
<span class="section"><a href="OCLInterpreterTutorial.html">使用经典OCL</a></span>
</dt>
<dt>
<span class="section"><a href="Extensions.html">扩展（在Unified / Pivot OCL原型中）</a></span>
</dt>
<dt>
<span class="section"><a href="Installation.html">安装Eclipse OCL示例和编辑器</a></span>
</dt>
</dl>
</div>
<p><a class="link" href="Tutorials.html#OCLinEcoreTutorial" title="OCLinEcore教程">OCLinEcore教程</a>展示了如何</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>安装OCL和其他编辑器和示例</p>
</li>
<li class="listitem">
<p>使用OCLinEcore编辑器</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>编辑Ecore元模型</p>
</li>
<li class="listitem">
<p>使用OCL不变量，主体和值来丰富Ecore元模型</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>使用嵌入式OCL验证模型</p>
</li>
<li class="listitem">
<p>使用OCL控制台来练习评估OCL</p>
</li>
<li class="listitem">
<p>为使用嵌入式OCL的Ecore生成Java代码</p>
</li>
</ul>
</div>
<p><a class="link" href="OCLInterpreterTutorial.html" title="使用经典OCL">使用经典OCL教程</a>展示了如何操作</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可以从Java调用OCL解析器</p>
</li>
<li class="listitem">
<p>可以从Java调用OCL评估程序</p>
</li>
</ul>
</div>
<div class="section" title="OCLinEcore教程">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OCLinEcoreTutorial"></a> OCLinEcore教程</h2>
</div>
</div>
</div>
<p>本教程已针对Eclipse Mars进行了更新; Eclipse 4.5，EMF 2.11，OCL 6.0。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一些截图可能会略微过时。</p>
</li>
</ul>
</div>
<div class="section" title="概观">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Overview"></a>概观</h3>
</div>
</div>
</div>
<p>在这个例子中你会</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>使用OCLinEcore文本编辑器创建Ecore模型</p>
</li>
<li class="listitem">
<p>创建Ecore模型的动态实例</p>
</li>
<li class="listitem">
<p>使用OCLinEcore文本编辑器使用OCL丰富Ecore模型</p>
</li>
<li class="listitem">
<p>验证模型并观察OCL浓缩</p>
</li>
<li class="listitem">
<p>使用Interactive OCL控制台执行OCL丰富</p>
</li>
</ul>
</div>
<p>以上都是在不生成任何Java代码的情况下执行的;这些模型利用了EMF的动态功能和OCL集成。</p>
<p>那么你可以</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>创建一个Ecore genmodel</p>
</li>
<li class="listitem">
<p>为Ecore模型生成调用OCL表达式的Java代码。</p>
</li>
</ul>
</div>
<p>有关调试，请参阅<a class="link" href="DebuggerTutorial.html" title="调试器教程">OCL调试器教程</a> 。请参阅<a class="link" href="CodeGenerationTutorial.html" title="代码生成教程">代码生成器教程</a>以获取Java代码</p>
</div>
<div class="section" title="参考">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="References"></a>参考</h3>
</div>
</div>
</div>
<p>本教程假定读者熟悉使用EMF生成模型。读者可参考<a class="ulink" href="/help/topic/org.eclipse.emf.doc/tutorials/clibmod/clibmod.html" target="_new">生成EMF模型</a> 。
				</p>
<p>其他参考：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>对象约束语言：让您的模型为MDA做好准备。 Jos Warmer和Anneke Kleppe。（Addison-Wesley对象技术）</p>
</li>
<li class="listitem">
<p>
							
<a class="ulink" href="http://www.omg.org/spec/OCL" target="_new">OCL规范</a> 。
						</p>
</li>
<li class="listitem">
<p>
							
<a class="ulink" href="http://wiki.eclipse.org/OCL/OCLinEcore" target="_new">OCLinEcore维基页面</a> 。
						</p>
</li>
</ul>
</div>
</div>
<div class="section" title="安装Eclipse OCL示例">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinEcoreTutorial-Installation"></a>安装Eclipse OCL示例</h3>
</div>
</div>
</div>
<p>请参阅<a class="link" href="Installation.html" title="Installing the Eclipse OCL Examples and Editors">安装OCL编辑器</a>的<a class="link" href="Installation.html" title="安装Eclipse OCL示例和编辑器">说明</a> 。
				</p>
</div>
<div class="section" title="故障排除">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Troubleshooting"></a>故障排除</h3>
</div>
</div>
</div>
<p>编辑器目前提供语法和语义验证。它尚未应用所有格式良好的验证规则，因此可能未报告某些问题。这项工作正在进行中。有时会显示虚假错误，可能会因“ <span class="bold"><strong>保存</strong></span> ”而消失，但可能需要关闭编辑器并重新打开。
				</p>
</div>
<div class="section" title="使用Ecore的OCLinEcore文本编辑器">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="UsingtheOCLinEcoretexteditorforEcore"></a>使用Ecore的OCLinEcore文本编辑器</h3>
</div>
</div>
</div>
<p>有许多不同的（兼容的）方法来创建和编辑Ecore模型。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可以从XSD模式文件创建Ecore模型</p>
</li>
<li class="listitem">
<p>可以从Rose模型文件创建Ecore模型</p>
</li>
<li class="listitem">
<p>可以从带注释的Java文件创建Ecore模型</p>
</li>
<li class="listitem">
<p>Sample Ecore Editor提供树编辑</p>
</li>
<li class="listitem">
<p>Ecore Tools项目提供图形编辑</p>
</li>
<li class="listitem">
<p>Papyrus提供可以转换为Ecore的UML编辑</p>
</li>
</ul>
</div>
<p>这里我们介绍提供文本编辑的OCLinEcore编辑器，适用于需要非常重要的OCL浓缩量的情况。</p>
<p>所有上述方法都会更新* .ecore文件，因此用户可以自由选择最适合计划更改的编辑方法。</p>
<div class="section" title="创建一个新的EMF项目">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="CreateaNewEMFProject"></a>创建一个新的EMF项目</h4>
</div>
</div>
</div>
<p>我们将首先为此示例创建一个新项目;所以调用<span class="bold"><strong>File-&gt; New-&gt; Project ...</strong></span>（左键单击“ <span class="bold"><strong>文件”</strong></span>菜单，然后左键单击“ <span class="bold"><strong>新建”</strong></span> ，然后左键单击“ <span class="bold"><strong>项目...”</strong></span> ）。
					</p>
<p>在<span class="bold"><strong>New Project</strong></span>对话框中，单击鼠标左键以展开<span class="bold"><strong>Eclipse Modeling Framework</strong></span> ，然后单击鼠标左键以选择<span class="bold"><strong>Empty EMF Project</strong></span> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-new_project.png"></div>
<p>
					
</p>
<p>左键单击<span class="bold"><strong>Next，</strong></span>然后在<span class="bold"><strong>New Empty EMF Project</strong></span>对话框中输入<span class="bold"><strong>Tutorial</strong></span>作为项目名称。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-new_empty_emf_project.png"></div>
<p>
					
</p>
<p>左键单击<span class="bold"><strong>Finish</strong></span> 。
					</p>
</div>
<div class="section" title="创建一个新的Ecore模型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="CreateaNewEcoreModel"></a>创建一个新的Ecore模型</h4>
</div>
</div>
</div>
<p>我们现在将为此示例创建一个新模型。</p>
<p>首先右键单击<span class="bold"><strong>Tutorial</strong></span>项目中的<span class="bold"><strong>模型</strong></span>文件夹以定义目标文件夹并弹出上下文相关菜单。选择<span class="bold"><strong>New-&gt; Other ...</strong></span>然后从<span class="bold"><strong>OCL</strong></span>类别中选择<span class="bold"><strong>OCLinEcore Ecore文件</strong></span> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-new_oclinecore-ecore.png"></div>
<p>
					
</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>替代的<span class="bold"><strong>OCLinEcore文本文件</strong></span>创建一个* .oclinecore文本文件，该文件更忠实地保留空白和注释，但必须将其转换为* .ecore文件以用于许多建模目的。
						</p>
</blockquote>
</div>
<p></p>
<p>左键单击<span class="bold"><strong>Next</strong></span>并输入<span class="bold"><strong>Tutorial.ecore</strong></span>作为文件名。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-new_ecore_model_dialog.png"></div>
<p>
					
</p>
<p>左键单击“ <span class="bold"><strong>完成”</strong></span>以打开一个编辑器，其中显示了一些最小的示例内容</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>包中的类中的属性或操作或不变量的嵌套</p>
</li>
<li class="listitem">
<p>使用OCL来定义操作的主体</p>
</li>
<li class="listitem">
<p>相反属性的语法</p>
</li>
<li class="listitem">
<p>使用OCL定义不变量和自定义错误消息</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-empty_oclinecore.png"></div>
<p>
					
</p>
<p>通过左键单击编辑器选项卡上的十字来关闭编辑器。</p>
<p>右键单击<span class="bold"><strong>Tutorial.ecore</strong></span>文件，弹出上下文相关菜单，然后选择<span class="bold"><strong>Open With-&gt; Sample Ecore Model Editor，</strong></span>可以看到文件的正常Ecore视图。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-empty_ecore.png"></div>
<p>
					
</p>
<p>通过左键单击编辑器选项卡上的十字来关闭编辑器。</p>
</div>
<div class="section" title="将Ecore模型编辑为OCLinEcore">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcoreMetamodel"></a>将Ecore模型编辑为OCLinEcore</h4>
</div>
</div>
</div>
<p>我们现在将使用OCLinEcore文本编辑器打开Ecore模型并提供一些初始内容。</p>
<p>右键单击<span class="bold"><strong>Tutorial.ecore</strong></span>文件以弹出上下文相关菜单，然后选择<span class="bold"><strong>Open With-&gt; OCLinEcore Editor</strong></span> 。
					</p>
<p>现在，按照以下步骤将以下文本剪切并粘贴到编辑器中。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>选择所有现有内容（例如Ctrl-A）</p>
</li>
<li class="listitem">
<p>全部删除（例如Ctrl-X）</p>
</li>
<li class="listitem">
<p>打开<a class="ulink" href="../references/4100-metamodel.oclinecore" target="_new">[剪切和粘贴文本]</a>
							
</p>
</li>
<li class="listitem">
<p>从浏览器中选择并复制文本（例如Ctrl-A和Ctrl-C）</p>
</li>
<li class="listitem">
<p>在原始编辑器中粘贴（例如Ctrl-V）</p>
</li>
<li class="listitem">
<p>保存内容（例如Ctrl-S）</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-metamodel.png"></div>
<p>
					
</p>
<p>语法在<a class="link" href="OCLinEcore.html" title="OCLinEcore语言">OCLinEcore中</a>定义。它使用'name：type [multiplicity] {properties}'模拟OMG规范。
					</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">import</code>将别名与外部EPackage相关联。
							</p>
</li>
<li class="listitem">
<p>
								
<code class="code">package</code>引入了一个名为的EPackage，nsPrefix和nsURI。</p>
</li>
<li class="listitem">
<p>
								
<code class="code">class</code>引入了一个带有名称和可选超类的EClass。
							</p>
</li>
<li class="listitem">
<p>
								
<code class="code">attribute</code>引入了一个具有数据类型类型（EAttribute）的属性。
							</p>
</li>
<li class="listitem">
<p>
								
<code class="code">property</code>引入了一个具有类类型（EReference）的属性。
							</p>
</li>
<li class="listitem">
<p>
								
<code class="code">#</code>引入了相反的角色名称。
							</p>
</li>
<li class="listitem">
<p>
								
<code class="code">_'xxx'</code>逃脱了一个尴尬或保留的单词标识符。
							</p>
</li>
</ul>
</div>
<p>导入URI是Package的URI，因此在示例中， <code class="code">http://www.eclipse.org/emf/2002/Ecore</code>是模型的URI， <code class="code">#</code>是片段分隔符，而<code class="code">/</code>是包的路径在XMI文档的根目录。
					</p>
<p>完成辅助（Ctrl Space）可用于语法帮助。</p>
<p>格式（Ctrl-Shift F）可用于自动格式化所选范围。</p>
<p>为了发现完成辅助不足的语法，您可以使用测试文件上的Sample Ecore Editor来创建所需的Ecore元素，然后使用OCLinEcore编辑器打开测试文件以查看相应的文本句法。</p>
</div>
<div class="section" title="教程元模型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="TheTutorialMetaModel"></a>教程元模型</h4>
</div>
</div>
</div>
<p>示例元模型使用成员和书籍以及向成员提供书籍贷款来模拟图书馆。可以使用Ecore Tools（不是本教程的一部分）以图形方式查看。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4100-ecore_diagram.png"></div>
<p>
					
</p>
<p>请注意，此图是Ecore Diagram而不是UML Diagram，因此属性的默认多重性是Ecore的[0..1]，而不是OCLinEcore和UML的[1..1]。</p>
<p>另请注意，OCL类型<code class="code">String</code>和<code class="code">Integer</code>映射到Ecore中的<code class="code">EString</code>和<code class="code">EBigInteger</code> 。
					</p>
</div>
</div>
<div class="section" title="创建动态模型实例">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CreateaDynamicModelInstance"></a>创建动态模型实例</h3>
</div>
</div>
</div>
<p>此时，相应的EMF教程将展示如何为元模型生成Java代码以及如何为元模型生成编辑器。这里我们关注建模，所以我们将继续单独使用模型。</p>
<p>上<span class="bold"><strong>创建动态实例</strong></span>在编辑器视图中， <span class="bold"><strong>图书馆</strong></span>双击选中它，然后右键单击以显示上下文相关菜单，然后左键点击<span class="bold"><strong>...</strong></span>开始创建一个新的动态模型<code class="code">Library</code>在其根。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>创建动态实例需要存在有效的* .ecore文件。编辑* .oclinecore文件时它不起作用。</p>
</blockquote>
</div>
<p></p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-create_dynamic_instance.png"></div>
<p>
				
</p>
<p>在<span class="bold"><strong>Create Dynamic Instance</strong></span>对话框中，选择<span class="bold"><strong>Tutorial / model</strong></span>作为父文件夹，输入<span class="bold"><strong>Tutorial.xmi</strong></span>作为动态模型实例的文件名，然后左键单击<span class="bold"><strong>Finish</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-create_dynamic_instance_dialog.png"></div>
<p>
				
</p>
<p>模型将自动打开以进行编辑。如果未使用Sample Reflective Ecore Model Editor打开，请关闭编辑器并使用* Open With-&gt; Sample Reflective Ecore Model Editor明确打开。这给出了模型的树状表示。可以在“属性”视图中看到每个节点的属性。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-initial_model.png"></div>
<p>
				
</p>
<p>（如果“属性”视图不可见，请在编辑器中单击鼠标右键，然后左键单击“ <span class="bold"><strong>显示属性视图”</strong></span> 。）
				</p>
<p>选择库并使用为其命名，例如<code class="code">lib</code> 。
				</p>
<p>从<code class="code">Library</code>的右键菜单中选择<span class="bold"><strong>New Child-&gt; Books Book</strong></span>两次，使用<span class="bold"><strong>New Child-&gt; Loans Loan</strong></span> once和<span class="bold"><strong>New Child-&gt; Members Member</strong></span>三次，用两本书，一个贷款和三个成员填充模型。
				</p>
<p>左键单击以依次选择每个书籍和成员，并使用“属性视图”输入名称，例如<code class="code">b1</code>或<code class="code">m2</code> 。指定b1有一个副本，b2有2个副本。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-model_copies.png"></div>
<p>
				
</p>
<p>书籍和成员现在在大纲中有不同的标题。左键单击以选择贷款并编辑其工作簿和成员属性时，关联的下拉列表具有有意义的条目。指定贷款是针对<code class="code">b2</code>的<code class="code">m3</code> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-model_pull_down.png"></div>
<p>
				
</p>
<p>到目前为止，配置很简单，有三个成员，两本书和一个贷款。我们可以通过右键单击<code class="code">Library</code>节点并左键单击<span class="bold"><strong>Validate</strong></span> <code class="code">Library</code>及其所有子节点来验证这一点。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-validate_menu.png"></div>
<p>
				
</p>
<p>由于模型如此简单，很难有任何错误;编辑执行元模型会阻止大多数非法建模选项，如贷款撰写而不是引用书籍。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-validation_successful.png"></div>
<p>
				
</p>
<p>（如果此时出现错误，“ <span class="bold"><strong>详细信息”</strong></span>按钮将引导您进行一些可能会澄清问题的诊断。将以下XMI粘贴到<span class="bold"><strong>Tutorial.xmi中</strong></span>也应解决入口问题。）
				</p>
<div class="literallayout">
<p>
<code class="code">&lt;?xml&nbsp;version="1.0"&nbsp;encoding="ASCII"?&gt;<br>
&lt;tut:Library&nbsp;xmi:version="2.0"&nbsp;xmlns:xmi="http://www.omg.org/XMI"<br>
&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>
&nbsp;&nbsp;&nbsp;&nbsp;xmlns:tut="http://www.eclipse.org/mdt/ocl/oclinecore/tutorial"<br>
&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://www.eclipse.org/mdt/ocl/oclinecore/tutorial&nbsp;Tutorial.ecore"<br>
&nbsp;&nbsp;&nbsp;&nbsp;name="lib"&gt;<br>
&nbsp;&nbsp;&lt;books&nbsp;name="b1"&nbsp;copies="1"/&gt;<br>
&nbsp;&nbsp;&lt;books&nbsp;name="b2"&nbsp;copies="2"/&gt;<br>
&nbsp;&nbsp;&lt;loans&nbsp;book="//@books.1"&nbsp;member="//@members.2"/&gt;<br>
&nbsp;&nbsp;&lt;members&nbsp;name="m1"/&gt;<br>
&nbsp;&nbsp;&lt;members&nbsp;name="m2"/&gt;<br>
&nbsp;&nbsp;&lt;members&nbsp;name="m3"/&gt;<br>
&lt;/tut:Library&gt;<br>

</code>
</p>
</div>
<p></p>
<p>我们现在将创建另外两个相同的<code class="code">b2</code>乘以<code class="code">m3</code>贷款。这可以方便地通过左键单击以选择现有贷款，键入Ctrl-C进行复制，左键单击以选择<code class="code">Library</code>作为新父项，然后键入Ctrl-V将其粘贴到库上来执行。重复以便有三个相同的贷款。
				</p>
<p>验证图书馆应该仍然是成功的，尽管<code class="code">b2</code>的两个副本明显错误地参与三个贷款。
				</p>
</div>
<div class="section" title="使用OCL丰富元模型">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="EnrichthemetamodelwithOCL"></a>使用OCL丰富元模型</h3>
</div>
</div>
</div>
<p>书籍不能比书籍借用的语义约束是一个简单的约束例子，不能用简单的多重性来表达;需要更强大的功能，可能需要评估几乎任意复杂性的功能。对象约束语言提供此功能。</p>
<p>约束可以作为书上的不变量来实现，该书规定了（（涉及书籍的贷款选择）的大小）小于或等于（书的副本数量）。</p>
<div class="literallayout">
<p>
<code class="code">&nbsp;&nbsp;&nbsp;&nbsp;invariant&nbsp;SufficientCopies:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;library.loans-&gt;select(book=self)-&gt;size()&nbsp;&lt;=&nbsp;copies;<br>

</code>
</p>
</div>
<p></p>
<p>更详细：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>定义了一个名为<code class="code">SufficientCopies</code>的不变量
						
</p>
</li>
<li class="listitem">
<p>在一本书的不变量中， <code class="code">self</code>是被验证的<code class="code">Book</code>的实例。
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">library.loans</code> ，它是<code class="code">self.library.loans</code> ，导航到库，然后导航到库中的所有贷款。
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">-&gt;select(...)</code>是对贷款的集合迭代。它选择其参数表达式为true的每个贷款</p>
</li>
<li class="listitem">
<p>
							
<code class="code">book=self</code> ，这是<code class="code">aLoan : Loan | aLoan.book = self</code> ，在每笔贷款上使用<code class="code">aLoan</code>迭代器来选择那本书正在被验证的书籍</p>
</li>
<li class="listitem">
<p>
							
<code class="code">-&gt;size()</code>是一个收集操作，只计算所选贷款的数量</p>
</li>
<li class="listitem">
<p>
							
<code class="code">&lt;= copies</code> ，它是<code class="code">&lt;= self.copies</code> ，如果它是一致的，则将计数转换为<code class="code">true</code> ，如果不一致，则将其转换为<code class="code">false</code> 。
						</p>
</li>
</ul>
</div>
<p>在修改其元模型之前，请关闭<span class="bold"><strong>Tutorial.xmi</strong></span>编辑器。（请注意，如果在加载模型后更改元模型，则会发生各种令人不快的错误。）
				</p>
<p>将下面显示的不变量添加到元模型中。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-metamodel2.png"></div>
<p>

					
<a class="ulink" href="../references/4100-metamodel2.oclinecore" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>所需的语义由Book的<code class="code">SufficientCopies</code>不变约束表示。对于有效模型，SufficientCopies不变量必须始终为true。
				</p>
<p>如果您重新打开<span class="bold"><strong>Tutorial.xmi</strong></span>编辑器并调用<code class="code">Library</code> <span class="bold"><strong>验证</strong></span> ，您将收到验证错误。左键单击<span class="bold"><strong>详细</strong></span>信息。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-validation_unsuccessful.png"></div>
<p>
				
</p>
<p><span class="bold"><strong>详细信息</strong></span>确定<code class="code">SufficientCopies</code>书籍不满足<code class="code">b2</code>不变量。
				</p>
<p>或者，您可以调用<span class="bold"><strong>实时验证，</strong></span>以便自动使用错误图标和悬停文本识别问题进行验证。
				</p>
<p>如果您现在更改第一笔贷款以便借用<code class="code">b1</code>然后再次验证，则问题得以解决。<code class="code">m3</code>可以借用<code class="code">b1</code>的一个副本和<code class="code">b2</code>的两个副本。
				</p>
<p>在引入无重复贷款的进一步约束之前，我们将展示如何行使OCL表达式。OCL是一种非常强大的紧凑语言;这个例子隐藏了所有贷款的循环。更复杂的示例可能很容易在一行上涉及三个或四个级别的隐藏循环，但可能同样容易出现简单错误。因此，简化表达式并使用辅助操作和属性来模块化它们是有帮助的。然后可以使用OCL控制台执行这些操作，或使用<a class="link" href="Debugger.html" title="调试器（Luna中的新功能）">OCL调试器进行调试</a> 。
				</p>
</div>
<div class="section" title="OCL控制台">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinEcoreTutorial-Console"></a> OCL控制台</h3>
</div>
</div>
</div>
<p>OCL控制台支持在模型实例的上下文中交互执行OCL表达式。</p>
<p>要使OCL控制台可见，首先通过<span class="bold"><strong>Window-&gt; Show View-&gt; Console</strong></span>使<span class="bold"><strong>控制台</strong></span>视图可见。然后右键单击<span class="bold"><strong>Open Console</strong></span>并左键单击<span class="bold"><strong>Interactive Xtext OCL</strong></span> 。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-ocl_console_menu.png"></div>
<p>
				
</p>
<p>或者，您可以从<span class="bold"><strong>Sample Ecore Editor</strong></span>或<span class="bold"><strong>Sample Reflective Ecore Editor中</strong></span>的右键菜单调用<span class="bold"><strong>OCL-&gt; Show Xtext OCL Console</strong></span> 。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p><span class="bold"><strong>Xtext OCL</strong></span>控制台是使用Pivot绑定的基于Xtext的新功能。与使用LPG解析器和Ecore绑定的<span class="bold"><strong>OCL</strong></span>控制台相比，它更快，更符合OCL规范。
					</p>
</blockquote>
</div>
<p></p>
<p><span class="bold"><strong>Interactive Xtext OCL</strong></span>控制台包含两个主要文本窗格。上部窗格显示结果。下部窗格支持输入查询。
				</p>
<p>单击鼠标左键以选择<span class="bold"><strong>Tutorial.xmi中</strong></span>的<code class="code">Library</code>作为查询的上下文，然后在控制台的下部窗格中键入<code class="code">books</code>后跟新行。
				</p>
<p>显示了为库评估此查询的结果。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-books_query.png"></div>
<p>
				
</p>
<p>可以输入跨越许多行的大量OCL查询，因此向上光标和向下光标键在线上移动。如果要访问较早的查询，可以使用<span class="bold"><strong>Page Up</strong></span>或<span class="bold"><strong>Page Down</strong></span>键来保存再次输入。
				</p>
<p>您可以通过依次选择每本书并执行<code class="code">library.loans-&gt;select(book=self)</code>来查看示例不变量内的查询执行情况，以查看<code class="code">b1</code>有一个贷款而<code class="code">b2</code>两个。
				</p>
</div>
<div class="section" title="帮手功能和操作">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinEcoreTutorialHelpers"></a>帮手功能和操作</h3>
</div>
</div>
</div>
<p>我们现在将介绍一些帮助器属性和操作，以使OCL更清晰，并提供更丰富的元模型API。关闭<span class="bold"><strong>Tutorial.xmi</strong></span>编辑器并修改元模型以包含派生的<code class="code">loans</code>属性和辅助操作<code class="code">isAvailable()</code> 。简化不变量以使用派生属性。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-metamodel3.png"></div>
<p>

					
<a class="ulink" href="../references/4100-metamodel3.oclinecore" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>请注意，派生属性也必须是易失性的，以避免在加载模型但没有内容时出现问题。</p>
<p>重新打开<span class="bold"><strong>Tutorial.xmi</strong></span>并选择<span class="bold"><strong>Book b2，</strong></span>以便在<span class="bold"><strong>Properties</strong></span>视图中显示派生属性。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-derived_property.png"></div>
<p>
				
</p>
<p>通过选择book <code class="code">b2</code>并输入<code class="code">isAvailable()</code>来执行，可以在关闭和重新打开后在<span class="bold"><strong>Console</strong></span>视图中评估帮助程序操作。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-helper_operation.png"></div>
<p>
				
</p>
<p>我们现在将添加更多帮助者和约束来强制执行每个成员政策最多两笔贷款，并要求贷款是唯一的。</p>
<p>（不要忘记在更改其元模型时关闭<span class="bold"><strong>Tutorial.xmi</strong></span> 。）
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-metamodel4.png"></div>
<p>

					
<a class="ulink" href="../references/4100-metamodel4.oclinecore" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>可以在OCL控制台中评估附加<code class="code">books</code>属性，以显示每个成员借出的书籍。该属性也可以在<span class="bold"><strong>Properties</strong></span>视图中看到。
				</p>
<p>再次选择库并从右键菜单中调用<span class="bold"><strong>Validate</strong></span> 。现在有两个验证失败。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-two_validation_errors.png"></div>
<p>
				
</p>
</div>
<div class="section" title="生成Java代码">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinEcoreTutorial-genmodel"></a>生成Java代码</h3>
</div>
</div>
</div>
<p>我们已经展示了如何使用OCL来丰富Ecore元模型，如何创建和验证模型实例以及如何评估表达式，所有这些都不会生成任何Java代码。</p>
<p>如果您确实生成了Java代码，那么完全相同的工具可用，因此您可以获得一些速度优势。默认情况下，在Eclipse OCL 6.4.0（Photon）版本中，将解释为OCL生成的Java代码，因此仅对EMF模型进行速度增益。在<a class="link" href="CodeGenerationTutorial.html" title="代码生成教程">代码生成教程中</a> ，描述了OCL到Java代码生成器的初步版本，速度提高了大约五倍，并且无需运行时编译。
				</p>
<p>生成Java代码与任何其他EMF项目完全相同。（在EMF 2.8之前，有一个重要的区别;您必须将<span class="bold"><strong>Operation Reflection</strong></span>明确设置为true。在EMF 2.8中，默认值更改为true。）
				</p>
<p>选择<span class="bold"><strong>Tutorial.ecore</strong></span>文件并从右键菜单中调用<span class="bold"><strong>New-&gt; Other ...</strong></span>并选择<span class="bold"><strong>Eclipse Modeling Framework</strong></span>和<span class="bold"><strong>EMF Generator Model</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-new_emf_generator.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>Next</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-new_emf_generator_model.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>Next</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-new_emf_generator_model_ecore.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>Next</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-new_emf_generator_model_load.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>加载</strong></span>和<span class="bold"><strong>下一步</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-new_emf_generator_model_packages.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>完成</strong></span> 。
				</p>
<p><span class="bold"><strong>Tutorial.genmodel</strong></span>编辑器打开。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-gen_model.png"></div>
<p>
				
</p>
<p>大多数默认设置都适用。突出显示可能不是的那个。选择根<span class="bold"><strong>Tutorial</strong></span>并向下滚动<span class="bold"><strong>Properties</strong></span>视图，如果尚未为true，则将<span class="bold"><strong>Operation Reflection</strong></span>设置为true。（从EMF 2.8开始，默认为真。）
				</p>
<p>您现在可以从<span class="bold"><strong>Tutorial</strong></span>的右键菜单调用<span class="bold"><strong>Generate Model Code</strong></span>来生成调用OCL的Java模型。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4100-gen_model_menu.png"></div>
<p>
				
</p>
<div class="section" title="Java详细信息">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="JavaDetails"></a> Java详细信息</h4>
</div>
</div>
</div>
<p>您可以通过查看<span class="bold"><strong>tutorial.util来检查OCL是否出现在Java中<span class="bold"><strong>。TutorialValidator.java</strong></span> ，您可以在其中找到OCL表达式作为在运行时等待编译的String，以及触发编译和执行的validate调用。
					</p>
<div class="literallayout">
<p>
<code class="code">protected&nbsp;static&nbsp;final&nbsp;String&nbsp;MEMBER__AT_MOST_TWO_LOANS__EEXPRESSION&nbsp;=&nbsp;"\n"&nbsp;+<br>
&nbsp;&nbsp;"\t\t\tloans-&gt;size()&nbsp;&lt;=&nbsp;2";<br>

<br>
public&nbsp;boolean&nbsp;validateMember_AtMostTwoLoans(Member&nbsp;member,&nbsp;DiagnosticChain<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diagnostics,&nbsp;Map&lt;Object,&nbsp;Object&gt;&nbsp;context)&nbsp;{<br>
&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;validate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TutorialPackage.Literals.MEMBER,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diagnostics,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"http://www.eclipse.org/emf/2002/Ecore/OCL",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"AtMostTwoLoans",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MEMBER__AT_MOST_TWO_LOANS__EEXPRESSION,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diagnostic.ERROR,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIAGNOSTIC_SOURCE,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0);<br>
}<br>

</code>
</p>
</div>
<p></p>
<p>类似地，在<span class="bold"><strong>BookImpl中，</strong></span>您将找到缓存委托的声明以及引发第一次编译的动态调用。
					</p>
<div class="literallayout">
<p>
<code class="code">protected&nbsp;static&nbsp;final&nbsp;EOperation.Internal.InvocationDelegate<br>
&nbsp;&nbsp;IS_AVAILABLE__EINVOCATION_DELEGATE&nbsp;=&nbsp;((EOperation.Internal)<br>
&nbsp;&nbsp;&nbsp;&nbsp;TutorialPackage.Literals.BOOK___IS_AVAILABLE).getInvocationDelegate();<br>

<br>
public&nbsp;boolean&nbsp;isAvailable()&nbsp;{<br>
&nbsp;&nbsp;try&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(Boolean)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IS_AVAILABLE__EINVOCATION_DELEGATE.dynamicInvoke(this,&nbsp;null);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;catch&nbsp;(InvocationTargetException&nbsp;ite)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;WrappedException(ite);<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p></p>
<p>可以在<span class="bold"><strong>TutorialPackageImpl.createPivotAnnotations（）中</strong></span>找到调用委托的OCL表达式。
					</p>
<div class="literallayout">
<p>
<code class="code">addAnnotation<br>
&nbsp;&nbsp;(getBook__IsAvailable(),&nbsp;<br>
&nbsp;&nbsp;&nbsp;source,&nbsp;<br>
&nbsp;&nbsp;&nbsp;new&nbsp;String[]&nbsp;{<br>
&nbsp;&nbsp;&nbsp;"body",&nbsp;"loans-&gt;size()&nbsp;&lt;&nbsp;copies"<br>
&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="API不变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="APIInvariants"></a> API不变量</h4>
</div>
</div>
</div>
<p>到目前为止我们使用的不变量对类API没有贡献。</p>
<p>如果您希望对执行哪些验证进行细粒度控制，可能是因为在某些增量上下文中并非所有验证都合适，您可以使用不变量的操作形式。</p>
<div class="literallayout">
<p>
<code class="code">&nbsp;&nbsp;class&nbsp;Book<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;sufficientCopies(diagnostics&nbsp;:&nbsp;ecore::EDiagnosticChain,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context&nbsp;:&nbsp;ecore::EMap&lt;ecore::EJavaObject,ecore::EJavaObject&gt;)&nbsp;:&nbsp;Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;body:&nbsp;library.loans-&gt;select(book=self)-&gt;size()&nbsp;&lt;=&nbsp;copies;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;attribute&nbsp;name&nbsp;:&nbsp;String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;attribute&nbsp;copies&nbsp;:&nbsp;Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;library#books&nbsp;:&nbsp;Library;<br>
&nbsp;&nbsp;}<br>

</code>
</p>
</div>
<p></p>
<p>请注意，该操作必须具有布尔返回值（true表示有效）以及诊断和上下文参数。</p>
</div>
</div>
<div class="section" title="摘要">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Summary"></a>摘要</h3>
</div>
</div>
</div>
<p>为了说明如何使用OCL和Ecore作为我们的模型</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>使用OCLinEcore文本编辑器创建了Ecore元模型</p>
</li>
<li class="listitem">
<p>从该元模型创建动态模型实例</p>
</li>
<li class="listitem">
<p>丰富了嵌入式OCL的元模型</p>
</li>
<li class="listitem">
<p>在验证模型时使用嵌入式OCL</p>
</li>
<li class="listitem">
<p>使用Interactive OCL控制台查询模型。</p>
</li>
<li class="listitem">
<p>评估嵌入在控制台中的元模型中的OCL。</p>
</li>
</ul>
</div>
<p>要使用OCL和Ecore作为生成的Java模型，我们有</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>生成的Java利用嵌入式OCL。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>