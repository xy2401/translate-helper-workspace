<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s0.html" rel="prev">&lt;&lt;§0关于本文件</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.html" rel="next">§2角色绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s1">
            <div class="headl">
               <div class="headr">
                  <h1>§1团队和角色</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s1.html">§1团队和角色</a></li>
                  <li><a href="#s1.1">§1.1团队课程</a></li>
                  <li><a href="#s1.2">§1.2角色类和对象</a></li>
                  <li><a href="#s1.3">§1.3角色类的获取和隐式继承</a></li>
                  <li><a href="#s1.4">§1.4姓名冲突</a></li>
                  <li><a href="#s1.5">§1.5团队和角色嵌套</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>团队的基本概念</h3>
               <div class="line"></div>
               <div class="term">团队和角色</div>
               <div class="termdesc">使用修饰符<code>team</code>定义的类称为团队类，或简称为<strong>团队</strong> 。<br>团队的直接内部类称为角色类，或简称为<strong>角色</strong> 。
               </div>
               <div class="line"></div>
               <div class="term">角色继承</div>
               <div class="termdesc">团队之间的继承在其包含的角色之间引入了特殊的继承关系。下面给出了这种<strong>隐式继承</strong>的规则（ <a href="#s1.3.1" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ）。
               </div>
               <div class="line"></div>
               <div class="term">外化角色</div>
               <div class="termdesc">角色通常局限于其封闭团队实例的上下文。根据特定限制， <em>可以</em>使用外化角色的概念（第<a href="#s1.2.2" title="§1.2.2外化角色" class="sect">1.2.2节</a> ）将角色传递到团队之外。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s1.1">
               <h2 class="sect">§1.1团队课程<a class="img" href="s1.1.html" title="PermaLink到§1.1团队类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.1.1" title="§A.1.1ClassDeclaration" class="syntax">→语法§A.1.1</a></div>
               <p>使用修改器<code>team</code>声明的类是<em>团队类</em> （或简称团队）。
                  		
               </p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <em><b>team</b> <b>class</b> MyTeamA</em> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  ...</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <p>团队意味着<em>角色的</em>容器，在以下段落中定义。
                  		
               </p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>public</b> <em><b>class</b> MyRole</em></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    ...</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <p>团队为包含的角色类引入了一种新的继承变体（参见下面的<a href="#s1.3.1" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ）。团队的其他属性（在后面的部分中定义）包括：</p>
               <ul>
                  <li>团队激活（ <a href="s5.html" title="§5团队激活" class="sect">§5</a> ）</li>
                  <li>抽象和实例化（ <a href="s2.5.html" title="§2.5摘要角色" class="sect">§2.5</a> ）</li>
                  <li>宣布以团队方法取消（ <a href="s2.3.2.html" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ）</li>
                  <li><code>org.objectteams.定义的反射函数<code>org.objectteams.ITeam</code> （ <a href="s6.1.html" title="§6.1反思" class="sect">第6.1节</a> ）</li>
               </ul>
               <p>除了这些差异之外，团队类是具有方法和字段的常规Java类，其实例是常规Java对象。
                  		
               </p>
            </div>
            <div class="sect depth2" id="s1.2">
               <h2 class="sect">§1.2角色类和对象<a class="img" href="s1.2.html" title="PermaLinkto§1.2角色类和对象"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1</a></span></h2>
               <p>团队的每个直接内部类都是角色类。就像内部类一样，角色类的每个实例都有一个对其封闭团队实例的隐式引用。这个引用是不可变的。在它可以通过资格赛的标识符访问的角色执行<code>this</code>与球队类的名称，如：</p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>public</b> <em><b>class</b> MyRole</em> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>public</b> <b>void</b> print() { System.out.println("Team: "+ <em>MyTeamA.this</em>); }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <p>根据<a href="s2.4.html" title="§2.4明确的角色创建" class="sect">§2.4的</a>定义，角色实例的创建受到进一步限制。团队还可以像角色类一样定义角色接口。对于角色特定属性，角色接口被视为完全抽象的类。
                  		
               </p>
               <div class="sect depth3" id="s1.2.1">
                  <h3 class="sect">§1.2.1角色的修饰符<a class="img" href="s1.2.1.html" title="PermaLinkto§1.2.1角色的修饰符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.2">↑§1.2</a></span></h3>
                  <p>团队的成员类不能是<code>static</code> 。此外，角色的访问修饰符的使用受到限制，修饰符与常规类具有不同（更强）的语义（见下文）。关于可访问性，团队的行为主要类似于其角色的包。
                     			
                  </p>
                  <div class="subsect depth4" id="s1.2.1.a">
                     <h4 class="subsect">（a） <span class="title">角色类保护</span><a class="img" href="s1.2.1.a.html" title="PermaLink（a）角色类保护"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色类必须只有一个访问修饰符<code>public</code>或<code>protected</code> 。<br>此规则不影响类修饰符<code>abstract</code> ， <code>final</code>和<code>strictfp</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.b">
                     <h4 class="subsect">（b） <span class="title">受保护的角色类</span><a class="img" href="s1.2.1.b.html" title="PermaLink到（b）受保护的角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><code>protected</code>角色只能从封闭团队或其任何子团队中访问。封装的实际边界是封闭的团队<em>实例</em> 。受保护角色的规则在下面的<a href="#s1.2.3" title="§1.2.3受保护的角色" class="sect">§1.2.3</a>中给出。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.c">
                     <h4 class="subsect">（c） <span class="title">公共角色课程</span><a class="img" href="s1.2.1.c.html" title="PermaLink到（c）公共角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>只有<code>public</code>角色可以在其封闭团队之外访问。访问封闭团队实例之外的角色受<strong>外部角色</strong>规则的约束，将在下面定义（第<a href="#s1.2.2" title="§1.2.2外化角色" class="sect">1.2.2节</a> ）。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.d">
                     <h4 class="subsect">（d） <span class="title">抽象角色类</span><a class="img" href="s1.2.1.d.html" title="PermaLink（d）抽象角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果角色类的任何方法无效，则必须将其标记为<strong>抽象</strong> 。<br><em>角色类</em>的<em>方法</em>包括通过继承获得的直接方法和方法。除了常规继承之外，角色类还可以通过隐式继承（第<a href="#s1.3.1" title="§1.3.1角色类的获取和隐式继承" class="sect">1.3.1节</a> ）获取方法。<br>方法可以通过以下任一方式<em>生效</em> ：</p>
                     <ul>
                        <li>实施（即常规方法体），或</li>
                        <li>标注绑定（见<a href="s3.html" title="§3标注绑定" class="sect">§3</a> ）。
                        </li>
                     </ul>
                     <p><a href="s2.5.html" title="§2.5摘要角色" class="sect">§2.5</a>讨论了抽象角色在哪种情况下迫使封闭团队是抽象的。
                        
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.e">
                     <h4 class="subsect">（e） <span class="title">角色特征</span><a class="img" href="s1.2.1.e.html" title="PermaLink到（e）角色功能"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色成员的访问修饰符有一些特殊的解释：</p>
                     <ol>
                        <li>在任何隐<a href="#s1.3.1.c" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">式子</a>角色中也可以看到私有成员（请参阅隐式继承<a href="#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）。<br>与Java中的内部类相比，封闭团队看不到角色的私有成员。
                        </li>
                        <li>角色成员的默认可见性限制了对当前类及其子类（显式和隐式）的访问。
                        </li>
                        <li><code>protected</code>角色成员只能从封闭团队或通过<a href="s4.html" title="§4Callin绑定" class="sect">callin（§4）访问</a> 。
                        </li>
                        <li><code>public</code>角色成员授予不受限制的访问权限。
                        </li>
                     </ol>
                     <p>此外，角色始终可以访问其封闭团队有权访问的所有功能。</p>
                     <p>只能通过<a href="#s1.2.2" title="§1.2.2 Externalized roles" class="sect">外部化角色</a>访问<code>public</code>成员<a href="#s1.2.2" title="§1.2.2外化角色" class="sect">（第1.2.2节）</a> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.f">
                     <h4 class="subsect">（f） <span class="title">静态角色方法</span><a class="img" href="s1.2.1.f.html" title="PermaLink到（f）静态角色方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>与纯Java中的内部类相比，角色类可能确实定义了静态方法。静态角色方法不需要角色实例， <em>但</em>仍需要范围内的团队实例。可以调用静态角色方法：</p>
                     <ul>
                        <li>来自封闭团队，</li>
                        <li>通过callin（见<a href="s4.7.html" title="§4.7使用静态方法绑定Callin" class="sect">§4.7</a> ）。
                        </li>
                     </ul>
                     <p>在静态角色方法中，语法<code>MyTeam.this</code>可用于访问封闭的团队实例。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.1.g">
                     <h4 class="subsect">（g） <span class="title">没有静态初始化器</span><a class="img" href="s1.2.1.g.html" title="PermaLink到（g）没有静态初始化器"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色类的静态字段不得具有非常量初始化表达式。Java已经禁止内部类的静态初始化块（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#262890" class="ext">JLS§8.1.2</a> ）。
                        				
                     </p>
                     <div class="note">
                        <h5>注意：</h5>静态初始化通常提供用于在实例化之前（即，在类加载时）执行初始化代码的手段。在创建任何角色之前，已经执行了两个级别的初始化：（1）（最外部）封闭团队类在加载时执行静态初始化。（2）任何封闭团队在实例化时执行其构造函数。应该可以将任何早期初始化分配给这两个阶段中的任何一个，而不是使用静态角色初始化器。
                        				
                     </div>
                  </div>
               </div>
               <div class="sect depth3" id="s1.2.2">
                  <h3 class="sect">§1.2.2外化角色<a class="img" href="s1.2.2.html" title="PermaLinkto§1.2.2外部化角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.2">↑§1.2</a></span></h3>
                  <div class="syntaxlink"><a href="sA.html#sA.9.2" title="§A.9.2ActactTypeArgument" class="syntax">→语法§A.9.2</a></div>
                  <p>通常，团队将其角色封装起来以防止来自外部的不必要访问。如果角色在其封闭的团队实例之外可见，我们会谈到<strong>外部化角色</strong> 。
                     			
                  </p>
                  <p>外部化角色受特定类型规则的约束，以确保来自不同团队实例的角色实例不会以不一致的方式混合。在存在隐式继承（第<a href="#s1.3.1" title="§1.3.1角色类的获取和隐式继承" class="sect">1.3.1节</a> ）的情况下，可能会出现不一致，从而导致只能在运行时检测到的键入错误。外化角色使用“虚拟类” <a href="#fn1-virtual-classes" class="int">[1]</a>的理论，或者更具体地说是“家族多态性” <a href="#fn2-family-polymorphism" class="int">[2]</a> ，以实现所需的类型安全性。这些理论使用特殊形式的<em>依赖类型</em> 。外化角色具有<em>依赖于团队实例的类型</em> 。
                     			
                  </p>
                  <p><a href="#s1.2.3" title="§1.2.3受保护的角色" class="sect">§1.2.3</a>从有关外化角色的规则中推导出更强大的封装形式。
                     			
                  </p>
                  <div class="subsect depth4" id="s1.2.2.a">
                     <h4 class="subsect">（a） <span class="title">可见度</span><a class="img" href="s1.2.2.a.html" title="永久链接到（a）可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>只能将<code>public</code>角色类的实例外部化。
                        			  	
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.b">
                     <h4 class="subsect">（b） <span class="title">具有锚定类型的声明</span><a class="img" href="s1.2.2.b.html" title="PermaLink to（b）具有锚定类型的声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在团队之外，角色类型仅在相对于现有团队实例（进一步称为“锚定类型”）表示时才是合法的。语法是：</p>
                     <div class="listing plain"><pre><em>final</em> MyTeam myTeam = <i>expression</i>;
<em>RoleClass&lt;@myTeam&gt;</em> role = <i>expression</i>;</pre></div>
                     <p>语法<code>Type&lt;@anchor&gt;</code>是参数化类型的特例，更具体地说是<a href="s9.html" title="§9价值依赖类" class="sect">值依赖类型（§9）</a> 。type参数（即at符号后面的表达式）可以是简单名称或路径。它必须引用团队类的实例。据说角色类型<em>锚定</em>到此团队实例。<br>此语法的类型部分（在尖括号前面）必须是直接包含在给定团队中的角色类型的简单名称（包括通过隐式继承获取的角色）。<br></p>
                     <div class="note">
                        <h5>注意：</h5>以前版本的OTJLD对锚定类型使用了不同的语法，其中角色类型以锚点表达式为前缀，用点（ <code>anchor.分隔<code>anchor.Type</code> ，见<a href="sA.html#sA.6.3" title="§A.6.3锚定类型" class="sect">§A.6.3</a> ）。编译器可能仍然支持该路径语法，但应将其标记为已弃用。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.c">
                     <h4 class="subsect">（c） <span class="title">不可改变的锚</span><a class="img" href="s1.2.2.c.html" title="永久链接到（c）不可变锚"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>将外部化角色的类型锚定到团队实例需要团队由标记为<code>final</code> （即不可变）的变量引用。类型锚可以是路径<code>v.f1.f2...</code>其中<code>v</code>是任何最终变量， <code>f1</code> ...是最后的领域。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.d">
                     <h4 class="subsect">（d） <span class="title">隐式锚</span><a class="img" href="s1.2.2.d.html" title="PermaLink to（d）隐式类型锚点"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>当前团队实例可用作角色类型的默认锚点：</p>
                     <ol>
                        <li>在非静态团队级方法中，默认情况下，角色类型被解释为锚定<code>this</code> （引用团队实例）。即，以下两个声明表达相同：<div class="listing plain"><pre><b>public</b> RoleX getRoleX (RoleY r) { <i> stmts </i> }
<b>public</b> RoleX&lt;@<em>this</em>&gt; getRoleX (RoleY&lt;@<em>this</em>&gt; r) { <i> stmts </i> }</pre></div>
                        </li>
                        <li>类似地， <em>角色方法</em>使用封闭团队实例作为任何角色类型的默认锚点。
                        </li>
                     </ol>
                     <p>请注意， <code>this</code>和<code><em>Outer .this</em></code> 。 <code>this</code>总是<code>final</code> 。<br>编译器使用伪标识符<strong><code>tthis</code></strong>来表示错误消息中的此类隐式类型锚点。
                        			  	
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.e">
                     <h4 class="subsect">（e） <span class="title">一致性</span><a class="img" href="s1.2.2.e.html" title="永久链接到（e）一致性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>两种类型<code>RoleX&lt;@teamA&gt;</code>和<code>RoleY&lt;@teamB&gt;</code>之间的一致性不仅要求角色类型兼容，而且要求团队实例可以证明<em>是同一个对象</em> 。编译器必须能够静态分析锚标识。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.f">
                     <h4 class="subsect">（f） <span class="title">类型锚的替代品</span><a class="img" href="s1.2.2.f.html" title="永久链接到（f）类型锚的替代"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>只考虑两次替换来确定团队身份：</p>
                     <ol>
                        <li>对于类型检查团队方法的应用， <code>this</code>由实际的调用目标<strong>替代</strong> 。对于角色方法， <code><em>Outer</em> .this</code>形式的引用由调用目标的封闭实例代替。
                           					
                        </li>
                        <li>传递上遵循从<code>final</code>标识符到另一个<code>final</code>标识符的分配，即，如果<code>t1, t2</code>是最终的，则在分配<code>t1=t2</code> ，类型<code>R&lt;@t1&gt;</code>和<code>R&lt;@t2&gt;</code>被认为是相同的。否则<code>R&lt;@t1&gt;</code>和<code>R&lt;@t2&gt;</code>是不可通约的。<br>将实际参数附加到方法调用中的形式参数也被视为关于此规则的赋值。
                           					
                        </li>
                     </ol>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.g">
                     <h4 class="subsect">（g） <span class="title">法律背景</span><a class="img" href="s1.2.2.g.html" title="（g）法律背景的永久链接"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>外部化角色的锚定类型可以在以下上下文中使用：</p>
                     <ol>
                        <li>声明属性</li>
                        <li>声明局部变量</li>
                        <li>声明方法或构造函数的参数或结果类型</li>
                        <li>在角色类的<code>playedBy</code>子句中（参见<a href="s2.1.html" title="§2.1播放了关系" class="sect">§2.1</a> ）。
                        </li>
                     </ol>
                     <p>从锚定类型继承是不合法的，因为这需要引用的团队实例的成员资格，这只能通过类嵌套来实现。
                        				
                     </p>
                     <div class="note">
                        <h5>注意：</h5>第4项。- 在给定限制内 - 承认同一个类是一个团队的角色和另一个团队角色的基类的情况。另一种嵌套形式在<a href="#s1.5" title="§1.5团队和角色嵌套" class="sect">§1.5中</a>定义。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.h">
                     <h4 class="subsect">（h） <span class="title">外化创作</span><a class="img" href="s1.2.2.h.html" title="PermaLink（h）外化创作"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>可以使用以下任一等效形式将角色创建为外部化：</p>
                     <div class="listing plain"><pre>outer.<b>new</b> Role()
<b>new</b> Role&lt;@outer&gt;()</pre></div>
                     <p>这要求将封闭实例<code>outer</code>声明为<code>final</code> 。表达式的类型为<code>Role&lt;@outer&gt;</code> ，遵循外化角色的规则。<br>此表达式中的类型<code>Role</code>必须是简单（非限定）名称。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.2.i">
                     <h4 class="subsect">（i） <span class="title">没有进口</span><a class="img" href="s1.2.2.i.html" title="永久链接到（i）没有导入"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>导入角色类型既无用也不合法。<br></p>
                     <div class="note">
                        <h5>理由：</h5>导入类型允许在需要使用完全限定名称的情况下使用非限定名称，即前缀为其包含的类和封闭类的类型。但是，角色包含在团队<i>实例中</i> 。在团队之外，只能使用锚定类型访问角色类型，该类型使用团队实例来限定角色类型。相对于此团队锚点，角色<i>总是</i>使用其简单名称<i>来</i>表示，这使得导入角色无用。
                        				
                     </div>
                     <p>但是，在角色中声明的常量的静态导入是合法的。
                        				
                     </p>
                  </div>
                  <h5 class="listing">示例代码（外化角色）：</h5>
                  <div class="listing example frame" id="l1.2.2-1">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>team</b> <b>class</b> FlightBonus <b>extends</b> Bonus {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>class</b> Subscriber {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>void</b> clearCredits() { ... }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  <b>void</b> unsubscribe(Subscriber subscr) { ... }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="listing example frame" id="l1.2.2-2">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre><b>class</b> ClearAction <b>extends</b> Action {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>  <em>final</em> FlightBonus context;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>  <em>Subscriber&lt;@context&gt;</em> subscriber;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>  ClearAction (<em>final</em> FlightBonus bonus, <em>Subscriber&lt;@bonus&gt;</em> subscr) {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>    context = bonus; <span class="comment">// unique assignment to 'context'</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>    subscriber = subscr;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">14</td>
                           <td><pre>  <b>void</b> actionPerformed () {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">15</td>
                           <td><pre>    subscriber.clearCredits();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">16</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">17</td>
                           <td><pre>  <b>protected</b> <b>void</b> finalize () {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">18</td>
                           <td><pre>    context.unsubscribe(subscriber);</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">19</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">20</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>功效：</h5>
                     <ul>
                        <li>第1-6行显示了已发布示例<a href="http://www.objectteams.org/publications/index.html#NODe02" class="ext">[NODe02]</a>的简洁摘录。在这里，乘客可以是航班奖励计划中的订户。
                        </li>
                        <li>第7-20行显示了<code>Action</code>的子类，用于将重置订户信用的操作与应用程序GUI中的按钮或类似元素相关联。</li>
                        <li>属性<code>context</code> （第8行）和参数<code>bonus</code> （第10行）充当外化角色类型的锚点。
                        </li>
                        <li>属性<code>subscriber</code> （第9行）和参数<code>subscr</code> （第10行）在FlightBonus团队之外存储订户角色。
                        </li>
                        <li>为了在第12行中键入检查赋值，编译器必须确保LHS和RHS的类型锚定到同一个团队实例。这可以通过检查两个锚点确实是<code>final</code>并且在角色分配之前进行团队分配来验证（第11行）。<br><span class="underline">注意，</span>对最终变量的<strong>明确赋值</strong>的Java规则确保在将变量用作类型锚之前，恰好对变量赋值。无需进一步检查。
                           	                
                        </li>
                        <li>现在合法存储此角色引用并在稍后的某个时间点使用它，例如，用于调用方法<code>clearCredits</code> （第15行）。此方法调用也是隐式团队激活的示例（第<a href="s5.3.b.html" title="§5.3。（b）外化角色的方法" class="sect">5.3节（b）</a> ）。
                           					
                        </li>
                        <li>第18行演示了如何将外部化角色传递给团队级方法。<code>unsubscribe</code>的签名是针对此扩展的呼叫<div class="indent">void unsubscribe（订阅者&lt;@context&gt; subscr）</div>（通过将呼叫目标<code>context</code>替换<code>this</code> ）。这证明了实际和形式参数的相同类型。
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect depth3" id="s1.2.3">
                  <h3 class="sect">§1.2.3受保护的角色<a class="img" href="s1.2.3.html" title="PermaLinkto§1.2.3受保护的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.2">↑§1.2</a></span></h3>
                  <p>角色只能是<code>public</code>或<code>protected</code> 。<code>protected</code>角色由其封闭的团队实例封装。这是由以下规则强制执行的：</p>
                  <div class="subsect depth4" id="s1.2.3.a">
                     <h4 class="subsect">（a） <span class="title">进口角色类</span><a class="img" href="s1.2.3.a.html" title="PermaLink（a）导入角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><i>该规则被<a href="#s1.2.2.i" title="§1.2.2.(i) No import" class="sect">§1.2.2</a>取代<a href="#s1.2.2.i" title="§1.2.2。（i）无进口" class="sect">。（i）</a></i></p>
                  </div>
                  <div class="subsect depth4" id="s1.2.3.b">
                     <h4 class="subsect">（b） <span class="title">合格的角色类型</span><a class="img" href="s1.2.3.b.html" title="PermaLink到（b）合格的角色类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><code>protected</code>角色类的名称可能永远不会被限定使用，既不以其<em>封闭类型</em>为前缀，也不以<em>变量</em>参数<em>化为类型锚点</em> （参见<a href="#s1.2.2.a" title="§1.2.2。（a）可见性" class="sect">§1.2.2。（a）</a> ）。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.3.c">
                     <h4 class="subsect">（c） <span class="title">混合合格和不合格的类型</span><a class="img" href="s1.2.3.c.html" title="PermaLink to（c）混合合格和非合格类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>外部化角色类型是不合格的角色类型从不兼容，除了在换人<a href="#s1.2.2.f" title="§1.2.2。（f）类型锚的替代品" class="sect">§1.2.2。（F） ，</a>其中明确锚可以用隐含锚匹配<code>this</code> 。
                        				
                     </p>
                  </div>
                  <p>规则（a）和（b）确保受保护角色类的名称不能在其封闭团队的词法范围之外使用。规则（c）确保在其签名中包含不合格角色类型的团队方法不能在当前团队以外的团队中调用。因此，对于角色方法，团队上下文必须是封闭的团队实例。
                     			
                  </p>
                  <div class="subsect depth4" id="s1.2.3.d">
                     <h4 class="subsect">（d） <span class="title">封装水平</span><a class="img" href="s1.2.3.d.html" title="永久链接到（d）封装级别"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>由于受保护的角色类型不能用于外部化，因此这些类型的实例已经被其封闭团队非常有效地封装。基于这一概念， <em>角色限制</em>规则可以使受保护角色的封装更加严格。相反，即使是受保护的角色也可以外部化为<em>不透明的角色</em> ，这些<em>角色</em>仍然（几乎）没有暴露任何信息。限制和不透明角色是<a href="s7.html" title="§7角色封装" class="sect">§7的</a>主题。
                        				
                     </p>
                  </div>
               </div>
               <div class="sect depth3" id="s1.2.4">
                  <h3 class="sect">§1.2.4型式试验和铸件<a class="img" href="s1.2.4.html" title="Per.1链接到§1.2.4类型测试和演员表"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.2">↑§1.2</a></span></h3>
                  <p>根据<a href="#s1.2.2.e" title="§1.2.2。（e）一致性" class="sect">§1.2.2。（e）</a> ，在OT / J中， <code>instanceof</code>运算符和类型转换具有扩展的角色语义。
                     			
                  </p>
                  <div class="subsect depth4" id="s1.2.4.a">
                     <h4 class="subsect">（a） <span class="title">instanceof</span><a class="img" href="s1.2.4.a.html" title="PermaLink到（a）instanceof"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>对于角色类型，只有当类型的两个组件都匹配时， <code>instanceof</code>运算符才会生成true：动态角色类型必须与给定的静态类型兼容，并且类型锚点必须是同一个实例。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.4.b">
                     <h4 class="subsect">（b） <span class="title">铸造</span><a class="img" href="s1.2.4.b.html" title="永久链接到（b）铸造"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果将转换表达式锚定到与转换类型不同的团队实例，则转换也可能失败。这种失败由<code>org.objectteams.发出信号<code>org.objectteams.RoleCastException</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.4.c">
                     <h4 class="subsect">（c） <span class="title">字面文字</span><a class="img" href="s1.2.4.c.html" title="PermaLink to（c）Class literal"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>形式为<code>R.class</code>类文字动态绑定到当前实例上下文中的类<code>R</code> visible。在其封闭的团队实例之外的角色使用类文字（请参阅<a href="#s1.2.2" title="§1.2.2外化角色" class="sect">§1.2.2</a> ）需要以下语法：</p>
                     <div class="listing plain"><pre>RoleClass<em>&lt;@teamAnchor&gt;</em><strong>.class</strong></pre></div>
                  </div>
               </div>
               <div class="sect depth3" id="s1.2.5">
                  <h3 class="sect">§1.2.5文件结构<a class="img" href="s1.2.5.html" title="PermaLinkto§1.2.5文件结构"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.2">↑§1.2</a></span></h3>
                  <p>就像常规内部类一样，可以在封闭团队的源代码中内联角色类。作为替代样式，可以根据以下规则将角色类存储在单独的<strong>角色文件中</strong> ：</p>
                  <div class="subsect depth4" id="s1.2.5.a">
                     <h4 class="subsect">（a） <span class="title">角色目录</span><a class="img" href="s1.2.5.a.html" title="PermaLink到（a）角色目录"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在团队类的目录中，创建一个新目录，该目录与没有<tt>.java</tt>后缀的团队同名。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.5.b">
                     <h4 class="subsect">（b） <span class="title">角色档案</span><a class="img" href="s1.2.5.b.html" title="PermaLink到（b）角色文件"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色类存储在此目录中（a）。文件名派生自<tt>.java</tt>扩展的角色类名。<br>角色文件必须只包含一个顶级类型。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.5.c">
                     <h4 class="subsect">（c） <span class="title">一揽子声明</span><a class="img" href="s1.2.5.c.html" title="PermaLink到（c）包声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色文件中的角色类将其封装的团队类的完全限定名称声明为其包。角色文件的package语句必须使用<code>team</code>修饰符作为其第一个标记。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.5.d">
                     <h4 class="subsect">（d） <span class="title">参考角色档案</span><a class="img" href="s1.2.5.d.html" title="PermaLink到（d）对角色文件的引用"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>团队应在其javadoc注释中提及使用<tt>@role</tt>标记在外部存储的每个角色类。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.5.e">
                     <h4 class="subsect">（e） <span class="title">角色档案中的法律类型</span><a class="img" href="s1.2.5.e.html" title="PermaLink to（e）角色文件中的合法类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色文件中的类型不能是<code>enum</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.2.5.f">
                     <h4 class="subsect">（f） <span class="title">进口角色档案</span><a class="img" href="s1.2.5.f.html" title="PermaLink到（f）导入角色文件"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色文件可能具有自己的导入。在角色定义中<em>，除了</em>封闭团队的所有导入<em>外</em> ，这些导入都是可见的。只有<code>base</code>导入（参见<a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ） <em>必须</em>在团队中定义。
                     </p>
                  </div>
                  <p>从语义上讲，内联角色类与存储在单独角色文件中的角色类之间没有区别。
                     			
                  </p>
                  <div class="note">
                     <h5>注意：</h5>当前的Java编译器不允许类型具有与包相同的完全限定名称。但是，JLS似乎没有在这方面发表声明。在OT / J中，包和类型被解释为同一个团队，如果它们具有相同的完全限定名称并且都具有<code>team</code>修饰符。
                     			
                  </div>
                  <h5 class="listing">角色文件示例：</h5>
                  <div class="listing example frame" id="l1.2.5-1">
                     <table class="listing">
                        <tr class="lhead">
                           <td colspan="2">在文件<code>org/objectteams/examples/MyTeamA.java</code> ：</td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>package</b> org.objectteams.examples;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre><span class="comment">/**</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre> <span class="comment">* @author Stephan Herrmann</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre> <span class="comment">* @date 20.02.2007</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre> <span class="comment">* @file MyTeamA.java</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre> <span class="comment">* <em>@role MyRole</em></span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre> <span class="comment">*/</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>  ...</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="listing example frame" id="l1.2.5-2">
                     <table class="listing">
                        <tr class="lhead">
                           <td colspan="2">在文件<code>org/objectteams/examples <strong class="blue">/MyTeamA/MyRole.java</strong></code> ：</td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><em><b>team</b> <b>package</b> org.objectteams.examples.MyTeamA;</em></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre><b>public</b> <b>class</b> MyRole {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  ...</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s1.3">
               <h2 class="sect">§1.3角色类的获取和隐式继承<a class="img" href="s1.3.html" title="PermaLinkto§1.3角色类的获取和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1</a></span></h2>
               <p>每个团队类都隐式实现预定义的接口<code>org.objectteams.ITeam</code> 。如果团队类没有显式的<code>extends</code>子句，则它会隐式扩展<code>org.objectteams.Team</code> ，从而为<code>org.objectteams.的方法提供实现<code>org.objectteams.ITeam</code> 。如果团队类扩展了非团队类，则编译器会隐式添加<code>org.objectteams.声明的所有方法的<code>org.objectteams.ITeam</code>到团队课。团队的<code>org.objectteams.类（包括<code>org.objectteams.Team</code> ）必须再次成为一个团队。接口实现不受此规则的影响。
                  		
               </p>
               <p>通过接口<code>org.objectteams.提供的基础设施<code>org.objectteams.ITeam</code>在<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中介绍</a> 。
                  		
               </p>
               <div class="sect depth3" id="s1.3.1">
                  <h3 class="sect">§1.3.1角色类的获取和隐式继承<a class="img" href="s1.3.1.html" title="PermaLinkto§1.3.1角色类的获取和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.3">↑§1.3</a></span></h3>
                  <p>团队从其超级团队中获得所有角色。这种关系类似于内部类的继承，但是接下来定义了一些决定性的差异。两种实现方案中提到<a href="#aux1.1" class="int">以下</a> ，这可以用来实现角色收购的特殊语义（虚拟类和副本继承）。
                     			
                  </p>
                  <h5 class="listing">隐式角色继承</h5>
                  <div class="listing example frame" id="l1.3.1-1">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> S {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>    <b>protected</b> <b>class</b> R0 {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>protected</b> <b>class</b> R1 <em><b>extends</b> R0</em> {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>        <b>boolean</b> ok;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>        R2 m() {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>        <b>void</b> n(<em>R2</em> r) {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>    }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>    <b>protected</b> <b>class</b> R2 {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="listing example frame" id="l1.3.1-2">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">10</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> T <em><b>extends</b> S</em> {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">11</td>
                           <td><pre>    @Override <b>protected</b> <em><b>class</b> R1</em> {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">12</td>
                           <td><pre>        <strong>R2</strong> m() {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">13</td>
                           <td><pre>            if(<em>ok</em>) { <b>return</b> <em>tsuper</em>.m(); }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">14</td>
                           <td><pre>            <b>else</b> { <b>return</b> null; }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">15</td>
                           <td><pre>        }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">16</td>
                           <td><pre>        <b>void</b> doIt() {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">17</td>
                           <td><pre>            n(m());</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">18</td>
                           <td><pre>        }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">19</td>
                           <td><pre>    }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">20</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.a">
                     <h4 class="subsect">（a） <span class="title">角色类获取</span><a class="img" href="s1.3.1.a.html" title="PermaLink（a）角色类获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>扩展超级团队<code>S</code>的团队<code>T</code>具有对应于超级团队的每个角色<code>SR</code>的一个角色类<code>TR</code> 。新类型<code>TR</code> <strong>覆盖</strong> <code>R</code>用于<code>T</code>及其角色的上下文。获取角色类可以是直接的（见下文（b）），也可能涉及覆盖和隐式继承（下面的（c））。
                        				
                     </p>
                     <div class="codecomment">在上面的例子中（代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> ），团队<code>S</code>对类型<code>S.R0</code> ， <code>S.R1</code>和<code>S.R2</code>进行操作，而<code>T</code>对类型<code>T.R0</code> ， <code>T.R1</code>和<code>T.R2</code> 。<br><em>（类似于“ <code>S.R0</code> ”的引用在源代码中实际上是非法的（ <a href="#s1.2.3.b" title="§1.2.3。（b）合格的角色类型" class="sect">§1.2.3。（b）</a> ）。这里它们仅用于说明目的）</em></div>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.b">
                     <h4 class="subsect">（b） <span class="title">直接角色获取</span><a class="img" href="s1.3.1.b.html" title="PermaLink（b）直接角色获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在子团队<code>T</code> ，其超级团队<code>S</code>每个角色<code>SR</code>都可以通过简单名称<code>R</code>而无需进一步声明。
                        				
                     </p>
                     <div class="codecomment"><a href="#l1.3.1-1" class="listing">清单1.3.1-1中</a>的角色<code>R2</code>可用于子团队<code>T</code> （第12行），因为此角色类型是在封闭团队的超类中定义的。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.c">
                     <h4 class="subsect">（c） <span class="title">覆盖和隐含继承</span><a class="img" href="s1.3.1.c.html" title="PermaLink to（c）覆盖和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果团队包含与其超级团队中定义的角色同名的角色类定义，则新角色类将覆盖超级团队中的相应角色，并<strong>隐式继承</strong>其所有功能。这种关系只能通过名称对应来建立。
                        				
                     </p>
                     <p>覆盖继承角色的角色应使用<code>@Override</code>注释进行标记。编译器应该可选地使用警告标记缺少的<code>@Override</code>注释。相反，如果角色标有<code>@Override</code>注释但实际上没有覆盖继承的角色，则会出错。
                        				
                     </p>
                     <p>使用接口覆盖角色类是错误的，反之亦然。最后一个角色不能被覆盖。<br>与常规继承不同， <strong>构造函数</strong>也是沿着隐式继承继承的，并且可以像普通方法一样被覆盖。
                        				
                     </p>
                     <div class="codecomment">在<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> <code>R1</code>在<code>T</code>隐含继承的所有功能<code>R1</code>在<code>S</code> 。这是因为它的封闭团队<code>T</code>扩展了团队<code>S</code> （第10行），角色定义使用相同的名称<code>R1</code> （第11行）。因此，在<code>T.R1</code> （第13行）的方法<code>m()</code>中可以使用属性<code><strong>ok</strong></code> 。<code>T.R1</code>还覆盖<code>S.R1</code>其由标记<code>@Override</code>在第11行注释。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.d">
                     <h4 class="subsect">（d） <span class="title">缺乏分类</span><a class="img" href="s1.3.1.d.html" title="永久链接到（d）缺少子类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>从超级团队直接获取角色和隐式继承不会建立<strong>子类型</strong>关系。给定团队的角色永远不会与任何<em>其他</em>团队的任何角色保持一致（即可替代）。
                        	    <code>SR</code>和<code>TR</code>总是不可通约的。<br><span class="underline">请注意，</span>此规则是<a href="#s1.2.2.e" title="§1.2.2。（e）一致性" class="sect">§1.2.2。（e）</a>的直接结果。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.e">
                     <h4 class="subsect">（e） <span class="title">类型的动态绑定</span><a class="img" href="s1.3.1.e.html" title="PermaLink到（e）类型的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>通过新角色类覆盖获取的角色具有以下含义：如果表示或声明（代表团队<code>T</code>的实例或其包含的角色之一进行评估）引用角色<code>R</code> ，则<code>R</code>将始终解析为<code>TR</code>即使<code>R</code>是在<code>T</code>的超级团队中引入的，即使特定的代码行是从超级团队或其中一个角色继承而来的。只有封闭的team-instance的动态类型用于确定正确的角色类（请参阅下面的示例）。
                        				
                     </p>
                     <p>动态绑定角色类型的一个特例涉及所谓的类文字（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）。角色类文字包含在<a href="s6.1.c.html" title="§6.1。（c）角色的类文字" class="sect">第6.1节中。（c）</a> 。
                        				
                     </p>
                     <p>仅在涉及隐式继承的情况下才严格要求上述内容。然而，它可以帮助直觉，也可以考虑（b）中直接获得的角色<code>TR</code>来覆盖给定的角色<code>SR</code> 。</p>
                     <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1的</a>第17行中，使用<code>m</code>的调用结果调用隐式继承的方法<code>n</code> 。虽然<code>n</code>在定义<code>S</code> （因此与参数类型<code>S.R2, see line 6</code> ）的背景下<code>T</code>它期望的参数<code>T.R2</code> 。这是通过在<code>T</code>的上下文中调用<code>m</code>来正确提供的。</div>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.f">
                     <h4 class="subsect">（f） <span class="title">tsuper</span><a class="img" href="s1.3.1.f.html" title="永久链接到（f）tsuper"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <div class="syntaxlink"><a href="sA.html#sA.5.4" title="§A.5.4TSuperCall" class="syntax">→语法§A.5.4</a></div>
                     <p>隐式继承的超级调用使用new关键字<strong>tsuper</strong> 。虽然<code>super</code>仍然可以在常规继承中使用，但是调用<code>tsuper.m()</code>选择从超级团队获取的相应角色的<code>m</code>版本。
                        				
                     </p>
                     <p>有关角色构造函数的上下文中的<code>tsuper</code> ，请参见第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2</a> <code>tsuper</code> 。
                        				
                     </p>
                     <p><code>tsuper</code>只能用于调用封闭方法或构造函数的相应版本，即表达式<code>tsuper.m()</code>只能在方法<code>m</code> ，两个方法具有相同的签名（参见<a href="s2.3.2.b.html" title="§2.3.2。（b）在宣布解除的范围内超级" class="sect">§2.3.2。（b）</a>对于异常，两种方法的签名略有不同）。
                        				
                     </p>
                     <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中，团队<code>T</code>的角色<code>R1</code>覆盖了<code>S</code>隐式继承的方法<code>m()</code> 。 <code><strong>tsuper</strong> .m()</code>从<code>S.R1</code> （第13行<code><strong>tsuper</strong> .m()</code>调用重写的方法<code>m()</code> ）。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.g">
                     <h4 class="subsect">（g） <span class="title">隐含继承超类型</span><a class="img" href="s1.3.1.g.html" title="PermaLink to（g）隐式继承超类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果角色类具有显式超类（使用<code>extends</code> ），则此关系将沿隐式继承继承。
                        				
                     </p>
                     <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中， <code>T</code>的角色<code>R1</code>将<code>T.R0</code>作为其隐式继承的超类，因为超级团队中的相应角色<code><strong>extends R0</strong></code> （第3行）。
                        				
                     </div>
                     <p>覆盖隐式继承的超类由下面的<a href="#s1.3.2.b" title="§1.3.2。（b）继承和覆盖extends子句" class="sect">§1.3.2。（b）管理</a> 。<br>已实现的接口列表沿隐式继承合并。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.h">
                     <h4 class="subsect">（h） <span class="title">保持可见度</span><a class="img" href="s1.3.1.h.html" title="永久链接到（h）保持可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>角色类必须至少提供与隐式超级角色一样多的访问权限，否则会发生编译时错误（这与<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#227965" class="ext">JLS§8.4.6.3类似</a> ）。由隐式继承覆盖的方法的访问权限遵循与正常覆盖相同的规则。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.i">
                     <h4 class="subsect">（i） <span class="title">构造函数的动态绑定</span><a class="img" href="s1.3.1.i.html" title="PermaLink（i）构造函数的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>使用<code>new</code>创建角色实例时，不仅动态绑定要实例化的类型（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ），但是调用的构造函数也是根据具体类型动态绑定的。<br>在角色构造函数中，所有<code>this(..)</code>和<code>super(..)</code>调用都是静态绑定到显式继承，并且动态地关于隐式继承。这意味着目标角色名称是静态确定的，但使用该名称时，将使用动态绑定确定合适的角色类型。
                        			<br>另见<a href="s2.5.a.html" title="§2.5。（a）使用抽象类进行创建" class="sect">§2.5。（a）</a>关于使用抽象角色类的构造函数。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.j">
                     <h4 class="subsect">（j） <span class="title">覆盖和兼容性</span><a class="img" href="s1.3.1.j.html" title="PermaLink to（j）覆盖和兼容性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#228745" class="ext">JLS§8.4.6</a>的规则也适用于通过隐式继承继承的方法<em>和构造函数</em> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.1.k">
                     <h4 class="subsect">（k） <span class="title">协变回报类型</span><a class="img" href="s1.3.1.k.html" title="PermaLink到（k）协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>给定一组<code>T1</code>与两个角色<code>R1</code>和<code>R2</code> ，其中<code>R2</code>明确地从继承<code>R1</code> ，两个角色定义一个方法<code>m</code>返回某种类型的<code>A</code> 。还给出了一个<code>T1</code> ， <code>T2</code>的子团队，其中<code>T2.R1</code>使用协变返回类型<code>B</code> （ <code>A</code>子类型）覆盖<code>m</code> ：</p>
                     <div class="listing plain"><pre>    <b>public</b> <b>team</b> <b>class</b> T1 {
       <b>protected</b> <b>abstract</b> <b>class</b> R1 {
          <b>abstract</b> A m();
       }
       <b>protected</b> <b>class</b> R2 <b>extends</b> R1 {
          A m() { <b>return</b> <b>new</b> A(); }
       }
    }
    <b>public</b> <b>team</b> <b>class</b> T2 <b>extends</b> T1 {
       <b>protected</b> <b>class</b> R1 {
          @Override B m() { <b>return</b> <b>new</b> B(); } <span class="error">// this declaration renders <b>class</b> T2.R2 illegal</span>
       }
    }</pre></div>
                     <p>在这种情况下角色<code>T2.除非还使用至少为<code>B</code>的返回类型覆盖<code>m</code> ，否则R2</code>将是非法的。注意，实际错误发生在隐式继承的方法<code>T2.R2.m</code>在源代码中不可见，甚至是<code>T2.不需要在源代码中明确提及R2</code> 。编译器应将此标记为团队级别的不兼容性，因为团队必须以一致的方式专门化继承的角色。
                        				
                     </p>
                  </div>
                  <h5 class="listing">示例代码（团队和角色）：</h5>
                  <div class="listing example frame" id="l1.3.1-3">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>protected</b> <b>class</b> MyRole {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    String name;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>    <b>public</b> MyRole (String n) { name = n; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>    <b>public</b> <b>void</b> print() { System.out.println("id="+name); }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>  <b>protected</b> MyRole getRole() { <b>return</b> <b>new</b> MyRole("Joe"); }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="listing example frame" id="l1.3.1-4">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">10</td>
                           <td><pre><b>public</b> <b>team</b> <b>class</b> MySubTeam <b>extends</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">11</td>
                           <td><pre>  <b>protected</b> <b>class</b> MyRole {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">12</td>
                           <td><pre>    <b>int</b> age;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">13</td>
                           <td><pre>    <b>public</b> <b>void</b> setAge(<b>int</b> a) { age = a; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">14</td>
                           <td><pre>    <b>public</b> <b>void</b> print() {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">15</td>
                           <td><pre>      tsuper.print();</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">16</td>
                           <td><pre>      System.out.println("age="+age);</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">17</td>
                           <td><pre>    }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">18</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">19</td>
                           <td><pre>  <b>public</b> <b>void</b> doit() {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">20</td>
                           <td><pre>    MyRole r = getRole();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">21</td>
                           <td><pre>    r.setAge(27);</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">22</td>
                           <td><pre>    r.print();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">23</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">24</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">25</td>
                           <td><pre>...</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">26</td>
                           <td><pre>MySubTeam myTeam = <b>new</b> MySubTeam();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">27</td>
                           <td><pre>myTeam.doit();</pre></td>
                        </tr>
                     </table>
                  </div>
                  <h5 class="listing">程序输出</h5>
                  <div class="listing example frame"><pre>id=Joe
age=27</pre></div>
                  <div class="codecomment">
                     <h5>功效：</h5>
                     <ul>
                        <li>根据<a href="#s1.3" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ， <code>MyTeamA</code>实施了<code>ITeam</code> （第1行）。
                        </li>
                        <li>为<code>MySubTeam.创建了隐式角色继承<code>MySubTeam.MyRole</code> （ <a href="#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ;第11行）。<br>如果我们使用虚构关键字<code>overrides</code>可视化此特殊继承，编译器将看到一个声明：<div class="listing plain"><pre><b>protected</b> <b>class</b> MyRole <em>overrides MyTeamA.MyRole</em> { ... }</pre></div>
                        </li>
                        <li>在<code>myTeam</code>上调用<code>getRole()</code> （第<code>myTeam</code>行）会创建一个<code>MySubTeam.实例<code>MySubTeam.MyRole</code>因为获取的角色<code>MyTeamA.MyRole</code>被<code>MySubTeam.覆盖<code>MySubTeam.MyRole</code>遵循隐式继承的规则（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ）。
                           					 
                        </li>
                        <li>覆盖角色方法和访问继承的功能与往常一样。
                           					
                        </li>
                        <li>作为<a href="#s1.3.1.f" title="§1.3.1.(f) tsuper" class="sect">§1.3.1</a>的示例<a href="#s1.3.1.f" title="§1.3.1。（f）tsuper" class="sect">。（f）</a>参见调用<code>tsuper.print()</code> （第15行），它选择<code>MyTeamA.MyRole.print</code>的实现。
                           						
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect depth3" id="s1.3.2">
                  <h3 class="sect">§1.3.2常规角色继承<a class="img" href="s1.3.2.html" title="PermaLinkto§1.3.2常规角色继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s1.3">↑§1.3</a></span></h3>
                  <p>除了隐式继承之外，角色还可以使用标准Java关键字<code>extends</code>继承。这些限制适用：</p>
                  <div class="subsect depth4" id="s1.3.2.a">
                     <h4 class="subsect">（a） <span class="title">超级限制</span><a class="img" href="s1.3.2.a.html" title="PermaLink（a）超级限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果一个角色的超类再次成为一个角色，它必须是一个封闭团队的直接角色。这个规则只是通过在<code>extends</code>子句中禁止类型锚来强制执行（参见<a href="#s1.2.2.g" title="§1.2.2。（g）法律背景" class="sect">§1.2.2。（g）</a> ）。作为一种效果，超级类可能永远不会比子类更深入地嵌套。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.2.b">
                     <h4 class="subsect">（b） <span class="title">继承和覆盖扩展条款</span><a class="img" href="s1.3.2.b.html" title="PermaLink to（b）继承和覆盖extends子句"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果角色通过隐式继承覆盖另一个角色，则只有当新的超类是重写的extends子句中的类的子类时，它才可以更改继承的<code>extends</code>子句（参见<a href="#s1.3.1.g" title="§1.3.1。（g）隐式继承超类型" class="sect">上面的§1.3.1。（g）</a> ）。即，隐式子角色可以<em>专门</em>化其隐式超级角色的extends子句。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.2.c">
                     <h4 class="subsect">（c） <span class="title">建筑师和被覆盖的'延伸'</span><a class="img" href="s1.3.2.c.html" title="PermaLink to（c）构造函数和覆盖&#39;extends&#39;"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>覆盖其隐式超级角色的extends子句的角色类的每个构造函数都必须调用此新引入的显式超类的构造函数。因此，它可能不使用<code>tsuper</code>构造函数（参见<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">§2.4.2</a> ）。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.2.d">
                     <h4 class="subsect">（d） <span class="title">添加已实现的接口</span><a class="img" href="s1.3.2.d.html" title="PermaLink（d）添加已实现的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><code>implements</code>声明是附加的，即隐式子角色可以添加更多接口，但也必须实现其隐式超级角色的所有接口。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s1.3.2.e">
                     <h4 class="subsect">（e） <span class="title">继承方法的可见性</span><a class="img" href="s1.3.2.e.html" title="PermaLink（e）继承方法的可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>当角色继承了一个普通类（如父类）非公开方式，这些方式被认为是私人的角色，也就是说，它们只能在非限定方法调用访问<code>m()</code>使用隐式接收器<code>this</code> 。
                        				
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s1.4">
               <h2 class="sect">§1.4姓名冲突<a class="img" href="s1.4.html" title="PermaLinkto§1.4名称冲突"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1</a></span></h2>
               <p>OT / J在处理冲突名称时限制Java。
                  		
               </p>
               <div class="subsect depth3" id="s1.4.a">
                  <h4 class="subsect">（a） <span class="title">角色类的名称</span><a class="img" href="s1.4.a.html" title="PermaLink to（a）角色类的名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色类可能与其封闭团队的方法或字段名称不同。角色类可能不会影响在封闭团队范围内可见的另一个类。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s1.4.b">
                  <h4 class="subsect">（b） <span class="title">角色方法和领域的名称</span><a class="img" href="s1.4.b.html" title="PermaLink to（b）角色方法和字段的名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>沿着隐式继承，方法或字段的名称可能不会隐藏，阴影或模糊任何以前可见的名称。<br>（见JLS <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#40898" class="ext">§8.3</a> ， <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#227928" class="ext">§8.4.6.2</a> ， <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#246026" class="ext">第8.5节</a> ， <a href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#78642" class="ext">第9.3节</a> ， <a href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#252566" class="ext">第9.5节</a> （隐藏）， <a href="http://java.sun.com/docs/books/jls/second_edition/html/names.doc.html#34133" class="ext">第6.3.1节</a> （阴影）， <a href="http://java.sun.com/docs/books/jls/second_edition/html/names.doc.html#104058" class="ext">§6.3.2</a> （模糊）。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s1.5">
               <h2 class="sect">§1.5团队和角色嵌套<a class="img" href="s1.5.html" title="PermaLinkto§1.5团队和角色嵌套"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1</a></span></h2>
               <p>类的多级嵌套仅受以下规则的限制。
                  		
               </p>
               <h5 class="listing">示例代码（嵌套）：</h5>
               <div class="listing example frame" id="l1.5">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> SuperOuter {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>public</b> <em><b>team</b> <b>class</b> RoleAndTeam</em> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>protected</b> <b>class</b> InnerRole {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>      Runnable foo() { <b>return</b> null; }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>public</b> <em><b>team</b> <b>class</b> RoleAndTeamSub</em> <b>extends</b> <strong>RoleAndTeam</strong> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    <b>protected</b> <b>class</b> InnerRole {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>      Runnable foo() { <b>throw</b> <b>new</b> RuntimeException(); }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> OuterTeam <b>extends</b> SuperOuter {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>  <b>public</b> <em><b>team</b> <b>class</b> RoleAndTeam</em> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>    <b>protected</b> <b>class</b> InnerRole {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">16</td>
                        <td><pre>      Runnable foo() {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">17</td>
                        <td><pre>        <b>class</b> Local {};</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">18</td>
                        <td><pre>        <b>return</b> <b>new</b> Runnable() { <span class="comment">// anonymous class definition</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">19</td>
                        <td><pre>          <b>public</b> <b>void</b> run() {}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">20</td>
                        <td><pre>        };</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">21</td>
                        <td><pre>      }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">22</td>
                        <td><pre>      <span class="comment">// <span class="error">class IllegalMember {}</span></span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">23</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">24</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">25</td>
                        <td><pre>  <b>public</b> <em><b>team</b> <b>class</b> RoleAndTeamSub</em> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">26</td>
                        <td><pre>    <b>protected</b> <b>class</b> InnerRole {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">27</td>
                        <td><pre>      Runnable foo() {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">28</td>
                        <td><pre>        <em>RoleAndTeamSub.tsuper</em>.foo();</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">29</td>
                        <td><pre>        <b>return</b> <em>OuterTeam.tsuper</em>.foo();</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">三十</td>
                        <td><pre>      };</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">31</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">32</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">33</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="subsect depth3" id="s1.5.a">
                  <h4 class="subsect">（a） <span class="title">嵌套团队</span><a class="img" href="s1.5.a.html" title="PermaLink（a）嵌套团队"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色类也使用<code>team</code>修饰符进行标记，则它可能包含下一级嵌套的角色。
                     			
                  </p>
                  <div class="codecomment">
                     <ul>
                        <li>在上面的示例（ <a href="#l1.5" class="listing">清单1.5</a> ）中，从第14行开始的类<code>RoleAndTeam</code>是<code>OuterTeam</code>的角色，同时包含另一个角色<code>InnerRole</code>的团队</li>
                     </ul>
                  </div>
                  <p>这种混合角色和团队具有两种类的所有属性。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s1.5.b">
                  <h4 class="subsect">（b） <span class="title">嵌套的角色类</span><a class="img" href="s1.5.b.html" title="PermaLink到（b）嵌套的角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>常规角色类（即，未标记为<code>team</code> ，见上文）可能包含本地类型（请参阅<a href="http://java.sun.com/docs/books/jls/second_edition/html/statements.doc.html#247766" class="ext">JLS§14.3</a> - 在示例中：类<code>Local</code> ），匿名类型（ <a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#252986" class="ext">JLS§15.9.5</a> - 在示例中：类定义在第18-20行但没有成员类型（ <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#246026" class="ext">JLS§8.5</a> - 在示例中：非法类<code>IllegalMember</code> ）。
                     			<br>结果是，常规角色的嵌套类型不能在其封闭角色的范围之外使用。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s1.5.c">
                  <h4 class="subsect">（c） <span class="title">禁止循环</span><a class="img" href="s1.5.c.html" title="（c）禁止循环的永久链接"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>嵌套团队可能不会扩展自己的封闭团队。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s1.5.d">
                  <h4 class="subsect">（d） <span class="title">禁止姓名冲突</span><a class="img" href="s1.5.d.html" title="（d）禁止姓名冲突的永久链接"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>嵌套团队可以从多个源继承角色：其显式超级团队以及来自不同嵌套级别的任何隐式超类（角色）。如果来自不同来源的团队继承了两个或多个与隐式继承无关的同名角色，则这是非法的名称冲突。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s1.5.e">
                  <h4 class="subsect">（e） <span class="title">不同超级之间的优先权</span><a class="img" href="s1.5.e.html" title="永久链接到（e）不同超级之间的优先权"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色从多个超级角色（super和tsuper）继承相同的功能，则隐式继承的版本始终会覆盖任何显式继承的功能，即具有相同简单名称的角色与具有不同名称的角色更紧密相关。
                  </p>
                  <p>此外，单独的隐式继承可能会生成角色类继承的几个候选方法。这是团队嵌套的结果，如果外部团队也参与继承关系，则每个嵌套级别可以再添加一个tsuper角色。在这种情况下，从封闭团队的<em>隐式</em>超级团队继承的角色与从<em>显式</em>超级团队继承的角色更紧密相关。如果需要，此规则将在内部应用，直到找到确实涉及显式团队继承的嵌套级别。<br>因此，当通过完全限定名称比较类时，最长的通用后缀将确定最接近的关系。例如， <code>SuperOuter.RoleAndTeamSub。InnerRole</code>是InnerRole</code>最近的祖先<code>SubOuter.RoleAndTeamSub。InnerRole</code>因为两者共享名称后缀<code>RoleAndTeamSub.InnerRole</code> 。
                     			
                  </p>
                  <div class="codecomment">
                     <table>
                        <colgroup span="1">
                           <col align="left" span="1">
                           <col align="center" span="1">
                        </colgroup>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">
                              <p>在上面的例子中（ <a href="#l1.5" class="listing">清单1.5</a> ）角色<code class="small">OuterTeam.RoleAndTeamSub。InnerRole</code>有两个直接的tsuper角色： <code class="small">OuterTeam.RoleAndTeam。InnerRole</code>和<code class="small">SuperOuter.RoleAndTeamSub。InnerRole</code> 。没有第27-30行定义的方法<code>foo</code> ，封闭类<code class="small">OuterTeam.RoleAndTeamSub。InnerRole</code>将继承<code>SuperOuter.定义的方法<code>foo</code> <code>SuperOuter.RoleAndTeamSub。InnerRole</code> （第9行），因为公用名后缀为<code>RoleAndTeamSub.InnerRole</code>创造了一种更强大的关系，使该类成为最接近的祖先。
                              </p>
                           </td>
                           <td rowspan="1" colspan="1"><img src="../images/team_nesting_hor.png" alt="示例图团队嵌套"></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s1.5.f">
                  <h4 class="subsect">（f） <span class="title">合格的tsuper</span><a class="img" href="s1.5.f.html" title="永久链接到（f）合格的tsuper"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>嵌套团队中的角色可以通过类型名称限定关键字<code>tsuper</code> （参见<a href="#s1.3.1.f" title="§1.3.1。（f）tsuper" class="sect">上面的§1.3.1。（f）</a> ），以便在不同的隐式超类中进行选择。术语<code>OuterTeam.tsuper</code>在封闭团队“ <code>OuterTeam</code> ”的显式超类（此处为： <code>SuperOuter</code> ）的上下文中求值为对应的隐式超类。一个方法调用<code>OuterTeam.tsuper.m()</code>的计算结果为内的方法版本<code>SuperOuter</code>最佳对应于含有tsuper呼叫当前方法。
                     			
                  </p>
                  <div class="codecomment">
                     <ul>
                        <li>在上面的示例（ <a href="#l1.5" class="listing">清单1.5</a> ）中，第28行选择<code>RoleAndTeamSub</code>超类中的方法版本（即在<code>RoleAndTeam</code> ），解析为<code>OuterTeam.RoleAndTeam。InnerRole.foo()</code> 。
                        </li>
                        <li>第29行从<code>SuperOuter</code>解析为<code>SuperOuter.的上下文中选择相应的方法<code>SuperOuter.RoleAndTeamSub。InnerRole.foo()</code>与非限定<code>tsuper</code>调用具有相同的语义。
                           					
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="aux" id="aux1.1">
               <h4 class="aux">语言实施： <span class="toplink"><a href="#s1">↑§1</a></span></h4>
               <p>角色获取和隐式继承可以至少以两种方式实现。
                  		
               </p>
               <p><strong>虚拟类：</strong>每个角色类都是其封闭团队的可覆盖功能。角色类通过与封闭团队实例的动态绑定来解决。此实现需要多重继承，以便还允许同一团队的角色之间的常规继承。 <code>super</code>和<code>tsuper</code>沿着继承的两个维度选择方法的父版本。
                  		
               </p>
               <p><strong>复制继承：</strong>从超级团队获取角色具有复制角色定义<code>TR</code>的效果，从而产生新角色<code>Tsub.R</code>角色副本中的所有角色应用程序<code>Rx</code>指<code>Tsub.Rx</code> 。隐式角色继承可以就地扩展角色副本。只有<code>tsuper</code>构造允许访问方法的先前版本（即在就地覆盖之前）。
                  		
               </p>
            </div>
            <div class="aux" id="aux1.2">
               <h4 class="aux">参考文献： <span class="toplink"><a href="#s1">↑§1</a></span></h4>
               <p id="fn1-virtual-classes">[1] Ole Lehrmann Madsen和BirgerMøller-Pedersen。<em>虚拟类：面向对象编程中的一种强大机制</em> 。在Proceedings OOPSLA 89，ACM SIGPLAN Notices，第24卷，第10卷，第397-406页，1989年10月。
                  
               </p>
               <p id="fn2-family-polymorphism">[2] Erik Ernst。<em>家庭多态性。</em> 在Proceedings ECOOP 2001，LNCS 2072，第303-326页，Springer，2001中。
                  
               </p>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s0.html" rel="prev">&lt;&lt;§0关于本文件</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.html" rel="next">§2角色绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>