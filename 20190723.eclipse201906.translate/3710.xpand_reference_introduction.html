<html dir="ltr">
<head>
<title>Xpand2</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="Xpand Documentation"></link>
<link rel="up" href="core_reference.html" title="Xpand / Xtend / Check Reference"></link>
<link rel="prev" href="Xtend_language.html" title="Xtend"></link>
<link rel="next" href="r10_profiler.html" title="Profiler"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Xpand2</h1>
<div class="section" title="Xpand2">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="xpand_reference_introduction"></a> <span class="emphasis"><em>Xpand2</em></span>
</h2>
</div>
</div>
</div>
<p><span class="emphasis"><em>Xpand</em></span> <a name="N111D8" class="indexterm"></a>模板中使用语言来控制输出生成。本文档描述了<span class="emphasis"><em>Xpand</em></span>语言的一般语法和语义。</p>
<p>打字<span class="foreignphrase"><em class="foreignphrase">guillemets</em></span> <a name="N111E5" class="indexterm"></a> Eclipse编辑器支持模板中使用的（«和»），它使用<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&lt;</strong></span>和<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&gt;</strong></span>提供键盘快捷键。</p>
<div class="section" title="模板文件和编码">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="xpand_reference_template_files_and_ecoding"></a>模板文件和编码</h3>
</div>
</div>
</div>
<p>模板存储在扩展名为<code class="filename">.xpt</code>文件中<a name="N111FF" class="indexterm"></a> 。 <a name="N11205" class="indexterm"></a> 模板文件<a name="N11209" class="indexterm"></a>必须驻留在生成器进程的Java类路径上。</p>
<p>标准语法中使用的几乎所有字符都是<span class="emphasis"><em>ASCII的</em></span>一部分，因此应该可以在任何编码中使用<a name="N11214" class="indexterm"></a><a name="N11219" class="indexterm"></a> 。唯一的限制是标记括号（ <span class="emphasis"><em>guillemets</em></span> ），使用字符“«”（Unicode <code class="varname">00AB</code> ）和“»”（Unicode <code class="varname">00BB</code> ）。因此，对于读取模板，应使用支持这些字符的编码（例如<code class="varname">ISO-8859-1</code>或<code class="varname">UTF-8</code> ）。</p>
<p>属性，模板，名称空间等的名称只能包含字母，数字和下划线。</p>
</div>
<div class="section" title="模板文件的一般结构">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="xpand_reference_general_structure_of_template_files"></a>模板文件的一般结构</h3>
</div>
</div>
</div>
<p>这是模板的第一个示例：</p>
<pre class="programlisting">«IMPORT meta :: model»«EXTENSION my :: ExtensionFile»«DEFINE javaClass FOR Entity»«FILE fileName（）»package«javaPackage（）»;公共课«名称»{//实施}«ENDFILE»«ENDDEFINE»</pre>
<p>模板文件由任意数量的IMPORT语句组成，后跟任意数量的EXTENSION语句，后跟一个或多个DEFINE块（称为定义）。</p>
</div>
<div class="section" title="Xpand语言的语句">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="xpand_reference_statements_of_the_expand_language"></a> <span class="emphasis"><em>Xpand</em></span>语言的语句</h3>
</div>
</div>
</div>
<div class="section" title="进口">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_import"></a>进口<a name="N11244" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>如果您厌倦了始终键入类型和定义的完全限定名称，则可以使用IMPORT语句导入命名空间。</p>
<pre class="programlisting">«IMPORT meta :: model»</pre>
<p>这个导入名称空间<code class="varname">meta::model</code> 。如果模板包含此类语句，则可以使用该命名空间中包含的所有类型和模板文件的非限定名称。这类似于Java import语句<code class="varname">import meta.model.*</code> 。</p>
</div>
<div class="section" title="延期">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_extension"></a>延期<a name="N11256" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>元模型通常以结构方式（图形或分层等）描述。这样做的一个缺点是很难指定其他行为（查询操作，派生属性等）。此外，最好不要使用目标平台特定信息（例如Java类型名称，包，getter和setter名称等）污染元模型。</p>
<p>扩展提供了一种灵活方便的方法来定义元类的其他功能。您可以使用<a class="link" href=""><span class="emphasis"><em>Xtend</em></span></a>执行此操作<a class="link" href=""><a name="N11261" class="indexterm"></a></a>语言。</p>
<p><code class="classname">EXTENSION</code>导入指向包含所需扩展名的<span class="emphasis"><em>Xtend</em></span>文件：</p>
<pre class="programlisting">«EXTENSION my :: ExtensionFile»</pre>
<p>请注意，扩展文件必须驻留在Java类路径上<a name="N11271" class="indexterm"></a>也是。因此，它们使用与类型和模板文件相同的命名空间机制（和语法）。</p>
</div>
<div class="section" title="限定">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_define"></a>限定<a name="N11279" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><span class="emphasis"><em>Xpand</em></span>的核心概念是<code class="code">DEFINE</code>块，也称为模板。这是模板文件中最小的可识别单元<a name="N11284" class="indexterm"></a> 。标记由名称，可选的逗号分隔参数列表以及为其定义模板的元模型类的名称组成。</p>
<pre class="programlisting">«DEFINE templateName（formalParameterList）FOR MetaClass»一系列语句«ENDDEFINE»</pre>
<p>在某种程度上，模板可以被视为元类的特殊方法。总是存在一个隐含的<code class="varname">this</code>参数，可用于解决“底层”模型元素;在上面的示例中，此模型元素的类型为“ <code class="classname">MetaClass</code> ”。</p>
<p>与在Java中一样，形式参数列表条目由类型后跟该参数的名称组成。</p>
<p>模板的主体可以包含一系列其他语句，包括任何文本。</p>
<p>完整的参数多态性<a name="N11299" class="indexterm"></a><a name="N1129D" class="indexterm"></a>可用于模板。如果有两个具有相同名称的模板是为从同一个超类继承的两个元类定义的，则<span class="emphasis"><em>Xpand</em></span>将使用相应的子类模板，以防为超类调用模板。反之亦然，如果子类模板不可用，将使用超类的模板。请注意，这不仅适用于目标类型，也适用于所有参数。从技术上讲，目标类型作为第一个参数处理。</p>
<p>所以，让我们假设你有以下元模型：</p>
<div class="figure">
<a name="N112A8"></a>
<p class="title">
<b>图1。示例元模型</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/XPand/metamodelexample.gif" alt="示例元模型">
</div>
</div>
</div>
<p>
<br class="figure-break">
</p>
<p>进一步假设，您将拥有一个模型，其中包含属性<code class="methodname">listOfAs</code>的<code class="classname">A</code> ， <code class="classname">B</code>和<code class="classname">C</code>实例的<code class="methodname">listOfAs</code> 。然后，您可以编写以下模板：</p>
<pre class="programlisting">«DEFINE someOtherDefine FOR SomeMetaClass»«EXPAND implClass FOREACH listOfAs»«ENDDEFINE»«DEFINE implClass FOR A»//这是为超类生成的代码A«ENDDEFINE»«DEFINE implClass FOR B»//这是为代码生成的代码子类B«ENDDEFINE»«DEFINE implClass FOR C»//这是为子类C«ENDDEFINE»生成的代码</pre>
<p>因此，对于列表中的每个<code class="classname">B</code> ，执行为<code class="classname">B</code>定义的模板，对于集合中的每个<code class="classname">C</code> ，调用为<span class="emphasis"><em><code class="classname">C</code></em></span>定义的模板，对于所有其他<span class="emphasis"><em><code class="classname">C</code></em></span> （然后是<code class="classname">A</code>实例），执行默认模板。</p>
</div>
<div class="section" title="文件">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_file"></a>文件<a name="N112DA" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><code class="varname">FILE</code>语句将从其body语句生成的输出重定向到指定的目标。
        </p>
<pre class="programlisting">«FILE表达式[outletName]»一系列语句«ENDFILE»</pre>
<p>目标是文件系统中的文件，其名称由表达式指定（相对于该生成器运行的指定目标目录）。目标规范的表达式可以是串联（使用+运算符）。此外，您可以为插座名称指定标识符（合法的Java标识符） <a name="N112E5" class="indexterm"></a> 。（有关插座的说明，请参阅配置部分）。要将目标文件生成到子目录中，请在表达式结果中使用“/”作为目录结构的分隔符。</p>
<p><code class="varname">FILE</code>语句的主体可以包含任何其他语句。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span>
</p>
<pre class="programlisting">«FILE InterfaceName +“。java”»package«InterfacePackageName»; / *生成类！不要修改！* / public interface«InterfaceName»{«EXPAND Operation :: InterfaceImplementation FOREACH Operation»}«ENDFILE»«FILE ImplName +“。java”MY_OUTLET»package«ImplPackageName»;公共类«ImplName»扩展«ImplBaseName»实现«InterfaceName»{// TODO：实现它}«ENDFILE»</pre>
</div>
<div class="section" title="扩大">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_expand"></a>扩大<a name="N112F8" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><code class="varname">EXPAND</code>语句“扩展”另一个<code class="varname">DEFINE</code>块（在单独的变量上下文中），将其输出插入当前位置并继续下一个语句。这在概念上类似于子程序调用。
        </p>
<pre class="programlisting">«EXPAND definitionName [（parameterList）] [FOR表达式| FOREACH表达式[SEPARATOR表达式]] [ONFILECLOSE]»</pre>
<p>下面解释各种替代语法。</p>
<div class="section" title="名称">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_names"></a>名称</h5>
</div>
</div>
</div>
<p>如果<span class="emphasis"><em>definitionName</em></span>是一个简单的非限定名称，则相应的<code class="varname">DEFINE</code>块必须位于同一模板文件中。</p>
<p>如果被调用的定义未包含在同一模板文件中，则必须指定模板文件的名称。像往常一样，双冒号用于分隔名称空间。</p>
<pre class="programlisting">«EXPAND TemplateFile :: definitionName FOR myModelElement»</pre>
<p>请注意，您需要导入名称空间<a name="N11317" class="indexterm"></a>模板文件（如果有）。例如，如果模板文件驻留在java包<code class="varname">my.templates</code> ，则有两种选择。你可以写</p>
<pre class="programlisting">«IMPORT my :: templates»...«EXPAND TemplateFile :: definitionName FOR myModelElement»</pre>
<p>要么</p>
<pre class="programlisting">«EXPAND my :: templates :: TemplateFile :: definitionName FOR myModelElement»</pre>
</div>
<div class="section" title="懒惰的评价">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N11325"></a>懒惰的评价</h5>
</div>
</div>
</div>
<p>附加<a name="N1132A" class="indexterm"></a> <code class="classname">ONFILECLOSE</code>语句推迟对扩展定义的评估，直到使用<code class="classname">ENDFILE</code>关闭当前文件。当在处理定义的评估期间收集创建文本所需的状态时，这是有用的。</p>
<pre class="programlisting">«文件......»...«EXPAND LazyEvaluatedDefinition FOREACH myCollection ONFILECLOSE»...«ENDFILE»«REM»现在'LazyEvaluatedDefinition'被称为«ENDFILE»</pre>
<p>使用<code class="classname">ONFILECLOSE</code>语句的典型示例是，您希望在Java类中创建导入列表，但是稍后在模板中使用时应添加使用的类型。</p>
<p>在文件关闭之前，用于延迟扩展评估的状态（通常是集合）必须有效。这可以通过两种方式实现：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>跨越<code class="classname">LET</code>空集合的<code class="classname">FILE</code>语句的<code class="classname">LET</code>语句</p>
<pre class="programlisting">«LET（List [MyType]）{} AS importedTypes»«FILE ...»...«EXPAND ImportStatement FOREACH importedTypes ONFILECLOSE»...«importedTypes.add（someType） - &gt;“” - »...«ENDFILE»«ENDLET»</pre>
</li>
<li class="listitem">
<p>使用<a class="link" href="Xtend_language.html#create_extension" title="创建扩展（模型转换）"><span class="emphasis"><em>create extension</em></span></a> ，返回一个空集合并向其追加元素。由于它是一个创建扩展，因此第一次调用时将返回空集合，并且对于每个后续调用，将返回对此集合的引用，而不是创建新集合。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span>
</p>
<p>
<code class="filename">some/path/InsertionPoints.ext</code> ：</p>
<pre class="programlisting">create List [Type] importedTypes（SomeType context）:( List [Type]）{};</pre>
<p>在Xpand中使用如下：</p>
<pre class="programlisting">«EXTENSION some :: path :: InsertionPoints»«FILE ...»...«EXPAND ImportStatement FOREACH importedTypes（）ONFILECLOSE»...«importedTypes（）。add（someType） - &gt;“” - »...«ENDFILE»«ENDLET»</pre>
</li>
</ul>
</div>
</div>
</div>
<div class="section" title="FOR FOR FOREACH">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_for_vs_foreach"></a> FOR FOR FOREACH <a name="N11365" class="indexterm"></a><a name="N11368" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>如果省略<code class="varname">FOR</code>或<code class="varname">FOREACH</code>则<code class="varname">FOR this</code>调用另一个模板。
        </p>
<pre class="programlisting">«EXPAND TemplateFile :: definitionName»</pre>
<p>等于</p>
<pre class="programlisting">«EXPAND TemplateFile :: definitionName FOR this»</pre>
<p>如果指定了<code class="varname">FOR</code>则为目标表达式的结果执行定义。</p>
<pre class="programlisting">«EXPAND myDef FOR实体»</pre>
<p>如果指定了<code class="varname">FOREACH</code> ，则目标表达式必须求值为集合类型<a name="N11385" class="indexterm"></a> 。在这种情况下，将为该集合的每个元素执行指定的定义。</p>
<pre class="programlisting">«EXPAND myDef FOREACH entity.allAttributes»</pre>
<p>如果无法将指定的目标表达式求值为实例化模型的现有元素，或者找不到合适的<code class="varname">DEFINE</code>块，则抛出<code class="varname">EvaluationException</code> 。</p>
<div class="section" title="指定分隔符">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_specifying_a_separator"></a>指定分隔符<a name="N11397" class="indexterm"></a>
</h5>
</div>
</div>
</div>
<p>如果要扩展定义<code class="varname">FOREACH</code>目标表达式的元素，则可以指定<code class="varname">SEPARATOR</code>表达式：</p>
<pre class="programlisting">«EXPAND paramTypeAndName FOREACH params SEPARATOR'，'»</pre>
<p>分隔符表达式的结果<a name="N113A5" class="indexterm"></a>将在每次评估目标定义之间写入输出。不是<span class="emphasis"><em>在</em></span>每一个之后，而是仅在两个元素<span class="emphasis"><em>之间</em></span> 。这对于逗号分隔的参数列表等内容非常有用。</p>
</div>
</div>
<div class="section" title="FOREACH">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_foreach"></a> FOREACH</h4>
</div>
</div>
</div>
<p>此语句扩展了目标集合的每个元素的<code class="varname">FOREACH</code>块的主体<a name="N113BA" class="indexterm"></a>这是表达式的结果。current元素绑定到当前上下文中具有指定名称的变量。
        </p>
<pre class="programlisting">«FOREACH表达式AS variableName [ITERATOR iterName] [SEPARATOR表达式]»使用variableName访问迭代的当前元素的语句序列«ENDFOREACH»</pre>
<p><code class="varname">FOREACH</code>块的主体可以包含任何其他语句;特别是<code class="varname">FOREACH</code>语句可以嵌套。</p>
<p>如果是<code class="varname">ITERATOR</code> <a name="N113CB" class="indexterm"></a>如果指定了name，则可以使用指定的名称访问<code class="classname">xpand2::Iterator</code>类型的对象（有关详细信息，请参阅API doc）。</p>
<p><code class="varname">SEPARATOR</code>表达式的工作方式与<a class="link" href="xpand_reference_introduction.html#xpand_reference_specifying_a_separator" title="指定分隔符"><code class="varname">EXPAND</code></a>表达方式相同。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span>
</p>
<pre class="programlisting">«FOREACH {'A'，'B'，'C'} AS c ITERATOR iter SEPARATOR'，'»«iter.counter1»：«c»«ENDFOREACH»</pre>
<p>对上述声明的评估结果如下：</p>
<pre class="programlisting">1：A，2：B，3：C</pre>
</div>
<div class="section" title="如果">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_if"></a>如果<a name="N113E9" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><code class="varname">IF</code>语句支持条件扩展。任意数量的<code class="varname">ELSEIF</code> <a name="N113F3" class="indexterm"></a>允许陈述。<code class="varname">ELSE</code>块是可选的。必须使用<code class="varname">ENDIF</code>关闭每个<code class="varname">IF</code>语句<a name="N113FF" class="indexterm"></a> 。<code class="varname">IF</code>块的主体可以包含任何其他语句，具体而言， <code class="varname">IF</code>语句可以嵌套。</p>
<pre class="programlisting">«IF表达»一系列陈述[«ELSEIF表达»]一系列陈述] [«ELSE»一系列陈述]«ENDIF»</pre>
</div>
<div class="section" title="保护">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_protect"></a>保护<a name="N1140F" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>保护区<a name="N11414" class="indexterm"></a>用于标记生成的代码中的部分，后续生成器运行不会再次覆盖这些部分。这些部分通常包含手动编写的代码。</p>
<pre class="programlisting">«保护CSTART表达式CEND表达式ID表达式（DISABLE）？»一系列陈述«ENDPROTECT»</pre>
<p><code class="classname">CSTART</code>的值<a name="N1141D" class="indexterm"></a>和<code class="classname">CEND</code> <a name="N11423" class="indexterm"></a>表达式用于将受保护区域标记括在输出中。它们应该构建有效的注释开始和注释与生成的目标语言相对应的结束字符串（例如，对于Java， <span class="emphasis"><em>“/ *”</em></span>和<span class="emphasis"><em>“* /”</em></span> ）。</p>
<p>以下是Java的示例：</p>
<pre class="programlisting">«保护CSTART“/ *”CEND“* /”ID ElementsUniqueID“这里有一些内容«ENDPROTECT»</pre>
<p>ID由<code class="varname">ID</code>表达式设置，并且必须是<span class="emphasis"><em>全局唯一的</em></span> （至少对于生成器的一次完整传递）。为了确保这些ID通常连接在一起。某些模型类型（例如UML2模型）包含可以使用的标识符，可以使用<a class="link" href="ch04s02.html#stdlib_uid_xmlid" title="String xmlId (ecore::EObject o)">stdlib中</a>的<a class="link" href="ch04s02.html#stdlib_uid_xmlid" title="String xmlId (ecore::EObject o)"><code class="methodname">xmlId()</code>函数</a>读取这些<a class="link" href="ch04s02.html#stdlib_uid_xmlid" title="String xmlId（ecore :: EObject o）"><code class="methodname">xmlId()</code></a> 。</p>
<p>生成的目标代码如下所示：</p>
<pre class="programlisting">public class Person {/ * PROTECTED REGION ID（Person）ENABLED START * /启用此受保护区域，因此将始终保留内容。如果你想从模板中获取默认内容，你必须删除ENABLED关键字（甚至删除整个文件:-)）/ * PROTECTED REGION END * /}</pre>
<p>受保护区域在启用状态下生成<a name="N11443" class="indexterm"></a>默认情况下。除非您手动禁用<a name="N11449" class="indexterm"></a>通过删除<code class="varname">ENABLED</code>关键字，它们将始终保留。</p>
<p>如果希望生成器生成禁用的受保护区域，则需要在声明中添加<code class="varname">DISABLE</code>关键字：</p>
<pre class="programlisting">«保护CSTART'/ *'CEND'* /'ID this.name DISABLE»</pre>
<p>生成的目标代码将不包含<code class="classname">ENABLED</code>标志。在这种情况下，必须将<code class="classname">ENABLED</code>添加到目标区域以激活受保护区域。默认情况下禁用受保护区域的优点是可以更改模板中受保护区域的默认内容，并且所有尚未激活的区域将在重新生成后包含更改的代码。</p>
</div>
<div class="section" title="让">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_let"></a>让<a name="N11465" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>
<code class="varname">LET</code>允许您指定局部变量：</p>
<pre class="programlisting">«LET表达式AS variableName»一系列语句«ENDLET»</pre>
<p>在<code class="varname">LET</code>身体扩张期间<a name="N11471" class="indexterm"></a> block，表达式的值绑定到指定的变量。请注意，表达式只会被评估一次，与<code class="varname">LET</code>块中变量的用法数无关。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span> </p>
<pre class="programlisting">«LET packageName +“。” + className AS fqn»完全限定名称是：«fqn»; «ENDLET»</pre>
<p>无法在<code class="classname">LET</code>块中重新分配变量值。</p>
</div>
<div class="section" title="错误">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_error"></a>错误<a name="N11488" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><code class="varname">ERROR</code>语句通过抛出<code class="varname">XpandException</code>中止模板的评估<a name="N11492" class="indexterm"></a>使用指定的消息。</p>
<pre class="programlisting">«错误表达»</pre>
<p>请注意，您应该非常谨慎地使用此工具，因为更好的做法是使用元模型上的约束检查无效模型，而不是模板中！</p>
</div>
<div class="section" title="评论">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_comments"></a>评论<a name="N1149D" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>注释仅允许在标签之外。</p>
<pre class="programlisting">«REM»文字评论«ENDREM»</pre>
<p>评论可能不包含REM <a name="N114A7" class="indexterm"></a> tag，这意味着注释不可嵌套。<code class="classname">REM</code>关键字及其括号之间的注释可能没有空格。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span> </p>
<pre class="programlisting">«REM»«LET表达式AS variableName»«ENDREM»一系列语句«REM»«variableName.stuff»«ENDLET»«ENDREM»</pre>
</div>
<div class="section" title="表达声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_expression_statement"></a>表达声明<a name="N114B9" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>表达式支持处理由实例化的元模型提供的信息。<span class="emphasis"><em>Xpand</em></span>为选择，聚合和导航提供了强大的表达式。
        <span class="emphasis"><em>Xpand</em></span>在我们到目前为止看到的几乎任何语句中都使用表达式子语言。表达式语句只是计算包含的表达式并将结果写入输出（使用<code class="varname">java.lang.的<code class="varname">toString()</code>方法<code class="varname">java.lang.Object</code> ）。例：</p>
<pre class="programlisting">公共课«this.name»{</pre>
<p>表达式子语言定义的所有表达式也可以在<span class="emphasis"><em>Xpand中使用</em></span> 。您可以调用导入的扩展名。（有关详细信息，请参阅<span class="emphasis"><em><a class="xref" href="r10_expressions_language.html" title="表达式">表达式</a></em></span>和<span class="emphasis"><em><a class="xref" href="Xtend_language.html" title="的Xtend">Xtend</a>语言参考</em></span> ）。</p>
</div>
<div class="section" title="控制空白的生成">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_controlling_generation_of_white_space"></a>控制空白的生成</h4>
</div>
</div>
</div>
<p>如果你想省略多余空格的输出<a name="N114E1" class="indexterm"></a>您可以在任何结束括号之前添加减号。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span> </p>
<pre class="programlisting">«FILE InterfaceName +“。java” - »«IF hasPackage-»package«InterfacePackageName»; “万一-” ...«ENDFILE»</pre>
<p>如果尚未设置减号字符，则生成的文件将以两个新行开头（一个在<code class="varname">FILE</code> ，一个在<code class="varname">IF</code>语句之后）。</p>
<p>通常，此机制的工作方式如下：如果语句（或注释）以这样的减去所有前面的空格结束直到换行符<a name="N114F7" class="indexterm"></a>人物（排除！）已移除。此外，还删除了包括第一个换行符（ <code class="varname">\r\n</code>作为一个字符处理）的所有后续空格。</p>
</div>
</div>
<div class="section" title="Xpand中面向方面的编程">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="xpand_reference_aspect-oriented_programming_in_xpand"></a> <span class="emphasis"><em>Xpand中</em></span>面向方面的编程<a name="N11504" class="indexterm"></a>
</h3>
</div>
</div>
</div>
<p>使用工作流引擎，现在可以打包（ <span class="emphasis"><em>例如</em></span>拉链）书面生成器并将其作为一种黑盒子传送（这通常称为盒式磁带<a name="N1150C" class="indexterm"></a> ）。如果你想使用这样的发电机但需要改变一些小代的东西，你可以使用<code class="varname">AROUND</code> <a name="N11512" class="indexterm"></a>方面。</p>
<pre class="programlisting">«AROUND qualifiedDefinitionName（parameterList）？FOR type»一系列陈述«ENDAROUND»</pre>
<p>
<code class="varname">AROUND</code>允许您以非侵入方式添加模板（您无需触摸生成器模板）。由于方面是侵入性的，因此必须按配置包含包含<code class="varname">AROUND</code>方面的模板文件（请参阅下一节）。</p>
<div class="section" title="加入Point和Point Cut语法">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_join_point_and_cut_syntax"></a>加入点<a name="N11522" class="indexterm"></a><a name="N11525" class="indexterm"></a>和点切<a name="N1152B" class="indexterm"></a><a name="N1152E" class="indexterm"></a>句法</h4>
</div>
</div>
</div>
<p>AOP基本上是将代码编织到软件模块的调用图内的不同点。这些点称为<span class="emphasis"><em>加入点</em></span> <a name="N11538" class="indexterm"></a> 。在<span class="emphasis"><em>Xpand中</em></span> ，到目前为止只有一个连接点：对定义的调用。</p>
<p>您可以通过在所有可用连接点上指定类似“查询”的内容来指定应执行贡献代码的连接点。这种查询称为<span class="emphasis"><em>切点</em></span> <a name="N11543" class="indexterm"></a> 。</p>
<pre class="programlisting">«AROUND [pointcut]»做东西«ENDAROUND»</pre>
<p>切点由完全限定名称，参数类型和目标类型组成。</p>
<div class="section" title="定义名称">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_definition_name"></a>定义名称</h5>
</div>
</div>
</div>
<p>切入点的定义名称部分必须与连接点定义的完全限定名称匹配。这些表达式<span class="emphasis"><em>区分大小写</em></span> 。星号字符用于指定通配符。</p>
<p>一些例子：</p>
<pre class="programlisting">my :: Template :: definition //具有指定名称的定义org :: eclipse :: xpand2 :: * //定义前缀为'org :: eclipse :: xpand2 ::'* Operation * //包含单词'的定义'操作'在里面。* //所有定义</pre>
</div>
<div class="section" title="参数类型">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_parameter_types"></a>参数类型</h5>
</div>
</div>
</div>
<p>我们想要添加建议的定义的参数也可以在切入点中指定。规则是指定参数的类型必须相同或者是相应参数类型的超类型（运行时的动态类型！）要调用的定义。</p>
<p>另外，可以在参数列表的末尾设置通配符，以指定可能存在任意数量的任意数量的参数。</p>
<p>一些例子：</p>
<pre class="programlisting">my :: Templ :: def（）//没有参数的templ def my :: Templ :: def（String s）// templ def只有一个参数//类型为String my :: Templ :: def（String s， *）//带有一个或多个参数的templ def，//其中第一个参数的类型为String my :: Templ :: def（*）// templ def，带有任意数量的参数</pre>
</div>
<div class="section" title="目标类型">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_target_type"></a>目标类型</h5>
</div>
</div>
</div>
<p>最后，我们必须指定目标类型。这很简单：</p>
<pre class="programlisting">my :: Templ :: def（）FOR Object // templ def for any target type my :: Templ :: def（）FOR Entity // templ def object of Entity类型</pre>
</div>
</div>
<div class="section" title="诉讼">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_proceeding"></a>诉讼</h4>
</div>
</div>
</div>
<p>在建议中，您可能希望调用基础定义。这可以使用隐含变量来实现<code class="varname">targetDef</code> ，这是该类型<span class="type">xpand2 ::定义</span>和提供的操作<code class="methodname">proceed()</code>调用与原来的参数基础定义（请注意，你可能会在咨询之前已经改变了可变对象）。</p>
<p>如果要控制将哪些参数传递给定义，可以使用操作<code class="methodname">proceed</code> （ <code class="classname">Object</code> <code class="varname">target</code> ， <code class="classname">List</code> <code class="varname">params</code> ）。请记住，在此上下文中没有进行类型检查。</p>
<p>此外，还有一些检查属性（如<code class="varname">name</code> ， <code class="varname">paramTypes</code>等）可用。</p>
</div>
</div>
<div class="section" title="生成器工作流程组件">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="xpand_reference_generator_workflow_component"></a>生成器工作流程组件<a name="N11597" class="indexterm"></a>
</h3>
</div>
</div>
</div>
<p>本节介绍为执行代码生成而提供的工作流组件，即运行模板。您应该对工作流引擎的工作原理有一个基本的了解。简单的生成器组件配置可能如下所示：</p>
<pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”org.eclipse.emf.ecore。EcorePackage“/&gt; &lt;/ metaModel&gt; &lt;expand value =”somenamespace :: example :: Java :: all FOR myModel“/&gt; &lt;！ -  aop configuration  - &gt; &lt;advices value ='somenamespace :: example :: Advices1，示例:: Advices2'/&gt; &lt;！ - 输出配置 - &gt; &lt;outlet path ='main / src-gen'&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt; &lt;outlet name ='TO_SRC'path ='main / src'ramprite ='false'&gt; &lt;postprocessor class =”org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt; &lt;！ -  optional：protected regions configuration  - &gt; &lt;prSrcPaths value =”main / src“/&gt; &lt;prDefaultExcludes value =”false“/&gt; &lt;prExcludes value =”*。xml“/ &gt; &lt;/ component&gt;</pre>
<p>现在，让我们一个接一个地浏览不同的属性。</p>
<div class="section" title="主要配置">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_main_configuration"></a>主要配置</h4>
</div>
</div>
</div>
<p>首先要注意的是组件的限定Java名称是<code class="varname">org.eclipse.xpand2.Generator</code> 。</p>
</div>
<div class="section" title="编码">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_encoding"></a>编码</h4>
</div>
</div>
</div>
<p>对于<span class="emphasis"><em>Xpand</em></span> ，重要的是进行文件编码<a name="N115B3" class="indexterm"></a>记住因为<span class="foreignphrase"><em class="foreignphrase">guillemet</em></span>字符<a name="N115BC" class="indexterm"></a> «»用于分隔关键字和属性访问。<code class="varname">fileEncoding</code>属性<a name="N115C3" class="indexterm"></a>指定用于读取模板，读取受保护区域和写入生成文件的文件编码。此属性默认为JVM的默认文件编码。</p>
<p>在使用不同操作系统或区域设置的团队中，最好为Xpand项目设置固定的文件编码并共享设置。使用的典型编码是UTF-8或ISO-8859-1，但任何具有guillemet括号的编码也都可以。 <sup>[ <a href="#ftn.N115CB" name="N115CB" class="footnote">8</a> ]</sup>
</p>
<p>错误编码可能会在运行时导致生成器的错误消息：</p>
<pre class="programlisting">1108 ERROR WorkflowRunner  -  [错误]：第1行的输入'''没有可行的替代方案</pre>
<p>在这种情况下，您必须配置输入编码。<span class="interface">ResourceManager</span>用于设置输入编码。使用生成器组件内<code class="code">ResourceManager</code>的<code class="code">fileEncoding</code>属性来配置模板和扩展的编码。</p>
<p><span class="emphasis"><em>MWE</em></span>示例：</p>
<pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel idRef =”mm_emf“/&gt; &lt;expand value =”template :: Template :: main FOR model“/&gt; &lt;outlet path =”$ {src-gen}“&gt; &lt;postprocessor class =”org.eclipse .xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt; &lt;resourceManager class =”org.eclipse.xtend.expression。ResourceManagerDefaultImpl“&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;/ resourceManager&gt; &lt;/ component&gt;</pre>
<p><span class="emphasis"><em>MWE2的</em></span>示例：</p>
<pre class="programlisting">component = org.eclipse.xpand2。生成器{metaModel = org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel {} expand =“templates :: Template :: main FOREACH model”outlet = {path = targetDir} resourceManager = org.eclipse.xtend.expression。ResourceManagerDefaultImpl {fileEncoding =“ISO-8859-1”}}</pre>
<p>“ <span class="emphasis"><em><a class="xref" href="xpand_reference_introduction.html#xpand_reference_output_configuration" title="输出配置">输出配置</a></em></span> ”部分介绍了如何配置生成文件的编码。</p>
</div>
<div class="section" title="元模型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_metamodel"></a>元模型</h4>
</div>
</div>
</div>
<p>属性<code class="varname">metaModel</code> <a name="N115F9" class="indexterm"></a>用于告诉生成器引擎应该在哪些元模型上评估<span class="emphasis"><em>Xpand</em></span>模板。可以在这里指定多个元模型。<span class="emphasis"><em>Xpand2</em></span>使用的表达式框架（请参阅<span class="emphasis"><em><a class="xref" href="r10_expressions_language.html" title="表达式">表达式</a></em></span> ）需要元模型实现。在上面的示例中，我们使用<span class="emphasis"><em>Xpand</em></span>发行版核心部分附带的<code class="classname">EMFMetaModel</code>实现配置了Ecore元模型。</p>
<p>强制配置是<code class="varname">expand</code>属性。它期望语法类似于<code class="varname">EXPAND</code>语句（如上所述）。唯一的区别是我们省略了<code class="varname">EXPAND</code> <a name="N11619" class="indexterm"></a>关键词。相反，我们指定属性的名称。</p>
<p>例子：</p>
<pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define FOR mySlot”/&gt;</pre>
<p>要么：</p>
<pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define（'foo'）FOREACH {mySlot1，mySlot2}”/&gt;</pre>
<p>使用工作流上下文评估表达式。每个槽都映射到一个变量。对于上面的示例，工作流上下文需要包含插槽<code class="varname">'mySlot'</code> ， <code class="varname">'mySlot1'</code>和<code class="varname">'mySlot2'</code> 。这里也可以指定一些复杂的表达式。例如，如果插槽<code class="varname">myModel</code>包含一组模型元素，则可以编写： <a name="N11631" class="indexterm"></a> </p>
<pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define FOREACH myModel.typeSelect（Entity）”/&gt;</pre>
<p>这将选择存储在<code class="varname">myModel</code>插槽中的集合中包含的所有<span class="emphasis"><em>Entity</em></span>类型的元素。</p>
</div>
<div class="section" title="输出配置">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_output_configuration"></a>输出配置</h4>
</div>
</div>
</div>
<p>第二个强制配置是所谓的出口规范（从AndroMDA借来的概念）。奥特莱斯<a name="N11645" class="indexterm"></a>负责将生成的文件写入磁盘。</p>
<p>示例<span class="emphasis"><em>MWE</em></span> ：</p>
<pre class="programlisting">&lt;component class =“org.eclipse.xpand2。发电机“&gt; ......&lt;outlet path ='main / src-gen'/&gt; &lt;outlet name ='TO_SRC'path ='main / src'overcrite ='false'&gt; &lt;fileEncoding value ='ISO-8859-1'/&gt; &lt;/ outlet&gt; &lt;fileEncoding value ='ISO-8859-1'/&gt; ...&lt;/组分&gt;</pre>
<p>示例<span class="emphasis"><em>MWE2</em></span> ：</p>
<pre class="programlisting">component = org.eclipse.xpand2。生成器{metaModel = org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel {} expand =“templates :: Template :: main FOREACH model”outlet = {path ='main / src-gen'} outlet = {name ='TO_SRC'path ='main / src'overprite = false fileEncoding =' ISO-8859-1'} fileEncoding ='ISO-8859-1'......}</pre>
<p>在示例中，配置了两个出口。第一个没有名称，因此作为默认出口处理。通过省略插座名称触发默认插座：</p>
<pre class="programlisting">«FILE'test / note.txt'»＃这将进入默认插座«ENDFILE»</pre>
<p>配置的基本路径是' <code class="filename">main/src-gen</code> '，因此上面的文件将转到' <code class="filename">main/src-gen/test/note.txt</code> '。</p>
<p>第二个出口具有指定的<code class="varname">name</code> （'TO_SRC'）。此外，标志<code class="varname">overwrite</code>设置为<code class="varname">false</code> （默认为<code class="varname">true</code> ）。以下<span class="emphasis"><em>Xpand</em></span>片段</p>
<pre class="programlisting">«FILE'test / note.txt'TO_SRC»＃这到TO_SRC出口«ENDFILE»</pre>
<p>如果文件尚不存在（ <code class="varname">overwrite</code>标志），将导致生成器将内容写入' <code class="filename">main/src/test/note.txt</code> '。</p>
<p>另一个名为<code class="varname">append</code>选项（默认为<code class="varname">false</code> ）会导致生成器将生成的文本追加到现有文件中。如果<code class="varname">overwrite</code>设置为<code class="varname">false</code>此标志无效。</p>
<p>编码<a name="N1168A" class="indexterm"></a>可以在两个不同的级别配置生成的文件。可以为完整的生成器组件定义文件编码。因此，必须使用组件定义中的<span class="emphasis"><em>fileEncoding</em></span>属性（请参阅上面的示例）。您还可以在插座级别定义文件编码。因此，必须使用出口定义中的<span class="emphasis"><em>fileEncoding</em></span>属性。</p>
</div>
<div class="section" title="PostProcessor中">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_beautifier"></a> PostProcessor中<a name="N1169A" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>美化生成的代码是个好主意。生成的代码看起来很好很重要，因为开发人员应该能够理解它。另一方面，模板文件也应该看起来不错。因此，最佳做法是编写漂亮的模板文件，而不是关心生成的代码的外观 - 然后在生成的代码上运行美化器来修复该问题。当然，如果没有美化器，或者白色空间具有语法意义（如在Python中），则必须记住模板（在前面部分中描述的关闭括号之前使用减号）。</p>
<p><span class="emphasis"><em>Xpand</em></span>工作流组件可以配置多个美化器：</p>
<pre class="programlisting">&lt;outlet ...&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt;</pre>
<p>这是<span class="emphasis"><em>Xpand</em></span>提供的两个美化<span class="emphasis"><em>器</em></span> 。如果你想使用自己的美化器，你只需要实现<code class="classname">PostProcessor</code> Java接口<a name="N116AD" class="indexterm"></a> ：</p>
<pre class="programlisting">包org.eclipse.xpand2.output; public interface PostProcessor {public void beforeWriteAndClose（FileHandle handle）; public void afterClose（FileHandle handle）; }</pre>
<p>为每个<code class="varname">ENDFILE</code>语句调用<code class="varname">beforeWriteAndClose</code>方法。</p>
<p>PostProcessors也可以用于其他方式，而不是格式化，如行计数。</p>
<div class="section" title="JavaBeautifier">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_javabeautifier"></a> JavaBeautifier</h5>
</div>
</div>
</div>
<p>JavaBeautifier <a name="N116C2" class="indexterm"></a>基于Eclipse Java格式化程序为Java文件提供基础美化。</p>
</div>
<div class="section" title="XmlBeautifier">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="xpand_reference_xmlbeautifier"></a> XmlBeautifier</h5>
</div>
</div>
</div>
<p>XmlBeautifier基于<span class="emphasis"><em>dom4j，</em></span>并提供单个选项<code class="varname">fileExtensions</code> （默认为“ <code class="filename">.xml</code> ， <code class="filename">.xsl</code> ， <code class="filename">.wsdd</code> ， <code class="filename">.wsdl</code> ”），用于指定哪些文件应该是漂亮打印的。</p>
</div>
<div class="section" title="CppBeautifier">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N116DE"></a> CppBeautifier</h5>
</div>
</div>
</div>
<p>CppBeautifier利用CDT格式化C / C ++源代码。因此，CDT需要使用此代码格式化程序。要使用这个美化器，必须将插件<span class="package">org.eclipse.xpand.support.cdt</span>添加到插件依赖项中。</p>
</div>
</div>
<div class="section" title="受保护的区域配置">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xpand_reference_protected_region_configuration"></a>受保护的区域配置</h4>
</div>
</div>
</div>
<p>最后，如果要使用受保护区域，则需要配置受保护区域解析程序<a name="N116EC" class="indexterm"></a> 。</p>
<pre class="programlisting">&lt;prSrcPaths value =“main / src”/&gt; &lt;prDefaultExcludes value =“false”/&gt; &lt;prExcludes value =“*。xml”/&gt;</pre>
<p><span class="emphasis"><em>prSrcPaths</em></span> <a name="N116F5" class="indexterm"></a> property指向以逗号分隔的目录列表。受保护区域解析程序将扫描这些目录以查找包含已激活受保护区域的文件。</p>
<p>默认情况下会排除多个文件名：</p>
<pre class="programlisting">RCS，SCCS，CVS，CVS.adm，RCSLOG，cvslog。*，tags，TAGS，.make.state，.nse_depinfo，*〜，＃* ,.＃*，'，*'，_ $ *，* $，*。old，* .bak，*。BAK，* .orig，* .rej，.del- *，*。a，* .olb，*。o，* .obj，*。so，* .exe，*。Z，* .elc，* .ln，core，.svn</pre>
<p>如果您不想排除其中任何一个，则必须将<code class="varname">prDefaultExcludes</code>设置为false。</p>
<pre class="programlisting">&lt;prDefaultExcludes value =“false”/&gt;</pre>
<p>如果要添加其他排除项，则应使用prExcludes属性。</p>
<pre class="programlisting">&lt;prExcludes value =“*。xml，*。hbm”/&gt;</pre>
<div class="note" title="注意" style="margin-left:0.5in;margin-right:0.5in">
<h3 class="title">注意</h3>
<p>将生成和未生成的代码混合在一个工件中是不好的做法。您应该尝试尽可能利用所使用的目标语言的扩展功能（继承，包含，引用等），而不是使用受保护的区域。使用受保护区域是一种适当的解决方案是非常罕见的。</p>
</div>
</div>
<div class="section" title="VetoStrategy">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N11709"></a> VetoStrategy <a name="N1170C" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p><span class="emphasis"><em>Xpand</em></span>引擎将为每个已处理的<span class="property">FILE</span>语句生成代码。这意味着写入的文件可能没有更改为先前的生成器运行。通常，重写文件并不重要。避免重写文件最好至少有两个好的理由：</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>生成的源代码将被签入。一般来说，不建议您检查生成的代码，但有时您必须这样做。特别是对于CVS，存在重写文件被识别为已修改的问题，即使它们没有改变。因此出现了问题，即一次又一次地检入相同的文件（或者您手动还原它）。当团队合作时，问题甚至会变得更糟，因为团队成员在办理登机手续时会有冲突。</p>
</li>
<li class="listitem">
<p>当可以预测生成器在文件甚至即将由FILE语句创建之前不会产生不同的内容时，这可以提高性能。当然，预测特定文件在创建之前不会产生不同的内容并非易事。这需要来自先前发电机运行的信息和针对当前模型的评估来处理。通常，diff模型将用作决策的输入。</p>
</li>
</ol>
</div>
<p>情况1）将在评估<span class="property">FILE</span>语句后阻止文件写入，情况2）将阻止创建文件。</p>
<p>为了实现这一点，可以将Veto Strategies添加到生成器，这是接口<code class="classname">org.eclipse.xpand2.output.实现<code class="classname">org.eclipse.xpand2.output.VetoStrategy</code>或<code class="classname">org.eclipse.xpand2.output.VetoStrategy2</code> 。如果您实现自己的<code class="classname">VetoStrategy2</code> ，请使用<code class="classname">VetoStrategy2</code> 。</p>
<p>
<code class="classname">VetoStrategy2</code>声明了两种方法：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
<code class="methodname">boolean hasVetoBeforeOpen（FileHandle）</code>
</p>
<p>在打开和生成文件之前将调用此方法。返回true以禁止创建文件。</p>
</li>
<li class="listitem">
<p>
<code class="methodname">boolean hasVeto（FileHandle）</code>
</p>
<p>在生成文件之后以及在调用所有已配置的PostProcessors之后，将调用此方法。返回true以禁止写入文件。</p>
</li>
</ul>
</div>
<p>每个插座都配置了Veto策略。可以为每个Outlet添加多个stratgy实例。</p>
<pre class="programlisting">&lt;component id =“generator”class =“org.eclipse.xpand2。生成器“skipOnErrors =”true“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.uml2。UML2MetaModel“/&gt; &lt;expand value =”templates :: Root :: Root FOR model“/&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;outlet path =”src-gen“&gt; &lt;postprocessor class =”org .eclipse.xpand2.output。JavaBeautifier“/&gt; <span class="bold"><strong>&lt;vetoStrategy class =”org.eclipse.xpand2.output。NoChangesVetoStrategy“/&gt;</strong></span> &lt;/ outlet&gt; &lt;/ component&gt;</pre>
<p>已经提供了一个<code class="classname">VetoStrategy</code> 。<code class="classname">org.eclipse.xpand2.output.NoChangesVetoStrategy</code> <a name="N1174F" class="indexterm"></a>是一个简单的实现，它将生成的输出在经过后处理后与目标文件进行比较。如果内容相同，则策略否决文件写入。这种策略很有效，但有两个严重的缺点：</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>该文件至少在内存中创建过。这会消耗时间和内存。如果应用代码格式化，这通常意味着临时写入文件。</p>
</li>
<li class="listitem">
<p>必须将现有文件读入内存。这也花费了时间和记忆。</p>
</li>
</ol>
</div>
<p>更好的方法是通过拥有<code class="classname">hasVetoBeforeOpen()</code>方法的有效实现来阻止文件的创建。提供预测不必创建文件的实现需要领域知识，因此标准实现不可用。</p>
<p>Generator组件将报告跳过的文件数，如下所示：</p>
<pre class="programlisting">2192 INFO  - 发电机（发电机）：发电&lt;...&gt; 3792 INFO  - <span class="bold"><strong>已将2个文件写入插座</strong></span> [默认]（src-gen）</pre>
</div>
</div>
<div class="section" title="在Xpand中使用面向方面编程的示例">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="aop_template_introduction"></a>在<span class="emphasis"><em>Xpand中</em></span>使用面向方面编程的<span class="emphasis"><em>示例</em></span>
</h3>
</div>
</div>
</div>
<p>
<a name="N1176F" class="indexterm"></a>此示例显示如何在<span class="emphasis"><em>Xpand</em></span>模板中使用面向方面的编程技术。它适用于基于EMF和<span class="emphasis"><em>Classic</em></span>系统。但是，我们根据<span class="emphasis"><em>emfExample</em></span>解释了这个想法。因此你应该先阅读。</p>
</div>
<div class="section" title="问题">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="aop_template_the_problem"></a>问题</h3>
</div>
</div>
</div>
<p>在模板AOP很有用的情况下有很多种情况。这是两个例子：</p>
<p>
<span class="bold"><strong>场景1：</strong></span>假设您有一个生成某些工件的漂亮生成器。生成器（或盒式磁带）可能是第三方产品，在单个JAR文件中提供。您仍然可能希望在<span class="emphasis"><em>不修改原始生成器的情况下调整</em></span>生成过程的某些方面。</p>
<p>
<span class="bold"><strong>场景2：</strong></span>您正在构建一系列可以生成生成代码变体的生成器，例如，针对不同嵌入式平台的实现。在这种情况下，您需要能够明智地表达这些差异（变量），而不会在模板中创建不可理解的<span class="emphasis"><em>if</em></span>语句混乱。</p>
</div>
<div class="section" title="例">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="aop_template_example"></a>例</h3>
</div>
</div>
</div>
<p>为了说明扩展生成器而不“触及”它的想法，让我们创建一个名为<code class="classname">org.eclipse.demo.emf.datamodel.generator-aop</code>的新项目。这个想法是它将“扩展” <span class="emphasis"><em>emfExample中</em></span>引入的原始<code class="classname">org.eclipse.demo.emf.datamodel.generator</code>项目。因此，这个新项目需要与前一个项目相关。</p>
<div class="section" title="模板">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="aop_template_example_templates"></a>模板</h4>
</div>
</div>
</div>
<p>AOP系统总是需要定义连接点<a name="N117A9" class="indexterm"></a>模型;也就是说，您必须定义（模板）程序的哪些位置可以添加其他（模板）代码。在<span class="emphasis"><em>Xpand中</em></span> ，连接点只是模板（即<span class="emphasis"><em>DEFINE ..ENDDEFINE</em></span> ）块。“方面模板”可以声明为<span class="emphasis"><em>AROUND</em></span> <a name="N117B5" class="indexterm"></a>以前存在的模板。如果您查看项目的<code class="classname">org.eclipse.demo.emf.datamodel.generator</code>源文件夹，可以找到<code class="filename">Root.xpt</code>模板文件。在里面，你可以找到一个名为<code class="classname">Impl</code>的模板，它生成JavaBean的实现。</p>
<pre class="programlisting">«DEFINE Entity FOR data :: Entity»«FILE baseClassFileName（）»//生成于«timestamp（）»公共抽象类«baseClassName（）»{«EXPAND Impl»}«ENDFILE»«ENDDEFINE»«DEFINE Impl FOR data： ：实体»«EXPAND GettersAndSetters»«ENDDEFINE»«DEFINE Impl FOR data :: PersistentEntity»«EXPAND GettersAndSetters»public void save（）{}«ENDDEFINE»</pre>
<p>我们现在想要实现的是：每当执行<span class="emphasis"><em>Impl</em></span>模板时，我们都希望运行一个额外的模板来生成额外的代码（例如，给定框架的某种元信息）。这个地方的具体代码对于此处的示例并不重要。</p>
<p>因此，在我们的新项目中，我们定义以下模板文件：</p>
<pre class="programlisting">«AROUND Impl FOR data :: Entity»«FOREACH属性AS a»public static final AttrInfo«a.name»Info = new AttrInfo（“«a.name»”，«a.type».class）; «ENDFOREACH»«targetDef.proceed（）»«ENDAROUND»</pre>
<p>因此，这个新模板包含了名为<code class="classname">Impl</code>的现有模板。它首先生成其他代码，然后使用<code class="methodname">targetDef.proceed()</code>将执行转发到原始模板。所以，实际上，这是一个<code class="varname">BEFORE</code>建议。将<code class="methodname">proceed</code>语句移动到开头使其成为<code class="varname">AFTER</code>建议，省略它，使其成为覆盖。</p>
</div>
<div class="section" title="工作流文件">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="aop_template_example_workflow_file"></a>工作流文件<a name="N117E4" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>让我们看一下运行此生成器的工作流文件：</p>
<pre class="programlisting">&lt;workflow&gt; &lt;cartridge file =“workflow.mwe”/&gt; &lt;component adviceTarget =“generator”id =“reflectionAdvice”class =“org.eclipse.xpand2。GeneratorAdvice“&gt; &lt;advices value =”templates :: Advices“/&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre>
<p>主要是，我们在这里做的是调用原始工作流文件。必须从类路径中获取它。在此墨盒调用之后，我们定义了一个额外的工作流组件，即所谓的<span class="emphasis"><em>建议组件</em></span> 。它将<span class="emphasis"><em>generator</em></span>指定为其<span class="emphasis"><em>adviceTarget</em></span> 。这意味着，我们在此通知组件中定义的所有属性都将添加到<span class="emphasis"><em>adviceTarget中</em></span>由name引用的组件中。在我们的例子中，这是发电机。因此，实际上，我们将<code class="classname">&lt;advices value="templates::Advices" /&gt;</code>到原始生成器组件（而无需有创地修改其自己的定义）。这将建议模板提供给生成器。</p>
</div>
<div class="section" title="运行新的发电机">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="aop_template_example_running_the_new_generator"></a>运行新的发电机</h4>
</div>
</div>
</div>
<p>运行生成器会生成以下代码：</p>
<pre class="programlisting">public abstract class PersonImplBase {public static final AttrInfo nameInfo = new AttrInfo（“name”，String.class）; public static final AttrInfo name2Info = new AttrInfo（“name2”，String.class）;私有字符串名称; private String name2; public void setName（String value）{this.name = value; public String getName（）{return this.name; public void setName2（String value）{this.name2 = value; public String getName2（）{return this.name2; }}</pre>
</div>
</div>
<div class="section" title="更多方面取向">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="aop_template_more_ao"></a>更多方面取向</h3>
</div>
</div>
</div>
<p>一般来说， <span class="emphasis"><em>AROUND</em></span>的语法<a name="N11810" class="indexterm"></a>构造如下：</p>
<pre class="programlisting">«AROUND fullQualifiedDefinitionNameWithWildcards（Paramlist（*）？）FOR TypeName»做东西«ENDAROUND»</pre>
<p>这里有些例子：</p>
<pre class="programlisting">«AROUND *（*）FOR Object»</pre>
<p>匹配所有模板</p>
<pre class="programlisting">«AROUND * define（*）FOR Object»</pre>
<p>匹配所有模板，其名称末尾包含<span class="emphasis"><em>define</em></span>和任意数量的参数</p>
<pre class="programlisting">«AROUND org :: eclipse :: xpand2 :: * FOR Entity»</pre>
<p>将所有模板与命名空间<span class="emphasis"><em>org :: eclipse :: xpand2 ::</em></span>匹配，它们没有任何参数，其类型为Entity或子类</p>
<pre class="programlisting">«AROUND *（String s）FOR Object»</pre>
<p>匹配具有一个<code class="classname">String</code>参数的所有模板</p>
<pre class="programlisting">«AROUND *（String s，*）FOR Object»</pre>
<p>匹配具有至少一个<code class="classname">String</code>参数的所有模板</p>
<pre class="programlisting">«AROUND my :: Template :: definition（String s）FOR Entity»</pre>
<p>恰好匹配这个单一的定义</p>
<p>在<code class="varname">AROUND</code>内部，有变量<code class="varname">targetDef</code> ，其类型为<code class="classname">xpand2::Definition</code> 。在此变量上，您可以调用<code class="methodname">proceed</code> ，还可以查询其他一些内容：</p>
<pre class="programlisting">«AROUND my :: Template :: definition（String s）FOR String»log（'invoking'+«targetDef.name»+'with'+ this）«targetDef.proceed（）»«ENDAROUND»</pre>
</div>
<div class="footnotes">
<br>
<hr align="left" width="100">
<div class="footnote">
<p>
<sup>[ <a href="#N115CB" name="ftn.N115CB" class="para">8</a> ]</sup>在Mac OSX上，默认编码是MacRoman，这不是一个好选择，因为其他操作系统不知道这种编码。建议将编码设置为更常见的编码，例如UTF-8，甚至可以用于整个工作区。</p>
</div>
</div>
</div>
</body>
</html>