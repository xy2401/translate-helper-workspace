<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <link rel="stylesheet" type="text/css" href="../css/ot.css">
      <link rel="stylesheet" type="text/css" href="../css/otjld.css">
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" >
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s2.2.html" rel="prev">&lt;&lt;§2.2降低</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.4.html" rel="next">§2.4显式角色创建&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
         <div class="sect depth2" id="s2.3">
            <h2 class="sect">§2.3提升<a class="img" href="s2.3.html" title="PermaLinkto§2.3提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <p>提升是降低的逆向翻译。但是，提升要求更高，因为给定的基础对象可能具有零到多个绑定到它的角色对象。因此，提升翻译需要更多的上下文信息，并且可能需要按需创建角色对象。
               		
            </p>
            <div class="subsect depth3" id="s2.3.a">
               <h4 class="subsect">（a） <span class="title">提升的定义</span><a class="img" href="s2.3.a.html" title="永久链接（a）提升的定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>检索给定基础对象的角色称为<strong>提升</strong> 。对于相同基础对象，相同团队实例和相同角色类的后续调用，保证提升产生相同的角色对象（有关由编译器警告和可能的运行时异常发出信号的歧义情况，请参阅<a href="#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ）。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.3.b">
               <h4 class="subsect">（b） <span class="title">解除场所</span><a class="img" href="s2.3.b.html" title="永久链接到（b）提升场所"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>提升转换不是由客户端代码调用，而是由编译器在以下位置插入转换：</p>
               <ul>
                  <li><a href="s3.3.c.html" title="§3.3。（c）结果翻译" class="sect">标注绑定（§3.3。（c））</a> （结果）</li>
                  <li><a href="s4.5.a.html" title="§4.5。（a）呼叫目标翻译" class="sect">Callin绑定（§4.5。（a））</a> （调用目标和参数）</li>
                  <li><a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">宣布解除（§2.3.2）</a></li>
               </ul>
            </div>
            <div class="subsect depth3" id="s2.3.c">
               <h4 class="subsect">（c） <span class="title">打字</span><a class="img" href="s2.3.c.html" title="永久链接到（c）打字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>提升翻译静态地期望特定的角色类。此预期角色类必须具有一个<code>playedBy</code>子句（直接或从超级角色继承（显式或隐式）），给定的基类型符合该子句。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.3.d">
               <h4 class="subsect">（d） <span class="title">提升阵列</span><a class="img" href="s2.3.d.html" title="永久链接到（d）提升阵列"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>提升也适用于角色对象数组。为了提升基础对象数组，创建一个新数组并用角色对象填充，一个用于原始数组中的每个基础对象。与角色对象本身相反，提升的数组永远不会被重用于后续的提升调用。
                  			
               </p>
            </div>
            <p id="s2.3.transpol">术语<strong>翻译多态性</strong>描述了这样的事实：在某些点处，只能考虑常规继承（ <code>extends</code> ），可以传递不符合相应声明类型的值。使用翻译多态性，可以使用提升或降低来翻译值。
               		
            </p>
            <div class="sect depth3" id="s2.3.1">
               <h3 class="sect">§2.3.1隐式角色创建<a class="img" href="s2.3.1.html" title="PermaLinkto§2.3.1隐式角色创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.3</a></span></h3>
               <p>提升尝试重用现有的角色对象，以便角色状态在提升和降低期间持续存在。如果在提升期间未找到合适的角色实例，则会创建新角色。
                  			
               </p>
               <div class="subsect depth4" id="s2.3.1.a">
                  <h4 class="subsect">（a） <span class="title">重用现有的角色对象</span><a class="img" href="s2.3.1.a.html" title="PermaLink（a）重用现有角色对象"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果这三个项目相同，则角色对象被认为适合在提升期间重复使用：</p>
                  <ol>
                     <li>给定的基础对象</li>
                     <li>给定的团队对象</li>
                     <li>静态要求的角色类型</li>
                  </ol>
                  <p>对于静态要求的角色类型和角色对象的实际类型之间的关系，请参阅<a href="#s2.3.3" title="§2.3.3智能提升" class="sect">“智能提升”（第2.3.3节）</a> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.1.b">
                  <h4 class="subsect">（b） <span class="title">默认提升构造函数</span><a class="img" href="s2.3.1.b.html" title="永久链接到（b）默认提升构造函数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>提升使用一个默认构造函数， <code>playedBy</code>接受一个声明的基类类型的参数（在<code>playedBy</code>之后）。默认情况下，编译器为每个绑定角色生成此类构造函数。另一方面，从不为绑定角色生成不带参数的默认构造函数（如<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#16823" class="ext">JLS§8.8.7</a> ）。
                     			<br>默认提升构造函数调用的超级构造函数取决于角色的超类是否为绑定角色。
                     				
                  </p>
                  <ul>
                     <li>如果超类是绑定角色，则默认提升构造函数将调用超类的默认提升构造函数。</li>
                     <li>如果超类不是绑定角色，则默认提升构造函数将调用超类的普通无参数默认构造函数。
                     </li>
                  </ul>
               </div>
               <div class="subsect depth4" id="s2.3.1.c">
                  <h4 class="subsect">（c） <span class="title">定制提升构造器</span><a class="img" href="s2.3.1.c.html" title="PermaLink至（c）定制提升构造器"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色类声明了与默认提升构造函数具有相同签名的自定义构造函数，则在提升期间使用此构造函数。此自定义构造函数可以预先假定角色已针对其基本链接正确设置并在团队的内部角色映射中注册。
                     			<br>如果绑定角色具有未绑定的超类而没有无参数构造函数，则必须提供自定义提升构造函数，因为不能生成合法的默认提升构造函数。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.1.d">
                  <h4 class="subsect">（d） <span class="title">微调角色实例化</span><a class="img" href="s2.3.1.d.html" title="PermaLink（d）微调角色实例化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果上面定义的提升操作降低了程序性能，则可以通过添加注释<code>@org.objectteams.来修改每个角色类的提升语义<code>@org.objectteams.需要参数类型为<code>org.objectteams. Instantiation</code> <code>org.objectteams.InstantiationPolicy</code>以便在以下行为之间进行选择：</p>
                  <dl>
                     <dt>一经请求</dt>
                     <dd>这是上面定义的默认行为。</dd>
                     <dt>总是</dt>
                     <dd>此策略避免维护内部角色缓存，而是为每个提升请求创建一个新的角色实例。这可能会增加角色实例的数量，但会降低访问缓存的成本，否则如果缓存变大，这可能会变得昂贵。由于此策略，角色状态不能再随时间共享，因此不鼓励使用此策略定义角色中的字段。此外，比较角色可能会导致意外结果。因此，使用此策略的角色应该实现自定义<code>equals</code>和<code>hashCode</code>方法，这些方法应该简单地委托给基本实例（使用<a href="s3.html" title="§3标注绑定" class="sect">callout§3</a> ）。
                     </dd>
                     <dt>决不</dt>
                     <dd>具有此实例化策略的角色永远不会通过提升来实例化。此类角色无法定义非静态字段。否则，此优化是完全透明的，特别是callout绑定将引用正确的基本实例。<br>从版本2.0开始，OT / J编译器不实现此策略。
                     </dd>
                     <dt>辛格尔顿</dt>
                     <dd>声明此策略的角色最多只能为每个团队实例化一次。同一团队中的后续提升请求将始终回答相同的角色实例。此类角色可能会从callin绑定接收触发器，但无法定义callout绑定。<br>从版本2.0开始，OT / J编译器不实现此策略。
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="sect depth3" id="s2.3.2">
               <h3 class="sect">§2.3.2宣布解除<a class="img" href="s2.3.2.html" title="PermaLinkto§2.3.2声明解除"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.3</a></span></h3>
               <div class="syntaxlink"><a href="sA.html#sA.6.2" title="§A.6.2LiftingType" class="syntax">→语法§A.6.2</a></div>
               <div class="subsect depth4" id="s2.3.2.a">
                  <h4 class="subsect">（a） <span class="title">声明提升的参数</span><a class="img" href="s2.3.2.a.html" title="PermaLink to（a）声明提升的参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>非静态团队级方法或构造函数可以声明具有两种类型的参数，以明确表示<strong>提升的位置</strong> 。使用语法</p>
                  <div class="listing plain"><pre><b>public</b> <b>void</b> m (BaseClass <em>as</em> RoleClass param) { <i>stmts</i> }</pre></div>
                  <p>如果第二种类型（ <code>RoleClass</code> ）是（ <code>playedBy</code> ）第一种类型（ <code>BaseClass</code> ）的角色，则可以声明一个可升级的参数。此外，角色类型必须是定义给定方法的封闭团队类的角色。角色类型必须由其简单（即不合格）名称给出。
                     			<br>这样的签名要求调用者提供基础对象（此处为<code>BaseClass</code> ），但被调用者接收角色对象（此处为<code>RoleClass</code> ）。实际上，客户端会看到一个签名，其中省略了“ <code>as RoleClass</code> ”部分。
                     			<br>呼叫者和被呼叫者之间的兼容性通过隐式插入的提升转换来实现。如果要求提升，则使用声明提升的签名仅有效（详情请参见<a href="#s2.3.3" title="§2.3.3智能提升" class="sect">§2.3.3</a>和<a href="#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ）。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.2.b">
                  <h4 class="subsect">（b） <span class="title">在宣布解除的范围内超级</span><a class="img" href="s2.3.2.b.html" title="PermaLink to（b）Super在声明提升的背景下"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在声明提升一个或多个参数的方法或构造函数中调用<code>super</code>或<code>tsuper</code>是指具有角色类型参数的方法或构造函数，即， <em>在</em>超级调用<em>之前进行</em>提升。然而，超级方法也可以具有声明的提升签名。然后它将看到与当前方法相同的角色实例。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.2.c">
                  <h4 class="subsect">（c） <span class="title">宣布解除阵列</span><a class="img" href="s2.3.2.c.html" title="PermaLink to（c）声明解除数组"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果涉及显式提升的参数应该是<strong>数组</strong>类型，则语法为</p>
                  <div class="listing plain"><pre><b>public</b> <b>void</b> m (BaseClass <b>as</b> RoleClass param[]) ...</pre></div>
                  <p>这里表示数组的括号适用于<code>BaseClass</code>和<code>RoleClass</code>这两种类型。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.2.d">
                  <h4 class="subsect">（d） <span class="title">宣布解除捕获区块</span><a class="img" href="s2.3.2.d.html" title="PermaLink to（d）声明解除catch块"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>catch块的参数也可以应用声明的提升，如：</p>
                  <div class="listing plain"><pre><b>catch</b> (BaseException <b>as</b> RoleClass param) { <i>stmts</i> }</pre></div>
                  <p>此语法仅在团队的非静态范围内有效（直接或嵌套）。在给定的示例中， <code>RoleClass</code>必须由<code>BaseException</code> 。注意， <code>RoleClass</code>本身不一定是throwable。由于此声明的效果，catch块将捕获<code>BaseException</code>类型的任何异常，并将其与<code>RoleClass</code>实例一起包装到后续块中。
                     			<br>还要注意，重新抛出给定的实例<code>param</code>具有在抛出之前隐式地将角色降低到其基本异常的语义，因为角色仅通过降低符合所需类型<code>Throwable</code> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.2.e">
                  <h4 class="subsect">（e） <span class="title">通用宣布解除</span><a class="img" href="s2.3.2.e.html" title="永久链接到（e）通用声明提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>声明提升的方法可能会引入一个相对于给定角色类型有界的类型参数。这种约束声明为：</p>
                  <div class="listing plain"><pre>&lt;AnyBase <b>base</b> SuperRole&gt;
<b>void</b> teamMethod(AnyBase <b>as</b> SuperRole arg) {
   <span class="comment">// body using arg as of type SuperRole</span>
}</pre></div>
                  <p>这意味着<code>AnyBase</code>是一个类型参数，其实例化对于角色<code>SuperRole</code>都必须是可<code>SuperRole</code> 。
                     				
                  </p>
                  <p>给定的类型绑定要求调用站点提供与任何基类兼容的参数，当前团队包含的绑定角色是<code>SuperRole</code>的子类，包括<code>SuperRole</code>本身。但是， <code>SuperRole</code>本身不需要绑定到任何基类。另一方面， <code>AnyBase</code>不同有效替换不需要通过继承来关联。
                     				
                  </p>
                  <div class="note">
                     <h5>注意：</h5>此功能支持对其他不相关的基类进行广义处理。这是通过为所考虑的每个基础定义一个绑定角色并使所有这些角色扩展一个共同的未绑定角色来完成的。
                     				
                  </div>
               </div>
               <h5 class="listing">示例代码（声明提升）：</h5>
               <div class="listing example frame" id="l2.3.2">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>team</b> <b>class</b> Super {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>public</b> <b>class</b> MyRole <b>playedBy</b> MyBase { ... }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>void</b> m (MyRole o) { ... };</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre><b>team</b> <b>class</b> Sub <b>extends</b> Super {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  <b>void</b> m (<em>MyBase <b>as</b> MyRole o</em>) {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>    <span class="comment">// inside this method o is of type MyRole</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    super.m(o);</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>Sub s_<b>team</b> = <b>new</b> Sub();</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>MyBase b = <b>new</b> MyBase();</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre>s_team.m(b); <span class="comment">// clients see a parameter "MyBase o"</span></pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <ul>
                     <li>客户端使用方法<code>m</code>和基本实例（类型<code>MyBase</code> ）作为其参数（第13行）。
                     </li>
                     <li>在执行<code>m</code>的主体之前，解除参数，使得方法体接收<code>MyRole</code>类型的参数（第8行）。
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth3" id="s2.3.3">
               <h3 class="sect">§2.3.3智能提升<a class="img" href="s2.3.3.html" title="PermaLinkto§2.3.3智能提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.3</a></span></h3>
               <p>在角色和基类是某些继承层次结构（ <code>extends</code> ）的一部分的情况下，在提升期间选择适当的角色类涉及以下规则：</p>
               <div class="subsect depth4" id="s2.3.3.a">
                  <h4 class="subsect">（a） <span class="title">静态调整</span><a class="img" href="s2.3.3.a.html" title="永久链接到（a）静态调整"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果一个基类<code>B</code>应该被提升到一个没有绑定到（ <code>playedBy</code> ） <code>B</code>的角色类<code>R</code> ，但是如果一个<code>R</code>的子类 - 比如<code>R2</code> - 被绑定到<code>B</code> ，则提升是静态设置为使用<code>R2</code> ，最通用的子类与<code>B</code>或其超类型之一绑定的<code>R</code>
                     				
                  </p>
                  <div class="note">
                     <h5>限制：</h5>此步骤不适用于<code>replace</code> callin绑定的参数映射（ <a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ）。
                     				
                  </div>
               </div>
               <div class="subsect depth4" id="s2.3.3.b">
                  <h4 class="subsect">（b） <span class="title">动态选择角色类</span><a class="img" href="s2.3.3.b.html" title="PermaLink to（b）动态选择角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在运行时，还会考虑基础对象的动态类型：提升总是尝试使用绑定到基础对象的确切类的角色类。提升考虑了由<code>playedBy</code>绑定的所有角色基对，使得角色类是所需（静态声明的）角色类型的子类，并且基类是基础对象的动态类型的超类。
                     			<br>从那些可能的对中，选择最具体的基类。如果将多个角色类绑定到此基类，则会选择这些类中最具体的类。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.3.c">
                  <h4 class="subsect">（c） <span class="title">团队作为封闭的世界</span><a class="img" href="s2.3.3.c.html" title="永久链接到（c）团队作为封闭的世界"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在上面的分析中，所有角色库对都在编译时执行。从下面可以看出，团队类只有在知道所有包含的角色类时才能编译，并且在没有团队的情况下永远不能编译角色类。
                     			<br>分析包括从超级团队继承的所有角色及其绑定。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.3.d">
                  <h4 class="subsect">（d） <span class="title">选择，无论抽象性如何</span><a class="img" href="s2.3.3.d.html" title="永久链接到（d）选择，无论抽象性如何"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>智能提升不受角色类抽象性的影响。有关抽象角色类的效果，请参见<a href="s2.5.html" title="§2.5摘要角色" class="sect">§2.5</a> 。
                     				
                  </p>
               </div>
               <h5>复杂的例子：</h5>
               <p><img src="../images/smart_lifting_small.png" alt="智能提升的例子"></p>
               <table border="2" width="80%">
                  <colgroup span="1">
                     <col align="left" span="1">
                     <col align="left" span="1">
                  </colgroup>
                  <tr>
                     <th rowspan="1" colspan="1">角色类</th>
                     <th rowspan="1" colspan="1">基类</th>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">R1级</td>
                     <td rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">class R2扩展了R1 playingBy B2</td>
                     <td rowspan="1" colspan="1">B2级</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">R3类延伸R2 <em>/ *继承：playingBy B2 * /</em></td>
                     <td rowspan="1" colspan="1">B3级延伸B2</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">R4级延伸R3播放B4</td>
                     <td rowspan="1" colspan="1">B4类扩展了B3</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">类R5扩展R4 <em>/ *继承：playingBy B4 * /</em></td>
                     <td rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"> </td>
                     <td rowspan="1" colspan="1">B6类扩展了B4</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">R7级延伸R5 playBy B7</td>
                     <td rowspan="1" colspan="1">B7类扩展了B6</td>
                  </tr>
               </table>
               <div class="codecomment">
                  <ul>
                     <li>如果声明需要将<code>B3</code>提升到<code>R1</code>则静态细化以使用<code>R2</code> ，因为这是最通用的类，声明绑定到超级<code>B3</code> 。
                        					
                     </li>
                     <li>如果相同情况下的动态基类型为<code>B6</code> ，则三个步骤选择适当的角色：<ol>
                           <li>通过搜索所有的<code>playedBy</code>子句（包括那些被继承的子句），以下角色库对是候选者：<br><code>(R2,B2), (R3,B2), (R4,B4)</code>和<code>(R5,B4)</code> 。
                           </li>
                           <li>从这些对中选择含有最特定碱基<code>B4</code>两个。
                           </li>
                           <li>这使<code>R4</code>和<code>R5</code>成为候选角色，最终选择最具体的<code>R5</code> 。
                           </li>
                        </ol>
                     </li>
                  </ul>
               </div>
               <p>如果给出了所涉及的基类和角色类的继承层次结构（如上图所示），则可以将智能提升算法改写为以下“图形”规则：<br></p>
               <div class="note">从动态基类型（示例中的<code>B6</code> ）开始向上移动继承关系，直到到达绑定到由指向基类（ <code>B4</code> ）的«playingBy»箭头指示的角色类的基类。此角色类必须符合所请求的角色类型。沿此箭头切换到角色一侧（ <code>R4</code> ）。现在向下移动角色继承层次结构，只要子角色不会细化playingBy关系（由另一个«playingBy»箭头指示）。您通过这种方式达到的最低角色（ <code>R5</code> ）是智能提升所选择的角色类型。
                  			
               </div>
            </div>
            <div class="sect depth3" id="s2.3.4">
               <h3 class="sect">§2.3.4绑定含糊不清<a class="img" href="s2.3.4.html" title="PermaLinkto§2.3.4绑定含糊不清"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.3</a></span></h3>
               <p>虽然到目前为止所有示例都只显示了1对1的类绑定，但允许多个绑定的情况。可以在编译时和/或在运行时检测模糊度。
                  			
               </p>
               <div class="subsect depth4" id="s2.3.4.a">
                  <h4 class="subsect">（a） <span class="title">潜在的模糊性</span><a class="img" href="s2.3.4.a.html" title="永久链接到（a）潜在的模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果存在两个角色类<code>R1</code>和<code>R2</code> ，则给出<strong>潜在的歧义</strong></p>
                  <ul>
                     <li><code>R1</code>和<code>R2</code>由相同的基类<code>B</code>播放，并且</li>
                     <li><code>R1</code>和<code>R2</code>具有共同的超级角色<code>R0</code> ，它也绑定到基类<code>B0</code> ，和</li>
                     <li>角色类<code>R1</code>和<code>R2</code>都不是另一个的（间接）子类。
                     </li>
                  </ul>
                  <div class="note">
                     <h5>注意：</h5>根据<a href="s2.1.c.html" title="§2.1。（c）协变细化" class="sect">§2.1。（c）中</a> ，如果<code>B</code>有别于<code>B0</code>它必须是一个亚类的<code>B0</code> 。
                     				
                  </div>
                  <div class="note">
                     <h5>影响：</h5>在这种情况下，编译器发出警告，声明<code>B</code> <em>可能不是可升级的，</em>因为角色类<code>R1</code>和<code>R2</code>都是候选者，并且没有理由<em>优先</em>选择其中一个。
                     					<br><strong>如果没有检测到潜在的歧义，那么提升将始终是明确的。</strong></div>
                  <p>在上述情况下，尝试将类型<code>B</code>的实例提升到角色类型<code>R0</code>是<strong>非法的提升请求</strong> 。如果<code>R0</code>与其子角色<code>R1</code>和<code>R2</code>绑定到相同的基类<code>B</code> ，则角色<code>R0</code>是<strong>不可释放的</strong> ，这意味着不能通过提升获得<code>R0</code>实例。
                     				
                  </p>
                  <h5 class="listing">示例代码（潜在歧义）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>class</b> SuperRole <b>playedBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleA <b>extends</b> SuperRole {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleB <b>extends</b> SuperRole {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth4" id="s2.3.4.b">
                  <h4 class="subsect">（b） <span class="title">明确的歧义</span><a class="img" href="s2.3.4.b.html" title="PermaLink to（b）明确的歧义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果有一个<strong>明确的歧义</strong></p>
                  <ul>
                     <li>根据上述（a）给出的潜在歧义的情况给出了</li>
                     <li>需要提升（通过方法绑定或显式（ <a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ））从共享基类<code>B</code>到任何角色类<code>R0</code> ，它是<code>R1</code>和<code>R2</code>的共同超级角色。
                     </li>
                  </ul>
                  <p>在通用声明提升<a href="#s2.3.2.e" title="§2.3.2.(e) Generic declared lifting" class="sect">§2.3.2的</a>情况下也会出现明确的绑定歧义<a href="#s2.3.2.e" title="§2.3.2。（e）通用宣布解除" class="sect">。（e）</a>如果指定的角色<code>R</code>是未绑定的，并且存在两个独立的子角色<code>R1</code>和<code>R2</code> ，它们将playBy绑定引入同一个基类<code>BX</code> 。在这种情况下，没有标记潜在的歧义，因为角色<code>R1</code>和<code>R2</code>没有共享绑定超级角色。
                     				
                  </p>
                  <div class="note">
                     <h5>影响：</h5>处理<code>org.objectteams.需要导致明确歧义的代码<code>org.objectteams.LiftingFailedException</code> 。
                     				
                  </div>
                  <p>在明确约束的情况下，除了一些极端情况之外，提升确实会失败。如果提升已经在缓存中找到了适当的角色，或者如果模糊绑定角色的（间接）子角色在运行时对于基础对象的具体类型是明确的提升目标，则可能出现这种极端情况。另见<a href="#s2.3.5" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> 。
                     				
                  </p>
                  <h5 class="listing">示例代码（Definite Ambiguity）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>class</b> SuperRole <b>playedBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleA <b>extends</b> SuperRole <b>playedBy</b> SubBase {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleB <b>extends</b> SuperRole <b>playedBy</b> SubBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  <b>public</b> <b>void</b> useSuperRole(SubBase <b>as</b> SuperRole r) {...} <span class="comment">// <span class="error">must declare LiftingFailedException</span></span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth4" id="s2.3.4.c">
                  <h4 class="subsect">（c） <span class="title">实际含糊不清</span><a class="img" href="s2.3.4.c.html" title="永久链接到（c）实际模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在运行时，如果要提升基础的<em>动态类型</em> ，则可能发生<strong>实际模糊</strong> ，因此上述（b）的条件相应地保持。实际模糊性仅在编译器报告为潜在或明确歧义的情况下才有可能。
                     				
                  </p>
                  <div class="note">
                     <h5>影响：</h5>通过抛出<code>org.objectteams.在运行时报告实际的歧义<code>org.objectteams.LiftingFailedException</code> 。
                     				
                  </div>
                  <h5 class="listing">示例代码（实际歧义）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>import</b> org.objectteams.LiftingFailedException;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre><b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>public</b> <b>class</b> SuperRole <b>playedBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleA <b>extends</b> SuperRole <b>playedBy</b> SubBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleB <b>extends</b> SuperRole <b>playedBy</b> SubBase {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  </pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>  <b>public</b> <b>void</b> useSuperRole(MyBase <b>as</b> SuperRole r) <b>throws</b> LiftingFailedException {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre><span class="comment">// plus these calls:</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>MyTeam mt = <b>new</b> MyTeam();</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>mt.useSuperRole(<b>new</b> SubBase()); <span class="comment">// <span class="error">will throw a LiftingFailedException</span></span></pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth4" id="s2.3.4.d">
                  <h4 class="subsect">（d） <span class="title">不匹配的作用</span><a class="img" href="s2.3.4.d.html" title="永久链接到（d）不匹配的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在可能存在歧义的情况下，可能会发生另一个运行时错误：在缓存中找到角色时遇到<strong>不匹配的角色</strong> ，该角色不符合所需的类型。如果基础对象先前已被提升到与当前请求的类型不兼容的类型，则会发生这种情况。
                     				
                  </p>
                  <div class="note">
                     <h5>影响：</h5>这是通过抛出<code>org.objectteams.来报告的<code>org.objectteams.WrongRoleException</code> 。
                     				
                  </div>
                  <h5 class="listing">示例代码（不匹配的角色）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>import</b> org.objectteams.LiftingFailedException;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>					<b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>public</b> <b>class</b> SuperRole <b>playedBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleA <b>extends</b> SuperRole {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  <b>public</b> <b>class</b> SubRoleB <b>extends</b> SuperRole {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  </pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>  <b>public</b> <b>void</b> useRoleA(MyBase <b>as</b> SubRoleA r) <b>throws</b> LiftingFailedException {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>  <b>public</b> <b>void</b> useRoleB(MyBase <b>as</b> SubRoleB r) <b>throws</b> LiftingFailedException {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre><span class="comment">// plus these calls:</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>MyTeam mt = <b>new</b> MyTeam();</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>MyBase b = <b>new</b> MyBase();</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre>mt.useRoleA(b); <span class="comment">// creates a SubRoleA for b</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">14</td>
                           <td><pre>mt.useRoleB(b); <span class="comment">// <span class="error">finds the SubRoleA which is not compatible</span></span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">15</td>
                           <td><pre>                <span class="comment">// <span class="error">to the expected type SubRoleB.</span></span></pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>从<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">§2.3.4。（a）</a>的第二项<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">开始</a> ，对于绑定歧义，不同的角色层次结构是<a href="#s2.3.4.a" title="§2.3.4。（a）潜在的模糊性" class="sect">单独</a>分析的。对于此分析，只考虑那些绑定到基类的角色类（直接使用<code>playedBy</code>或从另一个角色类继承此关系）。即，两个没有共同超级角色的角色类永远不会导致任何歧义。
                     				
                  </p>
               </div>
            </div>
            <div class="sect depth3" id="s2.3.5">
               <h3 class="sect">§2.3.5解除问题的后果<a class="img" href="s2.3.5.html" title="PermaLinkto§2.3.5解除问题的后果"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.3</a></span></h3>
               <p>提升和角色绑定的规则允许（在发出警告之后）两个有问题的情况：</p>
               <ol>
                  <li>潜在的约束歧义使得选择<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">适当的</a>角色类型成为不可能（ <a href="#s2.3.4.a" title="§2.3.4。（a）潜在的模糊性" class="sect">§2.3.4。（a）</a> ）</li>
                  <li>可能与提升相关的角色是抽象的（ <a href="s2.5.b.html" title="§2.5。（b）相关角色" class="sect">§2.5。（b）</a> ）</li>
               </ol>
               <p>每当提升失败时，由于其中一个原因， <code>org.objectteams.LiftingFailedException</code> （ LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）。鉴于这是一个经过检查的例外，并且取决于需要解除的位置，这会产生以下后果：</p>
               <div class="subsect depth4" id="s2.3.5.a">
                  <h4 class="subsect">（a）有<span class="title">问题的宣布解除</span><a class="img" href="s2.3.5.a.html" title="永久链接到（a）有问题的宣布解除"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>声明提升的方法（ <a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ）可能必须声明<code>org.objectteams.LiftingFailedException</code> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.5.b">
                  <h4 class="subsect">（b）有<span class="title">问题的标注约束</span><a class="img" href="s2.3.5.b.html" title="PermaLink到（b）有问题的标注绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>带结果提升的标注绑定的角色方法（ <a href="s3.3.c.html" title="§3.3。（c）结果翻译" class="sect">§3.3。（c）</a> ）可能必须声明<code>org.objectteams.LiftingFailedException</code> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.5.c">
                  <h4 class="subsect">（c）有<span class="title">问题的愈伤组织结合</span><a class="img" href="s2.3.5.c.html" title="PermaLink（c）有问题的callin结合"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由于<code>org.objectteams. callin绑定（ <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）可能会无声地失败<code>org.objectteams.LiftingFailedException</code> 。此异常实际上将保持隐藏，因为callin绑定未从任何源代码显式调用，而是由运行时调度机制隐式调用。为了表明这种情况，编译器会针对此类callin绑定引发错误。
                     				
                  </p>
                  <p>但是，编译器应允许配置此错误并理解警告标记<code>"hidden-lifting-problem"</code>以抑制此问题（第<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">4.1节（b）</a> ）。如果问题被忽略/抑制，并且如果在运行时发生提升问题，则触发callin绑定将无声地失败，即程序将在这种情况下继续，就好像绑定首先不存在一样。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.3.5.d">
                  <h4 class="subsect">（d） <span class="title">不兼容的角色层次结构的重新定义</span><a class="img" href="s2.3.5.d.html" title="PermaLink到（d）不兼容的角色层次结构重新定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>考虑具有方法<code>m</code>的团队<code>T1</code> ，其中关于角色<code>R</code>声明提升，其中没有检测到提升问题。接下来考虑一个子团队<code>T2</code> ，它修改角色<code>R</code>的层次结构，以便提升到<code>T2.由于绑定模糊， R</code>是有问题的。在这种情况下，调用<code>T1.m()</code>客户端可能会在运行时遇到使用<code>T2</code>的实例的情况，该实例<em>意外地</em>无法解除其角色<code>R</code>在这里，编译器发出一个特定的错误信号，反对<code>T2</code>警告不兼容的变化。
                     				
                  </p>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s2.2.html" rel="prev">&lt;&lt;§2.2降低</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.4.html" rel="next">§2.4显式角色创建&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>