<?xml version="1.0" encoding="utf-8" ?="">
<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>示例用例</title>
		<style type="text/css">
			.info {border: 1px solid #3c78b5;background-color: #D8E4F1;margin: 20px;padding: 0px 6px 0px 6px;}
			.note {border: 1px solid #F0C000;background-color: #FFFFCE;margin: 20px;padding: 0px 6px 0px 6px;}
			.panel {border: 1px solid #ccc;background-color: #FFFFCE;margin: 10px;padding: 0px 6px 0px 6px;}
			.tip {border: 1px solid #090;background-color: #dfd;margin: 20px;padding: 0px 6px 0px 6px;}
			.warning {border: 1px solid #c00;background-color: #fcc;margin: 20px;padding: 0px 6px 0px 6px;}
</style>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/bootstrap.css">
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/custom.css">
	</head>
	<body >
		<h1 id="Sample_use_case">示例用例</h1>
		<p>通过以下内容，我们将遵循元模型的生命周期，该元模型描述了一个非常基本的库，因为它在不同的分支中分别演变。这将使我们能够提供更具体的EMF Compare如何使用的示例，以及它如何为您提供帮助。</p>
		<h2 id="Creating_a_model">创建模型</h2>
		<p>对于此测试，我们假设您正在尝试在git下共享的UML模型上使用EMF Compare。这不会详细介绍UML和Git。我们假设您知道如何操作UML模型，创建或克隆git存储库，在其下共享项目以及使用标准Git操作。</p>
		<p>我们的示例项目的名称将是“library”。它包含一个包含两个模型的文件夹“model”：</p>
		<ul>
			<li>library_Types.uml将包含我们的原始类型，</li>
			<li>library.uml将包含我们的实际模型。</li>
		</ul>
		<p>这两个模型将致力于我们的git clone。整件事看起来像这样：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Setup.png">
		</p>
		<p>模型本身是一个非常简单的库。从图形上讲：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Model.png">
		</p>
		<p>既然已经提交了这个初始模型文件，我们想稍微改进一下。例如 ：</p>
		<ul>
			<li>向<i>Writer</i>类添加<i>别名</i>属性，</li>
			<li>添加新的<i>历史记录</i>类别，</li>
			<li>将<i>Book</i>的<i>pages</i>属性重命名为<i>length</i> 。
			</li>
		</ul>
		<p>我们的模型现在看起来像这样：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Model_Changed.png">
		</p>
		<p>但我们怎么知道到底发生了什么变化呢？让我们将它与Git Index中的文件进行比较：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_1.png">
		</p>
		<p>这将打开一个比较编辑器，最初看起来如下所示：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_2.png">
		</p>
		<p>这个编辑器有三个主要的兴趣领域。</p>
		<ol>
			<li>显示当前版本的模型与Git索引中的版本之间检测到的差异的结构化列表。</li>
			<li>这将对（1）中的选择作出反应并显示该比较的<i>左侧</i> 。根据经验， <i>左边</i>是模型的<i>本地</i>版本。在此示例中， <i>left</i>将是我们在工作区中修改的版本。这最初填充了顶部面板（1）中选择的第一个差异，更多内容在下面的示例中的此部分。
			</li>
			<li>如上所述，这将对（1）中的选择做出反应，但这次它将显示比较的<i>右侧</i> 。这通常是模型的<i>远程</i>版本;我们比较我们的版本。在这种情况下，这将表示模型的版本，因为它在Git索引中。这最初是空的，更多关于下面示例中的此部分。
			</li>
		</ol>
		<p>如上所述，（2）和（3）最初填充在顶部面板（1）中选择的差值。这两个面板用于显示有关模型之间检测到的差异的更多信息。让我们选择（1）中显示的另一个差异：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_3.png">
		</p>
		<ol>
			<li>我们在类<b>Writer中</b>选择了与属性<b>别名</b>相加的差异。双击这个差异更新了我们下面的两个窗格。
			</li>
			<li>
				<b>别名</b>已添加到Class <b>Writer</b>的属性中。在模型中，这对应于<i>Writer</i>类的引用<i>ownedAttributes</i>的更改。此子面板指示在oder中更改的实际引用以提醒我们上下文。
			</li>
			<li>这将显示（2）中列出的参考值的所有值，因为它们在<i>左侧</i>模型中。这是我们看到新值的地方， <b>别名</b>概述。
			</li>
			<li>对于（2），这将显示所选差异的上下文。通常在（2）和（4）中显示相同的参考。</li>
			<li>此面板显示（4）中概述的参考值的所有值，因为它们在<i>正确的</i>模型中。在这里，我们看到<b>别名</b>的位置被概述为空白区域。如果合并它，这个矩形就会添加新值...虽然在这种情况下，不可能<i>向右</i>合并：它是位于存储库中的版本，因此是不可编辑的。
			</li>
		</ol>
		<p>这对于确定我们的版本中确切改变了什么很有用，但没有其他用途：在此合并更改只意味着从存储库中恢复对“干净”状态的修改。让我们提交我们的更改。</p>
		<h2 id="Branching">分枝</h2>
		<p>现在，我们想为我们的图书馆创建一个新功能：我们希望客户能够借阅我们的图书。我们将分支我们的存储库以创建这个新功能并命名这个新的分支<i>借用方</i> ：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_4.png">
		</p>
		<p>立即开始，我们在模型中添加必要的新概念，以表示借书的可能性。我们“可能”以后需要有更多的书可以出借，所以让我们制作一个<i>Borrowable</i>界面来保持这个概念。我们还需要一个<i>Person</i>类，以及一个新的数据类型来表示该人的出生日期：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_5.png">
		</p>
		<p>在树形查看器中，我们的模型现在看起来像（以红色突出显示，我们在此步骤中添加的概念）：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_6.png">
		</p>
		<p>然而，当我们正在开发我们的<i>借用</i>分支时， <i>主</i>分支仍然可能会发展：项目中的其他人可能会添加他们自己的新概念，或者我们可能会切换到主分支以获得高优先级的修复。让我们假设自从我们对存储库进行分支后添加了两个功能。首先，有人需要让图书馆不仅拥有书籍，还拥有杂志。其次，我们需要记录我们的书籍和杂志的出版日期。
		</p>
		<p>这两个提交中的第一个将向我们的<i>主</i>分支模型添加以下概念：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_7.png">
		</p>
		<p>而第二个只添加基本类型和属性：</p>
		<p>
			<img border="0" src="../images/EMF_Compare_Use_Compare_8.png">
		</p>
		<h2 id="Merge">合并</h2>
		<p>如果您已经遵循这一点，我们现在有两个不同的分支， <i>主</i>分支和<i>借用</i>分支，它们都拥有我们的<i>library.uml</i>模型的不同版本。以下是这两个模型在这一点上的表现：</p>
		<table border="1" cellpadding="5" cellspacing="0">
			<tr>
				<th align="center">主</th>
				<th align="center">Borrowables</th>
			</tr>
			<tr>
				<td>
					<img align="middle" border="0" src="../images/EMF_Compare_Use_Compare_Master.png">
				</td>
				<td>
					<img align="middle" border="0" src="../images/EMF_Compare_Use_Compare_5.png">
				</td>
			</tr>
		</table>
		<p>在我们继续处理Borrowables分支之前，我们想要检索已经推送到master的所有修改。检查“Borrowables”分支后，我们将使用<i>Compare With&gt; Branch，Tag或Reference</i>操作：</p>
		<p>
			<img align="middle" border="0" src="../images/EMF_Compare_Use_Compare_With_Master_1.png">
		</p>
		<p>并与主人比较：</p>
		<p>
			<img align="middle" border="0" src="../images/EMF_Compare_Use_Compare_With_Master_2.png">
		</p>
		<p>这向我们展示了自“分支”点以来我们的本地副本和主分支之间的所有差异。</p>
		<p>
			<img align="middle" border="0" src="../images/EMF_Compare_Merge.png">
		</p>
		<p>与之前相同，您可以通过顶部面板（结构视图）浏览差异。这里显示了三种主要元素。
			模仿输入模型的包含树的<b>常规</b>元素可以分离各种差异，让您知道实际检测到它们的位置。然后有<b>传入的</b>差异，用蓝色箭头装饰（ <img border="0" src="../images/EMF_Compare_Incoming_Change.gif"> ）或衍生图标，以及用绿色箭头装饰的<b>外向</b>差异（ <img border="0" src="../images/EMF_Compare_Outgoing_Change.gif"> ）或派生图标。
		</p>
		<pre>* <b>Incoming</b> differences are changes that were made in the remote branch (here, <i>master</i>) since the branching point (common ancestor).
* <b>Outgoing</b> differences are changes that were made in the local copy (here, the <i>borrowables</i> branch) since the branching point.
</pre>
		<p>这里没有冲突，因为UML使用模型元素的计算标识符（XMI ID）。因此，看起来像冲突（在类型包中的两个分支上添加的“日期”类型）实际上是两个明显的差异。</p>
		<p>界面还允许您通过显示两个模型的共同祖先<img border="0" src="../images/EMF_Compare_Ancestor.gif">图标。例如，如果我们选择<b>Book</b>类，我们可以看到它在所有三个版本中的样子：</p>
		<p>
			<img align="middle" border="0" src="../images/EMF_Compare_Merge_Book_Ancestor.png">
		</p>
		<p>您可以使用前面的相应操作来导航差异（ <img border="0" src="../images/EMF_Compare_Prev_Diff.gif"> ）或下一个（ <img border="0" src="../images/EMF_Compare_Next_Diff.gif"> ） 区别。
		</p>
		<p>剩下的两个动作是我们真正感兴趣的行为，我们可以将所有非冲突的差异合并到本地副本中<img border="0" src="../images/EMF_Compare_Copy_All.gif">或者将它们一个接一个地合并到一起<img border="0" src="../images/EMF_Compare_Copy.gif"> 。
		</p>
		<p>合并<b>所有</b>差异并不是我们所寻求的：我们希望保留我们在本地进行的更改，而不是将它们恢复到分支点之前的状态（这是它们在<i>master</i>上的当前状态，右侧）。然后，我们将一个接一个地选择所有<i>传入的</i>差异并逐个合并。这给了我们合并的模型：</p>
		<p>
			<img align="middle" border="0" src="../images/EMF_Compare_Merged.png">
		</p>
		<p>请注意， <i>合并的</i>差异以<i>斜体</i>显示，并具有不同的图标。剩下的就是保存，我们的模型现在包含我们的本地更改和对master进行的更改。
		</p>
	</body>
</html>