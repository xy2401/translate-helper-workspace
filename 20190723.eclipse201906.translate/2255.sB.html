<html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="sB">
            <div class="headl">
               <div class="headr">
                  <h1>§B版本之间的变化</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sB.html">§B版本之间的变化</a></li>
                  <li><a href="#sB.1">§B.1版本之间的段落发生了变化</a></li>
                  <li><a href="#sB.2">§B.2版本之间的增加</a></li>
               </ul>
            </div>
            <div class="sect depth2" id="sB.1">
               <h2 class="sect">§B.1版本之间的段落发生了变化<a class="img" href="sB.1.html" title="PermaLinkto§B.1版本之间的段落发生了变化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.1.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.1.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s3.2.a.html" title="§3.2。（a）with clause" class="sect">§3.2。（a）</a> ： <strong>参数映射</strong><p>禁止角色接口中的参数映射。
                           			
                        </p>
                     </li>
                     <li><a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ： <strong>替换绑定</strong><p>禁止不安全地使用多态和原始类型转换。
                           			
                        </p>
                     </li>
                     <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法的签名</strong><p>使两个方法通用，以便可以使用返回值而无需进行转换。
                           				
                        </p>
                     </li>
                     <li><a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ：受<strong>限制的角色</strong><p>改进的解释。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.1.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.1.e.html" title="§1.2.1。（e）角色特征" class="sect">§1.2.1。（e）</a> ： <strong>角色特征的可见性</strong><p>添加了澄清说明角色可以始终访问其封闭团队有权访问的所有功能。
                           				
                        </p>
                     </li>
                     <li><a href="s2.1.2.e.html" title="§2.1.2。（e）没有自由类型参数" class="sect">§2.1.2。（e）</a> ： <strong>通用角色/基础</strong><p>放宽了有关通用绑定角色的规则。这种变化也包含了先前在<a href="s4.1.b.html" title="§4.1.(b) Prerequisite: Class binding" class="sect">§4.1中</a>的具体限制<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">。（b）</a> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.i.html" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a>和<a href="s3.5.f.html" title="§3.5。（f）速记定义" class="sect">§3.5。（f）</a> ： <strong>速记标注的可见性</strong><p>由速记标注绑定定义的角色方法现在可以指定可见性修饰符（另请参见<a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ），否则它将继承其绑定基本方法/字段的可见性修饰符。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断标注的可见性</strong><p>推断为标注绑定的角色方法是<code>public</code> （通过接口推断）或从自我调用/字段访问推断的<code>private</code> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>没有明确使用推断的字段</strong><p>已添加澄清说明，无法显式调用为推断的字段调用生成的访问器方法。
                           				
                        </p>
                     </li>
                     <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>没有通用角色的callin</strong><p>已经明确规定，通用角色无法定义callin绑定。
                           				
                        </p>
                     </li>
                     <li><a href="s4.2.d.html" title="§4.2。（d）Callin方法" class="sect">§4.2。（d）</a> ： <strong>Callin方法</strong><p>稍微改写并扩展规则以明确表示使用第二级callin绑定确实可以拦截callin方法。
                           				
                        </p>
                     </li>
                     <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法<code>getAllRoles</code></strong><p>更高精度：仅回答<em>绑定</em>角色。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.1.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字的语法</strong><p>以前，不支持语法<code>R&lt;@t&gt;.class</code> 。此限制已被删除。
                           					
                        </p>
                     </li>
                     <li><a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ： <strong>团队扩展非团队类</strong><p>以前， <code>org.objectteams.Team</code>是所有团队课程的超级班级。因此，团队无法扩展非团队类。通过引入所有团队的新超类型，界面<code>org.objectteams. ，已经消除了这一限制<code>org.objectteams.ITeam</code> 。当成员被移动到新界面时，此更改也会影响<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中的</a>某些段落。
                           					
                        </p>
                     </li>
                     <li><a href="s1.5.e.html" title="§1.5。（e）不同超级之间的优先权" class="sect">§1.5。（e）</a> ： <strong>不同隐式超级之间的优先权</strong><p>纠正了不同超级中优先级规则的不一致性：主要规则一直是隐式继承比显式继承更强，但是，对于不同隐式超级中的优先级，定义了不同的规则。<br>这已被改变，使得不同的隐<em>式</em>超级优先于其封闭团队的优先级，使得来自<em>隐式</em>超级团队的角色与来自<em>显式</em>超级团队的角色更紧密相关。
                           					
                        </p>
                     </li>
                     <li><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）</a> ： <strong>放宽了对基类循环的规则</strong><p><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）中</a>定义的基类循环不再是错误，而是可配置警告。但是，在存在基类循环的情况下，不允许调用（第<a href="s2.4.2.html" title="§2.4.2 Role creation via a regular constructor" class="sect">3.1节</a> <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">（a）</a> ）和基本构造函数调用（第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2节</a> ）。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ： <strong>更改了角色绑定歧义的处理</strong><p>明确的绑定歧义不再是（可抑制的）编译器错误，而是由声明<code>org.objectteams.的需要发出信号<code>org.objectteams.LiftingFailedException</code> 。通过这种方式，诊断可以从团队中非常不特定的位置移动到那些在运行时可能因提升失败而受到影响的应用程序。虽然通常不建议忽略任何<code>LiftingFailedException</code>但在<a href="s2.3.4.b.html" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4。（b）中</a>提到的一些<a href="s2.3.4.b.html" title="§2.3.4。（b）明确的歧义" class="sect">极端</a>情况下，捕获此异常仍然有意义。
                           					
                        </p>
                     </li>
                     <li><a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ： <strong>进一步限制callin绑定后的结果映射</strong><p>澄清<code>after</code> callin绑定<code>after</code>无法使用<code>-&gt;</code>标记来映射结果值。
                           					
                        </p>
                     </li>
                     <li><a href="s4.8.a.html" title="§4.8。（a）优先权声明" class="sect">§4.8。（a）</a> ： <strong>影响callin绑定<code>after</code>优先声明。</strong><p>虽然以前优先声明的效果不明确，但已经定义优先声明中元素的顺序会影响它们的<em>优先级，</em>类似于<a href="s5.1.html" title="§5.1团队激活的影响" class="sect">§5.1</a> 。这意味着与先前的实现相比， <code>after</code>绑定的执行顺序现在是颠倒的。为了在程序中可视化，现在必须使用关键字<code>after</code>标记后绑定的优先声明。
                           					
                        </p>
                     </li>
                     <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ， <a href="s4.10.a.html" title="§4.10。（a）新鲜型参数" class="sect">§4.10。（a）</a> ： <strong>通用的callin绑定</strong><p><a href="s4.10.e.html" title="§4.10.(e) Propagating type parameters" class="sect">稍作</a>修改，为新段落<a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）留出</a>空间。
                        </p>
                     </li>
                     <li><a href="s5.4.1.a.html" title="§5.4.1。（a）方法绑定警卫" class="sect">§5.4.1。（a）</a> ： <strong>定期装订守卫的范围</strong><p>在常规方法绑定防护中删除了关于特殊标识符<code>result</code>的错误句子。由于在评估保护之前应用了参数映射，因此可以通过结果映射（ <a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ）访问结果值。此外，这句话实际上混淆了基础和角色方面。
                           	
                        </p>
                     </li>
                     <li><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ， <a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="sect">§A.3.3</a> ： <strong>语法：泛型方法绑定</strong><p>方法绑定中可能的类型参数的位置已经明确。</p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.4">
                  <h4 class="subsect">（4） <span class="title">在OTJLD 1.3和OTJLD 1.4之间</span><a class="img" href="sB.1.4.html" title="PermaLink to（4）OTJLD 1.3和OTJLD 1.4之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ： <strong>没有按需基础进口</strong><p>已经澄清，基础进口不能是按需进口（使用通配符） <code>.*</code> ）。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="sB.2">
               <h2 class="sect">§B.2版本之间的增加<a class="img" href="sB.2.html" title="PermaLinkto§B.2版本之间的增加"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.2.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.2.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字</strong><p>使现有功能显式化并为外化角色引入新的限定类文字。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断出的标注</strong><p>新功能。
                           				
                        </p>
                     </li>
                     <li><a href="s4.6.a.html" title="§4.6。（a）超级班的私人方法" class="sect">§4.6。（a）</a> ： <strong>来自超级类的Callin绑定私有方法</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                     <li><a href="s4.9.html" title="§4.9Callin继承" class="sect">§4.9</a> ： <strong>Callin继承</strong><p>澄清了指定不充分或解释不充分的问题，具体而言：</p>
                        <ul>
                           <li>callin绑定对遗传或被覆盖的基本方法的影响（ <a href="s4.9.1.html" title="§4.9.1基础侧继承" class="sect">§4.9.1</a> ）。
                           </li>
                           <li>callin绑定和基本方法与协变返回类型的<a href="s4.9.3.html" title="§4.9.3 Covariant return types" class="sect">相互作用</a> （ <a href="s4.9.3.html" title="§4.9.3协变返回类型" class="sect">§4.9.3</a> ）</li>
                        </ul>
                     </li>
                     <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ： <strong>通用替换绑定</strong><p>通过使用类型参数调整<a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）中</a>引入的替换绑定的类型安全性，并具有所需的灵活性。
                           				
                        </p>
                     </li>
                     <li><a href="s7.2.b.html" title="§7.2。（b）受限阵列" class="sect">§7.2。（b）</a> ： <strong>受限制的阵列</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.2.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.2.h.html" title="§1.2.2。（h）外化创作" class="sect">§1.2.2。（h）</a> ： <strong>外化创作</strong><p>使用值参数和更改的标题添加了替代语法。</p>
                     </li>
                     <li><a href="s1.2.5.f.html" title="§1.2.5。（f）进口角色档案" class="sect">§1.2.5。（f）</a> ： <strong>角色文件中的导入</strong><p>添加了缺少的规则，用于定义角色文件中的导入效果。</p>
                     </li>
                     <li><a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">§1.3.1。（c）</a> ： <strong>@</strong> <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">Override</a> <strong>角色注释</strong><p>常规的<code>@Override</code>注释（Java≥5）也已扩展为适用于角色类。
					
                        </p>
                     </li>
                     <li><a href="s1.3.1.k.html" title="§1.3.1。（k）协变返回类型" class="sect">§1.3.1。（k）</a> ： <strong>协变返回类型</strong><p>在存在隐式和显式继承的情况下协变返回类型的必要约束。
                           					
                        </p>
                     </li>
                     <li><a href="s2.1.2.c.html" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ： <strong>绑定到最终基类</strong><p>已经补充说，绑定到最终基类现在也被视为解封装。
                           					
                        </p>
                     </li>
                     <li><a href="s2.2.f.html" title="§2.2。（f）模糊降低" class="sect">§2.2。（f）</a> ： <strong>模糊降低</strong><p>添加了一个诊断来检测可能意图降低但由于声明的类型是<code>java.lang.而失败的情况<code>java.lang.Object</code> ，这使得潜在的降低翻译变得不必要并且因此是模糊的。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.2.e.html" title="§2.3.2。（e）通用宣布解除" class="sect">§2.3.2。（e）</a> ： <strong>通用声明提升</strong><p>支持将不相关的基类型传递到声明提升的相同方法中。
                           					
                        </p>
                     </li>
                     <li><a href="s2.6.g.html" title="§2.6。（g）通过基准参考进行解封装" class="sect">§2.6。（g）</a> ： <strong>通过基准参考进行解封装</strong><p>将解封装扩展到两个以上的位置。
                           					
                        </p>
                     </li>
                     <li><a href="s4.3.f.html" title="§4.3。（f）基本超级电话" class="sect">§4.3。（f）</a> ： <strong>基本超级呼叫</strong><p>支持base直接调用绑定基本方法的超级版本，从而绕过精确绑定的基本方法以及与此基本方法或其超级版本相关的任何其他callins。
                           					
                        </p>
                     </li>
                     <li><a href="s5.4.b.html" title="§5.4。（b）无副作用" class="sect">§5.4。（b）</a> ： <strong>守卫谓词的副作用</strong><p>将有关未来功能的先前注释迁移到常规段落。</p>
                     </li>
                     <li><a href="s5.4.c.html" title="§5.4。（c）例外情况" class="sect">§5.4。（c）</a> ： <strong>守卫谓词的例外情况</strong><p>澄清从保护谓词抛出的异常的影响。</p>
                     </li>
                     <li><strong>§6.2</strong> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ： <strong>LiftingVetoException</strong><p>添加了大部分内部<code>LiftingVetoException</code>文档以及它如何在客户端代码中实际使用。
                           				    
                        </p>
                     </li>
                     <li><a href="s6.2.e.html" title="§6.2。（e）角色迁移" class="sect">§6.2。（e）</a> ： <strong>角色迁移</strong><p>添加了两个接口，以将迁移功能添加到角色类。
                           				    
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.2.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a> ：将<strong>角色绑定到基接口</strong><p><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a>中提到的实施限制已被大部分删除。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.1.d.html" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> ： <strong>微调角色实例化</strong><p>已经定义了注释用于修改提升的语义以便提高性能。此外，还添加了一个新的部分作为<a href="s6.3.html" title="§6.3注释" class="sect">§6.3，</a>以总结本文档中定义的注释类型。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ： <strong>解除问题的后果</strong><p>在<a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a>澄清了<code>LiftingFailedException</code> （ <code>LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）确实是一个经过检查的异常之后，又添加了一个子节来定义这种异常在各种程序情况下的后果。
                           					
                        </p>
                     </li>
                     <li><a href="s3.1.k.html" title="§3.1。（k）通用方法的标注" class="sect">§3.1。（k）</a> ： <strong>通用方法的标注</strong><p>添加了关于callout绑定如何引用泛型基本方法的规则。
                           					
                        </p>
                     </li>
                     <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>Callin以“不可授予的”角色进行约束</strong><p>现在甚至可以在“unliftable”角色中定义Callin绑定。
                           	
                        </p>
                     </li>
                     <li><a href="s4.1.h.html" title="§4.1。（h）封闭类的方法" class="sect">§4.1。（h）</a> ： <strong>绑定团队方法</strong><p>callin绑定<code>before</code>和<code>after</code>现在也可以绑定到封闭类的方法。
                           	
                        </p>
                     </li>
                     <li><a href="s4.8.d.html" title="§4.8。（d）多个优先权陈述" class="sect">§4.8。（d）</a> ： <strong>合并优先声明时的顺序</strong><p>阐明了如何合并多个优先级声明，这是未指定的，因为C3算法需要有序输入，但未指定此顺序。
                           					
                        </p>
                     </li>
                     <li><a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ： <strong>在callin绑定中传播类型参数</strong><p>除了捕获协变返回类型之外，callin绑定还可以声明类型参数，以便将通用性从其基本方法传播到角色方法。
                           	
                        </p>
                     </li>
                     <li><a href="s5.3.d.html" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> ： <strong>配置隐式激活</strong><p>添加了用于配置隐式团队激活的机制。默认值已更改为不应用隐式激活。<a href="s5.3.html" title="§5.3隐式团队激活" class="sect">§5.3中</a>也增加了相应的注释</p>
                     </li>
                     <li><a href="s9.2.1.a.html" title="§9.2.1。（a）实例约束类型参数" class="sect">§9.2.1。（a）</a> ： <strong>实例约束类型参数</strong><p>类型锚现在也可以应用于类型参数，从而在类型参数上表达一种新的约束。
                           	
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.4">
                  <h4 class="subsect">（4） <span class="title">OTJLD 1.3之后</span><a class="img" href="sB.2.4.html" title="PermaLink至（4）OTJLD 1.3之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s4.1.i.html" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ： <strong>致电建设者</strong><p>绑定后的callin现在也可以应用于基类的构造函数。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html>