<html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>Eclipse支持</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="ide-concepts">Eclipse支持</h1>

<p>对于以下部分，我们将参考<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/Statemachine.xtext">状态机示例</a>来描述Xtext的UI功能的不同方面。</p>

<h2 id="label-provider">标签提供商</h2>

<p>UI中有许多地方必须向用户呈现模型元素：在<a href="#outline">大纲视图中</a> ，在<a href="#hyperlinking">超链接中</a> ，在<a href="#content-assist">内容提案中</a> ，查找对话框等.Xtext允许通过<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProvider.html">ILabelProvider</a>接口的单独实现来自定义每个外观。</p>

<p><a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProvider.html">ILabelProvider</a>有两个方法： <code>getText(Object)</code>返回对象标签中的文本，而<code>getImage(Object)</code>返回图标。此外，Eclipse UI框架提供了<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DelegatingStyledCellLabelProvider.IStyledLabelProvider.html">IStyledLabelProvider</a> ，它在<code>getStyledText(Object)</code>方法中返回<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledString.html">StyledString</a> （即使用自定义字体，颜色等）。</p>

<p>Xtext框架中的几乎所有标签提供程序都继承自基类<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/AbstractLabelProvider.java">AbstractLabelProvider</a> ，它统一了这两种方法。子类可以在<code>doGetText(Object)</code>方法中返回样式字符串或字符串。框架将自动将其转换为样式文本（具有默认样式）或相应方法中的纯文本。</p>

<p>处理图像也很麻烦，因为图像处理往往是稀缺的系统资源。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/AbstractLabelProvider.java">AbstractLabelProvider</a>可以帮助您管理图像：在<code>doGetImage(Object)</code>实现中，您还可以返回<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Image.html">Image</a> ， <a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageDescriptor.html">ImageDescriptor</a>或字符串，表示包含插件的<em>icons /</em>文件夹中的路径。此路径实际上可由Google Guice配置。看看<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/PluginImageHelper.java">PluginImageHelper</a> ，了解自定义的可能性。</p>

<p>如果您的语言的MWE2工作流中的生成器片段列表中有<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/ui/labeling/LabelProviderFragment2.xtend">LabelProviderFragment2</a> ，它将自动为<a href="#eobject-label-provider"><code>{MyLang}EObjectLabelProvider</code></a>和<a href="#description-label-provider"><code>{MyLang}DescriptionLabelProvider</code></a>创建存根和绑定，您可以手动实现它们。</p>

<h3 id="eobject-label-provider">EObjects的标签提供者</h3>

<p>EObject标签提供程序引用实际加载的，从而可用的模型元素。默认情况下，Xtext将<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/DefaultEObjectLabelProvider.java">DefaultEObjectLabelProvider</a>绑定到所有用例，但您可以单独更改Outline，Content Assist或其他位置的绑定。为此，每个用例都有一个所谓的<em>绑定注释</em> 。例如，要使用自定义<em>MyContentAssistLabelProvider</em>在内容辅助中显示元素，您必须在语言的UI模块中覆盖<code>configureContentProposalLabelProvider(..)</code> ：</p>

<pre><code class="language-java">@Override public void configureContentProposalLabelProvider（Binder binder）{binder.bind（ILabelProvider.class）.annotatedWith（ContentProposalLabelProvider.class）.to（MyContentAssistLabelProvider.class）; }</code></pre>

<p>如果您的语法使用导入的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">EPackage</a> ，则可能存在EMF生成的现有<em>编辑</em>插件，该插件还为模型元素提供标签提供程序。要将此作为回退使用，标签提供程序应使用delegate参数调用构造函数，并使用依赖注入进行初始化，例如</p>

<pre><code class="language-java">public class MyLabelProvider {@Inject public MyLabelProvider（AdapterFactoryLabelProvider delegate）{super（delegate）; }}</code></pre>

<h4 id="default-eobject-label-provider">DefaultEObjectLabelProvider</h4>

<p><a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProvider.html">ILabelProvider</a>接口的默认实现利用多态调度程序惯用法来实现外部访问者，因为标签提供者的要求是这种模式的最佳匹配。归结为这样一个事实，你唯一需要做的就是实现一个匹配特定签名的方法。它提供图像文件名或用于表示模型元素的文本。请查看以下示例以获取有关<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/DefaultEObjectLabelProvider.java">DefaultEObjectLabelProvider</a>的更详细信息。</p>

<pre><code class="language-java">public class SecretCompartmentsLabelProvider扩展DefaultLabelProvider {public String text（Event event）{return event.getName（）+“（”+ event.getCode（）+“）”; public字符串图像（事件事件）{return“event.gif”; public String image（State state）{return“state.gif”; }}</code></pre>

<p>默认实现的特别之处在于其类名的实际原因：它提供了非常合理的默认值。要计算某个模型元素的标签，它将首先查找<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java">EAttribute</a> <em>名称</em>并尝试使用此<em>名称</em> 。如果找不到这样的功能，它将尝试使用可以最好地用作标签的第一个功能。在最坏的情况下，它将返回模型元素的类名，这是不太可能发生的。</p>

<p>您也可以通过重写方法自定义错误处理<code>handleTextError()</code>或<code>handleImageError()</code></p>

<h3 id="description-label-provider">索引条目的标签提供程序</h3>

<p>Xtext维护所有模型元素的索引，以允许快速搜索和链接，而无需加载引用的资源（有关详细信息，请参阅有关基于<a href="303_runtime_concepts.html#index-based">索引的范围</a>的章节）。此索引中的元素也出现在某些UI上下文中，例如，在“ <em>查找模型元素”</em>对话框或“ <em>查找引用”</em>视图中。出于可伸缩性的原因，UI不应自动加载资源，因此我们需要另一个标签提供程序实现，该标签提供程序使用索引中的元素，即<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription</a> ， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IReferenceDescription.java">IReferenceDescription</a> 。</p>

<p>此服务的默认实现是<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/DefaultDescriptionLabelProvider.java">DefaultDescriptionLabelProvider</a> 。它使用与<a href="#default-eobject-label-provider">DefaultEObjectLabelProvider</a>相同的多态分派机制。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription</a>的默认文本是其索引名称。通过使用所描述对象的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java">EClass</a>分派到<code>image(EClass)</code>来解析<code>image(EClass)</code> 。这可能是您要覆盖的唯一方法。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription的</a>实例将以其路径和为您的语言编辑器注册的图标来表示。</p>

<p>要拥有自定义描述标签提供程序，请确保它绑定在UI模块中：</p>

<pre><code class="language-java">public void configureResourceUIServiceLabelProvider（Binder binder）{binder.bind（ILabelProvider.class）.annotatedWith（ResourceServiceDescriptionLabelProvider.class）.to（MyCustomDefaultDescriptionLabelProvider.class）; }</code></pre>

<h2 id="content-assist">内容辅助</h2>

<p>除其他外，Xtext生成器生成以下两个与内容辅助相关的工件：</p>

<ul>
  <li>名为<code>Abstract{MyLang}ProposalProvider</code>的抽象提议提供程序类生成到<em>ui</em>项目中的<em>src-gen</em>文件夹中，并且</li>
  <li><em>ui</em>项目的<em>src</em> -folder中的一个具体子类，名为<code>{MyLang}ProposalProvider</code></li>
</ul>

<p>首先，我们将使用如下所示的方法调查生成的<code>Abstract{MyLang}ProposalProvider</code> ：</p>

<pre><code class="language-java">public void complete {TypeName} _ {FeatureName}（EObject模型，赋值赋值，ContentAssistContext上下文，ICompletionProposalAcceptor接受者）{//客户端可以覆盖} public void complete_ {RuleName}（EObject model，RuleCall ruleCall，ContentAssistContext context，ICompletionProposalAcceptor acceptor）{ //客户可能会覆盖}</code></pre>

<p>上面的代码段表明生成的类包含语法和每个规则中每个指定功能的<em>完整*</em>方法。片段中的大括号是占位符，应该提供有关用于为实现者创建各种入口点的命名方案的线索。生成的提案提供程序会回退到交叉引用和关键字的某些默认行为。此外，它继承了混合到当前语言中的语法中引入的逻辑。</p>

<p>想要自定义行为的客户端可以覆盖<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/contentassist/AbstractJavaBasedContentProposalProvider.java">AbstractJavaBasedContentProposalProvider中</a>的方法，或者使用专门的第一个参数引入新方法。框架检查模型对象的类型，并将方法调用分派给可以找到的最具体的实现。</p>

<p>重要的是要知道，对于模型文件中的给定偏移，存在许多可能的语法元素。框架将调度任何有效元素的方法声明。这意味着可以调用一堆<em>完整的*</em>方法。</p>

<p>要为<code>event</code>实例的代码提供虚拟提议，可以引入生成方法的特化并按如下方式实现。这将提出<code>ZonkID</code>与名称的事件<code>Zonk</code> 。</p>

<pre><code class="language-xtend">override void completeEvent_Code（Event event，Assignment assignment，ContentAssistContext context，ICompletionProposalAcceptor acceptor）{//超类super.completeEvent_Code的调用实现（模型，赋值，上下文，接受器）//计算普通提议val String proposal = event.getName（） +“ID”//创建并注册完成建议：//建议可能为null，因为createCompletionProposal（..）//方法检查有效前缀和终端令牌冲突。// acceptor正常处理null值。acceptor.accept（createCompletionProposal（proposal，context））}</code></pre>

<h2 id="quick-fixes">快速修复</h2>

<p>对于使用<a href="303_runtime_concepts.html#custom-validation">AbstractDeclarativeValidator</a>编写的验证，可以在编辑器中提供相应的快速修复。为了能够对给定诊断（警告或错误）实施快速修复，必须知道诊断的根本<em>原因</em> （即诊断代表什么实际问题），否则修复不知道需要做什么。由于我们不想从诊断的错误消息中推断出这一点，因此我们将特定于问题的<em>代码</em>与诊断相关联。</p>

<p>在以下来自<em>DomainmodelJavaValidator</em>的示例中，诊断的<em>代码</em>由<code>warning()</code>方法的第三个参数给出，它是对validator类中的静态<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a>字段<code>INVALID_TYPE_NAME</code>的引用。</p>

<pre><code class="language-java">警告（“名称应以大写字母开头”，DomainmodelPackage。TYPE__NAME，INVALID_TYPE_NAME，type.getName（））;</code></pre>

<p>现在验证具有识别问题的唯一代码，我们可以为其注册快速修复。我们首先将<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/ui/quickfix/QuickfixProviderFragment2.xtend">QuickfixProviderFragment2</a>添加到我们的工作流程中，在重新生成代码后，我们应该在DSL的UI项目中找到一个空类<em>MyDslQuickfixProvider</em> ，并在<em>plugin.xml_gen</em>文件中找到新条目。</p>

<p>继续来自域模型示例的<code>INVALID_TYPE_NAME</code>问题，我们添加了一个可以解决问题的方法（有关详细信息，请查看<em>DomainmodelQuickfixProvider</em> ）：</p>

<pre><code class="language-java">@Fix（DomainmodelJavaValidator。INVALID_TYPE_NAME）public void fixName（final Issue issue，IssueResolutionAcceptor acceptor）{acceptor.accept（issue，“Capitalize name”，// quick fix label“Capitalize name of'”+ issue.getData（）[0] +“'”， // description“upcase.png”，//快速修复图标new IModification（）{public void apply（IModificationContext context）throws BadLocationException {IXtextDocument xtextDocument = context.getXtextDocument（）; String firstLetter = xtextDocument.get（issue.getOffset（） ，1）; xtextDocument.replace（issue.getOffset（），1，Strings.toFirstUpper（firstLetter））;}}）; }</code></pre>

<p>通过使用正确的签名（见下文）并使用@ <a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/quickfix/Fix.java">Fix</a>注释引用该方法来引用验证器中先前指定的问题代码，Xtext知道此方法实现了对问题的修复。这也允许我们注释多个方法作为同一问题的修复。</p>

<p><a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/quickfix/IssueResolutionAcceptor.java">IssueResolutionAcceptor</a>的前三个参数定义了快速修复的UI表示。由于在提供快速修复时未必加载文档，因此我们需要在上面的验证器中创建问题时从UI中提供我们想要引用的模型中的任何其他数据。在这种情况下，我们提供了现有的类型名称。附加数据以<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/Issue.java">Issue.getData（）的形式提供</a> 。由于它保留在标记中，因此只允许使用字符串。</p>

<p>实际模型修改在<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModification.java">IModification中</a>实现。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModificationContext.java">IModificationContext</a>提供对错误文档的访问。在这种情况下，我们使用Eclipse的<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocument.html">IDocument</a> API来替换文本区域。</p>

<p>如果您希望在语义模型方面实现快速修复，请使用<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/ISemanticModification.java">ISemanticModification</a> 。它的<code>apply(EObject, IModificationContext)</code>方法将在modify-transaction中调用，第一个参数将是错误的语义元素。这使得fix方法很容易根据需要修改模型。方法返回后，模型以及Xtext编辑器的内容将相应更新。如果方法失败（抛出异常），则不会提交更改。以下代码段显示了针对类似问题的语义快速修复。</p>

<pre><code class="language-java">@Fix（DomainmodelJavaValidator。INVALID_FEATURE_NAME）public void fixFeatureName（final Issue issue，IssueResolutionAcceptor acceptor）{acceptor.accept（issue，“Uncapitalize name”，// label“Uncapitalize name of”“+ issue.getData（）[0] +”'“，// description“upcase.png”，// icon new ISemanticModification（）{public void apply（EObject element，IModificationContext context）{（（Feature）element）.setName（Strings.toFirstLower（issue.getData（）[0]））; }}; }</code></pre>

<p><code>@Fix</code>注释是可重复的，因此如果方法为多个问题代码提供<code>@Fix</code>则可以多次指定它。</p>

<pre><code class="language-java">@Fix（DomainmodelJavaValidator。INVALID_TYPE_NAME）@Fix（DomainmodelJavaValidator。OTHER_ISSUE）public void fixName（最终问题，IssueResolutionAcceptor acceptor）{...}</code></pre>

<p>或者，您可以将其包装在<code>@Fixes</code>容器中。</p>

<pre><code class="language-java">@Fixes（@Fix（DomainmodelJavaValidator。INVALID_TYPE_NAME），@修复（DomainmodelJavaValidator。OTHER_ISSUE））public void fixName（final Issue issue，IssueResolutionAcceptor acceptor）{...}</code></pre>

<h3 id="quick-fixes-for-linking-errors-and-syntax-errors">快速修复链接错误和语法错误</h3>

<p>您甚至可以定义快速修复链接错误。问题代码由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/ILinkingDiagnosticMessageProvider.java">ILinkingDiagnosticMessageProvider</a>分配。看看域模型示例如何为这些错误添加快速修复。</p>

<p>因此，有<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java">ISyntaxErrorMessageProvider</a>将问题代码分配给语法错误。</p>

<h2 id="templates">模板建议</h2>

<p>基于Xtext的编辑器自动支持代码模板。这意味着您将获得相应的首选项页面，用户可以在其中添加和更改模板提议。如果要发送几个默认模板，则必须将名为<em>templates.xml</em>的文件放在生成的UI插件的<em>templates</em>目录中。此文件包含<a href="http://help.eclipse.org/luna/topic/org.eclipse.cdt.doc.user/tasks/cdt_t_imp_code_temp.htm">Eclipse联机帮助</a>中所述格式的模板。</p>

<p><img src="images/preferences_templates.png" alt=""></p>

<p>默认情况下，Xtext会注册遵循某些模式的<em>上下文类型</em> 。将创建上下文类型</p>

<ol>
  <li>对于每个规则（ <code>{languageName}.{RuleName}</code> ）和</li>
  <li>对于每个关键字（ <code>{languageName}.kw_{keyword}</code> ）。</li>
</ol>

<p>如果你不喜欢这些默认值，你必须<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/XtextTemplateContextTypeRegistry.java">继承XtextTemplateContextTypeRegistry</a>并通过<a href="302_configuration.html#guicemodules">Guice</a>配置它。</p>

<p>除了标准模板提议扩展机制之外，Xtext还附带一组预定义的<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/templates/TemplateVariableResolver.html">TemplateVariableResolvers</a>来解析<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/templates/TemplateVariableResolver.html">模板</a>中的特殊变量类型。除了<code>${user}</code> ， <code>${date}</code> ， <code>${time}</code> ， <code>${cursor}</code>等<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/templates/GlobalTemplateVariables.html">GlobalTemplateVariables中</a>提供的标准模板变量外，这些<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/templates/TemplateVariableResolver.html">TemplateVariableResolvers还</a>支持交叉引用枚举值的自动解析。两个解析器将在以下部分中解释。</p>

<p>最佳做法是在首选项页面中编辑模板，将它们导出到<em>templates.xml</em> -file中，然后将其放入UI-plug-in的<em>templates</em>文件夹中。但是，默认情况下，这些模板不可见。要修复它，您必须手动编辑xml文件并为每个模板元素插入一个<code>id</code>属性。请注意，属性名称区分大小写。与eclipse插件开发一样，如果之前不存在文件夹<em>模板</em> ，则必须将其添加到<em>build.properties中</em>的<em>bin.includes</em> 。</p>

<h3 id="cross-reference-template-variable-resolver">交叉参考模板可变解析器</h3>

<p>Xtext附带一个名为<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/CrossReferenceTemplateVariableResolver.java">CrossReferenceTemplateVariableResolver</a>的特定模板变量解析器，可用于预先填充占位符以便在模板中进行交叉引用。相应的模板变量称为<em>CrossReference</em> ，其语法如下：</p>

<p><code>$ {&lt;displayText&gt;：交叉引用（[。&lt;MyPackageName&gt;] &lt;的MyType&gt; &lt;myRef&gt;）}</code></p>

<p>其中“displayText”是编辑器中显示的初始值。它也是占位符的标识符，以便用户使用链接编辑一次更新具有相同名称的多个占位符。</p>

<p>这个小例子产生了text <em>event =&gt; state，</em>并允许使用下拉列表选择任何事件和状态：</p>

<pre><code class="language-xml">&lt;template name =“transition”description =“event transition”id =“transition”context =“org.xtext.example。SecretCompartments。转换“enabled =”true“&gt; $ {event：CrossReference（'Transition.event'）} =&gt; $ {state：CrossReference（'Transition.state'）} &lt;/ template&gt;</code></pre>

<p><img src="images/templates_crossref.png" alt=""></p>

<h3 id="enumeration-template-variable-resolver">枚举模板变量解析器</h3>

<p><a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/EnumTemplateVariableResolver.java">EnumTemplateVariableResolver</a>将模板变量解析为<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EEnumLiteral.java">EEnumLiterals</a> ，它与枚举类型赋值兼容，枚举类型声明为<em>Enum</em>模板变量的第一个参数。</p>

<p>语法如下：</p>

<p><code>$ {&lt;displayText&gt;：枚举（[。&lt;MyPackage的&gt;] &lt;EnumType&gt;）}</code></p>

<p>例如，以下模板（取自另一个示例）：</p>

<pre><code class="language-domainexample">&lt;template name =“Entity”description =“Entity的模板”id =“entity”context =“org.eclipse.xtext.example。的DomainModel。实体“enabled =”true“&gt; $ {public：Enum（'Visibility'）} entity $ {Name} {$ {cursor}} &lt;/ template&gt;</code></pre>

<p>产生文本<code>public entity Name {}</code> ，其中text <code>public</code>是<code>Visibility</code>的默认值。编辑器提供一个下拉列表，其中填充了<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EEnum.java">EEnum中</a>定义的其他文字值。</p>

<h2 id="outline">大纲视图</h2>

<p>Xtext提供大纲视图以帮助您导航模型。默认情况下，它为模型提供分层视图，并允许您按字母顺序对树元素进行排序。选择轮廓中的元素将突出显示文本编辑器中的相应元素。用户可以通过单击“ <em>使用编辑器链接”</em>按钮选择将轮廓与编辑器选择同步。</p>

<p><img src="images/sample_outline.png" alt=""></p>

<p>在其默认实现中，大纲视图显示模型的包含层次结构。在大多数情况下，这应该足够了。如果要调整轮廓的结构，即省略某种节点或引入其他节点，可以通过实现自己的<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/IOutlineTreeProvider.java">IOutlineTreeProvider</a>来自定义轮廓。</p>

<p>如果您的工作流定义了<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/ui/outline/OutlineTreeProviderFragment2.xtend">OutlineTreeProviderFragment2</a> ，则Xtext会为您自己的<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/IOutlineTreeProvider.java">IOutlineTreeProvider</a>生成存根，该存根允许您通过继承<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/DefaultOutlineTreeProvider.java">DefaultOutlineTreeProvider</a>的强大自定义方法来自定义大纲的每个方面。以下部分显示如何使用生命填充此存根。</p>

<h3 id="influencing-the-outline-structure">影响轮廓结构</h3>

<p>大纲树中的每个节点都是<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/IOutlineNode.java">IOutlineNode的</a>一个实例。大纲树始终以<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/DocumentRootNode.java">DocumentRootNode</a>为根。将自动为您创建此节点。它的子节点是显示视图中的根节点。</p>

<p><a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/EObjectNode.java">EObjectNode</a>表示模型元素。默认情况下，Xtext为其容器的节点中的每个模型元素创建一个<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/EObjectNode.java">EObjectNode</a> 。节点是通过调用<code>createNode(parentNode, modelElement)</code>方法创建的，如果没有区别指定<code>createNode(parentNode, modelElement)</code>该方法将委托给<code>createEObjectNode(..)</code> 。</p>

<p>要更改特定节点的子节点，您必须实现该方法</p>

<pre><code class="language-java">_createChildren（parentNode，parentModelElement）</code></pre>

<p>适当的类型。以下代码段显示了如何在域模型示例的大纲中跳过<code>Domainmodel</code>类型的根模型元素：</p>

<pre><code class="language-java">protected void _createChildren（DocumentRootNode parentNode，Domainmodel domainModel）{for（AbstractElement element：domainModel.getElements（））{createNode（parentNode，element）; }}</code></pre>

<p>您可以选择不在<code>_createChildren()</code>方法中创建任何节点。由于大纲节点是按需计算的，因此UI将显示一个可展开的节点，即使它已展开，也不会显示任何子节点。这可能会让您的用户感到困惑。要克服这个缺点，您必须使用适当的参数类型实现方法<code>_isLeaf(modelElement)</code> ，例如</p>

<pre><code class="language-java">//特征节点是叶子而不是可扩展的受保护的布尔_isLeaf（特征）{返回true; }</code></pre>

<p>Xtext提供第三种类型的节点： <a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/EStructuralFeatureNode.java">EStructuralFeatureNode</a> 。它用于表示模型元素的特征而不是元素本身。Xtend2的以下简化代码段说明了如何使用它：</p>

<pre><code class="language-java">protected void _createChildren（DocumentRootNode parentNode，XtendFile xtendFile）{//显示属性XtendFile.package的节点createEStructuralFeatureNode（parentNode，xtendFile，Xtend2Package。文字。XTEND_FILE__PACKAGE，getImageForPackage（），xtendFile.getPackage（），true）; //显示列表引用的容器节点XtendFile.imports //导入将显示为单个子节点自动createEStructuralFeatureNode（parentNode，xtendFile，Xtend2Package。文字。XTEND_FILE__IMPORTS，getImageForImportContainer（），“import declarations”，false）; createEObjectNode（parentNode，xtendFile.getXtendClass（））; }</code></pre>

<p>当然，您可以添加更多自定义类型的节点。为保持一致性，请确保从<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/AbstractOutlineNode.java">AbstractOutlineNode</a>继承。要实例化这些，必须使用适当的参数类型实现<code>_createNode(parentNode, semanticElement)</code> 。</p>

<h3 id="styling-the-outline">造型大纲</h3>

<p>您还可以自定义大纲节点的图标和文本。默认情况下，Xtext使用您的语言的<a href="#label-provider">标签提供程序</a> 。如果你想在标签具体到轮廓，可以覆盖的方法<code>_text(modelElement)</code>和<code>_image(modelElement)</code>在<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/DefaultOutlineTreeProvider.java">DefaultOutlineTreeProvider</a> 。</p>

<p>请注意，方法<code>_text(modelElement)</code>可以返回<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a>或<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledString.html">StyledString</a> 。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/StylerFactory.java">StylerFactory</a>可用于创建<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledString.html">StyledStrings</a> ，如下例所示：</p>

<pre><code class="language-java">@Inject私有StylerFactory stylerFactory; public Object _text（Entity entity）{if（entity.isAbstract（））{return new StyledString（entity.getName（），stylerFactory .createXtextStyleAdapterStyler（getTypeTextStyle（））））; else返回entity.getName（）; protected TextStyle getTypeTextStyle（）{TextStyle textStyle = new TextStyle（）; textStyle.setColor（new RGB（149,125,71））; textStyle.setStyle（SWT.ITALIC）; return textStyle; }</code></pre>

<p>要访问图像，我们建议使用<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/PluginImageHelper.java">PluginImageHelper</a> 。</p>

<h3 id="filtering-actions">过滤操作</h3>

<p>通常，您希望允许用户过滤大纲的内容，以便更容易专注于模型的相关方面。要为大纲添加过滤功能，您需要在大纲中添加过滤器操作。筛选器操作必须扩展<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/AbstractFilterOutlineContribution.java">AbstractFilterOutlineContribution</a>以确保正确处理操作切换状态。以下是我们的域模型示例中的示例：</p>

<pre><code class="language-java">public class FilterOperationsContribution extends AbstractFilterOutlineContribution {public static final String PREFERENCE_KEY =“ui.outline.filterOperations”; @Inject private PluginImageHelper imageHelper; @Override protected boolean apply（IOutlineNode node）{return！（节点实例EObjectNode）|| ！（（EObjectNode）node）.getEClass（）。equals（DomainmodelPackage。文字。操作）; } @Override public String getPreferenceKey（）{return PREFERENCE_KEY; } @Override protected void configureAction（Action action）{action.setText（“Hide operations”）; action.setDescription（“隐藏操作”）; action.setToolTipText（“隐藏操作”）; action.setImageDescriptor（getImageDescriptor（ “Operation.gif”））; protected ImageDescriptor getImageDescriptor（String imagePath）{return ImageDescriptor.createFromImage（imageHelper.getImage（imagePath））; }}</code></pre>

<p>贡献必须像这样绑定在<em>MyDslUiModule中</em></p>

<pre><code class="language-java">public void configureFilterOperationsContribution（Binder binder）{binder .bind（IOutlineContribution.class）.annotatedWith（Names.named（“FilterOperationsContribution”））。to（FilterOperationsContribution.class）; }</code></pre>

<h3 id="sorting-actions">排序操作</h3>

<p>Xtext已经为您的大纲添加了一个排序操作。默认情况下，节点按其文本排序。您可以通过绑定自己的<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/impl/OutlineFilterAndSorter.java">IComparator</a>来更改此行为。</p>

<p>一个非常常见的用例是首先按类别对子项进行分组，例如在包声明中显示类型之前的导入，并分别对类别进行排序。这就是为什么<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/SortOutlineContribution.java">DefaultComparator</a>有一个方法<code>getCategory(IOutlineNode)</code>允许指定这样的类别。该示例显示了如何使用此类别：</p>

<pre><code class="language-java">公共类MydslOutlineNodeComparator扩展DefaultComparator {@Override public int getCategory（IOutlineNode node）{if（node instanceof EObjectNode）switch（（EObjectNode）node）.getEClass（）。getClassifierID（）））{case MydslPackage。TYPE0：返回-10;案例MydslPackage。TYPE1：返回-20; }返回整数。MIN_VALUE; }}</code></pre>

<p>与往常一样，您必须在<em>MyDslUiModule中</em>为自定义实现声明绑定：</p>

<pre><code class="language-java">@Override public Class &lt;？扩展IComparator&gt; bindOutlineFilterAndSorter $ IComparator（）{return MydslOutlineNodeComparator.class; }</code></pre>

<h3 id="quick-outline">快速大纲</h3>

<p>Xtext还提供了一个快速概述：如果在Xtext编辑器中按CTRL-O，模型的轮廓将显示在弹出窗口中。快速大纲还支持使用通配符进行深入搜索。要启用快速大纲，您必须将<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/ui/outline/QuickOutlineFragment2.xtend">QuickOutlineFragment2</a>放入工作流程中。</p>

<h2 id="hyperlinking">超链接</h2>

<p>Xtext编辑器为与语法定义中的交叉引用相对应的任何标记提供超链接支持。您可以<em>按住CTRL键单击</em>这些标记中的任何一个，或者在光标位置位于相关标记处时点击<em>F3</em> ，这将带您进入引用的模型元素。正如您所期望的那样，它适用于对同一资源中的元素的引用以及对其他资源中元素的引用。在后一种情况下，首先使用相应的编辑器打开引用的资源。</p>

<h3 id="location-provider">位置提供者</h3>

<p>在导航超链接时，Xtext还将选择与引用的模型元素对应的文本区域。确定此文本区域是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/ILocationInFileProvider.java">ILocationInFileProvider</a>的责任。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/DefaultLocationInFileProvider.java">默认实现</a>实现尽力而为策略，可以概括为：</p>

<ol>
  <li>如果model元素的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java">类型</a>声明了一个特征<em>名称，</em>则返回相应标记的区域。作为后备还检查功能<em>ID</em> 。</li>
  <li>如果模型元素的节点模型包含与语法中规则<em>ID的</em>调用相对应的任何顶级标记，则返回跨越所有这些标记的区域。</li>
  <li>作为最后的手段，返回与引用的模型元素的第一个关键字标记相对应的区域。</li>
</ol>

<p>位置服务提供了不同的方法来获取特殊用例的感兴趣区域。您可以获取对象的完整区域，也可以只获取通常是实例名称的标识字符串（请参阅<code>getSignificantTextRegion(EObject)</code> ）。您还可以通过<code>getFullTextRegion(EObject, EStructuralFeature, int)</code>查询特定<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EStructuralFeature.java">EStructuralFeature</a>的文本区域。</p>

<p>由于默认策略是尽力而为，因此可能并不总是会产生您想要的选择。如果是这种情况，您可以在UI模块中<a href="302_configuration.html#guicemodules">覆盖</a> <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/ILocationInFileProvider.java">ILocationInFileProvider</a>绑定，如以下示例所示：</p>

<pre><code class="language-java">公共类MyDslUiModule扩展AbstractMyDslUiModule {@Override public Class &lt;？扩展ILocationInFileProvider&gt; bindILocationInFileProvider（）{return MyDslLocationInFileProvider.class; }}</code></pre>

<p>通常，默认策略仅需要一些指导（例如，选择与<em>名称</em>相对应的另一个特征的文本）。在这种情况下，您可以简单地<code>useKeyword()</code> <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/DefaultLocationInFileProvider.java">DefaultLocationInFileProvider</a>并覆盖方法<code>getIdentifierFeature()</code>或<code>useKeyword()</code>来指导策略的第一步和最后一步，如上所述（有关<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/xtext/XtextLocationInFileProvider.java">示例</a> ，请参阅<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/xtext/XtextLocationInFileProvider.java">XtextLocationInFileProvider</a> ）。</p>

<h3 id="customizing-available-hyperlinks">自定义可用的超链接</h3>

<p>超链接由<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/hyperlinking/HyperlinkHelper.java">HyperlinkHelper</a>提供，默认情况下将为交叉引用的对象创建链接。客户端可能希望覆盖<code>createHyperlinksByOffset(XtextResource, int, IHyperlinkAcceptor)</code>以提供其他链接或取代默认实现。</p>

<h2 id="highlighting">语法着色</h2>

<p>除了已经提到的<a href="#content-assist">内容辅助</a>和<a href="303_runtime_concepts.html#formatting">代码格式化</a>等高级功能外，DSL的强大编辑器还能够标记您的模型代码，以提高整体可读性。根据输入文件不同部分的含义，可以使用不同的颜色和字体。人们可能希望对大块注释使用一些不引人注意的颜色，而标识符，关键字和字符串应该以不同的颜色着色，以便更容易区分它们。这种文本装饰标记不会影响各个部分的语义，但有助于理解其含义并在源代码中查找错误。</p>

<p><img src="images/highlighting.png" alt=""></p>

<p>突出显示分两个阶段完成。这允许以异步方式执行的复杂算法以提供高级着色，而可以使用简单的模式匹配来即时突出显示文本的部分。后者称为词汇突出显示，而第一个则基于不同模型元素的含义，因此称为语义突出显示。</p>

<p>引入新的突出显示样式时，会自动配置DSL的首选项页面，并允许自定义任何已注册的突出显示设置。它们会在启动时自动保留并重新加载。</p>

<p><img src="images/preferences_syntax.png" alt=""></p>

<h3 id="lexical-highlighting">词汇突出显示</h3>

<p>可以通过提供<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java">IHighlightingConfiguration</a>接口和抽象类<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/AbstractTokenScanner.java">AbstractTokenScanner的</a>实现来定制词法突出显示。后者通过底层JFace框架实现了<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/rules/ITokenScanner.html">ITokenScanner</a>接口，可以由客户直接实现。</p>

<p><a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java">IHighlightingConfiguration</a>用于注册任何默认样式，而不对模型文件中的模式进行特定绑定。它用于填充首选项页面并初始化<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/ITextAttributeProvider.java">ITextAttributeProvider</a> ，后者又是用于获取样式id的实际设置的组件。实现通常与<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/DefaultHighlightingConfiguration.java">DefaultHighlightingConfiguration</a>非常相似，并且如下所示：</p>

<pre><code class="language-java">公共类DefaultHighlightingConfiguration实现IHighlightingConfiguration {public static final String KEYWORD_ID =“keyword”; public static final String COMMENT_ID =“comment”; public void configure（IHighlightingConfigurationAcceptor acceptor）{acceptor.acceptDefaultHighlighting（KEYWORD_ID，“Keyword”，keywordTextStyle（））; acceptor.acceptDefaultHighlighting（COMMENT_ID，“评论”，// ...public TextStyle keywordTextStyle（）{TextStyle textStyle = new TextStyle（）; textStyle.setColor（new RGB（127,0,85））; textStyle.setStyle（SWT.BOLD）; return textStyle; }}</code></pre>

<p><a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/rules/ITokenScanner.html">ITokenScanner的</a>实现负责将文档的内容分成各个部分，即所谓的标记，并返回每个标识范围的突出显示信息。至关重要的是，这一过程非常快，因为每个按键都会使用此组件。Xtext附带了一个默认实现，该实现基于ANTLR生成的词法分析器，它非常轻量且快速。客户可以轻松地自定义此默认实现。它们只需要绑定<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/AbstractAntlrTokenToAttributeIdMapper.java">AbstractAntlrTokenToAttributeIdMapper的</a>另一个实现。要了解它，请查看<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/DefaultAntlrTokenToAttributeIdMapper.java">DefaultAntlrTokenToAttributeIdMapper</a> 。</p>

<h3 id="semantic-highlighting">语义突出显示</h3>

<p>语义突出显示阶段在后台异步执行，并可用于根据不同模型元素的含义计算突出显示状态。编辑器的用户在编辑文本之后会注意到很短的延迟，直到样式实际应用于文档。这样可以在编写模型时提供帮助，同时保持编辑器的响应性。</p>

<p>至于词汇突出显示注册可用样式的界面是<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java">IHighlightingConfiguration</a> 。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/ISemanticHighlightingCalculator.java">ISemanticHighlightingCalculator</a>是实现逻辑的主要钩子，该逻辑将基于模型元素计算要突出显示的范围。</p>

<p>框架将当前的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a>和<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightedPositionAcceptor.java">IHighlightedPositionAcceptor</a>传递给计算器。确保在被调用方法提供<code>provideHighlightingFor()</code>返回之前不会在外部更改资源。但是，如果模型中存在错误，则资源可能为<code>null</code> 。实现者的任务是导航语义模型并基于附加的节点信息计算各种范围并将样式与它们相关联。这可能类似于以下代码段：</p>

<pre><code class="language-java">public void provideHighlightingFor（XtextResource resource，IHighlightedPositionAcceptor acceptor）{if（resource == null || resource.getParseResult（）== null）return; INode root = resource.getParseResult（）。getRootNode（）; for（INode node：root.getAsTreeIterable（））{if（node.getGrammarElement（）instanceof CrossReference）{acceptor.addPosition（node.getOffset（），node.getLength（），MyHighlightingConfiguration。CROSS_REF）; }}}</code></pre>

<p>此示例引用<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java">IHighlightingConfiguration</a>的实现，该实现为每个交叉引用注册自己的样式。它与前面提到的词法<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java">IHighlightingConfiguration</a>样本几乎相同。</p>

<pre><code class="language-java">公共类HighlightingConfiguration实现了IHighlightingConfiguration {// lexical stuff到这里// ..public final static String CROSS_REF =“CrossReference”; public void configure（IHighlightingConfigurationAcceptor acceptor）{// lexical stuff到这里// ..acceptor.acceptDefaultHighlighting（CROSS_REF，“交叉引用”，crossReferenceTextStyle（））; public TextStyle crossReferenceTextStyle（）{TextStyle textStyle = new TextStyle（）; textStyle.setStyle（SWT.ITALIC）; return textStyle; }}</code></pre>

<p><a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/ISemanticHighlightingCalculator.java">ISemanticHighlightingCalculator</a>的实现者应该了解性能以确保良好的用户体验。当您只注册一些突出显示的范围时，通过某些类型化的方法调用可以更容易地找到模型的所有内容，这可能不是一个好主意。强烈建议使用有目的的方法来导航模型。在这方面，负责语义突出显示的Xtext核心部分也得到了很好的优化。例如，框架将仅更新实际已更改的范围。这加快了重绘过程。在用户更改文档之后触发下一个语义突出显示通道之前，它甚至会根据最佳猜测移动，缩小或放大先前公布的区域。</p>

<h2 id="refactoring">重命名重构</h2>

<p>Xtext提供了对您语言中元素的重命名重构。那包括</p>

<ul>
  <li>声明和引用上的命令，处理程序和键绑定，</li>
  <li>新名称的就地链接编辑，</li>
  <li>验证和预览，</li>
  <li>即使跨越语言边界，也要重命名声明和所有引用。</li>
</ul>

<p>要启用重构支持，请确保在您的语言的MWE工作流的片段部分中启用了<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/ui/refactoring/RefactorElementNameFragment2.xtend">RefactorElementNameFragment2</a> ，例如</p>

<pre><code class="language-mwe2">//重命名重构片段=重构。RefactorElementNameFragment {}</code></pre>

<p>该片段有一个额外的标志<code>useJdtRefactoring</code> ，可用于委托JDT的重构基础结构，用于使用<a href="305_xbase.html">Xbase</a>和<a href="305_xbase.html#xbase-inferred-type">推断的JVM模型</a> （即域模型示例或Xtend）的语言。</p>

<p>如果您坚持使用关于命名，交叉引用和索引的默认值，则重命名重构不应该需要任何自定义。试试看。</p>

<h3 id="customizing">定制</h3>

<p>您想要自定义的最可能的组件是<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/IRenameStrategy.java">IRenameStrategy</a> 。该组件定义了如何执行目标元素的声明。它有两个主要职责：</p>

<ul>
  <li>应用并恢复语义模型上的声明更改（方法<code>applyDeclarationChange</code>和<code>revertDeclarationChange</code> ）。默认设置是在目标对象上查找<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java">EAttribute</a> <code>name</code> ，并使用EMFs反射API设置其值。</li>
  <li>创建声明更改的LTK <a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/Change.html">Change</a>对象。这些更改将被聚合，检查重叠，在预览中呈现给您，并在您应用重构时最终执行。默认设置是使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/ILocationInFileProvider.java">ILocationInFileProvider</a>来查找表示名称的文本范围，并为其创建<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/text/edits/ReplaceEdit.html">ReplaceEdit</a> 。</li>
</ul>

<p>由于<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/IRenameStrategy.java">IRenameStrategy</a>是有状态对象，因此必须绑定自定义<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/IRenameStrategy.java">Provider</a>才能创建它。</p>

<p>您可能想要自定义的第二个组件是<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/IDependentElementsCalculator.java">IDependentElementsCalculator</a> 。从属元素是重命名目标元素时名称更改的元素。例如，当您重命名Java类时，其内部类的限定名称也会更改，因此也必须更新对这些类的引用。该计算由<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/IDependentElementsCalculator.java">IDependentElementsCalculator</a>执行。默认情况下，会添加目标元素中包含的所有元素。这与Xtext的限定名称计算的默认策略相匹配。</p>

<h3 id="rename-participants">重命名参与者</h3>

<p>一次重构可以触发另一种重构：在Xtext语法中重命名规则时，也应该重命名返回的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java">EClass</a> 。对于这些情况，您可以通过LTK的常用方法注册<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ltk/core/refactoring/participants/RenameParticipant.html">RenameParticipant</a> 。如果参与者的目标是基于Xtext的，则可以使用<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/refactoring/impl/AbstractProcessorBasedRenameParticipant.java">AbstractProcessorBasedRenameParticipant</a> 。</p>

<h2 id="projectwizard">项目向导</h2>

<p>MWE2工作流可以生成一个向导，您的语言的客户可以使用该向导来创建模型项目。这将在<code>.ui</code>项目中生成。如果在<code>plugin.xml</code>必须与<code>plugin.xml_gen</code>手动合并之前生成语言。</p>

<p>必须在<code>language</code>部分的MWE2文件中明确指定，如下所示</p>

<pre><code class="language-mwe2">projectWizard = {generate = true}</code></pre>

<p>默认情况下，生成的向导将创建插件项目。如果需要General项目，则需要将以下属性设置为false：例如， <code>pluginProject=false</code></p>

<pre><code class="language-mwe2">projectWizard = {generate = true pluginProject = false}</code></pre>

<p>在<code>ui</code>项目的<code>src</code>文件夹中，将生成<code>MyDslProjectTemplateProvider</code> Xtend文件，您可以在其中指定用户可以从中选择的模板以生成新项目。</p>

<p>模板定义了两件事。一方面，他们定义了如何向用户呈现模板。用户获取的小部件的名称，描述和布局，以选择模板参数的值。另一方面，定义了模板生成的项目的内容。该向导能够生成任意数量和类型的项目，其中包含任意数量和类型的文件作为内容。</p>

<p>扩展点<code>org.eclipse.xtext.ui.projectTemplate</code>将模板提供给向导。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/IProjectTemplateProvider.java">IProjectTemplateProvider</a>的实现者已注册其提供模板的语言。此接口的方法返回<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/AbstractProjectTemplate.java">AbstractProjectTemplate的</a>实例。每个实例都定义一个模板。</p>

<p>要创建<code>AbstractProjectTemplate</code>的子类，建议使用活动注释<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/ProjectTemplate.xtend">ProjectTemplate</a>注释类。通过此注释，可以定义名称和描述，并使其可用于用户界面。此外， <code>AbstractProjectTemplate</code>的扩展将为您完成。</p>

<p>在项目模板中，需要重写方法<code>generateProjects(IProjectGenerator)</code> 。参数实例提供了一个<code>generate</code>方法，该方法接受<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/util/ProjectFactory.java">ProjectFactory</a>的实例。使用此类或可用的子类，模板可以生成所有类型的项目。以下说明了使用模板生成插件项目的简单示例：</p>

<pre><code class="language-xtend">generator.generate（new PluginProjectFactory =&gt; [projectName = projectInfo.projectName location = projectInfo.locationPath projectNatures + =＃[JavaCore。NATURE_ID，“org.eclipse.pde。PluginNature“，XtextProjectHelper。NATURE_ID] builderIds + = JavaCore。BUILDER_ID文件夹+ =“src”addFile（'''src / Model.mydsl'''，'''Hello World！'''）]）</code></pre>

<p><code>AbstractProjectTemplate</code>提供了创建复选框，文本字段和组合框的方法。这些将在向导中提供给用户以配置所选模板。然后，可以使用用户插入的值来配置模板。在以下示例中，复选框用于控制是否生成文件。</p>

<pre><code class="language-xtend">@ProjectTemplate（label =“Test”，icon =“project_template.png”，description =“&lt;p&gt; &lt;b&gt;测试&lt;/ b&gt; &lt;/ p&gt; &lt;p&gt;这是一个测试项目。&lt;/ p&gt;”） final类TestProject {val generateHello = check（“Generate Hello”，true）覆盖generateProjects（IProjectGenerator生成器）{if（generateHello.value）{generator.generate（new PluginProjectFactory =&gt; [projectName = projectInfo.projectName location = projectInfo.locationPath projectNatures + =＃[JavaCore。NATURE_ID，“org.eclipse.pde。PluginNature“，XtextProjectHelper。NATURE_ID] builderIds + = JavaCore。BUILDER_ID文件夹+ =“src”addFile（'''src / Model.mydsl'''，'''Hello World！'''）））}}}</code></pre>

<p>对于更复杂的模板，还可以将参数组合在一起，启用/禁用参数，响应不同参数的更改而更改参数值，并在所选参数正确时向向导添加验证。这可以通过实现提供的方法<code>updateVariables</code>和<code>validate</code>来完成。</p>

<h2 id="file-wizard">文件向导</h2>

<p>与<a href="#projectwizard">Project Wizard</a>类似，可以使用MWE2工作流生成文件generaten的向导。该向导将在<code>.ui</code>项目中生成。如果在<code>plugin.xml</code>必须与<code>plugin.xml_gen</code>手动合并之前生成语言。</p>

<p>必须在<code>language</code>部分的MWE2文件中明确指定，如下所示</p>

<pre><code class="language-mwe2">fileWizard = {generate = true}</code></pre>

<p>文件向导的API与项目向导的API非常相似。使用相同的小部件/参数定义模板，但不生成整个项目，而是生成一个或多个文件。要添加新的模板提供程序，可以使用扩展点<code>org.eclipse.xtext.ui.projectTemplate</code>来注册<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/IFileTemplateProvider.java">IFileTemplateProvider</a> 。要创建<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/AbstractFileTemplate.xtend">AbstractFileTemplate的</a>实例，应使用活动注释<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/wizard/template/FileTemplate.xtend">FileTemplate</a> 。</p>

<p>一个简单的示例模板可能如下所示：</p>

<pre><code>@FileTemplate（label =“Hello World”，icon =“file_template.png”，description =“为MyDsl创建一个hello world。”）final class HelloWorldFile {val helloName = combo（“Hello Name：”，＃[“Xtext” ，“World”，“Foo”，“Bar”]，“名称'Hello'to”）覆盖generateFiles（IFileGenerator generator）{generator.generate（'''«folder»/«name».mydsl'' '，'''你好«helloName»！'''）}}</code></pre>

<h2 id="code-mining">代码挖掘</h2>

<p>代码挖掘在文本编辑器中显示内联注释，这些注释不是文本本身的一部分，而是从其内容派生而来。利用代码挖掘来显示推断类型，文字的参数名称和其他类型的元信息可能非常有用。</p>

<p>代码挖掘有两种形式：“标题注释”打印在挖掘文本上方的单独行中，“内联注释”以串联方式显示。以下屏幕截图显示了两种风格：</p>

<p><img src="images/code_mining.png" alt=""></p>

<p>要启用代码挖掘，请使用<code>org.eclipse.xtext.xtext.generator.ui.codemining.CodeMiningFragment</code>必须集成在MWE2文件的<code>language</code>部分中，如下所示：</p>

<pre><code class="language-mwe2">fragment = org.eclipse.xtext.xtext.generator.ui.codemining。CodeMiningFragment {}</code></pre>

<p>执行生成器后，将在UI插件的<code>.codemining</code>子包中创建存根类<code>&lt;LanguageName&gt;CodeMiningProvider</code> 。此外，提供程序已注册到<code>plugin.xml</code>的<code>org.eclipse.ui.workbench.texteditor.codeMiningProviders</code>扩展点。</p>

<p>以下类<code>MyDslCodeMiningProvider</code>显示了一个简单示例：</p>

<pre><code class="language-java">公共类MyDslCodeMiningProvider扩展AbstractXtextCodeMiningProvider {@Override protected void createCodeMinings（IDocument文档，XtextResource资源，CancelIndicator指示符，IAcceptor &lt;ICodeMining&gt; acceptor）抛出BadLocationException {acceptor.accept（createNewLineHeaderCodeMining（1，document，“header annotation”））; acceptor.accept（createNewLineContentCodeMining（5，“inline annotation”））; }}</code></pre>

<p>客户端必须实现<code>createCodeMinings()</code>方法，计算应在文本编辑器中显示的元信息的文本和位置。最后，使用该信息创建<code>ICodeMining</code>实例并将其传递给<code>acceptor</code> 。</p>

<p>基类<code>AbstractXtextCodeMiningProvider</code>提供了一些工厂方法，以便于创建<code>ICodeMining</code>实例。为此目的使用<code>createNewLineHeaderCodeMining()</code>和<code>createNewLineContentCodeMining()</code> 。</p>

<p>有关实现参考，请查看Domainmodel示例。</p>

<hr>

<p><strong><a href="330_web_support.html">下一章：Web编辑器支持</a></strong></p>


</body>
</html>