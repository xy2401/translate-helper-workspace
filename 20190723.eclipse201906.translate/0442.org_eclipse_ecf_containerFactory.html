<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" gtc:encodedoriginal="PCFET0NUWVBFIEhUTUwgUFVCTElDICItLy9XM0MvL0RURCBIVE1MIDQuMCBUcmFuc2l0aW9uYWwvL0VOIj4=">
<html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>ECF集装箱工厂</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">ECF集装箱工厂</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ecf.containerFactory<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>0.0.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展允许插件将自己注册为ECF容器的“提供者”。一旦通过此扩展点注册，插件就可以提供自己的IContainer实现，以响应ECF容器工厂的客户端请求（ <b>org.eclipse.ecf.core。ContainerFactory</b> ）。
<p>使用此扩展点的插件可以定义任何所需通信协议的新实现，并将该协议公开为<b>IContainer</b>的实例。当客户端请求ECF ContainerFactory创建<b>IContainer</b>实例时，这些请求将被重定向到给定的IContainer实现者。</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.containerFactory">containerFactory</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>&gt;<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.containerFactory">containerFactory</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST containerFactory</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">服务器（true | false）</p><p class="code SchemaDtdAttlist">隐藏（true | false）</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">容器工厂扩展点。可以选择包含“defaultargument”元素列表，这些元素描述要传递给提供者实现的参数</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<b>org.eclipse.ecf.core.provider的类的完全限定名<b>。IContainerInstantiator</b>接口。</li>
<li><b>name</b> - 扩展<b>名</b>的可选名称。如果扩展名未明确提供名称，则使用containerFactory类名作为名称。请注意，此名称<b>不得</b>与ECF SharedFactory中的任何其他名称冲突，以便在容器工厂中成功注册。因此，应注意选择名称，使其与此工厂实施的其他预先存在的名称不冲突</li>
<li><b>description</b> - 适用于在用户界面中呈现的容器工厂的描述。</li>
<li><b>server</b> - 用于指示工厂是否用于创建服务器的标志。默认值为false。</li>
<li><b>hidden</b> - 用于指定容器工厂是否应隐藏在用户界面中的标志。默认值为false。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>这是一个扩展，它将类org.eclipse.ecf.test.FooContainerFactory与名称'foo'关联在ECF <b>ContainerFactory中</b> ：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ecf.containerFactory”</span> <span class="code SchemaTag">&gt; &lt;containerFactory name =</span> <span class="code SchemaCstring">“foo”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.ecf.test.FooInstantiator”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“我的容器工厂”</span> <span class="code SchemaTag">/&gt; &lt;/ extension&gt;</span></pre>以下是实现此类的一些示例代码：<pre class="Example"><span class="code SchemaTag">包org.eclipse.ecf.test; import org.eclipse.ecf.core。的IContainer; import org.eclipse.ecf.core。ContainerInstantiationException; import org.eclipse.ecf.core.provider。IContainerInstantiator;公共类FooInstantiator实现IContainerInstantiator {public FooInstantiator（）{super（）; public IContainer createInstance（ContainerTypeDescription description，Class [] argTypes，Object [] args）throws ContainerInstantiationException {//创建/返回FooContainer的实例//注意FooContainer类必须//实现IContainer返回新的FooContainer（）; }}</span></pre>在此示例中，给定类通过创建并返回FooInstantiator的新实例来实现<b>IContainerInstantiator</b> .createInstance方法，FooInstantiator也是在扩展插件中定义的类。如代码中所述，此类必须实现<b>IContainer</b> ，以便可以从createInstance成功返回它。

<h3>客户端使用容器的示例</h3>希望使用'foo'容器实现的客户端只需通过以下调用来创建<b>IContainer即可</b> ：<pre class="Example"><span class="code SchemaTag">IContainer newContainer = ContainerFactory.getDefault（）。createContainer（'foo'）; //在这里进一步使用newContainer实例</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>此扩展点的API由<b>org.eclipse.ecf.core提供<b>。ContainerFactory.getDefault（）</b>方法。具体来说，客户端将使用'createContainer'方法。扩展点机制提供的功能可以在运行时通过<b>ContainerFactory.getDefault（）。addDescription（ContainerTypeDescription）</b>方法使用。这是IContainerFactory接口契约：<pre class="Example"><span class="code SchemaTag">/ ** *容器工厂合同{@link ContainerFactory}用于默认*实现。* / public interface IContainerFactory {/ ** *将ContainerTypeDescription添加到已知ContainerDescriptions集合中。* * @param description *要添加到此工厂的ContainerTypeDescription。不能为*。* @return ContainerTypeDescription同名的旧描述，* null如果没有找到* / public ContainerTypeDescription addDescription（ContainerTypeDescription description）; / ** *获取此*工厂当前已知的ContainerDescriptions的集合。这允许客户端查询工厂以确定当前*工厂是否注册了*任何其他ContainerDescriptions，如果是，那么它们是什么。* * @return ContainerTypeDescription实例列表* / public List / * ContainerTypeDescription * / getDescriptions（）; / ** *检查这个* factory * * @param描述是否已经包含给定的命名描述*如果工厂已知描述，则查找* @return，否则返回true;否则返回false * / public boolean containsDescription（ ContainerTypeDescription description）; / ** *获取已知的ContainerTypeDescription，并给出其名称。* * @param name *用作密钥的名称，用于查找ContainerTypeDescription * @return找到ContainerTypeDescription。如果没有找到空。* / public ContainerTypeDescription getDescriptionByName（String name）; / ** *制作IContainer实例。给定一个ContainerTypeDescription对象，一个参数类型的* String []和一个参数的Object []，这个方法*将* &lt;p&gt; * &lt;ul&gt; * &lt;li&gt;查找已知的ContainerDescriptions以找到一个匹配的名称&lt;/ li&gt; * &lt;li&gt;如果找到，将为该*描述检索或创建IContainerInstantiator &lt;/ li&gt; * &lt;li&gt;调用IContainerInstantiator.createInstance方法返回IContainer的*实例&lt;/ li&gt; * &lt;/ ul&gt; * * @param description *用于创建实例的ContainerTypeDescription * @param参数*传递给IContainerInstantiator的createInstance方法*的参数的Object [] *返回IContainer的有效实例* @throws ContainerCreateException * / public IContainer createContainer （ContainerTypeDescription description，Object []参数）抛出ContainerCreateException; / ** *制作IContainer实例。给定一个ContainerTypeDescription名称，这个*方法将* &lt;p&gt; * &lt;ul&gt; * &lt;li&gt;查找已知的ContainerDescriptions以找到匹配名称之一&lt;/ li&gt; * &lt;li&gt;如果找到，将检索或创建一个IContainerInstantiator * description &lt;/ li&gt; * &lt;li&gt;调用IContainerInstantiator.createInstance方法返回IContainer的*实例&lt;/ li&gt; * &lt;/ ul&gt; * * @param descriptionName *要查找的ContainerTypeDescription名称* @return有效的实例IContainer * @throws ContainerCreateException * / public IContainer createContainer（String descriptionName）抛出ContainerCreateException; / ** *制作IContainer实例。给定一个ContainerTypeDescription名称，此*方法将* &lt;p&gt; * &lt;ul&gt; * &lt;li&gt;查找已知的ContainerDescriptions以查找匹配名称之一&lt;/ li&gt; * &lt;li&gt;如果找到，将检索或创建一个IContainerInstantiator * description &lt;/ li&gt; * &lt;li&gt;调用IContainerInstantiator.createInstance方法返回IContainer的*实例&lt;/ li&gt; * &lt;/ ul&gt; * * @param descriptionName *要查找的ContainerTypeDescription名称* @param参数*对象[]传递给* IContainerInstantiator.createInstance方法的参数* @return一个有效的IContainer实例* @throws ContainerCreateException * / public IContainer createContainer（String descriptionName，Object [] parameters）抛出ContainerCreateException; / ** *从本工厂已知的集合中删除给定的描述。* * @param description *要删除的ContainerTypeDescription * @return删除的ContainerTypeDescription，如果没有删除则为null * / public ContainerTypeDescription removeDescription（ContainerTypeDescription description）; }</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>此扩展点的提供实现是：org.eclipse.ecf.provider.generic。GenericContainerInstantiator<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2004 Composent，Inc。和其他人。版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。贡献者：Composent，Inc。 - 初始API和实施。

</p>
</body>
</html>
