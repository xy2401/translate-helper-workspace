<html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s1.html" rel="prev">&lt;&lt;§1团队和角色</a></td>
               <td class="top"><a href="index.html" rel="contents">目录  </a></td>
               <td class="next"><a href="s3.html" rel="next">§3标注绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s2">
            <div class="headl">
               <div class="headr">
                  <h1>§2角色绑定</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s2.html">§2角色绑定</a></li>
                  <li><a href="#s2.1">§2.1播放了关系</a></li>
                  <li><a href="#s2.2">§2.2降低</a></li>
                  <li><a href="#s2.3">2.3 起吊 6</a></li>
                  <li><a href="#s2.4">§2.4明确的角色创建</a></li>
                  <li><a href="#s2.5">§2.5摘要角色</a></li>
                  <li><a href="#s2.6">§2.6明确的基础参考</a></li>
                  <li><a href="#s2.7">§2.7先进的结构</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>角色和基类</h3>
               <div class="line"></div>
               <div class="term">playBy关系</div>
               <div class="termdesc">可以通过<code>playedBy</code>关系将角色绑定到团队外部的类，该关系声明每个角色实例都与基础实例相关联。
               </div>
               <div class="line"></div>
               <div class="term">基类</div>
               <div class="termdesc">角色绑定到的类（使用<code>playedBy</code> ）称为其<strong>基类</strong> 。角色实例可以从其基本实例继承和覆盖功能，该实例使用<strong>callout</strong> （ <a href="s3.html" title="§3标注绑定" class="sect">§3</a> ）和<strong>callin</strong> （ <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）方法绑定进行声明。
               </div>
               <div class="line"></div>
               <div class="term">约束角色</div>
               <div class="termdesc">声明<code>playedBy</code>关系的每个角色类称为<strong>绑定角色</strong> 。术语绑定角色也可以用于这种类的实例。
               </div>
               <div class="line"></div>
               <div class="term">提升/降低</div>
               <div class="termdesc">角色与其基础之间的翻译称为<strong>提升</strong> （从基础到角色）（第<a href="#s2.3" title="2.3 起吊 6" class="sect">2.3节</a> ）和<strong>降低</strong> （从角色到基础）（第<a href="#s2.2" title="§2.2降低" class="sect">2.2节</a> ）。
               </div>
               <div class="line"></div>
               <div class="term">翻译多态性</div>
               <div class="termdesc">角色和基础之间的一致性由<strong>翻译多态性决定</strong> ， <strong>翻译多态性</strong>是指使用提升或降低实现的可替代性。
               </div>
               <div class="line"></div>
               <div class="term">宣布解除</div>
               <div class="termdesc">通常，提升在角色对象与其基础之间的数据流中隐式发生。团队级方法提供额外的数据流，可以明确声明提升。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s2.1">
               <h2 class="sect">§2.1播放了关系<a class="img" href="s2.1.html" title="PermaLink到§2.1播放了关系"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.1.1" title="§A.1.1ClassDeclaration" class="syntax">→语法§A.1.1</a></div>
               <div class="subsect depth3" id="s2.1.a">
                  <h4 class="subsect">（a）基于<span class="title">角色的约束力</span><a class="img" href="s2.1.a.html" title="PermaLink到（a）角色基础绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色由<code>playedBy</code>关键字绑定到基类。
                     			
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>公共</b> <b>课</b> MyRole <em><b>playBy</b> MyBase</em> {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>...</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s2.1.b">
                  <h4 class="subsect">（b） <span class="title">继承</span><a class="img" href="s2.1.b.html" title="永久链接到（b）继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><code>playedBy</code>关系沿着显式和隐式（ <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）角色继承继承。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.1.c">
                  <h4 class="subsect">（c） <span class="title">协变细化</span><a class="img" href="s2.1.c.html" title="PermaLink（c）协变细化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><em>显</em> <code>playedBy</code>角色（使用<code>extends</code>子类）可以将<code>playedBy</code>关系细化为更具体的基类（这是<a href="#s2.3.3" title="§2.3.3 Smart lifting" class="sect">智能提升</a>的基础<a href="#s2.3.3" title="§2.3.3智能提升" class="sect">（第2.3.3节）</a> ）。<br>如果角色类从其超类及其超级接口继承了几个<code>playedBy</code>关系，则这些关系中必须存在最特定的基类，这与所有其他基类一致。这个最具体的基类是当前角色的基类。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.1.d">
                  <h4 class="subsect">（d） <span class="title">无差异</span><a class="img" href="s2.1.d.html" title="永久链接到（d）无差异"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><em>隐</em> <a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">式子</a>角色（根据<a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）可能只添加一个<code>playedBy</code>关系但从不更改现有关系。<br>但是请注意，隐式继承可能隐含地专门化现有的<code>playedBy</code>关系（这种高级情况在<a href="#s2.7.d" title="§2.7。（d）隐式播放专业化" class="sect">§2.7。（d）中说明</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.1.e">
                  <h4 class="subsect">（e） <span class="title">使用playingBy绑定</span><a class="img" href="s2.1.e.html" title="永久链接到（e）使用playBy绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><code>playedBy</code>关系本身对角色和基础对象的行为没有影响。然而，它是翻译多态性（降低： <a href="#s2.2" title="§2.2降低" class="sect">§2.2</a>和提升： <a href="#s2.3" title="2.3 起吊 6" class="sect">§2.3</a> ）和方法绑定（标注： <a href="s3.html" title="§3标注绑定" class="sect">§3</a>和callin： <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）的前提条件。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.1.f">
                  <h4 class="subsect">（f） <span class="title">对垃圾收集的影响</span><a class="img" href="s2.1.f.html" title="PermaLink（f）对垃圾收集的影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色及其基础对象形成一个概念实体。垃圾收集器将以双向方式链接角色及其基础对象。因此，如果角色的基础仍然可以访问，则不能对其进行垃圾回收，反之亦然。
                     <br>在内部，团队使用弱引用来管理其角色和相应的基础。使用其中一个<code>getAllRoles(..)</code>方法（参见<a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ），结果可能是非确定性的，因为这些内部结构可能包含对下一次垃圾收集器收集的对象的弱引用。我们建议<code>getAllRoles(..)</code>客户在调用<code>getAllRoles(..)</code>之前调用<code>System.gc()</code>以确保确定性结果。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="s2.1.1">
                  <h3 class="sect">§2.1.1绑定接口<a class="img" href="s2.1.1.html" title="PermaLinkto§2.1.1绑定接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.1">↑§2.1</a></span></h3>
                  <p>角色基础绑定可能涉及类和/或接口。定义为团队成员的接口是角色接口，因此可以具有<code>playedBy</code>子句。另外，在<code>playedBy</code>关键字之后提到的类型可以是接口。
                     			
                  </p>
                  <div class="note">
                     <h5>实施限制：</h5>OTDT版本2.0的语言实现在将角色绑定到基接口时强加了一个特定的限制：绑定到基接口的角色可能不包含任何callin绑定（ <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）。
                     			
                  </div>
               </div>
               <div class="sect depth3" id="s2.1.2">
                  <h3 class="sect">§2.1.2法定基础类<a class="img" href="s2.1.2.html" title="PermaLinkto§2.1.2法定基类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.1">↑§2.1</a></span></h3>
                  <p>通常， <code>playedBy</code>之后提到的基类必须在封闭范围内可见（参见<a href="#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">下文（§2.1.2。（c））</a>的异常）。通常，此范围仅由封闭团队的导入定义。对于角色文件（ <a href="s1.2.5.b.html" title="§1.2.5。（b）角色文件" class="sect">§1.2.5。（b）</a> ），还会考虑角色文件中的其他导入。
                     <br><a href="#s2.1.2.d" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a>定义了如何约束导入，以便某些类型只能用作基类型。
                     			
                  </p>
                  <div class="subsect depth4" id="s2.1.2.a">
                     <h4 class="subsect">（a） <span class="title">同一团队没有任何作用</span><a class="img" href="s2.1.2.a.html" title="PermaLink（a）没有同一团队的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>任何角色类的基类都不能是同一团队的角色。
                        			<br>如果该基类以其简单名称给出并使用常规导入解析，则也不允许声明与绑定到此或其他角色的基类绑定同名的角色类。换句话说， <code>playedBy</code>之后提到的基类可能不会被封闭团队的任何角色类<em>遮蔽</em> 。
                        			<br>如下定义的<em>基本导入</em> （第<a href="#s2.1.2.d" title="§2.1.2。（d）基础进口" class="sect">2.1.2节（d）</a> ）通过允许仅将类作为基类导入来放宽此规则。在这种情况下，由于基类和角色的范围是不相交的，因此不会发生阴影。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.1.2.b">
                     <h4 class="subsect">（b） <span class="title">周期</span><a class="img" href="s2.1.2.b.html" title="永久链接到（b）周期"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在<code>playedBy</code>之后提到的基类通常不应该是被定义的角色类的封闭类型（在任何深度）。
                        <br>此规则不鼓励创建循环，其中给定角色<code>R</code>的基本实例包含相同类型<code>R</code>角色。<br>更一般地，这涉及<code>C <sub>1</sub> , C <sub>2</sub> , ..类的任何序列<code>C <sub>1</sub> , C <sub>2</sub> , ..C <sub>n</sub></code>各自<code>C <sub>i+1</sub></code>可以是一个部件或基类的<code>C <sub>i</sub></code>和<code>C <sub>n</sub> = C <sub>1</sub></code> 。
                        <br>这些结构可能难以理解，并且对callout（ <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">§3.1。（a）</a> ）和基本构造函数调用（ <a href="#s2.4.2" title="§2.4.2通过常规构造函数创建角色" class="sect">§2.4.2</a> ）有一定的限制。此外，建议装备一个封闭类所扮演的所有角色，并使用这样的守护谓词（ <a href="s5.4.html" title="§5.4守护谓词" class="sect">§5.4</a> ）：</p>
                     <div class="listing plain"><pre><em>基数</em> <em>时</em> （MyTeam.this == <em>base</em> ）</pre></div>
                     <p>这将避免角色适应封闭类的其他实例，而不是封闭实例。
                        
                     </p>
                     <p>禁止将角色类绑定到其自己的内部类。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.1.2.c">
                     <h4 class="subsect">（c） <span class="title">基类解封</span><a class="img" href="s2.1.2.c.html" title="PermaLink到（c）基类解封装"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果在<code>playedBy</code>之后引用的基类存在但在Java的正常可见性规则下不可见，则可以覆盖此限制。这个概念称为解<strong>封装</strong> ，即与封装相反（另见<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ）。编译器应该发出任何基类解封装的信号。如果编译器支持配置警告，则可以使用这个来让用户选择（a）忽略基类解封装，（b）将其视为警告或甚至（c）将其视为错误。
                        
                     </p>
                     <p>绑定到<code>final</code>基类也被视为解封装，因为<code>playedBy</code>关系具有类似于<code>extends</code>关系的权限，这通过将类标记为<code>final</code>来禁止。
                        
                     </p>
                     <p>如果基类是一个受限制的角色，则不允许解封装（参见<a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ）。
                        
                     </p>
                     <p>在当前角色中，可以在任何方法绑定（ <a href="s3.html" title="§3标注绑定" class="sect">callout（§3）</a>或<a href="s4.html" title="§4Callin绑定" class="sect">callin（§4）</a> ）的右侧提及解封装的基类。这些位置的参数也可以提到解封的基类：</p>
                     <ul>
                        <li>角色的一个构造函数的第一个参数（参见<a href="#s2.4.1" title="§2.4.1通过提升构造函数创建角色" class="sect">提升构造函数（第2.4.1节）</a> ）。
                        </li>
                        <li>声明提升的参数的基础侧（参见<a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">声明的提升（§2.3.2）</a> ）。
                        </li>
                     </ul>
                  </div>
                  <div class="subsect depth4" id="s2.1.2.d">
                     <h4 class="subsect">（d） <span class="title">基础进口</span><a class="img" href="s2.1.2.d.html" title="永久链接到（d）基础进口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果文件中的主要类型表示团队，则可以将修改器<code>base</code>应用于单个导入，以指定应仅将此类型作为基本类型导入应用程序。例子===</p>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><em><b>进口</b>基地</em> some.pack。MyBase;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre><b>公共</b> <b>团队</b> <b>班</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>  <span class="comment">//简单名称解析为导入的类：</span></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>  <b>受保护的</b> <b>类</b> MyRole <em><b>playBy</b> MyBase</em> {}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre>  <span class="error"><em>MyBase</em>非法声明;</span> <span class="comment">// base import不适用于此职位</span></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>}</pre></td>
                           </tr>
                        </table>
                     </div>
                     <p>基本导入不能是按需导入（使用通配符） <code>.*</code> ）。<br>基本导入导入的类型只能用于同样适用基类解封装（ <a href="#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）的位置。<br>建议在关键字<code>playedBy</code>之后提到的类型始终使用<code>base</code>修饰符导入，否则编译器将发出警告。<br>基本导入创建的范围与正常范围不相交。因此，作为基础导入的名称永远不会与通常可见的名称冲突（与<a href="s1.4.html" title="§1.4姓名冲突" class="sect">§1.4</a>相反）。更具体地说，如果使用基本导入，则对其角色使用基类名称也不是问题。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.1.2.e">
                     <h4 class="subsect">（e） <span class="title">没有自由类型参数</span><a class="img" href="s2.1.2.e.html" title="永久链接到（e）没有自由类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>playBy绑定中的角色类和基类都不能具有任何<em>自由类型参数</em> 。如果使用相同名称的类型参数指定两个类，则会识别这两个参数，并且不会将其视为<em>空闲</em> 。
                        				
                     </p>
                     <p>由此可见，角色类不能具有比其基础更多的类型参数。相反，只存在一种情况，其中基类可以拥有比绑定到它的角色类更多的类型参数：如果角色类没有类型参数，则可以使用基类的原始类型绑定通用基类，即，不指定类型参数。
                        				
                     </p>
                     <div class="note">
                        <h5>注：</h5>来自<code>playedBy</code>声明的信息在运行时用于将角色实例与基本实例相关联。指定具有自由类型参数的基类将意味着只有这样的基类实例由类型符合指定参数化类的角色进行修饰。但是，类型参数在运行时不可用，因此运行时环境无法确定哪些基本实例应该具有角色，哪些不应该具有角色。这是由于Java中的泛型设计是通过擦除实现的。
                        				
                     </div>
                     <p>以下示例显示了如何在各种位置使用泛型。请注意，示例中使用的某些概念将在后面的部分中介绍。
                     </p>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>公共</b> <b>类</b> ValueTrafo <em>&lt;T&gt;</em> {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>  <b>public</b> <em>T</em> transform（ <em>T</em> val） <b>抛出</b>异常{/ * ...* /}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre><b>公共</b> <b>团队</b> <b>类</b> TransformTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre>    <b>受保护的</b> <b>类</b> SafeTrafo <em>&lt;U&gt;</em> <b>playingBy</b> ValueTrafo <em>&lt;U&gt;</em> {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>        <em>U</em>变换（ <em>U</em> v） <b>- &gt;</b> <em>U</em>变换（ <em>U</em> val）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>        <b>protected</b> <em>U</em> safeTransform（ <em>U</em> v）{</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">8</td>
                              <td><pre>            尝试</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">9</td>
                              <td><pre>            	<b>return</b> transform（v）;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">10</td>
                              <td><pre>  } catch (Exception e) {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">11</td>
                              <td><pre>            	                 return v;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">12</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">13</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">14</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre>    <em>&lt;V&gt; V</em>执行（ValueTrafo <em>&lt;V&gt;</em> <b>为</b> SafeTrafo <em>&lt;V&gt;</em> trafo， <em>V</em>值）{</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">16</td>
                              <td><pre>        <b>return</b> trafo.safeTransform（value）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">17</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">18</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">19</td>
                              <td><pre>..</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">20</td>
                              <td><pre>ValueTrafo <em>&lt;String&gt;</em> trafo = <b>new</b> ValueTrafo <em>&lt;String&gt;</em> （）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">21</td>
                              <td><pre>TransformTeam safeTrafo = <b>new</b> TransformTeam（）;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">22</td>
                              <td><pre>String s = safeTrafo.perform（trafo，“Testing”）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">23</td>
                              <td><pre></pre></td>
                           </tr>
                        </table>
                     </div>
                     <div class="codecomment">
                        <h5>解释</h5>
                        <ul>
                           <li>第5行显示了一个带有类型参数<code>U</code>的角色，其中type参数用角色基类的相应类型参数标识（最初在第1行中声明为<code>T</code>
                           </li>
                           <li>第6行显示了一个callout绑定（ <a href="s3.html" title="§3标注绑定" class="sect">§3</a> ），它将一个基本方法转换为相应的角色方法，同时保持灵活的类型。
                           </li>
                           <li>第7-13行中的常规方法只传递<code>U</code>类型的值。
                           </li>
                           <li>第15行中的通用方法。使用声明的提升（第<a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">2.3.2节</a> ）来获取给定基础对象的角色。该方法不知道role或base的具体类型参数，但在保证两个类型参数对于任何单个调用都是相同的情况下工作。
                           </li>
                           <li>第20行ff。最后创建base和team的实例并调用该行为，从而将类型参数实例化为<code>String</code> 。
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s2.2">
               <h2 class="sect">§2.2降低<a class="img" href="s2.2.html" title="PermaLinkto§2.2降低"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <p>绑定角色类的每个实例在内部存储对其基础对象的引用。保证每个绑定的角色实例都存在引用，并且在其生命周期内不能更改。
                  		
               </p>
               <div class="subsect depth3" id="s2.2.a">
                  <h4 class="subsect">（a） <span class="title">降低的定义</span><a class="img" href="s2.2.a.html" title="PermaLink to（a）降低的定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>从角色对象中检索基础对象称为<strong>降低</strong> 。没有其他方法可以访问基准引用。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.2.b">
                  <h4 class="subsect">（b） <span class="title">降低的地方</span><a class="img" href="s2.2.b.html" title="永久链接到（b）降低地点"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>降低转换不是由客户端代码调用，而是由编译器在提供角色类型的所有位置插入<strong>隐式转换</strong> ，同时期望相应的基本类型（或超类型）。<br>换句话说：编译器在程序中的所有位置插入降低翻译，否则这些位置将不是类型正确的，并且使用降低是静态类型正确的。这可能涉及：</p>
                  <ul>
                     <li>作业的右手边。左手边的静态类型，</li>
                     <li>方法或构造函数的参数值调用wrt。相应形式参数的静态类型，</li>
                     <li>与方法的声明返回类型相比较的方法的返回值。</li>
                     <li>标注绑定中的角色参数（ <a href="s3.3.d.html" title="§3.3。（d）打字规则" class="sect">§3.3。（d）</a> ）</li>
                     <li>或者callin绑定中的返回值（ <a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ）</li>
                  </ul>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>公共</b> <b>课</b> <em>MyRole <b>playBy</b> MyBase</em> {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>void</b> useMyBase（ <em>MyBase</em> myb）{...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <em>MyRole</em> returnMyRole（）{...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  public void doSomething() {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>    <em>MyRole r</em> = <b>new</b> MyRole（ <b>new</b> MyBase（））;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>    <em>MyBase b</em> = <em>r</em> ;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>useMyBase（ <em>r</em> ）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>    <em>MyBase b2</em> = returnMyRole（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>效果：</h5>
                     <p>将<code>MyRole</code>类型的实例降低为类型<code>MyBase</code></p>
                     <ul>
                        <li>将其分配给<code>b</code> （第7行）</li>
                        <li>将它作为参数传递给具有<code>MyBase</code>类型的形式参数的方法（第8行）</li>
                        <li>将返回值赋给<code>MyBase</code>类型的变量（第9行）</li>
                     </ul>
                     <p><em>注意</em> ：第6行中的构造函数调用使用第<a href="#s2.4.1" title="§2.4.1 Role creation via a lifting constructor" class="sect">2.4.1节中</a>定义的<em>提升构造</em> <a href="#s2.4.1" title="§2.4.1通过提升构造函数创建角色" class="sect">函数</a></p>
                  </div>
                  <p><span class="underline">不</span>插入降低翻译</p>
                  <ul>
                     <li>参考比较（使用<code>==</code>或<code>!=</code> ）</li>
                     <li><code>instanceof</code>检查</li>
                     <li>演员表达</li>
                     <li>在callout绑定中返回值<a href="s3.3.d.html" title="§3.3。（d）打字规则" class="sect">§3.3。（d）</a> ）</li>
                     <li>callin绑定中的参数（ <a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ）</li>
                  </ul>
                  <p>对于<em>强制</em>降低的情况，见下文<a href="#s2.2.d" title="§2.2。（d）明显降低" class="sect">§2.2。（d）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.2.c">
                  <h4 class="subsect">（c） <span class="title">打字</span><a class="img" href="s2.2.c.html" title="永久链接到（c）打字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>隐式降低转换的静态类型是在相应的角色类中使用<code>playedBy</code>声明的基类。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.2.d">
                  <h4 class="subsect">（d）明显<span class="title">降低</span><a class="img" href="s2.2.d.html" title="永久链接到（d）显式降低"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果基类型也是其角色的超类型（经常发生），如果只有<code>Object</code>类型知道基本引用，则无法自动推断降低，因为类型可以解释为角色类型和基类型。这些情况可能需要<strong>明确降低</strong> 。为此，角色类必须声明实现接口<strong><code>ILowerable</code></strong> （来自<code>org.objectteams.ITeam</code> ）。这将导致编译器生成一个方法</p>
                  <div class="listing plain"><pre><b>public</b> Object lower（）</pre></div>
                  <p>对于给定的角色类。客户端代码可以使用此方法显式请求给定角色对象的基础对象。
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>公共</b> <b>类</b> MyRole <em><b>实现</b> ILowerable</em> <b>playingBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  public void doSomething() {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>MyRole r = <b>new</b> MyRole（ <b>new</b> MyBase（））;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>对象oMyRole = r;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>对象oMyBase = r。 <em>lower（）</em> ;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="subsect depth3" id="s2.2.e">
                  <h4 class="subsect">（e） <span class="title">降低阵列</span><a class="img" href="s2.2.e.html" title="PermaLink（e）降低数组"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>降低也适用于角色对象数组。为了降低角色对象数组，将创建一个新数组并使用基础对象填充，对应于原始数组中的每个角色对象。阵列可以具有任何形状的任何数量的尺寸。降低的阵列将具有完全相同的形状。<br>请注意，每次降低转换都会创建一个新数组。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.2.f">
                  <h4 class="subsect">（f） <span class="title">模糊降低</span><a class="img" href="s2.2.f.html" title="永久链接到（f）模糊降低"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>将绑定角色类型的值分配给<code>java.lang.类型的变量或参数时<code>java.lang.Object</code>这种情况被认为是模糊的降低，因为赋值可以应用（a）直接向上<code>Object</code>或（b）降低然后向上转换。在这种情况下，编译器<em>不会</em>插入降低转换，但会发出可配置的警告。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s2.3">
               <h2 class="sect">2.3 起吊 6</h2>
               <p>提升是降低的逆向翻译。但是，提升要求更高，因为给定的基础对象可能具有零到多个绑定到它的角色对象。因此，提升翻译需要更多的上下文信息，并且可能需要按需创建角色对象。
                  		
               </p>
               <div class="subsect depth3" id="s2.3.a">
                  <h4 class="subsect">（a） <span class="title">提升的定义</span><a class="img" href="s2.3.a.html" title="永久链接（a）提升的定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>检索给定基础对象的角色称为<strong>提升</strong> 。对于相同基础对象，相同团队实例和相同角色类的后续调用，保证提升产生相同的角色对象（有关由编译器警告和可能的运行时异常发出信号的歧义情况，请参阅<a href="#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.3.b">
                  <h4 class="subsect">（b） <span class="title">解除场所</span><a class="img" href="s2.3.b.html" title="永久链接到（b）提升场所"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>提升转换不是由客户端代码调用，而是由编译器在以下位置插入转换：</p>
                  <ul>
                     <li><a href="s3.3.c.html" title="§3.3。（c）结果翻译" class="sect">标注绑定（§3.3。（c））</a> （结果）</li>
                     <li><a href="s4.5.a.html" title="§4.5。（a）呼叫目标翻译" class="sect">Callin绑定（§4.5。（a））</a> （调用目标和参数）</li>
                     <li><a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">宣布解除（§2.3.2）</a></li>
                  </ul>
               </div>
               <div class="subsect depth3" id="s2.3.c">
                  <h4 class="subsect">（c） <span class="title">打字</span><a class="img" href="s2.3.c.html" title="永久链接到（c）打字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>提升翻译静态地期望特定的角色类。此预期角色类必须具有一个<code>playedBy</code>子句（直接或从超级角色继承（显式或隐式）），给定的基类型符合该子句。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.3.d">
                  <h4 class="subsect">（d） <span class="title">提升阵列</span><a class="img" href="s2.3.d.html" title="永久链接到（d）提升阵列"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>提升也适用于角色对象数组。为了提升基础对象数组，创建一个新数组并用角色对象填充，一个用于原始数组中的每个基础对象。与角色对象本身相反，提升的数组永远不会被重用于后续的提升调用。
                     			
                  </p>
               </div>
               <p id="s2.3.transpol">术语<strong>翻译多态性</strong>描述了这样的事实：在某些点处，只能考虑常规继承（ <code>extends</code> ），可以传递不符合相应声明类型的值。使用翻译多态性，可以使用提升或降低来翻译值。
                  		
               </p>
               <div class="sect depth3" id="s2.3.1">
                  <h3 class="sect">§2.3.1隐式角色创建<a class="img" href="s2.3.1.html" title="PermaLinkto§2.3.1隐式角色创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.3">↑§2.3</a></span></h3>
                  <p>提升尝试重用现有的角色对象，以便角色状态在提升和降低期间持续存在。如果在提升期间未找到合适的角色实例，则会创建新角色。
                     			
                  </p>
                  <div class="subsect depth4" id="s2.3.1.a">
                     <h4 class="subsect">（a） <span class="title">重用现有的角色对象</span><a class="img" href="s2.3.1.a.html" title="PermaLink（a）重用现有角色对象"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果这三个项目相同，则角色对象被认为适合在提升期间重复使用：</p>
                     <ol>
                        <li>给定的基础对象</li>
                        <li>给定的团队对象</li>
                        <li>静态要求的角色类型</li>
                     </ol>
                     <p>对于静态要求的角色类型和角色对象的实际类型之间的关系，请参阅<a href="#s2.3.3" title="§2.3.3智能提升" class="sect">“智能提升”（第2.3.3节）</a> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.1.b">
                     <h4 class="subsect">（b） <span class="title">默认提升构造函数</span><a class="img" href="s2.3.1.b.html" title="永久链接到（b）默认提升构造函数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>提升使用一个默认构造函数， <code>playedBy</code>接受一个声明的基类类型的参数（在<code>playedBy</code>之后）。默认情况下，编译器为每个绑定角色生成此类构造函数。另一方面，从不为绑定角色生成不带参数的默认构造函数（如<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#16823" class="ext">JLS§8.8.7</a> ）。
                        			<br>默认提升构造函数调用的超级构造函数取决于角色的超类是否为绑定角色。
                        				
                     </p>
                     <ul>
                        <li>如果超类是绑定角色，则默认提升构造函数将调用超类的默认提升构造函数。</li>
                        <li>如果超类不是绑定角色，则默认提升构造函数将调用超类的普通无参数默认构造函数。
                        </li>
                     </ul>
                  </div>
                  <div class="subsect depth4" id="s2.3.1.c">
                     <h4 class="subsect">（c） <span class="title">定制提升构造器</span><a class="img" href="s2.3.1.c.html" title="PermaLink至（c）定制提升构造器"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果角色类声明了与默认提升构造函数具有相同签名的自定义构造函数，则在提升期间使用此构造函数。此自定义构造函数可以预先假定角色已针对其基本链接正确设置并在团队的内部角色映射中注册。
                        			<br>如果绑定角色具有未绑定的超类而没有无参数构造函数，则必须提供自定义提升构造函数，因为不能生成合法的默认提升构造函数。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.1.d">
                     <h4 class="subsect">（d） <span class="title">微调角色实例化</span><a class="img" href="s2.3.1.d.html" title="PermaLink（d）微调角色实例化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果上面定义的提升操作降低了程序性能，则可以通过添加注释<code>@org.objectteams.来修改每个角色类的提升语义<code>@org.objectteams.需要参数类型为<code>org.objectteams. Instantiation</code> <code>org.objectteams.InstantiationPolicy</code>以便在以下行为之间进行选择：</p>
                     <dl>
                        <dt>OnDemand</dt>
                        <dd>这是上面定义的默认行为。</dd>
                        <dt>总是这样。</dt>
                        <dd>此策略避免维护内部角色缓存，而是为每个提升请求创建一个新的角色实例。这可能会增加角色实例的数量，但会降低访问缓存的成本，否则如果缓存变大，这可能会变得昂贵。由于此策略，角色状态不能再随时间共享，因此不鼓励使用此策略定义角色中的字段。此外，比较角色可能会导致意外结果。因此，使用此策略的角色应该实现自定义<code>equals</code>和<code>hashCode</code>方法，这些方法应该简单地委托给基本实例（使用<a href="s3.html" title="§3标注绑定" class="sect">callout§3</a> ）。
                        </dd>
                        <dt>永远不要。</dt>
                        <dd>具有此实例化策略的角色永远不会通过提升来实例化。此类角色无法定义非静态字段。否则，此优化是完全透明的，特别是callout绑定将引用正确的基本实例。<br>从版本2.0开始，OT / J编译器不实现此策略。
                        </dd>
                        <dt>Singleton;</dt>
                        <dd>声明此策略的角色最多只能为每个团队实例化一次。同一团队中的后续提升请求将始终回答相同的角色实例。此类角色可能会从callin绑定接收触发器，但无法定义callout绑定。<br>从版本2.0开始，OT / J编译器不实现此策略。
                        </dd>
                     </dl>
                  </div>
               </div>
               <div class="sect depth3" id="s2.3.2">
                  <h3 class="sect">§2.3.2宣布解除<a class="img" href="s2.3.2.html" title="PermaLinkto§2.3.2声明解除"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.3">↑§2.3</a></span></h3>
                  <div class="syntaxlink"><a href="sA.html#sA.6.2" title="§A.6.2LiftingType" class="syntax">→语法§A.6.2</a></div>
                  <div class="subsect depth4" id="s2.3.2.a">
                     <h4 class="subsect">（a） <span class="title">声明提升的参数</span><a class="img" href="s2.3.2.a.html" title="PermaLink to（a）声明提升的参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>非静态团队级方法或构造函数可以声明具有两种类型的参数，以明确表示<strong>提升的位置</strong> 。使用语法</p>
                     <div class="listing plain"><pre><b>public</b> <b>void</b> m（BaseClass <em>as</em> RoleClass param）{ <i>stmts</i> }</pre></div>
                     <p>如果第二种类型（ <code>RoleClass</code> ）是（ <code>playedBy</code> ）第一种类型（ <code>BaseClass</code> ）的角色，则可以声明一个可升级的参数。此外，角色类型必须是定义给定方法的封闭团队类的角色。角色类型必须由其简单（即不合格）名称给出。
                        			<br>这样的签名要求调用者提供基础对象（此处为<code>BaseClass</code> ），但被调用者接收角色对象（此处为<code>RoleClass</code> ）。实际上，客户端会看到一个签名，其中省略了“ <code>as RoleClass</code> ”部分。
                        			<br>呼叫者和被呼叫者之间的兼容性通过隐式插入的提升转换来实现。如果要求提升，则使用声明提升的签名仅有效（详情请参见<a href="#s2.3.3" title="§2.3.3智能提升" class="sect">§2.3.3</a>和<a href="#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ）。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.2.b">
                     <h4 class="subsect">（b） <span class="title">在宣布解除的范围内超级</span><a class="img" href="s2.3.2.b.html" title="PermaLink to（b）Super在声明提升的背景下"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在声明提升一个或多个参数的方法或构造函数中调用<code>super</code>或<code>tsuper</code>是指具有角色类型参数的方法或构造函数，即， <em>在</em>超级调用<em>之前进行</em>提升。然而，超级方法也可以具有声明的提升签名。然后它将看到与当前方法相同的角色实例。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.2.c">
                     <h4 class="subsect">（c） <span class="title">宣布解除阵列</span><a class="img" href="s2.3.2.c.html" title="PermaLink to（c）声明解除数组"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果涉及显式提升的参数应该是<strong>数组</strong>类型，则语法为</p>
                     <div class="listing plain"><pre><b>public</b> <b>void</b> m（BaseClass <b>as</b> RoleClass param []）...</pre></div>
                     <p>这里表示数组的括号适用于<code>BaseClass</code>和<code>RoleClass</code>这两种类型。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.2.d">
                     <h4 class="subsect">（d） <span class="title">宣布解除捕获区块</span><a class="img" href="s2.3.2.d.html" title="PermaLink to（d）声明解除catch块"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>catch块的参数也可以应用声明的提升，如：</p>
                     <div class="listing plain"><pre><b>catch</b> （BaseException <b>as</b> RoleClass param）{ <i>stmts</i> }</pre></div>
                     <p>此语法仅在团队的非静态范围内有效（直接或嵌套）。在给定的示例中， <code>RoleClass</code>必须由<code>BaseException</code> 。注意， <code>RoleClass</code>本身不一定是throwable。由于此声明的效果，catch块将捕获<code>BaseException</code>类型的任何异常，并将其与<code>RoleClass</code>实例一起包装到后续块中。
                        			<br>还要注意，重新抛出给定的实例<code>param</code>具有在抛出之前隐式地将角色降低到其基本异常的语义，因为角色仅通过降低符合所需类型<code>Throwable</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.2.e">
                     <h4 class="subsect">（e） <span class="title">通用宣布解除</span><a class="img" href="s2.3.2.e.html" title="永久链接到（e）通用声明提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>声明提升的方法可能会引入一个相对于给定角色类型有界的类型参数。这种约束声明为：</p>
                     <div class="listing plain"><pre>&lt;AnyBase <b>base</b> SuperRole&gt; <b>void</b> teamMethod（AnyBase <b>as</b> SuperRole arg）{ <span class="comment">// body使用arg，类型为SuperRole</span> }</pre></div>
                     <p>这意味着<code>AnyBase</code>是一个类型参数，其实例化对于角色<code>SuperRole</code>都必须是可<code>SuperRole</code> 。
                        				
                     </p>
                     <p>给定的类型绑定要求调用站点提供与任何基类兼容的参数，当前团队包含的绑定角色是<code>SuperRole</code>的子类，包括<code>SuperRole</code>本身。但是， <code>SuperRole</code>本身不需要绑定到任何基类。另一方面， <code>AnyBase</code>不同有效替换不需要通过继承来关联。
                        				
                     </p>
                     <div class="note">
                        <h5>注：</h5>此功能支持对其他不相关的基类进行广义处理。这是通过为所考虑的每个基础定义一个绑定角色并使所有这些角色扩展一个共同的未绑定角色来完成的。
                        				
                     </div>
                  </div>
                  <h5 class="listing">示例代码（声明提升）：</h5>
                  <div class="listing example frame" id="l2.3.2">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>团队</b> <b>级</b>超级{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>公共</b> <b>课</b> MyRole <b>playBy</b> MyBase {...}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>void</b> m（MyRole o）{...};</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre><b>团队</b> <b>类</b> Sub <b>延伸</b>超级{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>  <b>void</b> m（ <em>MyBase <b>as</b> MyRole o</em> ）{</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>    <span class="comment">//在此方法中，o的类型为MyRole</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>super.m（O）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>Sub s_ <b>team</b> = <b>new</b> Sub（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>MyBase b = <b>new</b> MyBase（）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre>s_team.m（b）中; <span class="comment">//客户端看到参数“MyBase o”</span></pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>效果：</h5>
                     <ul>
                        <li>客户端使用方法<code>m</code>和基本实例（类型<code>MyBase</code> ）作为其参数（第13行）。
                        </li>
                        <li>在执行<code>m</code>的主体之前，解除参数，使得方法体接收<code>MyRole</code>类型的参数（第8行）。
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect depth3" id="s2.3.3">
                  <h3 class="sect">§2.3.3智能提升<a class="img" href="s2.3.3.html" title="PermaLinkto§2.3.3智能提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.3">↑§2.3</a></span></h3>
                  <p>在角色和基类是某些继承层次结构（ <code>extends</code> ）的一部分的情况下，在提升期间选择适当的角色类涉及以下规则：</p>
                  <div class="subsect depth4" id="s2.3.3.a">
                     <h4 class="subsect">（a） <span class="title">静态调整</span><a class="img" href="s2.3.3.a.html" title="永久链接到（a）静态调整"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果一个基类<code>B</code>应该被提升到一个没有绑定到（ <code>playedBy</code> ） <code>B</code>的角色类<code>R</code> ，但是如果一个<code>R</code>的子类 - 比如<code>R2</code> - 被绑定到<code>B</code> ，则提升是静态设置为使用<code>R2</code> ，最通用的子类与<code>B</code>或其超类型之一绑定的<code>R</code>
                        				
                     </p>
                     <div class="note">
                        <h5>限制</h5>此步骤不适用于<code>replace</code> callin绑定的参数映射（ <a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ）。
                        				
                     </div>
                  </div>
                  <div class="subsect depth4" id="s2.3.3.b">
                     <h4 class="subsect">（b） <span class="title">动态选择角色类</span><a class="img" href="s2.3.3.b.html" title="PermaLink to（b）动态选择角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在运行时，还会考虑基础对象的动态类型：提升总是尝试使用绑定到基础对象的确切类的角色类。提升考虑了由<code>playedBy</code>绑定的所有角色基对，使得角色类是所需（静态声明的）角色类型的子类，并且基类是基础对象的动态类型的超类。
                        			<br>从那些可能的对中，选择最具体的基类。如果将多个角色类绑定到此基类，则会选择这些类中最具体的类。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.3.c">
                     <h4 class="subsect">（c） <span class="title">团队作为封闭的世界</span><a class="img" href="s2.3.3.c.html" title="永久链接到（c）团队作为封闭的世界"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在上面的分析中，所有角色库对都在编译时执行。从下面可以看出，团队类只有在知道所有包含的角色类时才能编译，并且在没有团队的情况下永远不能编译角色类。
                        			<br>分析包括从超级团队继承的所有角色及其绑定。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.3.d">
                     <h4 class="subsect">（d） <span class="title">选择，无论抽象性如何</span><a class="img" href="s2.3.3.d.html" title="永久链接到（d）选择，无论抽象性如何"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>智能提升不受角色类抽象性的影响。有关抽象角色类的效果，请参见<a href="#s2.5" title="§2.5摘要角色" class="sect">§2.5</a> 。
                        				
                     </p>
                  </div>
                  <h5>复杂的例子：</h5>
                  <p><img src="../images/smart_lifting_small.png" alt="智能提升的例子"></p>
                  <table border="2" width="80%">
                     <colgroup span="1">
                        <col align="left" span="1">
                        <col align="left" span="1">
                     </colgroup>
                     <tr>
                        <th rowspan="1" colspan="1">角色类</th>
                        <th rowspan="1" colspan="1">基类</th>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">R1级</td>
                        <td rowspan="1" colspan="1"> </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">class R2扩展了R1 playingBy B2</td>
                        <td rowspan="1" colspan="1">B2级</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">R3类延伸R2 <em>/ *继承：playingBy B2 * /</em></td>
                        <td rowspan="1" colspan="1">B3级延伸B2</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">R4级延伸R3播放B4</td>
                        <td rowspan="1" colspan="1">B4类扩展了B3</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">类R5扩展R4 <em>/ *继承：playingBy B4 * /</em></td>
                        <td rowspan="1" colspan="1"> </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"> </td>
                        <td rowspan="1" colspan="1">B6类扩展了B4</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">R7级延伸R5 playBy B7</td>
                        <td rowspan="1" colspan="1">B7类扩展了B6</td>
                     </tr>
                  </table>
                  <div class="codecomment">
                     <ul>
                        <li>如果声明需要将<code>B3</code>提升到<code>R1</code>则静态细化以使用<code>R2</code> ，因为这是最通用的类，声明绑定到超级<code>B3</code> 。
                           					
                        </li>
                        <li>如果相同情况下的动态基类型为<code>B6</code> ，则三个步骤选择适当的角色：<ol>
                              <li>通过搜索所有的<code>playedBy</code>子句（包括那些被继承的子句），以下角色库对是候选者：<br><code>(R2,B2), (R3,B2), (R4,B4)</code>和<code>(R5,B4)</code> 。
                              </li>
                              <li>从这些对中选择含有最特定碱基<code>B4</code>两个。
                              </li>
                              <li>这使<code>R4</code>和<code>R5</code>成为候选角色，最终选择最具体的<code>R5</code> 。
                              </li>
                           </ol>
                        </li>
                     </ul>
                  </div>
                  <p>如果给出了所涉及的基类和角色类的继承层次结构（如上图所示），则可以将智能提升算法改写为以下“图形”规则：<br></p>
                  <div class="note">从动态基类型（示例中的<code>B6</code> ）开始向上移动继承关系，直到到达绑定到由指向基类（ <code>B4</code> ）的«playingBy»箭头指示的角色类的基类。此角色类必须符合所请求的角色类型。沿此箭头切换到角色一侧（ <code>R4</code> ）。现在向下移动角色继承层次结构，只要子角色不会细化playingBy关系（由另一个«playingBy»箭头指示）。您通过这种方式达到的最低角色（ <code>R5</code> ）是智能提升所选择的角色类型。
                     			
                  </div>
               </div>
               <div class="sect depth3" id="s2.3.4">
                  <h3 class="sect">§2.3.4绑定含糊不清<a class="img" href="s2.3.4.html" title="PermaLinkto§2.3.4绑定含糊不清"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.3">↑§2.3</a></span></h3>
                  <p>虽然到目前为止所有示例都只显示了1对1的类绑定，但允许多个绑定的情况。可以在编译时和/或在运行时检测模糊度。
                     			
                  </p>
                  <div class="subsect depth4" id="s2.3.4.a">
                     <h4 class="subsect">（a） <span class="title">潜在的模糊性</span><a class="img" href="s2.3.4.a.html" title="永久链接到（a）潜在的模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果存在两个角色类<code>R1</code>和<code>R2</code> ，则给出<strong>潜在的歧义</strong></p>
                     <ul>
                        <li><code>R1</code>和<code>R2</code>由相同的基类<code>B</code>播放，并且</li>
                        <li><code>R1</code>和<code>R2</code>具有共同的超级角色<code>R0</code> ，它也绑定到基类<code>B0</code> ，和</li>
                        <li>角色类<code>R1</code>和<code>R2</code>都不是另一个的（间接）子类。
                        </li>
                     </ul>
                     <div class="note">
                        <h5>注：</h5>根据<a href="#s2.1.c" title="§2.1。（c）协变细化" class="sect">§2.1。（c）中</a> ，如果<code>B</code>有别于<code>B0</code>它必须是一个亚类的<code>B0</code> 。
                        				
                     </div>
                     <div class="note">
                        <h5>16 生效</h5>在这种情况下，编译器发出警告，声明<code>B</code> <em>可能不是可升级的，</em>因为角色类<code>R1</code>和<code>R2</code>都是候选者，并且没有理由<em>优先</em>选择其中一个。
                        					<br><strong>如果没有检测到潜在的歧义，那么提升将始终是明确的。</strong></div>
                     <p>在上述情况下，尝试将类型<code>B</code>的实例提升到角色类型<code>R0</code>是<strong>非法的提升请求</strong> 。如果<code>R0</code>与其子角色<code>R1</code>和<code>R2</code>绑定到相同的基类<code>B</code> ，则角色<code>R0</code>是<strong>不可释放的</strong> ，这意味着不能通过提升获得<code>R0</code>实例。
                        				
                     </p>
                     <h5 class="listing">示例代码（潜在歧义）：</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展了</b> SuperRole {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre>}</pre></td>
                           </tr>
                        </table>
                     </div>
                  </div>
                  <div class="subsect depth4" id="s2.3.4.b">
                     <h4 class="subsect">（b） <span class="title">明确的歧义</span><a class="img" href="s2.3.4.b.html" title="PermaLink to（b）明确的歧义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果有一个<strong>明确的歧义</strong></p>
                     <ul>
                        <li>根据上述（a）给出的潜在歧义的情况给出了</li>
                        <li>需要提升（通过方法绑定或显式（ <a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ））从共享基类<code>B</code>到任何角色类<code>R0</code> ，它是<code>R1</code>和<code>R2</code>的共同超级角色。
                        </li>
                     </ul>
                     <p>在通用声明提升<a href="#s2.3.2.e" title="§2.3.2.(e) Generic declared lifting" class="sect">§2.3.2的</a>情况下也会出现明确的绑定歧义<a href="#s2.3.2.e" title="§2.3.2。（e）通用宣布解除" class="sect">。（e）</a>如果指定的角色<code>R</code>是未绑定的，并且存在两个独立的子角色<code>R1</code>和<code>R2</code> ，它们将playBy绑定引入同一个基类<code>BX</code> 。在这种情况下，没有标记潜在的歧义，因为角色<code>R1</code>和<code>R2</code>没有共享绑定超级角色。
                        				
                     </p>
                     <div class="note">
                        <h5>16 生效</h5>处理<code>org.objectteams.需要导致明确歧义的代码<code>org.objectteams.LiftingFailedException</code> 。
                        				
                     </div>
                     <p>在明确约束的情况下，除了一些极端情况之外，提升确实会失败。如果提升已经在缓存中找到了适当的角色，或者如果模糊绑定角色的（间接）子角色在运行时对于基础对象的具体类型是明确的提升目标，则可能出现这种极端情况。See also
                        				
                     </p>
                     <h5 class="listing">示例代码（Definite Ambiguity）：</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>  <b>public</b> <b>void</b> useSuperRole（SubBase <b>as</b> SuperRole r）{...} <span class="comment">// <span class="error">必须声明LiftingFailedException</span></span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>}</pre></td>
                           </tr>
                        </table>
                     </div>
                  </div>
                  <div class="subsect depth4" id="s2.3.4.c">
                     <h4 class="subsect">（c） <span class="title">实际含糊不清</span><a class="img" href="s2.3.4.c.html" title="永久链接到（c）实际模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在运行时，如果要提升基础的<em>动态类型</em> ，则可能发生<strong>实际模糊</strong> ，因此上述（b）的条件相应地保持。实际模糊性仅在编译器报告为潜在或明确歧义的情况下才有可能。
                        				
                     </p>
                     <div class="note">
                        <h5>16 生效</h5>通过抛出<code>org.objectteams.在运行时报告实际的歧义<code>org.objectteams.LiftingFailedException</code> 。
                        				
                     </div>
                     <h5 class="listing">示例代码（实际歧义）：</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>import</b> org.objectteams。LiftingFailedException;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>  </pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>  <b>public</b> <b>void</b> useSuperRole（MyBase <b>as</b> SuperRole r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">8</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">9</td>
                              <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">10</td>
                              <td><pre>MyTeam mt = <b>new</b> MyTeam（）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">11</td>
                              <td><pre>mt.useSuperRole（ <b>new</b> SubBase（））; <span class="comment">// <span class="error">将抛出LiftingFailedException</span></span></pre></td>
                           </tr>
                        </table>
                     </div>
                  </div>
                  <div class="subsect depth4" id="s2.3.4.d">
                     <h4 class="subsect">（d） <span class="title">不匹配的作用</span><a class="img" href="s2.3.4.d.html" title="永久链接到（d）不匹配的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在可能存在歧义的情况下，可能会发生另一个运行时错误：在缓存中找到角色时遇到<strong>不匹配的角色</strong> ，该角色不符合所需的类型。如果基础对象先前已被提升到与当前请求的类型不兼容的类型，则会发生这种情况。
                        				
                     </p>
                     <div class="note">
                        <h5>16 生效</h5>这是通过抛出<code>org.objectteams.来报告的<code>org.objectteams.WrongRoleException</code> 。
                        				
                     </div>
                     <h5 class="listing">示例代码（不匹配的角色）：</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>import</b> org.objectteams。LiftingFailedException;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>					<b>团队</b> <b>一级</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展了</b> SuperRole {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>  </pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>  <b>public</b> <b>void</b> useRoleA（MyBase <b>as</b> SubRoleA r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">8</td>
                              <td><pre>  <b>public</b> <b>void</b> useRoleB（MyBase <b>as</b> SubRoleB r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">9</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">10</td>
                              <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">11</td>
                              <td><pre>MyTeam mt = <b>new</b> MyTeam（）;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">12</td>
                              <td><pre>MyBase b = <b>new</b> MyBase（）;</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">13</td>
                              <td><pre>mt.useRoleA（b）中; <span class="comment">//为b创建一个SubRoleA</span></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">14</td>
                              <td><pre>mt.useRoleB（b）中; <span class="comment">// <span class="error">找到不兼容的SubRoleA</span></span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre>                <span class="comment">// <span class="error">到期望的类型SubRoleB。</span></span></pre></td>
                           </tr>
                        </table>
                     </div>
                     <p>从<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">§2.3.4。（a）</a>的第二项<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">开始</a> ，对于绑定歧义，不同的角色层次结构是<a href="#s2.3.4.a" title="§2.3.4。（a）潜在的模糊性" class="sect">单独</a>分析的。对于此分析，只考虑那些绑定到基类的角色类（直接使用<code>playedBy</code>或从另一个角色类继承此关系）。即，两个没有共同超级角色的角色类永远不会导致任何歧义。
                        				
                     </p>
                  </div>
               </div>
               <div class="sect depth3" id="s2.3.5">
                  <h3 class="sect">§2.3.5解除问题的后果<a class="img" href="s2.3.5.html" title="PermaLinkto§2.3.5解除问题的后果"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.3">↑§2.3</a></span></h3>
                  <p>提升和角色绑定的规则允许（在发出警告之后）两个有问题的情况：</p>
                  <ol>
                     <li>潜在的约束歧义使得选择<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">适当的</a>角色类型成为不可能（ <a href="#s2.3.4.a" title="§2.3.4。（a）潜在的模糊性" class="sect">§2.3.4。（a）</a> ）</li>
                     <li>可能与提升相关的角色是抽象的（ <a href="#s2.5.b" title="§2.5。（b）相关角色" class="sect">§2.5。（b）</a> ）</li>
                  </ol>
                  <p>每当提升失败时，由于其中一个原因， <code>org.objectteams.LiftingFailedException</code> （ LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）。鉴于这是一个经过检查的例外，并且取决于需要解除的位置，这会产生以下后果：</p>
                  <div class="subsect depth4" id="s2.3.5.a">
                     <h4 class="subsect">（a）有<span class="title">问题的宣布解除</span><a class="img" href="s2.3.5.a.html" title="永久链接到（a）有问题的宣布解除"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>声明提升的方法（ <a href="#s2.3.2" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ）可能必须声明<code>org.objectteams.LiftingFailedException</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.5.b">
                     <h4 class="subsect">（b）有<span class="title">问题的标注约束</span><a class="img" href="s2.3.5.b.html" title="PermaLink到（b）有问题的标注绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>带结果提升的标注绑定的角色方法（ <a href="s3.3.c.html" title="§3.3。（c）结果翻译" class="sect">§3.3。（c）</a> ）可能必须声明<code>org.objectteams.LiftingFailedException</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.5.c">
                     <h4 class="subsect">（c）有<span class="title">问题的愈伤组织结合</span><a class="img" href="s2.3.5.c.html" title="PermaLink（c）有问题的callin结合"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>由于<code>org.objectteams. callin绑定（ <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）可能会无声地失败<code>org.objectteams.LiftingFailedException</code> 。此异常实际上将保持隐藏，因为callin绑定未从任何源代码显式调用，而是由运行时调度机制隐式调用。为了表明这种情况，编译器会针对此类callin绑定引发错误。
                        				
                     </p>
                     <p>但是，编译器应允许配置此错误并理解警告标记<code>"hidden-lifting-problem"</code>以抑制此问题（第<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">4.1节（b）</a> ）。如果问题被忽略/抑制，并且如果在运行时发生提升问题，则触发callin绑定将无声地失败，即程序将在这种情况下继续，就好像绑定首先不存在一样。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.3.5.d">
                     <h4 class="subsect">（d） <span class="title">不兼容的角色层次结构的重新定义</span><a class="img" href="s2.3.5.d.html" title="PermaLink到（d）不兼容的角色层次结构重新定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>考虑具有方法<code>m</code>的团队<code>T1</code> ，其中关于角色<code>R</code>声明提升，其中没有检测到提升问题。接下来考虑一个子团队<code>T2</code> ，它修改角色<code>R</code>的层次结构，以便提升到<code>T2.由于绑定模糊， R</code>是有问题的。在这种情况下，调用<code>T1.m()</code>客户端可能会在运行时遇到使用<code>T2</code>的实例的情况，该实例<em>意外地</em>无法解除其角色<code>R</code>在这里，编译器发出一个特定的错误信号，反对<code>T2</code>警告不兼容的变化。
                        				
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s2.4">
               <h2 class="sect">§2.4明确的角色创建<a class="img" href="s2.4.html" title="PermaLinkto§2.4显式角色创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <p>提升是隐式创建角色对象的常用技术。本节定义了在哪些条件下还可以明确创建角色。
                  		
               </p>
               <div class="sect depth3" id="s2.4.1">
                  <h3 class="sect">§2.4.1通过提升构造函数创建角色<a class="img" href="s2.4.1.html" title="PermaLinkto§2.4.1通过提升构造函数创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.4">↑§2.4</a></span></h3>
                  <p>提升使用角色的默认构造函数（参见<a href="#s2.3.1" title="§2.3.1隐式角色创建" class="sect">§2.3.1</a> ）。如果遵循以下规则，则可以从客户端代码调用此构造函数。
                     			
                  </p>
                  <div class="subsect depth4" id="s2.4.1.a">
                     <h4 class="subsect">（a） <span class="title">团队背景</span><a class="img" href="s2.4.1.a.html" title="PermaLink到（a）团队环境"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>提升构造函数只能在要实例化的角色的封闭团队中使用。因此，合格的分配表达式（ <code>someTeam.new SomeRole(..)</code> ）可能永远不会使用提升构造函数。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.4.1.b">
                     <h4 class="subsect">（b） <span class="title">新鲜基础物体</span><a class="img" href="s2.4.1.b.html" title="PermaLink to（b）Fresh base object"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果提升构造函数调用的参数是一个<code>new</code>表达式，创建一个新的基础对象，则使用提升构造函数是安全的。否则，以下（c）的规则适用。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.4.1.c">
                     <h4 class="subsect">（c） <span class="title">重复角色运行时检查</span><a class="img" href="s2.4.1.c.html" title="PermaLink到（c）重复角色运行时检查"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果它不能在语法上派生，那么提升构造函数的参数是一个新创建的基础对象（b），编译时警告将指示需要进行额外的运行时检查：必须防止为a创建新角色基础对象，已在给定团队中具有所需类型的角色。使用提升构造器无法替换现有角色。在运行时，任何尝试这样做都会导致<code>org.objectteams.要抛出DuplicateRoleException</code> 。此异常只能在发出上述编译时警告的情况下发生。
                        		<br><a href="s6.1.html" title="反射" class="sect">§6.1</a>将引入反射函数，可用于手动防止重复角色等错误。
                        				
                     </p>
                  </div>
               </div>
               <div class="sect depth3" id="s2.4.2">
                  <h3 class="sect">§2.4.2通过常规构造函数创建角色<a class="img" href="s2.4.2.html" title="PermaLinkto§2.4.2通过常规构造函数创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.4">↑§2.4</a></span></h3>
                  <p>还可以使用具有除提升构造函数的签名之外的任意签名的自定义构造函数来显式创建角色。<br>在角色构造函数中，有四种自调用：</p>
                  <dl>
                     <dt><code>基本</code></dt>
                     <dd>相应基类的构造函数（第<a href="sA.html#sA.5.3" title="§A.5.3BaseCall" class="sect">A.5.3节</a> （c））， <span class="underline">除非</span>该角色涉及基类循环（第<a href="#s2.1.2.b" title="§2.1.2。（b）周期" class="sect">2.1.2节（b）</a> ），在这种情况下，基础构造函数调用是非法的。
                     </dd>
                     <dt><code>T.H.I.S</code></dt>
                     <dd>同一类的另一个构造函数。</dd>
                     <dt><code>超级</code></dt>
                     <dd>超类的构造函数（normal <code>extends</code> ）， <span class="underline">除非</span>超类绑定到不同的基类，在这种情况下调用<code>super(..)</code>是不合法的。
                     </dd>
                     <dt><code>tsuper（..）</code></dt>
                     <dd>超级团队相应角色的构造函数（ <a href="sA.html#sA.5.4" title="§A.5.4TSuperCall" class="sect">§A.5.4</a> （e））。另见<a href="s1.3.2.c.html" title="§1.3.2。（c）构造者和被覆盖的&#39;延伸&#39;" class="sect">§1.3.2。（c）中</a>的约束。
                     </dd>
                  </dl>
                  <div class="subsect depth4" id="s2.4.2.a">
                     <h4 class="subsect">（a） <span class="title">不受约束的角色</span><a class="img" href="s2.4.2.a.html" title="PermaLink到（a）未绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><strong>未绑定</strong>到基类的角色的每个构造函数必须使用<code>this(..)</code> ， <code>super(..)</code>或<code>tsuper(..)</code> 。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.4.2.b">
                     <h4 class="subsect">（b） <span class="title">约束角色</span><a class="img" href="s2.4.2.b.html" title="PermaLink到（b）绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p><strong>绑定角色的</strong>每个构造函数必须直接或间接调用<code>base(..)</code>构造函数或提升构造函数（参见<a href="#s2.3.1" title="§2.3.1隐式角色创建" class="sect">§2.3.1</a> ）。间接调用基础构造函数或提升构造函数可以使用任何<code>this(..)</code> ， <code>super(..)</code> 或者<code>tsuper(..)</code> ，它只是将义务委托给被调用的构造函数。
                        		<br>如果<code>base(..)</code>引用的构造函数根据Java的常规规则不可见，则仍可使用解<b>封装</b>调用它（另请参见<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ， <a href="#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）。
                        <br>请注意，如果未绑定super或tsuper角色，则将该义务委派给该未绑定角色将不起作用。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s2.4.2.c">
                     <h4 class="subsect">（c） <span class="title">超级约束角色</span><a class="img" href="s2.4.2.c.html" title="PermaLink to（c）超级调用绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>而不是在调用<code>base(..)</code>之前或之前，绑定角色的构造函数显式或隐式地调用超级构造函数。哪个构造函数适用取决于超级角色及其<code>playedBy</code>子句。
                        				
                     </p>
                     <ul>
                        <li>如果超级角色绑定到与当前角色相同的基类，<ul>
                              <li>不写超级调用会导致调用超级角色的提升构造函数。</li>
                              <li>显式调用超构造函数需要超级构造<i>要么</i><ol>
                                    <li>使用基础构造函数调用（直接或间接）创建角色实例， <i>或</i></li>
                                    <li>是一个提升构造函数，接收一个基本实例，当前角色必须提供该实例作为参数。</li>
                                 </ol>
                              </li>
                           </ul>
                        </li>
                        <li>如果超级角色被绑定但当前角色改进了<code>playedBy</code>关系（参见c.12<ul>
                              <li>必须调用提升构造函数，显式传递基础对象作为参数。</li>
                           </ul>
                        </li>
                        <li>如果角色具有未绑定的显式或隐式超级角色，则构造函数可以在调用<code>base(..)</code>之前可选地调用超级构造函数（使用<code>super(..)</code>或<code>tsuper(..)</code> <code>base(..)</code> 。否则，将隐式调用默认构造函数。
                           					
                        </li>
                     </ul>
                     <p>在调用超级角色的提升构造函数时，可以选择通过使用基础构造函数调用作为表达式来获取基础对象：</p>
                     <div class="listing plain"><pre>super（base（ <i>&lt;args&gt;</i> ））;</pre></div>
                  </div>
                  <p>语言系统通过使用具有匹配签名的构造函数创建适当基类的实例来评估基本构造函数。此外，还设置了从角色访问基础对象以及将来将基础对象提升到新角色所需的内部链接。
                     			
                  </p>
                  <p>基本构造函数的语法遵循以下规则：角色实现永远不会直接引用基类的任何名称或其功能。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="s2.4.3">
                  <h3 class="sect">§2.4.3在智能提升的情况下创建角色<a class="img" href="s2.4.3.html" title="PermaLinkto§2.4.3在智能提升的情况下创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s2.4">↑§2.4</a></span></h3>
                  <p>明确地实例化绑定到基本<code>B</code>的角色<code>R1</code> ，其中智能提升<code>B</code>到<code>R1</code>实际上将提供子角色<code>R2</code>是危险的：实例化将<code>R1</code>输入到团队的内部缓存中。如果在以后任何时候请求将此<code>B</code>提升为<code>R2</code> ，这是合法请求，则运行时系统将通过抛出<code>org.objectteams.WrongRoleException</code>因为它找到<code>R1</code>而不是所需的<code>R2</code> 。因此，在这种特定情况下，显式实例化<code>new R1(..)</code>将被警告标记。通过在实例化表达式中使用<code>R2</code>可以避免该问题。
                     			
                  </p>
                  <h5 class="listing">示例代码（WrongRoleException）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>课</b> B { <b>void</b> bm（）{}}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>班级</b> T {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>受保护的</b> <b>类</b> R1 <b>播放了</b> B {...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>受保护的</b> <b>类</b> R2 <b>扩展</b> R1 { <span class="comment">//继承绑定到B</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>    <b>void</b> rm（）{ <span class="comment">/ * body省略* /</span> }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>  <b>public</b> B getDecoratedB（）{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>    <b>返回</b> <em><b>新的</b> R1</em> （ <b>new</b> B（））; <span class="comment">// <span class="error">编译时警告！</span></span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>  <b>public</b> <b>void</b> requestLifting（B <b>as</b> R2 r）{}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre>T t = <b>new</b> T（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">14</td>
                           <td><pre>B b = t.getDecoratedB（）; <span class="comment">//为b创建一个R1</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre>t.requestLifting（b）中; <span class="comment">// =&gt; <span class="error"><code>org.objectteams.WrongRoleException！</code></span></span></pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <ul>
                        <li>第8行的注释：该行将新的<code>B</code>实例传递给<code>R1</code>的提升构造函数（参见<a href="#s2.4.1.b" title="§2.4.1。（b）新鲜的基础物体" class="sect">§2.4.1。（b）</a> ）。为了返回此<code>B</code>实例，降级被隐式用于return语句。
                        </li>
                        <li>当执行第15行时，请求将<code>b</code>提升到<code>R2</code> ，但是由于第8行，在内部高速缓存中找到了<code>R1</code> 。
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s2.5">
               <h2 class="sect">§2.5摘要角色<a class="img" href="s2.5.html" title="PermaLinkto§2.5抽象角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <p>覆盖角色类和角色类型的动态绑定（ <a href="s1.3.1.e.html" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ）将新案例添加到抽象类的<strong>创建中</strong> 。
                  		
               </p>
               <div class="subsect depth3" id="s2.5.a">
                  <h4 class="subsect">（a） <span class="title">使用抽象类进行创建</span><a class="img" href="s2.5.a.html" title="PermaLink（a）使用抽象类进行创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>抽象角色类确实可以用于创建对象。这种说法的效果是团队必须标记为<code>abstract</code> 。只有那些子团队具体为创建表达式中使用的所有角色类提供具体版本。<br>这包括以下情况：超级团队具有具体角色类并创建此角色类的实例，并且只有子团队将此角色类的状态更改为抽象。此外，子团队必须标记为抽象，因为它包含在创建表达式中使用的抽象角色类。
                     			
                  </p>
                  <div class="note">
                     <h5>解释</h5>由于角色创建表达式中的类型相对于封闭团队实例是后期绑定的，因此抽象角色类可以被视为<strong>模板和钩子模式</strong>中的<strong>钩子</strong> ，从<strong>模式</strong>级别提升到类级别：超级团队可能已经引用抽象角色类的构造函数，只有子团队将提供具体的角色类来填充必要的实现。
                     			
                  </div>
               </div>
               <div class="subsect depth3" id="s2.5.b">
                  <h4 class="subsect">（b） <span class="title">相关角色</span><a class="img" href="s2.5.b.html" title="PermaLink到（b）相关角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>一个团队必须注明<code>abstract</code> ，如果它的<strong>相关职责</strong>之一是抽象的。
                     		<br>在这个意义上，角色是相关的</p>
                  <ul>
                     <li>角色类是公共的<em>还是</em></li>
                     <li>一个显式的<code>new</code>表达式需要创建角色类的实例， <em>或者如果</em></li>
                     <li>封闭团队的任何提升方法都需要创建角色类的实例。<br>如果满足以下任一条件，则角色与提升无关：<ul>
                           <li>它既不直接绑定到基类，也不绑定到继承的<code>playedBy</code>子句。
                           </li>
                           <li>它有一个没有<code>playedBy</code>子句的子角色。
                           </li>
                           <li>它绑定到抽象基类，并且对于基类的所有具体子类，存在对更具体的角色类的绑定。
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>如果属性，相关性和不相关性都不能显示为抽象角色，则在封闭团队不是抽象的情况下会给出警告。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s2.6">
               <h2 class="sect">§2.6明确的基础参考<a class="img" href="s2.6.html" title="PermaLinkto§2.6显式基础引用"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <p>基于角色的链接并不是要从程序中显式访问，而是完全在编译器和运行时环境的控制之下。访问角色基础对象的功能是通过<a href="s3.html" title="§3标注绑定" class="sect">标注绑定（第3节）完成的</a> 。然而，存在关键字<code>base</code> ，可以在以下上下文中使用：</p>
               <div class="subsect depth3" id="s2.6.a">
                  <h4 class="subsect">（a） <span class="title">基础团队的外部化角色</span><a class="img" href="s2.6.a.html" title="PermaLink（a）基础团队的外部化角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果是角色<code>T1.的基类<code>T1.R1</code>又是一个队<code>T2</code> ，该团队的角色<code>T2</code>可以被外部（见<a href="s1.2.2.html" title="§1.2.2外化角色" class="sect">§1.2.2</a>使用） <code>base</code>作为其类型的锚。鉴于<code>R2</code>是<code>T2</code>的角色，可以写：</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>班</b> T1 {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>受保护的</b> <b>类</b> R1 <em><b>玩过</b> T2</em> {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>受保护的</b> <em>R2 &lt;@base&gt;</em> aRoleOfMyBase;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>此语法仅在角色<code>T1.的正文中合法<code>T1.R1</code>绑定到包含角色<code>R2</code>的团队<code>T2</code> 。静态类型前缀可用于消除基本锚的歧义，因此上述类型的显式变体将为<code>R2&lt;@ <strong>R1</strong> .base&gt;</code> 。
                     <br>使用包含<code>base</code>的类型锚作为<code>&lt;@base. <span class="error">field</span> &gt;</code>等引用路径中的元素是不合法的<code>&lt;@base. <span class="error">field</span> &gt;</code>或<code>&lt;@ <span class="error">field</span> .base&gt;</code> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.b">
                  <h4 class="subsect">（b） <span class="title">显式创建基础对象</span><a class="img" href="s2.6.b.html" title="PermaLink到（b）显式基础对象创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在角色构造函数（不是提升构造函数）中，语法<code>base( <em>arguments</em> )</code>导致创建和链接绑定基类的实例（参见<a href="#s2.4.2" title="§2.4.2通过常规构造函数创建角色" class="sect">§2.4.2</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.c">
                  <h4 class="subsect">（c） <span class="title">callin方法的碱基调用</span><a class="img" href="s2.6.c.html" title="PermaLink到（c）callin方法中的基本调用"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在<a href="s4.2.d.html" title="§4.2。（d）Callin方法" class="sect">callin方法（§4.2。（d））中</a> ，表达式<code>base.m( <em>args</em> )</code>用于调用最初调用的方法（参见<a href="s4.3.html" title="§4.3基本呼叫" class="sect">§4.3</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.d">
                  <h4 class="subsect">（d） <span class="title">基地保护谓词</span><a class="img" href="s2.6.d.html" title="永久链接到（d）基础守卫谓词"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以指定<a href="s5.4.html" title="§5.4守护谓词" class="sect">Guard谓词（第5.4节）</a> <code><strong>base when</strong></code>关键字<code><strong>base when</strong></code>使用<code><strong>base when</strong></code>作为<code><strong>base when</strong></code> 。在这样的基础保护谓词<code>base</code>被解释为一个特殊的标识符，其中包含对基础对象的引用，该基础对象即将被提取以进行callin方法拦截（参见<a href="s5.4.2.a.html" title="§5.4.2。（a）基础对象参考" class="sect">§5.4.2。（a）</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.e">
                  <h4 class="subsect">（e） <span class="title">参数映射</span><a class="img" href="s2.6.e.html" title="PermaLink到（e）参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>参数映射右侧的表达式（callin绑定中的参数（ <a href="s4.4.html" title="§4.4Callin参数映射" class="sect">§4.4</a> ）或导致callout绑定（ <a href="s3.2.c.html" title="§3.2。（c）结果映射" class="sect">§3.2。（c）</a> ））可以使用关键字<code>base</code>来引用绑定的基本实例。这种用法要求在此方法绑定中绑定的角色方法是非静态的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.f">
                  <h4 class="subsect">（f） <span class="title">禁止修改</span><a class="img" href="s2.6.f.html" title="PermaLink（f）抑制修饰"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在所有情况下， <code>base</code>引用都是不可变的，即<code>base</code>永远不会显示为赋值的左侧。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.6.g">
                  <h4 class="subsect">（g） <span class="title">通过基准参考进行解封装</span><a class="img" href="s2.6.g.html" title="PermaLink到（g）通过基准参考解封装"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在<a href="#s2.6.d" title="§2.6。（d）基地保护谓词" class="sect">上面的§2.6。（d）</a>和<a href="#s2.6.e" title="§2.6。（e）参数映射" class="sect">§2.6。（e）的情况下</a> ，可以访问基础对象的成员，这些成员在Java的可见性规则下是不可见的。根据<a href="s3.4.a.html" title="§3.4。（a）标注不可访问的基本方法" class="sect">§3.4。（a）</a>和<a href="s3.5.e.html" title="§3.5。（e）访问控制" class="sect">§3.5。（e）将</a>这些参考文献视为解封装。<br>请注意，仅通过<code>base</code>访问基本字段可以读取此字段的读取权限。
                     			
                  </p>
               </div>
               <div class="newpage"></div>
            </div>
            <div class="sect depth2" id="s2.7">
               <h2 class="sect">§2.7先进的结构<a class="img" href="s2.7.html" title="PermaLinkto§2.7高级结构"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2</a></span></h2>
               <p>本节讨论如何组合角色包含和playingBy关系。它没有定义新规则，但说明了上面定义的规则。中心思想是任何一个班级都可以拥有三种风格的<em>团队，角色</em>和<em>基础中的一种</em> 。
                  		
               </p>
               <div class="subsect depth3" id="s2.7.a">
                  <h4 class="subsect">（a） <span class="title">筑巢</span><a class="img" href="s2.7.a.html" title="PermaLink（a）嵌套"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果一个角色（包含在一个团队中）也是一个团队（用<code>team</code>修改器标记），那么它就是一个<strong>嵌套团队</strong> 。嵌套的深度不受限制。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.7.b">
                  <h4 class="subsect">（b） <span class="title">堆叠</span><a class="img" href="s2.7.b.html" title="PermaLink到（b）堆叠"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果使用<code>playedBy</code>绑定角色的基类是一个团队，则该角色被称为<strong>堆叠</strong>在基础团队中。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s2.7.c">
                  <h4 class="subsect">（c） <span class="title">分层</span><a class="img" href="s2.7.c.html" title="PermaLink（c）分层"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果团队<code>Secondary</code>节点的角色由另一个团队<code>Primary</code>角色（即基类是角色）扮演，则团队<code>Secondary</code>节点在团队<code>Primary</code> <code>Secondary</code>定义一个<strong>层</strong> 。这种分层需要从<code>Secondary</code>到<code>Primary</code>节点的最终引用<code>anchor</code> 。<code>Secondary</code>所有playingBy声明都指定了锚定到该最终链接<code>anchor</code>的基类。
                     			
                  </p><img src="../images/Layering.png" alt="团队分层示例"><p>由于锚定的基类型，分层团队隐式支持以下保证： <code>Secondary</code>角色的所有基础对象都包含在链接<code>anchor</code>指定的团队实例中。如果<code>Secondary</code>角色包含对非静态基本方法的任何callin绑定，则只有在由<code>anchor</code>指定的团队中包含的基本实例上调用基本方法时才会触发这些。
                     			<br>根据<a href="#s2.6.a" title="§2.6。（a）基础团队的外部化角色" class="sect">§2.6。（a）</a>这种锚定的playingBy声明中的锚点也可以是伪标识符<code>base</code> ，前提是<code>Secondary</code>是一个嵌套团队，它具有与<code>Primary</code>作为基类的playingBy绑定。这种情况是<a href="#s2.7.d" title="§2.7.(d) Implicit playedBy specialization" class="sect">下面</a>第二个例子的一部分<a href="#s2.7.d" title="§2.7。（d）隐式播放专业化" class="sect">（§2.7。（d））</a> （参见<code>T1 playedBy TB1</code> ）。
                     			
                  </p>
               </div>
               <div class="newpage"></div>
               <div class="subsect depth3" id="s2.7.d">
                  <h4 class="subsect">（d） <span class="title">隐性播放专业化</span><a class="img" href="s2.7.d.html" title="PermaLink to（d）隐式playBy专业化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>根据<a href="#s2.1.d" title="§2.1。（d）无差异" class="sect">§2.1。（d）</a>隐含的子角色可以<em>隐含地</em>专门化现有的<code>playedBy</code>关系。这需要相对于某些隐式（ <code>OuterTeam.this</code> ）或显式（ <code>OuterTeam.base</code> ）团队锚点指定基类。专门研究团队锚也会自动专门化playBy声明。此规则从不需要程序员的任何操作，但只解释了复杂情况下的playingBy声明的解释。
                     			
                  </p>
                  <h5>展示以上内容的两个高级示例是：</h5>
                  <table border="0">
                     <colgroup span="1">
                        <col align="left" span="1">
                        <col align="left" span="1">
                     </colgroup>
                     <tr>
                        <td rowspan="1" colspan="1">
                           <ul>
                              <li>如果是<code>TOuter1.的角色<code>TOuter1.<strong>嵌套团队</strong> <code>TOuter1. TR</code> <code>TOuter1.T</code>由外部封闭团队<code>TOuter1.另一个角色扮演<code>TOuter1.B</code> ，将外部团队<code>TOuter1</code>子类<code>TOuter1</code> <code>TOuter2</code>将产生一个新角色<code>TOuter2.TR</code>这是由自动播放<code>TOuter2.B</code> ，原始基类<code>TOuter1.的隐<code>TOuter1.类<code>TOuter1.13.6±2.2 b</li>
                           </ul>
                        </td>
                        <td rowspan="1" colspan="1"><img src="../images/implicitly_overriding_playedby.png" alt="隐含地压倒了玩家"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">
                           <ul>
                              <li>考虑将作为<code>TOuter</code>角色的<strong>嵌套</strong> <code>T1</code> <strong>堆叠</strong>在基础团队<code>TB1</code> 。此外， <code>T1</code>是<code>TB1</code>的<strong>分层团队</strong> ，因为其角色<code>R</code>适应角色<code>TB1.13.6±2.2 b<br>在这种情况下，playBy角色<code>TOuter.关系<code>TOuter.ŤR</code>由碱基锚<code>B&lt;@T1.base&gt;</code> 。如果进一步<code>TOuter.T1</code>被子类<code>TOuter.T2</code>将继承的playingBy声明共同细化为<code>TB2</code> ，然后是<code>TOuter.ŤR</code>将自动细化与<code>TB2.的继承的playingBy关系<code>TB2.B</code>遵循<code>base</code>锚的新解释。
                              </li>
                           </ul>
                        </td>
                        <td rowspan="1" colspan="1"><img src="../images/implicitly_overriding_playedby_base.png" alt="隐含地覆盖了playBy base"></td>
                     </tr>
                  </table>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s1.html" rel="prev">&lt;&lt;§1团队和角色</a></td>
               <td class="top"><a href="index.html" rel="contents">目录  </a></td>
               <td class="next"><a href="s3.html" rel="next">§3标注绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html>