<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>调试器教程</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="Tutorials.html" title="Tutorials"></link>
<link rel="prev" href="CodeGenerationTutorial.html" title="Code Generation tutorial"></link>
<link rel="next" href="ValidationTutorial.html" title="Validation tutorial"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">调试器教程</h1>
<div class="section" title="调试器教程">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="DebuggerTutorial"></a>调试器教程</h2>
</div>
</div>
</div>
<p>本教程已针对Eclipse Mars更新：Eclipse 4.5，EMF 2.11，OCL 6.0。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一些截图可能会略微过时。</p>
</li>
</ul>
</div>
<p>在本教程中，我们将继续<a class="link" href="Tutorials.html#OCLinEcoreTutorial" title="OCLinEcore教程">OCLinEcore教程</a>并演示如何使用<a class="link" href="Debugger.html" title="调试器（Luna中的新功能）">OCL调试器</a>进行调试：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在控制台视图中手动键入约束</p>
</li>
<li class="listitem">
<p>有效性视图中嵌入的OCLinEcore验证失败</p>
</li>
<li class="listitem">
<p>从Validity View中完成OCL验证失败</p>
</li>
</ul>
</div>
<div class="section" title="加载OCLinEcore教程示例项目">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadOCLinEcoreTutorialExampleProject2"></a>加载OCLinEcore教程示例项目</h3>
</div>
</div>
</div>
<p>本教程前两部分的材料作为OCLinEcore示例项目的一部分提供，您可以通过使用Project Explorer的右键上下文菜单选择<span class="bold"><strong>New，</strong></span>然后<span class="bold"><strong>示例</strong></span>来加载。这应该给出<span class="bold"><strong>New Example</strong></span>对话框，您可以在其中选择<span class="bold"><strong>OCL（OCL约束语言）插件</strong></span>和<span class="bold"><strong>OCLinEcore教程</strong></span> 。
				</p>
<p>本教程第三部分的材料作为CompleteOCL示例项目的一部分提供，您可以以类似的方式加载它。</p>
</div>
<div class="section" title="OCL调试器">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLDebugger"></a> OCL调试器</h3>
</div>
</div>
</div>
<p>OCL调试器是Eclipse调试器框架的自定义，因此它的大多数功能应该给熟悉Java调试器的人带来一些惊喜。</p>
<p>有：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>堆栈视图，显示嵌套评估环境中的当前行号</p>
</li>
<li class="listitem">
<p>变量视图，可以重新检查本地和中间变量</p>
</li>
<li class="listitem">
<p>一个编辑器，其中突出显示源以显示要评估的下一个AST节点</p>
</li>
<li class="listitem">
<p>一个大纲，其中源以树形式显示</p>
</li>
<li class="listitem">
<p>断点可以控制断点的视图</p>
</li>
</ul>
</div>
<p>我们将通过调试一个简单的例子来演示其中的一些功能。</p>
</div>
<div class="section" title="非常简单的调试会话">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="VerySimpleDebugsession"></a>非常简单的调试会话</h3>
</div>
</div>
</div>
<p>我们将在<span class="bold"><strong>EPackage</strong></span>上调试OCL表达式<span class="bold"><strong>self.name</strong></span>的执行。
				</p>
<div class="section" title="启动调试器">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Startingthedebugger"></a>启动调试器</h4>
</div>
</div>
</div>
<p>双击<span class="bold"><strong>model / Tutorial.ecore</strong></span>打开模型并展开顶部条目以显示EPackage。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-model.png"></div>
<p>
					
</p>
<p>如果模型使用其他编辑器打开，请将其关闭，然后使用Sample Ecore Editor打开，方法是选择<span class="bold"><strong>model / Tutorial.ecore</strong></span> ，然后从上下文菜单中选择<span class="bold"><strong>Open With-&gt; Sample Ecore Model Editor</strong></span> 。
					</p>
<p>从上下文菜单中选择<span class="bold"><strong>教程</strong></span> EPackage并调用<span class="bold"><strong>OCL-&gt; Show Xtext OCL Console</strong></span> 。（等一两秒。）
					</p>
<p>在控制台窗口的底部键入<span class="bold"><strong>self.name</strong></span> ，然后按Enter键。然后点击Page Up键重新显示您的条目。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-input.png"></div>
<p>
					
</p>
<p>控制台在按Enter键后自动运行评估并显示评估结果： <span class="bold"><strong>'tutorial'</strong></span> 。
					</p>
<p>控制台视图提供运行OCL调试器所需的两条信息：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一个EObject用作OCL的<span class="bold"><strong>自我</strong></span> ;控制台在其工具栏下方显示当前选择</p>
</li>
<li class="listitem">
<p>要执行的OCL表达式</p>
</li>
</ul>
</div>
<p>单击Console View工具栏中的debug图标启动调试器。（等一两秒。）</p>
<p>调试器透视图应自动出现。如果没有，您可以通过从Eclipse菜单栏调用<span class="bold"><strong>Window-&gt; Perspective-&gt; Open Perspective-&gt; Debug</strong></span>来手动打开Debug透视图。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-image.png"></div>
<p>
					
</p>
<p>将自动创建一个完整的OCL文档，以将OCL表达式封装在内部，作为<span class="bold"><strong>自身</strong></span>对象类型的附加操作。该文件显示在编辑器中;它是readonly。
					</p>
<p>堆栈显示在合成的完整OCL文档中将上下文显示为<span class="bold"><strong>oclDebugExpression（）</strong></span>的第5行。
					</p>
<p>在堆栈显示中选择<span class="bold"><strong>oclDebugExpression（）</strong></span>行; <span class="bold"><strong>self</strong></span>在Complete OCL文档中突出显示，因为要执行的下一个评估是评估执行自我访问的VariableExp AST节点。
					</p>
<p>变量视图显示两个变量。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="bold"><strong>self</strong></span>是OCL的自我对象</p>
</li>
<li class="listitem">
<p>
								
<span class="bold"><strong>$ pc</strong></span>是表示当前程序计数器的合成变量</p>
</li>
</ul>
</div>
<p>大纲视图显示略微修剪的OCL抽象语法树;您可以选择关闭此视图。在将来的版本中，它可能会更改为支持断点。视图显示</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><span class="bold"><strong>生态</strong></span>的<span class="bold"><strong>进口</strong></span> 
							
</p>
</li>
<li class="listitem">
<p>一个名为<span class="bold"><strong>EPackage</strong></span>的<span class="bold"><strong>类</strong></span>包含</p>
</li>
<li class="listitem">
<p>一个名为<span class="bold"><strong>oclDebugExpression</strong></span>的<span class="bold"><strong>操作</strong></span>包含</p>
</li>
<li class="listitem">
<p>一个<span class="bold"><strong>ExpressionInOCL，</strong></span>其<span class="bold"><strong>OwnedBody</strong></span>是一个<span class="bold"><strong>名为</strong></span> <span class="bold"><strong>PropertyCallExp</strong></span> ，其来源是</p>
</li>
<li class="listitem">
<p>一个<span class="bold"><strong>自己</strong></span>的<span class="bold"><strong>VariableExp</strong></span> 。
							</p>
</li>
</ul>
</div>
<p>大纲显示更全面的签名以帮助调试。</p>
</div>
<div class="section" title="探索变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExploringVariables"></a>探索变量</h4>
</div>
</div>
</div>
<p>“变量视图”提供了任意向下钻取以检查程序可用数据的功能。</p>
<p>显示的左列显示变量的名称，可以展开以导航到变量引用的数据部分。部件名称显示当前显示为0，而不是像OCL中那样基于1。</p>
<p>右列以各种方式显示可以展开的部件类型以及不能展开的部件的值。使用OCL语法，因此字符串出现在单引号中，而集合使用诸如OrderedSet之类的名称。</p>
<p>底线显示所选变量的文本呈现。对于许多类型的数据，可以使用有用的渲染。对于其他人，后备是默认的Java toString（）功能。文本可以自定义</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>如果对象实现<span class="bold"><strong>Labelable，则为</strong></span> <span class="bold"><strong>org.eclipse.ocl.pivot.utilities.getText（）</strong></span>方法
							
</p>
</li>
<li class="listitem">
<p><span class="bold"><strong>LabelUtil。如果<span class="bold"><strong>org.eclipse.ocl.pivot.label_generator</strong></span>扩展点具有对象类的注册，则为QUALIFIED_NAME_REGISTRY</strong></span></p>
</li>
</ul>
</div>
<p>单击<span class="bold"><strong>$ pc</strong></span>左侧的展开/折叠图标以展开它并允许检查OCL AST。接下来执行一个VariableExp，可以检查其<span class="bold"><strong>$ pc.referredProperty</strong></span>或<span class="bold"><strong>$ pc.type</strong></span>以查看更多程序详细信息。
					</p>
<p>单击<span class="bold"><strong>self</strong></span>左侧的展开/折叠图标，即<span class="bold"><strong>ecore :: EPackage</strong></span> ，展开它并显示其<span class="bold"><strong>名称</strong></span>为<span class="bold"><strong>'tutorial'的</strong></span>字段。
					</p>
<p>单击<span class="bold"><strong>self.eClassifiers</strong></span>左侧的展开/折叠图标以显示四个分类器。
					</p>
<p>选择<span class="bold"><strong>self.eClassifiers [1]</strong></span> ，使底行显示显示第二个名为Book。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-image.png"></div>
<p>
					
</p>
<p>变量视图提供了对样本生成器属性视图的更多洞察，因此您可能会发现使用<span class="bold"><strong>self</strong></span>作为OCL表达式来浏览任意模型数据时，使用简单的OCL调试器会话很方便。
					</p>
</div>
<div class="section" title="步进执行">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="SteppingExecution"></a>步进执行</h4>
</div>
</div>
</div>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span>图标以通过一个AST节点评估推进执行。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-step1.png"></div>
<p>
					
</p>
<p>编辑器现在突出显示<span class="bold"><strong>.name</strong></span> ; <span class="bold"><strong>$ pc</strong></span>显示一个PropertCallExp作为下一次执行。
						<span class="bold"><strong>$ pc.referredProperty</strong></span>显示它是<span class="bold"><strong>ecore :: ENamedElement：name</strong></span> 。
					</p>
<p>另一个合成变量<span class="bold"><strong>$ owwnedSource</strong></span>显示构成PropertyCallExp的源项的<span class="bold"><strong>自我</strong></span>评估的结果。正如所料，这与<span class="bold"><strong>自我</strong></span>相同。
					</p>
<p>再次单击F5或<span class="bold"><strong>Step Into</strong></span>图标以通过进一步的AST节点评估来提前执行。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-step2.png"></div>
<p>
					
</p>
<p>整个<span class="bold"><strong>self.name</strong></span>突出显示， <span class="bold"><strong>$ pc</strong></span>显示整个ExpressionInOCL即将被评估。其输入的合成<span class="bold"><strong>$ ownedBody</strong></span>显示<span class="bold"><strong>self.name被</strong></span>评估为<span class="bold"><strong>'tutorial'</strong></span> 。
					</p>
</div>
</div>
<div class="section" title="调试验证失败">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DebuggingaValidationfailure"></a>调试验证失败</h3>
</div>
</div>
</div>
<p>OCL对于使用其他格式良好的规则来详细说明是有用的，但是当这些规则失败时，很难理解为什么会发生故障，特别是如果bug在OCL而不是模型中。我们现在将展示如何使用OCL调试器来调试验证失败。</p>
<p>双击<span class="bold"><strong>model / Tutorial.xmi</strong></span>打开模型，然后展开前两个条目以显示一些细节。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-model.png"></div>
<p>
				
</p>
<p>如果模型使用其他编辑器打开，请将其关闭，然后使用Sample Reflective Ecore Model Editor打开，方法是选择<span class="bold"><strong>model / Tutorial.xmi</strong></span> ，然后从上下文菜单中选择<span class="bold"><strong>Open With-&gt; Sample Reflective Ecore Model Editor</strong></span> 。
				</p>
<p>选择第一行并从上下文菜单中调用<span class="bold"><strong>Validate</strong></span> 。（等一等。）（可选）单击“细节”
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-errors.png"></div>
<p>
				
</p>
<p>这些错误消息提供的精确度不足以真正理解问题，因此单击“ <span class="bold"><strong>确定”</strong></span>关闭弹出窗口，然后选择<span class="bold"><strong>“Book b2”</strong></span> ，这会出现错误，并调用<span class="bold"><strong>OCL-&gt;“显示有效性视图”</strong></span>以提供更多信息。
				</p>
<p>如果“有效性视图”显示问号而不是红色/绿色/琥珀色状态装饰，请单击“有效性视图”工具栏中的“运行”图标。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-vv1.png"></div>
<p>
				
</p>
<p>单击“有效性视图”工具栏中的“ <span class="bold"><strong>固定”</strong></span>图标，以避免在更改鼠标选择时发生颠簸。
				</p>
<p>取消选中Metamodel约束中的顶级<span class="bold"><strong>ecore</strong></span>行，因为我们对<span class="bold"><strong>教程</strong></span>元模型中的成功Ecore元模型约束不感兴趣。
				</p>
<p>同样取消选中Model Elements中的底部<span class="bold"><strong>教程</strong></span>行，因为我们对成功的元模型不感兴趣，只是对教程模型中的元模型感兴趣。
				</p>
<p>单击+工具栏图标以显示详细信息。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-vv2.png"></div>
<p>
				
</p>
<p>我们现在将调试<span class="bold"><strong>Library lib :: Book b2</strong></span>模型元素上的<span class="bold"><strong>tutorial :: Book :: SufficientCopies</strong></span>的失败。选择任一叶子警告，即左侧窗格中的<span class="bold"><strong>Book b2</strong></span>的<span class="bold"><strong>tutorial :: Book :: SufficientCopies</strong></span>子项，或右侧窗格中的<span class="bold"><strong>SufficientCopies</strong></span>的<span class="bold"><strong>Library lib :: Book b2</strong></span>子项，并调用<span class="bold"><strong>Debug Single Enabled选择</strong></span> 。等一两秒钟，调试器启动。如果没有，请手动打开Debugger透视图。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-image.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>oclDebuggerExpression（）</strong></span>堆栈行。调试器显示<span class="bold"><strong>library.loans-&gt; select（（book = self）） - &gt; size（）&lt;=副本，</strong></span>其中<span class="bold"><strong>l</strong></span>突出显示为下一次执行。大纲表明， <span class="bold"><strong>自我</strong></span> <span class="bold"><strong>VariableExp</strong></span>是接下来要执行。源代码中的<span class="bold"><strong>库</strong></span>是<span class="bold"><strong>self.library</strong></span>的简写，因此突出显示<span class="bold"><strong>l</strong></span>是突出显示不可见<span class="bold"><strong>源</strong></span>的近似值<span class="bold"><strong>。</strong></span>在<span class="bold"><strong>图书馆</strong></span>前。

					变量视图中的<span class="bold"><strong>$ pc</strong></span>也显示自己的VariableExp作为下一条指令。
				</p>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span> ， <span class="bold"><strong>$ pc</strong></span>前进，编辑器突出显示对<span class="bold"><strong>库的</strong></span>更改。
				</p>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span>几次，突出显示将显示<span class="bold"><strong>选择</strong></span>主体内的迭代，允许检查每个元素的每个状态以确定展示行为发生的原因。
				</p>
<p>继续单击F5或<span class="bold"><strong>Step Into</strong></span>直到<span class="bold"><strong>- &gt; size（）</strong></span>突出显示。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-step1.png"></div>
<p>
				
</p>
<p>在变量视图中展开<span class="bold"><strong>$ ownedSource</strong></span>显示了三个选定贷款的集合，每个贷款与自己具有相同的图书。
				</p>单击F5或<span class="bold"><strong>Step Into</strong></span>三次，直到<span class="bold"><strong>&lt;=</strong></span>突出显示。
				<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-step2.png"></div>
<p>
				
</p>
<p>我们现在可以看到比较的<span class="bold"><strong>$ ownedSource</strong></span> （左侧）是3而<span class="bold"><strong>$ ownedArguments [0]</strong></span>右侧是2。进一步的步骤，我们看到结果为<span class="bold"><strong>$ ownedBody</strong></span>演示验证失败的原因。
				</p>
</div>
<div class="section" title="调试完成OCL验证失败">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DebuggingCompleteOCLvalidationfailure"></a>调试完成OCL验证失败</h3>
</div>
</div>
</div>
<p>前两个示例在合成的完整OCL文档中显示其源文本。</p>
<p>在此示例中，我们调试OCL已在完整OCL文档中可用的故障。</p>
<p>使用Sample Ecore Editor从<a class="link" href="CompleteOCLTutorial.html" title="完成OCL教程">Complete OCL教程</a>项目打开<span class="bold"><strong>模型/ EcoreTestFile.ecore</strong></span> 。
				</p>
<p>在Ecore编辑器中使用<span class="bold"><strong>OCL-&gt; Load Document</strong></span>然后拖放<span class="bold"><strong>model / ExtraEcoreValidation.ocl</strong></span>并单击<span class="bold"><strong>OK</strong></span>关闭弹出窗口。
				</p>
<p>再次在Ecore编辑器中使用<span class="bold"><strong>OCL-&gt;显示有效性视图</strong></span>来查看约束/元素对。
					<span class="italic">如果有效视图已经可见，请将其关闭并重新显示，因为在Mars中添加完整的OCL文档无法正确刷新。</span>
				
</p>
<p>在Validity View中，取消选中仅保留<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>贡献的<span class="bold"><strong>ecore</strong></span> Metamodel Constraint贡献。单击<span class="bold"><strong>Metamodel Constraint</strong></span>工具栏中的加号图标以展开所有条目。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-complete-ocl-debugger-model.png"></div>
<p>
				
</p>
<p>在<span class="bold"><strong>DerivationIsVolatile</strong></span>约束下面选择右下角的<span class="bold"><strong>BadClass</strong></span>模型元素，并调用<span class="bold"><strong>Debug Single Enabled Selection</strong></span> 。从上下文菜单（等待一两秒）。如果没有手动打开Debugger透视图，调试器应该启动。
				</p>
<p>
					
<span class="italic">在Mars中，选择<span class="bold"><strong>DerivationIsVolatile</strong></span>堆栈行以刷新选择。
					</span>
				
</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-complete-ocl-debugger-image.png"></div>
<p>
				
</p>
<p><span class="bold"><strong>asError</strong></span>和<span class="bold"><strong>hasDerivation</strong></span>都是OCL定义的，因此当您逐步导航到已定义的属性和操作时。
				</p>
</div>
<div class="section" title="控制台实验">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Consoleexperiments"></a>控制台实验</h3>
</div>
</div>
</div>
<p>在调试时，Console中的原始OCL表达式将显示在完整的OCL编辑器中。此编辑器是只读的，因此您无法对其进行编辑以纠正错误或进行实验。</p>
<p>但是，您可以安全地使用OCL控制台执行进一步的实验。在“变量视图”中选择合适的自身对象，然后剪切并粘贴以准备实验性OCL表达式。</p>
<p>
					
<span class="italic">在Mars中，控制台选择不能是集合，因此您不幸地被限制为单个对象。</span>
				
</p>
</div>
<div class="section" title="更长距离的踩踏">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Longerrangestepping"></a>更长距离的踩踏</h3>
</div>
</div>
</div>
<p>在上面的例子中，我们只使用了F5或<span class="bold"><strong>Step Into</strong></span> 。
				</p>
<p>原则上，可以通过F7或<span class="bold"><strong>Step Return</strong></span>来避免繁琐的迭代<span class="bold"><strong>步骤</strong></span> ，这应该在迭代结束时在弹出的评估环境中终止。
					<span class="italic">该设施尚未在火星上进行过充分测试</span> 。
				</p>
<p>如果您在源文本中安排了一些换行符，则可以使用F6或<span class="bold"><strong>Step Next</strong></span>继续操作，直到行号前进。
					<span class="italic">该设施尚未在火星上进行过充分测试</span> 。可以使用Shift和Enter一起在OCL控制台中添加换行符。
				</p>
</div>
<div class="section" title="断点">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Breakpoints"></a>断点</h3>
</div>
</div>
</div>
<p>从完整OCL文档调试OCL时，原始文档是调试器的合适来源，因此可以设置行断点。
					<span class="italic">该设施尚未在火星上进行过充分测试</span>
				
</p>
</div>
</div>
</body>
</html>