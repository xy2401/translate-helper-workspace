<html dir="ltr">
<head>
    <link rel="stylesheet" type="text/css" href="../css/style.css"></link>
    <link rel="stylesheet" type="text/css" href="../css/nn.css"></link>
	<title>OTDT 2.3  - 新的和值得注意的</title>
</head>
<script language="JavaScript">
	// web: var OTJLD_BASE = "http://www.objectteams.org/def/1.3.1"; //"../otjld/def"
	// help:
	var OTJLD_BASE = "../otjld/def"
	var HELP_ROOT = "http://help.eclipse.org/luna/topic" // only if not already replaced
  	function replaceROOTS() {
  		var baseURLskip = document.URL.lastIndexOf("/");
    	var anchors = document.getElementsByTagName("a");
    	for (i = 0; i < anchors.length; i++) {
      		var item = anchors[i];
      		var relref = item.href.substring(baseURLskip+1)
      		if (relref.indexOf("OTJLD") == 0) {
  				item.href = relref.replace("OTJLD", OTJLD_BASE);
      		} else if (relref.indexOf("PLUGINS_ROOT") == 0) {
      			item.href = relref.replace("PLUGINS_ROOT", HELP_ROOT);
      		}
    	}
  	}
</script>
<body dir="ltr" onload="replaceROOTS();">
<h1>OTDT 2.3  - 新的和值得注意的</h1>
<div class="navigation">在此页面上： <!--a href="#metrics">&bull; Metrics Plug-in</a--> <!--a href="#configuration">&bull; Configuration</a--> <!--a href="#views">&bull; Views/Dialogs</a--> <!--a href="#assist">&bull; Content Assist</a--> <!--a href="#refactor">&bull; Refactoring</a--> <!--a href="#formatting">&bull; Formatting</a--> <!--a href="#debug">&bull; Run/Debug</a--> <a href="#language">•语言</a> <!--a href="#api">&bull; API</a--> <!--a href="#compiler">&bull; Compiler</a--> <a href="#otre">•运行时</a> <a href="#otequinox">•OT / Equinox</a> <!--a href="#releng">&bull; Release Engineering</a-->  
</div>
<table cellpadding="10" cellspacing="0" width="100%">
  <colgroup>
  <col width="20%">
  <col width="80%">
  </colgroup>
  <tbody>
<td><!--
  <tr><td colspan="2" id="NAME"><h2>HEADING</h2></td></tr>
  <tr>
    <td><p align="right"><b>DESC</b><br>
        <span class="since">since&nbsp;0.7.1</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/308029">308029</a></p></td>
    <td><p>
    		
    	</p>
    	<p><img alt="TEXT" src="../images/screenshots/NN07/.png"></p>
    	<p></p>
    </td>
  </tr>
  <div class="listbox"><div class="listing"><pre><code class="keyword">public team class</code> <font color="blue">MyTeam</font> {
}</pre></div></div>
-->
  <tr></tr></td><td colspan="2" id="language"><h2>语言</h2></td>
  <tr>
    <td id="java8"><a href="PLUGINS_ROOT/org.eclipse.jdt.doc.user/whatsNew/jdt_whatsnew.html#JavaCompiler"><img align="right" src="../../images/java8.png"></a><br>
    	<p align="right"><b>采用Java 8</b><br>
    	 <br>
        <!--span class="since">since&nbsp;2.3</span><br--> <a class="buglink" title="[java8]从JDT的BETA_JAVA8分支采用并合并Java 8的实现" href="https://bugs.eclipse.org/384991" target="_blank">384991</a></p></td>
    <td>
    	<div style="background-color:#fffce4;padding:4px;border:solid 2px #e0e0f0;color:#300080"><strong>OT / J已与Java™8完全集成。</strong><br>这意味着lambda表达式，方法引用，默认方法，类型注释等都可以在OT / J程序中使用。此外，OT / J中的角色可以绑定到包含任何这些新功能的Java 8类。
		</div>
		<h3>语法挑战</h3>
		<p>从语法上讲，Java 8中的一些新功能看起来与OT / J类似：</p>
		<ul>
		<li>用于lambda表达式的箭头“ <code>-&gt;</code> ”与OT / J用于<a class="otjldlink" href="OTJLD/s3.html">标注绑定</a>和<a class="otjldlink" href="OTJLD/s3.html#s3.2">角色到基础参数映射的</a>标记相同（另请参见<a class="otjldlink" href="OTJLD/s4.html#s4.4">4.4</a> ）。</li>
		<li>用于类型注释的“ <code>@</code> ”标记（JSR 308）与OT / J用于表示<a class="otjldlink" href="OTJLD/s1.html#s1.2.2.b">团队锚点的</a>标记相同</li>
		</ul>
		<h3>清洁整合</h3>		
		<p>尽管存在这些语法上的相似性，但为了与Java 8的语法协调，没有必要更改OT / J.因此，最小的，不可避免的限制（“团队”和“内部”是OT / J中的无条件关键字）每个合法的Java 8程序也是合法的OT / J程序。相反，早期版本的每个合法OT / J程序仍然是合法的OT / J程序。
		</p>
		<h3>功能互动</h3>
		<p>在大多数情况下，Java 8中的新功能可以被视为与OT / J引入的功能正交：</p>
		<ul>
		<li>Java 8中的Lambda表达式是关于实现算法的细节</li>
		<li>Java 8中的类型注释是关于改进类型系统的</li>
		<li>OT / J中的角色和团队是关于将单个对象组合到系统中</li>
		</ul> 
		<p>关于<strong>类型检查</strong> ，以下特性需要在幕后进行重要工作以协调各种类型规则：具有增强型类型推断的泛型，类型注释以及最终：角色类型，所有这些都有助于形成非常丰富的类型概念。鉴于Eclipse Compiler for Java中的类型推断已经完全重写，采用OT / J的重写需要对该实现有深入的了解。</p>
		<p>由于引入了默认方法， <strong>继承</strong>现在有更多选项。这与OT / J的<a href="OTJLD/s1.html#s1.3.1">隐式继承</a>相结合提出了新的挑战，其中一些细节可能在2.3版本之后仍需要更多的工作。从技术上讲，OT / J现在支持两种不同风格的多重继承，但从细节来看，很明显这两个概念都追求完全不同的目标。预计这些概念不会竞争解决任何现实世界的设计任务。
			</p>
    </td>
  </tr>

  <tr><td colspan="2" id="otre"><h2>对象团队运行时环境</h2></td></tr>
  <tr>
    <td><p align="right"><b>新的字节码编织器</b><br>
         <br>
        <a class="buglink" title="支持运行时编织" href="https://bugs.eclipse.org/398232" target="_blank">398232</a></p></td>
    <td><p>从2.3开始，OTDT附带一个新的字节码编织器作为传统<a href="PLUGINS_ROOT/org.eclipse.objectteams.otdt.doc/guide/features.html#execution">OTRE</a>的替代品。</p>
    	<p>这个称为“ <strong>对象团队动态运行时环境（OTDRE）</strong> ”的<strong>编织器的</strong>开发目的是支持<strong>运行时编织</strong> ，即支持在应用程序启动期间未知的角色和团队的集成。此功能已完全实现，但仍需要开发充分利用新灵活性的基础架构（例如，允许运行时部署新监控团队类的监控控制台）。</p>
    	<p>OTDRE使用字节码库<strong>ASM实现</strong> ，而不是基于BCEL的OTRE实现。 ASM采用更现代的方法，可以提高织造性能。ASM也得到积极维护，遗憾的是，BCEL不再适用。</p>
    </td></tr>
  <tr>
  <td class="noborder"><a href="#java8"><img align="right" src="../../images/java8.png"></a></td>
  <td class="noborder"><p>通过使用最新版本的ASM，OTDRE能够处理甚至<strong>Java 8的</strong>类文件，这是使用BCEL无法实现的。因此，OTDRE的具体目标是支持Java 8，尽管它还没有达到OTRE多年来获得的成熟度。</p>
    	<p>编织器支持两种编织器，通过生成要从编织代码调用的特定基础结构。由于<strong>编织方案</strong>的根本区别，有必要在编译时选择，编织者应该作为目标。请参阅开发人员指南中有关<a href="../weavingscheme.html">目标编织方案</a>的部分。</p>
    </td>
  </tr>

  <tr><td colspan="2" id="otequinox"><h2>OT /春分</h2></td></tr>
  <tr>
    <td><p align="right"><b>迁移到新的Equinox实施</b><br>
        <span class="since">从2.3M2开始</span><br>
        <a class="buglink" title="将OT / Equinox迁移到标准的OSGi WeavingHook" href="https://bugs.eclipse.org/406518" target="_blank">406518</a></p></td>
    <td><h3>大多数兼容的重新实现</h3>
    	<p>OT / Equinox的实现已被重写，当Equinox撤销了一个名为“Adapter Hooks”的“非官方API”时，这是必要的，OT / Equinox已经依赖它多年。</p>
    	<p>在表面上，OT / Equinox技术的常规客户几乎看不到这种情况;支持现有的扩展点<a href="PLUGINS_ROOT/org.eclipse.objectteams.otdt.doc/reference/extension-points/org_eclipse_objectteams_otequinox_aspectBindings.html"><code>aspectBindings</code></a>不变。</p>
    	<p>单个表面更改考虑了如何建立基类和适应团队之间的可见性：在新实现中，每个方面包必须<strong>导出包含一个或多个团队类的所有包</strong> 。这是一项硬性要求，缺少的导出将被标记为错误。提供了一个新的<strong><a href="#qfAddExport">快速修复程序</a></strong>来支持此任务。</p>
    	<h3>目前的局限</h3>
    	<p>OT / Equinox的一些附加功能目前尚未实现，并计划在Luna服务版本中重新添加：</p>
    	<ul>
    	<li><a href="PLUGINS_ROOT/org.eclipse.objectteams.otdt.doc/reference/extension-points/org_eclipse_objectteams_otequinox_aspectBindings.html#e.forcedExports">强迫出口</a></li>
    	<li><a href="PLUGINS_ROOT/org.eclipse.objectteams.otdt.doc/reference/extension-points/org_eclipse_objectteams_otequinox_liftingParticipant.html">提升参与者</a>
    	</li><li><a href="PLUGINS_ROOT/org.eclipse.objectteams.otdt.doc/reference/extension-points/org_eclipse_objectteams_otequinox_aspectBindingNegotiators.html">Aspect Binding Negotiation</a>
    	</li></ul>
    	<h3>细节</h3>
    	<p>以前，我们已经建议可以通过从文件<code>configuration/config.ini</code>删除特定行来<strong>禁用</strong> OT / Equinox。这条线不再存在。相反，现在可以使用以下Java属性禁用OT / Equinox：</p>
    	<pre>-Dot.equinox = FALSE</pre>
    	<p>Equinox <strong>延迟加载时</strong> ，新的实现也可以更好地发挥作用：之前，只要受影响的基本<em>包</em>被激活，就会触发团队的加载和激活。鉴于团队加载/激活可以反过来触发其他捆绑加载/激活，在系统启动期间可以观察到很多加载活动，这不是绝对必要的。新实现等待直到实际访问受影响的基<em>类</em> ，这是激活相应团队的最新可能点。结果，可以显着减少对装载顺序的影响。</p>
    	<h3>可移植性</h3>
    	<p>新实现不再依赖于“非官方API”，而是依赖于OSGi标准<strong>WeavingHook</strong> 。这样，OT / Equinox的基本功能实际上也适用于其他OSGi容器。当然，使用扩展点来声明团队被激活仍然取决于Equinox，但这是一个很好的孤立的问题，并将其移植到任何其他配置方式应该是直截了当的。</p>
    	<h3>可视化不变</h3>
		<p>作为兼容性的（部分）证明，现有的<strong>OT / Equinox Monitor</strong>视图在新实现之上工作，而不需要更改单行代码。</p>
			<img src="../images/screenshots/otequinoxMonitor.png" width="519" alt="OT / Equinox Montitor视图">
		<p>事实上，这个视图可以用来观察OT / Equinox在两个方面的不影响：</p>
		<ul>
		<li>尚未知道/显示其基类尚未加载的团队。要查看突出显示的BrandingAdaptor，需要打开“ <code class="UI">Help &gt; Installation Details &gt; Plug-ins</code>对话框</li>
		<li>适应已被垃圾收集的基本实例的角色实例也将从内存中删除，因此不再显示在监视器视图中（参见“＃roles”列中的多个零）。</li>
		</ul>
    </td>
  </tr>
  <tr>
    <td id="qfAddExport"><p align="right"><b>快速修复以添加方面导出</b><br>
        <span class="since">从2.3M2开始</span><br>
        <a class="buglink" title="将OT / Equinox迁移到标准的OSGi WeavingHook" href="https://bugs.eclipse.org/406518#c37" target="_blank">406518＃C37</a></p></td>
    <td><p>OT / Equinox的新实现需要导出包含团队的所有包（参见上文）。如果缺少此导出，则会针对插件的清单标记错误，并提供快速修复以便以推荐格式添加所需的导出。
    	</p>
    	<a href="../images/screenshots/NN23/QFAddAspectExport.png"><img src="../images/screenshots/NN23/QFAddAspectExport.png" width="519" alt="快速修复以添加所需的方面导出"></a>
    	<p>应用快速修复会产生以下结果：</p>
    	<a href="../images/screenshots/NN23/QFAddAspectExport1.png"><img src="../images/screenshots/NN23/QFAddAspectExport1.png" width="519" alt="快速修复的结果"></a>
    	<p>屏幕截图显示了一个包导出，其中包含<em>推荐的</em>属性<code>ot-aspect-host</code> ，它将导出标记为仅用于让编织代码调用到团队中。此外，此属性的值标识声明方面包，即使在拆分包的情况下，它也在内部用于唯一标识此包。
   		</p>
    	<p>最后，导出可以使用<code>x-internal</code>或<code>x-friends</code>来防止意外使用此包。
    	</p>
    	<p>一旦我们重新实施Forced Exports概念（见上文），我们可能会考虑删除导出包含团队的所有包的附加要求。
   		</p>    
  	</td>
  </tr>
  	
<td><!--

  <tr><td colspan="2" id="debug"><h2>Run / Debug</h2></td></tr>
  <tr>
    <td><p align="right"><b>HEADING</b><br>
        <span class="since">since&nbsp;2.1M6</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/301314">301314</a></p></td>
    <td><p>PARA</p>
    </td>
  </tr>

  <tr><td colspan="2" id="api"><h2>API</h2></td></tr>
  <tr>
    <td><p align="right"><b>HEADING</b><br>
        <span class="since">since&nbsp;2.1M6</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/301314">301314</a></p></td>
    <td><p>PARA</p>
    </td>
  </tr>

  <tr><td colspan="2" id="compiler"><h2>Compiler</h2></td></tr>
  <tr>
    <td><p align="right"><b>HEADING</b><br>
        <span class="since">since&nbsp;2.1M6</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/301314">301314</a></p></td>
    <td><p>PARA</p>
    </td>
  </tr>

 
  <tr><td colspan="2" id="releng"><h2>Release Engineering</h2></td></tr>
  <tr>
    <td><p align="right"><b>HEADING</b><br>
        <span class="since">since&nbsp;2.1M6</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/301314">301314</a></p></td>
    <td><p>PARA</p>
    </td>
  </tr>
-->  
</td></tbody></table>
</body>