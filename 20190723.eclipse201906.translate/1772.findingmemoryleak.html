<html lang="en-us"  xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="Finding Memory Leak">
<meta name="abstract" content="">
<meta name="description" content="">
<meta name="DC.Relation" scheme="URI" content="../reference/querymatrix.html">
<meta name="copyright" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html ">
<meta name="DC.Rights.Owner" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html ">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="ref_findingmemoryleak">
<meta name="DC.Language" content="en-us">
<link rel="stylesheet" type="text/css" href="../styles/commonltr.css">
<title>发现内存泄漏</title>
</head>
<body id="ref_findingmemoryleak" >


	<h1 class="title topictitle1">发现内存泄漏</h1>

	

	


	<div class="body refbody"><p class="shortdesc"></p>

		<div class="section">
			<p class="p">事实证明，以下4步方法可以最有效地检测内存问题：</p>

			<ol class="ol">
				<li class="li">获取堆转储的概述。请参阅： <em class="ph i">概述</em>
				</li>

				<li class="li">查找大内存块（单个对象或对象组）。
				</li>

				<li class="li">检查此内存块的内容。</li>

				<li class="li">如果内存块的内容太大，请检查谁将此内存块保持活动状态</li>

			</ol>

			<p class="p">“ <a class="xref" href="../tasks/runningleaksuspectreport.html">泄漏嫌疑人报告”</a>在Memory Analyzer中自动执行这一系列操作。
			</p>

			<p class="p">下表包含最有助于分析内存泄漏问题的查询列表。
			</p>

			<table cellpadding="4" cellspacing="0" id="ref_findingmemoryleak__findingmemoryleak" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="40%">支配树</td>

					<td valign="top" class="stentry" width="60%">在Dominator Tree中，每个节点都有责任让孩子保持活力。树按保留的大小排序，因此您可以轻松找到单个大对象。当没有单个对象负责大内存消耗时，按类和类加载器对结果进行分组以显示大内存块是有帮助的。
					</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">顶级消费者</td>

					<td valign="top" class="stentry">Top Consumers查询返回有关按类，类加载器和包分组的最大对象的信息。
					</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">GC根的路径</td>

					<td valign="top" class="stentry">GC Roots查询的路径有助于识别谁负责将单个对象保留在堆中。合理地在可能的可疑（内存累积点）上运行此查询，您可以找到它，例如使用Dominator Tree Query中的Big Drops（有关更多详细信息，请参阅<em class="ph i">Big Drop</em>条目）。
					</td>

				</tr>
<tr class="strow">
				    <td valign="top" class="stentry">重复的类</td>

					<td valign="top" class="stentry">列出多次加载的类。通过类加载器对结果进行分组指向多次加载相同类的类加载器。可能的原因：部署了同一个库的多个版本。
					</td>

				</tr>
<tr class="strow">
				    <td valign="top" class="stentry">支配树查询中的大丢弃</td>

					<td valign="top" class="stentry">显示支配树中的内存累积点。显示的是父项和子项的保留大小和累积点的第一个“有趣”支配者之间有很大差异的对象。这些是许多小对象的记忆在一个对象下累积的地方。
					</td>

				</tr>
<tr class="strow">
				    <td valign="top" class="stentry">泄密嫌疑人报告</td>

					<td valign="top" class="stentry">Leak Suspects查询分析堆转储，搜索内存泄漏并提供已识别嫌疑人的说明性描述。
					</td>

				</tr>
</table>

		</div>

	</div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a class="link" href="../reference/querymatrix.html" title="没有精确的内存分析算法。下表按使用类别划分现有堆转储查询。">查询矩阵</a></div>
</div>
</div>

</body>
</html>