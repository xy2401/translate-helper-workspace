<html dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><title>Xpand文档</title><link href="book.css" rel="stylesheet" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta></head><body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Xpand文档"><div class="titlepage"><div><div><h1 class="title"><a name="xpand_documentation"></a> Xpand文档</h1></div></div><hr></div><div class="chapter" title="Chapter 9. 入门"><div class="titlepage"><div><div><h2 class="title">Chapter 9. 入门</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#emf_tutorial_installing">Xpand安装程序</a></span></dt><dt><span class="section"><a href="#emf_tutorial_overview">教程概述</a></span></dt><dt><span class="section"><a href="#emf_tutorial_define_metamodel">定义EMF元模型</a></span></dt><dd><dl><dt><span class="section"><a href="#emf_tutorial_creating_emf_project">创建EMF项目</a></span></dt><dt><span class="section"><a href="#emf_tutorial_defining_metamodel">定义（meta）模型</a></span></dt></dl></dd><dt><span class="section"><a href="#emf_tutorial_generate_emf_tooling">生成EMF工具</a></span></dt><dt><span class="section"><a href="#emf_tutorial_setting_generator_project">设置发电机项目</a></span></dt><dt><span class="section"><a href="#emf_tutorial_defining_sample_model">定义示例数据模型</a></span></dt><dt><span class="section"><a href="#emf_tutorial_dynamic_emf">使用动态EMF</a></span></dt><dt><span class="section"><a href="#emf_tutorial_generating_code">从示例模型生成代码</a></span></dt><dd><dl><dt><span class="section"><a href="#emf_tutorial_the_workflow_definition">工作流程定义</a></span></dt><dt><span class="section"><a href="#emf_tutorial_running_the_workflow">运行工作流程</a></span></dt><dt><span class="section"><a href="#emf_tutorial_templates">模板</a></span></dt><dt><span class="section"><a href="#emf_tutorial_running_the_generator_again">再次运行发电机</a></span></dt></dl></dd><dt><span class="section"><a href="#emf_tutorial_checking_contraints_with_check">用<span class="emphasis"><em>检查</em></span>语言检查约束</a></span></dt><dd><dl><dt><span class="section"><a href="#emf_tutorial_defining_the_constraint">定义约束</a></span></dt><dt><span class="section"><a href="#emf_tutorial_integration_into_the_workflow_file">集成到工作流文件中</a></span></dt></dl></dd><dt><span class="section"><a href="#emf_tutorial_extensions">扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#emf_tutorial_expression_extensions">表达式扩展</a></span></dt><dt><span class="section"><a href="#emf_tutorial_java_extensions">Java扩展</a></span></dt></dl></dd></dl></div><p>此示例使用Eclipse EMF <a name="N1000D" class="indexterm"></a>作为代码生成的基础。大量可用的第三方工具使EMF成为良好的基础。具体来说，已经有更好的构建EMF元模型的工具（Xtext，GMF等）。为了更深入地了解EMF，我们建议您先阅读EMF教程</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://www-128.ibm.com/developerworks/library/os-ecemf1/" target="_new">http://www-128.ibm.com/developerworks/library/os-ecemf1/</a></p></li><li class="listitem"><p><a class="ulink" href="http://www-128.ibm.com/developerworks/library/os-ecemf2/" target="_new">http://www-128.ibm.com/developerworks/library/os-ecemf2/</a></p></li><li class="listitem"><p><a class="ulink" href="http://www-128.ibm.com/developerworks/library/os-ecemf3/" target="_new">http://www-128.ibm.com/developerworks/library/os-ecemf3/</a></p></li></ul></div><p>您也可以在不完全了解EMF的情况下运行本教程，但教程可能看起来不必要地复杂。</p><div class="section" title="Xpand安装程序"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_installing"></a> Xpand安装程序</h2></div></div></div><p>在您完成本教程并执行示例之前，您需要安装Xpand。有关详细信息，请考虑<a class="ulink" href="http://www.eclipse.org/modeling/m2t/downloads/?project=xpand" target="_new">http://www.eclipse.org/modeling/m2t/downloads/?project=xpand</a> 。</p></div><div class="section" title="教程概述"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_overview"></a>教程概述</h2></div></div></div><p>本教程的目的是说明使用Xpand从EMF模型生成代码。我们要经历的过程将首先定义元模型（使用EMF工具），提供一些示例数据，编写代码生成模板，运行生成器以及最后添加一些约束检查。</p><p>该示例的实际内容相当简单 - 我们将遵循JavaBean约定生成Java类。该模型将包含实体（例如<span class="type">人</span>或<span class="type">车辆</span> ），包括一些属性和它们之间的关系 - 一个相当典型的数据模型。从模型中的这些实体，我们希望生成用于在Java中实现的Bean。在实际环境中，我们可能还想生成持久性映射等。对于这个简单的介绍，我们不会这样做。</p></div><div class="section" title="定义EMF元模型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_define_metamodel"></a>定义EMF元模型</h2></div></div></div><p>为了说明元模型，在我们处理EMF的复杂性之前，这里是UML中的元模型：</p><div class="figure"><a name="emf_tutorial_sample_metamodel"></a><p class="title"><b>图1。示例元模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/metamodel.gif" alt="示例元模型"></div></div></div><p><br class="figure-break"></p><div class="section" title="创建EMF项目"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_creating_emf_project"></a>创建EMF项目</h3></div></div></div><p>创建一个EMF项目，如下所示：</p><div class="figure"><a name="emf_tutorial_create_emf_project"></a><p class="title"><b>图2。创建EMF项目</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_emf_project.png" alt="创建EMF项目"></div></div></div><br class="figure-break"><p>创建EMF项目非常重要，而不仅仅是简单项目或Java项目。将其命名为<code class="filename">xpand.demo.emf.datamodel</code> 。</p></div><div class="section" title="定义（meta）模型"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_defining_metamodel"></a>定义（meta）模型</h3></div></div></div><p>在该项目中创建一个新的源文件夹<code class="filename">metamodel</code> 。然后，在名为<code class="filename">data.ecore</code>源文件夹中创建一个新的Ecore模型。使用<span class="type">EPackage</span>作为模型对象。</p><div class="figure"><a name="emf_tutorial_create_ecore_model"></a><p class="title"><b>图3。创建新的Ecore模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_model.png" alt="创建新的Ecore模型"></div></div></div><p><br class="figure-break">这将打开Ecore编辑器。您将看到名为<code class="varname">null</code>的根包。打开“属性视图”（上下文菜单）。为包设置以下属性：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>名称：数据</p></li><li class="listitem"><p>Ns前缀：数据</p></li><li class="listitem"><p>Ns URI：http：//www.xpand.org/xpand.demo.emf.datamodel</p></li></ul></div><p> </p><div class="figure"><a name="emf_tutorial_adjust_namespace_settings"></a><p class="title"><b>图4。调整命名空间设置</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_model_adjust_namespace.png" alt="调整命名空间设置"></div></div></div><p><br class="figure-break"></p><p>创建以下Ecore模型。 <sup>[ <a href="#ftn.N100A4" name="N100A4" class="footnote">1</a> ]</sup>确保<span class="emphasis"><em>完全</em></span>按照下面的描述设置以下属性：</p><p>在<span class="package">数据</span>包中，使用它们的属性创建这些<code class="classname">EClass</code>元素： <sup>[ <a href="#ftn.N100B6" name="N100B6" class="footnote">2</a> ]</sup></p><div class="informaltable"><a name="emf_tutorial_metamodel_attributes"></a><table border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">EClass名称</th><th align="left">EAttribute名称</th><th align="left">EAttribute EType</th></tr></thead><tbody><tr><td align="left">的DataModel</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">名称</td><td align="left">为EString</td></tr><tr><td align="left">实体</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">名称</td><td align="left">为EString</td></tr><tr><td align="left">属性</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">名称</td><td align="left">为EString</td></tr><tr><td align="left"> </td><td align="left">类型</td><td align="left">为EString</td></tr><tr><td align="left">的EntityReference</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">名称</td><td align="left">为EString</td></tr><tr><td align="left"> </td><td align="left">太多</td><td align="left">EBoolean</td></tr></tbody></table></div><p>现在，是时候在模型元素之间创建引用了。添加<code class="classname">EReferences</code>类型的子<code class="classname">EReferences</code>如下： <sup>[ <a href="#ftn.N1010E" name="N1010E" class="footnote">3</a> ]</sup></p><div class="informaltable"><a name="emf_tutorial_metamodel_references"></a><table width="100%" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">的EClass</th><th align="left">EReference名称</th><th align="left">EReference属性名称</th><th align="left">EReference属性值</th></tr></thead><tbody><tr><td align="left">的DataModel</td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">实体</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">ETYPE</td><td align="left">实体</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">遏制</td><td align="left">真正</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">下界</td><td align="left">0</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">UPPERBOUND</td><td align="left">-1</td></tr><tr><td align="left">实体</td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">属性</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">ETYPE</td><td align="left">属性</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">遏制</td><td align="left">真正</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">下界</td><td align="left">1</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">UPPERBOUND</td><td align="left">-1</td></tr><tr><td align="left">实体</td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">参考</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">ETYPE</td><td align="left">的EntityReference</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">遏制</td><td align="left">真正</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">下界</td><td align="left">0</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">UPPERBOUND</td><td align="left">-1</td></tr><tr><td align="left">的EntityReference</td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left">目标</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">ETYPE</td><td align="left">实体</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">遏制</td><td align="left">假</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">下界</td><td align="left">1</td></tr><tr><td align="left"> </td><td align="left"> </td><td align="left">UPPERBOUND</td><td align="left">1</td></tr></tbody></table></div><div class="figure"><a name="emf_tutorial_metamodel_structure"></a><p class="title"><b>图5。元模型结构</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_model_mm_structure.png" alt="元模型结构"></div></div></div><p><br class="figure-break"></p><p>EMF将我们在上面创建的模型保存在自己的XMI方言中<a name="N101D9" class="indexterm"></a> 。为避免任何歧义，这里是元模型的完整XMI源。它进入文件<code class="filename">data.ecore</code> ：</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;ecore：EPackage xmi：version =“2.0”xmlns：xmi =“http://www.omg.org/XMI”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance” xmlns：ecore =“http://www.eclipse.org/emf/2002/Ecore”name =“data”nsURI =“http://www.xpand.org/xpand.demo.emf.datamodel”nsPrefix =“ data“&gt; &lt;eClassifiers xsi：type =”ecore：EClass“name =”DataModel“&gt; &lt;eStructuralFeatures xsi：type =”ecore：EAttribute“name =”name“eType =”ecore：EDataType http：//www.eclipse。 org / emf / 2002 / Ecore＃// EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”entity“upperBound =” -  1“eType =”＃// Entity“containment =”true“/ &gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =“ecore：EClass”name =“Entity”&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“name”eType =“ecore：EDataType http：// www。 eclipse.org/emf/2002/Ecore#// EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”attribute“lowerBound =”1“upperBound =” -  1“eType =”＃// Attribute “containment =”true“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”reference“upperBound =” -  1“eType = “＃// EntityReference”containment =“true”/&gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =“ecore：EClass”name =“Attribute”&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“name” eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString”/&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“type”eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString“/&gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =”ecore：EClass“name =”EntityReference“&gt; &lt;eStructuralFeatures xsi：type =” ecore：EAttribute“name =”name“eType =”ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EAttribute“name = “toMany”eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean”/&gt; &lt;eStructuralFeatures xsi：type =“ecore：EReference”name =“target”lowerBound =“ 1“eType =”＃//实体“/&gt; &lt;/ eClassifiers&gt; &lt;/ ecore：EPackage&gt;</pre></div></div><div class="section" title="生成EMF工具"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_generate_emf_tooling"></a>生成EMF工具</h2></div></div></div><p>除了提供Ecore元元模型<a name="N101E8" class="indexterm"></a> ，EMF还支持构建（或多或少）可用的编辑器。这些是从我们刚刚定义的元模型自动生成的。为了定义示例模型（我们将在下面做），我们必须生成这些编辑器。此外，我们必须为元模型生成实现类。为了生成所有这些东西，我们必须定义一个标记模型，其中包含许多细节来控制各种工件的生成。此标记模型称为<span class="emphasis"><em>genmodel</em></span> <a name="N101EE" class="indexterm"></a> 。</p><p>所以我们必须首先定义<span class="emphasis"><em>genmodel</em></span> 。在资源管理器中选择<code class="filename">data.ecore</code>模型，然后右键单击“ <span class="guimenu">新建”</span> →“ <span class="guisubmenu">其他”</span> →“ <span class="guisubmenu">Eclipse建模框架”</span> →“ <span class="guimenuitem">EMF生成器模型”</span> 。遵循以下五个步骤;请注意，它们也在下图中说明。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>选择EMF Generator Model</p></li><li class="listitem"><p>定义名称</p></li><li class="listitem"><p>选择文件夹</p></li><li class="listitem"><p>选择Ecore模型作为源</p></li><li class="listitem"><p>按<span class="emphasis"><em>Load</em></span>按钮，然后按<span class="emphasis"><em>Finish</em></span></p></li></ol></div><p> </p><div class="figure"><a name="emf_tutorial_creating_genmodel"></a><p class="title"><b>图6。创建genmodel</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_genmodel_step_all_admonitions.png" alt="创建genmodel"></div></div></div><p><br class="figure-break"></p><p>因此，您将获得完成的EMF <span class="emphasis"><em>genmodel</em></span> 。它是原始元模型周围的一种“包装”，因此，它具有相同的结构，但模型元素具有不同的属性。截至目前，您无需更改任何这些内容。</p><div class="figure"><a name="emf_tutorial_structure_genmodel"></a><p class="title"><b>图7。genmodel的结构</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_genmodel_gm_structure.png" alt="genmodel的结构"></div></div></div><p><br class="figure-break"></p><p>您现在可以生成其他项目。</p><div class="figure"><a name="emf_tutorial_creating_editing_projects"></a><p class="title"><b>图8。生成编辑项目</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_genmodel_generate_all.png" alt="生成编辑项目"></div></div></div><p><br class="figure-break"></p><p>您现在拥有所有生成的其他项目。</p><div class="figure"><a name="emf_tutorial_generated_projects"></a><p class="title"><b>图9。生成的项目</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_ecore_genmodel_generated_projects.png" alt="生成的项目"></div></div></div><p><br class="figure-break"></p><p>我们暂时不会深入研究这些额外的项目。但是，有一点需要指出：生成器还为元模型生成了实现类。如果您查看<code class="filename">xpand.demo.emf.datamodel/src</code>文件夹，您可以找到表示元模型中定义的概念的类（实际上是顶层的接口）。这些可用于访问模型。有关如何使用EMF模型API以及反射表兄弟的更多详细信息，请查看<a class="ulink" href="http://voelterblog.blogspot.com/2005/12/codeblogck-emf_10.html" target="_new">http://voelterblog.blogspot.com/2005/12/codeblogck-emf_10.html</a> 。</p></div><div class="section" title="设置发电机项目"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_setting_generator_project"></a>设置发电机项目</h2></div></div></div><p>为了使用Eclipse EMF（我们必须导出插件，重启Eclipse等等）使它变得轻松一点，我们在IDE中启动了另一个Eclipse。此实例称为<span class="emphasis"><em>Runtime Workbench</em></span> 。因此，选择<code class="filename">xpand.demo.emf.datamodel.edit</code>项目，然后从上下文菜单<span class="guimenu">Run As</span> → <span class="guimenuitem">Eclipse Application中选择</span> 。</p><div class="figure"><a name="emf_tutorial_launch_runtime_platform"></a><p class="title"><b>图10。启动运行时平台</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/runas_eclipseapplication.png" width="324" alt="启动运行时平台"></div></div></div><p><br class="figure-break"></p><p>如果您使用的是Mac或* nix，现在应该打开工作区首选项页面并更改默认编码<a name="N10287" class="indexterm"></a>符合ISO-8859-1。 <sup>[ <a href="#ftn.N1028B" name="N1028B" class="footnote">4</a> ]</sup>从原始工作区导入<code class="filename">xpand.demo.emf.datamodel</code>项目。 <sup>[ <a href="#ftn.N102A0" name="N102A0" class="footnote">5</a> ]</sup> 请注意，导入项目不会物理移动文件， <sup>[ <a href="#ftn.N102AC" name="N102AC" class="footnote">6</a> ]</sup>因此您可以让项目同时成为两个工作区的一部分。</p><p>创建一个名为<code class="filename">xpand.demo.emf.datamodel.generator</code>的新Xpand Project <sup>[ <a href="#ftn.N102B2" name="N102B2" class="footnote">7</a> ]</sup> 。不要选择“生成简单示例”选项。</p><div class="figure"><a name="emf_tutorial_create_new_xpand_project"></a><p class="title"><b>图11。创建新的Xpand项目</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_new_xpand_project.png" alt="创建新的Xpand项目"></div></div></div><p><br class="figure-break"></p><p>您的Xpand项目已经配置为使用EMF模型。您可以在项目属性对话框中进行检查：</p><div class="figure"><a name="emf_tutorial_project_properties"></a><p class="title"><b>图12。项目属性</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_new_xpand_project_step2.png" alt="项目属性"></div></div></div><p><br class="figure-break"></p></div><div class="section" title="定义示例数据模型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_defining_sample_model"></a>定义示例数据模型</h2></div></div></div><p>选择<code class="filename">src</code>文件夹，然后选择<span class="guimenu">New</span> → <span class="guisubmenu">Other</span> → <span class="guisubmenu">Example EMF Model Creation Wizards</span> → <span class="guimenuitem">Data Model</span> 。创建一个新的数据模型，称之为<code class="filename">example.data</code> 。在向导的最后一页上，选择<span class="emphasis"><em>Model</em></span>作为模型对象。</p><div class="figure"><a name="emf_tutorial_create_sample_data_model"></a><p class="title"><b>图13。创建示例数据模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/create_data_model.png" alt="创建示例数据模型"></div></div></div><p><br class="figure-break"></p><p>接下来，将此模型填充如下。请注意，在属性的情况下，您还必须定义类型（即字符串），而不仅仅是名称。</p><div class="figure"><a name="emf_tutorial_sample_data_model"></a><p class="title"><b>图14。样本数据模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/sample_datamodel.png" alt="样本数据模型"></div></div></div><p><br class="figure-break"></p><p>同样，为了避免任何拼写错误，例如XMI for <code class="filename">example.data</code> ：</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;data：DataModel xmi：version =“2.0”xmlns：xmi =“http://www.omg.org/XMI”xmlns：data =“http://www.xpand.org/xpand.demo.emf。 datamodel“&gt; &lt;entity name =”Person“&gt; &lt;attribute name =”name“type =”String“/&gt; &lt;reference name =”cars“toMany =”true“target =”// @ entity.1“/&gt; &lt; / entity&gt; &lt;entity name =“Vehicle”&gt; &lt;attribute name =“plate”type =“String”/&gt; &lt;/ entity&gt; &lt;/ data：DataModel&gt;</pre></div><div class="section" title="使用动态EMF"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_dynamic_emf"></a>使用动态EMF</h2></div></div></div><p>您也可以使用动态EMF，而不是生成编辑器和元类<a name="N10328" class="indexterm"></a> 。这可以通过在打开的元模型中选择要创建的模型的根类（此处为： <span class="emphasis"><em>DataModel</em></span> ），然后从上下文菜单中选择“ <span class="guimenuitem">创建动态实例”</span>来实现。这将打开一个可以动态编辑相应实例的编辑器。默认情况下，创建的文件具有<code class="filename">.xmi</code>扩展名。</p><p>请注意，Xpand可以完全使用动态模型，没有理由生成代码。但是，如果要以编程方式使用模型，则生成的元类（而不是编辑器！）真的很有帮助。还请记住：在本教程的后续部分中，您将指定<span class="emphasis"><em>metaModelPackage</em></span> <a name="N1033A" class="indexterm"></a>在工作流文件中的各种组件配置中，如下所示：</p><pre class="programlisting">&lt;metaModel id =“mm”class =“org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”数据。DataPackage“/&gt; &lt;/ metaModel&gt;</pre><p>在动态EMF的情况下，没有生成元模型包。因此，您必须指定元模型文件，即您刚刚创建的<code class="filename">.ecore</code>文件。请注意， <code class="filename">.ecore</code>文件必须位于类路径中才能使其工作。</p><pre class="programlisting">&lt;metaModel id =“mm”class =“org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”data.ecore“/&gt; &lt;/ metaModel&gt;</pre></div><div class="section" title="从示例模型生成代码"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_generating_code"></a>从示例模型生成代码</h2></div></div></div><div class="section" title="工作流程定义"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_the_workflow_definition"></a>工作流程定义</h3></div></div></div><p>要运行Xpand生成器，您必须定义工作流。它控制生成器执行的步骤（加载模型，检查它们，生成代码）。有关工作流文件如何工作的详细信息，请查看“ <span class="emphasis"><em>建模工作流引擎参考文档”</em></span> 。</p><p>在<code class="filename">src</code>文件夹中创建<code class="filename">workflow.mwe</code>和<code class="filename">workflow.properties</code> 。这些文件的内容如下所示：</p><pre class="programlisting">&lt;workflow&gt; &lt;property file =“workflow.properties”/&gt; &lt;bean class =“org.eclipse.emf.mwe.utils。StandaloneSetup“&gt; &lt;platformUri value =”..“/&gt; &lt;registerGeneratedEPackage value =”data。DataPackage“/&gt; &lt;/ bean&gt; &lt;component class =”org.eclipse.emf.mwe.utils。Reader“&gt; &lt;uri value =”$ {modelFile}“/&gt; &lt;modelSlot value =”model“/&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre><p><code class="code">workflow.properties</code> ：</p><pre class="programlisting">modelFile = platform：/resource/xpand.demo.emf.datamodel.generator/src/example.data srcGenPath = src-gen fileEncoding = ISO-8859-1</pre><p>工作流尝试从类路径加载内容;所以，例如， <code class="classname">data.DataPackage</code>类是从类路径解析的，属性中指定的模型文件也是如此（ <code class="filename">modelFile=example.data</code> ）</p><p>这将实例化示例模型并存储在名为model的工作流槽中。请注意，在<span class="emphasis"><em>metamodelPackage</em></span>插槽中，您必须指定EMF包对象（此处为： <code class="classname">data.DataPackage</code> ），而不是Java包（这里是<span class="package">数据</span> ）。</p></div><div class="section" title="运行工作流程"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_running_the_workflow"></a>运行工作流程</h3></div></div></div><p>在实际运行工作流之前，请确保可以在类路径中找到元模型。在我们的例子中，这可以通过将<code class="filename">xpand.demo.emf.datamodel</code>项目添加到<code class="filename">xpand.demo.emf.datamodel</code>的插件依赖项来<code class="filename">xpand.demo.emf.datamodel.generator</code> 。为此，请双击文件<code class="filename">xpand.demo.emf.datamodel.generator/META-INF/MANIFEST.MF</code> 。清单编辑器将出现。转到<span class="guimenu">Dependencies</span>选项卡，然后单击<span class="guimenu">Add ...</span>添加一些新的依赖项。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename">xpand.demo.emf.datamodel</code></p></li><li class="listitem"><p><code class="filename">org.eclipse.emf.mwe.utils</code></p></li><li class="listitem"><p><code class="filename">org.eclipse.emf.ecore.xmi</code></p></li><li class="listitem"><p><code class="filename">org.eclipse.jface.text</code></p></li><li class="listitem"><p><code class="filename">org.antlr.runtime</code></p></li><li class="listitem"><p><code class="filename">com.ibm.icu</code></p></li><li class="listitem"><p><code class="filename">org.eclipse.jdt.core</code></p></li></ul></div><div class="figure"><a name="emf_tutorial_add_metamodel_dependency"></a><p class="title"><b>图15。添加元模型依赖项</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/add_metamodel_to_classpath.png" alt="添加元模型依赖项"></div></div></div><p><br class="figure-break">别忘了保存清单文件！</p><p>现在，您可以在Eclipse中运行工作流：</p><div class="figure"><a name="emf_tutorial_run_workflow"></a><p class="title"><b>图16。</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/run_workflow.png" width="432"></div></div></div><p><br class="figure-break"></p><p>以下应该是输出：</p><pre class="screen">信息：------------------------------------------------ -------------------------------------- INFO：EMF Modeling Workflow Engine 1.2.1，Build v201206110920信息：（c）2005-2009 openarchitectureware.org和贡献者信息：----------------------------------- -------------------------------------------------- -  INFO：正在运行的工作流程：../ xpand.demo.emf.datamodel.generator/src/workflow.mwe INFO：14.04.2010 15:49:18 org.eclipse.emf.mwe.utils。StandaloneSetup setPlatformUri INFO：注册平台uri'..'14.04.2010 15:49:18 org.eclipse.emf.mwe.utils。StandaloneSetup addRegisterGeneratedEPackage INFO：添加生成的EPackage数据。DataPackage'14.04.2010 15:49:18 org.eclipse.emf.mwe.core.container。CompositeComponent internalInvoke INFO：Reader：从平台加载模型：/resource/xpand.demo.emf.datamodel.generator/src/example.data 14.04.2010 15:49:19 org.eclipse.emf.mwe.core。WorkflowRunner executeWorkflow INFO：工作流程在116ms完成！</pre></div><div class="section" title="模板"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_templates"></a>模板</h3></div></div></div><p>尚未生成代码。这并不奇怪，因为我们还没有添加任何模板。让我们改变这一点。在<code class="filename">src</code>文件夹和包中创建一个名为<code class="filename">Root.xpt</code>的文件包<span class="package">模板</span> 。</p><p><code class="filename">Root.xpt</code>如下所示。顺便说一句，如果你需要输入<span class="foreignphrase"><em class="foreignphrase">guillemets</em></span> <a name="N103F1" class="indexterm"></a> （«和»），编辑器使用<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&lt;</strong></span>和<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&gt;</strong></span>提供键盘快捷键。</p><pre class="programlisting">«DEFINE Root FOR data :: DataModel»«EXPAND Entity FOREACH entity»«ENDDEFINE»«DEFINE Entity FOR data :: Entity»«FILE name +“。java”»public class«name»{«FOREACH属性AS a»//不良做法私人«a.type»«a.name»; «ENDFOREACH»}«ENDFILE»«ENDDEFINE»</pre><p>我们必须扩展<code class="filename">workflow.mwe</code>文件，以便使用刚编写的模板：</p><pre class="programlisting">&lt;workflow&gt; &lt;property file =“workflow.properties”/&gt; ..&lt;component class =“org.eclipse.emf.mwe.utils。Reader“&gt; &lt;uri value =”platform：/ resource / $ {modelFile}“/&gt; ..&lt;/工作流程&gt;</pre><p>首先，我们清理我们想要生成代码的目录。</p><pre class="programlisting">&lt;component class =“org.eclipse.emf.mwe.utils。DirectoryCleaner“&gt; &lt;directory value =”$ {srcGenPath}“/&gt; &lt;/ component&gt;</pre><p>然后，我们启动生成器组件。其配置略有参与。</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。发电机“&gt;</pre><p>首先，您必须定义元模型。在我们的例子中，我们使用<code class="classname">EmfMetaModel</code> <a name="N1041C" class="indexterm"></a>因为我们想要使用EMF模型。此外，您必须指定表示该元模型的EMF包的类名。它必须在类路径上。</p><pre class="programlisting">&lt;metaModel id =“mm”class =“org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel“&gt; &lt;/ metaModel&gt;</pre><p>然后，您必须为<span class="emphasis"><em>Xpand</em></span>定义<span class="emphasis"><em>条目语句</em></span> 。知道模型槽包含<code class="classname">data.实例<code class="classname">data.DataModel</code> （XmiReader已将模型的第一个元素放入该槽中，我们从数据中知道它是一个<code class="classname">DataModel</code> ），我们可以编写以下语句。再次注意，模型在这里引用了一个插槽名称！</p><pre class="programlisting">&lt;expand value =“templates :: Root :: Root FOR model”/&gt;</pre><p>然后，我们指定生成器应该放置生成的代码的位置，并且生成的代码应该由代码美化器处理：</p><pre class="programlisting">&lt;outlet path =“$ {srcGenPath} /”&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt;</pre><p>现在，我们差不多完成了。</p><pre class="programlisting">&lt;/ component&gt; &lt;/ workflow&gt;</pre><p>您还需要将<span class="emphasis"><em>srcGenPath</em></span>添加到<code class="filename">workflow.properties</code>文件中。</p><pre class="programlisting">modelFile = example.data srcGenPath = src-gen</pre></div><div class="section" title="再次运行发电机"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_running_the_generator_again"></a>再次运行发电机</h3></div></div></div><p>因此，如果您现在重新启动生成器，您应该获得一个生成的文件，如下所示：</p><pre class="programlisting">public class Person {// bad practice public String lastName; }</pre></div></div><div class="section" title="用检查语言检查约束"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_checking_contraints_with_check"></a>用<span class="emphasis"><em>检查</em></span>语言检查约束</h2></div></div></div><p>使用纯Java检查约束的替代方法是声明性约束检查语言<span class="emphasis"><em>Check</em></span> <a name="N1045D" class="indexterm"></a> 。有关此语言的详细信息， <span class="emphasis"><em><a class="xref" href="#Check_language" title="校验">请查看Check语言</a></em></span>参考。我们将在这里提供一个简单的例子。</p><div class="section" title="定义约束"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_defining_the_constraint"></a>定义约束</h3></div></div></div><p>我们首先定义约束<a name="N1046D" class="indexterm"></a>本身。我们在项目的<code class="filename">src</code>文件夹中创建一个名为<code class="filename">checks.chk</code>的新文件。这个文件驻留在类路径中非常重要！该文件包含以下内容：</p><pre class="programlisting">进口数据; context属性错误“名称必须多于一个char”：name.length&gt; 1;</pre><p>这个约束表明，对于元类<code class="classname">data::Attribute</code> ，我们要求名称长度超过一个字符。如果此表达式的计算结果为false，则将报告冒号前给出的错误消息。检查文件可以包含任意数量的此类约束。将针对相应元类的所有实例评估它们。</p><p>为了显示一个更复杂的约束示例，这个示例确保属性的名称必须是唯一的：</p><pre class="programlisting">context Entity ERROR“Entity属性的名称必须是唯一的”：attribute.forAll（a1 | attribute.notExists（a2 | a1！= a2 &amp;&amp; a1.name == a2.name））;</pre></div><div class="section" title="集成到工作流文件中"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_integration_into_the_workflow_file"></a>集成到工作流文件中</h3></div></div></div><p>以下XML是我们上面已经使用过的工作流文件。</p><pre class="programlisting">&lt;workflow&gt; &lt;property file =“workflow.properties”/&gt; ..&lt;component class =“org.eclipse.emf.mwe.utils。Reader“&gt; &lt;uri value =”platform：/ resource / $ {modelFile}“/&gt; ..&lt;/ component&gt; &lt;/ workflow&gt;</pre><p>在阅读模型后，我们添加了一个额外的组件，即<span class="emphasis"><em>CheckComponent</em></span> 。</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.check。CheckComponent“&gt;</pre><p>与代码生成器一样，我们必须向检查器解释我们使用的元元模型和元模型。</p><pre class="programlisting">&lt;metaModel id =“mm”class =“org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel“&gt; &lt;/ metaModel&gt;</pre><p>然后我们必须提供检查文件。组件尝试通过将<code class="filename">.chk</code>附加到名称并搜索类路径来加载文件 - 这就是它必须位于类路径中的原因。</p><pre class="programlisting">&lt;checkFile value =“checks”/&gt;</pre><p>最后，我们必须告诉引擎哪些模型或部分模型的检查应该起作用。通常，您可以使用<code class="code">&lt;expressionvalue="..."/&gt;</code>元素在插槽内容上定义任意表达式。出于我们的目的，我们希望在模型槽中使用完整的EMF数据结构，我们可以使用快捷方式<span class="emphasis"><em>emfAllChildrenSlot</em></span>属性，该属性返回特定槽的内容元素下面的完整子树，包括槽内容元素本身。</p><pre class="programlisting">&lt;emfAllChildrenSlot value =“model”/&gt; &lt;/ component&gt;</pre><p>如果名称的长度不大于1，则运行工作流会产生错误。同样，有意义的是将<code class="code">skipOnError="true"</code>添加到需要跳过的后续组件调用中，以防约束检查发现错误（通常是代码生成器或变换器）。</p></div></div><div class="section" title="扩展"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="emf_tutorial_extensions"></a>扩展</h2></div></div></div><p>通常情况下，您需要在模板中添加其他属性;这些属性不应直接添加到元类中，因为它们通常特定于特定的代码生成目标，因此不应“污染”元模型。</p><p>可以定义这样的扩展<a name="N104BB" class="indexterm"></a>在元类之外。有关详细信息，请参阅<span class="emphasis"><em>Xtend语言文档</em></span> ，我们在此提供一个简单示例。</p><div class="section" title="表达式扩展"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_expression_extensions"></a>表达式扩展</h3></div></div></div><p>假设我们想要更改模板的<span class="emphasis"><em>Attribute</em></span>部分，如下所示：</p><pre class="programlisting">«FOREACH属性AS»私人«a.type»«a.name»; public void«a.setterName（）»（«a.type»value）{this。«a.name»= value; } public«a.type»«a.getterName（）»（）{return this。«a.name»; }«ENDFOREACH»</pre><p>为了使其工作，我们需要定义<code class="methodname">setterName()</code>和<code class="methodname">getterName()</code>操作。我们通过编写一个所谓的扩展文件来做到这一点;我们称之为<code class="filename">java.ext</code> 。它必须具有<code class="filename">.ext</code>后缀才能被Xpand识别; <span class="emphasis"><em>Java</em></span>名称是因为它包含Java生成特定属性。我们将此文件直接放在<code class="filename">src</code>下的<code class="filename">templates</code>目录中，即直接放在<code class="filename">Root.xpt</code>文件旁边。扩展文件如下所示：</p><p>首先，我们必须导入数据元模型;否则我们将无法使用<span class="emphasis"><em>属性</em></span>元类。</p><pre class="programlisting">进口数据;</pre><p>然后我们可以定义两个新的操作<code class="methodname">setterName</code>和<code class="methodname">getterName</code> 。请注意，它们将它们被称为第一个参数的类型，一种“明确地”。在冒号之后，我们使用一个返回待定义值的表达式。</p><pre class="programlisting">String setterName（Attribute ele）：'set'+ ele.name.toFirstUpper（）; String getterName（Attribute ele）：'get'+ ele.name.toFirstUpper（）;</pre><p>要使这些扩展工作，我们必须<code class="filename">Root.xpt</code>添加到<code class="filename">Root.xpt</code>模板文件的开头：</p><pre class="programlisting">«EXTENSION templates :: java»</pre></div><div class="section" title="Java扩展"><div class="titlepage"><div><div><h3 class="title"><a name="emf_tutorial_java_extensions"></a> Java扩展<a name="N10509" class="indexterm"></a></h3></div></div></div><p>如果您无法使用表达式语言表达表达式的“业务逻辑”，则可以回退到Java。请查看以下扩展定义文件。它被称为<code class="filename">util.ext</code> ，位于<code class="filename">src/datamodel/generator/util</code> ：</p><pre class="programlisting">String timestamp（）：JAVA datamodel.generator.util。TemplateUtils.timestamp（）;</pre><p>在这里，我们定义一个独立于特定模型元素的扩展，因为它没有形式参数！扩展的实现被委托给Java类的静态操作。这是它的实现：</p><pre class="programlisting">public class TemplateUtils {public static String timestamp（）{return String.valueOf（System.currentTimeMillis（））; }}</pre><p>该元素可以独立于任何模型元素使用 - 它可以在全球范围内使用。</p><p>有时，不仅需要从模板和其他Xtend文件访问扩展，还需要从Java代码访问扩展。以下示例属于这种类型：我们希望定义从实体名称本身派生实现类名称的属性。此用例的最佳实践是将派生属性实现为Java方法，如上所述。以下代码声明了<code class="classname">Entity</code>属性：</p><pre class="programlisting">包数据模型;导入数据。实体; public class EntityHelper {public static String className（Entity e）{return e.getName（）+“Implementation”; public static String classFileName（Entity e）{return className（e）+“。java”; }}</pre><p>此外，要从模板文件访问属性，我们定义了一个使用辅助方法的扩展。<code class="filename">helper.ext</code>文件位于上面显示的辅助类旁边，即在<span class="package">datamodel</span>包中：</p><pre class="programlisting">进口数据; String className（Entity e）：JAVA datamodel。EntityHelper.className（数据。实体）; String classFileName（Entity e）：JAVA datamodel。EntityHelper.classFileName（数据。实体）;</pre><p>除了可以通过调用<code class="code">EntityHelper.className(someEntity)</code>从Java代码访问这些新属性<code class="code">EntityHelper.className(someEntity)</code> ，我们现在可以编写以下模板：</p><pre class="programlisting">«EXTENSION templates :: java»«EXTENSION datamodel :: generator :: util :: util»«EXTENSION datamodel :: helper»«DEFINE Root FOR data :: DataModel»«EXPAND Entity FOREACH entity»«ENDDEFINE»«DEFINE Entity FOR data ::实体»«FILE classFileName（）»//生成于«timestamp（）»公共抽象类«className（）»{«FOREACH属性AS a»private«a.type»«a.name»; public void«a.setterName（）»（«a.type»value）{this。«a.name»= value; } public«a.type»«a.getterName（）»（）{return this。«a.name»; }«ENDFOREACH»}«ENDFILE»«ENDDEFINE»</pre><p>为完整起见，下图显示了生成的目录和文件结构。</p><div class="figure"><a name="emf_tutorial_what_happened_so_far"></a><p class="title"><b>图17。到目前为止发生了什么</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/emf_tutorial/generator_structure_so_far.png" alt="到目前为止发生了什么"></div></div></div><p><br class="figure-break"></p></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[ <a href="#N100A4" name="ftn.N100A4" class="para">1</a> ]</sup>要添加子项，请右键单击要添加这些子项的元素，然后从列表中选择子项的类型。要配置属性，请通过选择任何上下文菜单底部的“ <span class="guimenu">显示属性视图”</span>打开属性对话框。请注意，这不是EMF教程。有关如何构建EMF（元）模型的更多详细信息，请参阅EMF文档。</p></div><div class="footnote"><p><sup>[ <a href="#N100B6" name="ftn.N100B6" class="para">2</a> ]</sup>属性是<code class="classname">EAttribute</code>类型的子类。请填写<span class="property">名称</span>和<span class="property">EType</span>属性。</p></div><div class="footnote"><p><sup>[ <a href="#N1010E" name="ftn.N1010E" class="para">3</a> ]</sup>注意：有几个<span class="emphasis"><em>-1的</em></span> ...不要错过减号！此外，收容标志是必不可少的。如果包含为<code class="literal">true</code>您将能够创建引用类型的子项，否则您只能引用它们。</p></div><div class="footnote"><p><sup>[ <a href="#N1028B" name="ftn.N1028B" class="para">4</a> ]</sup> <span class="guimenu">窗口</span> → <span class="guisubmenu">首选项</span> → <span class="guisubmenu">常规</span> → <span class="guisubmenu">工作区</span> → <span class="guimenuitem">文本文件编码</span> 。这是必要的，以提供<span class="foreignphrase"><em class="foreignphrase">guillemet</em></span>托架。</p></div><div class="footnote"><p><sup>[ <a href="#N102A0" name="ftn.N102A0" class="para">5</a> ]</sup> <span class="guimenu">文件</span> → <span class="guisubmenu">导入</span> → <span class="guisubmenu">常规</span> → <span class="guimenuitem">现有项目到工作区</span></p></div><div class="footnote"><p><sup>[ <a href="#N102AC" name="ftn.N102AC" class="para">6</a> ]</sup>除非您选中“将项目复制到工作区”选项</p></div><div class="footnote"><p><sup>[ <a href="#N102B2" name="ftn.N102B2" class="para">7</a> ]</sup> <span class="guimenu">文件</span> → <span class="guisubmenu">新建</span> → <span class="guisubmenu">项目</span> → <span class="guisubmenu">Xpand</span> → <span class="guimenuitem">Xpand项目</span></p></div></div></div><div class="part" title="第一部分。参考"><div class="titlepage"><div><div><h1 class="title"><a name="Reference"></a>第一部分。参考</h1></div></div></div><div class="toc"><p><b>目录</b></p><dl><dt><span class="chapter"><a href="#core_reference">2。<span class="emphasis"><em>Xpand</em></span> / <span class="emphasis"><em>Xtend</em></span> / <span class="emphasis"><em>Check</em></span> Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#r10_introduction">介绍</a></span></dt><dt><span class="section"><a href="#r10_typesystem">键入系统</a></span></dt><dd><dl><dt><span class="section"><a href="#r10_typesystem_types">类型</a></span></dt><dt><span class="section"><a href="#r10_builtintypes">内置类型</a></span></dt><dt><span class="section"><a href="#r10_metamodel_implementations">元模型实现（也称为Meta-Metamodels）</a></span></dt><dt><span class="section"><a href="#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a></span></dt><dt><span class="section"><a href="#metamodel_reference">元模型参考</a></span></dt></dl></dd><dt><span class="section"><a href="#r10_expressions_language">表达式</a></span></dt><dd><dl><dt><span class="section"><a href="#r10_expressions_builtin">内置类型的文字和特殊运算符</a></span></dt><dt><span class="section"><a href="#r10_expressions_collection_operations">特别收集业务</a></span></dt><dt><span class="section"><a href="#r10_expressions_if"><code class="methodname">if</code>表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_switch"><code class="methodname">switch</code>表达式</a></span></dt><dt><span class="section"><a href="#r10_expressions_chain">链表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_create"><code class="methodname">new</code>表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_globalvar">'GLOBALVAR'表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_multidispatch">多种方法（多次发送）</a></span></dt><dt><span class="section"><a href="#r10_expressions_casting">铸件</a></span></dt><dt><span class="section"><a href="#N10CD6">Xpand关键字和元模型属性</a></span></dt></dl></dd><dt><span class="section"><a href="#Check_language"><span class="emphasis"><em>校验</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#Check_language_description"><span class="emphasis"><em>检查</em></span>语言的描述</a></span></dt><dt><span class="section"><a href="#check_checkcomponent">工作流组件<span class="emphasis"><em>CheckComponent</em></span></a></span></dt></dl></dd><dt><span class="section"><a href="#Xtend_language"><span class="emphasis"><em>的Xtend</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#N10DE7">Xtend文件</a></span></dt><dt><span class="section"><a href="#N10E05">评论</a></span></dt><dt><span class="section"><a href="#N10E15">导入语句</a></span></dt><dt><span class="section"><a href="#N10E26">扩展进口声明</a></span></dt><dt><span class="section"><a href="#N10E43">扩展</a></span></dt><dt><span class="section"><a href="#N10EF3">Java扩展</a></span></dt><dt><span class="section"><a href="#create_extension">创建扩展（模型转换）</a></span></dt><dt><span class="section"><a href="#N11023">从Java调用扩展</a></span></dt><dt><span class="section"><a href="#N11067">WorkflowComponent</a></span></dt><dt><span class="section"><a href="#N1107E"><span class="emphasis"><em>Xtend中</em></span>面向方面的编程</a></span></dt></dl></dd><dt><span class="section"><a href="#xpand_reference_introduction"><span class="emphasis"><em>Xpand2</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a></span></dt><dt><span class="section"><a href="#xpand_reference_general_structure_of_template_files">模板文件的一般结构</a></span></dt><dt><span class="section"><a href="#xpand_reference_statements_of_the_expand_language"><span class="emphasis"><em>Xpand</em></span>语言的语句</a></span></dt><dt><span class="section"><a href="#xpand_reference_aspect-oriented_programming_in_xpand"><span class="emphasis"><em>Xpand中</em></span>面向方面的编程</a></span></dt><dt><span class="section"><a href="#xpand_reference_generator_workflow_component">生成器工作流程组件</a></span></dt><dt><span class="section"><a href="#aop_template_introduction">在<span class="emphasis"><em>Xpand中</em></span>使用面向方面编程的<span class="emphasis"><em>示例</em></span></a></span></dt><dt><span class="section"><a href="#aop_template_the_problem">问题</a></span></dt><dt><span class="section"><a href="#aop_template_example">例</a></span></dt><dt><span class="section"><a href="#aop_template_more_ao">更多方面取向</a></span></dt></dl></dd><dt><span class="section"><a href="#r10_profiler">探查</a></span></dt></dl></dd><dt><span class="chapter"><a href="#builtin_api">3。内置类型API文档</a></span></dt><dd><dl><dt><span class="section"><a href="#Object.html"><code class="classname">宾语</code></a></span></dt><dt><span class="section"><a href="#String.html"><code class="classname">串</code></a></span></dt><dt><span class="section"><a href="#Integer.html"><code class="classname">整数</code></a></span></dt><dt><span class="section"><a href="#Boolean.html"><code class="classname">布尔</code></a></span></dt><dt><span class="section"><a href="#Real.html"><code class="classname">真实</code></a></span></dt><dt><span class="section"><a href="#Collection.html"><code class="classname">采集</code></a></span></dt><dt><span class="section"><a href="#List.html"><code class="classname">名单</code></a></span></dt><dt><span class="section"><a href="#Set.html"><code class="classname">组</code></a></span></dt><dt><span class="section"><a href="#xpand2_Type.html"><code class="classname">xpand2 ::类型</code></a></span></dt><dt><span class="section"><a href="#xpand2_Feature.html"><code class="classname">xpand2 ::特写</code></a></span></dt><dt><span class="section"><a href="#xpand2_Property.html"><code class="classname">xpand2 ::物业</code></a></span></dt><dt><span class="section"><a href="#xpand2_Operation.html"><code class="classname">xpand2 ::操作</code></a></span></dt><dt><span class="section"><a href="#xpand2_StaticProperty.html"><code class="classname">xpand2 :: StaticProperty</code></a></span></dt><dt><span class="section"><a href="#Void.html"><code class="classname">空虚</code></a></span></dt><dt><span class="section"><a href="#xtend_AdviceContext.html"><code class="classname">XTEND :: AdviceContext</code></a></span></dt><dt><span class="section"><a href="#xpand2_Definition.html"><code class="classname">xpand2 ::定义</code></a></span></dt><dt><span class="section"><a href="#xpand2_Iterator.html"><code class="classname">xpand2 ::迭代器</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#stdlib_reference">4。STDLIB</a></span></dt><dd><dl><dt><span class="section"><a href="#N123CE">介绍</a></span></dt><dt><span class="section"><a href="#N123D6">Stdlib扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#N123E3">IO扩展</a></span></dt><dt><span class="section"><a href="#N124C0">柜台扩展</a></span></dt><dt><span class="section"><a href="#N12520">属性扩展</a></span></dt><dt><span class="section"><a href="#N1256E">元素属性扩展</a></span></dt><dt><span class="section"><a href="#N125B0">问题扩展</a></span></dt><dt><span class="section"><a href="#N1262A">命名扩展</a></span></dt><dt><span class="section"><a href="#N12684">Globalvar扩展</a></span></dt><dt><span class="section"><a href="#N1269B">克隆扩展</a></span></dt><dt><span class="section"><a href="#N126DD">交叉引用扩展</a></span></dt><dt><span class="section"><a href="#N12704">UID扩展</a></span></dt><dt><span class="section"><a href="#N1274E">Mixin扩展</a></span></dt><dt><span class="section"><a href="#N1278E">跟踪扩展</a></span></dt></dl></dd><dt><span class="section"><a href="#N12811">Stdlib工作流程组件</a></span></dt><dd><dl><dt><span class="section"><a href="#N12816">SystemCommand</a></span></dt><dt><span class="section"><a href="#N12879">SlotCopier</a></span></dt><dt><span class="section"><a href="#N128C4">SlotListAdder</a></span></dt><dt><span class="section"><a href="#N12913">SlotPrinter</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#eclipse_integration">5。Xpand Eclipse集成</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_introduction">介绍</a></span></dt><dt><span class="section"><a href="#eclipse_integration_installation">安装</a></span></dt><dt><span class="section"><a href="#eclipse_integration_overview">概观</a></span></dt><dt><span class="section"><a href="#eclipse_integration_file_decorations">文件装饰</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors">编者</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_editors_syntax_coloring">语法着色</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors_code_completion">代码完成</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors_xpand_tag_delimiter"><span class="emphasis"><em>Xpand</em></span>标记分隔符创建支持</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_preference_pages">首选项页面</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_preference_pages_meta_model_contributors">Metamodel贡献者</a></span></dt><dt><span class="section"><a href="#eclipse_integration_preference_pages_global_preferences">全球偏好</a></span></dt><dt><span class="section"><a href="#eclipse_integration_preference_pages_preferences_per_project">每个项目的偏好</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_xpand_nature_builder">Xpand Nature和Xpand Builder</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_xpand_nature_builder_problem_markers">问题标记</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_running_a_workflow">运行工作流程</a></span></dt></dl></dd><dt><span class="chapter"><a href="#incrementalGeneration">6。增量生成</a></span></dt><dd><dl><dt><span class="section"><a href="#incrementalGeneration_background">技术背景</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_usage">使用增量生成</a></span></dt><dd><dl><dt><span class="section"><a href="#incrementalGeneration_usage_facade">增量发电门面</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_usage_callback">增量生成回调</a></span></dt></dl></dd><dt><span class="section"><a href="#incrementalGeneration_notes">补充说明</a></span></dt><dd><dl><dt><span class="section"><a href="#incrementalGeneration_limitations">限制</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_performance">性能注意事项</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#backend">7。使用后端提高性能</a></span></dt><dd><dl><dt><span class="section"><a href="#backend_background">技术背景</a></span></dt><dd><dl><dt><span class="section"><a href="#backend_interpretation_background">它如何在解释模式下工作</a></span></dt></dl></dd><dt><span class="section"><a href="#backend_usage">使用后端</a></span></dt><dd><dl><dt><span class="section"><a href="#backend_quickstart">快速入门</a></span></dt><dt><span class="section"><a href="#backend_compiler">将源代码编译为Java</a></span></dt><dt><span class="section"><a href="#backend_execution">使用后端执行工作流程</a></span></dt><dt><span class="section"><a href="#java_middleend">在Java中实现函数 -  Java Annotations Middleend</a></span></dt></dl></dd><dt><span class="section"><a href="#call_functions_backend">调用从Java后端注册的函数</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uml_adapter">8。UML2适配器</a></span></dt><dd><dl><dt><span class="section"><a href="#uml_adapter_introduction">介绍</a></span></dt><dt><span class="section"><a href="#uml_adapter_installation">安装</a></span></dt><dt><span class="section"><a href="#uml_adapter_eclipse_setup">设置Eclipse</a></span></dt><dd><dl><dt><span class="section"><a href="#uml_adapter_setup_profiles">Eclipse中的配置文件</a></span></dt></dl></dd><dt><span class="section"><a href="#uml_adapter_runtime_configuration">运行时配置</a></span></dt><dd><dl><dt><span class="section"><a href="#uml_adapter_runtime_workflow">工作流程</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#xsd_reference">9。XSD适配器</a></span></dt><dd><dl><dt><span class="section"><a href="#xsd_reference_prerequisites">先决条件</a></span></dt><dt><span class="section"><a href="#xsd_reference_overview">概观</a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components">工作流程组件</a></span></dt><dd><dl><dt><span class="section"><a href="#xsd_reference_workflow_components_xsdmetamodel">
        <code class="classname">XSDMetaModel</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlreader">
        <code class="classname">XMLReader的</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlwriter">
        <code class="classname">XMLWriter的</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlbeautifier">
        <code class="classname">XMLBeautifier</code>
      </a></span></dt></dl></dd><dt><span class="section"><a href="#xsd_reference_xsd2ecore">幕后制作：将XSD转变为Ecore</a></span></dt><dt><span class="section"><a href="#xsd_reference_declare_xsd">如何声明XML Schema</a></span></dt></dl></dd></dl></div><div class="chapter" title="Chapter 9. Xpand / Xtend / Check Reference"><div class="titlepage"><div><div><h2 class="title">Chapter 9. <span class="emphasis"><em>Xpand</em></span> / <span class="emphasis"><em>Xtend</em></span> / <span class="emphasis"><em>Check</em></span> Reference</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#r10_introduction">介绍</a></span></dt><dt><span class="section"><a href="#r10_typesystem">键入系统</a></span></dt><dd><dl><dt><span class="section"><a href="#r10_typesystem_types">类型</a></span></dt><dt><span class="section"><a href="#r10_builtintypes">内置类型</a></span></dt><dt><span class="section"><a href="#r10_metamodel_implementations">元模型实现（也称为Meta-Metamodels）</a></span></dt><dt><span class="section"><a href="#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a></span></dt><dt><span class="section"><a href="#metamodel_reference">元模型参考</a></span></dt></dl></dd><dt><span class="section"><a href="#r10_expressions_language">表达式</a></span></dt><dd><dl><dt><span class="section"><a href="#r10_expressions_builtin">内置类型的文字和特殊运算符</a></span></dt><dt><span class="section"><a href="#r10_expressions_collection_operations">特别收集业务</a></span></dt><dt><span class="section"><a href="#r10_expressions_if"><code class="methodname">if</code>表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_switch"><code class="methodname">switch</code>表达式</a></span></dt><dt><span class="section"><a href="#r10_expressions_chain">链表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_create"><code class="methodname">new</code>表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_globalvar">'GLOBALVAR'表达</a></span></dt><dt><span class="section"><a href="#r10_expressions_multidispatch">多种方法（多次发送）</a></span></dt><dt><span class="section"><a href="#r10_expressions_casting">铸件</a></span></dt><dt><span class="section"><a href="#N10CD6">Xpand关键字和元模型属性</a></span></dt></dl></dd><dt><span class="section"><a href="#Check_language"><span class="emphasis"><em>校验</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#Check_language_description"><span class="emphasis"><em>检查</em></span>语言的描述</a></span></dt><dt><span class="section"><a href="#check_checkcomponent">工作流组件<span class="emphasis"><em>CheckComponent</em></span></a></span></dt></dl></dd><dt><span class="section"><a href="#Xtend_language"><span class="emphasis"><em>的Xtend</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#N10DE7">Xtend文件</a></span></dt><dt><span class="section"><a href="#N10E05">评论</a></span></dt><dt><span class="section"><a href="#N10E15">导入语句</a></span></dt><dt><span class="section"><a href="#N10E26">扩展进口声明</a></span></dt><dt><span class="section"><a href="#N10E43">扩展</a></span></dt><dt><span class="section"><a href="#N10EF3">Java扩展</a></span></dt><dt><span class="section"><a href="#create_extension">创建扩展（模型转换）</a></span></dt><dt><span class="section"><a href="#N11023">从Java调用扩展</a></span></dt><dt><span class="section"><a href="#N11067">WorkflowComponent</a></span></dt><dt><span class="section"><a href="#N1107E"><span class="emphasis"><em>Xtend中</em></span>面向方面的编程</a></span></dt></dl></dd><dt><span class="section"><a href="#xpand_reference_introduction"><span class="emphasis"><em>Xpand2</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a></span></dt><dt><span class="section"><a href="#xpand_reference_general_structure_of_template_files">模板文件的一般结构</a></span></dt><dt><span class="section"><a href="#xpand_reference_statements_of_the_expand_language"><span class="emphasis"><em>Xpand</em></span>语言的语句</a></span></dt><dt><span class="section"><a href="#xpand_reference_aspect-oriented_programming_in_xpand"><span class="emphasis"><em>Xpand中</em></span>面向方面的编程</a></span></dt><dt><span class="section"><a href="#xpand_reference_generator_workflow_component">生成器工作流程组件</a></span></dt><dt><span class="section"><a href="#aop_template_introduction">在<span class="emphasis"><em>Xpand中</em></span>使用面向方面编程的<span class="emphasis"><em>示例</em></span></a></span></dt><dt><span class="section"><a href="#aop_template_the_problem">问题</a></span></dt><dt><span class="section"><a href="#aop_template_example">例</a></span></dt><dt><span class="section"><a href="#aop_template_more_ao">更多方面取向</a></span></dt></dl></dd><dt><span class="section"><a href="#r10_profiler">探查</a></span></dt></dl></div><div class="section" title="介绍"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="r10_introduction"></a>介绍</h2></div></div></div><p><span class="emphasis"><em>Xpand</em></span>生成器框架提供了文本语言，这些语言在MDSD过程中的不同上下文中很有用（例如验证，元模型扩展，代码生成，模型转换）。每种语言（ <span class="emphasis"><em>Check</em></span> ， <span class="emphasis"><em>Xtend</em></span>和<span class="emphasis"><em>Xpand</em></span> ）都是基于通用表达式语言和类型系统构建的。因此，它们可以在相同的模型，元模型和元元模型上运行，并且您不需要一次又一次地学习语法，因为它始终是相同的。</p><p>表达式框架在不同的元元模型上提供了统一的抽象层（例如EMF Ecore，Eclipse UML2，JavaBeans，XML Schema等）。此外，它还提供了一种功能强大的静态类型表达式语言，可用于各种文本语言。</p></div><div class="section" title="键入系统"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="r10_typesystem"></a>键入系统<a name="N10574" class="indexterm"></a> <a name="N1057A" class="indexterm"></a></h2></div></div></div><p>基于API的抽象层称为类型系统。它提供对内置类型和不同注册元模型实现的访问。这些已注册的元模型实现提供对它们提供的类型的访问。本文档的第一部分描述了类型系统。之后在本文档的第二部分中描述了表达式子语言。这种区分是必要的，因为类型系统和表达语言是两个不同的东西。类型系统是一种反射层，可以使用元模型实现进行扩展。表达式语言使用类型系统定义可执行表达式的具体语法。</p><p>此处描述的Java API位于<span class="package">org.eclipse.xpand.type</span>包中，是子项目<span class="package">core.expressions</span>的一部分。</p><div class="section" title="类型"><div class="titlepage"><div><div><h3 class="title"><a name="r10_typesystem_types"></a>类型</h3></div></div></div><p>每个对象（例如模型元素，值等）都有一个类型。类型包含属性和操作。此外，它可能继承自其他类型（多重继承也是可能的，具体取决于底层的元元模型）。</p><div class="section" title="输入名称"><div class="titlepage"><div><div><h4 class="title"><a name="r10_typesystem_typenames"></a>输入名称</h4></div></div></div><p>类型有一个简单的名称（例如<code class="classname">String</code> ）和一个可选的命名空间，用于在两个具有相同名称的类型之间（例如<code class="classname">my::metamodel</code> ）。名称空间片段的分隔符是双冒号“ <code class="classname">::</code> ”。完全限定名称如下所示：</p><pre class="programlisting">我完全:: ::合格::元类型</pre><p>特定类型使用的名称空间和名称由相应的<code class="classname">MetaModel</code>定义<a name="N105A5" class="indexterm"></a>实现。<code class="classname">EmfMetaModel <a name="N105AB" class="indexterm"></a></code>举例来说，映射<code class="classname">EPackages</code>到命名空间和<code class="classname">EClassifiers</code>至名。 <a name="N105B5" class="indexterm"></a><a name="N105B9" class="indexterm"></a> 因此，调用Ecore元素<code class="classname">EClassifier</code>的名称：</p><pre class="programlisting">的Ecore :: EClassifier</pre><p>如果您不想使用名称空间（无论出于何种原因），您始终可以实现自己的元模型并相应地映射名称。</p></div><div class="section" title="集合类型名称"><div class="titlepage"><div><div><h4 class="title"><a name="r10_typesystem_collection_typenames"></a>集合类型名称</h4></div></div></div><p>内置类型系统还包含以下集合类型<a name="N105CA" class="indexterm"></a> ： <code class="classname">Collection</code> ， <code class="classname">List</code>和<code class="classname">Set</code> 。因为表达式语言是静态类型检查的，我们不喜欢强制转换和<code class="classname">ClassCastExceptions</code> ，所以我们引入了<span class="emphasis"><em>参数化类型</em></span>的概念。类型系统不支持全功能泛型，因为我们不需要它们。</p><p>语法是：</p><pre class="programlisting">集合[my :: Type] List [my :: Type] Set [my :: Type]</pre></div><div class="section" title="特征"><div class="titlepage"><div><div><h4 class="title"><a name="r10_typesystem_features"></a>特征</h4></div></div></div><p>每种类型都提供功能。类型（或元模型）负责映射功能。有三种不同的功能：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>属性</p></li><li class="listitem"><p>操作</p></li><li class="listitem"><p>静态属性</p></li></ul></div><p><span class="emphasis"><em>属性</em></span> <a name="N105F4" class="indexterm"></a>直截了当：他们有名字和类型。可以在相应类型的实例上调用它们。对于<span class="emphasis"><em>运营来说</em></span>也是如此<a name="N105FC" class="indexterm"></a> 。但与属性相比，它们可以有参数。<span class="emphasis"><em>静态属性</em></span> <a name="N10605" class="indexterm"></a>相当于枚举或常量。必须静态调用它们，它们没有参数。</p></div></div><div class="section" title="内置类型"><div class="titlepage"><div><div><h3 class="title"><a name="r10_builtintypes"></a>内置类型<a name="N1060F" class="indexterm"></a></h3></div></div></div><p>如前所述，表达式框架有几个内置类型，用于定义操作和属性。在下文中，我们将粗略概述类型及其功能。我们不会在这里记录所有操作，因为内置类型会随着时间的推移而发展，我们希望从实现中获取文档（当然是模型驱动的）。有关完整参考，请参阅生成的<a class="link" href="#">API文档</a> 。</p><div class="section" title="宾语"><div class="titlepage"><div><div><h4 class="title"><a name="r10_builtintypes_object"></a><code class="classname">Object<a name="N1061D" class="indexterm"></a></code></h4></div></div></div><p><code class="classname">Object</code>定义了几个基本操作，如<code class="methodname">equals()</code> 。属性metaType提供对该Object的Xpand类型的访问。每种类型都必须扩展<code class="classname">Object</code> 。</p></div><div class="section" title="空虚"><div class="titlepage"><div><div><h4 class="title"><a name="r10_builtintypes_void"></a><code class="classname">Void</code><a name="N10631" class="indexterm"></a></h4></div></div></div><p>可以将<code class="classname">Void</code>类型指定为操作的返回类型，但不建议这样做，因为只要有可能，表达式应尽可能没有副作用。唯一可能的值为<code class="varname">null</code> 。有时将<code class="classname">Void</code>用作参数类型可能很有用，如果您希望能够为不同的参数类型调用函数，并且在使用<code class="varname">null</code>调用函数时也提供有效的实现。</p></div><div class="section" title="简单类型（数据类型）"><div class="titlepage"><div><div><h4 class="title"><a name="r10_builtintypes_simple"></a>简单类型（数据类型）</h4></div></div></div><a name="N10648" class="indexterm"></a><p>类型系统没有概念数据类型。数据类型只是类型。与在OCL中一样，我们支持以下类型： <code class="classname">String</code> ， <code class="classname">Boolean</code> ， <code class="classname">Integer</code> ， <code class="classname">Real</code> 。
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">String</code> <a name="N10660" class="indexterm"></a> ：丰富而方便的<code class="classname">String</code>库对于代码生成尤为重要。类型系统支持用于连接的'+'运算符，通常是<code class="classname">java.lang.String</code>操作（ <code class="methodname">length()</code>等）和一些特殊操作（如<code class="methodname">toFirstUpper()</code> ， <code class="methodname">toFirstLower()</code> ，正则表达式等在代码生成模板中经常需要）。</p></li><li class="listitem"><p><code class="classname">Boolean</code> <a name="N10677" class="indexterm"></a> ： <code class="classname">Boolean</code>提供常用的运算符（Java语法）：&amp;&amp;，|| ,!等。</p></li><li class="listitem"><p><code class="classname">Integer</code> <a name="N10682" class="indexterm"></a>和<code class="classname">Real</code> <a name="N10688" class="indexterm"></a> ： <code class="classname">Integer</code>和<code class="classname">Real</code>提供常用的比较运算符（&lt;，&gt;，&lt;=，&gt; =）和简单的算术（+， - ，*，/）。请注意， <span class="emphasis"><em><code class="classname">Integer</code>扩展了<code class="classname">Real</code> ！</em></span></p></li></ul></div></div><div class="section" title="集合类型"><div class="titlepage"><div><div><h4 class="title"><a name="r10_builtintypes_collections"></a>集合类型</h4></div></div></div><a name="N1069D" class="indexterm"></a><p>类型系统有三种不同的Collection类型。
        <code class="classname">Collection</code> <a name="N106A6" class="indexterm"></a>是基类型，它提供了<code class="classname">java.util.已知的几个操作<code class="classname">java.util.Collection</code> 。另外两种类型（ <code class="classname">List</code> <a name="N106AF" class="indexterm"></a> ， <code class="classname">Set <a name="N106B5" class="indexterm"></a></code> ）也对应于它们的<span class="package">java.util</span>等价物。</p></div><div class="section" title="输入系统类型"><div class="titlepage"><div><div><h4 class="title"><a name="r10_builtintypes_typesystem_types"></a>输入系统类型</h4></div></div></div><p>类型系统描述了自身，因此，存在不同概念的类型。反射编程需要这些类型。为避免与具有相同名称的元类型混淆（例如，具有名为<code class="classname">Operation</code>的元类型并不罕见），我们使用命名空间<code class="classname">xpand2</code>为所有类型添加前缀。我们有：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">xpand2 ::类型</code></p></li><li class="listitem"><p><code class="classname">xpand2 ::特写</code></p></li><li class="listitem"><p><code class="classname">xpand2 ::物业</code></p></li><li class="listitem"><p><code class="classname">xpand2 :: StaticProperty</code></p></li><li class="listitem"><p><code class="classname">xpand2 ::操作</code></p></li></ul></div><p>您应该知道，如果您在表达式中按名称命名类型，则您获得的对象实际上是<code class="classname">xpand2::Type</code> 。一个常见的用例是使用<code class="methodname">instanceOf()</code>操作或完全一种类型来证明某个对象属于某种类型或其子类型。</p><pre class="programlisting">//结果为true，如果someExpression的结果是MyType类型或其子类型MyType.isInstance（someExpression）//结果为true，如果someExpression的结果完全是MyType类型someExpression.metaType == MyType</pre><p>请注意，这只应在真正需要时使用。处理类型层次结构的替代实现的推荐方法是使用<a class="link" href="#">Multiple Dispatch</a> 。</p></div></div><div class="section" title="元模型实现（也称为Meta-Metamodels）"><div class="titlepage"><div><div><h3 class="title"><a name="r10_metamodel_implementations"></a>元模型实现（也称为Meta-Metamodels）<a name="N106F2" class="indexterm"></a></h3></div></div></div><p>默认情况下，类型系统只知道<a class="link" href="#">内置类型</a> 。为了注册您自己的元类型（例如<code class="classname">Entity</code>或<code class="classname">State</code> ），您需要使用类型系统注册相应的元模型实现。在元模型实现中， <span class="emphasis"><em>Xpand</em></span>类型系统元素（ <code class="classname">Type</code> ， <code class="classname">Property</code> ， <a name="N1070A" class="indexterm"></a> <code class="classname">Operation)</code> <a name="N1070F" class="indexterm"></a>被映射到任意其他类型的系统（例如Java反射，Ecore或XML Schema）。</p><div class="section" title="示例JavaMetaModel"><div class="titlepage"><div><div><h4 class="title"><a name="r10_metamodel_example_java"></a>示例JavaMetaModel</h4></div></div></div><p>例如，如果您希望以下JavaBean充当元类型（即您的模型包含该类型的实例）：</p><pre class="programlisting">public class Attribute {private String name;私有字符串类型; public String getName（）{return name; public void setName（String name）{this.name = name; public String getType（）{return type; public void setType（String type）{this.type = type; }}</pre><p>您需要使用<code class="classname">JavaMetaModel</code> <a name="N10721" class="indexterm"></a>实现，它使用普通的Java反射层来映射对模型的访问。</p><p>所以，如果你有例如<span class="emphasis"><em>Xpand中</em></span>的以下表达式：</p><pre class="programlisting">myattr.name.toFirstUpper（）</pre><p>和<code class="varname">myattr</code>是指向<code class="classname">Attribute</code>实例的局部变量的名称。<span class="emphasis"><em>Xpand</em></span>类型系统询问元模型实现，如果他们“知道”属性实例的类型。如果您注册了<code class="classname">JavaMetaModel</code> ，它将返回一个映射到底层Java类的<code class="classname">xpand2::Type</code> 。当询问类型是否知道属性“ <code class="varname">name</code> ”时，它将使用Java反射API检查Java类。</p><p>附带<span class="emphasis"><em>XPAND</em></span>的JavaMetaModel实现可以与一个策略[GOF95-图案]，以便控制或改变映射来配置。例如， <code class="classname">JavaBeansStrategy</code>将getter和setter方法映射到简单属性，因此我们将此策略用于上面的示例。</p></div><div class="section" title="Eclipse IDE MetaModelContributors"><div class="titlepage"><div><div><h4 class="title"><a name="r10_metamodel_contributors"></a> Eclipse IDE MetaModelContributors</h4></div></div></div><p>您应该知道每个<code class="classname">Metamodel</code> <a name="N10751" class="indexterm"></a>在运行时使用的实现，您需要有一个所谓的<code class="classname">MetamodelContributor</code>扩展，以便插件可以使用。如果您只使用标准元模型实现之一（EMF，UML2或Java），则不必担心它，因为<span class="emphasis"><em>Xpand</em></span>随各自的MetamodelContributors一起提供（有关详细信息，请参阅相应的文档）。如果您需要实现自己的<code class="classname">MetamodelContributor</code> <a name="N1075D" class="indexterm"></a>您应该查看Eclipse插件参考文档。</p></div><div class="section" title="使用工作流配置Metamodel实现"><div class="titlepage"><div><div><h4 class="title"><a name="r10_metamodel_workflow"></a>使用工作流配置Metamodel实现</h4></div></div></div><p>您需要使用相应的元模型实现配置<span class="emphasis"><em>Xpand</em></span>语言组件。</p><p><code class="classname">Xpand2</code>生成器组件的可能配置如下所示：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel class =”org.eclipse.type.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”my.generated。MetaModel1Package“/&gt; &lt;/ metaModel&gt; &lt;metaModel class =”org.eclipse.type.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”my / java / package / metamodel2.ecore“/&gt; &lt;/ metaModel&gt; ...&lt;/组分&gt;</pre><p>在此示例中， <code class="classname">EmfMetaModel</code>实现配置了两次。这意味着我们想要同时使用两个元模型，两者都基于EMF。 <span class="property">metaModelPackage</span>属性是特定于<code class="classname">EmfMetaModel</code>的属性（位于<code class="filename">org.eclipse.xtend.typesystem.emf</code>插件中）。它指向生成的<code class="classname">EPackages</code>接口。使用Ecore文件配置第二个元模型。为了工作，您不需要为<span class="emphasis"><em>Xpand</em></span>生成生成的Ecore模型。<code class="classname">EmfMetaModel</code>与动态EMF模型一起使用，就像生成的EMF模型一样。</p><p>请注意，尽管<code class="classname">EmfMetaModel</code>派生自<code class="classname">EmfMetaModel</code> ，但建议您更喜欢<code class="classname">EmfRegistryMetaModel</code>而不是<code class="classname">EmfRegistryMetaModel</code> 。此外，建议使用平台URI（请参阅<a class="ulink" href="http://help.eclipse.org/galileo/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/common/util/URI.html" target="_new">API Doc URI</a> ）来引用EMF资源。</p><p>在工作流中使用平台URI需要使用<code class="classname">org.eclipse.emf.mwe.utils</code>插件中的<code class="classname">StandaloneSetup</code>类为独立执行设置EMF。此外，StandaloneSetup用于注册已知的EMF包。上面示例的等效工作流配置如下所示：</p><pre class="programlisting">&lt;bean class =“org.eclipse.emf.mwe.utils。StandaloneSetup“&gt; &lt;platformUri value =”..“/&gt; &lt;registerGeneratedEPackage value =”my.generated。MetaModel1Package“/&gt; &lt;registerEcoreFile value =”platform：/resource/my/java/package/metamodel2.ecore“/&gt; &lt;/ bean&gt; ...&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel class =”org.eclipse.type.emf。EmfRegistryMetaModel“/&gt; ......&lt;/组分&gt;</pre><p><code class="classname">StandaloneSetup</code>被赋予平台的路径。这是平台资源URI相对于其解析的路径。它通常指向工作区或检出插件项目的位置，该项目通常是执行工作流的工作目录上方的一个目录。</p><p>元模型实例通常在使用表达式的不同组件之间共享（最值得注意的是Xpand <code class="classname">Generator</code> ， <code class="classname">XtendComponent</code>和<code class="classname">CheckComponent</code> ）。通常，您不希望为每个工作流组件配置和实例化Metamodel实例。MWE允许您使用<code class="methodname">&lt;bean&gt;</code>标记实例化一个类，并通过为bean提供一个id值，可以使用idRef属性引用该相同的实例。这将导致此工作流程：</p><pre class="programlisting">&lt;bean class =“org.eclipse.emf.mwe.utils。StandaloneSetup“&gt; &lt;platformUri value =”..“/&gt; &lt;registerGeneratedEPackage value =”my.generated。MetaModel1Package“/&gt; &lt;registerEcoreFile value =”platform：/resource/my/java/package/metamodel2.ecore“/&gt; &lt;/ bean&gt; &lt;bean id =”mm_emf“class =”org.eclipse.type.emf。EmfRegistryMetaModel“/&gt; ......&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel idRef =”mm_emf“/&gt; ...&lt;/组分&gt;</pre></div></div><div class="section" title="使用不同的Metamodel实现（也称为Meta-Metamodels）"><div class="titlepage"><div><div><h3 class="title"><a name="r10_using_different_metamodels"></a>使用不同的Metamodel实现（也称为Meta-Metamodels）</h3></div></div></div><p>使用Xpand，您可以以透明的方式同时处理不同类型的模型表示。可以在同一个<span class="emphasis"><em>Xpand</em></span>模板中使用EMF模型，XML DOM模型和简单JavaBeans。您只需配置相应的MetaModel实现。</p><p>如果您想这样做，您需要知道类型查找的工作原理。我们假设我们有一个EMF元模型<a name="N107C8" class="indexterm"></a>以及基于某些Java类的模型。那么以下是可能的配置：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。Generator“&gt; &lt;metaModel class =”org.eclipse.internal.xtend.type.impl.java。JavaMetaModel“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel“&gt; &lt;metaModelFile value =”my / java / package / metamodel.ecore“/&gt; &lt;/ metaModel&gt; ...&lt;/组分&gt;</pre><p>当运行时需要访问给定对象的属性时，它会按配置的顺序询问元模型。我们假设我们的模型元素是Java类型<code class="classname">org.eclipse.emf.ecore.一个实例<code class="classname">org.eclipse.emf.ecore.EObject</code> ，它是EMF EClass <code class="classname">MyType</code>的动态实例。</p><p>我们有<span class="emphasis"><em>三个</em></span>元模型：</p><div class="orderedlist"><a name="N107DD" class="indexterm"></a><ol class="orderedlist" type="1"><li class="listitem"><p>内置（始终是第一个）</p></li><li class="listitem"><p>JavaMetaModel</p></li><li class="listitem"><p>EMFMetaModel  -  metamodel.ecore</p></li></ol></div><p>第一个将返回<code class="classname">Object</code>类型（而不是<code class="classname">java.lang.Object</code>但是<span class="emphasis"><em>Xpand的</em></span> <code class="classname">Object</code> ！）。此时， <code class="classname">Object</code>类型最适合请求，因此它将作为所需类型。</p><p>第二个元模型返回一个名为<code class="classname">org::eclipse::emf::ecore::EObject</code>的类型类型系统将检查返回的类型是否是当前“最适合”类型（ <code class="classname">Object</code> ）的特化。它是，因为它扩展了<code class="classname">Object</code> （每个元类型都必须扩展<code class="classname">Object</code> ）。此时类型系统假定<code class="classname">org::eclipse::emf::ecore::EObject</code>是所需的类型。</p><p>第三个元模型将返回<code class="classname">metamodel::MyType</code> ，它是所需的类型。但不幸的是，它没有扩展<code class="classname">org::eclipse::emf::ecore::EObject</code>因为它与这些Java类型无关。相反，它扩展了扩展<code class="classname">Object</code> <code class="classname">emf::EObject</code> 。</p><p>我们需要交换两个元模型的配置以获得所需的类型。</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”my / java / package / metamodel.ecore“/&gt; &lt;/ metaModel&gt; &lt;metaModel class =”org.eclipse.internal.xtend.type.impl.java。JavaMetaModel“/&gt; ...&lt;/组分&gt;</pre><p>元模型的顺序对于Xpand编辑器中的工作很重要。可以在<span class="emphasis"><em>Xtend / Xpand</em></span> -properties对话框中配置要使用的元模型。<span class="emphasis"><em>Activated元模型贡献者</em></span>表是有序列表。更具体的元模型必须放在列表的顶部。</p><div class="mediaobject"><img src="images/eclipse_integration/projectProperties.png"></div></div><div class="section" title="元模型参考"><div class="titlepage"><div><div><h3 class="title"><a name="metamodel_reference"></a>元模型参考</h3></div></div></div><a name="N10835" class="indexterm"></a><p>在下文中，将记录每个随<span class="emphasis"><em>Xpand</em></span>一起提供的内置元模型。此外，还有一些关于如何实现自己的元模型的指南。</p><div class="section" title="EMF元模型"><div class="titlepage"><div><div><h4 class="title"><a name="emf_metamodels"></a> EMF元模型</h4></div></div></div><p>本节将介绍可用于EMF模型的元模型。<span class="strong"><strong>请注意，必须先在工作流中执行一个安装实用程序类<code class="classname">Setup</code>或<code class="classname">StandaloneSetup</code> ，然后才能使用其中一个EMF元模型。</strong></span></p><div class="section" title="EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）"><div class="titlepage"><div><div><h5 class="title"><a name="emfregistry_metamodel"></a> EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）</h5></div></div></div><a name="N10852" class="indexterm"></a><a name="N10857" class="indexterm"></a><p>此元模型在全局EMF模型注册表中查找引用的元模型。这意味着，在使用此元模型时，只能在元模型中访问在此全局EMF模型注册表中注册的模型。</p><p>此元模型提供以下配置属性：</p><div class="table"><a name="properties_emfregistrymetamodel"></a><p class="title"><b>表格1。<code class="classname">EmfRegistryMetaModel</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of
            EmfRegistryMetaModel"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">useSingleGlobalResourceSet</code></td><td align="left">此布尔属性确定资源集的使用方式。如果设置为<span class="emphasis"><em>true</em></span> ，则所有模型资源将存储在单个全局资源集中。否则，将为每个模型资源使用单独的资源集。</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）"><div class="titlepage"><div><div><h5 class="title"><a name="emf_metamodel"></a> EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）</h5></div></div></div><a name="N10883" class="indexterm"></a><a name="N10888" class="indexterm"></a><p>此元模型是<a class="xref" href="#emfregistry_metamodel" title="EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）">EMF注册表元模型</a>的专用版本。除了前者的功能之外，它还允许以不同的方式指定未注册的模型，这些模型将添加到元模型中。</p><p>此元模型提供以下配置属性：</p><div class="table"><a name="properties_emfmetamodel"></a><p class="title"><b>表2。<code class="classname">EmfMetaModel</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of EmfMetaModel"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">useSingleGlobalResourceSet</code></td><td align="left">此布尔属性确定资源集的使用方式。如果设置为<span class="emphasis"><em>true</em></span> ，则所有模型资源将存储在单个全局资源集中。否则，将为每个模型资源使用单独的资源集。</td></tr><tr><td align="left"><code class="varname">metaModelFile</code></td><td align="left">设置将添加到元模型的Ecore文件的路径。</td></tr><tr><td align="left"><code class="varname">metaModelDescriptor</code></td><td align="left">通过指定EPackage描述符类的名称将模型添加到元模型。</td></tr><tr><td align="left"><code class="varname">metaModelPackage</code></td><td align="left">通过指定EPackage的名称将模型添加到元模型。</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="UML元模型"><div class="titlepage"><div><div><h4 class="title"><a name="uml_metamodels"></a> UML元模型</h4></div></div></div><p><span class="emphasis"><em>Xpand</em></span>还提供了几个元模型，允许将UML模型与此模型到文本生成框架结合使用。<span class="strong"><strong>请注意，您必须先在工作流中执行安装实用程序类<code class="classname">Setup</code> ，然后才能使用其中一个UML元模型</strong></span></p><div class="section" title="UML2 Metamodel（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）"><div class="titlepage"><div><div><h5 class="title"><a name="uml2_metamodel"></a> UML2 Metamodel（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）</h5></div></div></div><a name="N108D8" class="indexterm"></a><a name="N108DD" class="indexterm"></a><p>此元模型是<span class="emphasis"><em><a class="xref" href="#emf_metamodel" title="EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）">EMF元模型</a></em></span>的专用版本。它提供对UML2模型的访问，并具有以下配置属性：</p><div class="table"><a name="properties_uml2metamodel"></a><p class="title"><b>表3。<code class="classname">UML2MetaModel</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of UML2MetaModel"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">useSingleGlobalResourceSet</code></td><td align="left">此布尔属性确定资源集的使用方式。如果设置为<span class="emphasis"><em>true</em></span> ，则所有模型资源将存储在单个全局资源集中。否则，将为每个模型资源使用单独的资源集。</td></tr><tr><td align="left"><code class="varname">modelFile</code></td><td align="left">设置将添加到元模型的UML2模型文件的路径。</td></tr></tbody></table></div></div><br class="table-break"><p>这种实现很少使用，因为通常会使用配置文件的UML模型，因此Profile Metamodel也是如此。</p></div><div class="section" title="UML2配置文件元模型（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）"><div class="titlepage"><div><div><h5 class="title"><a name="uml2profile_metamodel"></a> UML2配置文件元模型（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）</h5></div></div></div><a name="N10913" class="indexterm"></a><a name="N10918" class="indexterm"></a><p>此元模型允许将UML配置文件应用于UML2模型，并扩展UML2元模型。它具有以下配置属性：</p><div class="table"><a name="properties_profilemetamodel"></a><p class="title"><b>表4。<code class="classname">ProfileMetaModel</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of
            ProfileMetaModel"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">useSingleGlobalResourceSet</code></td><td align="left">此布尔属性确定资源集的使用方式。如果设置为<span class="emphasis"><em>true</em></span> ，则所有模型资源将存储在单个全局资源集中。否则，将为每个模型资源使用单独的资源集。</td></tr><tr><td align="left"><code class="varname">modelFile</code></td><td align="left">设置将添加到元模型的UML2模型文件的路径。使用资源URI作为值。</td></tr><tr><td align="left"><code class="varname">轮廓</code></td><td align="left">设置将应用于UML2模型的UML概要文件的路径。如果使用多个配置文件，则可以多次使用此属性。使用资源URI作为值。</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）"><div class="titlepage"><div><div><h5 class="title"><a name="xmi_reader"></a> XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）</h5></div></div></div><a name="N1094E" class="indexterm"></a><a name="N10951" class="indexterm"></a><p>在使用UML模型时，XMI阅读器组件非常重要。它允许读出存储在XMI文件中的模型，并将其内容放入模型槽中。</p><p><code class="classname">XMIReader</code>组件提供以下可配置属性：</p><div class="table"><a name="properties_xmireader"></a><p class="title"><b>表5。<code class="classname">XMIReader</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of XMIReader"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">metaModelFile</td><td align="left">设置将添加到元模型的Ecore文件的路径。</td></tr><tr><td align="left">metaModelDescriptor</td><td align="left">通过指定EPackage描述符类的名称将模型添加到元模型。</td></tr><tr><td align="left">metaModelPackage</td><td align="left">通过指定EPackage的名称将模型添加到元模型。</td></tr><tr><td align="left">outputSlot</td><td align="left">设置将存储读取模型的模型槽的名称。</td></tr><tr><td align="left">firstElementOnly</td><td align="left">此布尔属性确定是否仅使用XMI文件的第一个模型元素。如果设置为<span class="emphasis"><em>true</em></span> ，则仅使用第一个模型元素，将忽略所有其他元素。否则，将使用XMI文件中的所有模型元素。</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）"><div class="titlepage"><div><div><h4 class="title"><a name="java_metamodel"></a> Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）</h4></div></div></div><a name="N10993" class="indexterm"></a><a name="N10998" class="indexterm"></a><p>Java元模型允许普通Java类作为元模型的元类型。<code class="classname">JavaMetaClass</code>使用策略模式来定义元素如何精确映射到元模型元素。有一个名为<code class="classname">org.eclipse.internal.xtend.type.impl.java.的类<code class="classname">org.eclipse.internal.xtend.type.impl.java.JavaBeansMetaModel</code> ，其预先配置了将简单Java bean映射到元模型元素的策略。</p><p>Java元模型没有可配置的属性。</p></div><div class="section" title="XSD Metamodel（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）"><div class="titlepage"><div><div><h4 class="title"><a name="xsd_metamodel"></a> XSD Metamodel（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）</h4></div></div></div><a name="N109AA" class="indexterm"></a><a name="N109AF" class="indexterm"></a><p>XSD元模型提供对以XML Schema Definition语言实现的模型的访问。它具有以下配置属性：</p><div class="table"><a name="properties_xsdmetamodel"></a><p class="title"><b>表6。<code class="classname">XSDMetaModel</code>属性</b></p><div class="table-contents"><table border="1" summary="Properties of XSDMetaModel"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">ID</code></td><td align="left">设置当前模型的ID。</td></tr><tr><td align="left"><code class="varname">registerPackagesGlobally</code></td><td align="left">此布尔属性确定是否将全局注册模型包。如果设置为<span class="emphasis"><em>true</em></span> ，则模型包将在全局注册表中注册。否则，将不会注册包。</td></tr><tr><td align="left"><code class="varname">savePackagesPath</code></td><td align="left">设置将保存模型包的路径（采用XMI格式）。</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="实现自己的元模型"><div class="titlepage"><div><div><h4 class="title"><a name="implementing_metamodels"></a>实现自己的元模型</h4></div></div></div><a name="N109E5" class="indexterm"></a><p><span class="emphasis"><em>Xpand</em></span>框架还允许您集成新的元模型实现。本节快速概述了为实现元模型必须采取的步骤：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>创建一个实现<code class="classname">MetaModel</code>接口的类。</p></li><li class="listitem"><p>为了能够将元模型集成到Eclipse UI中，您还必须为元模型实现提供元模型贡献者类，以实现<code class="classname">MetaModelContributor</code>或<code class="classname">MetaModelContributor2</code>接口。</p></li><li class="listitem"><p>最后，您必须扩展<code class="classname">org.eclipse.xtend.shared.ui.metaModelContributors</code>扩展点，以便使用Eclipse UI注册元模型贡献者。</p></li></ol></div></div></div></div><div class="section" title="表达式"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="r10_expressions_language"></a>表达式<a name="N10A0A" class="indexterm"></a></h2></div></div></div><p>表达式子语言<a name="N10A0F" class="indexterm"></a>是Java和OCL的语法混合<a name="N10A13" class="indexterm"></a> 。本文档提供了每个可用表达式的详细说明。让我们从一些简单的例子开始。</p><p>进入物业：</p><pre class="programlisting">myModelElement.name</pre><p>访问操作：</p><pre class="programlisting">myModelElement.doStuff（）</pre><p>简单算术：</p><pre class="programlisting">1 + 1 * 2</pre><p>布尔表达式（只是一个例子:-)）：</p><pre class="programlisting">！（'text'.startsWith（'t'）&amp;&amp;！假）</pre><div class="section" title="内置类型的文字和特殊运算符"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_builtin"></a>内置类型的文字和特殊运算符</h3></div></div></div><p>有几个文字<a name="N10A2D" class="indexterm"></a>对于内置类型：</p><div class="section" title="宾语"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_object"></a><code class="classname">Object</code> <a name="N10A37" class="indexterm"></a> <a name="N10A3E" class="indexterm"></a></h4></div></div></div><p>对象自然没有文字，但我们有两个运算符：</p><p>等于：</p><pre class="programlisting">obj1 == obj2</pre><p>不等于：</p><pre class="programlisting">obj1！= obj2</pre></div><div class="section" title="空虚"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_void"></a><code class="classname">Void</code></h4></div></div></div><p>唯一可能的<code class="classname">Void</code>实例是<code class="varname">null</code>引用。因此，我们有一个文字：</p><pre class="programlisting">空值</pre></div><div class="section" title="输入文字"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_typeliterals"></a>输入文字</h4></div></div></div><p>类型的文字只是类型的名称（没有' <code class="filename">.class</code> '后缀等）。例：</p><pre class="programlisting">String //类型字符串my :: special :: Type //的计算结果为'my :: special :: Type'</pre></div><div class="section" title="StaticProperty文字"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_staticproperties"></a> StaticProperty文字</h4></div></div></div><p>静态属性的文字<a name="N10A6E" class="indexterm"></a> （又名枚举文字<a name="N10A74" class="indexterm"></a> ）与类型文字相关：</p><pre class="programlisting">我::颜色:: RED</pre></div><div class="section" title="串"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_string"></a><code class="classname">String</code></h4></div></div></div><p>有两种不同的文字语法（具有相同的语义）：</p><pre class="programlisting">'一个字符串文字'“一个字符串文字”//两个都没关系</pre><p>对于字符串，表达式子语言支持使用串联重载的加号运算符：</p><pre class="programlisting">'我的元素'+ ele.name +'非常酷！“</pre><p>请注意，支持多行字符串。</p></div><div class="section" title="布尔"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_boolean"></a><code class="classname">Boolean</code></h4></div></div></div><p>布尔文字是：</p><pre class="programlisting">真假</pre><p>经营者是：</p><pre class="programlisting">true &amp;&amp; false // AND true ||假//或者！是的//不是</pre></div><div class="section" title="整数和真实"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_numeric"></a> <code class="classname">Integer</code>和<code class="classname">Real</code></h4></div></div></div><p>整数文字的语法如预期：</p><pre class="programlisting">//整数文字3 57278 //真实文字3.0 0.75</pre><p>另外，我们有常见的算术运算符：</p><pre class="programlisting">3 + 4 //加法4  -  5 //减法2 * 6 //乘法3/64 //除数//一元减运算符 -  42  -  47.11</pre><p>此外，众所周知的比较运算符是定义的：</p><pre class="programlisting">4&gt; 5 //大于4 &lt;5 //小于4&gt; = 23 //大于等于4 &lt;= 12 //小于等于</pre></div><div class="section" title="集合"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_builtin_collections"></a>集合</h4></div></div></div><p>列表有一个文字：</p><pre class="programlisting">{1,2,3,4} //一个包含四个整数的列表</pre><p>集合没有其他特殊的具体语法。如果需要一个集合，则必须在列表文字上调用<code class="methodname">toSet()</code>操作：</p><pre class="programlisting">{1,2,4,4} .toSet（）//一个带3的集合（！）整数</pre></div></div><div class="section" title="特别收集业务"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_collection_operations"></a>特别收集业务</h3></div></div></div><p>与OCL一样， <span class="emphasis"><em>Xpand</em></span>表达式子语言定义了对集合的几个特殊操作。但是，这些操作不是类型系统的成员，因此您不能以反射方式使用它们。</p><div class="section" title="选择"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_select"></a><code class="methodname">select<a name="N10AC9" class="indexterm"></a></code></h4></div></div></div><p>有时，表达式会产生一个大集合，但只有一个集合只对该集合的特殊子集感兴趣。表达式子语言具有特殊构造，用于指定特定集合中的选择。这些是<code class="methodname">select</code>和<code class="methodname">reject</code>操作。select指定集合的子集。<code class="methodname">select</code>是对集合的操作，具体如下：</p><pre class="programlisting">collection.select（v | boolean-expression-with-v）</pre><p><code class="methodname">select</code>返回指定集合的子列表。该列表包含对<code class="varname">boolean-expression-with-v</code>结果的求值为<code class="varname">true</code>所有元素。例：</p><pre class="programlisting">{1,2,3,4} .select（i | i&gt; = 3）//返回{3,4}</pre></div><div class="section" title="typeSelect"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_typeselect"></a><code class="methodname">typeSelect</code> <a name="N10AEB" class="indexterm"></a></h4></div></div></div><p>select表达式的特殊版本是<code class="methodname">typeSelect</code> 。这里不提供布尔表达式，而是提供类名。</p><pre class="programlisting">collection.typeSelect（SOMETYPE）</pre><p><code class="methodname">typeSelect</code>返回指定集合的子列表，该子列表仅包含作为指定类的实例的对象（也是继承的）。它等同于表达式</p><pre class="programlisting">collection.select（e | SomeType.isInstance（e））</pre></div><div class="section" title="拒绝"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_reject"></a><code class="methodname">reject<a name="N10B01" class="indexterm"></a></code></h4></div></div></div><p><code class="methodname">reject</code>操作类似于<code class="methodname">select</code>操作，但是对于<code class="methodname">reject</code>我们得到表达式求值为<code class="varname">false</code>的集合的所有元素的子集。<code class="methodname">reject</code>语法与<code class="methodname">select</code>语法相同：</p><pre class="programlisting">collection.reject（v | boolean-expression-with-v）</pre><p>例：</p><pre class="programlisting">{1,2,3,4} .reject（i | i&gt; = 3）//返回{1,2}</pre></div><div class="section" title="搜集"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_collect"></a><code class="methodname">collect<a name="N10B23" class="indexterm"></a></code></h4></div></div></div><p>如上一节所示， <code class="methodname">select</code>和<code class="methodname">reject</code>操作始终会生成原始集合的子集合。有时，人们希望对集合的所有元素应用操作，并在列表中收集评估结果。在这种情况下，我们可以使用<code class="methodname">collect</code>操作。<code class="methodname">collect</code>操作使用与<code class="methodname">select</code>和<code class="methodname">reject</code>相同的语法，并按如下方式编写：</p><pre class="programlisting">collection.collect（v | expression-with-v）</pre><p><code class="methodname">collect</code>再次遍历目标集合并评估每个元素上的给定表达式。与<code class="methodname">select</code>相反，评估结果收集在列表中。迭代完成后，将返回包含所有结果的列表。例：</p><pre class="programlisting">namedElements.collect（ne | ne.name）//返回一个名为Elements.collect的字符串列表（ne | ne.name.length&gt; 3）//返回一个布尔列表</pre></div><div class="section" title="收集的简写（以及更多）"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_collect_shorthand"></a> <code class="methodname">collect</code>简写（以及更多）</h4></div></div></div><p>由于通过许多对象的导航非常常见，因此有一个简写表示收集<a name="N10B4E" class="indexterm"></a>这使表达式更具可读性。代替</p><pre class="programlisting">self.employee.collect（e | e.birthdate）</pre><p>一个人也可以写：</p><pre class="programlisting">self.employee.birthdate</pre><p>通常，当一个属性被应用到对象的集合，它会自动被解释为<code class="methodname">collect</code>在所述收集的具有指定属性的成员。</p><p>如果要素本身不返回集合，则语法是<code class="methodname">collect</code>的简写。但有时候我们有以下几点：</p><pre class="programlisting">self.buildings.rooms.windows //返回一个窗口列表</pre><p>这种语法有效，但无法使用<code class="methodname">collect</code>操作以简单的方式表达它。</p></div><div class="section" title="对全部"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_forall"></a><code class="methodname">forAll</code></h4></div></div></div><p>通常必须为集合中的所有元素计算布尔表达式。<code class="methodname">forAll</code> <a name="N10B72" class="indexterm"></a> operation允许指定一个布尔表达式，对于集合中的所有对象，该表达式必须为<code class="varname">true</code>才能使<code class="methodname">forAll</code>操作返回<code class="varname">true</code> ：</p><pre class="programlisting">collection.forAll（v | boolean-expression-with-v）</pre><p>结果<code class="methodname">forAll</code>是<code class="varname">true</code> ，如果<code class="varname">boolean-expression-with-v</code>是<code class="varname">true</code>为所有包含在集合中的元素。如果<code class="varname">boolean-expression-with-v</code>是<code class="varname">false</code>的一个或多个集合中的元素，则<code class="methodname">forAll</code>表达式评估为<code class="varname">false</code> 。</p><h5><a name="N10B9B"></a>例：</h5><pre class="programlisting">{3,4,500} .forAll（i | i &lt;10）//评估为假（500 &lt;10为假）</pre></div><div class="section" title="存在"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_exists"></a><code class="methodname">exists<a name="N10BA4" class="indexterm"></a></code></h4></div></div></div><p>通常，您需要知道集合中是否至少有一个元素，其布尔值为<code class="varname">true</code> 。exists操作允许您指定一个布尔表达式，该表达式对于集合中的至少一个对象必须为<code class="varname">true</code> ：</p><pre class="programlisting">collection.exists（v | boolean-expression-with-v）</pre><p>的结果存在操作是<code class="varname">true</code>如果<code class="varname">boolean-expression-with-v</code>是<code class="varname">true</code>集合中的至少一种元素为。如果集合中的所有元素的<code class="varname">boolean-expression-with-v</code>为<code class="varname">false</code> ，则完整表达式的计算结果为<code class="varname">false</code> 。</p><h5><a name="N10BC5"></a>例：</h5><pre class="programlisting">{3,4,500} .exists（i | i &lt;10）//求值为真（例如3 &lt;10）</pre></div><div class="section" title="排序方式"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_collection_sortby"></a><code class="methodname">sortBy</code></h4></div></div></div><p>如果要对元素列表进行排序，可以使用高阶函数<code class="methodname">sortBy</code> <a name="N10BD3" class="indexterm"></a> 。您调用<code class="methodname">sortBy</code>操作的列表按给定表达式的结果排序。</p><h5><a name="N10BDA"></a>例：</h5><pre class="programlisting">myListOfEntity.sortBy（entity | entity.name）</pre><p>在该示例中，实体列表按实体的名称排序。请注意， <span class="emphasis"><em>Xpand中</em></span>没有这样的<code class="classname">Comparable</code>类型。如果从表达式返回的值是<code class="classname">java.util.实例<code class="classname">java.util.Comparable</code>使用<code class="methodname">compareTo</code>方法，否则调用<code class="methodname">toString()</code>并使用结果。</p><p>以下所有表达式都返回<code class="varname">true</code> ：</p><pre class="programlisting">{'C'，'B'，'A'}。sortBy（e | e）== {'A'，'B'，'C'} {'AAA'，'BB'，'C'}。sortBy （e | e.length）== {'C'，'BB'，'AAA'} {5,3,1,2} .sortBy（e | e）== {1,2,3,5} { 5,3,1,2} .sortBy（e | e  -  2 * e）== {5,3,2,1} ...</pre></div></div><div class="section" title="如果表达"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_if"></a> <code class="methodname">if</code>表达</h3></div></div></div><a name="N10BFC" class="indexterm"></a><p>有两种不同形式的条件表达式。第一个是所谓的<span class="emphasis"><em>if表达式</em></span> 。句法：</p><pre class="programlisting">条件？thenExpression：elseExpression</pre><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">名称 ！= null？名称：'未知'</pre><p>或者，您也可以写：</p><pre class="programlisting">如果名字！= null然后命名其他'未知'</pre></div><div class="section" title="切换表达式"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_switch"></a> <code class="methodname">switch</code>表达式</h3></div></div></div><a name="N10C18" class="indexterm"></a><p>另一个称为<span class="emphasis"><em>切换表达式</em></span> 。句法：</p><pre class="programlisting">switch（表达式）{（case expression：thenExpression）* default：catchAllExpression}</pre><p>默认部分是必需的，因为<code class="methodname">switch</code>是一个表达式，因此它需要在任何情况下评估。</p><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">switch（person.name）{case'Hansen'：'Du kanns platt schnacken'默认：'Du kanns mi nech verstohn！'}</pre><p><span class="emphasis"><em>布尔</em></span>表达式有一个缩写：</p><pre class="programlisting">switch {case booleanExpression：thenExpression default：catchAllExpression}</pre></div><div class="section" title="链表达"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_chain"></a>链表达</h3></div></div></div><a name="N10C3A" class="indexterm"></a><p>表达式和函数式语言应尽可能没有副作用。但有时你需要有副作用的调用。在某些情况下，表达式甚至没有返回类型（即返回类型为<code class="classname">Void</code> ）。如果需要调用此类操作，可以使用链表达式。</p><p><span class="bold"><strong>句法：</strong></span></p><pre class="programlisting">anExpr  - &gt; anotherExpr  - &gt; lastExpr</pre><p>每个表达式按顺序计算，但仅返回最后一个表达式的结果。</p><p><span class="bold"><strong>示例</strong></span> ：</p><pre class="programlisting">person.setName（'test'） - &gt; person</pre><p>此链表达式将在返回person对象本身之前首先设置该人的<code class="varname">name</code> 。</p></div><div class="section" title="新的表达"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_create"></a> <code class="methodname">new</code>表达</h3></div></div></div><a name="N10C5E" class="indexterm"></a><p><code class="methodname">new</code>表达式用于实例化给定类型的新对象：</p><pre class="programlisting">新的TypeName</pre><p>请注意， <a class="link" href="#">创建扩展</a>通常是用于模型转换时实例化对象的更好方法。</p></div><div class="section" title="&#39;GLOBALVAR&#39;表达"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_globalvar"></a> 'GLOBALVAR'表达</h3></div></div></div><p>有时您不希望通过参数将所有内容传递给调用堆栈。因此，我们有<code class="methodname">GLOBALVAR</code> <a name="N10C79" class="indexterm"></a>表达。要使用全局变量，您需要做两件事。</p><div class="section" title="使用GLOBALVARS配置工作流程"><div class="titlepage"><div><div><h4 class="title"><a name="r10_expressions_globalvar_workflow"></a>使用GLOBALVARS配置工作流程</h4></div></div></div><p>使用表达式框架（ <span class="emphasis"><em>Xpand</em></span> ， <span class="emphasis"><em>Check</em></span>和<span class="emphasis"><em>Xtend</em></span> ）的每个工作流组件都可以使用全局变量进行配置。
        <a name="N10C8C" class="indexterm"></a>这是一个例子：</p><pre class="programlisting">&lt;workflow&gt; .... stuff &lt;component class =“org.eclipse.xpand2。生成器“&gt; ...通常的东西（参见参考文档）&lt;globalVarDef name =”MyPSM“value =”slotNameOfPSM“/&gt; &lt;globalVarDef name =”ImplClassSuffix“value =”'Impl'“/&gt; &lt;/ component&gt; &lt;/ workflow &gt;</pre><p>请注意， <code class="varname">value</code>包含表达式或插槽名称。如果要传递字符串值，则必须引用该值，例如示例中的<code class="classname">ImplClassSuffix</code>的值。</p><p>如果已将全局变量注入相应的组件，则可以使用以下语法调用它们：</p><pre class="programlisting">GLOBALVAR ImplClassSuffix</pre><p>注意，我们没有任何静态类型信息。因此假设<code class="classname">Object</code> 。因此，您必须将全局变量向下转换为预期类型：</p><pre class="programlisting">（（String）GLOBALVAR ImplClassSuffix）</pre><p>最好使用Extension键入一次，然后始终引用该扩展名：</p><pre class="programlisting">String implClassSuffix（）：GLOBALVAR ImplClassSuffix; //使用类型化的全局var扩展名ImplName（Class c）：name + implClassSuffix（）;</pre></div></div><div class="section" title="多种方法（多次发送）"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_multidispatch"></a>多种方法（多次发送）</h3></div></div></div><p>表达式语言支持多个调度<a name="N10CB1" class="indexterm"></a> 。这意味着当存在一堆重载操作时，决定哪个操作必须解决是基于所有参数的动态类型（包含隐式' <code class="varname">this</code> '）。</p><p>在Java中，只考虑' <code class="varname">this</code> '元素的动态类型，对于使用静态类型的参数（这称为单调度）。</p><p>这是一个Java示例：</p><pre class="programlisting">class MyType {boolean equals（Object o）{if（o instanceof MyClass）{return equals（（MyClass）o）; } return super.equals（o）; } boolean equals（MyType mt）{//实现...}}</pre><p>如果Java支持多个调度，则不必覆盖<code class="methodname">equals(Object o)</code>的方法。</p></div><div class="section" title="铸件"><div class="titlepage"><div><div><h3 class="title"><a name="r10_expressions_casting"></a>铸件<a name="N10CCB" class="indexterm"></a></h3></div></div></div><p>表达式语言是静态类型检查的。虽然有许多概念可以帮助程序员获得非常好的静态类型信息。人们比系统更了解真实的类型。为了明确地给系统提供这样的信息强制转换是可用的。<span class="emphasis"><em>演员是100％静态的，所以你不需要它们，如果你从来没有静态地检查你的表情！</em></span></p><p>强制转换的语法非常类似于Java：</p><pre class="programlisting">（（字符串）unTypedList.get（0））。toUpperCase（）</pre></div><div class="section" title="Xpand关键字和元模型属性"><div class="titlepage"><div><div><h3 class="title"><a name="N10CD6"></a> Xpand关键字和元模型属性<a name="N10CD9" class="indexterm"></a></h3></div></div></div><p>当元模型属性的名称与<span class="emphasis"><em>Xpand</em></span>或<span class="emphasis"><em>Xtend</em></span>关键字冲突时，将解决冲突以支持关键字。要在这些情况下引用元模型属性，其名称前面必须带有“ <code class="varname">^</code> ”字符。</p><p>例：</p><pre class="programlisting">private String foo（Import ^ import）：^ import.name;</pre></div></div><div class="section" title="校验"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Check_language"></a> <span class="emphasis"><em>校验</em></span></h2></div></div></div><div class="section" title="检查语言的描述"><div class="titlepage"><div><div><h3 class="title"><a name="Check_language_description"></a> <span class="emphasis"><em>检查</em></span>语言的描述</h3></div></div></div><p><span class="emphasis"><em>Xpand</em></span>还提供了一种指定约束的语言<a name="N10CFF" class="indexterm"></a>该模型必须满足才能正确。这种语言很容易理解和使用。基本上，它是围绕表达式语法构建的，已在上一节中详细讨论过。<span class="emphasis"><em>Check中</em></span>指定的约束<a name="N10D06" class="indexterm"></a>语言必须存储在文件扩展名为<code class="filename">.chk</code>的文件中<a name="N10D0F" class="indexterm"></a><a name="N10D12" class="indexterm"></a> 。此外，这些文件必须位于Java类路径上，当然，为了找到它们。让我们看一个例子，以了解这些约束的样子和它们的作用：</p><pre class="programlisting">进口数据; context属性ERROR“名称长度必须超过一个字符。” ：name.length&gt; 1;</pre><p>现在，让我们逐行查看示例：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>首先，必须导入元模型。</p></li><li class="listitem"><p>然后，指定约束适用的上下文。换句话说，在<code class="code">context</code>关键字之后，我们放置将由约束检查的元类的名称。然后，出现<code class="code">ERROR</code>或<code class="code">WARNING</code> ，这些关键字指定在约束失败时将采取的操作类型：</p><div class="table"><a name="N10D2C"></a><p class="title"><b>表7。<span class="emphasis"><em>检查</em></span>约束的操作类型</b></p><div class="table-contents"><table border="1" summary="Types of action for Check
                constraints"><colgroup><col><col></colgroup><tbody><tr><td><code class="code">警告</code></td><td>如果约束失败，则打印指定的消息，但不会停止工作流程执行。</td></tr><tr><td><code class="code">错误</code></td><td>如果约束失败，则打印指定的消息并停止所有进一步处理。</td></tr></tbody></table></div></div><p><br class="table-break"></p></li><li class="listitem"><p>现在，在约束失败的情况下放置的消息被指定为字符串。可以在消息中包含属性值或函数的返回值，以使消息更清晰。例如，可以通过重写它来改进上面的例子：</p><pre class="programlisting">进口数据; context属性ERROR“名称'”+名称+“太短。名称长度不得超过一个字符。“：name.length&gt; 1;</pre></li><li class="listitem"><p>最后，有一个条件本身，它由一个表达式指定，这已在前一节中详细讨论过。如果此表达式为<code class="varname">true</code> ，则满足约束。</p></li></ol></div><div class="important" title="重要" style="margin-left:0.38in;margin-right:0.38in"><table border="0" summary="Important"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[重要]" src="images/important.gif"></td><th align="left"></th></tr><tr><td valign="top" align="left"><p>请始终记住，如果约束的条件为<code class="varname">false</code> ，则打印与约束关联的消息！因此，如果指定的约束条件为<code class="varname">true</code> ，则不打印任何内容并且将满足约束。</p></td></tr></table></div><div class="section" title="警卫条件"><div class="titlepage"><div><div><h4 class="title"><a name="Guard_conditions"></a>警卫条件</h4></div></div></div><p><span class="emphasis"><em>Xpand</em></span>的<span class="emphasis"><em>Check</em></span>语言也提供了所谓的<a name="N10D6A" class="indexterm"></a> 。这些条件允许仅将检查约束应用于满足特定条件的模型元素。通过向check约束添加<span class="emphasis"><em>if</em></span>子句来指定这样的保护条件。必须在<span class="emphasis"><em>context</em></span>子句之后添加<span class="emphasis"><em>if</em></span>子句，如以下示例所示：</p><pre class="programlisting">进口数据; context属性if name.length&gt; 1 ERROR“属性名称必须以'a'开头”：name.startsWith（“a”）;</pre></div></div><div class="section" title="工作流组件CheckComponent"><div class="titlepage"><div><div><h3 class="title"><a name="check_checkcomponent"></a>工作流组件<span class="emphasis"><em>CheckComponent</em></span></h3></div></div></div><p>工作流组件<code class="classname">org.eclipse.xtend.check.CheckComponent</code>允许使用使用MWE的<span class="emphasis"><em>Check</em></span> into建模工作流程来集成模型验证约束。</p><p>该组件提供以下配置属性：</p><div class="table"><a name="properties_checkcomponent"></a><p class="title"><b>表8。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="left">财产名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code class="varname">checkFile</code></td><td align="left">此属性允许将包含以<span class="emphasis"><em>Check</em></span>语言编写的约束的文件添加到验证组件。</td></tr><tr><td align="left"><code class="varname">emfAllChildrenSlot</code></td><td align="left">包含EMF对象的工作流槽的名称，必须对其进行验证，包括其包含的所有子元素。<span class="emphasis"><em>此属性仅与基于EMF的模型一起使用。</em></span></td></tr><tr><td align="left"><code class="varname">表达</code></td><td align="left">此属性允许为验证组件设置检查表达式。<span class="strong"><strong>此属性仅与非EMF模型一起使用。</strong></span></td></tr><tr><td align="left"><code class="varname">abortOnError</code></td><td align="left">此布尔属性确定在其中一个验证约束失败时是否中止工作流。</td></tr><tr><td align="left"><code class="varname">warnIfNothingChecked</code></td><td align="left">如果此布尔属性设置为<span class="emphasis"><em>true</em></span> ，则在没有验证检查时将生成警告。否则，不会发出警告。</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="的Xtend"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Xtend_language"></a> <span class="emphasis"><em>的Xtend</em></span></h2></div></div></div><a name="N10DCF" class="indexterm"></a><p>像表达式子语言一样，它总结了<span class="emphasis"><em>Xpand</em></span>框架提供的所有其他文本语言的表达式语法，还有另一种常用语言<span class="emphasis"><em>Xtend</em></span> 。</p><p>该语言提供了定义独立操作和非侵入式元模型扩展的丰富库的可能性<a name="N10DDE" class="indexterm"></a>基于Java方法或<span class="emphasis"><em>Xtend</em></span>表达式。可以从基于表达式框架的所有其他文本语言引用这些库。</p><div class="section" title="Xtend文件"><div class="titlepage"><div><div><h3 class="title"><a name="N10DE7"></a> Xtend文件</h3></div></div></div><a name="N10DEA" class="indexterm"></a><p><a name="N10DEE" class="indexterm"></a> Xtend文件必须驻留在已使用的执行上下文的Java类路径中。文件扩展名必须为<code class="filename">*.ext</code> 。我们来看看Xend文件。</p><pre class="programlisting">import my :: metamodel; extension other :: ExtensionFile; / ** * Documentation * / anExpressionExtension（String stringParam）：doingStuff（with（stringParam））; / ** * java扩展只是映射* / String aJavaExtension（String param）：JAVA my。JavaClass.staticMethod（java.lang中。String）;</pre><p>该示例显示以下语句：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>进口报表</p></li><li class="listitem"><p>扩展导入语句</p></li><li class="listitem"><p>表达式或java扩展</p></li></ol></div></div><div class="section" title="评论"><div class="titlepage"><div><div><h3 class="title"><a name="N10E05"></a>评论<a name="N10E08" class="indexterm"></a></h3></div></div></div><p>我们有单行和多行评论。单行注释的语法是：</p><pre class="programlisting">//我的评论</pre><p>多行注释的写法如下：</p><pre class="programlisting">/ *我的多行评论* /</pre></div><div class="section" title="导入语句"><div class="titlepage"><div><div><h3 class="title"><a name="N10E15"></a>导入语句</h3></div></div></div><p>使用导入<a name="N10E1A" class="indexterm"></a>语句一可以导入不同类型的名称空间。（参见表达式框架参考文档）。</p><p>语法是：</p><pre class="programlisting">import my :: imported :: namespace;</pre><p>Xtend不支持静态导入或任何类似的概念。因此，以下是不正确的语法：</p><pre class="programlisting">import my :: imported :: namespace :: *; //错！import my :: Type; //错！</pre></div><div class="section" title="扩展进口声明"><div class="titlepage"><div><div><h3 class="title"><a name="N10E26"></a>扩展进口声明</h3></div></div></div><a name="N10E29" class="indexterm"></a><p>您可以使用扩展语句导入另一个Xtend文件。语法是：</p><pre class="programlisting">extension fully :: qualified :: ExtensionFileName;</pre><p>请注意，未指定文件扩展名（ <code class="filename">*.ext</code> ）。</p><div class="section" title="重新导出扩展"><div class="titlepage"><div><div><h4 class="title"><a name="N10E35"></a>重新导出扩展</h4></div></div></div><p>如果要将扩展名从其他扩展文件与本地扩展名一起导出，可以添加关键字<code class="methodname">reexport</code> <a name="N10E3D" class="indexterm"></a>到相应的扩展导入语句的末尾。</p><pre class="programlisting">extension fully :: qualified :: ExtensionFileName reexport;</pre></div></div><div class="section" title="扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N10E43"></a>扩展</h3></div></div></div><p>简单表达式扩展的语法如下：</p><pre class="programlisting">ReturnType extensionName（ParamType1 paramName1，ParamType2 ...）：expression-using-params;</pre><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">String getterName（NamedElement ele）：'get'+ ele.name.firstUpper（）;</pre><div class="section" title="扩展调用"><div class="titlepage"><div><div><h4 class="title"><a name="N10E50"></a>扩展调用<a name="N10E53" class="indexterm"></a></h4></div></div></div><p>如何调用扩展有两种不同的方法。它可以像函数一样调用：</p><pre class="programlisting">getterName（myNamedElement）</pre><p>调用扩展的另一种方法是通过“成员语法”：</p><pre class="programlisting">myNamedElement.getterName（）</pre><p>对于成员语法中的任何调用，目标表达式（成员）将映射到第一个参数。因此，两种句法形式都做同样的事情。</p><p>重要的是要理解扩展不是类型系统的成员，因此，它们不能通过反射访问，并且您不能使用它们专门化或覆盖操作。</p><p>表达式评估引擎在查找扩展名之前首先查找适当的操作，换句话说，操作具有更高的优先级。</p></div><div class="section" title="类型推断"><div class="titlepage"><div><div><h4 class="title"><a name="N10E66"></a>类型推断<a name="N10E69" class="indexterm"></a></h4></div></div></div><p>对于大多数扩展，您不需要指定返回类型， <a name="N10E6E" class="indexterm"></a>因为它可以从指定的表达式派生。特别的是，这种扩展的静态返回类型取决于使用的上下文。</p><p>例如，如果您有以下扩展名</p><pre class="programlisting">asList（Object o）：{o};</pre><p>调用</p><pre class="programlisting">asList（ '文本'）</pre><p>具有静态类型<code class="classname">List[String]</code> 。这意味着你可以打电话</p><pre class="programlisting">asList（ '文本'）。得到（0）.toUpperCase（）</pre><p>表达式是静态类型安全的，因为它的返回类型是自动派生的。</p><p>即使您明确指定“ <code class="classname">Void</code> ”，也<span class="emphasis"><em>始终</em></span>存在返回值，无论您是否指定它。</p><p>请参阅以下示例。</p><pre class="programlisting">modelTarget.ownedElements.addAllNotNull（modelSource.contents.duplicate（））</pre><p>在此示例中， <code class="methodname">duplicate()</code>多态方式调度<a name="N10E94" class="indexterm"></a> 。其中两个扩展可能如下所示：</p><pre class="programlisting">虚空重复（Realization realization）：实现。Specifier（）。duplicate（） - &gt;实现。Realizer（）。duplicate（）; create target :: Class duplicate（source :: Class）：...;</pre><p>如果“ <code class="classname">Realization</code> ”包含在“ <code class="methodname">contents</code> ”的“名单<code class="varname">modelSource</code> ”中，“ <code class="methodname">Realizer</code>的”的“ <code class="classname">Realization</code> ”将被添加到“ <code class="varname">ownedElements</code>了“的名单<code class="varname">modelTarget</code> ”。如果您不想添加包含的元素是“实现”的情况，您可以将扩展名更改为：</p><pre class="programlisting">虚空重复（Realization realization）：实现。Specifier（）。duplicate（） - &gt;实现。Realizer（）。duplicate（） - &gt; {};</pre></div><div class="section" title="递归"><div class="titlepage"><div><div><h4 class="title"><a name="N10EB3"></a>递归</h4></div></div></div><p>只有一个例外：对于递归扩展<a name="N10EB8" class="indexterm"></a><a name="N10EBB" class="indexterm"></a>无法推断返回类型，因此您需要明确指定它：</p><pre class="programlisting">String fullyQualifiedName（NamedElement n）：n.parent == null？n.name：fullyQualifiedName（n.parent）+'::'+ n.name;</pre><p>递归扩展在静态上下文中是非确定性的，因此，必须指定返回类型。</p></div><div class="section" title="缓存扩展"><div class="titlepage"><div><div><h4 class="title"><a name="N10EC5"></a>缓存扩展<a name="N10EC8" class="indexterm"></a></h4></div></div></div><p>如果您经常调用没有副作用的扩展，您希望缓存每组参数的结果，以提高性能。你可以添加关键字' <code class="code">cached</code> ' <a name="N10ED2" class="indexterm"></a>扩展以实现这一目标：</p><pre class="programlisting">cached String getterName（NamedElement ele）：'get'+ ele.name.firstUpper（）;</pre><p>该<code class="methodname">getterName</code>将为每个被计算一次<code class="classname">NamedElement</code> 。</p></div><div class="section" title="私人扩展"><div class="titlepage"><div><div><h4 class="title"><a name="N10EE0"></a>私人扩展<a name="N10EE3" class="indexterm"></a></h4></div></div></div><p>默认情况下，所有扩展都是公共的，即它们在扩展文件外部可见。如果您想要隐藏扩展程序，可以添加关键字“ <code class="methodname">private</code> ” <a name="N10EED" class="indexterm"></a>在他们面前：</p><pre class="programlisting">private internalHelper（NamedElement ele）：//实现....;</pre></div></div><div class="section" title="Java扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N10EF3"></a> Java扩展</h3></div></div></div><p>在某些情况下，人们确实希望从表达式内部调用Java方法。这可以通过提供Java扩展来完成<a name="N10EF8" class="indexterm"></a><a name="N10EFB" class="indexterm"></a> ：</p><pre class="programlisting">Void myJavaExtension（String param）：JAVA my。Type.someMethod（java.lang中。String）;</pre><p>签名与任何其他扩展名相同。它的语法是：</p><pre class="programlisting">JAVA完全合格。Type.someMethod（我的。ParamType1，我的。ParamType2，...）;</pre><p>请注意，您不能使用任何导入的命名空间。您必须以完全限定的方式指定类型，方法和参数类型。</p><p><span class="bold"><strong>例：</strong></span></p><p>如果已定义以下Java扩展：</p><pre class="programlisting">String concat（String a，String b）：JAVA my。Helper.concat（java.lang中。String，java.lang。串）;</pre><p>并且您有以下Java类：</p><pre class="programlisting">打包我; public class Helper {public String concat（String a，String b）{return a + b; }}</pre><p>表达式</p><pre class="programlisting">concat（'你好'，'世界！“）”你好“.concat（'世界！“）</pre><p>两个结果都是调用Java方法<code class="methodname">void concat(String a, String b).</code></p><div class="section" title="静态与非静态调用"><div class="titlepage"><div><div><h4 class="title"><a name="N10F1D"></a>静态与非静态调用</h4></div></div></div><p>Java扩展的实现被重定向到Java类中的公共方法。如果该方法未声明为static，则需要Java类具有默认构造函数。Xtend将为每次调用实例化该类。</p></div><div class="section" title="IExecutionContextAware"><div class="titlepage"><div><div><h4 class="title"><a name="N10F22"></a> IExecutionContextAware<a name="N10F25" class="indexterm"></a></h4></div></div></div><p>使用Java扩展可以访问ExecutionContext <a name="N10F2A" class="indexterm"></a> ，它可以检索有关调用的详细运行时信息。要在Java扩展中使用当前的ExecutionContext，该类必须实现<code class="classname">org.eclipse.xtend.expression.IExecutionContextAware</code></p><pre class="programlisting">public interface IExecutionContextAware {void setExecutionContext（ExecutionContext ctx）; }</pre><p>调用的方法不能是静态的。</p></div></div><div class="section" title="创建扩展（模型转换）"><div class="titlepage"><div><div><h3 class="title"><a name="create_extension"></a>创建扩展（模型转换）</h3></div></div></div><p><span class="emphasis"><em>Xtend</em></span>语言支持对模型转换的额外支持<a name="N10F3E" class="indexterm"></a> 。这个概念叫做<span class="emphasis"><em>创建扩展</em></span>和<a name="N10F45" class="indexterm"></a><a name="N10F4A" class="indexterm"></a>它像往常一样被解释得更加全面。</p><p>模型中包含的元素通常被多次引用。考虑以下模型结构：</p><pre class="programlisting">P / \ C1 C2 \ / R.</pre><p>包<code class="varname">P</code>包含两个类<code class="varname">C1</code>和<code class="varname">C2</code> 。<code class="varname">C1</code>包含<code class="varname">C2</code>类型的参考<code class="varname">R</code> （ <code class="varname">P</code>也参考<code class="varname">C2</code> ）。</p><p>我们可以编写以下扩展，以便将Ecore（EMF）模型转换为我们的元模型（Package，Class，Reference）。</p><pre class="programlisting">package toPackage（EPackage x）：let p = new Package：p.ownedMember.addAll（x.eClassifiers.toClass（）） - &gt; p; class toClass（EClass x）：let c = new Class：c.attributes.addAll（x.eReferences.toReference（）） - &gt; c;引用引用（EReference x）：令r = new引用：r.setType（x.eType.toClass（）） - &gt; r;</pre><p>对于具有上述结构的Ecore模型，结果将是：</p><pre class="programlisting">P / \ C1 C2 | R  -  C2</pre><p>发生了什么？<code class="varname">C2</code>类已创建2次（包含限制一次，参考<code class="varname">R</code>另一次也引用<code class="varname">C2</code> ）。我们可以通过添加' <code class="methodname">cached</code> '关键字来解决问题<a name="N10F82" class="indexterm"></a>到第二个扩展：</p><pre class="programlisting">缓存toClass（EClass x）：let c = new Class：c.attributes.addAll（c.eAttributes.toAttribute（）） - &gt; c;</pre><p>过程如下：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开始创造<code class="varname">P</code></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>开始创建<code class="varname">C1</code> （包含在<code class="varname">P</code> ）</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem"><p>开始创建<code class="varname">R</code> （包含在<code class="varname">C1</code> ）</p><div class="orderedlist"><ol class="orderedlist" type="A"><li class="listitem"><p>开始创建<code class="varname">C2</code> （从<code class="varname">R</code>引用）</p></li><li class="listitem"><p>结束（结果<code class="varname">C2</code>被缓存）</p></li></ol></div></li><li class="listitem"><p>结束<code class="varname">R</code></p></li></ol></div></li><li class="listitem"><p>结束<code class="varname">C1</code></p></li><li class="listitem"><p>开始获取缓存<code class="varname">C2</code> （包含在<code class="varname">P</code> ）</p></li></ol></div></li><li class="listitem"><p>结束P.</p></li></ol></div><p>所以这很有效。我们将获得预期的结构。但是循环依赖呢？例如， <code class="varname">C2</code>可以包含<code class="varname">C1</code>类型的<code class="classname">Reference</code> <code class="varname">R2</code> （双向引用）：</p><p>转换将发生如下：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开始创造<code class="varname">P</code></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>开始创建<code class="varname">C1</code> （包含在<code class="varname">P</code> ）</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem"><p>开始创建<code class="varname">R</code> （包含在<code class="varname">C1</code> ）</p><div class="orderedlist"><ol class="orderedlist" type="A"><li class="listitem"><p>开始创建<code class="varname">C2</code> （从<code class="varname">R</code>引用）</p><div class="orderedlist"><ol class="orderedlist" type="I"><li class="listitem"><p>开始创建<code class="varname">R2</code> （包含在<code class="varname">C2</code> ）</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开始创建<code class="varname">C1</code> （从<code class="varname">R1</code>引用）......OOPS！</p></li></ol></div></li></ol></div></li></ol></div></li></ol></div></li></ol></div></li></ol></div><p><code class="varname">C1</code>已经在创建，并且在堆栈减少之前不会完成。僵局！问题是缓存缓存了返回值，但到目前为止还没有返回<code class="varname">C1</code> ，因为它仍处于构造状态。</p><p>解决方案：创建扩展！</p><p>语法如下：</p><pre class="programlisting">create Package toPackage（EPackage x）：this.classifiers.addAll（x.eClassifiers.toClass（））; create class toClass（EClass x）：this.attributes.addAll（x.eReferences.toReference（））; create referenceReference（EReference x）：this.setType（x.eType.toClass（））;</pre><p>这不仅是一种较短的语法，而且还具有所需的语义：在评估主体之前，创建的模型元素将被添加到缓存中。返回值始终是对已创建且可能未完全初始化元素的引用。</p></div><div class="section" title="从Java调用扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N11023"></a>从Java调用扩展</h3></div></div></div><p>上一节介绍了如何在Java中实现Extensions。本节介绍如何从Java调用Extensions。<a name="N11028" class="indexterm"></a></p><pre class="programlisting">// setup XtendFacade f = XtendFacade.create（“my :: path :: MyExtensionFile”）; //使用f.call（“sayHello”，new Object [] {“World”}）;</pre><p>被调用的扩展文件如下所示：<a name="N1102F" class="indexterm"></a></p><pre class="programlisting">sayHello（String s）：“你好”+ s;</pre><p>此示例仅使用<code class="classname">BuiltinMetaModel</code>功能，在本例中为<code class="classname">StringTypeImpl</code>的“ <code class="methodname">+</code> ”功能。</p><p>这是另一个使用<code class="classname">JavaBeansMetaModel</code>示例<a name="N11045" class="indexterm"></a>战略。此策略提供了附加功能：使用getter和setter方法访问属性。</p><p>有关类型系统的更多信息，请参阅<span class="emphasis"><em><a class="xref" href="#r10_expressions_language" title="表达式">表达式</a></em></span>参考文档。</p><p>我们有一个类似JavaBean的元模型类：</p><pre class="programlisting">打包我的包装; public class MyBeanMetaClass {private String myProp; public String getMyProp（）{return myProp; public void setMyProp（String s）{myProp = s;}}</pre><p>除了内置的元模型类型系统，我们还注册了<code class="classname">JavaMetaModel</code> <a name="N11057" class="indexterm"></a>使用<code class="classname">JavaBeansStrategy</code> <a name="N1105D" class="indexterm"></a>对于我们的门面。现在，我们也可以在我们的扩展中使用此策略：</p><pre class="programlisting">// setup facade XtendFacade f = XtendFacade.create（“myext :: JavaBeanExtension”）; //设置其他类型系统JavaMetaModel jmm = new JavaMetaModel（“JavaMM”，new JavaBeansStrategy（））; f.registerMetaModel（JMM）; //使用Facade MyBeanMetaClass jb = MyBeanMetaClass（）; jb.setMyProp（ “测试”）; f.call（“readMyProp”，new Object [] {jb}））;</pre><p>被调用的扩展文件如下所示：</p><pre class="programlisting">进口包装; readMyProp（MyBeanMetaClass jb）：jb.myProp;</pre></div><div class="section" title="WorkflowComponent"><div class="titlepage"><div><div><h3 class="title"><a name="N11067"></a> WorkflowComponent<a name="N1106A" class="indexterm"></a></h3></div></div></div><p>通过对模型转换的额外支持，在工作流中调用<span class="emphasis"><em>Xtend</em></span>是有意义的。<span class="emphasis"><em>Xtend</em></span>组件的典型工作流配置<a name="N11075" class="indexterm"></a>看起来像这样：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel1.ecore“/&gt; &lt;/ metamodel&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.type.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel2.ecore“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”my :: example :: Trafo :: transform（inputSlot）“/&gt; &lt;outputSlot value =”transformedModel“/&gt; &lt;/组件&gt;</pre><p>请注意，您可以混合使用任何类型的元模型（不仅仅是EMF元模型）。</p></div><div class="section" title="Xtend中面向方面的编程"><div class="titlepage"><div><div><h3 class="title"><a name="N1107E"></a> <span class="emphasis"><em>Xtend中</em></span>面向方面的编程<a name="N11083" class="indexterm"></a><a name="N11086" class="indexterm"></a></h3></div></div></div><p>使用工作流引擎，现在可以打包（例如zip）一个书面生成器并将其作为一种黑盒子传送。如果您想使用这样的生成器但需要在不修改任何代码的情况下更改某些内容，则可以使用<span class="emphasis"><em>Xtend</em></span>支持的建议。</p><p>编织以下建议<a name="N11090" class="indexterm"></a>围绕名称以' <span class="package">my :: generator ::</span> '开头的扩展的每次调用：</p><pre class="programlisting">我的:: generator :: *（*）：log（'Invoking'+ ctx.name） - &gt; ctx.proceed（）;</pre><p>周围的建议<a name="N1109B" class="indexterm"></a>让您以非侵入方式更改行为（您不需要触摸打包的扩展）。</p><div class="section" title="加入Point和Point Cut语法"><div class="titlepage"><div><div><h4 class="title"><a name="N1109F"></a>加入Point和Point Cut语法</h4></div></div></div><p>方面取向基本上是将代码编织到软件模块的调用图内的不同点。这些点称为<span class="emphasis"><em>连接点</em></span> 。在<span class="emphasis"><em>Xtend中</em></span> ，连接点是扩展调用（请注意， <span class="emphasis"><em>Xpand</em></span>提供了类似的功能，请参阅<span class="emphasis"><em>Xpand</em></span>文档）。</p><p>一个指定哪个连接点<a name="N110B2" class="indexterm"></a>应该通过在所有可用连接点上指定类似“查询”的内容来执行提供的代码。这种查询称为切点。<a name="N110B6" class="indexterm"></a></p><pre class="programlisting">围绕[切入点]：表达;</pre><p>切入点由完全限定名称和参数声明列表组成。</p><div class="section" title="扩展名称"><div class="titlepage"><div><div><h5 class="title"><a name="N110BD"></a>扩展名称</h5></div></div></div><p>切入点的扩展名称部分必须与连接点定义的完全限定名称匹配。这些表达式区分大小写。星号字符用于指定通配符。</p><p>一些例子：</p><pre class="programlisting">my :: Extension :: definition //具有指定名称的扩展名org :: eclipse :: xpand2 :: * //扩展名前缀为'org :: eclipse :: xpand2 ::'* Operation * //包含单词'的扩展名操作'在里面。* //所有扩展名</pre><div class="warning" title="警告" style="margin-left:0.38in;margin-right:0.38in"><table border="0" summary="Warning"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[警告]" src="images/warning.gif"></td><th align="left"></th></tr><tr><td valign="top" align="left"><p>使用通配符时要小心，因为如果你编织一个在建议中调用的扩展名，你将获得无休止的递归。</p></td></tr></table></div></div><div class="section" title="参数类型"><div class="titlepage"><div><div><h5 class="title"><a name="N110C9"></a>参数类型</h5></div></div></div><p>我们想要添加建议的扩展的参数也可以在切入点中指定。规则是，指定参数的类型必须相同，或者是要调用的定义的相应参数类型（运行时的动态类型）的超类型。</p><p>此外，可以在参数列表的末尾设置通配符，以指定可能没有任何类型的参数。<a name="N110D0" class="indexterm"></a></p><p>一些例子：</p><pre class="programlisting">my :: Templ :: extension（）//没有参数的扩展名my :: Templ :: extension（String s）//扩展名只有一个类型为String的参数my :: Templ :: extension（String s，*）// templ def带有一个或多个参数，//其中第一个参数的类型为String my :: Templ :: extension（*）// templ def，带有任意数量的参数</pre></div><div class="section" title="诉讼"><div class="titlepage"><div><div><h5 class="title"><a name="N110D9"></a>诉讼</h5></div></div></div><p>在建议中，您可能希望调用基础定义。这可以使用隐式变量<code class="varname">ctx</code>来完成，它是<span class="type">xtend :: AdviceContext</span>类型<a name="N110E3" class="indexterm"></a>并提供操作<code class="methodname">proceed()</code> <a name="N110E9" class="indexterm"></a>它使用原始参数调用基础定义（请注意，您之前可能已更改了通知中的任何可变对象）。</p><p>如果要控制将哪些参数传递给定义，可以使用操作<code class="methodname">proceed(List[Object] params)</code> 。您应该知道，在建议中，没有进行类型检查。</p><p>此外，还有一些检查属性（如<code class="varname">name</code> ， <code class="varname">paramTypes</code>等）可用。</p></div></div><div class="section" title="工作流程配置"><div class="titlepage"><div><div><h4 class="title"><a name="N110FA"></a>工作流程配置</h4></div></div></div><p>将定义的建议编织到不同的连接点<a name="N110FF" class="indexterm"></a> ，您需要配置<code class="classname">XtendComponent</code> <a name="N11105" class="indexterm"></a>使用包含建议的扩展文件的限定名称。</p><p>例：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel1.ecore“/&gt; &lt;/ metamodel&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel2.ecore“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”my :: example :: Trafo :: transform（inputSlot）“/&gt; &lt;outputSlot value =”transformedModel“/&gt; &lt;advices value =“my :: Advices，my :: Advices2”/&gt; &lt;/ component&gt;</pre></div><div class="section" title="使用Xtend进行模型到模型的转换"><div class="titlepage"><div><div><h4 class="title"><a name="xtend_example_introduction"></a>使用<span class="emphasis"><em>Xtend进行</em></span>模型到模型的转换</h4></div></div></div><p>此示例使用Eclipse EMF作为基础<a name="N11118" class="indexterm"></a>用于模型到模型的转换。它建立在其他地方记录的<span class="emphasis"><em>emfExample</em></span>之上。请先阅读并安装<span class="emphasis"><em>emfExample</em></span> 。</p><p>此示例中的想法是将EMF示例中引入的数据模型转换为自身。这可能看起来很无聊，但事实上这个例子非常具有说明性。</p></div><div class="section" title="工作流程"><div class="titlepage"><div><div><h4 class="title"><a name="xtend_example_workflow"></a>工作流程</h4></div></div></div><p>到目前为止，您应该了解工作流文件的角色和结构。因此，下面的工作流文件的有趣方面是<span class="emphasis"><em><code class="classname">XtendComponent</code></em></span> 。</p><pre class="programlisting">&lt;workflow&gt; &lt;property file =“workflow.properties”/&gt; ...&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”数据。DataPackage“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”test :: Trafo :: duplicate（rootElement）“/&gt; &lt;outputSlot value =”newModel“/&gt; &lt;/ component&gt; ...&lt;/工作流程&gt;</pre><p>像往常一样，我们必须定义应该使用的元模型，因为我们想要将数据模型转换为数据模型，所以我们只需要指定<code class="classname">data.DataPackage</code>作为元模型。</p><p>然后，我们指定要为转换调用哪个函数。语句<code class="classname">test::Trafo::duplicate(rootElement)</code>意味着调用：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">duplicate</code>函数将<code class="classname">rootElement</code>插槽的内容作为参数</p></li><li class="listitem"><p>该函数可以在<code class="filename">Trafo.ext</code>文件中找到</p></li><li class="listitem"><p>而这又是在类路径中，在<span class="package">测试</span>包中。</p></li></ul></div></div><div class="section" title="转型"><div class="titlepage"><div><div><h4 class="title"><a name="xtend_example_the_transformation"></a>转型</h4></div></div></div><p>如上所述，转换可以在<code class="classname">src</code>文件夹的<code class="classname">test</code>包中的<code class="filename">Trafo.ext</code>文件中找到。让我们一起浏览文件。</p><p>所以，首先我们导入元模型。</p><pre class="programlisting">进口数据;</pre><p>下一个功能是所谓的创建扩展<a name="N11167" class="indexterm"></a><a name="N1116C" class="indexterm"></a> 。创建扩展，作为调用时的副作用，创建<code class="classname">create</code>关键字后面给出的类型的实例。在我们的例子中， <code class="classname">duplicate</code>函数创建了一个<code class="classname">DataModel</code>实例。可以在转换中引用此新创建的对象<a name="N11179" class="indexterm"></a>由<code class="classname">this</code> （这就是为什么<code class="classname">this</code>在后面类型指定）。由于<code class="classname">this</code>可以省略，我们不必在转换中明确提及它。</p><p>该函数还将<code class="classname">DataModel</code>的实例作为其唯一参数。该对象在转换中称为<code class="varname">s</code> 。因此，此函数将新创建的<code class="classname">DataModel</code>的名称设置为原始<code class="classname">DataModel</code>的名称，然后将原始实体的所有实体的重复项添加到新实体。要创建实体的<code class="classname">duplicate()</code>将为每个<code class="classname">Entity</code>调用<code class="classname">duplicate()</code>操作。这是转换中的下一个功能。</p><pre class="programlisting">创建DataModel这个重复（DataModel s）：entity.addAll（s.entity.duplicate（）） - &gt; setName（s.name）;</pre><p>实体的复制功能也是创建扩展。这一次，它为传入的每个旧<code class="classname">Entity</code>创建一个新<code class="classname">Entity</code> 。同样，它复制名称并添加属性的重复项和对新名称的引用。</p><pre class="programlisting">create Entity this duplicate（Entity old）：attribute.addAll（old.attribute.duplicate（）） - &gt; reference.addAll（old.reference.duplicate（）） - &gt; setName（old.name）;</pre><p>复制属性的功能相当简单，但......</p><pre class="programlisting">create Attribute this duplicate（Attribute old）：setName（old.name） - &gt; setType（old.type）;</pre><a name="N111AA" class="indexterm"></a><p>......参考文献更有趣。请注意，引用虽然由某个<code class="classname">Entity</code>拥有，但也引用另一个实体作为其目标。那么，你如何确保不重复目标两次？<span class="emphasis"><em>Xtend</em></span>为这种情况提供了明确的支持。<span class="emphasis"><em>创建扩展只在每个参数元组执行一次！</em></span>因此，例如，如果通过使用相应参数调用<code class="methodname">duplicate</code>函数来复制目标引用后面的<span class="emphasis"><em>实体</em></span> ，则下次调用它时将<span class="emphasis"><em>返回完全相同的对象</em></span> 。这对图形转换非常有用。</p><pre class="programlisting">创建EntityReference这个副本（EntityReference old）：setName（old.name） - &gt; setTarget（old.target.duplicate（））;</pre><p>有关<span class="emphasis"><em>Xtend</em></span>语言的更多信息，请参阅<span class="emphasis"><em><a class="xref" href="#Xtend_language" title="的Xtend">Xtend</a></em></span>参考文档。</p></div></div></div><div class="section" title="Xpand2"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand_reference_introduction"></a> <span class="emphasis"><em>Xpand2</em></span></h2></div></div></div><p><span class="emphasis"><em>Xpand</em></span> <a name="N111D8" class="indexterm"></a>模板中使用语言来控制输出生成。本文档描述了<span class="emphasis"><em>Xpand</em></span>语言的一般语法和语义。</p><p>打字<span class="foreignphrase"><em class="foreignphrase">guillemets</em></span> <a name="N111E5" class="indexterm"></a> Eclipse编辑器支持模板中使用的（«和»），它使用<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&lt;</strong></span>和<span class="keycap"><strong>Ctrl</strong></span> + <span class="keycap"><strong>&gt;</strong></span>提供键盘快捷键。</p><div class="section" title="模板文件和编码"><div class="titlepage"><div><div><h3 class="title"><a name="xpand_reference_template_files_and_ecoding"></a>模板文件和编码</h3></div></div></div><p>模板存储在扩展名为<code class="filename">.xpt</code>文件中<a name="N111FF" class="indexterm"></a> 。 <a name="N11205" class="indexterm"></a> 模板文件<a name="N11209" class="indexterm"></a>必须驻留在生成器进程的Java类路径上。</p><p>标准语法中使用的几乎所有字符都是<span class="emphasis"><em>ASCII的</em></span>一部分，因此应该可以在任何编码中使用<a name="N11214" class="indexterm"></a><a name="N11219" class="indexterm"></a> 。唯一的限制是标记括号（ <span class="emphasis"><em>guillemets</em></span> ），使用字符“«”（Unicode <code class="varname">00AB</code> ）和“»”（Unicode <code class="varname">00BB</code> ）。因此，对于读取模板，应使用支持这些字符的编码（例如<code class="varname">ISO-8859-1</code>或<code class="varname">UTF-8</code> ）。</p><p>属性，模板，名称空间等的名称只能包含字母，数字和下划线。</p></div><div class="section" title="模板文件的一般结构"><div class="titlepage"><div><div><h3 class="title"><a name="xpand_reference_general_structure_of_template_files"></a>模板文件的一般结构</h3></div></div></div><p>这是模板的第一个示例：</p><pre class="programlisting">«IMPORT meta :: model»«EXTENSION my :: ExtensionFile»«DEFINE javaClass FOR Entity»«FILE fileName（）»package«javaPackage（）»;公共课«名称»{//实施}«ENDFILE»«ENDDEFINE»</pre><p>模板文件由任意数量的IMPORT语句组成，后跟任意数量的EXTENSION语句，后跟一个或多个DEFINE块（称为定义）。</p></div><div class="section" title="Xpand语言的语句"><div class="titlepage"><div><div><h3 class="title"><a name="xpand_reference_statements_of_the_expand_language"></a> <span class="emphasis"><em>Xpand</em></span>语言的语句</h3></div></div></div><div class="section" title="进口"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_import"></a>进口<a name="N11244" class="indexterm"></a></h4></div></div></div><p>如果您厌倦了始终键入类型和定义的完全限定名称，则可以使用IMPORT语句导入命名空间。</p><pre class="programlisting">«IMPORT meta :: model»</pre><p>这个导入名称空间<code class="varname">meta::model</code> 。如果模板包含此类语句，则可以使用该命名空间中包含的所有类型和模板文件的非限定名称。这类似于Java import语句<code class="varname">import meta.model.*</code> 。</p></div><div class="section" title="延期"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_extension"></a>延期<a name="N11256" class="indexterm"></a></h4></div></div></div><p>元模型通常以结构方式（图形或分层等）描述。这样做的一个缺点是很难指定其他行为（查询操作，派生属性等）。此外，最好不要使用目标平台特定信息（例如Java类型名称，包，getter和setter名称等）污染元模型。</p><p>扩展提供了一种灵活方便的方法来定义元类的其他功能。您可以使用<a class="link" href="#"><span class="emphasis"><em>Xtend</em></span></a>执行此操作<a name="N11261" class="indexterm"></a>语言。</p><p><code class="classname">EXTENSION</code>导入指向包含所需扩展名的<span class="emphasis"><em>Xtend</em></span>文件：</p><pre class="programlisting">«EXTENSION my :: ExtensionFile»</pre><p>请注意，扩展文件必须驻留在Java类路径上<a name="N11271" class="indexterm"></a>也是。因此，它们使用与类型和模板文件相同的命名空间机制（和语法）。</p></div><div class="section" title="限定"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_define"></a>限定<a name="N11279" class="indexterm"></a></h4></div></div></div><p><span class="emphasis"><em>Xpand</em></span>的核心概念是<code class="code">DEFINE</code>块，也称为模板。这是模板文件中最小的可识别单元<a name="N11284" class="indexterm"></a> 。标记由名称，可选的逗号分隔参数列表以及为其定义模板的元模型类的名称组成。</p><pre class="programlisting">«DEFINE templateName（formalParameterList）FOR MetaClass»一系列语句«ENDDEFINE»</pre><p>在某种程度上，模板可以被视为元类的特殊方法。总是存在一个隐含的<code class="varname">this</code>参数，可用于解决“底层”模型元素;在上面的示例中，此模型元素的类型为“ <code class="classname">MetaClass</code> ”。</p><p>与在Java中一样，形式参数列表条目由类型后跟该参数的名称组成。</p><p>模板的主体可以包含一系列其他语句，包括任何文本。</p><p>完整的参数多态性<a name="N11299" class="indexterm"></a><a name="N1129D" class="indexterm"></a>可用于模板。如果有两个具有相同名称的模板是为从同一个超类继承的两个元类定义的，则<span class="emphasis"><em>Xpand</em></span>将使用相应的子类模板，以防为超类调用模板。反之亦然，如果子类模板不可用，将使用超类的模板。请注意，这不仅适用于目标类型，也适用于所有参数。从技术上讲，目标类型作为第一个参数处理。</p><p>所以，让我们假设你有以下元模型：</p><div class="figure"><a name="N112A8"></a><p class="title"><b>图1。示例元模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/XPand/metamodelexample.gif" alt="示例元模型"></div></div></div><p><br class="figure-break"></p><p>进一步假设，您将拥有一个模型，其中包含属性<code class="methodname">listOfAs</code>的<code class="classname">A</code> ， <code class="classname">B</code>和<code class="classname">C</code>实例的<code class="methodname">listOfAs</code> 。然后，您可以编写以下模板：</p><pre class="programlisting">«DEFINE someOtherDefine FOR SomeMetaClass»«EXPAND implClass FOREACH listOfAs»«ENDDEFINE»«DEFINE implClass FOR A»//这是为超类生成的代码A«ENDDEFINE»«DEFINE implClass FOR B»//这是为代码生成的代码子类B«ENDDEFINE»«DEFINE implClass FOR C»//这是为子类C«ENDDEFINE»生成的代码</pre><p>因此，对于列表中的每个<code class="classname">B</code> ，执行为<code class="classname">B</code>定义的模板，对于集合中的每个<code class="classname">C</code> ，调用为<span class="emphasis"><em><code class="classname">C</code></em></span>定义的模板，对于所有其他<span class="emphasis"><em><code class="classname">C</code></em></span> （然后是<code class="classname">A</code>实例），执行默认模板。</p></div><div class="section" title="文件"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_file"></a>文件<a name="N112DA" class="indexterm"></a></h4></div></div></div><p><code class="varname">FILE</code>语句将从其body语句生成的输出重定向到指定的目标。
        </p><pre class="programlisting">«FILE表达式[outletName]»一系列语句«ENDFILE»</pre><p>目标是文件系统中的文件，其名称由表达式指定（相对于该生成器运行的指定目标目录）。目标规范的表达式可以是串联（使用+运算符）。此外，您可以为插座名称指定标识符（合法的Java标识符） <a name="N112E5" class="indexterm"></a> 。（有关插座的说明，请参阅配置部分）。要将目标文件生成到子目录中，请在表达式结果中使用“/”作为目录结构的分隔符。</p><p><code class="varname">FILE</code>语句的主体可以包含任何其他语句。</p><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">«FILE InterfaceName +“。java”»package«InterfacePackageName»; / *生成类！不要修改！* / public interface«InterfaceName»{«EXPAND Operation :: InterfaceImplementation FOREACH Operation»}«ENDFILE»«FILE ImplName +“。java”MY_OUTLET»package«ImplPackageName»;公共类«ImplName»扩展«ImplBaseName»实现«InterfaceName»{// TODO：实现它}«ENDFILE»</pre></div><div class="section" title="扩大"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_expand"></a>扩大<a name="N112F8" class="indexterm"></a></h4></div></div></div><p><code class="varname">EXPAND</code>语句“扩展”另一个<code class="varname">DEFINE</code>块（在单独的变量上下文中），将其输出插入当前位置并继续下一个语句。这在概念上类似于子程序调用。
        </p><pre class="programlisting">«EXPAND definitionName [（parameterList）] [FOR表达式| FOREACH表达式[SEPARATOR表达式]] [ONFILECLOSE]»</pre><p>下面解释各种替代语法。</p><div class="section" title="名称"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_names"></a>名称</h5></div></div></div><p>如果<span class="emphasis"><em>definitionName</em></span>是一个简单的非限定名称，则相应的<code class="varname">DEFINE</code>块必须位于同一模板文件中。</p><p>如果被调用的定义未包含在同一模板文件中，则必须指定模板文件的名称。像往常一样，双冒号用于分隔名称空间。</p><pre class="programlisting">«EXPAND TemplateFile :: definitionName FOR myModelElement»</pre><p>请注意，您需要导入名称空间<a name="N11317" class="indexterm"></a>模板文件（如果有）。例如，如果模板文件驻留在java包<code class="varname">my.templates</code> ，则有两种选择。你可以写</p><pre class="programlisting">«IMPORT my :: templates»...«EXPAND TemplateFile :: definitionName FOR myModelElement»</pre><p>要么</p><pre class="programlisting">«EXPAND my :: templates :: TemplateFile :: definitionName FOR myModelElement»</pre></div><div class="section" title="懒惰的评价"><div class="titlepage"><div><div><h5 class="title"><a name="N11325"></a>懒惰的评价</h5></div></div></div><p>附加<a name="N1132A" class="indexterm"></a> <code class="classname">ONFILECLOSE</code>语句推迟对扩展定义的评估，直到使用<code class="classname">ENDFILE</code>关闭当前文件。当在处理定义的评估期间收集创建文本所需的状态时，这是有用的。</p><pre class="programlisting">«文件......»...«EXPAND LazyEvaluatedDefinition FOREACH myCollection ONFILECLOSE»...«ENDFILE»«REM»现在'LazyEvaluatedDefinition'被称为«ENDFILE»</pre><p>使用<code class="classname">ONFILECLOSE</code>语句的典型示例是，您希望在Java类中创建导入列表，但是稍后在模板中使用时应添加使用的类型。</p><p>在文件关闭之前，用于延迟扩展评估的状态（通常是集合）必须有效。这可以通过两种方式实现：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>跨越<code class="classname">LET</code>空集合的<code class="classname">FILE</code>语句的<code class="classname">LET</code>语句</p><pre class="programlisting">«LET（List [MyType]）{} AS importedTypes»«FILE ...»...«EXPAND ImportStatement FOREACH importedTypes ONFILECLOSE»...«importedTypes.add（someType） - &gt;“” - »...«ENDFILE»«ENDLET»</pre></li><li class="listitem"><p>使用<a class="link" href="#create_extension" title="创建扩展（模型转换）"><span class="emphasis"><em>create extension</em></span></a> ，返回一个空集合并向其追加元素。由于它是一个创建扩展，因此第一次调用时将返回空集合，并且对于每个后续调用，将返回对此集合的引用，而不是创建新集合。</p><p><span class="bold"><strong>例：</strong></span></p><p><code class="filename">some/path/InsertionPoints.ext</code> ：</p><pre class="programlisting">create List [Type] importedTypes（SomeType context）:( List [Type]）{};</pre><p>在Xpand中使用如下：</p><pre class="programlisting">«EXTENSION some :: path :: InsertionPoints»«FILE ...»...«EXPAND ImportStatement FOREACH importedTypes（）ONFILECLOSE»...«importedTypes（）。add（someType） - &gt;“” - »...«ENDFILE»«ENDLET»</pre></li></ul></div></div></div><div class="section" title="FOR FOR FOREACH"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_for_vs_foreach"></a> FOR FOR FOREACH<a name="N11365" class="indexterm"></a><a name="N11368" class="indexterm"></a></h4></div></div></div><p>如果省略<code class="varname">FOR</code>或<code class="varname">FOREACH</code>则<code class="varname">FOR this</code>调用另一个模板。
        </p><pre class="programlisting">«EXPAND TemplateFile :: definitionName»</pre><p>等于</p><pre class="programlisting">«EXPAND TemplateFile :: definitionName FOR this»</pre><p>如果指定了<code class="varname">FOR</code>则为目标表达式的结果执行定义。</p><pre class="programlisting">«EXPAND myDef FOR实体»</pre><p>如果指定了<code class="varname">FOREACH</code> ，则目标表达式必须求值为集合类型<a name="N11385" class="indexterm"></a> 。在这种情况下，将为该集合的每个元素执行指定的定义。</p><pre class="programlisting">«EXPAND myDef FOREACH entity.allAttributes»</pre><p>如果无法将指定的目标表达式求值为实例化模型的现有元素，或者找不到合适的<code class="varname">DEFINE</code>块，则抛出<code class="varname">EvaluationException</code> 。</p><div class="section" title="指定分隔符"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_specifying_a_separator"></a>指定分隔符<a name="N11397" class="indexterm"></a></h5></div></div></div><p>如果要扩展定义<code class="varname">FOREACH</code>目标表达式的元素，则可以指定<code class="varname">SEPARATOR</code>表达式：</p><pre class="programlisting">«EXPAND paramTypeAndName FOREACH params SEPARATOR'，'»</pre><p>分隔符表达式的结果<a name="N113A5" class="indexterm"></a>将在每次评估目标定义之间写入输出。不是<span class="emphasis"><em>在</em></span>每一个之后，而是仅在两个元素<span class="emphasis"><em>之间</em></span> 。这对于逗号分隔的参数列表等内容非常有用。</p></div></div><div class="section" title="FOREACH"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_foreach"></a> FOREACH</h4></div></div></div><p>此语句扩展了目标集合的每个元素的<code class="varname">FOREACH</code>块的主体<a name="N113BA" class="indexterm"></a>这是表达式的结果。current元素绑定到当前上下文中具有指定名称的变量。
        </p><pre class="programlisting">«FOREACH表达式AS variableName [ITERATOR iterName] [SEPARATOR表达式]»使用variableName访问迭代的当前元素的语句序列«ENDFOREACH»</pre><p><code class="varname">FOREACH</code>块的主体可以包含任何其他语句;特别是<code class="varname">FOREACH</code>语句可以嵌套。</p><p>如果是<code class="varname">ITERATOR</code> <a name="N113CB" class="indexterm"></a>如果指定了name，则可以使用指定的名称访问<code class="classname">xpand2::Iterator</code>类型的对象（有关详细信息，请参阅API doc）。</p><p><code class="varname">SEPARATOR</code>表达式的工作方式与<a class="link" href="#xpand_reference_specifying_a_separator" title="指定分隔符"><code class="varname">EXPAND</code></a>表达方式相同。</p><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">«FOREACH {'A'，'B'，'C'} AS c ITERATOR iter SEPARATOR'，'»«iter.counter1»：«c»«ENDFOREACH»</pre><p>对上述声明的评估结果如下：</p><pre class="programlisting">1：A，2：B，3：C</pre></div><div class="section" title="如果"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_if"></a>如果<a name="N113E9" class="indexterm"></a></h4></div></div></div><p><code class="varname">IF</code>语句支持条件扩展。任意数量的<code class="varname">ELSEIF</code> <a name="N113F3" class="indexterm"></a>允许陈述。<code class="varname">ELSE</code>块是可选的。必须使用<code class="varname">ENDIF</code>关闭每个<code class="varname">IF</code>语句<a name="N113FF" class="indexterm"></a> 。 <code class="varname">IF</code>块的主体可以包含任何其他语句，具体而言， <code class="varname">IF</code>语句可以嵌套。</p><pre class="programlisting">«IF表达»一系列陈述[«ELSEIF表达»]一系列陈述] [«ELSE»一系列陈述]«ENDIF»</pre></div><div class="section" title="保护"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_protect"></a>保护<a name="N1140F" class="indexterm"></a></h4></div></div></div><p>保护区<a name="N11414" class="indexterm"></a>用于标记生成的代码中的部分，后续生成器运行不会再次覆盖这些部分。这些部分通常包含手动编写的代码。</p><pre class="programlisting">«保护CSTART表达式CEND表达式ID表达式（DISABLE）？»一系列陈述«ENDPROTECT»</pre><p><code class="classname">CSTART</code>的值<a name="N1141D" class="indexterm"></a>和<code class="classname">CEND</code> <a name="N11423" class="indexterm"></a>表达式用于将受保护区域标记括在输出中。它们应该构建有效的注释开始和注释与生成的目标语言相对应的结束字符串（例如，对于Java， <span class="emphasis"><em>“/ *”</em></span>和<span class="emphasis"><em>“* /”</em></span> ）。</p><p>以下是Java的示例：</p><pre class="programlisting">«保护CSTART“/ *”CEND“* /”ID ElementsUniqueID“这里有一些内容«ENDPROTECT»</pre><p>ID由<code class="varname">ID</code>表达式设置，并且必须是<span class="emphasis"><em>全局唯一的</em></span> （至少对于生成器的一次完整传递）。为了确保这些ID通常连接在一起。某些模型类型（例如UML2模型）包含可以使用的标识符，可以使用<a class="link" href="#stdlib_uid_xmlid" title="String xmlId (ecore::EObject o)">stdlib中</a>的<a class="link" href="#stdlib_uid_xmlid" title="String xmlId (ecore::EObject o)"><code class="methodname">xmlId()</code>函数</a>读取这些<a class="link" href="#stdlib_uid_xmlid" title="String xmlId（ecore :: EObject o）"><code class="methodname">xmlId()</code></a> 。</p><p>生成的目标代码如下所示：</p><pre class="programlisting">public class Person {/ * PROTECTED REGION ID（Person）ENABLED START * /启用此受保护区域，因此将始终保留内容。如果你想从模板中获取默认内容，你必须删除ENABLED关键字（甚至删除整个文件:-)）/ * PROTECTED REGION END * /}</pre><p>受保护区域在启用状态下生成<a name="N11443" class="indexterm"></a>默认情况下。除非您手动禁用<a name="N11449" class="indexterm"></a>通过删除<code class="varname">ENABLED</code>关键字，它们将始终保留。</p><p>如果希望生成器生成禁用的受保护区域，则需要在声明中添加<code class="varname">DISABLE</code>关键字：</p><pre class="programlisting">«保护CSTART'/ *'CEND'* /'ID this.name DISABLE»</pre><p>生成的目标代码将不包含<code class="classname">ENABLED</code>标志。在这种情况下，必须将<code class="classname">ENABLED</code>添加到目标区域以激活受保护区域。默认情况下禁用受保护区域的优点是可以更改模板中受保护区域的默认内容，并且所有尚未激活的区域将在重新生成后包含更改的代码。</p></div><div class="section" title="让"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_let"></a>让<a name="N11465" class="indexterm"></a></h4></div></div></div><p><code class="varname">LET</code>允许您指定局部变量：</p><pre class="programlisting">«LET表达式AS variableName»一系列语句«ENDLET»</pre><p>在<code class="varname">LET</code>身体扩张期间<a name="N11471" class="indexterm"></a> block，表达式的值绑定到指定的变量。请注意，表达式只会被评估一次，与<code class="varname">LET</code>块中变量的用法数无关。</p><p><span class="bold"><strong>例：</strong></span> </p><pre class="programlisting">«LET packageName +“。” + className AS fqn»完全限定名称是：«fqn»; «ENDLET»</pre><p>无法在<code class="classname">LET</code>块中重新分配变量值。</p></div><div class="section" title="错误"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_error"></a>错误<a name="N11488" class="indexterm"></a></h4></div></div></div><p><code class="varname">ERROR</code>语句通过抛出<code class="varname">XpandException</code>中止模板的评估<a name="N11492" class="indexterm"></a>使用指定的消息。</p><pre class="programlisting">«错误表达»</pre><p>请注意，您应该非常谨慎地使用此工具，因为更好的做法是使用元模型上的约束检查无效模型，而不是模板中！</p></div><div class="section" title="评论"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_comments"></a>评论<a name="N1149D" class="indexterm"></a></h4></div></div></div><p>注释仅允许在标签之外。</p><pre class="programlisting">«REM»文字评论«ENDREM»</pre><p>评论可能不包含REM <a name="N114A7" class="indexterm"></a> tag，这意味着注释不可嵌套。<code class="classname">REM</code>关键字及其括号之间的注释可能没有空格。</p><p><span class="bold"><strong>例：</strong></span> </p><pre class="programlisting">«REM»«LET表达式AS variableName»«ENDREM»一系列语句«REM»«variableName.stuff»«ENDLET»«ENDREM»</pre></div><div class="section" title="表达声明"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_expression_statement"></a>表达声明<a name="N114B9" class="indexterm"></a></h4></div></div></div><p>表达式支持处理由实例化的元模型提供的信息。<span class="emphasis"><em>Xpand</em></span>为选择，聚合和导航提供了强大的表达式。
        <span class="emphasis"><em>Xpand</em></span>在我们到目前为止看到的几乎任何语句中都使用表达式子语言。表达式语句只是计算包含的表达式并将结果写入输出（使用<code class="varname">java.lang.的<code class="varname">toString()</code>方法<code class="varname">java.lang.Object</code> ）。例：</p><pre class="programlisting">公共课«this.name»{</pre><p>表达式子语言定义的所有表达式也可以在<span class="emphasis"><em>Xpand中使用</em></span> 。您可以调用导入的扩展名。（有关详细信息，请参阅<span class="emphasis"><em><a class="xref" href="#r10_expressions_language" title="表达式">表达式</a></em></span>和<span class="emphasis"><em><a class="xref" href="#Xtend_language" title="的Xtend">Xtend</a>语言参考</em></span> ）。</p></div><div class="section" title="控制空白的生成"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_controlling_generation_of_white_space"></a>控制空白的生成</h4></div></div></div><p>如果你想省略多余空格的输出<a name="N114E1" class="indexterm"></a>您可以在任何结束括号之前添加减号。</p><p><span class="bold"><strong>例：</strong></span> </p><pre class="programlisting">«FILE InterfaceName +“。java” - »«IF hasPackage-»package«InterfacePackageName»; “万一-” ...«ENDFILE»</pre><p>如果尚未设置减号字符，则生成的文件将以两个新行开头（一个在<code class="varname">FILE</code> ，一个在<code class="varname">IF</code>语句之后）。</p><p>通常，此机制的工作方式如下：如果语句（或注释）以这样的减去所有前面的空格结束直到换行符<a name="N114F7" class="indexterm"></a>人物（排除！）已移除。此外，还删除了包括第一个换行符（ <code class="varname">\r\n</code>作为一个字符处理）的所有后续空格。</p></div></div><div class="section" title="Xpand中面向方面的编程"><div class="titlepage"><div><div><h3 class="title"><a name="xpand_reference_aspect-oriented_programming_in_xpand"></a> <span class="emphasis"><em>Xpand中</em></span>面向方面的编程<a name="N11504" class="indexterm"></a></h3></div></div></div><p>使用工作流引擎，现在可以打包（ <span class="emphasis"><em>例如</em></span>拉链）书面生成器并将其作为一种黑盒子传送（这通常称为盒式磁带<a name="N1150C" class="indexterm"></a> ）。如果你想使用这样的发电机但需要改变一些小代的东西，你可以使用<code class="varname">AROUND</code> <a name="N11512" class="indexterm"></a>方面。</p><pre class="programlisting">«AROUND qualifiedDefinitionName（parameterList）？FOR type»一系列陈述«ENDAROUND»</pre><p><code class="varname">AROUND</code>允许您以非侵入方式添加模板（您无需触摸生成器模板）。由于方面是侵入性的，因此必须按配置包含包含<code class="varname">AROUND</code>方面的模板文件（请参阅下一节）。</p><div class="section" title="加入Point和Point Cut语法"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_join_point_and_cut_syntax"></a>加入点<a name="N11522" class="indexterm"></a><a name="N11525" class="indexterm"></a>和点切<a name="N1152B" class="indexterm"></a><a name="N1152E" class="indexterm"></a>句法</h4></div></div></div><p>AOP基本上是将代码编织到软件模块的调用图内的不同点。这些点称为<span class="emphasis"><em>加入点</em></span> <a name="N11538" class="indexterm"></a> 。在<span class="emphasis"><em>Xpand中</em></span> ，到目前为止只有一个连接点：对定义的调用。</p><p>您可以通过在所有可用连接点上指定类似“查询”的内容来指定应执行贡献代码的连接点。这种查询称为<span class="emphasis"><em>切点</em></span> <a name="N11543" class="indexterm"></a> 。</p><pre class="programlisting">«AROUND [pointcut]»做东西«ENDAROUND»</pre><p>切点由完全限定名称，参数类型和目标类型组成。</p><div class="section" title="定义名称"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_definition_name"></a>定义名称</h5></div></div></div><p>切入点的定义名称部分必须与连接点定义的完全限定名称匹配。这些表达式<span class="emphasis"><em>区分大小写</em></span> 。星号字符用于指定通配符。</p><p>一些例子：</p><pre class="programlisting">my :: Template :: definition //具有指定名称的定义org :: eclipse :: xpand2 :: * //定义前缀为'org :: eclipse :: xpand2 ::'* Operation * //包含单词'的定义'操作'在里面。* //所有定义</pre></div><div class="section" title="参数类型"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_parameter_types"></a>参数类型</h5></div></div></div><p>我们想要添加建议的定义的参数也可以在切入点中指定。规则是指定参数的类型必须相同或者是相应参数类型的超类型（运行时的动态类型！）要调用的定义。</p><p>另外，可以在参数列表的末尾设置通配符，以指定可能存在任意数量的任意数量的参数。</p><p>一些例子：</p><pre class="programlisting">my :: Templ :: def（）//没有参数的templ def my :: Templ :: def（String s）// templ def只有一个参数//类型为String my :: Templ :: def（String s， *）//带有一个或多个参数的templ def，//其中第一个参数的类型为String my :: Templ :: def（*）// templ def，带有任意数量的参数</pre></div><div class="section" title="目标类型"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_target_type"></a>目标类型</h5></div></div></div><p>最后，我们必须指定目标类型。这很简单：</p><pre class="programlisting">my :: Templ :: def（）FOR Object // templ def for any target type my :: Templ :: def（）FOR Entity // templ def object of Entity类型</pre></div></div><div class="section" title="诉讼"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_proceeding"></a>诉讼</h4></div></div></div><p>在建议中，您可能希望调用基础定义。这可以使用隐含变量来实现<code class="varname">targetDef</code> ，这是该类型<span class="type">xpand2 ::定义</span>和提供的操作<code class="methodname">proceed()</code>调用与原来的参数基础定义（请注意，你可能会在咨询之前已经改变了可变对象）。</p><p>如果要控制将哪些参数传递给定义，可以使用操作<code class="methodname">proceed</code> （ <code class="classname">Object</code> <code class="varname">target</code> ， <code class="classname">List</code> <code class="varname">params</code> ）。请记住，在此上下文中没有进行类型检查。</p><p>此外，还有一些检查属性（如<code class="varname">name</code> ， <code class="varname">paramTypes</code>等）可用。</p></div></div><div class="section" title="生成器工作流程组件"><div class="titlepage"><div><div><h3 class="title"><a name="xpand_reference_generator_workflow_component"></a>生成器工作流程组件<a name="N11597" class="indexterm"></a></h3></div></div></div><p>本节介绍为执行代码生成而提供的工作流组件，即运行模板。您应该对工作流引擎的工作原理有一个基本的了解。简单的生成器组件配置可能如下所示：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”org.eclipse.emf.ecore。EcorePackage“/&gt; &lt;/ metaModel&gt; &lt;expand value =”somenamespace :: example :: Java :: all FOR myModel“/&gt; &lt;！ -  aop configuration  - &gt; &lt;advices value ='somenamespace :: example :: Advices1，示例:: Advices2'/&gt; &lt;！ - 输出配置 - &gt; &lt;outlet path ='main / src-gen'&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt; &lt;outlet name ='TO_SRC'path ='main / src'ramprite ='false'&gt; &lt;postprocessor class =”org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt; &lt;！ -  optional：protected regions configuration  - &gt; &lt;prSrcPaths value =”main / src“/&gt; &lt;prDefaultExcludes value =”false“/&gt; &lt;prExcludes value =”*。xml“/ &gt; &lt;/ component&gt;</pre><p>现在，让我们一个接一个地浏览不同的属性。</p><div class="section" title="主要配置"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_main_configuration"></a>主要配置</h4></div></div></div><p>首先要注意的是组件的限定Java名称是<code class="varname">org.eclipse.xpand2.Generator</code> 。</p></div><div class="section" title="编码"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_encoding"></a>编码</h4></div></div></div><p>对于<span class="emphasis"><em>Xpand</em></span> ，重要的是进行文件编码<a name="N115B3" class="indexterm"></a>记住因为<span class="foreignphrase"><em class="foreignphrase">guillemet</em></span>字符<a name="N115BC" class="indexterm"></a> «»用于分隔关键字和属性访问。<code class="varname">fileEncoding</code>属性<a name="N115C3" class="indexterm"></a>指定用于读取模板，读取受保护区域和写入生成文件的文件编码。此属性默认为JVM的默认文件编码。</p><p>在使用不同操作系统或区域设置的团队中，最好为Xpand项目设置固定的文件编码并共享设置。使用的典型编码是UTF-8或ISO-8859-1，但任何具有guillemet括号的编码也都可以。 <sup>[ <a href="#ftn.N115CB" name="N115CB" class="footnote">8</a> ]</sup></p><p>错误编码可能会在运行时导致生成器的错误消息：</p><pre class="programlisting">1108 ERROR WorkflowRunner  -  [错误]：第1行的输入'''没有可行的替代方案</pre><p>在这种情况下，您必须配置输入编码。<span class="interface">ResourceManager</span>用于设置输入编码。使用生成器组件内<code class="code">ResourceManager</code>的<code class="code">fileEncoding</code>属性来配置模板和扩展的编码。</p><p><span class="emphasis"><em>MWE</em></span>示例：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel idRef =”mm_emf“/&gt; &lt;expand value =”template :: Template :: main FOR model“/&gt; &lt;outlet path =”$ {src-gen}“&gt; &lt;postprocessor class =”org.eclipse .xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt; &lt;resourceManager class =”org.eclipse.xtend.expression。ResourceManagerDefaultImpl“&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;/ resourceManager&gt; &lt;/ component&gt;</pre><p><span class="emphasis"><em>MWE2的</em></span>示例：</p><pre class="programlisting">component = org.eclipse.xpand2。生成器{metaModel = org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel {} expand =“templates :: Template :: main FOREACH model”outlet = {path = targetDir} resourceManager = org.eclipse.xtend.expression。ResourceManagerDefaultImpl {fileEncoding =“ISO-8859-1”}}</pre><p>“ <span class="emphasis"><em><a class="xref" href="#xpand_reference_output_configuration" title="输出配置">输出配置</a></em></span> ”部分介绍了如何配置生成文件的编码。</p></div><div class="section" title="元模型"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_metamodel"></a>元模型</h4></div></div></div><p>属性<code class="varname">metaModel</code> <a name="N115F9" class="indexterm"></a>用于告诉生成器引擎应该在哪些元模型上评估<span class="emphasis"><em>Xpand</em></span>模板。可以在这里指定多个元模型。<span class="emphasis"><em>Xpand2</em></span>使用的表达式框架（请参阅<span class="emphasis"><em><a class="xref" href="#r10_expressions_language" title="表达式">表达式</a></em></span> ）需要元模型实现。在上面的示例中，我们使用<span class="emphasis"><em>Xpand</em></span>发行版核心部分附带的<code class="classname">EMFMetaModel</code>实现配置了Ecore元模型。</p><p>强制配置是<code class="varname">expand</code>属性。它期望语法类似于<code class="varname">EXPAND</code>语句（如上所述）。唯一的区别是我们省略了<code class="varname">EXPAND</code> <a name="N11619" class="indexterm"></a>关键词。相反，我们指定属性的名称。</p><p>例子：</p><pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define FOR mySlot”/&gt;</pre><p>要么：</p><pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define（'foo'）FOREACH {mySlot1，mySlot2}”/&gt;</pre><p>使用工作流上下文评估表达式。每个槽都映射到一个变量。对于上面的示例，工作流上下文需要包含插槽<code class="varname">'mySlot'</code> ， <code class="varname">'mySlot1'</code>和<code class="varname">'mySlot2'</code> 。这里也可以指定一些复杂的表达式。例如，如果插槽<code class="varname">myModel</code>包含一组模型元素，则可以编写： <a name="N11631" class="indexterm"></a> </p><pre class="programlisting">&lt;expand value =“some :: namespace :: Template :: define FOREACH myModel.typeSelect（Entity）”/&gt;</pre><p>这将选择存储在<code class="varname">myModel</code>插槽中的集合中包含的所有<span class="emphasis"><em>Entity</em></span>类型的元素。</p></div><div class="section" title="输出配置"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_output_configuration"></a>输出配置</h4></div></div></div><p>第二个强制配置是所谓的出口规范（从AndroMDA借来的概念）。奥特莱斯<a name="N11645" class="indexterm"></a>负责将生成的文件写入磁盘。</p><p>示例<span class="emphasis"><em>MWE</em></span> ：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。发电机“&gt; ......&lt;outlet path ='main / src-gen'/&gt; &lt;outlet name ='TO_SRC'path ='main / src'overcrite ='false'&gt; &lt;fileEncoding value ='ISO-8859-1'/&gt; &lt;/ outlet&gt; &lt;fileEncoding value ='ISO-8859-1'/&gt; ...&lt;/组分&gt;</pre><p>示例<span class="emphasis"><em>MWE2</em></span> ：</p><pre class="programlisting">component = org.eclipse.xpand2。生成器{metaModel = org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel {} expand =“templates :: Template :: main FOREACH model”outlet = {path ='main / src-gen'} outlet = {name ='TO_SRC'path ='main / src'overprite = false fileEncoding =' ISO-8859-1'} fileEncoding ='ISO-8859-1'......}</pre><p>在示例中，配置了两个出口。第一个没有名称，因此作为默认出口处理。通过省略插座名称触发默认插座：</p><pre class="programlisting">«FILE'test / note.txt'»＃这将进入默认插座«ENDFILE»</pre><p>配置的基本路径是' <code class="filename">main/src-gen</code> '，因此上面的文件将转到' <code class="filename">main/src-gen/test/note.txt</code> '。</p><p>第二个出口具有指定的<code class="varname">name</code> （'TO_SRC'）。此外，标志<code class="varname">overwrite</code>设置为<code class="varname">false</code> （默认为<code class="varname">true</code> ）。以下<span class="emphasis"><em>Xpand</em></span>片段</p><pre class="programlisting">«FILE'test / note.txt'TO_SRC»＃这到TO_SRC出口«ENDFILE»</pre><p>如果文件尚不存在（ <code class="varname">overwrite</code>标志），将导致生成器将内容写入' <code class="filename">main/src/test/note.txt</code> '。</p><p>另一个名为<code class="varname">append</code>选项（默认为<code class="varname">false</code> ）会导致生成器将生成的文本追加到现有文件中。如果<code class="varname">overwrite</code>设置为<code class="varname">false</code>此标志无效。</p><p>编码<a name="N1168A" class="indexterm"></a>可以在两个不同的级别配置生成的文件。可以为完整的生成器组件定义文件编码。因此，必须使用组件定义中的<span class="emphasis"><em>fileEncoding</em></span>属性（请参阅上面的示例）。您还可以在插座级别定义文件编码。因此，必须使用出口定义中的<span class="emphasis"><em>fileEncoding</em></span>属性。</p></div><div class="section" title="PostProcessor中"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_beautifier"></a> PostProcessor中<a name="N1169A" class="indexterm"></a></h4></div></div></div><p>美化生成的代码是个好主意。生成的代码看起来很好很重要，因为开发人员应该能够理解它。另一方面，模板文件也应该看起来不错。因此，最佳做法是编写漂亮的模板文件，而不是关心生成的代码的外观 - 然后在生成的代码上运行美化器来修复该问题。当然，如果没有美化器，或者白色空间具有语法意义（如在Python中），则必须记住模板（在前面部分中描述的关闭括号之前使用减号）。</p><p><span class="emphasis"><em>Xpand</em></span>工作流组件可以配置多个美化器：</p><pre class="programlisting">&lt;outlet ...&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;postprocessor class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“/&gt; &lt;/ outlet&gt;</pre><p>这是<span class="emphasis"><em>Xpand</em></span>提供的两个美化<span class="emphasis"><em>器</em></span> 。如果你想使用自己的美化器，你只需要实现<code class="classname">PostProcessor</code> Java接口<a name="N116AD" class="indexterm"></a> ：</p><pre class="programlisting">包org.eclipse.xpand2.output; public interface PostProcessor {public void beforeWriteAndClose（FileHandle handle）; public void afterClose（FileHandle handle）; }</pre><p>为每个<code class="varname">ENDFILE</code>语句调用<code class="varname">beforeWriteAndClose</code>方法。</p><p>PostProcessors也可以用于其他方式，而不是格式化，如行计数。</p><div class="section" title="JavaBeautifier"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_javabeautifier"></a> JavaBeautifier</h5></div></div></div><p>JavaBeautifier <a name="N116C2" class="indexterm"></a>基于Eclipse Java格式化程序为Java文件提供基础美化。</p></div><div class="section" title="XmlBeautifier"><div class="titlepage"><div><div><h5 class="title"><a name="xpand_reference_xmlbeautifier"></a> XmlBeautifier</h5></div></div></div><p>XmlBeautifier基于<span class="emphasis"><em>dom4j，</em></span>并提供单个选项<code class="varname">fileExtensions</code> （默认为“ <code class="filename">.xml</code> ， <code class="filename">.xsl</code> ， <code class="filename">.wsdd</code> ， <code class="filename">.wsdl</code> ”），用于指定哪些文件应该是漂亮打印的。</p></div><div class="section" title="CppBeautifier"><div class="titlepage"><div><div><h5 class="title"><a name="N116DE"></a> CppBeautifier</h5></div></div></div><p>CppBeautifier利用CDT格式化C / C ++源代码。因此，CDT需要使用此代码格式化程序。要使用这个美化器，必须将插件<span class="package">org.eclipse.xpand.support.cdt</span>添加到插件依赖项中。</p></div></div><div class="section" title="受保护的区域配置"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_reference_protected_region_configuration"></a>受保护的区域配置</h4></div></div></div><p>最后，如果要使用受保护区域，则需要配置受保护区域解析程序<a name="N116EC" class="indexterm"></a> 。</p><pre class="programlisting">&lt;prSrcPaths value =“main / src”/&gt; &lt;prDefaultExcludes value =“false”/&gt; &lt;prExcludes value =“*。xml”/&gt;</pre><p><span class="emphasis"><em>prSrcPaths</em></span> <a name="N116F5" class="indexterm"></a> property指向以逗号分隔的目录列表。受保护区域解析程序将扫描这些目录以查找包含已激活受保护区域的文件。</p><p>默认情况下会排除多个文件名：</p><pre class="programlisting">RCS，SCCS，CVS，CVS.adm，RCSLOG，cvslog。*，tags，TAGS，.make.state，.nse_depinfo，*〜，＃* ,.＃*，'，*'，_ $ *，* $，*。old，* .bak，*。BAK，* .orig，* .rej，.del- *，*。a，* .olb，*。o，* .obj，*。so，* .exe，*。Z，* .elc，* .ln，core，.svn</pre><p>如果您不想排除其中任何一个，则必须将<code class="varname">prDefaultExcludes</code>设置为false。</p><pre class="programlisting">&lt;prDefaultExcludes value =“false”/&gt;</pre><p>如果要添加其他排除项，则应使用prExcludes属性。</p><pre class="programlisting">&lt;prExcludes value =“*。xml，*。hbm”/&gt;</pre><div class="note" title="注意" style="margin-left:0.38in;margin-right:0.38in"><table border="0" summary="Note"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[注意]" src="images/note.gif"></td><th align="left"></th></tr><tr><td valign="top" align="left"><p>将生成和未生成的代码混合在一个工件中是不好的做法。您应该尝试尽可能利用所使用的目标语言的扩展功能（继承，包含，引用等），而不是使用受保护的区域。使用受保护区域是一种适当的解决方案是非常罕见的。</p></td></tr></table></div></div><div class="section" title="VetoStrategy"><div class="titlepage"><div><div><h4 class="title"><a name="N11709"></a> VetoStrategy<a name="N1170C" class="indexterm"></a></h4></div></div></div><p><span class="emphasis"><em>Xpand</em></span>引擎将为每个已处理的<span class="property">FILE</span>语句生成代码。这意味着写入的文件可能没有更改为先前的生成器运行。通常，重写文件并不重要。避免重写文件最好至少有两个好的理由：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>生成的源代码将被签入。一般来说，不建议您检查生成的代码，但有时您必须这样做。特别是对于CVS，存在重写文件被识别为已修改的问题，即使它们没有改变。因此出现了问题，即一次又一次地检入相同的文件（或者您手动还原它）。当团队合作时，问题甚至会变得更糟，因为团队成员在办理登机手续时会有冲突。</p></li><li class="listitem"><p>当可以预测生成器在文件甚至即将由FILE语句创建之前不会产生不同的内容时，这可以提高性能。当然，预测特定文件在创建之前不会产生不同的内容并非易事。这需要来自先前发电机运行的信息和针对当前模型的评估来处理。通常，diff模型将用作决策的输入。</p></li></ol></div><p>情况1）将在评估<span class="property">FILE</span>语句后阻止文件写入，情况2）将阻止创建文件。</p><p>为了实现这一点，可以将Veto Strategies添加到生成器，这是接口<code class="classname">org.eclipse.xpand2.output.实现<code class="classname">org.eclipse.xpand2.output.VetoStrategy</code>或<code class="classname">org.eclipse.xpand2.output.VetoStrategy2</code> 。如果您实现自己的<code class="classname">VetoStrategy2</code> ，请使用<code class="classname">VetoStrategy2</code> 。</p><p><code class="classname">VetoStrategy2</code>声明了两种方法：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="methodname">boolean hasVetoBeforeOpen（FileHandle）</code></p><p>在打开和生成文件之前将调用此方法。返回true以禁止创建文件。</p></li><li class="listitem"><p><code class="methodname">boolean hasVeto（FileHandle）</code></p><p>在生成文件之后以及在调用所有已配置的PostProcessors之后，将调用此方法。返回true以禁止写入文件。</p></li></ul></div><p>每个插座都配置了Veto策略。可以为每个Outlet添加多个stratgy实例。</p><pre class="programlisting">&lt;component id =“generator”class =“org.eclipse.xpand2。生成器“skipOnErrors =”true“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.uml2。UML2MetaModel“/&gt; &lt;expand value =”templates :: Root :: Root FOR model“/&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;outlet path =”src-gen“&gt; &lt;postprocessor class =”org .eclipse.xpand2.output。JavaBeautifier“/&gt; <span class="bold"><strong>&lt;vetoStrategy class =”org.eclipse.xpand2.output。NoChangesVetoStrategy“/&gt;</strong></span> &lt;/ outlet&gt; &lt;/ component&gt;</pre><p>已经提供了一个<code class="classname">VetoStrategy</code> 。<code class="classname">org.eclipse.xpand2.output.NoChangesVetoStrategy</code> <a name="N1174F" class="indexterm"></a>是一个简单的实现，它将生成的输出在经过后处理后与目标文件进行比较。如果内容相同，则策略否决文件写入。这种策略很有效，但有两个严重的缺点：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>该文件至少在内存中创建过。这会消耗时间和内存。如果应用代码格式化，这通常意味着临时写入文件。</p></li><li class="listitem"><p>必须将现有文件读入内存。这也花费了时间和记忆。</p></li></ol></div><p>更好的方法是通过拥有<code class="classname">hasVetoBeforeOpen()</code>方法的有效实现来阻止文件的创建。提供预测不必创建文件的实现需要领域知识，因此标准实现不可用。</p><p>Generator组件将报告跳过的文件数，如下所示：</p><pre class="programlisting">2192 INFO  - 发电机（发电机）：发电&lt;...&gt; 3792 INFO  - <span class="bold"><strong>已将2个文件写入插座</strong></span> [默认]（src-gen）</pre></div></div><div class="section" title="在Xpand中使用面向方面编程的示例"><div class="titlepage"><div><div><h3 class="title"><a name="aop_template_introduction"></a>在<span class="emphasis"><em>Xpand中</em></span>使用面向方面编程的<span class="emphasis"><em>示例</em></span></h3></div></div></div><p><a name="N1176F" class="indexterm"></a>此示例显示如何在<span class="emphasis"><em>Xpand</em></span>模板中使用面向方面的编程技术。它适用于基于EMF和<span class="emphasis"><em>Classic</em></span>系统。但是，我们根据<span class="emphasis"><em>emfExample</em></span>解释了这个想法。因此你应该先阅读。</p></div><div class="section" title="问题"><div class="titlepage"><div><div><h3 class="title"><a name="aop_template_the_problem"></a>问题</h3></div></div></div><p>在模板AOP很有用的情况下有很多种情况。这是两个例子：</p><p><span class="bold"><strong>场景1：</strong></span>假设您有一个生成某些工件的漂亮生成器。生成器（或盒式磁带）可能是第三方产品，在单个JAR文件中提供。您仍然可能希望在<span class="emphasis"><em>不修改原始生成器的情况下调整</em></span>生成过程的某些方面。</p><p><span class="bold"><strong>场景2：</strong></span>您正在构建一系列可以生成生成代码变体的生成器，例如，针对不同嵌入式平台的实现。在这种情况下，您需要能够明智地表达这些差异（变量），而不会在模板中创建不可理解的<span class="emphasis"><em>if</em></span>语句混乱。</p></div><div class="section" title="例"><div class="titlepage"><div><div><h3 class="title"><a name="aop_template_example"></a>例</h3></div></div></div><p>为了说明扩展生成器而不“触及”它的想法，让我们创建一个名为<code class="classname">org.eclipse.demo.emf.datamodel.generator-aop</code>的新项目。这个想法是它将“扩展” <span class="emphasis"><em>emfExample中</em></span>引入的原始<code class="classname">org.eclipse.demo.emf.datamodel.generator</code>项目。因此，这个新项目需要与前一个项目相关。</p><div class="section" title="模板"><div class="titlepage"><div><div><h4 class="title"><a name="aop_template_example_templates"></a>模板</h4></div></div></div><p>AOP系统总是需要定义连接点<a name="N117A9" class="indexterm"></a>模型;也就是说，您必须定义（模板）程序的哪些位置可以添加其他（模板）代码。在<span class="emphasis"><em>Xpand中</em></span> ，连接点只是模板（即<span class="emphasis"><em>DEFINE ..ENDDEFINE</em></span> ）块。“方面模板”可以声明为<span class="emphasis"><em>AROUND</em></span> <a name="N117B5" class="indexterm"></a>以前存在的模板。如果您查看项目的<code class="classname">org.eclipse.demo.emf.datamodel.generator</code>源文件夹，可以找到<code class="filename">Root.xpt</code>模板文件。在里面，你可以找到一个名为<code class="classname">Impl</code>的模板，它生成JavaBean的实现。</p><pre class="programlisting">«DEFINE Entity FOR data :: Entity»«FILE baseClassFileName（）»//生成于«timestamp（）»公共抽象类«baseClassName（）»{«EXPAND Impl»}«ENDFILE»«ENDDEFINE»«DEFINE Impl FOR data： ：实体»«EXPAND GettersAndSetters»«ENDDEFINE»«DEFINE Impl FOR data :: PersistentEntity»«EXPAND GettersAndSetters»public void save（）{}«ENDDEFINE»</pre><p>我们现在想要实现的是：每当执行<span class="emphasis"><em>Impl</em></span>模板时，我们都希望运行一个额外的模板来生成额外的代码（例如，给定框架的某种元信息）。这个地方的具体代码对于此处的示例并不重要。</p><p>因此，在我们的新项目中，我们定义以下模板文件：</p><pre class="programlisting">«AROUND Impl FOR data :: Entity»«FOREACH属性AS a»public static final AttrInfo«a.name»Info = new AttrInfo（“«a.name»”，«a.type».class）; «ENDFOREACH»«targetDef.proceed（）»«ENDAROUND»</pre><p>因此，这个新模板包含了名为<code class="classname">Impl</code>的现有模板。它首先生成其他代码，然后使用<code class="methodname">targetDef.proceed()</code>将执行转发到原始模板。所以，实际上，这是一个<code class="varname">BEFORE</code>建议。将<code class="methodname">proceed</code>语句移动到开头使其成为<code class="varname">AFTER</code>建议，省略它，使其成为覆盖。</p></div><div class="section" title="工作流文件"><div class="titlepage"><div><div><h4 class="title"><a name="aop_template_example_workflow_file"></a>工作流文件<a name="N117E4" class="indexterm"></a></h4></div></div></div><p>让我们看一下运行此生成器的工作流文件：</p><pre class="programlisting">&lt;workflow&gt; &lt;cartridge file =“workflow.mwe”/&gt; &lt;component adviceTarget =“generator”id =“reflectionAdvice”class =“org.eclipse.xpand2。GeneratorAdvice“&gt; &lt;advices value =”templates :: Advices“/&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre><p>主要是，我们在这里做的是调用原始工作流文件。必须从类路径中获取它。在此墨盒调用之后，我们定义了一个额外的工作流组件，即所谓的<span class="emphasis"><em>建议组件</em></span> 。它将<span class="emphasis"><em>generator</em></span>指定为其<span class="emphasis"><em>adviceTarget</em></span> 。这意味着，我们在此通知组件中定义的所有属性都将添加到<span class="emphasis"><em>adviceTarget中</em></span>由name引用的组件中。在我们的例子中，这是发电机。因此，实际上，我们将<code class="classname">&lt;advices value="templates::Advices" /&gt;</code>到原始生成器组件（而无需有创地修改其自己的定义）。这将建议模板提供给生成器。</p></div><div class="section" title="运行新的发电机"><div class="titlepage"><div><div><h4 class="title"><a name="aop_template_example_running_the_new_generator"></a>运行新的发电机</h4></div></div></div><p>运行生成器会生成以下代码：</p><pre class="programlisting">public abstract class PersonImplBase {public static final AttrInfo nameInfo = new AttrInfo（“name”，String.class）; public static final AttrInfo name2Info = new AttrInfo（“name2”，String.class）;私有字符串名称; private String name2; public void setName（String value）{this.name = value; public String getName（）{return this.name; public void setName2（String value）{this.name2 = value; public String getName2（）{return this.name2; }}</pre></div></div><div class="section" title="更多方面取向"><div class="titlepage"><div><div><h3 class="title"><a name="aop_template_more_ao"></a>更多方面取向</h3></div></div></div><p>一般来说， <span class="emphasis"><em>AROUND</em></span>的语法<a name="N11810" class="indexterm"></a>构造如下：</p><pre class="programlisting">«AROUND fullQualifiedDefinitionNameWithWildcards（Paramlist（*）？）FOR TypeName»做东西«ENDAROUND»</pre><p>这里有些例子：</p><pre class="programlisting">«AROUND *（*）FOR Object»</pre><p>匹配所有模板</p><pre class="programlisting">«AROUND * define（*）FOR Object»</pre><p>匹配所有模板，其名称末尾包含<span class="emphasis"><em>define</em></span>和任意数量的参数</p><pre class="programlisting">«AROUND org :: eclipse :: xpand2 :: * FOR Entity»</pre><p>将所有模板与命名空间<span class="emphasis"><em>org :: eclipse :: xpand2 ::</em></span>匹配，它们没有任何参数，其类型为Entity或子类</p><pre class="programlisting">«AROUND *（String s）FOR Object»</pre><p>匹配具有一个<code class="classname">String</code>参数的所有模板</p><pre class="programlisting">«AROUND *（String s，*）FOR Object»</pre><p>匹配具有至少一个<code class="classname">String</code>参数的所有模板</p><pre class="programlisting">«AROUND my :: Template :: definition（String s）FOR Entity»</pre><p>恰好匹配这个单一的定义</p><p>在<code class="varname">AROUND</code>内部，有变量<code class="varname">targetDef</code> ，其类型为<code class="classname">xpand2::Definition</code> 。在此变量上，您可以调用<code class="methodname">proceed</code> ，还可以查询其他一些内容：</p><pre class="programlisting">«AROUND my :: Template :: definition（String s）FOR String»log（'invoking'+«targetDef.name»+'with'+ this）«targetDef.proceed（）»«ENDAROUND»</pre></div></div><div class="section" title="探查"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="r10_profiler"></a>探查</h2></div></div></div><p><span class="emphasis"><em>ProfilerComponent</em></span>允许您测量每个检查，Xtend功能或Xpand定义需要在工作流程中执行的时间。它通过充当<span class="emphasis"><em>CheckComponent</em></span> ， <span class="emphasis"><em>XtendComponent</em></span>和<span class="emphasis"><em>XpandComponent</em></span>的回调来<span class="emphasis"><em>实现</em></span> ，其中每个调用的时间将存储在分析模型中。根据这些数据，探查器最终导出具有和不具有子进程的执行时间，具有相应呼叫计数的呼叫者/被叫者以及最终关于递归呼叫的呼叫图。一组Xpand模板可以将模型转换为HTML报告或GNU GProf格式的文本文件。</p><div class="figure"><a name="N1185F"></a><p class="title"><b>图2。探查器的HTML输出示例</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/Xpand/profiler.png" width="513" alt="探查器的HTML输出示例"></div></div></div><br class="figure-break"><p>使用<span class="emphasis"><em>ProfilerComponent</em></span>将其他组件包装在工作流中。表示探查器最终存储模型的<span class="emphasis"><em>resultSlot</em></span> 。然后，通过<span class="emphasis"><em>idRef</em></span>作为回调引用此组件。一旦探查器的component-tag关闭，它就会将派生的分析模型存储在给定的槽中。您可以自由地转换此模型，也可以重新使用profiler附带的模板之一。</p><pre class="programlisting">&lt;component id =“profiler”class =“org.eclipse.xtend.profiler。ProfilerComponent“&gt; &lt;resultSlot value =”profilingResult“/&gt; &lt;component class =”org.eclipse.xtend.check。CheckComponent“&gt; &lt;vetoableCallback idRef =”profiler“/&gt; ...&lt;/ component&gt; &lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;vetoableCallback idRef =”profiler“/&gt; ...&lt;/ component&gt; &lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;vetoableCallback idRef =”profiler“/&gt; ...&lt;/ component&gt; &lt;/ component&gt; &lt;component class =“org.eclipse.xpand2。生成器“fileEncoding =”ISO-8859-1“&gt; &lt;metaModel idRef =”mm“/&gt; &lt;expand value =”org :: eclipse :: xtend :: profiler :: templates :: Html :: Main FOR profilingResult“/&gt; &lt;outlet overwrite =“true”path =“profiling”/&gt; &lt;/ component&gt;</pre><p>目前，有两种不同的模板可用于呈现分析模型</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>组织::日食:: XTEND ::探查::模板:: HTML ::主要</p></li><li class="listitem"><p>组织::日食:: XTEND ::探查::模板:: GProf使用::主要</p></li></ul></div><p>Xpand向导将生成一个名为<span class="emphasis"><em>workflowWithProfiler.mwe</em></span>的工作<span class="emphasis"><em>流</em></span> ，该工作<span class="emphasis"><em>流</em></span>演示了探查器的功能。它将结果放在文件夹<span class="emphasis"><em>分析中</em></span> 。</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[ <a href="#N115CB" name="ftn.N115CB" class="para">8</a> ]</sup>在Mac OSX上，默认编码是MacRoman，这不是一个好选择，因为其他操作系统不知道这种编码。建议将编码设置为更常见的编码，例如UTF-8，甚至可以用于整个工作区。</p></div></div></div><div class="chapter" title="Chapter 9. 内置类型API文档"><div class="titlepage"><div><div><h2 class="title">Chapter 9. 内置类型API文档</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#Object.html"><code class="classname">宾语</code></a></span></dt><dt><span class="section"><a href="#String.html"><code class="classname">串</code></a></span></dt><dt><span class="section"><a href="#Integer.html"><code class="classname">整数</code></a></span></dt><dt><span class="section"><a href="#Boolean.html"><code class="classname">布尔</code></a></span></dt><dt><span class="section"><a href="#Real.html"><code class="classname">真实</code></a></span></dt><dt><span class="section"><a href="#Collection.html"><code class="classname">采集</code></a></span></dt><dt><span class="section"><a href="#List.html"><code class="classname">名单</code></a></span></dt><dt><span class="section"><a href="#Set.html"><code class="classname">组</code></a></span></dt><dt><span class="section"><a href="#xpand2_Type.html"><code class="classname">xpand2 ::类型</code></a></span></dt><dt><span class="section"><a href="#xpand2_Feature.html"><code class="classname">xpand2 ::特写</code></a></span></dt><dt><span class="section"><a href="#xpand2_Property.html"><code class="classname">xpand2 ::物业</code></a></span></dt><dt><span class="section"><a href="#xpand2_Operation.html"><code class="classname">xpand2 ::操作</code></a></span></dt><dt><span class="section"><a href="#xpand2_StaticProperty.html"><code class="classname">xpand2 :: StaticProperty</code></a></span></dt><dt><span class="section"><a href="#Void.html"><code class="classname">空虚</code></a></span></dt><dt><span class="section"><a href="#xtend_AdviceContext.html"><code class="classname">XTEND :: AdviceContext</code></a></span></dt><dt><span class="section"><a href="#xpand2_Definition.html"><code class="classname">xpand2 ::定义</code></a></span></dt><dt><span class="section"><a href="#xpand2_Iterator.html"><code class="classname">xpand2 ::迭代器</code></a></span></dt></dl></div><div class="section" title="宾语"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Object.html"></a><code class="classname">Object</code></h2></div></div></div><p>超类型：无</p><p>
		

		</p><div class="table"><a name="Object_Properties"></a><p class="title"><b>表格1。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#xpand2_Type.html" title="xpand2 ::类型"><code class="classname">xpand2 ::类型</code></a>
						</td><td align="left">
							<code class="methodname">元类型</code>
						</td><td align="left">返回此对象的元类型。
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="Object_Operations"></a><p class="title"><b>表2。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">==</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toString</code> （）</td><td align="left">返回此对象的String表示形式。（调用Java的toString（）方法）</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">！=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">compareTo</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">将此对象与指定的对象进行比较以获得顺序。返回负整数，零或正整数，因为此对象小于，等于或大于指定对象。
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="串"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="String.html"></a><code class="classname">String</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="String_Properties"></a><p class="title"><b>表3。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">长度</code>
						</td><td align="left">这个字符串的长度</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="String_Operations"></a><p class="title"><b>表4。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toLowerCase</code> （）</td><td align="left">使用默认语言环境的规则（来自Java）将此String中的所有字符转换为小写</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">+</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">连接两个字符串</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">toCharList</code> （）</td><td align="left">将此String拆分为包含长度为1的字符串的List [String]</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toFirstUpper</code> （）</td><td align="left">使用默认语言环境的规则将此String中的第一个字符转换为大写（来自Java）</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">subString</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ， <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">返回一个新字符串，该字符串是此字符串的子字符串。
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">trim</code> （）</td><td align="left">返回字符串的副本，省略前导和尾随空格。 （来自Java 1.4）</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toFirstLower</code> （）</td><td align="left">使用默认语言环境的规则将此String中的第一个字符转换为小写（来自Java）</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toUpperCase</code> （）</td><td align="left">使用默认语言环境的规则（来自Java）将此String中的所有字符转换为大写</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">split</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">将此字符串拆分为给定正则表达式的匹配（来自Java 1.4）</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">startsWith</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">测试此字符串是否以指定的前缀开头。
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">matches</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">判断此字符串是否与给定的正则表达式匹配。 （来自Java 1.4）</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">asInteger</code> （）</td><td align="left">返回一个包含指定String值的Integer对象（来自Java 1.5）</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">contains</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">测试此字符串是否包含子字符串。
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">endsWith</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">测试此字符串是否以指定的前缀结尾。
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">replaceFirst</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ， <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">将给定替换的给定正则表达式匹配的此字符串的第一个子字符串替换。
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">replaceAll</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ， <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">将给定替换的给定正则表达式匹配的此字符串的每个子字符串替换。
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="整数"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Integer.html"></a><code class="classname">Integer</code></h2></div></div></div><p>超类型： <a class="link" href="#Real.html" title="真实"><code class="classname">Real</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="Integer_Operations"></a><p class="title"><b>表5。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">upTo</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">返回以目标表达式的值开头的整数List，直到指定的Integer的值，加1，例如'1.upTo（5）'计算为{1,2,3,4,5}</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;=</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">==</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">！=</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">upTo</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ， <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">返回以目标表达式的值开头的整数列表，直到第一个参数的值，再增加第二个参数，例如'1.upTo（10,2）'计算结果为{1,3,5,7 ，9}</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">-</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">+</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;=</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">*</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">-</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">/</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="布尔"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Boolean.html"></a><code class="classname">Boolean</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="Boolean_Operations"></a><p class="title"><b>表6。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">！</code>（）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="真实"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Real.html"></a><code class="classname">Real</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="Real_Operations"></a><p class="title"><b>表7。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Real.html" title="真实"><code class="classname">真实</code></a>
						</td><td align="left">
							<code class="methodname">*</code> （ <a class="link" href="#Real.html" title="真实"><code class="classname">Real</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Real.html" title="真实"><code class="classname">真实</code></a>
						</td><td align="left">
							<code class="methodname">-</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">==</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">！=</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&lt;</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Real.html" title="真实"><code class="classname">真实</code></a>
						</td><td align="left">
							<code class="methodname">-</code> （ <a class="link" href="#Real.html" title="真实"><code class="classname">Real</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Real.html" title="真实"><code class="classname">真实</code></a>
						</td><td align="left">
							<code class="methodname">/</code> （ <a class="link" href="#Real.html" title="真实"><code class="classname">Real</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">&gt;</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Real.html" title="真实"><code class="classname">真实</code></a>
						</td><td align="left">
							<code class="methodname">+</code> （ <a class="link" href="#Real.html" title="真实"><code class="classname">Real</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="采集"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Collection.html"></a><code class="classname">Collection</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="Collection_Properties"></a><p class="title"><b>表8。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">是空的</code>
						</td><td align="left">如果此Collection为空，则返回true</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">尺寸</code>
						</td><td align="left">返回此Collection的大小</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="Collection_Operations"></a><p class="title"><b>表9。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">contains</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">如果此collection包含指定的对象，则返回true。否则是假的。返回此Collection。
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">toList</code> （）</td><td align="left">将此集合转换为List</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">toSet</code> （）</td><td align="left">将此集合转换为Set</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">flatten</code> （）</td><td align="left">返回一个展平的List。
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">intersect</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">返回一个新的Set，只包含this和指定Collection中包含的元素</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toString</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">连接每个包含的元素（使用toString（）），由指定的String分隔。
						</td></tr><tr><td align="left">
							<a class="link" href="#Collection.html" title="采集"><code class="classname">采集</code></a>
						</td><td align="left">
							<code class="methodname">removeAll</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">如果包含，则从此Collection中删除指定集合中包含的所有元素（修改它！）。返回此Collection。
						</td></tr><tr><td align="left">
							<a class="link" href="#Collection.html" title="采集"><code class="classname">采集</code></a>
						</td><td align="left">
							<code class="methodname">remove</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">如果包含，则从此Collection中删除指定的元素（修改它！）。返回此Collection。
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">without</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">返回一个新的Set，其中包含此Collection中的所有元素，而不包含指定Collection中的元素</td></tr><tr><td align="left">
							<a class="link" href="#Collection.html" title="采集"><code class="classname">采集</code></a>
						</td><td align="left">
							<code class="methodname">addAll</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">将所有元素添加到Collection中（修改它！）。返回此Collection。
						</td></tr><tr><td align="left">
							<a class="link" href="#Collection.html" title="采集"><code class="classname">采集</code></a>
						</td><td align="left">
							<code class="methodname">add</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">向Collection添加一个元素（修改它！）。返回此Collection。
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">union</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">返回一个新的Set，包含来自this和指定Collection的所有元素</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">containsAll</code> （ <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a> ）</td><td align="left">如果此collection包含指定collection中包含的每个元素，则返回true。否则是假的。返回此Collection。
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="名单"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="List.html"></a><code class="classname">List</code></h2></div></div></div><p>超类型： <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="List_Operations"></a><p class="title"><b>表10。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">withoutFirst</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">last</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">indexOf</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">withoutLast</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Collection.html" title="采集"><code class="classname">采集</code></a>
						</td><td align="left">
							<code class="methodname">reverse</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">first</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">get</code> （ <a class="link" href="#Integer.html" title="整数"><code class="classname">Integer</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="组"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Set.html"></a><code class="classname">Set</code></h2></div></div></div><p>超类型： <a class="link" href="#Collection.html" title="采集"><code class="classname">Collection</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>此类型未定义任何操作。
		

		</p></div><div class="section" title="xpand2 ::类型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Type.html"></a><code class="classname">xpand2::Type</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="xpand2::Type_Properties"></a><p class="title"><b>表11。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">名称</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">allStaticProperties</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">文件</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">超类型</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">allProperties</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">allFeatures</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Set.html" title="组"><code class="classname">组</code></a>
						</td><td align="left">
							<code class="methodname">allOperations</code>
						</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="xpand2::Type_Operations"></a><p class="title"><b>表12。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#xpand2_StaticProperty.html" title="xpand2 :: StaticProperty"><code class="classname">xpand2 :: StaticProperty</code></a>
						</td><td align="left">
							<code class="methodname">getStaticProperty</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Feature.html" title="xpand2 ::特写"><code class="classname">xpand2 ::特写</code></a>
						</td><td align="left">
							<code class="methodname">getFeature</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ， <a class="link" href="#List.html" title="名单"><code class="classname">List</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">isInstance</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Property.html" title="xpand2 ::物业"><code class="classname">xpand2 ::物业</code></a>
						</td><td align="left">
							<code class="methodname">getProperty</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">newInstance</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">isAssignableFrom</code> （ <a class="link" href="#xpand2_Type.html" title="xpand2 ::类型"><code class="classname">xpand2::Type</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Operation.html" title="xpand2 ::操作"><code class="classname">xpand2 ::操作</code></a>
						</td><td align="left">
							<code class="methodname">getOperation</code> （ <a class="link" href="#String.html" title="串"><code class="classname">String</code></a> ， <a class="link" href="#List.html" title="名单"><code class="classname">List</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="xpand2 ::特写"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Feature.html"></a><code class="classname">xpand2::Feature</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="xpand2::Feature_Properties"></a><p class="title"><b>表13。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">名称</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Type.html" title="xpand2 ::类型"><code class="classname">xpand2 ::类型</code></a>
						</td><td align="left">
							<code class="methodname">返回类型</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">文件</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Type.html" title="xpand2 ::类型"><code class="classname">xpand2 ::类型</code></a>
						</td><td align="left">
							<code class="methodname">所有者</code>
						</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>此类型未定义任何操作。
		

		</p></div><div class="section" title="xpand2 ::物业"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Property.html"></a><code class="classname">xpand2::Property</code></h2></div></div></div><p>超类型： <a class="link" href="#xpand2_Feature.html" title="xpand2 ::特写"><code class="classname">xpand2::Feature</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="xpand2::Property_Operations"></a><p class="title"><b>表14。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Void.html" title="空虚"><code class="classname">空虚</code></a>
						</td><td align="left">
							<code class="methodname">set</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ， <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">get</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="xpand2 ::操作"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Operation.html"></a><code class="classname">xpand2::Operation</code></h2></div></div></div><p>超类型： <a class="link" href="#xpand2_Feature.html" title="xpand2 ::特写"><code class="classname">xpand2::Feature</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="xpand2::Operation_Operations"></a><p class="title"><b>表15。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">getParameterTypes</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">evaluate</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ， <a class="link" href="#List.html" title="名单"><code class="classname">List</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="xpand2 :: StaticProperty"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_StaticProperty.html"></a><code class="classname">xpand2::StaticProperty</code></h2></div></div></div><p>超类型： <a class="link" href="#xpand2_Feature.html" title="xpand2 ::特写"><code class="classname">xpand2::Feature</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>
		

		</p><div class="table"><a name="xpand2::StaticProperty_Operations"></a><p class="title"><b>表16。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">get</code> （）</td><td align="left">返回静态值</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="空虚"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Void.html"></a><code class="classname">Void</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>此类型未定义任何属性。
		

		</p><p>此类型未定义任何操作。
		

		</p></div><div class="section" title="XTEND :: AdviceContext"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xtend_AdviceContext.html"></a><code class="classname">xtend::AdviceContext</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="xtend::AdviceContext_Properties"></a><p class="title"><b>表17。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">paramTypes</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">名称</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">paramNames</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">paramValues</code>
						</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="xtend::AdviceContext_Operations"></a><p class="title"><b>表18。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">proceed</code> （ <a class="link" href="#List.html" title="名单"><code class="classname">List</code></a> ）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Object.html" title="宾语"><code class="classname">宾语</code></a>
						</td><td align="left">
							<code class="methodname">proceed</code> （）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="xpand2 ::定义"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Definition.html"></a><code class="classname">xpand2::Definition</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="xpand2::Definition_Properties"></a><p class="title"><b>表19。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">paramTypes</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">名称</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#List.html" title="名单"><code class="classname">名单</code></a>
						</td><td align="left">
							<code class="methodname">paramNames</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#xpand2_Type.html" title="xpand2 ::类型"><code class="classname">xpand2 ::类型</code></a>
						</td><td align="left">
							<code class="methodname">TARGETTYPE</code>
						</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>
		

		</p><div class="table"><a name="xpand2::Definition_Operations"></a><p class="title"><b>表20。操作</b></p><div class="table-contents"><table border="1" summary="Operations"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">返回类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Void.html" title="空虚"><code class="classname">空虚</code></a>
						</td><td align="left">
							<code class="methodname">proceed</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#String.html" title="串"><code class="classname">串</code></a>
						</td><td align="left">
							<code class="methodname">toString</code> （）</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Void.html" title="空虚"><code class="classname">空虚</code></a>
						</td><td align="left">
							<code class="methodname">proceed</code> （ <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a> ， <a class="link" href="#List.html" title="名单"><code class="classname">List</code></a> ）</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p></div><div class="section" title="xpand2 ::迭代器"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xpand2_Iterator.html"></a><code class="classname">xpand2::Iterator</code></h2></div></div></div><p>超类型： <a class="link" href="#Object.html" title="宾语"><code class="classname">Object</code></a>
		</p><p>
		

		</p><div class="table"><a name="xpand2::Iterator_Properties"></a><p class="title"><b>表21。属性</b></p><div class="table-contents"><table border="1" summary="Properties"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">lastIteration</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Boolean.html" title="布尔"><code class="classname">布尔</code></a>
						</td><td align="left">
							<code class="methodname">firstIteration</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">分子</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">C0的</code>
						</td><td align="left">
							
						</td></tr><tr><td align="left">
							<a class="link" href="#Integer.html" title="整数"><code class="classname">整数</code></a>
						</td><td align="left">
							<code class="methodname">计数器1</code>
						</td><td align="left">
							
						</td></tr></tbody></table></div></div><p><br class="table-break">
		

		</p><p>此类型未定义任何操作。
		

		</p></div></div><div class="chapter" title="Chapter 9. STDLIB"><div class="titlepage"><div><div><h2 class="title">Chapter 9. STDLIB</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#N123CE">介绍</a></span></dt><dt><span class="section"><a href="#N123D6">Stdlib扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#N123E3">IO扩展</a></span></dt><dt><span class="section"><a href="#N124C0">柜台扩展</a></span></dt><dt><span class="section"><a href="#N12520">属性扩展</a></span></dt><dt><span class="section"><a href="#N1256E">元素属性扩展</a></span></dt><dt><span class="section"><a href="#N125B0">问题扩展</a></span></dt><dt><span class="section"><a href="#N1262A">命名扩展</a></span></dt><dt><span class="section"><a href="#N12684">Globalvar扩展</a></span></dt><dt><span class="section"><a href="#N1269B">克隆扩展</a></span></dt><dt><span class="section"><a href="#N126DD">交叉引用扩展</a></span></dt><dt><span class="section"><a href="#N12704">UID扩展</a></span></dt><dt><span class="section"><a href="#N1274E">Mixin扩展</a></span></dt><dt><span class="section"><a href="#N1278E">跟踪扩展</a></span></dt></dl></dd><dt><span class="section"><a href="#N12811">Stdlib工作流程组件</a></span></dt><dd><dl><dt><span class="section"><a href="#N12816">SystemCommand</a></span></dt><dt><span class="section"><a href="#N12879">SlotCopier</a></span></dt><dt><span class="section"><a href="#N128C4">SlotListAdder</a></span></dt><dt><span class="section"><a href="#N12913">SlotPrinter</a></span></dt></dl></dd></dl></div><div class="section" title="介绍"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="N123CE"></a>介绍</h2></div></div></div><p>Xpand在<span class="package">org.eclipse.xpand.util.stdlib</span>包中提供了一组小的有用的实用程序扩展和组件。如果要使用它，则需要为此插件添加依赖项。</p></div><div class="section" title="Stdlib扩展"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="N123D6"></a> Stdlib扩展</h2></div></div></div><p>本节介绍Stdlib提供的组件和扩展。为方便起见，我们在工作流配置中使用包中<span class="package">org.eclipse.xtend.util.stdlib</span>中的组件类的快捷方式<span class="emphasis"><em>xpand.util.stdlib ...。</em></span></p><p>请注意，Stdlib的许多函数都在其Java实现中使用静态变量，因此值通过完整的MWE工作流保存。此外，由于静态实现，功能不是线程安全的。</p><div class="section" title="IO扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N123E3"></a> IO扩展</h3></div></div></div><p>这是一个非常有用的库，用于将信息打印到日志记录工具。通过转换过程或复杂的表达式来确定对表达式进行精确计算是非常有价值的。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::io</code></p><div class="section" title="debug（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N123EE"></a> debug（对象o）</h4></div></div></div><p>将具有DEBUG级别的对象记录到记录器。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 要转储的对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="info（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N123FE"></a> info（对象o）</h4></div></div></div><p>将具有INFO级别的对象记录到记录器。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 要转储的对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="错误（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N1240E"></a>错误（对象o）</h4></div></div></div><p>将具有ERROR级别的对象记录到记录器。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 要转储的对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="syserr（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N1241E"></a> syserr（对象o）</h4></div></div></div><p>将对象打印到System.err。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 应打印的对象。允许<code class="code">null</code> 。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="syserr（Object o，String prefix）"><div class="titlepage"><div><div><h4 class="title"><a name="N12431"></a> syserr（Object o，String prefix）</h4></div></div></div><p>将对象打印到System.err。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 应打印的对象。允许<code class="code">null</code> 。</p></li><li class="listitem"><p>prefix  - 消息的前缀字符串。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="syserr（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N12447"></a> syserr（对象o）</h4></div></div></div><p>将对象打印到System.err。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 应打印的对象。允许<code class="code">null</code> 。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象o</p></div><div class="section" title="throwError（Object o）"><div class="titlepage"><div><div><h4 class="title"><a name="N1245A"></a> throwError（Object o）</h4></div></div></div><p>抛出IllegalStateMessage。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 异常消息。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>没有，因为抛出异常。</p></div><div class="section" title="String includeFile（String filePath，String encoding）"><div class="titlepage"><div><div><h4 class="title"><a name="N1246A"></a> String includeFile（String filePath，String encoding）</h4></div></div></div><p>读取文件的内容。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>filePath  - 文件的路径</p><p>encoding  - 用于读取的文件编码</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>文件内容。</p></div><div class="section" title="字符串includeFile（String filePath）"><div class="titlepage"><div><div><h4 class="title"><a name="N1247C"></a>字符串includeFile（String filePath）</h4></div></div></div><p>读取文件的内容。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>filePath  - 文件的路径</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>文件内容。</p></div><div class="section" title="例子"><div class="titlepage"><div><div><h4 class="title"><a name="N1248C"></a>例子</h4></div></div></div><pre class="programlisting">进口数据;扩展名org.eclipse.xtend.util.stdlib :: io;创建DataModel这个重复（DataModel s）：entity.addAll（s.entity.duplicate（）） - &gt; setName（s.name）;创建实体此副本（实体旧）:( old.name +“has”+ old.reference.size +“references”）。info（） - &gt; old.reference.name.info（） - &gt;</pre><p>这导致控制台上的以下输出：</p><pre class="programlisting">922 INFO  - 人有1个引用923 INFO  -  [autos] 926 INFO  -  Vehicle有0个引用926 INFO  -  []</pre><p>当然IO扩展函数也可以在Xpand中使用，但是如果用于记录目的，你必须处理一个副作用：因为函数返回传递的对象（表达式的结果，在最简单的情况下只是一个字符串）和Xpand将表达式结果打印到打开的文件，消息将显示在控制台上，但也可以在结果文件中。这可能是你想要避免的，所以你可以使用一个小技巧：在调用日志函数之后使用链接运算符并让表达式的结果为空字符串：</p><pre class="programlisting">«EXTENSION org :: eclipse :: xtend :: util :: stdlib :: io»...«DEFINE javaClass FOR Entity»«REM»以下表达式将转储功能名称而不产生输出作为副作用«ENDREM»«features.name.info（） - &gt;“”»</pre><p>这将在控制台上产生此输出：</p><pre class="programlisting">1122 INFO IOExtensions  -  [姓名，年龄，地址] 1740 INFO IOExtensions  -  [街道，邮编，城市]</pre><p>每个函数都返回调用它们的对象，因此您可以构建链表达式。或者，换句话说，如果你有一些表达式</p><pre class="programlisting">element.xyzselect（T | t.someProp）.A</pre><p>你总是可以在任何地方嵌入其中一个io功能</p><pre class="programlisting">element.x。 <span class="emphasis"><em>syserr（）。</em></span> yzselect（t | t.someProp.info <span class="emphasis"><em>（）</em></span> ）。a</pre></div><div class="section" title="控制日志级别"><div class="titlepage"><div><div><h4 class="title"><a name="N124AF"></a>控制日志级别</h4></div></div></div><p>您可能希望控制通过日志记录工具打印的消息的日志记录级别。具体配置方式取决于底层日志框架。Xpand使用Apache Commons Logging库，它可以调度到另一个日志框架，主要是Log4J。</p><p>要精确控制IO扩展的日志记录级别，您必须知道消息所记录的类别。通常使用使用记录器的类的类名。对于IO扩展，此类是<code class="classname">org.eclipse.xtend.util.stdlib.IOExtensions</code> 。</p><p>以下示例显示了一个Log4J配置文件，该文件将禁用低于警告的日志级别。只有在类路径的开头找到属性文件时，此示例才有效。确保在类路径上的任何其他Log4J配置之前找到该文件。该文件必须命名为<code class="filename">log4j.properties</code> 。</p><pre class="programlisting">log4j.appender。CONSOLE = org.apache.log4j。ConsoleAppender log4j.appender。CONSOLE.layout = org.apache.log4j。PatternLayout log4j.appender。CONSOLE.layout。ConversionPattern =％p％C {1}％m％n log4j.rootLogger = INFO，CONSOLE＃抑制来自IOExtensions的信息消息log4j.logger.org.eclipse.xtend.util.stdlib。IOExtensions = WARN，CONSOLE log4j.additivity.org.eclipse.xtend.util.stdlib。IOExtensions = FALSE</pre></div></div><div class="section" title="柜台扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N124C0"></a>柜台扩展</h3></div></div></div><p>有时需要在转换代码中包含计数器。计数器扩展可以初始化，操作和检索计数器。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse:xtend:::util::stdlib::counter</code></p><div class="section" title="int counterInc（Object o）"><div class="titlepage"><div><div><h4 class="title"><a name="N124CA"></a> int counterInc（Object o）</h4></div></div></div><p>增加一个计数器。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 此计数器的键。如果使用<code class="code">null</code>参数调用此函数，则使用匿名计数器。如果没有为密钥注册计数器，则将创建一个新的计数器实例并使用0初始化。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>递增的计数器。</p></div><div class="section" title="int counterDec（Object o）"><div class="titlepage"><div><div><h4 class="title"><a name="N124DD"></a> int counterDec（Object o）</h4></div></div></div><p>减少一个柜台。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 此计数器的键。如果使用<code class="code">null</code>参数调用此函数，则使用匿名计数器。如果没有为密钥注册计数器，则将创建一个新的计数器实例并使用0初始化。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>递减的计数器。</p></div><div class="section" title="int counterReset（Object o）"><div class="titlepage"><div><div><h4 class="title"><a name="N124F0"></a> int counterReset（Object o）</h4></div></div></div><p>重置计数器。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 此计数器的键。如果使用<code class="code">null</code>参数调用此函数，则使用匿名计数器。如果没有为密钥注册计数器，则将创建一个新的计数器实例并使用0初始化。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>总是0。</p></div><div class="section" title="int counterGet（Object o）"><div class="titlepage"><div><div><h4 class="title"><a name="N12503"></a> int counterGet（Object o）</h4></div></div></div><p>检索计数器的当前状态。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>o  - 此计数器的键。如果使用<code class="code">null</code>参数调用此函数，则使用匿名计数器。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>当前计数器值。</p></div><div class="section" title="例"><div class="titlepage"><div><div><h4 class="title"><a name="N12516"></a>例</h4></div></div></div><pre class="programlisting">«DEFINE CounterExtensionsDemo FOR Object»«FILE“CounterExtensions.txt”»第一个计数器：get：«counterGet（）»inc：«counterInc（）»inc：«counterInc（）»inc：«counterInc（）»dec：«counterDec（ ）»第二个（命名）计数器：inc：«counterInc（“idx”）»inc：«counterInc（“idx”）»inc：«counterInc（“idx”）»reset：«counterReset（“idx”）»inc： «counterInc（“idx”）»第一个计数器：inc：«counterInc（）»«ENDFILE»«ENDDEFINE»</pre><p>此示例将创建以下输出：</p><pre class="programlisting">第一个计数器：get：0 inc：1 inc：2 inc：3 dec：2 Second（named）counter：inc：1 inc：2 inc：3 reset：0 inc：1 First counter：inc：3</pre></div></div><div class="section" title="属性扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N12520"></a>属性扩展</h3></div></div></div><p>您可能希望从转换代码中的属性文件中指定配置值。属性扩展可以帮助您。在能够通过扩展功能访问属性之前，必须读取属性文件并存储其值。这是通过工作流组件<span class="emphasis"><em>PropertiesReader完成的</em></span> ，如下所述。</p><p><span class="emphasis"><em>扩展：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::properties</code></p><div class="section" title="String getProperty（String key）"><div class="titlepage"><div><div><h4 class="title"><a name="N1252E"></a> String getProperty（String key）</h4></div></div></div><p>检索配置属性。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">o</code> - 属性密钥</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>属性值，如果已定义，则<span class="emphasis"><em>返回</em></span> null。</p></div><div class="section" title="工作流程组件"><div class="titlepage"><div><div><h4 class="title"><a name="N12540"></a>工作流程组件</h4></div></div></div><p>工作流组件PropertiesReader用于加载属性文件。可以通过多次添加propertiesFile标记来配置多个属性文件。</p><div class="table"><a name="N12545"></a><p class="title"><b>表格1。工作流组件org.eclipse.xtend.util.stdlib。PropertiesReader</b></p><div class="table-contents"><table border="1" summary="Workflow component
          org.eclipse.xtend.util.stdlib.PropertiesReader"><colgroup><col><col><col><col></colgroup><tbody><tr><td>属性</td><td>类型</td><td>强制性</td><td>描述</td></tr><tr><td>propertiesFile</td><td>串</td><td>是</td><td>要读取的属性文件</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="例"><div class="titlepage"><div><div><h4 class="title"><a name="N1255D"></a>例</h4></div></div></div><p>工作流程配置：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.util.stdlib。PropertiesReader“&gt; &lt;propertiesFile value =”src / config1.properties“/&gt; &lt;propertiesFile value =”src / config2.properties“/&gt; &lt;/ component&gt;</pre><p><code class="filename">config1.properties</code> ：</p><pre class="programlisting">shapes = box，polygon，ellipse，point</pre><p>扩展中的用法：</p><pre class="programlisting">扩展org :: eclipse :: xtend :: util :: stdlib :: properties;缓存List [String] SHAPES（）：getProperty（“shapes”）。split（“，”）。trim（）;</pre></div></div><div class="section" title="元素属性扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N1256E"></a>元素属性扩展</h3></div></div></div><p>这允许您临时将名称 - 值对与任何模型元素相关联。</p><p><span class="emphasis"><em>扩展：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::elementprops</code></p><p></p><div class="section" title="void setProperty（Object element，String name，Object value）"><div class="titlepage"><div><div><h4 class="title"><a name="N1257A"></a> void setProperty（Object element，String name，Object value）</h4></div></div></div><p>将名为<code class="code">name</code>的属性设置为值。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">element</code> - 模型元素</p></li><li class="listitem"><p><code class="code">name</code> - 属性名称</p></li><li class="listitem"><p><code class="code">element</code> - 属性值</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>没什么。</p></div><div class="section" title="Object getProperty（Object element，String name）"><div class="titlepage"><div><div><h4 class="title"><a name="N12599"></a> Object getProperty（Object element，String name）</h4></div></div></div><p>从元素中检索动态属性。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">element</code> - 模型元素</p></li><li class="listitem"><p><code class="code">name</code> - 属性名称</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>属性值。</p></div></div><div class="section" title="问题扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N125B0"></a>问题扩展</h3></div></div></div><p>在模板代码中，无法直接访问工作流上下文的“问题”实例。问题扩展有助于在转换期间向“问题”实例报告警告和错误。</p><p>这不应该鼓励您使用约束检查，并且通常直接从转换中引发错误。但是，有时能够这样做是明智和有用的。</p><p><span class="emphasis"><em>扩展：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::issues</code></p><div class="section" title="字符串reportWarning（String message）"><div class="titlepage"><div><div><h4 class="title"><a name="N125BC"></a>字符串reportWarning（String message）</h4></div></div></div><p>向工作流上下文报告警告消息。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">message</code> - 消息</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>消息。</p></div><div class="section" title="字符串reportWarning（Object object，String message）"><div class="titlepage"><div><div><h4 class="title"><a name="N125CE"></a>字符串reportWarning（Object object，String message）</h4></div></div></div><p>向工作流上下文报告警告消息和上下文对象的限定名称。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">object</code> - 上下文对象</p></li><li class="listitem"><p><code class="code">message</code> - 消息</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>消息。</p></div><div class="section" title="字符串reportError（字符串消息）"><div class="titlepage"><div><div><h4 class="title"><a name="N125E5"></a>字符串reportError（字符串消息）</h4></div></div></div><p>向工作流上下文报告错误消息。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">message</code> - 消息</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>消息。</p></div><div class="section" title="字符串reportError（对象对象，字符串消息）"><div class="titlepage"><div><div><h4 class="title"><a name="N125F7"></a>字符串reportError（对象对象，字符串消息）</h4></div></div></div><p>向工作流上下文报告错误消息和上下文对象的限定名称。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">object</code> - 上下文对象</p></li><li class="listitem"><p><code class="code">message</code> - 消息</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>消息。</p></div><div class="section" title="工作流程组件"><div class="titlepage"><div><div><h4 class="title"><a name="N1260E"></a>工作流程组件</h4></div></div></div><p>问题扩展需要工作流组件<code class="classname">org.eclipse.xtend.util.stdlib.在调用扩展之前，在工作流中配置ExtIssueReporter</code> 。此组件的目的是使工作流的“问题”实例可用于扩展。</p><p><code class="classname">ExtIssueReporter</code>组件没有任何属性。</p></div><div class="section" title="例"><div class="titlepage"><div><div><h4 class="title"><a name="N1261B"></a>例</h4></div></div></div><p>工作流程配置：</p><pre class="programlisting">&lt;？xml版本=“1.0”？&gt; &lt;工作流程&gt; ......&lt;component class =“xpand.util.stdlib。ExtIssueReporter“/&gt;</pre><p>从Xtend使用：</p><pre class="programlisting">导入元模型;扩展org :: eclipse :: xtend :: util :: stdlib :: issues; demo（Model this）：issuesExtensionsDemo（）; issuesExtensionsDemo（）：reportWarning（“报告从Xtend到工作流的警告消息”）;</pre><p>控制台输出：</p><pre class="programlisting">INFO WorkflowRunner运行工作流程：workflow / generator.mwe ......INFO CompositeComponent ExtIssueReporter：从.ext和.xpt文件中设置问题日志记录INFO WorkflowRunner工作流程在1101ms完成！WARN WorkflowRunner报告从Xtend到工作流的警告消息</pre></div></div><div class="section" title="命名扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N1262A"></a>命名扩展</h3></div></div></div><p>命名扩展仅适用于EMF模型。这个有助于名称，限定名称和命名空间。限定名称定义为元素的包含层次结构的原始名称的seuqence，由点分隔（例如java.lang。串）。为了使其工作，模型元素应具有EString类型的name属性。 <sup>[ <a href="#ftn.N1262F" name="N1262F" class="footnote">9</a> ]</sup></p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::naming</code></p><div class="section" title="String namespace（Object this）"><div class="titlepage"><div><div><h4 class="title"><a name="N12637"></a> String namespace（Object this）</h4></div></div></div><p>返回命名空间，即限定名称减去元素本身的名称。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">this</code> - 一个模型元素</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>元素的限定名称空间名称。</p></div><div class="section" title="String qualifiedName（Object this）"><div class="titlepage"><div><div><h4 class="title"><a name="N12649"></a> String qualifiedName（Object this）</h4></div></div></div><p>通过评估元素的包含层次结构，返回元素的限定名称（以点分隔）。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">this</code> - 一个模型元素</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>元素的限定名称。</p></div><div class="section" title="String loc（Object this）"><div class="titlepage"><div><div><h4 class="title"><a name="N1265B"></a> String loc（Object this）</h4></div></div></div><p>试图在模型中构建一个有用的元素描述;对错误报告非常有用。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">this</code> - 一个模型元素</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>有关元素的位置信息。</p></div><div class="section" title="对象findByName（集合候选者，字符串名称）"><div class="titlepage"><div><div><h4 class="title"><a name="N1266D"></a>对象findByName（集合候选者，字符串名称）</h4></div></div></div><p>在候选者中搜索具有特定名称的元素。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">candidates</code> - 模型元素的集合</p></li><li class="listitem"><p><code class="code">name</code> - 搜索的元素名称</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>搜索的元素;如果候选集合中不包含具有该名称的元素，则<span class="emphasis"><em>返回</em></span> null。</p></div></div><div class="section" title="Globalvar扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N12684"></a> Globalvar扩展</h3></div></div></div><p>有时您可能希望在转换过程中共享信息。一种替代方法是使用GLOBALVAR表达式，但这需要在工作流中配置变量。Globalvar扩展有助于在转换过程中存储和检索对象。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::globalvar</code></p><div class="section" title="例"><div class="titlepage"><div><div><h4 class="title"><a name="N1268E"></a>例</h4></div></div></div><p>在Xtend中的用法：</p><pre class="programlisting">导入元模型;扩展org :: eclipse :: xtend :: util :: stdlib :: io;扩展org :: eclipse :: xtend :: util :: stdlib :: globalvar; demo（Model this）：globalvarExtensionsDemo1（） - &gt; globalvarExtensionsDemo2（）; globalvarExtensionsDemo1（）：“存储全局变量...”。info（） - &gt; storeGlobalVar（“msg”，“Xpand很酷！“）; globalvarExtensionsDemo2（）:(”从全局变量获取消息：“+ getGlobalVar（”msg“））。info（）;</pre><p>控制台输出：</p><pre class="programlisting">INFO IOExtensions存储全局变量...INFO IOExtensions从全局var：Xpand获取消息是很酷的东西！</pre><p>这是一个存储字符串的简单示例，但当然您可以通过这种方式存储任何表达式的结果。</p></div></div><div class="section" title="克隆扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N1269B"></a>克隆扩展</h3></div></div></div><p>克隆实用程序可帮助您克隆模型元素及其所有子元素。<code class="code">clone(Object)</code>函数克隆单个对象及其子对象，而<code class="code">clone(List)</code>克隆元素列表。克隆的语义如下：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>作为参数传入的对象是重复的</p></li><li class="listitem"><p>通过包含引用引用的所有对象也是递归复制的</p></li><li class="listitem"><p>属性的值是重复的</p></li><li class="listitem"><p>在未克隆目标时复制对其他对象的非包含引用（在新对象中创建对原始的引用）</p></li></ul></div><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::cloning</code></p><div class="section" title="对象克隆（对象原始）"><div class="titlepage"><div><div><h4 class="title"><a name="N126B9"></a>对象克隆（对象原始）</h4></div></div></div><p>克隆一个对象。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">original</code> - 应该克隆的对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>克隆的对象。</p></div><div class="section" title="列表克隆（列表l）"><div class="titlepage"><div><div><h4 class="title"><a name="N126CB"></a>列表克隆（列表l）</h4></div></div></div><p>克隆对象列表。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">l</code> - 来源清单。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>克隆对象的列表。</p></div></div><div class="section" title="交叉引用扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N126DD"></a>交叉引用扩展</h3></div></div></div><p>有时需要找到引用特定对象的对象。此扩展有助于解决此重复任务。此扩展名仅可用于基于EMF的模型。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::crossref</code></p><div class="section" title="List [EObject] getReferencingObjects（EObject target）"><div class="titlepage"><div><div><h4 class="title"><a name="N126E7"></a> List [EObject] getReferencingObjects（EObject target）</h4></div></div></div><p>检索引用给定对象的对象。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">target</code> - 目标对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>引用目标的对象列表。</p></div><div class="section" title="例"><div class="titlepage"><div><div><h4 class="title"><a name="N126F9"></a>例</h4></div></div></div><p>在Xtend中的用法：</p><pre class="programlisting">扩展org :: eclipse :: xtend :: util :: stdlib :: crossref; crossRefDemo（Model this）：eAllContents.typeSelect（Datatype）.dumpCrossReferences（）; dumpCrossReferences（datatype this）:(“对数据类型的交叉引用数”+ name +“：”+ getReferencingObjects（）。size）.info（）;</pre><p>控制台输出：</p><pre class="programlisting">INFO IOExtensions数据类型的交叉引用数Integer：1 INFO IOExtensions数据类型的交叉引用数字符串：4</pre></div></div><div class="section" title="UID扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N12704"></a> UID扩展</h3></div></div></div><p>通常需要通过转换过程为对象创建和检索唯一标识符。UID扩展为此任务提供了一种简单的机制。唯一标识符根据当前系统时间加上内部计数器计算得出。因此，扩展仅保证标识符在一个工作流程执行中保持不变，但将通过不同的运行进行更改。如果您需要在每一代运行中保持相同的唯一标识符（例如，对于受保护的区域ID），那么您需要另一种机制。</p><p>如果要加载为<code class="classname">EObject</code>分配ID的模型（仅适用于基于EMF的模型），则<code class="methodname">xmlId()</code>函数将非常有用。特别是在使用UML2模型时，此函数将返回对象的唯一且不变的标识符。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::uid</code></p><div class="section" title="缓存的字符串uid（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N12717"></a>缓存的字符串uid（对象o）</h4></div></div></div><p>检索对象的唯一标识符。首次访问时创建一个新的。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">o</code> - 模型元素或其他对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>此对象的UID</p></div><div class="section" title="字符串createUID（对象o）"><div class="titlepage"><div><div><h4 class="title"><a name="N12729"></a>字符串createUID（对象o）</h4></div></div></div><p>为对象创建唯一标识符。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">o</code> - 模型元素或其他对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>此对象的新创建的UID。</p></div><div class="section" title="String xmlId（ecore :: EObject o）"><div class="titlepage"><div><div><h4 class="title"><a name="stdlib_uid_xmlid"></a> String xmlId（ecore :: EObject o）</h4></div></div></div><p>检索对象的标识符。必须从XMLResource读取该对象。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">o</code> - 一个对象。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>对象的id。如果未从XMLResource加载对象，则返回null。</p></div></div><div class="section" title="Mixin扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N1274E"></a> Mixin扩展</h3></div></div></div><p>这些实用程序有助于mixin模型。Mixin模型通常是简单模型，可在变换的源模型中提供有关模型元素的其他信息。它们可以被视为注释。</p><p>这些实用程序期望mixin模型具有非常特定的结构：根元素，然后是任何子树，其中元素具有name属性。这是一个例子：</p><div class="figure"><a name="N12755"></a><p class="title"><b>图1。Mixin模型示例</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/stdlib/mixinmodel.png" width="432" alt="Mixin模型示例"></div></div></div></div><br class="figure-break"><p>mixin元素是<code class="classname">ControllingServiceRefSpec</code>和<code class="classname">BundleSpec</code> 。它们由根元素<code class="classname">Cbd2OsgiMixin</code> 。该名称应包含注释引用的元素的限定名称。一旦模型设置如此，并使用工作流的GLOBALVAR工具进行转换，您就可以使用扩展功能。</p><p>扩展名：org :: eclipse :: xtend :: util :: stdlib :: mixin</p><div class="section" title="Object getMandatoryMixin（Object mixinModel，Object ctx，xpand2 :: Type t）"><div class="titlepage"><div><div><h4 class="title"><a name="N1276D"></a> Object getMandatoryMixin（Object mixinModel，Object ctx，xpand2 :: Type t）</h4></div></div></div><p>返回上下文对象的相应mixin元素; mixin必须是t类型，并且其name属性必须对应于上下文的限定名称。如果未找到，则引发工作流ERROR并返回null对象（因此您可以在其上调用其他操作而不会获得null评估错误）。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">mixinModel</code> -  mixin模型的根元素。</p></li><li class="listitem"><p><code class="code">ctx</code> - 上下文对象。</p></li><li class="listitem"><p><code class="code">t</code> -  mixin模型元素的类型。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>与ctx对应的mixin模型元素。</p></div><div class="section" title="Object getOptionalMixin（Object mixinModel，Object ctx，xpand2 :: Type t）"><div class="titlepage"><div><div><h4 class="title"><a name="N12789"></a> Object getOptionalMixin（Object mixinModel，Object ctx，xpand2 :: Type t）</h4></div></div></div><p>与getMandatoryMixin（）相同，但如果未找到任何内容，则不会引发错误。</p></div></div><div class="section" title="跟踪扩展"><div class="titlepage"><div><div><h3 class="title"><a name="N1278E"></a>跟踪扩展</h3></div></div></div><p>跟踪扩展允许在模型转换期间创建跟踪路径。这是通过创建跟踪模型来完成的，该模型保存从源元素到目标元素的引用。必须将跟踪显式添加到转换代码中。</p><p><span class="emphasis"><em>扩展名：</em></span> <code class="classname">org::eclipse::xtend::util::stdlib::tracing</code></p><div class="section" title="Void createTrace（Object from，Object to，String kind，String backKind）"><div class="titlepage"><div><div><h4 class="title"><a name="N12799"></a> Void createTrace（Object from，Object to，String kind，String backKind）</h4></div></div></div><p>在两个元素之间创建跟踪。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">from</code> - 来源元素。</p></li><li class="listitem"><p><code class="code">to</code> - 目标元素。</p></li><li class="listitem"><p><code class="code">kind</code> - 从源到目标的跟踪的名称。</p></li><li class="listitem"><p><code class="code">backkind</code> - 从目标返回到源的跟踪的名称。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>没什么。</p></div><div class="section" title="Void createTrace（Object from，Object to，String kind）"><div class="titlepage"><div><div><h4 class="title"><a name="N127BA"></a> Void createTrace（Object from，Object to，String kind）</h4></div></div></div><p>在两个元素之间创建跟踪。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">from</code> - 来源元素。</p></li><li class="listitem"><p><code class="code">to</code> - 目标元素。</p></li><li class="listitem"><p><code class="code">kind</code> - 从源到目标的跟踪的名称。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>没什么。</p></div><div class="section" title="Void clearTrace（）"><div class="titlepage"><div><div><h4 class="title"><a name="N127D6"></a> Void clearTrace（）</h4></div></div></div><p>清除所有痕迹。</p><p><span class="emphasis"><em>参数：</em></span>无</p><p><span class="emphasis"><em>返回：</em></span>没什么。</p></div><div class="section" title="Object getSingleTraceTarget（Object from，String kind）"><div class="titlepage"><div><div><h4 class="title"><a name="N127E3"></a> Object getSingleTraceTarget（Object from，String kind）</h4></div></div></div><p>找到跟踪的目标。如果找不到源元素到指定类型的目标的跟踪，则此函数将报告错误。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">from</code> - 来源元素。</p></li><li class="listitem"><p><code class="code">kind</code> - 跟踪类型名称。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>该跟踪的目标元素。</p></div><div class="section" title="Boolean hasTrace（Object from，String kind）"><div class="titlepage"><div><div><h4 class="title"><a name="N127FA"></a> Boolean hasTrace（Object from，String kind）</h4></div></div></div><p>证明某些元素是否存在特定类型的痕迹。</p><p><span class="emphasis"><em>参数：</em></span></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">from</code> - 来源元素。</p></li><li class="listitem"><p><code class="code">kind</code> - 跟踪类型名称。</p></li></ul></div><p><span class="emphasis"><em>返回：</em></span>如果元素存在该类型的跟踪，则<span class="emphasis"><em>返回</em></span> true。</p></div></div></div><div class="section" title="Stdlib工作流程组件"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="N12811"></a> Stdlib工作流程组件</h2></div></div></div><p>除了上一节中描述的扩展，Xpand的Stdlib还提供了一些工作流组件。</p><div class="section" title="SystemCommand"><div class="titlepage"><div><div><h3 class="title"><a name="N12816"></a> SystemCommand</h3></div></div></div><p>该组件执行系统命令<a name="N1281B" class="indexterm"></a> 。</p><div class="table"><a name="N1281F"></a><p class="title"><b>表2。工作流组件org.eclipse.xtend.util.stdlib。SystemCommand</b></p><div class="table-contents"><table border="1" summary="Workflow component
        org.eclipse.xtend.util.stdlib.SystemCommand"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">强制性</th><th align="center">描述</th></tr></thead><tbody><tr><td>命令</td><td>串</td><td>是</td><td>要执行的命令。</td></tr><tr><td>目录</td><td>串</td><td>没有</td><td>执行目录。</td></tr><tr><td>ARG</td><td>串</td><td>没有</td><td>（多个）命令参数</td></tr><tr><td>ENV</td><td>串</td><td>没有</td><td>（多个）其他环境条目。格式：[键]，[值]</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.util.stdlib。SystemCommand“&gt; &lt;directory value =”src-gen“/&gt; &lt;command value =”sh“/&gt; &lt;arg value =”processdot.sh“/&gt; &lt;/ component&gt;</pre><p><span class="bold"><strong>控制台输出：</strong></span></p><pre class="programlisting">1639 INFO  - 在目录[absolutepath]中运行命令'[sh，processdot.sh]'...1667 INFO  - 处理shape_box.dot ...2597 INFO  - 处理shape_polygon.dot ......3564 INFO  - 命令执行成功。</pre><p>Windows提示：</p><p>在Windows上执行命令时，通常使用cmd作为命令值来完成。命令终止很重要，因此参数/ c必须作为arg值附加。 <sup>[ <a href="#ftn.N1286F" name="N1286F" class="footnote">10</a> ]</sup></p></div><div class="section" title="SlotCopier"><div class="titlepage"><div><div><h3 class="title"><a name="N12879"></a> SlotCopier<a name="N1287C" class="indexterm"></a></h3></div></div></div><p>此组件将元素从一个插槽复制到另一个插槽。插槽内容未克隆。</p><div class="table"><a name="N12882"></a><p class="title"><b>表3。工作流组件org.eclipse.xtend.util.stdlib。SlotCopier</b></p><div class="table-contents"><table border="1" summary="Workflow component
          org.eclipse.xtend.util.stdlib.SlotCopier"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">强制性</th><th align="center">描述</th></tr></thead><tbody><tr><td>fromSlot</td><td>串</td><td>是</td><td>源槽名称。</td></tr><tr><td>toSlot</td><td>串</td><td>是</td><td>目标插槽名称。</td></tr><tr><td>removeTopLevelList</td><td>布尔</td><td>没有</td><td>如果为true，则源槽必须包含列表并删除顶级列表（即列表中的第一个元素被复制到目标槽），否则不会删除它。</td></tr></tbody></table></div></div><p><br class="table-break"><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.util.stdlib。SlotCopier“&gt; &lt;fromSlot value =”model“/&gt; &lt;toSlot value =”target“/&gt; &lt;/ component&gt;</pre><p><span class="bold"><strong>控制台输出：</strong></span></p><pre class="programlisting">INFO SlotCopier复制org.eclipse.emf.ecore.impl。DynamicEObjectImpl @ 1fdbef（eClass：org.eclipse.emf.ecore.impl。EClassImpl @ fc5b01（name：Model）（instanceClassName：null）（abstract：false，interface：false））[org.eclipse.emf.ecore.impl。DynamicEObjectImpl]</pre></div><div class="section" title="SlotListAdder"><div class="titlepage"><div><div><h3 class="title"><a name="N128C4"></a> SlotListAdder<a name="N128C7" class="indexterm"></a></h3></div></div></div><p>此组件将元素从一个插槽复制到另一个插槽中包含的列表。</p><div class="table"><a name="N128CC"></a><p class="title"><b>表4。工作流组件org.eclipse.xtend.util.stdlib。SlotListAdder</b></p><div class="table-contents"><table border="1" summary="Workflow component
        org.eclipse.xtend.util.stdlib.SlotListAdder"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">强制性</th><th align="center">描述</th></tr></thead><tbody><tr><td>modelSlot</td><td>串</td><td>是</td><td>源槽名称。</td></tr><tr><td>listSlot</td><td>串</td><td>是</td><td>目标插槽名称。此插槽包含元素列表。</td></tr><tr><td>uniqueNames</td><td>布尔</td><td>没有</td><td>如果为true，则名称必须是唯一的，否则不是。要求modelSlot包含EObject。</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>例：</strong></span></p><p>此示例将插槽'model'的内容添加到插槽'targetList'。插槽'targetList'在执行时不包含任何内容。</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.util.stdlib。SlotListAdder“&gt; &lt;modelSlot value =”model“/&gt; &lt;listSlot value =”targetList“/&gt; &lt;/ component&gt;</pre><p><span class="bold"><strong>控制台输出：</strong></span></p><pre class="programlisting">INFO CompositeComponent SlotListAdder：将插槽'model'的内容添加到'targetList'中的东西列表中......INFO WorkflowRunner工作流程在1503ms完成！WARN WorkflowRunner'targetList'为空，创建一个新列表。[org.eclipse.xtend.util.stdlib。SlotListAdder @ 7536e7]</pre><p>请注意，警告消息将在工作流完成后显示，因为它们被报告为工作流警告问题。</p></div><div class="section" title="SlotPrinter"><div class="titlepage"><div><div><h3 class="title"><a name="N12913"></a> SlotPrinter<a name="N12916" class="indexterm"></a></h3></div></div></div><p>此组件将工作流上下文槽内容打印到日志。这对于调试目的很有用。</p><div class="table"><a name="N1291B"></a><p class="title"><b>表5。工作流组件org.eclipse.xtend.util.stdlib。SlotPrinter</b></p><div class="table-contents"><table border="1" summary="Workflow component
        org.eclipse.xtend.util.stdlib.SlotPrinter"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">强制性</th><th align="center">描述</th></tr></thead><tbody><tr><td>插槽名</td><td>串</td><td>是</td><td>应转储其内容的插槽的名称。</td></tr><tr><td>信息</td><td>串</td><td>没有</td><td>一个可选的消息，它将以日志输出为前缀。</td></tr><tr><td>水平</td><td>串</td><td>没有</td><td>消息的日志级别。有效值为TRACE，DEBUG，INFO，WARN。</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>例：</strong></span></p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.util.stdlib。SlotPrinter“&gt; &lt;slotName value =”model“/&gt; &lt;message value =”DUMP“/&gt; &lt;level value =”INFO“/&gt; &lt;/ component&gt;</pre><p><span class="bold"><strong>控制台输出：</strong></span></p><pre class="programlisting">INFO SlotPrinter DUMP :( slot：model）org.eclipse.emf.ecore.impl。DynamicEObjectImpl @ d22ddb（eClass：org.eclipse.emf.ecore.impl。EClassImpl @ fe0ce9（name：Model）（instanceClassName：null）（abstract：false，interface：false））</pre></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[ <a href="#N1262F" name="ftn.N1262F" class="para">9</a> ]</sup> uml2ecore实用程序可以自动为每个元类添加这样的name属性。</p></div><div class="footnote"><p><sup>[ <a href="#N1286F" name="ftn.N1286F" class="para">10</a> ]</sup>参见<a class="ulink" href="http://www.ss64.com/nt/cmd.html" target="_new">http://www.ss64.com/nt/cmd.html</a> ， <a class="ulink" href="http://www.java-forum.org/de/viewtopic.php?p=469059" target="_new">http://www.java-forum.org/de/viewtopic.php?p=469059</a></p></div></div></div><div class="chapter" title="Chapter 9. Xpand Eclipse集成"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Xpand Eclipse集成</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#eclipse_integration_introduction">介绍</a></span></dt><dt><span class="section"><a href="#eclipse_integration_installation">安装</a></span></dt><dt><span class="section"><a href="#eclipse_integration_overview">概观</a></span></dt><dt><span class="section"><a href="#eclipse_integration_file_decorations">文件装饰</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors">编者</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_editors_syntax_coloring">语法着色</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors_code_completion">代码完成</a></span></dt><dt><span class="section"><a href="#eclipse_integration_editors_xpand_tag_delimiter"><span class="emphasis"><em>Xpand</em></span>标记分隔符创建支持</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_preference_pages">首选项页面</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_preference_pages_meta_model_contributors">Metamodel贡献者</a></span></dt><dt><span class="section"><a href="#eclipse_integration_preference_pages_global_preferences">全球偏好</a></span></dt><dt><span class="section"><a href="#eclipse_integration_preference_pages_preferences_per_project">每个项目的偏好</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_xpand_nature_builder">Xpand Nature和Xpand Builder</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse_integration_xpand_nature_builder_problem_markers">问题标记</a></span></dt></dl></dd><dt><span class="section"><a href="#eclipse_integration_running_a_workflow">运行工作流程</a></span></dt></dl></div><div class="section" title="介绍"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_introduction"></a>介绍</h2></div></div></div><p>本文档描述了Xpand插件为Eclipse安装做出的各种功能。它旨在作为使用Eclipse的用户指令。您需要阅读其他文档以了解Xpand框架本身。</p></div><div class="section" title="安装"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_installation"></a>安装</h2></div></div></div><p>假设您已经按照<span class="emphasis"><em>安装文档</em></span>中的<span class="emphasis"><em>说明</em></span>从更新站点安装了Xpand核心和Xpand UI功能。</p></div><div class="section" title="概观"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_overview"></a>概观</h2></div></div></div><p>Xpand UI插件提供不同语言的编辑器和启动工作流文件的启动快捷方式。我们先来看看不同的Xpand特定文件。</p></div><div class="section" title="文件装饰"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_file_decorations"></a>文件装饰</h2></div></div></div><p>当您打开Eclipse并将项目导入工作区时，您可以看到几个文件装饰图像。</p><div class="informaltable"><table border="0"><colgroup><col width=""><col width="" align="left"></colgroup><tbody><tr valign="top"><td align="left" valign="top"><p>有特定的图像：</p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>工作流文件（ <code class="filename">.mwe</code>扩展名）</p></li><li class="listitem"><p><span class="emphasis"><em>Xpand2</em></span>模板（ <code class="filename">.xpt</code>扩展名）</p></li><li class="listitem"><p>扩展文件（ <code class="filename">.ext</code>扩展名）</p></li><li class="listitem"><p><span class="emphasis"><em>检查</em></span>约束（ <code class="filename">.chk</code>扩展名）</p></li></ul></div></td><td align="left" valign="top"><div class="mediaobject"><img src="images/eclipse_integration/fileImages.png" width="NaN"></div></td></tr></tbody></table></div></div><div class="section" title="编者"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_editors"></a>编者</h2></div></div></div><p>当您双击上述文件类型之一时，将打开特殊编辑器，提供适当的语法着色。</p><div class="section" title="语法着色"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_editors_syntax_coloring"></a>语法着色</h3></div></div></div><p>以下是<span class="emphasis"><em>Xpand</em></span>编辑器的示例：</p><div class="mediaobject"><img src="images/eclipse_integration/xpandCodeHighlighting.jpg"></div><p>对于扩展编辑器：</p><div class="mediaobject"><img src="images/eclipse_integration/xtendCodeHighlighting.jpg"></div><p>对于<span class="emphasis"><em>Check</em></span>编辑器：</p><div class="mediaobject"><img src="images/eclipse_integration/checkCodeHighlighting.jpg"></div></div><div class="section" title="代码完成"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_editors_code_completion"></a>代码完成</h3></div></div></div><p>编辑器通过按<span class="keycap"><strong>Ctrl + Space</strong></span>提供广泛的代码完成支持，类似于Java编辑器中已知的。将找到可用的类型，属性和操作，以及<code class="filename">.ext</code>文件的扩展名。<span class="emphasis"><em>Xpand</em></span>编辑器还为<span class="emphasis"><em>Xpand</em></span>语言语句提供了额外的支持。</p><div class="mediaobject"><img src="images/eclipse_integration/codeCompletion.jpg"></div></div><div class="section" title="Xpand标记分隔符创建支持"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_editors_xpand_tag_delimiter"></a> <span class="emphasis"><em>Xpand</em></span>标记分隔符创建支持</h3></div></div></div><p>在<span class="emphasis"><em>Xpand</em></span>编辑器中，还有一个额外的按键可用于创建开始和结束标记括号，即<span class="foreignphrase"><em class="foreignphrase">guillemets</em></span> （“«”和“»”）。</p><div class="variablelist"><dl><dt><span class="term"><span class="keycap"><strong>Ctrl + &lt;</strong></span></span></dt><dd><p>创造“«”</p></dd><dt><span class="term"><span class="keycap"><strong>按Ctrl +&gt;</strong></span></span></dt><dd><p>创造“»”</p></dd></dl></div></div></div><div class="section" title="首选项页面"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_preference_pages"></a>首选项页面</h2></div></div></div><div class="section" title="Metamodel贡献者"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_preference_pages_meta_model_contributors"></a> Metamodel贡献者</h3></div></div></div><p>Xpand支持几种类型的元元模型。</p><p>从旧版本开始，可能会知道经典的UML元模型。目前，JavaBeans元模型和基于EMF的元模型也是开箱即用的。</p><p>可以通过扩展点注册其他元模型贡献者。</p><p>编辑需要知道你正在使用什么样的元模型。因此，可以在工作空间和项目级别配置元模型贡献者。</p></div><div class="section" title="全球偏好"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_preference_pages_global_preferences"></a>全球偏好</h3></div></div></div><p>如果您始终使用相同类型的元模型，则可以在全局首选项页面中指定元模型贡献者。它在<span class="emphasis"><em>Xtend / Xpand</em></span>部分的Windows  - &gt; Preferences下可用。</p></div><div class="section" title="每个项目的偏好"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_preference_pages_preferences_per_project"></a>每个项目的偏好</h3></div></div></div><p>在项目属性页面中还有一个<span class="emphasis"><em>Xtend / Xpand</em></span>部分。</p><p>在其中，您可以启用Xtend / Xpand特性（见下文）并设置项目特定的元模型贡献者设置。</p><div class="mediaobject"><img src="images/eclipse_integration/projectProperties.png"></div></div></div><div class="section" title="Xpand Nature和Xpand Builder"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_xpand_nature_builder"></a> Xpand Nature和Xpand Builder</h2></div></div></div><p>您已经在上一个屏幕截图中看到，您可以切换<span class="emphasis"><em>Xpand</em></span>性质。如果这样做，则为该项目中的所有Xpand特定文件类型启用分析器支持。</p><div class="section" title="问题标记"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse_integration_xpand_nature_builder_problem_markers"></a>问题标记</h3></div></div></div><p>在构建过程中，所有发现的问题都会在编辑器中标记，并在“ <span class="emphasis"><em>问题”</em></span>视图中列出。
      </p><div class="mediaobject"><img src="images/eclipse_integration/problemDisplay.jpg"></div><p>在当前实现中，当<span class="emphasis"><em>Eclipse</em></span>运行增量或完整构建时，将进行分析。这意味着，例如，在保存文件时会实现问题标记。如果您对问题标记的实际情况存在疑问，则应清理项目并重新进行重建。</p><p>请注意，如果更改例如扩展的签名，则不会自动分析引用工件（Xpand模板等）。</p></div></div><div class="section" title="运行工作流程"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="eclipse_integration_running_a_workflow"></a>运行工作流程</h2></div></div></div><p>您可以通过右键单击工作流文件<code class="filename">(*.mwe)</code>并选择<span class="guimenu">Run As</span> → <span class="guimenuitem">MWE工作流</span>来<span class="guimenu">启动</span> <span class="guimenuitem">工作流</span> 。</p><div class="mediaobject"><img src="images/eclipse_integration/workflowStart.png"></div><p>因为它是正常的启动配置，所以您可以使用普通的Eclipse功能运行甚至调试它。</p></div></div><div class="chapter" title="Chapter 9. 增量生成"><div class="titlepage"><div><div><h2 class="title">Chapter 9. 增量生成</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#incrementalGeneration_background">技术背景</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_usage">使用增量生成</a></span></dt><dd><dl><dt><span class="section"><a href="#incrementalGeneration_usage_facade">增量发电门面</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_usage_callback">增量生成回调</a></span></dt></dl></dd><dt><span class="section"><a href="#incrementalGeneration_notes">补充说明</a></span></dt><dd><dl><dt><span class="section"><a href="#incrementalGeneration_limitations">限制</a></span></dt><dt><span class="section"><a href="#incrementalGeneration_performance">性能注意事项</a></span></dt></dl></dd></dl></div><p>随着项目变得越来越大，通常他们的模型。但是，模型越大，代码生成过程所需的时间就越长。在成熟的项目中，开发人员通常只更改大型模型的一小部分。由于各种因素，对整个模型执行完整的代码生成过程会大大减慢开发周期：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">必须遍历整个模型，并且必须执行Xpand模板中的每个语句。模型越大，您拥有的Xpand模板越多，负面影响就越大。
      </li><li class="listitem">所有生成的文件都写入磁盘。I / O操作本身是总体运行时间的主要贡献者之一。更重要的是，文件通常由美化师进行后处理，这是另一个耗时的操作。如果您正在与受保护区域合作，其影响将更加显着。
      </li><li class="listitem">由于每个文件在代码生成后都有一个新的时间戳，通常编译器会获取这些新文件并开始编译，这会为进程增加更多的CPU和I / O周期。
      </li></ul></div><p>考虑到对于模型中的小变化，只有一小部分生成的文件实际上确实改变了它们的内容，执行完整生成显然是浪费时间。
  </p><p>从Helios发布系列（Eclipse 3.6，Xpand 0.8）开始，Xpand现在附带增量生成工具。这与Eclipse中的增量Java编译器非常相似。它检测自上一代过程以来模型的哪些部分发生了变化。然后，它确定由于该更改而需要生成哪些文件以及哪些文件不受其影响。只有前者是再生的，而后者则保持不变。
  </p><p>以下部分说明了此增量生成功能的工作原理以及如何使用它。
  </p><div class="section" title="技术背景"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="incrementalGeneration_background"></a>技术背景</h2></div></div></div><p>增量生成的关键在于知道模型中的哪个元素用于生成哪个文件。通过跟踪在任何给定的<code class="code">«FILE»</code>语句的上下文中访问模型的哪些部分，可以在生成期间容易地计算该信息。Xpand生成器的回调可以完成这项工作，并在运行中构建所谓的<span class="emphasis"><em>跟踪模型</em></span> 。
    </p><p>第二个重要信息是模型中发生的实际变化。基本上有两种计算方法。一种是在编辑模型时附加更改侦听器并在发生更改时捕获更改。另一种方法是保留模型的备份副本，并将旧版本与当前版本进行比较以计算更改。有关<a class="xref" href="#incrementalGeneration_performance" title="Performance Considerations">这</a>两种方法的优缺点，请参阅<a class="xref" href="#incrementalGeneration_performance" title="性能注意事项">“性能注意事项”一节</a> 。在任何一种情况下，结果都是所谓的<span class="emphasis"><em>差异模型</em></span> 。
    </p><p>当我们知道模型的哪些部分已经改变，并且我们也知道基于模型的这些部分生成了哪些文件时，我们可以跳过所有其他文件的生成，从而执行增量生成。
    </p></div><div class="section" title="使用增量生成"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="incrementalGeneration_usage"></a>使用增量生成</h2></div></div></div><div class="section" title="增量发电门面"><div class="titlepage"><div><div><h3 class="title"><a name="incrementalGeneration_usage_facade"></a>增量发电门面</h3></div></div></div><p>从增量生成中受益的最简单方法是使用<span class="emphasis"><em>IncrementalGenerationFacade</em></span>工作流组件：</p><pre class="programlisting">&lt;workflow&gt; &lt;component id =“incremental”class =“org.eclipse.xpand2.incremental。IncrementalGenerationFacade“&gt; &lt;newModelFile value =”path / to / your / model.file“/&gt; &lt;oldModelFile value =”path / to / backup / model.file“/&gt; &lt;traceModelFile value =”path / to / store / trace / model.trace“/&gt; &lt;outlet path =”path / to / your / outlet /“overwrite =”true“/&gt; &lt;/ component&gt; &lt;component id =”generator“class =”org.eclipse.xpand2。生成器“&gt; &lt;expand value =”your :: template :: Root FOR model“/&gt; &lt;outlet path =”temp /“overwrite =”true“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel“/&gt; &lt;vetoableCallback idRef =”incremental“/&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre><p><span class="emphasis"><em>IncrementalGenerationFacade</em></span>有四个参数：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>newModelFile</em></span>是存储要生成的模型的文件路径。此文件存储在名为<span class="emphasis"><em>model</em></span>的模型槽中
            </p></li><li class="listitem"><p><span class="emphasis"><em>oldModelFile</em></span>是存储模型的先前状态的副本的文件路径。在生成过程之后，模型会自动复制到此位置，并在生成器调用之间保持不变。
            </p></li><li class="listitem"><p><span class="emphasis"><em>traceModelFile</em></span>是生成进程的<span class="emphasis"><em>跟踪模型</em></span>存储在生成器调用之间的文件路径。
            </p></li><li class="listitem"><p>常规<span class="emphasis"><em>出口</em></span>列表必须与为常规生成器调用指定的<span class="emphasis"><em>出口</em></span>列表匹配。
            </p></li></ul></div><p>然后必须将<span class="emphasis"><em>IncrementalGenerationFacade</em></span>组件作为<span class="emphasis"><em>vetoableCallback</em></span>参数传递给Xpand <span class="emphasis"><em>Generator</em></span>的调用。
      </p><p>通过上面给出的简单工作流程，您应该能够观察到对于模型中的任何给定更改，仅重新生成受该更改影响的文件，而所有其他文件保持不变。即使删除元素也会导致从硬盘中删除特定（以前生成的）文件。
      </p><p>请注意，您必须为所有模型使用文件路径，因为它们是物理复制到硬盘上的。传递只能从类路径中解析的位置是不可能的。
      </p></div><div class="section" title="增量生成回调"><div class="titlepage"><div><div><h3 class="title"><a name="incrementalGeneration_usage_callback"></a>增量生成回调</h3></div></div></div><p>虽然<span class="emphasis"><em>IncrementalGenerationFacade</em></span>易于使用，但它的功能受到限制，并在其执行的操作中得到修复。使用<span class="emphasis"><em>IncrementalGenerationCallback</em></span>可以更好地控制所涉及的步骤。增量生成的典型工作流程需要执行以下任务：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>将（当前）模型读入插槽。
            </p></li><li class="listitem"><p>将模型的先前状态读入另一个插槽。当然，这可能不存在，例如对于第一次调用。在这种情况下必须执行完整生成。
            </p></li><li class="listitem"><p>计算模型的两个版本之间的更改（如果可能）并将该<span class="emphasis"><em>diff模型</em></span>放入插槽中。
            </p></li><li class="listitem"><p>读取在先前生成器调用期间计算的<span class="emphasis"><em>跟踪模型</em></span>并将其放入插槽。与模型的旧状态一样，这可能不存在，这也导致完全生成。
            </p></li><li class="listitem"><p>使用<span class="emphasis"><em>diff模型</em></span>和<span class="emphasis"><em>跟踪模型</em></span>初始化<span class="emphasis"><em>IncrementalGenerationCallback</em></span> 。
            </p></li><li class="listitem"><p>使用<span class="emphasis"><em>IncrementalGenerationCallback</em></span>运行Xpand <span class="emphasis"><em>Generator</em></span>组件。
            </p></li><li class="listitem"><p>清理过时的文件，即需要删除的文件，因为模型中的相应元素已被删除。
            </p></li><li class="listitem"><p>将在代码生成期间计算的新<span class="emphasis"><em>跟踪模型</em></span>写入硬盘，以便它可用于下一代进程。
            </p></li><li class="listitem"><p>制作模型的备份副本，以便在后续生成器调用时将其与下一版本进行比较。
            </p></li></ol></div><p>
      </p><p>这是执行所有这些步骤的示例工作流：</p><pre class="programlisting">&lt;workflow&gt; &lt;！ - 读取新模型 - &gt; &lt;component id =“modelreader”class =“org.eclipse.emf.mwe.utils。Reader“uri =”model / my.model“firstElementOnly =”true“modelSlot =”model“/&gt; &lt;！ - 读取旧模型，从上次运行中复制。可能不存在，因此忽略缺少的模型 - &gt; &lt;component id =“oldmodelreader”class =“org.eclipse.emf.mwe.utils。Reader“uri =”temp / old.model“firstElementOnly =”true“ignoreMissingModel =”true“modelSlot =”oldmodel“/&gt; &lt;！ -  compute diff。 - &gt; &lt;component id =”compare“class =”org。 eclipse.xpand2.incremental.compare。EmfCompare“oldModelSlot =”oldmodel“newModelSlot =”model“diffModelSlot =”diff“/&gt; &lt;！ - 读取跟踪模型，由上次运行生成。可能不存在，因此忽略缺少的模型 - &gt; &lt;component id =”tracemodelreader“类=“org.eclipse.emf.mwe.utils。Reader“uri =”temp / trace.trace“firstElementOnly =”true“ignoreMissingModel =”true“modelSlot =”oldtrace“/&gt; &lt;！ - 这是实际的增量生成回调 - &gt; &lt;component id =”incremental“类=“org.eclipse.xpand2.incremental。IncrementalGenerationCallback“diffModelSlot =”diff“oldTraceModelSlot =”oldtrace“newTraceModelSlot =”trace“/&gt; &lt;！ -  generate code  - &gt; &lt;component id =”generator“class =”org.eclipse.xpand2。生成器“&gt; &lt;expand value =”resources :: templates :: Test :: Test FOR model“/&gt; &lt;outlet path =”somewhere /“overwrite =”true“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem .EMF。EmfRegistryMetaModel“/&gt; &lt;vetoableCallback idRef =”incremental“/&gt; &lt;/ component&gt; &lt;！ -  clean assolete files  - &gt; &lt;component id =”cleaner“class =”org.eclipse.xpand2.incremental。FileCleaner“&gt; &lt;oldTraceModelSlot value =”oldtrace“/&gt; &lt;newTraceModelSlot value =”trace“/&gt; &lt;outlet path =”somewhere /“overwrite =”true“/&gt; &lt;/ component&gt; &lt;！ - 写跟踪模型 - &gt; &lt;component id =“tracemodelwriter”class =“org.eclipse.emf.mwe.utils。Writer“modelSlot =”trace“uri =”temp / trace.trace“/&gt; &lt;！ - 制作模型的备份副本 - &gt; &lt;component id =”copier“class =”org.eclipse.emf.mwe.utils。FileCopy“sourceFile =”model / my.model“targetFile =”temp / old.model“/&gt; &lt;/ workflow&gt;</pre></div></div><div class="section" title="补充说明"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="incrementalGeneration_notes"></a>补充说明</h2></div></div></div><div class="section" title="限制"><div class="titlepage"><div><div><h3 class="title"><a name="incrementalGeneration_limitations"></a>限制</h3></div></div></div><p>增量生成过程只能与基于EMF的模型一起使用。这是因为参考原始模型的所有中间工件（ <span class="emphasis"><em>差异模型</em></span>和<span class="emphasis"><em>跟踪模型</em></span> ）也存储为EMF模型。因此不可能参考其他模型格式。此外，您应确保模型具有各个模型元素的稳定ID，以便模型比较不会遇到任何歧义。
      </p><p>另请注意，目前，Xpand无法跟踪对JAVA扩展模型元素的访问。这可能导致特定模型元素的更改应触发要重新生成的特定（一组）文件的情况，但实际上不会。这是因为Xpand不知道在原始文件生成期间访问的模型元素，因此它没有迹象表明需要重新生成。因此，您应该尝试尽可能多地从Xpand或Xtend访问您的模型，并且只有在不可避免时才使用JAVA代码。
      </p></div><div class="section" title="性能注意事项"><div class="titlepage"><div><div><h3 class="title"><a name="incrementalGeneration_performance"></a>性能注意事项</h3></div></div></div><p>增量产生的主要性能优势来自于<span class="emphasis"><em>没有</em></span>做的事情，是没有必要的。鉴于<a class="xref" href="#incrementalGeneration_usage_callback" title="The Incremental Generation Callback">“增量生成回调”一节中</a>的工作流程， <a class="xref" href="#incrementalGeneration_usage_callback" title="增量生成回调">在</a>甚至可以确定是否必须生成文件之前，首先执行昂贵的模型比较操作似乎会适得其反。
      </p><p>虽然模型比较确实是一项非常昂贵的操作，但事实证明它仍然超过了不必要地生成文件的成本，即使不涉及后处理或后续编译器调用。
      </p><p>也就是说，如果没有模型比较，最好是在运行时捕捉模型的变化，这绝对是可取的。因此，无论何时在受控环境中工作，您都可能需要考虑将生成器调用与模型编辑器进行自定义集成。
      </p></div></div></div><div class="chapter" title="Chapter 9. 使用后端提高性能"><div class="titlepage"><div><div><h2 class="title">Chapter 9. 使用后端提高性能</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#backend_background">技术背景</a></span></dt><dd><dl><dt><span class="section"><a href="#backend_interpretation_background">它如何在解释模式下工作</a></span></dt></dl></dd><dt><span class="section"><a href="#backend_usage">使用后端</a></span></dt><dd><dl><dt><span class="section"><a href="#backend_quickstart">快速入门</a></span></dt><dt><span class="section"><a href="#backend_compiler">将源代码编译为Java</a></span></dt><dt><span class="section"><a href="#backend_execution">使用后端执行工作流程</a></span></dt><dt><span class="section"><a href="#java_middleend">在Java中实现函数 -  Java Annotations Middleend</a></span></dt></dl></dd><dt><span class="section"><a href="#call_functions_backend">调用从Java后端注册的函数</a></span></dt></dl></div><p>另一种改进生成和模型转换性能的方法是使用M2T后端。M2T后端是用于模型到文本（M2T）和模型到模型（M2M）转换的新执行引擎，它提供：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">通过提供将各自的语言翻译成后端抽象语法树的中间端来编译后端支持的M2T和M2M语言。这个AST又被编译为Java。编译器仍然是实验性的。
      		</li><li class="listitem">Backeend解释了后端支持的M2T和M2M语言的执行。
      		</li><li class="listitem">使用惰性字符串连接和积极缓存的性能改进</li><li class="listitem">语言互操作性，例如将Xpand与Xtend2混合使用</li></ul></div><p>
	</p><p>M2T后端提供了一个编译器，可以将用Xpand / Xtend / Check编写的资源和后端支持的其他语言编译为Java。后端用作通用平台，就像JVM是多语言的通用平台一样。后端支持的语言可以互操作，就像JVM上支持的语言可以互操作一样。这使您能够导入用Xpand / Xtend / Check之外的其他语言编写的模板，扩展和转换，并调用其中声明的函数，例如从Xpand调用QVT转换。只要Xtend2的中间端可用，就会支持与旧式Xpand / Xtend / Check的互操作性。
	</p><p>从Eclipse Helios版本（Eclipse 3.6）开始，M2T后端是M2T Xpand的一部分。截至Eclipse Indigo发布，后端编译器已添加。
	</p><div class="section" title="技术背景"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="backend_background"></a>技术背景</h2></div></div></div><p><span class="emphasis"><em>M2T后端</em></span>背后的基本思想是不为每种语言构建编译器，而是使用中间“语言”，即后端抽象语法树，它被编译成可执行的Java代码。Xpand，Xtend和Check被所谓的<span class="emphasis"><em>middleends</em></span>转换为后端AST。Middleends特定于每种语言。因此，对于每种支持的语言存在<span class="emphasis"><em>语言特定的中间节点</em></span> 。如果某个语言的中间端可用，则可以编译为Java代码，最后使用普通Java编译器进行字节编码，或者在构建Eclipse JDT编译器时自动编译。与后端语言相比，Xpand，Xtend和Check称为<span class="emphasis"><em>前端语言</em></span> 。
		</p><p>M2T后端支持功能和面向方面的编程。其中它支持语言功能，例如：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">关闭</li><li class="listitem">高阶函数 - 使用任何表达式作为参数，甚至是函数调用</li><li class="listitem">干算功能</li><li class="listitem">multi dispatch  - 调用基于运行时参数类型的函数，如Xpand / Xtend / Check，而不是像Java中那样静态分配的参数类型</li><li class="listitem">保护功能 - 将功能的执行约束到保护中定义的某些条件</li><li class="listitem">延迟评估表达式 - 使用函数调用作为占位符并稍后评估表达式</li><li class="listitem">AOP</li><li class="listitem">使用多个注释在Java中声明函数</li><li class="listitem">支持多种类型系统即元模型。目前支持JavaBeans，EMF，Eclipse UML2和XSD。
				</li></ul></div><p>
		</p><div class="section" title="它如何在解释模式下工作"><div class="titlepage"><div><div><h3 class="title"><a name="backend_interpretation_background"></a>它如何在解释模式下工作</h3></div></div></div><p>在解释模式下，执行以下步骤：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">读取资源，例如Xpand模板。
		      	</li><li class="listitem">找到负责的<span class="emphasis"><em>中间端</em></span> ，能够将<span class="emphasis"><em>前端语言</em></span> AST（例如Xpand）转换为<span class="emphasis"><em>后端AST</em></span> 。中间端是否可以处理某个前端语言AST到后端AST的转换是基于资源的文件结束来确定的，例如“.xpt”并且通过尝试用中间端口前端解析器来解析资源。
					</li><li class="listitem">最后，使用后端执行后端AST。
					</li></ul></div><p>
			</p></div></div><div class="section" title="使用后端"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="backend_usage"></a>使用后端</h2></div></div></div><div class="section" title="快速入门"><div class="titlepage"><div><div><h3 class="title"><a name="backend_quickstart"></a>快速入门</h3></div></div></div><p>在开始之前，您需要安装以下功能：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Xtend后端</li><li class="listitem">Xtend后端UML2Types</li><li class="listitem">Xtend后端XSDTypes</li><li class="listitem">Xtend后端编译器</li><li class="listitem">Xtend后端UI（仅限编译器要求）</li><li class="listitem">Xpand Middleend</li><li class="listitem">Xpand Middleend UI（仅限编译器要求）</li><li class="listitem">Xtend Middleend</li><li class="listitem">Xtend Middleend UI（仅限编译器要求）</li></ul></div><p>您可以安装<span class="emphasis"><em>Xtend Backend SDK</em></span>和<span class="emphasis"><em>Xpand Middleend SDK</em></span>
			</p><p>作为快速入门，您可以使用<span class="emphasis"><em>Xpand Project</em></span>向导并选择“生成基于EMF的示例EMp项目”。完成向导后，您将在“工作流程”文件夹中找到工作流文件“generatorWithBackend.mwe”。工作流已准备好使用后端进行生成。
			</p></div><div class="section" title="将源代码编译为Java"><div class="titlepage"><div><div><h3 class="title"><a name="backend_compiler"></a>将源代码编译为Java</h3></div></div></div><p>通过将M2T后端编译器性质添加到项目中，可以将编译器激活为构建器。这样做是从Xpand项目的上下文菜单中选择“配置”&gt;“添加M2T后端编译器”。然后，所有Xpand / Xtend / Check资源都将编译为Java源文件到项目的“backend-gen”文件夹中。从项目菜单中选择“Clean ...”时，Backend Compiler将执行完整构建，而更改Xpand / Xtend / Check资源将逐步编译此资源。
			</p><p>编译器仍然是实验性的。
			</p></div><div class="section" title="使用后端执行工作流程"><div class="titlepage"><div><div><h3 class="title"><a name="backend_execution"></a>使用后端执行工作流程</h3></div></div></div><p>后端可以执行已编译为Java的函数和模板或可由其中一个可用中间端处理的其他资源。它会自动识别编译资源（如果在构建路径上可用），并且优先于本机Xpand / Xtend / Check资源。
			</p><p>执行编译函数/模板的最佳方法是使用XpandComponent或XtendComponent。要调用的函数的名称与Xpand / Xtend / Check中定义的完全限定名称相同。
			</p><div class="section" title="设置后端语言"><div class="titlepage"><div><div><h4 class="title"><a name="backend_setup"></a>设置后端语言</h4></div></div></div><p>在使用Xpand和后端之类的语言之前，必须在后端注册负责的中间人。这是通过<code class="classname">org.eclipse.xtend.middleend.完成的<code class="classname">org.eclipse.xtend.middleend.LanguageSetup</code> 。Middleends在这里被称为<code class="classname">languageContributor</code>贡献者。您可以注册任何特定语言的中间人。特定于语言的中间端实现接口<code class="classname">org.eclipse.xtend.middleend.plugins.LanguageSpecificMiddleEnd</code> 。要注册Xpand，Xtend和Check中间件，请在调用任何相应语言的midend组件之前在工作流中执行以下操作：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.middleend。LanguageSetup“&gt; &lt;languageContributor value =”org.eclipse.xtend.middleend.xtend.plugin。OldXtendRegistryFactory“/&gt; &lt;languageContributor value =”org.eclipse.xtend.middleend.xtend.plugin。OldCheckRegistryFactory“/&gt; &lt;languageContributor value =”org.eclipse.xtend.middleend.xpand.plugin。OldXpandRegistryFactory“/&gt; &lt;/ component&gt;</pre><p>现在注册了中间端，您可以使用相应的中间工作流组件在解释模式下使用后端。
				</p></div><div class="section" title="调用Xpand模板 - 生成器"><div class="titlepage"><div><div><h4 class="title"><a name="xpand_middleend_usage"></a>调用Xpand模板 - 生成器</h4></div></div></div><p>Xpand中端引入了一个新组件，而不是<code class="classname">org.eclipse.xpand2.Generator</code>从工作流程调用Xpand模板。该组件具有与Xpand <code class="classname">Generator</code>组件相同的参数。因此，以下工作流片段调用模板<code class="classname">template::Template::main</code> ：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.middleend.xpand。XpandComponent“&gt; &lt;metaModel idRef =”mm_emf“/&gt; &lt;expand value =”template :: Template :: main FOR model“/&gt; &lt;outlet path =”$ {src-gen}“&gt; &lt;postprocessor class =”org.eclipse .xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt; &lt;/ component&gt;</pre><p>该组件支持<code class="classname">Generator</code>所有属性，但<code class="classname">collectProfileSummary</code>和<code class="classname">verboseProfileFilename</code>除外
				</p></div><div class="section" title="在后端执行检查"><div class="titlepage"><div><div><h4 class="title"><a name="check_middleend_usage"></a>在后端执行检查</h4></div></div></div><p>正如Xpand中间端一样，Check middleend还提供了一个新组件来执行后端检查。组件<code class="classname">org.eclipse.xtend.check.必须用<code class="classname">org.eclipse.xtend.middleend.xtend.替换CheckComponent</code> <code class="classname">org.eclipse.xtend.middleend.xtend.CheckComponent</code> 。新组件使用与<code class="classname">org.eclipse.xtend.check.相同的属性<code class="classname">org.eclipse.xtend.check.CheckComponent</code> 。因此，使用后端调用检查将如下所示：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.middleend.xtend。CheckComponent“&gt; &lt;metaModel idRef =”mm_emf“/&gt; &lt;checkFile value =”metamodel :: Checks“/&gt; &lt;emfAllChildrenSlot value =”model“/&gt; &lt;/ component&gt;</pre></div><div class="section" title="在后端执行Xtend扩展"><div class="titlepage"><div><div><h4 class="title"><a name="xtend_middleend_usage"></a>在后端执行Xtend扩展</h4></div></div></div><p>要从工作流调用Xtend扩展，Xtend中端引入了新组件<code class="classname">org.eclipse.xtend.middleend.xtend.XtendComponent</code> 。新组件提供与旧组件相同的配置属性。因此，您可以使用以下工作流程片段调用扩展<code class="classname">extensions::modification::modify</code> ：</p><pre class="programlisting">&gt; component class =“org.eclipse.xtend.middleend.xtend。XtendComponent“&gt; &lt;metaModel idRef =”mm_emf“/&gt; &lt;invoke value =”extensions :: modification :: modify（model）“/&gt; &lt;/ component&gt;</pre></div></div><div class="section" title="在Java中实现函数 -  Java Annotations Middleend"><div class="titlepage"><div><div><h3 class="title"><a name="java_middleend"></a>在Java中实现函数 -  Java Annotations Middleend</h3></div></div></div><p>函数也可以由Java Annotations Middleend贡献给M2T后端。midend由<code class="classname">org.eclipse.xtend.middleend.javaannotations.实现<code class="classname">org.eclipse.xtend.middleend.javaannotations.JavaFunctionClassContributor</code> 。通过使用类调用方法<code class="classname">classAsResource</code>来完成Java类的注册。
			</p><p>函数在<code class="classname">org.eclipse.xtend.backend.common.表示的后端具有限定名称<code class="classname">org.eclipse.xtend.backend.common.QualifiedName</code>由命名空间和简单名称组成。例如，Xpand定义<code class="classname">template::Template::main</code>具有名称空间<code class="classname">template::Template</code>和简单名称<code class="classname">main</code> 。QualifiedName的String表示形式为<code class="classname">template::Template::main</code> 。注册Java定义函数时，通常只将函数的简单名称定义为其名称。简单名称是方法名称。要设置函数的限定名称，请使用注释<code class="classname">@M2tQualifiedName</code> 。命名空间将从完全限定的类名派生。
			</p><p>默认情况下，所有公共方法都将注册为函数。要防止注册方法，请使用<code class="classname">@M2tNoFunction</code>注释它。您还可以使用以下注释之一：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="classname">@M2tCached</code> - 使用缓存</li><li class="listitem"><code class="classname">@M2tPrivateFunction</code> - 将该函数标记为私有</li><li class="listitem"><code class="classname">@M2tAroundAdvice(pointcut)</code> - 使用方法作为周围的建议。切入点具有以下参数：<div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><code class="classname">namePattern</code> - <code class="classname">namePattern</code>中的函数名称模式<code class="classname">paramTypeNames</code> - 具有参数类型名称模式的数组<code class="classname">hasVarArgs</code> - 如果匹配函数在切入点中指定的<code class="classname">paramTypeNames</code>之后具有任意数量的参数， <code class="classname">paramTypeNames</code></li></ul></div></li></ul></div><p>
			</p><p>可以在外观<code class="classname">org.eclipse.xtend.middleend.javaannotations.上直接调用由Java类的方法定义的函数<code class="classname">org.eclipse.xtend.middleend.javaannotations.JavaAnnotationBackendFacade</code> 。调用方法invoke来调用Java中定义的函数：</p><pre class="programlisting">invokeFunction（String className，BackendTypesystem ts，QualifiedName functionName，List &lt;？&gt;参数）</pre><p>
			</p></div></div><div class="section" title="调用从Java后端注册的函数"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="call_functions_backend"></a>调用从Java后端注册的函数</h2></div></div></div><p>要调用在后端注册的函数，请使用<code class="classname">org.eclipse.xtend.backend.BackendFacade</code> 。要在后端调用函数，请调用该方法</p><pre class="programlisting">invoke（ExecutionContext ctx，QualifiedName functionName，List &lt;？extends Object&gt; params）</pre><p>
		</p></div></div><div class="chapter" title="Chapter 9. UML2适配器"><div class="titlepage"><div><div><h2 class="title">Chapter 9. UML2适配器</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#uml_adapter_introduction">介绍</a></span></dt><dt><span class="section"><a href="#uml_adapter_installation">安装</a></span></dt><dt><span class="section"><a href="#uml_adapter_eclipse_setup">设置Eclipse</a></span></dt><dd><dl><dt><span class="section"><a href="#uml_adapter_setup_profiles">Eclipse中的配置文件</a></span></dt></dl></dd><dt><span class="section"><a href="#uml_adapter_runtime_configuration">运行时配置</a></span></dt><dd><dl><dt><span class="section"><a href="#uml_adapter_runtime_workflow">工作流程</a></span></dt></dl></dd></dl></div><div class="section" title="介绍"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml_adapter_introduction"></a>介绍</h2></div></div></div><p>它基于Eclipse的UML2 2.0框架，并提供从UML 2.1元模型实现到Xpand类型系统的类型映射。因此，可以从<span class="emphasis"><em>Check</em></span> ， <span class="emphasis"><em>Xtend</em></span>和<span class="emphasis"><em>Xpand</em></span>访问整个UML2元模型。此外，更重要的是，适配器将应用于模型元素的构造型动态映射到Xpand类型，并将标记值映射到Xpand属性。您不必再实现其他Java类。只需导出模型和应用的配置文件。就这样！</p></div><div class="section" title="安装"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml_adapter_installation"></a>安装</h2></div></div></div><p>首先，您需要从eclipse.org安装UML2功能：</p><p><a class="ulink" href="http://download.eclipse.org/modeling/mdt/updates/releases/" target="_new">http://download.eclipse.org/modeling/mdt/updates/releases/</a></p><p>Xpand uml2adapter可从Xpand更新站点获得：</p><p><a class="ulink" href="http://download.eclipse.org/modeling/m2t/updates/releases/" target="_new">http://download.eclipse.org/modeling/m2t/updates/releases/</a></p><p>（如果其中一个站点不起作用，请转到项目的主页并查找当前位置）</p><p>当Eclipse要求您重新启动Eclipse工作台时。</p></div><div class="section" title="设置Eclipse"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml_adapter_eclipse_setup"></a>设置Eclipse</h2></div></div></div><p>您需要配置项目（或整个工作区）以使用UML2Adapter。</p><p>右键单击项目，然后从弹出菜单中选择“ <span class="emphasis"><em>属性</em></span> ”。在其中打开' <span class="emphasis"><em>Xtend / Xpand</em></span> '选项卡，激活复选框<span class="emphasis"><em>启用项目特定设置</em></span>并添加<span class="emphasis"><em>UML2配置文件</em></span>元模型贡献者。使用“ <span class="emphasis"><em>向上”</em></span>按钮将UML2配置文件贡献者推送到第一个位置。</p><div class="section" title="Eclipse中的配置文件"><div class="titlepage"><div><div><h3 class="title"><a name="uml_adapter_setup_profiles"></a> Eclipse中的配置文件</h3></div></div></div><p>如果您希望Eclipse注册您的特定配置文件以便在编辑器中提供静态类型检查和代码完成，则配置文件（* .profile.uml或* .profile.uml2）需要位于项目的类路径中（例如，包含在<code class="filename">src</code>文件夹中）</p></div></div><div class="section" title="运行时配置"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml_adapter_runtime_configuration"></a>运行时配置</h2></div></div></div><p>在运行时，您只需要<code class="filename">org.eclipse.xtend.typesystem.uml2-1.0.0.jar</code> （或更高版本）。您可以使用PDE中Eclipse的依赖性机制，或直接复制或引用相应的JAR文件。没关系，你只需要注意它在类路径上。</p><div class="section" title="工作流程"><div class="titlepage"><div><div><h3 class="title"><a name="uml_adapter_runtime_workflow"></a>工作流程</h3></div></div></div><p>如果您编写了一些<span class="emphasis"><em>Check</em></span> ， <span class="emphasis"><em>Xtend</em></span>或<span class="emphasis"><em>Xpand</em></span>文件，现在想要执行它们，则必须提供正确的配置。</p><p>您需要为直接使用的<span class="emphasis"><em>每个配置文件</em></span>配置UML2元模型和配置文件元模型。典型配置如下所示：</p><pre class="programlisting">&lt;workflow&gt; &lt;bean class =“org.eclipse.xtend.typesystem.uml2。设置“standardUML2Setup =”true“/&gt; &lt;component class =”org.eclipse.xtend.typesystem.emf。XmiReader“&gt; ......&lt;/ component&gt; &lt;component class =“org.eclipse.xpand2。Generator“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.uml2。UML2MetaModel“/&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel“&gt; &lt;profile value =”myProfile.profile.uml2“/&gt; &lt;/ metaModel&gt; ...&lt;/ component&gt; &lt;workflow&gt;</pre><p><span class="emphasis"><em>请注意第二行中的bean配置。它静态配置XmiReader以使用正确的工厂用于* .uml和* .uml2文件。这是非常重要的。</em></span></p><p>如果要调用多个Xpand组件，则应使用<code class="varname">id</code> / <code class="varname">idRef</code>机制：</p><pre class="programlisting">&lt;workflow&gt; &lt;bean class =“org.eclipse.xtend.typesystem.uml2。设置“standardUML2Setup =”true“/&gt; &lt;component class =”org.eclipse.xtend.typesystem.emf。XmiReader“&gt; ......&lt;/ component&gt; &lt;component class =“org.eclipse.xpand2。Generator“&gt; &lt;metaModel id =”uml“class =”org.eclipse.xtend.typesystem.uml2。UML2MetaModel“/&gt; &lt;metaModel id =”profile“class =”org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel“&gt; &lt;profile value =”myProfile.profile.uml2“/&gt; &lt;/ metaModel&gt; ...&lt;/组分&gt;</pre></div></div></div><div class="chapter" title="Chapter 9. XSD适配器"><div class="titlepage"><div><div><h2 class="title">Chapter 9. XSD适配器</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#xsd_reference_prerequisites">先决条件</a></span></dt><dt><span class="section"><a href="#xsd_reference_overview">概观</a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components">工作流程组件</a></span></dt><dd><dl><dt><span class="section"><a href="#xsd_reference_workflow_components_xsdmetamodel">
        <code class="classname">XSDMetaModel</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlreader">
        <code class="classname">XMLReader的</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlwriter">
        <code class="classname">XMLWriter的</code>
      </a></span></dt><dt><span class="section"><a href="#xsd_reference_workflow_components_xmlbeautifier">
        <code class="classname">XMLBeautifier</code>
      </a></span></dt></dl></dd><dt><span class="section"><a href="#xsd_reference_xsd2ecore">幕后制作：将XSD转变为Ecore</a></span></dt><dt><span class="section"><a href="#xsd_reference_declare_xsd">如何声明XML Schema</a></span></dt></dl></div><p>XSD适配器允许Xpand读取/写入XML文件作为模型，并使用XML Schema（XSD）作为元模型。该参考资料提供了深入的详细信息，有关快速实用的介绍，请参阅<a class="xref" href="#xsd_tutorial" title="Chapter 9. XSD教程">第11章<i>XSD教程</i></a> 。</p><div class="section" title="先决条件"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_reference_prerequisites"></a>先决条件</h2></div></div></div><p>请查看<a class="xref" href="#xsd_tutorial_setup" title="建立">“设置”部分</a> 。
     </p></div><div class="section" title="概观"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_reference_overview"></a>概观</h2></div></div></div><p>XSD适配器执行两个主要任务：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>它以透明的方式将XML模式（XSD）转换为Ecore模型，因此Ecore模型对用户是隐藏的。这在工作流程和IDE中完成（允许Xtend / Xpand / Check的XSD感知代码完成）。有关映射的详细信息，请参阅<a class="xref" href="#xsd_reference_xsd2ecore" title="幕后制作：将XSD转变为Ecore">“幕后操作：将XSD转换为Ecore”一节</a> 。有关工作流程集成的详细信息，请参阅<a class="xref" href="#xsd_reference_workflow_components" title="工作流程组件">“工作流程组件”一节</a></p></li><li class="listitem"><p>它使用XSD所需的概念扩展了EmfMetaModel。例如，这些论文支持特征映射（处理注释，嵌套文本，CDATA和处理指令所需），QNames，EMaps和组合的Simpletypes。</p></li></ol></div></div><div class="section" title="工作流程组件"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_reference_workflow_components"></a>工作流程组件</h2></div></div></div><p>XSD适配器提供以下工作流组件：</p><div class="section" title="XSDMetaModel"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xsdmetamodel"></a>
        <code class="classname">XSDMetaModel</code>
      </h3></div></div></div><p>XSDMetaModel加载指定的XSD，将它们转换为Ecore模型，并使其可用于其他MWE组件。如果XSD包含/导入其他XSD，或者XML文件通过<span class="property">schemaLocation</span>引用XSD，则还会加载这些XSD（详细信息： <a class="xref" href="#xsd_reference_declare_xsd" title="如何声明XML Schema">“如何声明XML模式”一节</a> ）。最常见的情况是在<code class="classname">XMLReader</code>声明<code class="classname">XSDMetaModel</code> ：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.typesystem.xsd。XMLReader“&gt; &lt;modelSlot value =”model“/&gt; &lt;uri value =”model.xml“/&gt; &lt;metaModel id =”mm“class =”org.eclipse.xtend.typesystem.xsd。XSDMetaModel“&gt; &lt;schemaFile value =”metamodel.xsd“/&gt; &lt;registerPackagesGlobally value =”true“/&gt; &lt;/ metaModel&gt; &lt;/ component&gt;</pre><p>另一种选择是将<code class="classname">XSDMetaModel</code>独立于其他组件指定为bean：</p><pre class="programlisting">&lt;bean id =“ <span class="bold"><strong>mymetamodel</strong></span> ”class =“org.eclipse.xtend.typesystem.xsd。XSDMetaModel“&gt; &lt;schemaFile value =”metamodel.xsd“/&gt; &lt;/ bean&gt; &lt;component class =”org.eclipse.xtend.typesystem.xsd。XMLReader“&gt; &lt;modelSlot value =”model“/&gt; &lt;uri value =”model.xml“/&gt; &lt;metaModel <span class="bold"><strong>idRef =”mymetamodel“</strong></span> /&gt; &lt;/ component&gt;</pre><p>注意：多次加载XSD时可能会导致错误，这只有在一个工作流程中使用多个<code class="classname">XSDMetaModels</code>时才会发生。安全的方法是为每个工作流声明一个<code class="classname">XSDMetaModel</code> ，并从需要它的所有组件中引用它。</p><p>属性：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="property">schemaFile</span> ：可选，允许多次：指定正在加载的XSD文件。路径可以是完整的URI，也可以是项目根目录或类路径。</p></li><li class="listitem"><p><span class="property">registerPackagesGlobally</span> ：可选，默认为“ <span class="property">false</span> ”：如果为<span class="property">true</span> ，则生成的EPackages将注册到<code class="classname">org.eclipse.emf.ecore.EPackage。注册。EMF的全球软件包注册表INSTANCE</code> 。警告：从您自己的Java代码运行工作流时，请确保在下次运行之前从注册表中删除生成的包！</p></li></ul></div></div><div class="section" title="XMLReader的"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlreader"></a>
        <code class="classname">XMLReader</code>
      </h3></div></div></div><p><code class="classname">XMLReader</code>读取一个XML文件，该文件根据<code class="classname">XSDMetaModel</code>加载的XSD有效。XML文件作为模型加载并存储在指定的槽中。例：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.typesystem.xsd。XMLReader“&gt; &lt;modelSlot value =”model“/&gt; &lt;uri value =”model.xml“/&gt; &lt;metaModel idRef =”mymetamodel“/&gt; &lt;/ component&gt;</pre><p>属性：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="property">slot</span> ：required：存储加载模型的插槽名称。其他工作流程组件可以通过引用此插槽来访问模型。</p></li><li class="listitem"><p><span class="property">uri</span> ：required：应该读取的XML文件的文件名。绝对URI以及相对于项目根或类路径的路径名是有效的。</p></li><li class="listitem"><p><span class="property">metaModel</span> ：optional：为<code class="classname">XMLReader</code>指定<code class="classname">XSDMetaModel</code> （请参阅<a class="xref" href="#xsd_reference_workflow_components_xsdmetamodel" title="XSDMetaModel">“ <code class="classname">XSDMetaModel</code> ”一节</a> ）。在情况下，不<code class="classname">XSDMetaModel</code>指定，一个<code class="classname">XSDMetaModel</code>使用缺省配置被隐含实例化。重要的是要注意在加载过程中可以找到所有需要的XSD： <a class="xref" href="#xsd_reference_declare_xsd" title="如何声明XML Schema">“如何声明XML模式”一节</a> 。</p></li><li class="listitem"><p><span class="property">useDocumentRoot</span> ：可选，默认为“ <span class="property">false</span> ”：将XML文件作为模型处理，大多数人将XML的根元素视为模型的根对象。这是<code class="classname">XMLReader</code>使用的默认值。但XML的根元素实际上有一个父元素，即所谓的DocumentRoot。此外，DocumentRoot包含注释/处理指令和CDATA部分，它出现在XML的根元素之前或之后，最值得注意的是，DocumentRoot包含有关使用的命名空间的信息。如果<span class="property">useDocumentRoot</span>设置为<span class="property">true</span> ，则<code class="classname">XMLReader</code>将DocumentRoot-Object而不是XML的根元素的对象存储到指定的槽。</p></li><li class="listitem"><p><span class="property">option</span> ：optional，可以多次指定：Option指定一个键值对，在加载过程中将其传递给EMF的XMLResource。有效选项通过接口<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi. JavaDoc进行记录<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code></a> 。此外， <code class="classname">XMLReader</code>支持以下选项：</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="property">DEFAULT_NAMESPACE</span> ：指定默认命名空间，以防XML文件未声明一个：</p><pre class="programlisting">&lt;option key =“DEFAULT_NAMESPACE”val =“http://www.dlese.org/Metadata/opml”/&gt;</pre></li><li class="listitem"><p><span class="property">NAMESPACE_MAP</span> ：指定名称空间的映射，在加载XML文件时应用。</p><pre class="programlisting">&lt;option key =“NAMESPACE_MAP”&gt; &lt;val class =“org.eclipse.xtend.typesystem.xsd.lib。MapBean“&gt; &lt;mapping from =”http://www.eclipse.org/modeling/xpand/example/model/wrong“to =”http://www.eclipse.org/modeling/xpand/example/model/loadcurve “/&gt; &lt;/ val&gt; &lt;/ option&gt;</pre></li></ul></div></li></ul></div></div><div class="section" title="XMLWriter的"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlwriter"></a>
        <code class="classname">XMLWriter</code>
      </h3></div></div></div><p><code class="classname">XMLWriter</code>将存储在插槽中的模型写入XML文件。如果插槽包含模型集合，则每个模型都写入单独的文件。必须使用基于XSD的元模型实例化模型。例：</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.typesystem.xsd。XMLWriter“&gt; &lt;metaModel idRef =”svgmm“/&gt; &lt;modelSlot value =”svgmodel“/&gt; &lt;uri value =”src-gen / mycurve.svg“/&gt; &lt;/ component&gt;</pre><p>属性：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="property">slot</span> ：required：保存模型的槽的名称或应序列化为XML的模型集合。</p></li><li class="listitem"><p><span class="property">元模型</span> ：要求：的实例<code class="classname">XSDMetaModel</code> ，其中认为所提供的模型是基于XSD。另请参阅<a class="xref" href="#xsd_reference_workflow_components_xsdmetamodel" title="XSDMetaModel">“ <code class="classname">XSDMetaModel</code> ”一节</a></p></li><li class="listitem"><p><span class="property">uri</span> ：如果未指定<span class="property">uriExpression，</span>则为必需：应写入的XML文件的文件名。绝对URI有效。使用相对路径名称需要您自担风险。</p></li><li class="listitem"><p><span class="property">uriExpression</span> ：如果未指定<span class="property">uri，</span>则为必需：在编写多个XML文件的方案中，这提供了一种机制来确定每个文件的文件名。表达式中指定的Xtend <code class="classname">expression</code>是针对每个文件计算的，并且必须返回文件名。要写入的模型可以通过具有<code class="classname">varName</code>指定名称的变量在表达式中访问。例：</p><pre class="programlisting">&lt;uriExpression varName =“docroot”expression =“'src-gen /'+ ecore2xsd :: getFileName（docroot）”/&gt;</pre></li><li class="listitem"><p><span class="property">option</span> ：optional，可以多次指定：Option指定一个键值对，在写入过程中将其传递给EMF的XMLResource。有效选项通过接口<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi. JavaDoc进行记录<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code></a> 。</p></li></ul></div></div><div class="section" title="XMLBeautifier"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlbeautifier"></a>
        <code class="classname">XMLBeautifier</code>
      </h3></div></div></div><p><code class="classname">XMLBeautifier</code>使用EMF加载XML文件，格式化混合内容（同一元素包含的元素和文本），并将文件写回磁盘，为元素应用一个很好的缩进。<code class="classname">XMLBeautifier</code>不打算与<code class="classname">XMLWriter</code>结合使用，因为<code class="classname">XMLWriter</code>本身就关心缩进。相反，使用Xpand将其用于“手动”构造的XML文件。由于用于加载/存储XML的框架总是将整个文件加载到内存中的复杂数据结构中，因此这种方法不能很好地扩展到大型XML文件。例：</p><pre class="programlisting">&lt;component class =“org.eclipse.xpand2。生成器“&gt; &lt;metaModel idRef =”mm“/&gt; &lt;expand value =”$ {src-pkg} :: $ {file} :: Root FOR'$ {out}'“/&gt; &lt;outlet path =”$ {src -gen-dir}“/&gt; &lt;beautifier class =”org.eclipse.xtend.typesystem.xsd。XMLBeautifier“&gt; &lt;maxLineWidth value =”60“/&gt; &lt;formatComments value =”true“/&gt; &lt;fileExtensions value =”。xml，.html“/&gt; &lt;/ beautifier&gt; &lt;/ component&gt;</pre><p>属性：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="property">maxLineWidth</span> ：optional：指定应在其后执行换行的字符数。</p></li><li class="listitem"><p><span class="property">formatComments</span> ：optional，default <span class="property">true</span> ：指定是否还应将格式应用于注释。</p></li><li class="listitem"><p><span class="property">fileExtensions</span> ：可选，默认为“ <span class="property">.xml，.xsl，.xsd，.wsdd，.wsdl</span> ”：指定应对其应用文件格式的过滤器。仅处理与其中一个指定文件扩展名匹配的文件。</p></li><li class="listitem"><p><span class="property">loadOption</span> ：可选，可以多次指定：Option指定一个键值对，在加载过程中将其传递给EMF的XMLResource。有效选项通过接口<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi. JavaDoc进行记录<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_new"><code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code></a> 。</p></li><li class="listitem"><p><span class="property">saveOption</span> ：可选，可以多次指定：与<span class="property">loadOption</span>相同，但在写入过程中应用这些选项的区别除外。例：</p><pre class="programlisting">&lt;saveOption key =“XML_VERSION”val =“1.1”/&gt; &lt;saveOption key =“ENCODING”val =“ASCII”/&gt;</pre></li></ul></div></div></div><div class="section" title="幕后制作：将XSD转变为Ecore"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_reference_xsd2ecore"></a>幕后制作：将XSD转变为Ecore</h2></div></div></div><p>在代码生成过程中，XML Schema被转换为EMF Ecore模型，然后由EMF用作元模型。 XSD复杂数据类型映射到EClasses，XSD简单数据类型映射到<code class="classname">org.eclipse.emf.ecore.xml.type.定义的EMF数据类型<code class="classname">org.eclipse.emf.ecore.xml.type.XMLTypePackage</code>和<code class="classname">org.eclipse.xtend.typesystem.xsd.XSDMetaModel</code>将它们映射到Xpand数据类型。文档<span class="emphasis"><em><a class="ulink" href="http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf" target="_new">XML Schema to Ecore Mapping</a></em></span>解释了映射的详细信息。
    <a class="ulink" href="http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf" target="_new">http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf</a></p></div><div class="section" title="如何声明XML Schema"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_reference_declare_xsd"></a>如何声明XML Schema</h2></div></div></div><p>声明XSD有三种不同的方法。只要XSD适配器可以找到所有需要的模式，您选择的方式或组合方式无关紧要。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>在工作流中： <code class="classname">org.eclipse.xtend.typesystem.xsd.XSDMetaModel</code>可以包含任意数量的<code class="classname">schemaFile</code>元素。</p><pre class="programlisting">&lt;component class =“org.eclipse.xtend.typesystem.xsd。XMLReader“&gt; &lt;modelSlot value =”model“/&gt; &lt;uri value =”$ {file}“/&gt; &lt;metaModel id =”mm“class =”org.eclipse.xtend.typesystem.xsd。XSDMetaModel“&gt; &lt;schemaFile value =”model / loadcurve.xsd“/&gt; &lt;schemaFile value =”model / device.xsd“/&gt; &lt;/ metaModel&gt; &lt;/ component&gt;</pre></li><li class="listitem"><p>在XML文件中：XML文件可以包含<code class="classname">schemaLocation</code>属性，这些属性将模式的名称空间与模式的文件名相关联。如果使用WTP创建模式，如<a class="xref" href="#xsd_tutorial_model" title="Step 3: Create a Model using XML">“步骤3：使用XML创建模型”一节</a>中<a class="xref" href="#xsd_tutorial_model" title="第3步：使用XML创建模型">所述</a> ，则会自动创建<code class="classname">schemaLocation</code>属性。</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;device：Device xmlns：device =“http://www.eclipse.org/modeling/xpand/example/model/device”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance “xsi：schemaLocation =”http://www.eclipse.org/modeling/xpand/example/model/device device.xsd“&gt; &lt;device：Name&gt; MyLaptop &lt;/ device：Name&gt; &lt;/ device：Device&gt;</pre></li><li class="listitem"><p>在XSD中：如果一个模式导入另一个模式，则<code class="classname">import</code>元素也可以具有<code class="classname">schemaLocation</code>属性。</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;schema targetNamespace =“http://www.eclipse.org/modeling/xpand/example/model/device”elementFormDefault =“qualified”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns： tns =“http://www.eclipse.org/modeling/xpand/example/model/device”xmlns：lc =“http://www.eclipse.org/modeling/xpand/example/model/loadcurve”xmlns： ecore =“http://www.eclipse.org/emf/2002/Ecore”&gt; &lt;import namespace =“http://www.eclipse.org/modeling/xpand/example/model/loadcurve”schemaLocation =“loadcurve。 xsd“&gt; &lt;/ import&gt; &lt;complexType name =”Device“&gt; &lt;sequence&gt; &lt;element name =”Name“type =”string“/&gt; &lt;element name =”LoadCurve“type =”lc：LoadCurve“/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;element name =“Device”type =“tns：Device”&gt; &lt;/ element&gt; &lt;/ schema&gt;</pre></li></ol></div></div></div></div><div class="part" title="第二部分。教程"><div class="titlepage"><div><div><h1 class="title"><a name="Tutorials"></a>第二部分。教程</h1></div></div></div><div class="toc"><p><b>目录</b></p><dl><dt><span class="chapter"><a href="#uml2example">10。UML2示例</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_setup_eclipse">设置Eclipse</a></span></dt><dt><span class="section"><a href="#uml2example_setup_project">设置项目</a></span></dt><dt><span class="section"><a href="#uml2example_create_model">创建UML2模型</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_modelling">建模内容</a></span></dt></dl></dd><dt><span class="section"><a href="#uml2example_codegen">代码生成</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_codegen_templates">定义模板</a></span></dt><dt><span class="section"><a href="#uml2example_codegen_workflow">定义工作流程</a></span></dt></dl></dd><dt><span class="section"><a href="#uml2example_profiles">档案支持</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_profiles_define">定义配置文件</a></span></dt><dt><span class="section"><a href="#uml2example_profile_apply">应用个人资料</a></span></dt><dt><span class="section"><a href="#uml2example_profiles_codegen">生成代码</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#xsd_tutorial">11。XSD教程</a></span></dt><dd><dl><dt><span class="section"><a href="#xsd_tutorial_setup">建立</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_overview">概观</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_create_project">第1步：创建项目</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_metamodel">第2步：使用XML Schema定义元模型</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_model">第3步：使用XML创建模型</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_template">第4步：使用Xpand创建模板</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_create_workflow">第5步：创建工作流程</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_execute_workflow">第6步：执行工作流程，即生成代码</a></span></dt></dl></dd></dl></div><div class="chapter" title="Chapter 9. UML2示例"><div class="titlepage"><div><div><h2 class="title">Chapter 9. UML2示例</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#uml2example_setup_eclipse">设置Eclipse</a></span></dt><dt><span class="section"><a href="#uml2example_setup_project">设置项目</a></span></dt><dt><span class="section"><a href="#uml2example_create_model">创建UML2模型</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_modelling">建模内容</a></span></dt></dl></dd><dt><span class="section"><a href="#uml2example_codegen">代码生成</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_codegen_templates">定义模板</a></span></dt><dt><span class="section"><a href="#uml2example_codegen_workflow">定义工作流程</a></span></dt></dl></dd><dt><span class="section"><a href="#uml2example_profiles">档案支持</a></span></dt><dd><dl><dt><span class="section"><a href="#uml2example_profiles_define">定义配置文件</a></span></dt><dt><span class="section"><a href="#uml2example_profile_apply">应用个人资料</a></span></dt><dt><span class="section"><a href="#uml2example_profiles_codegen">生成代码</a></span></dt></dl></dd></dl></div><div class="section" title="设置Eclipse"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml2example_setup_eclipse"></a>设置Eclipse</h2></div></div></div><p>在使用Xpand和Eclipse UML2之前<a name="N12ED7" class="indexterm"></a> ，首先必须将UML2插件安装到Eclipse安装中。（您至少需要'UML2最终用户'功能。可从Eclipse-Update站点下载。使用：Helios更新站点，然后浏览到<span class="emphasis"><em>建模</em></span>并至少选择<span class="emphasis"><em>UML2 Extender SDK</em></span> ）</p></div><div class="section" title="设置项目"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml2example_setup_project"></a>设置项目</h2></div></div></div><p>创建一个名为<span class="emphasis"><em>xpand.uml2.generator</em></span>的新Xpand插件项目。要告诉Xpand Eclipse插件该项目是特定于UML2的项目，您需要配置元模型贡献者。您需要添加<span class="emphasis"><em>UML2配置文件</em></span>和<span class="emphasis"><em>EMF Metamodels</em></span>元模型贡献者<a name="N12EF0" class="indexterm"></a> 。配置文件的顺序很重要！UML2配置文件条目必须位于列表的第一位。</p><div class="figure"><a name="uml2example_metamodel_config"></a><p class="title"><b>图1。配置UML2配置文件元模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/wizard.png" alt="配置UML2配置文件元模型"></div></div></div><p><br class="figure-break"></p><p>您必须将以下依赖项添加到清单文件：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="classname">org.eclipse.xtend.typesystem.uml2</code></p></li></ul></div></div><div class="section" title="创建UML2模型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml2example_create_model"></a>创建UML2模型</h2></div></div></div><p>首先定义UML2模型，即UML2元模型的实例。在项目内部，在源文件夹中，创建一个UML2模型，您应该调用<code class="filename">example.uml</code> （在pressig <span class="emphasis"><em>Next&gt;之后</em></span> ）。</p><div class="figure"><a name="uml2example_create_model_1"></a><p class="title"><b>图2。创建一个新的UML2模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/createUMLModel.png" alt="创建一个新的UML2模型"></div></div></div><br class="figure-break"><p>在向导的最后一页上，您必须选择模型对象。确保它是<span class="emphasis"><em>模型</em></span> ，而不是<span class="emphasis"><em>配置文件</em></span> 。</p><div class="figure"><a name="uml2example_select_modelobject"></a><p class="title"><b>图3。选择Model对象</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/modelobject.png" alt="选择Model对象"></div></div></div><p><br class="figure-break"></p><div class="section" title="建模内容"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_modelling"></a>建模内容</h3></div></div></div><p>然后，您应该构建一个看起来像这样的模型：</p><div class="figure"><a name="uml2example_examplemodel"></a><p class="title"><b>图4。示例模型</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/exampleModel.png" alt="示例模型"></div></div></div><p><br class="figure-break"></p><p>顺便说一下，如果将<code class="filename">.uml</code>文件重命名为<code class="filename">.ecore</code> ，则可以使用ecore编辑器编辑模型。要检查模型，它们可以提供更好的视图，因此您可以尝试！</p></div></div><div class="section" title="代码生成"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml2example_codegen"></a>代码生成</h2></div></div></div><div class="section" title="定义模板"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_codegen_templates"></a>定义模板</h3></div></div></div><p>在我们项目的源文件夹中，创建一个<code class="filename">templates</code>包。在该包文件夹中，创建具有以下内容的模板文件<code class="filename">Root.xpt</code> 。首先，我们定义名为<code class="classname">Root</code>的条目模板。由于我们期望UML模型元素成为模型的顶层元素，因此我们为<code class="classname">uml::Model</code>定义它。请注意<code class="classname">uml</code> Namespace前缀的使用，如UML2元模型中所定义。在该模板中，我们遍历模型中<code class="classname">uml::Package</code>类型的所有自有元素，并展开其中定义的包的模板。</p><pre class="programlisting">«DEFINE Root for uml :: Model»«EXPAND PackageRoot FOREACH allOwnedElements（）。typeSelect（uml :: Package）»«ENDDEFINE»</pre><p>在包模板中，我们再次遍历所有拥有的元素并调用处理类的模板。虽然我们只有那个包中的类，但我们一般不能依赖它。包可能包含任何其他可包装元素，因此我们需要使用<code class="methodname">typeSelect()</code>过滤类。</p><pre class="programlisting">«DEFINE PackageRoot for uml :: Package»«EXPAND ClassRoot FOREACH ownedType.typeSelect（uml :: Class）»«ENDDEFINE»</pre><p>此模板处理类。它打开一个与该类同名的文件，后缀为<code class="filename">.java</code> 。在该文件中，我们生成一个空的类体。</p><pre class="programlisting">«DEFINE ClassRoot FOR uml :: Class»«FILE name +“。java”»public class«name»{}«ENDFILE»«ENDDEFINE»</pre></div><div class="section" title="定义工作流程"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_codegen_workflow"></a>定义工作流程</h3></div></div></div><p>为了生成代码，我们需要一个工作流定义。这是工作流文件;你应该把它放到源文件夹中。如果您阅读“入门”一章，该文件通常是可以理解的。</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“ISO-8859-1”？&gt; &lt;workflow&gt;</pre><p>您需要设置UML2内容（注册URI映射，工厂等）。这可以在<code class="classname">XmiReader</code>之前声明一个bean <a name="N12F92" class="indexterm"></a>零件：</p><pre class="programlisting">&lt;bean class =“org.eclipse.emf.mwe.utils。StandaloneSetup“&gt; &lt;platformUri value =”..“/&gt; &lt;/ bean&gt; &lt;！ - 加载模型并将其存储在插槽'model' - &gt; &lt;component class =”org.eclipse.emf.mwe.utils中。Reader“&gt; &lt;uri value =”platform：/resource/xpand.uml2.generator/src/example.uml“/&gt; &lt;modelSlot value =”model“/&gt; &lt;/ component&gt;</pre><p><code class="classname">XmiReader</code>读取模型并将内容（包含模型元素的列表）存储在名为“ <code class="varname">model</code> ”的槽中。像往常一样，您可能希望清理目标目录<a name="N12FA1" class="indexterm"></a> 。</p><pre class="programlisting">&lt;component id =“dirCleaner”class =“org.eclipse.emf.mwe.utils。DirectoryCleaner“directory =”src-gen“/&gt;</pre><p>在生成器中我们还配置了UML2元模型<a name="N12FAA" class="indexterm"></a> 。</p><pre class="programlisting">&lt;component id =“generator”class =“org.eclipse.xpand2。生成器“skipOnErrors =”true“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.uml2。UML2MetaModel“/&gt; &lt;expand value =”templates :: Root :: Root FOR model“/&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;outlet path =”src-gen“&gt; &lt;postprocessor class =”org .eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre><p>如果运行工作流（通过右键单击<code class="filename">.mwe</code>文件并选择<span class="guiicon">Run As</span> → <span class="guimenuitem">MWE工作流</span> ），则应生成两个Java类。</p></div></div><div class="section" title="档案支持"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="uml2example_profiles"></a>档案支持</h2></div></div></div><p>Xpand附带了一个特殊的<span class="emphasis"><em>UML2配置文件</em></span>元模型实现。实现映射了Stereotypes <a name="N12FC5" class="indexterm"></a>到类型和标记值<a name="N12FC9" class="indexterm"></a>简单的属性。它还支持Enumerations <a name="N12FCD" class="indexterm"></a>在配置文件和Stereotype层次结构中定义。</p><div class="section" title="定义配置文件"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_profiles_define"></a>定义配置文件</h3></div></div></div><p>要定义配置文件，您可以使用各种基于UML2的建模工具。假设他们确实正确地创建了配置文件定义（并非总是如此，因为我们必须痛苦地学习），创建配置文件并正确导出它是直截了当的。</p><p>在本节中，我们将解释“手动方式”，它有助于解释发生的情况，但对实际使用完全没用。您不希望使用下面解释的机制构建实际大小的模型。</p><p>您开始创建一个新的UML2文件（如上所示）。在示例中，我们将其<code class="filename">test.profile.uml</code> 。但是，根元素将是一个<span class="emphasis"><em>配置文件</em></span> ，而不是一个<span class="emphasis"><em>包</em></span> 。不要忘记为配置文件实际指定名称！它也应该是<code class="literal">test</code> 。</p><p>创建的<span class="emphasis"><em>Profile</em></span>我们称之为<code class="literal">test</code> 。在我们的例子中，我们希望使构造型适用于UML类 - 它们被定义为UML2元模型的一部分。所以我们必须首先导入该元模型。因此，您要做的是选择您的配置文件对象，然后转到UML2 Editor菜单（在Eclipse菜单栏中）并选择<span class="emphasis"><em>Profile  - &gt; Reference Metaclass</em></span> 。选择<code class="classname">uml::Class</code> 。然后，在您的配置文件中添加一个原型（在配置文件上单击鼠标右键 - &gt; <span class="emphasis"><em>New Child</em></span> - &gt; <span class="emphasis"><em>Owned Stereotype</em></span> - &gt; <span class="emphasis"><em>Stereotype）。</em></span> 现在您可以定义构造型：从UML2 Editor菜单中选择<span class="emphasis"><em>Stereotype  - &gt; Create Extension</em></span> 。选择<code class="classname">uml::Class</code> 。这应该导致以下模型。保存它，您完成了配置文件定义。</p><div class="figure"><a name="uml2example_profile"></a><p class="title"><b>图5。建模配置文件</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/profile.png" alt="建模配置文件"></div></div></div><br class="figure-break"></div><div class="section" title="应用个人资料"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_profile_apply"></a>应用个人资料</h3></div></div></div><p>要使用配置文件，我们必须将其应用于某种模型。为此，我们将<code class="filename">example.uml</code>模型复制到<code class="filename">example-profiled.uml</code> 。然后我们打开该文件并加载资源，即我们刚刚定义的配置文件。这看起来有点像这样：</p><div class="figure"><a name="uml2example_profileApp1"></a><p class="title"><b>图6。加载个人资料</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/profileApp1.gif" alt="加载个人资料"></div></div></div><br class="figure-break"><p>现在，要使以下内容有效，首先必须选择配置文件，然后从UML2 Editor菜单中选择<span class="emphasis"><em>Profile  - &gt; Define</em></span>操作。这会创建各种其他模型元素，您现在不应该关注这些元素。</p><p>现在，最后，您可以选择您的<code class="literal">cars</code>包（示例模型中的一个）并从UML2 Editor菜单中选择<span class="emphasis"><em>Package  - &gt; Apply Profile</em></span> 。选择要应用的测试配置文件。</p><p>出于此示例的目的，您现在应该将测试<code class="classname">PersonCar</code>型应用于<code class="classname">PersonCar</code>类。选择类，然后从UML2 Editor菜单中选择<span class="emphasis"><em>Element  - &gt; Apply Stereotype</em></span> 。这应该导致以下模型：</p><div class="figure"><a name="uml2example_profileApp2"></a><p class="title"><b>图7。定义配置文件</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/uml2_example/profileApp2.png" alt="定义配置文件"></div></div></div><br class="figure-break"></div><div class="section" title="生成代码"><div class="titlepage"><div><div><h3 class="title"><a name="uml2example_profiles_codegen"></a>生成代码</h3></div></div></div><p>请注意，上面的所有内容都与Xpand没有任何关系，它只是创建和应用配置文件到UML2模型的“裸骨”手段。拥有一个能够将模型存储为EMF UML2 XMI的UML2工具<a name="N13055" class="indexterm"></a>会使模型的创建更容易。由于我们无法假设您正在使用哪个UML2工具，因此本教程将以这种方式向您展示，如果不安装其他工具，它将始终有效。</p><p>我们必须改变两件事：工作流（特别是生成器组件的配置）需要知道配置文件，如果类应用了测试构造型，模板需要生成不同的代码。让我们先来看第二个方面。这是修改后的模板（在<code class="filename">RootWithProfile.xpt</code> ）：</p><pre class="programlisting">«DEFINE Root for uml :: Model»«EXPAND PackageRoot FOREACH allOwnedElements（）。typeSelect（uml :: Package）»«ENDDEFINE»«DEFINE PackageRoot FOR uml :: Package»«EXPAND ClassRoot FOREACH ownedType.typeSelect（uml :: Class） »«ENDDEFINE»«DEFINE ClassRoot for uml :: Class»«FILE name +“。java”»public class«name»{}«ENDFILE»«ENDDEFINE»«DEFINE ClassRoot FOR test :: test»«FILE name +“。java” »公共类«名称»{} //刻板«ENDFILE»«ENDDEFINE»</pre><p>正如您所看到的， <span class="bold"><strong>构造型就像一个类型</strong></span> ，甚至基类型（ <code class="classname">uml::Class</code> ）和<code class="classname">uml::Class</code>型之间的多态分派也起作用！</p><p>调整工作流文件也很简单（ <code class="filename">workflowWithProfile.mwe</code> ）。以下是使用新模型<code class="filename">example-profiled.uml</code>和扩展设置的修改后的模型组件：</p><pre class="programlisting">&lt;？xml版本=“1.0”？&gt; &lt;workflow&gt; &lt;！ - 为独立执行设置EMF  - &gt; &lt;bean class =“org.eclipse.emf.mwe.utils。StandaloneSetup“platformUri =”..“/&gt; &lt;！ - 准备执行uml  - &gt; &lt;bean class =”org.eclipse.xtend.typesystem.uml2。设置“standardUML2Setup =”true“/&gt; &lt;！ -  UML2配置文件 -  Metamodell  - &gt; &lt;bean id =”mm_profile“class =”org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel“&gt; &lt;profile value =”platform：/resource/xpand.uml2.generator/src/test.profile.uml“/&gt; &lt;/ bean&gt; &lt;！ - 加载模型并将其存储在插槽'模型'中 - &gt; &lt;component class =“org.eclipse.emf.mwe.utils。Reader“&gt; &lt;uri value =”platform：/resource/xpand.uml2.generator/src/example-profiled.uml“/&gt; &lt;modelSlot value =”model“/&gt; &lt;/ component&gt;</pre><p>这是修改后的生成器组件：</p><pre class="programlisting">&lt;component id =“generator”class =“org.eclipse.xpand2。生成器“skipOnErrors =”true“&gt; &lt;metaModel idRef =”mm_profile“/&gt; &lt;expand value =”templates :: Root :: Root FOR model“/&gt; &lt;fileEncoding value =”ISO-8859-1“/&gt; &lt;outlet path =“src-gen”&gt; &lt;postprocessor class =“org.eclipse.xpand2.output。JavaBeautifier“/&gt; &lt;/ outlet&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre><p>我们唯一要做的就是添加一个引用我们刚创建的配置文件的新元模型。</p></div></div></div><div class="chapter" title="Chapter 9. XSD教程"><div class="titlepage"><div><div><h2 class="title">Chapter 9. XSD教程</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#xsd_tutorial_setup">建立</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_overview">概观</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_create_project">第1步：创建项目</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_metamodel">第2步：使用XML Schema定义元模型</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_model">第3步：使用XML创建模型</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_template">第4步：使用Xpand创建模板</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_create_workflow">第5步：创建工作流程</a></span></dt><dt><span class="section"><a href="#xsd_tutorial_execute_workflow">第6步：执行工作流程，即生成代码</a></span></dt></dl></div><p>本教程介绍了如何使用XML和XML模式定义（XSD）生成软件。它说明了如何将XML文件视为模型，将XSD视为元模型以及如何将其与Xpand集成。本教程是一个介绍，有关详细信息，请参阅<a class="xref" href="#xsd_reference" title="Chapter 9. XSD适配器">第9章， <i>XSD适配器</i></a> 。</p><div class="section" title="建立"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_setup"></a>建立</h2></div></div></div><p>XSD支持Xpand Xpand 0.7.2或更高版本。确保还安装了以下插件：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>XSD  -  XML架构定义运行时（ <a class="ulink" href="http://www.eclipse.org/xsd/" target="_new">http://www.eclipse.org/xsd/</a> ，可通过Ganymede更新站点获得）</p></li><li class="listitem"><p>Web工具平台（WTP）（WTP不需要使用Xpand XSD支持，但很有帮助，因为它提供了一个很好的XML Schema编辑器和一个支持模式的XML编辑器。（ <a class="ulink" href="http://www.eclipse.org/webtools/" target="_new">http://www.eclipse.org/webtools/</a> ，可通过Ganymede更新站点获得）</p></li></ul></div></div><div class="section" title="概观"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_overview"></a>概观</h2></div></div></div><p>本教程将介绍如何使用XML Schema Definitions作为元模型和XML文件作为模型，使用Xtend和Xpand进行代码生成。为了简单起见，引入的示例是一个简约的示例。从XML中指定的内容生成文本文件。模型的一般概念，元模型以及代码生成的原因和时间是有用的，没有解释。最后，我们将深入了解XML Schema如何转换为EMF Ecore模型，以及该方法提供的灵活性/限制。</p><p>本教程中列出的所有源文件也可作为示例项目使用，可通过运行<span class="emphasis"><em>“File”/“New”/“Example ...”/“Xpand / Xtend示例使用XSD元模型”</em></span>导入Eclipse工作区<span class="emphasis"><em>/“通过Xpand M2T自定义XML到文本（最小示例）”</em></span> 。这将在您的工作区中创建项目<code class="classname">org.eclipse.xpand.examples.xsd.m2t.minimal</code>项目。这个最小的例子基于“ <span class="emphasis"><em>通过Xpand的M2T自定义XML到Java</em></span> ”（ <code class="classname">org.eclipse.xpand.examples.xsd.m2t.xml2javawizard</code> ），它更全面，建议进一步阅读。</p><p>要使用Xpand从XML文件生成代码，至少需要以下四种类型的文件：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>元模型（ <code class="filename">metamodel.xsd</code> ）</p></li><li class="listitem"><p>型号（ <code class="filename">model.xml</code> ）</p></li><li class="listitem"><p>Xpand模板（ <code class="filename">template.xpt</code> ）</p></li><li class="listitem"><p>MWE工作流程（ <code class="filename">workflow.mwe</code> ）</p></li></ul></div><div class="figure"><a name="xsd_tutorial_xsd_project"></a><p class="title"><b>图1。简约的Xpand XSD项目</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/workspace-minidemo.png" alt="简约的Xpand XSD项目"></div></div></div><br class="figure-break"></div><div class="section" title="第1步：创建项目"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_create_project"></a>第1步：创建项目</h2></div></div></div><p>要创建项目，请创建一个普通的Xtend / Xpand-Project。这是在Eclipse中通过更改为Xtend / Xpand透视图并单击<span class="emphasis"><em>“File”/“New”/“Xtend / Xpand Project”来完成的</em></span> 。输入项目名称后，将创建该名称。</p><p>创建项目后，需要激活对XSD元模型的支持。在项目上单击鼠标右键，然后打开属性窗口。然后转到“Xpand / Xtend”页面，“ <span class="emphasis"><em>启用项目特定设置</em></span> ”并激活“ <span class="emphasis"><em>XSD Metamodels</em></span> ”复选框。没有必要为激活的任何其他元模型提供支持，除非您确定要使用其中一个模型。<a class="xref" href="#xsd_tutorial_project_properties_mm" title="图2。激活项目的XSD元模型支持">图2“激活项目的XSD元模型支持”</a>显示了配置的外观。</p><div class="figure"><a name="xsd_tutorial_project_properties_mm"></a><p class="title"><b>图2。激活项目的XSD元模型支持</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/project-properties-mm.png" alt="激活项目的XSD元模型支持"></div></div></div><br class="figure-break"><p>然后，需要将<code class="classname">org.eclipse.xtend.typesystem.xsd</code>添加到项目的依赖项中。为此，请从项目中打开文件<code class="filename">META-INF/MANIFEST.MF</code>并导航到“Dependencies”选项卡。
    需要将<code class="classname">org.eclipse.xtend.typesystem.xsd</code>添加到“Required Plug-ins”列表中， <a class="xref" href="#xsd_tutorial_project_dependencies" title="图3。项目所需的依赖项">如图3“Project的必需依赖</a>项”所示。</p><div class="figure"><a name="xsd_tutorial_project_dependencies"></a><p class="title"><b>图3。项目所需的依赖项</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/project-dependencies.png" alt="项目所需的依赖项"></div></div></div><br class="figure-break"></div><div class="section" title="第2步：使用XML Schema定义元模型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_metamodel"></a>第2步：使用XML Schema定义元模型</h2></div></div></div><p>如果您不打算使用现有的XML Schema Definition，可以创建一个新的，如下所述。这些步骤使用Eclipse Web Tools Platform（WTP）来创建花哨的编辑器。</p><p>在Eclipse中，单击<span class="emphasis"><em>“File”，“New”，“Other ...”，</em></span>然后从“XML”类别中选择<span class="emphasis"><em>“XML Schema</em></span> ”。选择项目的“src”文件夹并指定文件名。单击“完成”将创建一个空的XSD文件。XSD文件位于项目类路径中的某个位置非常重要。</p><p>此XML模式由两种复杂数据类型组成，其中包含一些元素和属性。 XSD术语中的“复杂”意味着与简单数据类型相反，它们实际上可以具有子元素和/或属性。这个例子过于简约，无法做任何有用的事情。</p><p>复杂的类型<code class="classname">Wizard</code>包含元素<code class="classname">startpage</code> ， <code class="classname">name</code> ， <code class="classname">welcometext</code>和<code class="classname">choicepage</code> 。除了<code class="classname">choicepage</code>之外，所有元素都必须包含字符串，而<code class="classname">startpage</code>字符串必须是任何<code class="classname">ChoicePage</code>的有效id。复杂类型<code class="classname">ChoicePage</code>只包含一个<code class="classname">id</code>和一个<code class="classname">name</code> 。对于Xpand，如果将某些内容建模为XML属性或XML元素，则没有任何区别。只是数据字段的类型定义了Xpand如何处理该值。</p><p>要概述Xpand XSD Adapter如何使用模式，请参阅<a class="xref" href="#xsd_reference_declare_xsd" title="如何声明XML Schema">“如何声明XML模式”一节。</a></p><p>在内部，Xpand XSD Adapter将XSD模型转换为Ecore模型，Xpand可以像任何其他Ecore模型一样使用它。有关更多信息，请参阅<a class="xref" href="#xsd_reference_xsd2ecore" title="幕后制作：将XSD转变为Ecore">“幕后操作：将XSD转换为Ecore”一节</a></p><div class="figure"><a name="xsd_tutorial_xsd_editor"></a><p class="title"><b>图4。WTP架构编辑器</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/xsd-editor.png" alt="WTP架构编辑器"></div></div></div><br class="figure-break"><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.example.org/wizard”xmlns：tns =“http://www.example.org/向导“elementFormDefault =”qualified“&gt; &lt;complexType name =”Wizard“&gt; &lt;sequence&gt; &lt;element name =”startpage“type =”IDREF“/&gt; &lt;element name =”name“type =”string“/&gt; &lt;element name =“welcometext”type =“string”/&gt; &lt;element name =“choicepage”type =“tns：ChoicePage”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;complexType name =“ChoicePage”&gt; &lt;sequence&gt; &lt;element name = “title”type =“string”/&gt; &lt;/ sequence&gt; &lt;attribute name =“id”type =“ID”/&gt; &lt;/ complexType&gt; &lt;element name =“wizard”type =“tns：Wizard”/&gt; &lt;/模式&gt;</pre></div><div class="section" title="第3步：使用XML创建模型"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_model"></a>第3步：使用XML创建模型</h2></div></div></div><p>正如标题所说，XML格式的数据将成为模型。并且由于模型必须根据元模型有效，因此XML文件必须根据XSD有效。</p><p>如果您不打算使用现有的XML文件，可以创建一个新的XML文件，如下所述。这些步骤需要安装Eclipse Web Tools Platform（WTP）。</p><p>在Eclipse中，点击<span class="emphasis"><em>“文件”，“新”，“其他...”，</em></span>然后从类别<span class="emphasis"><em><span class="emphasis"><em>“XML”，“XML”。</em></span></em></span>在文件夹“src”中指定文件名后，选择<span class="emphasis"><em>“从XML Schema创建XML文件”</em></span>并选择XML Schema Definition文件。告诉Eclipse使用哪个模式有三个优点：Eclipse验证XML文件，编辑时元模型识别代码完成，Eclipse创建一个<span class="property">xsi：schemaLocation</span> -attribute，告诉任何读取模式文件所在XML文件的人。本教程不使用<span class="property">xsi：schemaLocation</span> -attribute，而是在MWE工作流中引入模式文件。有关所有可能的方法，请参阅<a class="xref" href="#xsd_reference_declare_xsd" title="如何声明XML Schema">“如何声明XML架构”一节</a> 。XML文件位于项目类路径中的某个位置非常重要。</p><pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;wizard xmlns =“http://www.example.org/wizard”&gt; &lt;startpage&gt; start &lt;/ startpage&gt; &lt;name&gt;我的示例安装程序&lt;/ name&gt; &lt;welcometext&gt;欢迎使用这个小型演示应用程序。&lt;/ welcometext &gt; &lt;choicepage id =“start”&gt; &lt;title&gt;向导第一页&lt;/ title&gt; &lt;/ choicepage&gt; &lt;/ wizard&gt;</pre></div><div class="section" title="第4步：使用Xpand创建模板"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_template"></a>第4步：使用Xpand创建模板</h2></div></div></div><p>创建一个普通的Xpand Template文件：在Xpand / Xtend透视图中，转到<span class="emphasis"><em>“File”，“New”，“xPand template”</em></span> 。Xpand语言本身由其他几个Xpand文档解释。如同在<a class="xref" href="#xsd_tutorial_create_project" title="Step 1: Create a Project">“步骤1：创建项目”一节</a>中<a class="xref" href="#xsd_tutorial_create_project" title="第1步：创建项目">所述</a>激活XSD元模型支持，Xpand扫描并监视所有项目以获得合适的元模型。根据发现的内容，Xpand编辑器提供元模型识别代码完成。</p><p>此示例在开头导入“ <code class="classname">metamodel</code> ”，它指的是名为<code class="filename">metamodel.xsd</code>的文件，您在项目的类路径中创建了一个<a class="xref" href="#xsd_tutorial_metamodel" title="第2步：使用XML Schema定义元模型">名为“步骤2：使用XML模式定义元模型”的部分</a> 。define-block可以理解为一个名为“ <code class="methodname">Root</code> ”的函数，它将一个<code class="classname">metamodel::Wizard</code>类型的对象作为参数。这是XML的根对象的元模型类型。文件块创建一个名为<code class="filename">wizard.txt</code>的文件，并将文件块包围的文本写入文件。 <code class="classname">name</code> ， <code class="classname">welcometext</code>和<code class="classname">choicepage.title</code>是XSD元模型中定义的元素或属性。它们的值存储在XML文件中，此模板将它们插入到生成的（ <code class="filename">wizard.txt</code> ）文件中。</p><pre class="programlisting">«IMPORT metamodel»«DEFINE Root for metamodel :: Wizard»«FILE“wizard.txt”»姓名：«name»Welcometext：«welcometext»首页标题：«choicepage.title»«ENDFILE»«ENDDEFINE»</pre></div><div class="section" title="第5步：创建工作流程"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_create_workflow"></a>第5步：创建工作流程</h2></div></div></div><p>工作流将模型，元模型和模板联系在一起，并定义了如何生成代码的过程。</p><p>要创建新的工作流文件，请切换到Xpand / Xtend透视图，单击<span class="emphasis"><em>“文件”，“新建”和“工作流程文件”</em></span> 。指定文件夹和文件名后，将创建一个空工作流程。</p><p>简约方法包括两个步骤：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>阅读模型：这是由<code class="classname">org.eclipse.xtend.typesystem.xsd.完成的<code class="classname">org.eclipse.xtend.typesystem.xsd.XMLReader</code> 。它只需要一个定义XML文件的<code class="classname">uri</code>元素。<code class="classname">org.eclipse.xtend.typesystem.xsd.类型的另一个嵌套元素<code class="classname">org.eclipse.xtend.typesystem.xsd.XSDMetaModel</code>告诉<code class="classname">XMLReader</code>要使用哪个元模型。
        <code class="classname">XSDMetaModel</code>可以包含多个<code class="classname">schemaFile</code>元素。如何将模式用于XML文件是基于声明的名称空间确定的。
        <code class="classname">modelSlot</code>定义了模型在内部存储的位置，这就像变量名称，如果要在同一工作流程中处理多个模型， <code class="classname">modelSlot</code>变得很重要。</p></li><li class="listitem"><p>生成代码：这部分只是使用Xpand生成常规代码，并不是特定于Xpand XSD Adapter。生成器<code class="classname">org.eclipse.xpand2.Generator</code>需要知道要使用哪个元模型。此示例引用先前声明的一个。<code class="classname">expand</code>元素告诉生成器使用slot <code class="varname">model</code>作为参数调用文件<code class="filename">template.xpt</code>名为<code class="methodname">Root</code>的定义。元素<code class="classname">outlet</code>定义了生成文件的存储位置。</p></li></ol></div><pre class="programlisting">&lt;workflow&gt; &lt;component class =“org.eclipse.xtend.typesystem.xsd。XMLReader“&gt; &lt;modelSlot value =”model“/&gt; &lt;uri value =”model.xml“/&gt; &lt;metaModel id =”mm“class =”org.eclipse.xtend.typesystem.xsd。XSDMetaModel“&gt; &lt;schemaFile value =”metamodel.xsd“/&gt; &lt;/ metaModel&gt; &lt;/ component&gt; &lt;component class =”org.eclipse.xpand2。生成器“&gt; &lt;metaModel idRef =”mm“/&gt; &lt;expand value =”template :: Root FOR model“/&gt; &lt;outlet path =”src-gen“/&gt; &lt;/ component&gt; &lt;/ workflow&gt;</pre></div><div class="section" title="第6步：执行工作流程，即生成代码"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="xsd_tutorial_execute_workflow"></a>第6步：执行工作流程，即生成代码</h2></div></div></div><p>在您实际执行工作流程之前，或者在出现错误的情况下，您可以使用<a class="xref" href="#xsd_tutorial_minidemo_all" title="图5。本教程的文件">图5“本教程的文件”</a>来仔细检查您的文件。</p><div class="figure"><a name="xsd_tutorial_minidemo_all"></a><p class="title"><b>图5。本教程的文件</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/minidemo-all.png" alt="本教程的文件"></div></div></div><br class="figure-break"><p>要执行工作流程，请在工作流程文件上单击鼠标右键，然后选择<span class="emphasis"><em>“运行方式”，“MWE工作流程”</em></span> ，如<a class="xref" href="#xsd_tutorial_execute_workflow" title="第6步：执行工作流程，即生成代码">“步骤6：执行工作流程即生成代码”一节中所示</a> 。</p><div class="figure"><a name="xsd_tutorial_launch_workflow"></a><p class="title"><b>图6。执行工作流程</b></p><div class="figure-contents"><div class="mediaobject"><img src="xsd_tutorial/execute-workflow.png" alt="执行工作流程"></div></div></div><br class="figure-break"><p>执行工作流时，此输出应显示在Eclipse的控制台视图中。如果该视图没有自动弹出，您可以通过<span class="emphasis"><em>“窗口”，“显示视图”，“控制台”访问它</em></span> 。</p><pre class="programlisting">2009年5月25日下午3:09:35 org.eclipse.emf.mwe.core。WorkflowRunner准备INFO：正在运行的工作流程：/Users/meysholdt/Eclipse/workspace-3.5-M7/org.eclipse.xpand.examples.xsd.m2t.minimal/src/xsd/m2t/minimal/minimal.mwe 2009年5月25日3 ：09：35 PM org.eclipse.emf.mwe.core。WorkflowRunner准备信息：2009年5月25日下午3:09:36 org.eclipse.xtend.typesystem.xsd。XSDMetaModel addSchemaFile INFO：从'xsd / m2t / minimal / metamodel.xsd'加载XSDSchema 2009年5月25日下午3:09:37 org.eclipse.xtend.typesystem.xsd.builder。OawXSDEcoreBuilder initEPackage INFO：从XSDSchema'文件创建EPackage'元模型'：/.../ bin / xsd / m2t / minimal / metamodel.xsd'（http://www.example.org/wizard)2009年5月25日3： 09:37 PM org.eclipse.emf.mwe.core.container。CompositeComponent internalInvoke INFO：XMLReader：加载XML文件xsd / m2t / minimal / model.xml May 25,2009 3:09:37 PM org.eclipse.emf.mwe.core.container。CompositeComponent internalInvoke INFO：Generator：生成'xsd :: m2t :: minimal :: template :: Root FOR model'=&gt; src-gen 2009年5月25日下午3:09:38 org.eclipse.xpand2。生成器invokeInternal2 INFO：写入1个文件到outlet [默认]（src-gen）2009年5月25日下午3:09:38 org.eclipse.emf.mwe.core。WorkflowRunner executeWorkflow INFO：工作流程在657ms完成！
</pre><p>代码生成后， <code class="filename">src-gen</code>文件夹中有一个名为<code class="filename">wizard.txt</code>的文件。其内容应如下所示。您应该能够识别模板文件中定义的结构和XML模型中的内容。</p><pre class="programlisting">名称：我的示例设置Welcometext：欢迎使用这个小型演示应用程序。第一页标题：向导第一页</pre></div></div></div><div class="index" title="指数"><div class="titlepage"><div><div><h2 class="title"><a name="N1324A"></a>指数</h2></div></div></div><div class="index"><div class="indexdiv"><h3>符号</h3><dl><dt>.chk， <a class="indexterm" href="#Check_language_description">检查语言的描述</a></dt><dt>.xpt， <a class="indexterm" href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a></dt><dt>* .ext， <a class="indexterm" href="#N10DE7">Xtend文件</a></dt></dl></div><div class="indexdiv"><h3>一个</h3><dl><dt><a class="indexterm" href="#N1107E">Xtend中的</a>建议， <a class="indexterm" href="#N1107E">面向方面编程</a></dt><dt>AdviceContext， <a class="indexterm" href="#N110D9">Proceeding</a></dt><dt><a class="indexterm" href="#xpand_reference_aspect-oriented_programming_in_xpand">XOP中的</a> AOP， <a class="indexterm" href="#N1107E">面向</a> <a class="indexterm" href="#xpand_reference_aspect-oriented_programming_in_xpand">方面编程，Xpand中面向方面编程</a></dt><dd><dl><dt>加入点， <a class="indexterm" href="#xpand_reference_join_point_and_cut_syntax">加入点和点切割语法</a></dt><dt>点剪切， <a class="indexterm" href="#xpand_reference_join_point_and_cut_syntax">连接点和点剪切语法</a></dt><dt>工作流程， <a class="indexterm" href="#aop_template_example_workflow_file">工作流程文件</a></dt><dt>Xpand， <a class="indexterm" href="#aop_template_introduction">在Xpand中使用面向方面编程的示例</a></dt></dl></dd><dt>另外， <a class="indexterm" href="#xpand_reference_aspect-oriented_programming_in_xpand">Xpand中的面向方面编程</a> ， <a class="indexterm" href="#aop_template_example_templates">模板</a> ， <a class="indexterm" href="#aop_template_more_ao">更多面向方面</a></dt><dt>面向<a class="indexterm" href="#N1107E">方面编程，Xtend中面向方面编程</a></dt></dl></div><div class="indexdiv"><h3>乙</h3><dl><dt>布尔类型， <a class="indexterm" href="#r10_builtintypes_simple">简单类型（数据类型）</a></dt><dt>内置式， <a class="indexterm" href="#r10_builtintypes">内置式</a></dt><dd><dl><dt>集合类型， <a class="indexterm" href="#r10_builtintypes_collections">集合类型</a></dt><dt>对象， <a class="indexterm" href="#r10_builtintypes_object">对象</a> ， <a class="indexterm" href="#r10_expressions_builtin_object">对象</a></dt><dt>简单类型， <a class="indexterm" href="#r10_builtintypes_simple">简单类型（数据类型）</a></dt><dt>虚空， <a class="indexterm" href="#r10_builtintypes_void">虚空</a> ， <a class="indexterm" href="#r10_expressions_builtin_object">物体</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>缓存， <a class="indexterm" href="#N10EC5">缓存扩展</a></dt><dt>盒式磁带， <a class="indexterm" href="#xpand_reference_aspect-oriented_programming_in_xpand">Xpand中面向方面的编程</a></dt><dt>铸造， <a class="indexterm" href="#r10_expressions_casting">铸造</a></dt><dt>CEND， <a class="indexterm" href="#xpand_reference_protect">PROTECT</a></dt><dt>校验</dt><dd><dl><dt>文件扩展名， <a class="indexterm" href="#Check_language_description">Check语言的描述</a></dt><dt>语言，使用<a class="indexterm" href="#emf_tutorial_checking_contraints_with_check">检查</a>语言<a class="indexterm" href="#emf_tutorial_checking_contraints_with_check">检查约束，检查语言的</a> <a class="indexterm" href="#Check_language_description">描述</a></dt></dl></dd><dt>Classpath， <a class="indexterm" href="#xpand_reference_extension">EXTENSION</a></dt><dt>收集，收集， <a class="indexterm" href="#r10_expressions_collection_collect">收集的</a> <a class="indexterm" href="#r10_expressions_collection_collect_shorthand">速记（以及更多）</a></dt><dt>集合， <a class="indexterm" href="#r10_builtintypes_collections">集合类型</a> ， <a class="indexterm" href="#xpand_reference_foreach">FOREACH</a></dt><dt>集合类型， <a class="indexterm" href="#r10_typesystem_collection_typenames">集合类型名称</a></dt><dt>集合类型， <a class="indexterm" href="#xpand_reference_for_vs_foreach">FOR与FOREACH</a></dt><dt>约束， <a class="indexterm" href="#emf_tutorial_defining_the_constraint">定义约束</a> ， <a class="indexterm" href="#Check_language_description">检查语言的描述</a></dt><dt>创建， <a class="indexterm" href="#create_extension">创建扩展（模型转换）</a></dt><dt>创建扩展， <a class="indexterm" href="#xtend_example_the_transformation">转换</a></dt><dt>CSTART， <a class="indexterm" href="#xpand_reference_protect">保护</a></dt></dl></div><div class="indexdiv"><h3>d</h3><dl><dt>DEFINE， <a class="indexterm" href="#xpand_reference_define">DEFINE</a></dt><dt>DirectoryCleaner， <a class="indexterm" href="#uml2example_codegen_workflow">定义工作流程</a></dt><dt>动态EMF， <a class="indexterm" href="#emf_tutorial_dynamic_emf">使用动态EMF</a></dt></dl></div><div class="indexdiv"><h3>Ë</h3><dl><dt>EClassifiers， <a class="indexterm" href="#r10_typesystem_typenames">类型名称</a></dt><dt>ELSEIF， <a class="indexterm" href="#xpand_reference_if">IF</a></dt><dt>EMF， <a class="indexterm" href="#emf_tutorial">入门</a></dt><dt>EmfMetaModel， <a class="indexterm" href="#emf_tutorial_templates">模板</a> ， <a class="indexterm" href="#r10_typesystem_typenames">类型名称</a> ， <a class="indexterm" href="#emf_metamodel">EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）</a></dt><dd><dl><dt>metaModelPackage， <a class="indexterm" href="#emf_tutorial_dynamic_emf">使用动态EMF</a></dt></dl></dd><dt>EMF元模型， <a class="indexterm" href="#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a></dt><dt>EMF项目， <a class="indexterm" href="#emf_tutorial_creating_emf_project">创建EMF项目</a></dt><dt>EmfRegistryMetaModel， <a class="indexterm" href="#emfregistry_metamodel">EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）</a></dt><dt>EMF UML2 XMI， <a class="indexterm" href="#uml2example_profiles_codegen">生成代码</a></dt><dt>编码， <a class="indexterm" href="#emf_tutorial_setting_generator_project">设置生成器项目</a> （请参阅文件编码）</dt><dt>ENDIF， <a class="indexterm" href="#xpand_reference_if">IF</a></dt><dt>列举</dt><dd><dl><dt>Literal， <a class="indexterm" href="#r10_expressions_builtin_staticproperties">StaticProperty文字</a></dt></dl></dd><dt>枚举（UML2）， <a class="indexterm" href="#uml2example_profiles">配置文件支持</a></dt><dt>包装， <a class="indexterm" href="#r10_typesystem_typenames">类型名称</a></dt><dt>错误， <a class="indexterm" href="#xpand_reference_error">错误</a></dt><dt>ExecutionContext， <a class="indexterm" href="#N10F22">IExecutionContextAware</a></dt><dt>存在， <a class="indexterm" href="#r10_expressions_collection_exists">存在</a></dt><dt>EXPAND， <a class="indexterm" href="#xpand_reference_expand">EXPAND</a> ， <a class="indexterm" href="#xpand_reference_metamodel">Metamodel</a></dt><dt>表达， <a class="indexterm" href="#r10_expressions_language">表达</a></dt><dd><dl><dt>缓存， <a class="indexterm" href="#create_extension">创建扩展（模型转换）</a></dt><dt>调用， <a class="indexterm" href="#N11023">从Java调用扩展</a></dt><dt>链， <a class="indexterm" href="#r10_expressions_chain">链表达</a></dt><dt>创造， <a class="indexterm" href="#xtend_example_the_transformation">转型</a></dt><dt>如果， <a class="indexterm" href="#r10_expressions_if">如果表达</a></dt><dt>新的， <a class="indexterm" href="#r10_expressions_create">新的表达</a></dt><dt>分隔符， <a class="indexterm" href="#xpand_reference_specifying_a_separator">指定分隔符</a></dt><dt>切换， <a class="indexterm" href="#r10_expressions_switch">切换表达式</a></dt></dl></dd><dt>表达式语言， <a class="indexterm" href="#r10_expressions_language">表达式</a></dt><dt>扩展， <a class="indexterm" href="#emf_tutorial_extensions">扩展</a> ， <a class="indexterm" href="#N10E26">扩展导入声明</a></dt><dd><dl><dt>缓存， <a class="indexterm" href="#N10EC5">缓存扩展</a></dt><dt>创建， <a class="indexterm" href="#create_extension">创建扩展（模型转换）</a> ， <a class="indexterm" href="#xtend_example_the_transformation">转换</a></dt><dt>调用， <a class="indexterm" href="#N10E50">扩展调用</a></dt><dt>Java， <a class="indexterm" href="#N10EF3">Java扩展</a></dt><dt>私人， <a class="indexterm" href="#N10EE0">私人扩展</a></dt><dt>递归， <a class="indexterm" href="#N10EB3">递归</a></dt></dl></dd><dt>扩展， <a class="indexterm" href="#xpand_reference_extension">扩展</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>文件， <a class="indexterm" href="#xpand_reference_file">文件</a></dt><dt>文件编码</dt><dd><dl><dt>编码， <a class="indexterm" href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a> ， <a class="indexterm" href="#xpand_reference_encoding">编码</a> ， <a class="indexterm" href="#xpand_reference_output_configuration">输出配置</a></dt></dl></dd><dt>文件扩展名</dt><dd><dl><dt>.xpt， <a class="indexterm" href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a></dt></dl></dd><dt>FOR， <a class="indexterm" href="#xpand_reference_for_vs_foreach">FOR vs. FOREACH</a></dt><dt>forAll， <a class="indexterm" href="#r10_expressions_collection_forall">forAll</a></dt><dt>FOREACH， <a class="indexterm" href="#xpand_reference_for_vs_foreach">FOR FOR FOR FORACH</a></dt></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>发电机</dt><dd><dl><dt>fileEncoding属性， <a class="indexterm" href="#xpand_reference_encoding">编码</a></dt><dt>Metamodel配置， <a class="indexterm" href="#xpand_reference_metamodel">Metamodel</a></dt><dt>工作流组件， <a class="indexterm" href="#xpand_reference_generator_workflow_component">生成器工作流组件</a></dt></dl></dd><dt>Genmodel， <a class="indexterm" href="#emf_tutorial_generate_emf_tooling">生成EMF工具</a></dt><dt>GLOBALVAR， <a class="indexterm" href="#r10_expressions_globalvar">'GLOBALVAR'表达</a></dt><dt>全局变量， <a class="indexterm" href="#r10_expressions_globalvar_workflow">使用GLOBALVARS配置工作流程</a></dt><dt>守卫条件， <a class="indexterm" href="#Guard_conditions">守卫条件</a></dt><dt>Guillemet， <a class="indexterm" href="#emf_tutorial_templates">模板</a> ， <a class="indexterm" href="#xpand_reference_introduction">Xpand2</a> ， <a class="indexterm" href="#xpand_reference_encoding">编码</a></dt></dl></div><div class="indexdiv"><h3>一世</h3><dl><dt>IExecutionContextAware， <a class="indexterm" href="#N10F22">IExecutionContextAware</a></dt><dt>IF， <a class="indexterm" href="#xpand_reference_if">IF</a></dt><dt>导入， <a class="indexterm" href="#N10E15">导入语句</a></dt><dt>进口， <a class="indexterm" href="#xpand_reference_import">进口</a></dt><dt>整数类型， <a class="indexterm" href="#r10_builtintypes_simple">简单类型（数据类型）</a></dt><dt>ITERATOR， <a class="indexterm" href="#xpand_reference_foreach">FOREACH</a></dt></dl></div><div class="indexdiv"><h3>Ĵ</h3><dl><dt>JavaBeansMetaModel， <a class="indexterm" href="#N11023">从Java调用扩展</a></dt><dt>JavaBeansStrategy， <a class="indexterm" href="#N11023">从Java调用扩展</a></dt><dt>JavaBeautifier， <a class="indexterm" href="#xpand_reference_javabeautifier">JavaBeautifier</a></dt><dt>Java扩展， <a class="indexterm" href="#emf_tutorial_java_extensions">Java扩展</a> ， <a class="indexterm" href="#N10EF3">Java扩展</a></dt><dt>JavaMetaModel， <a class="indexterm" href="#r10_metamodel_example_java">示例JavaMetaModel</a> ， <a class="indexterm" href="#java_metamodel">Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）</a> ， <a class="indexterm" href="#N11023">从Java调用扩展</a></dt><dt>连接点， <a class="indexterm" href="#N1109F">连接点和点剪切语法</a> ， <a class="indexterm" href="#N110FA">工作流配置</a> ， <a class="indexterm" href="#xpand_reference_join_point_and_cut_syntax">连接点和点剪切语法</a></dt><dt>加入点， <a class="indexterm" href="#aop_template_example_templates">模板</a></dt></dl></div><div class="indexdiv"><h3>ķ</h3><dl><dt>关键词</dt><dd><dl><dt>属性， <a class="indexterm" href="#N10CD6">Xpand关键字和元模型属性</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>大号</h3><dl><dt>让， <a class="indexterm" href="#xpand_reference_let">让我们</a></dt><dt>列表， <a class="indexterm" href="#r10_builtintypes_collections">集合类型</a></dt><dt>文字， <a class="indexterm" href="#r10_expressions_builtin">文字和内置类型的特殊运算符</a></dt></dl></div><div class="indexdiv"><h3>中号</h3><dl><dt>元元模型， <a class="indexterm" href="#emf_tutorial_generate_emf_tooling">生成EMF工具</a></dt><dt>MetaModel， <a class="indexterm" href="#r10_typesystem_typenames">类型名称</a></dt><dt>Metamodel， <a class="indexterm" href="#r10_metamodel_contributors">Eclipse IDE MetaModelContributors</a> ， <a class="indexterm" href="#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a> ， <a class="indexterm" href="#metamodel_reference">Metamodel参考</a></dt><dd><dl><dt>（非侵入性）扩展， <a class="indexterm" href="#Xtend_language">Xtend</a></dt><dt>EMF， <a class="indexterm" href="#emf_metamodel">EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）</a></dt><dt>EMF注册表， <a class="indexterm" href="#emfregistry_metamodel">EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）</a></dt><dt>实现元模型， <a class="indexterm" href="#implementing_metamodels">实现自己的元模型</a></dt><dt>Java， <a class="indexterm" href="#java_metamodel">Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）</a></dt><dt>UML2， <a class="indexterm" href="#uml2_metamodel">UML2元模型（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）</a> ， <a class="indexterm" href="#uml2profile_metamodel">UML2 Profile Metamodel（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）</a></dt><dt>XSD， <a class="indexterm" href="#xsd_metamodel">XSD元模型（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）</a></dt></dl></dd><dt>MetamodelContributor， <a class="indexterm" href="#r10_metamodel_contributors">Eclipse IDE MetaModelContributors</a></dt><dt>Metamodel撰稿人， <a class="indexterm" href="#uml2example_setup_project">设置项目</a></dt><dt>元模型实现， <a class="indexterm" href="#r10_metamodel_implementations">元模型实现（也称为元元模型）</a></dt><dt><a class="indexterm" href="#xtend_example_introduction">使用Xtend进行模型</a>到模型的转换， <a class="indexterm" href="#xtend_example_introduction">模型到模型的转换</a></dt><dt>模型转换， <a class="indexterm" href="#create_extension">创建扩展（模型转换）</a></dt><dt>多种调度， <a class="indexterm" href="#r10_expressions_multidispatch">多种方式（多次调度）</a></dt></dl></div><div class="indexdiv"><h3>ñ</h3><dl><dt>命名空间</dt><dd><dl><dt>导入， <a class="indexterm" href="#xpand_reference_names">名称</a></dt></dl></dd><dt>换行， <a class="indexterm" href="#xpand_reference_controlling_generation_of_white_space">控制空白的生成</a></dt><dt>NoChangesVetoStrategy， <a class="indexterm" href="#N11709">VetoStrategy</a></dt></dl></div><div class="indexdiv"><h3>Ø</h3><dl><dt>OCL， <a class="indexterm" href="#r10_expressions_language">表达式</a></dt><dt>ONFILECLOSE， <a class="indexterm" href="#N11325">懒惰的评价</a></dt><dt>操作， <a class="indexterm" href="#r10_metamodel_implementations">元模型实现（也称为元元模型）</a></dt><dt>插座， <a class="indexterm" href="#xpand_reference_file">文件</a> ， <a class="indexterm" href="#xpand_reference_output_configuration">输出配置</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>点切割， <a class="indexterm" href="#N1109F">连接点和点切割语法</a> ， <a class="indexterm" href="#xpand_reference_join_point_and_cut_syntax">连接点和切割点语法</a></dt><dt>多态性， <a class="indexterm" href="#N10E66">类型推断</a> ， <a class="indexterm" href="#xpand_reference_define">DEFINE</a></dt><dt>PostProcessor， <a class="indexterm" href="#xpand_reference_beautifier">PostProcessor</a></dt><dt>私人， <a class="indexterm" href="#N10EE0">私人扩展</a></dt><dt>出发， <a class="indexterm" href="#N110D9">出发</a></dt><dt>ProfileMetaModel， <a class="indexterm" href="#uml2profile_metamodel">UML2配置文件元模型（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）</a></dt><dt>属性， <a class="indexterm" href="#r10_metamodel_implementations">元模型实现（也称为Meta-Metamodels）</a></dt><dt>保护， <a class="indexterm" href="#xpand_reference_protect">保护</a></dt><dt>受保护区域， <a class="indexterm" href="#xpand_reference_protect">PROTECT</a> ， <a class="indexterm" href="#xpand_reference_protected_region_configuration">受保护区域配置</a></dt><dd><dl><dt>禁用， <a class="indexterm" href="#xpand_reference_protect">保护</a></dt><dt>启用， <a class="indexterm" href="#xpand_reference_protect">保护</a></dt></dl></dd><dt>prSrcPaths， <a class="indexterm" href="#xpand_reference_protected_region_configuration">受保护区域配置</a></dt></dl></div><div class="indexdiv"><h3>[R</h3><dl><dt>真实类型， <a class="indexterm" href="#r10_builtintypes_simple">简单类型（数据类型）</a></dt><dt>递归扩展， <a class="indexterm" href="#N10EB3">递归</a></dt><dt>Reexport， <a class="indexterm" href="#N10E35">Reexporting Extensions</a></dt><dt>拒绝， <a class="indexterm" href="#r10_expressions_collection_reject">拒绝</a></dt><dt>REM， <a class="indexterm" href="#xpand_reference_comments">评论</a></dt><dt>返回类型， <a class="indexterm" href="#N10E66">类型推断</a></dt></dl></div><div class="indexdiv"><h3>小号</h3><dl><dt>选择， <a class="indexterm" href="#r10_expressions_collection_select">选择</a></dt><dt><a class="indexterm" href="#xpand_reference_specifying_a_separator">分离器</a> ， <a class="indexterm" href="#xpand_reference_specifying_a_separator">指定分隔符</a></dt><dt>设置类型， <a class="indexterm" href="#r10_builtintypes_collections">集合类型</a></dt><dt>SlotCopier， <a class="indexterm" href="#N12879">SlotCopier</a></dt><dt>SlotListAdder， <a class="indexterm" href="#N128C4">SlotListAdder</a></dt><dt>SlotPrinter， <a class="indexterm" href="#N12913">SlotPrinter</a></dt><dt>sortBy， <a class="indexterm" href="#r10_expressions_collection_sortby">sortBy</a></dt><dt>刻板印象， <a class="indexterm" href="#uml2example_profiles">配置文件支持</a></dt><dt>字符串类型， <a class="indexterm" href="#r10_builtintypes_simple">简单类型（数据类型）</a></dt><dt>SystemCommand， <a class="indexterm" href="#N12816">SystemCommand</a></dt></dl></div><div class="indexdiv"><h3>Ť</h3><dl><dt>标记值， <a class="indexterm" href="#uml2example_profiles">配置文件支持</a></dt><dt>模板</dt><dd><dl><dt>文件， <a class="indexterm" href="#xpand_reference_template_files_and_ecoding">模板文件和编码</a> ， <a class="indexterm" href="#xpand_reference_define">DEFINE</a></dt><dt>多态性， <a class="indexterm" href="#xpand_reference_define">DEFINE</a></dt></dl></dd><dt>转型， <a class="indexterm" href="#xtend_example_the_transformation">转型</a></dt><dt>类型</dt><dd><dl><dt>数据类型， <a class="indexterm" href="#r10_typesystem">类型系统</a></dt><dt>操作， <a class="indexterm" href="#r10_typesystem_features">功能</a></dt><dt>参数， <a class="indexterm" href="#N110C9">参数类型</a></dt><dt>参数化类型， <a class="indexterm" href="#r10_typesystem">类型系统</a></dt><dt>财产， <a class="indexterm" href="#r10_typesystem_features">特点</a></dt><dt>静态属性， <a class="indexterm" href="#r10_typesystem_features">功能</a> ， <a class="indexterm" href="#r10_expressions_builtin_staticproperties">StaticProperty文字</a></dt></dl></dd><dt>类型推断， <a class="indexterm" href="#N10E66">类型推断</a></dt><dt>typeSelect， <a class="indexterm" href="#r10_expressions_collection_typeselect">typeSelect</a> ， <a class="indexterm" href="#xpand_reference_metamodel">Metamodel</a></dt></dl></div><div class="indexdiv"><h3>ü</h3><dl><dt>UML2， <a class="indexterm" href="#uml2example_setup_eclipse">设置Eclipse</a></dt><dt>UML2MetaModel， <a class="indexterm" href="#uml2_metamodel">UML2 Metamodel（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）</a> ， <a class="indexterm" href="#uml2example_codegen_workflow">定义工作流程</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>VetoStrategy， <a class="indexterm" href="#N11709">VetoStrategy</a></dt></dl></div><div class="indexdiv"><h3>w ^</h3><dl><dt>编织建议， <a class="indexterm" href="#N1107E">Xtend中面向方面的编程</a></dt><dt>空白</dt><dd><dl><dt>省略， <a class="indexterm" href="#xpand_reference_controlling_generation_of_white_space">控制空白的生成</a></dt></dl></dd><dt>WorkflowComponent， <a class="indexterm" href="#N11067">WorkflowComponent</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>XMI， <a class="indexterm" href="#emf_tutorial_defining_metamodel">定义（meta）模型</a></dt><dt>XMIReader， <a class="indexterm" href="#xmi_reader">XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）</a></dt><dt>XmiReader， <a class="indexterm" href="#uml2example_codegen_workflow">定义工作流程</a></dt><dt>XMI阅读器， <a class="indexterm" href="#xmi_reader">XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）</a></dt><dt>XPAND</dt><dd><dl><dt>评论， <a class="indexterm" href="#xpand_reference_comments">评论</a></dt><dt>表达式语句， <a class="indexterm" href="#xpand_reference_expression_statement">表达式语句</a></dt><dt>语言， <a class="indexterm" href="#xpand_reference_introduction">Xpand2</a></dt></dl></dd><dt>XpandException， <a class="indexterm" href="#xpand_reference_error">ERROR</a></dt><dt>XSDMetaModel， <a class="indexterm" href="#xsd_metamodel">XSD Metamodel（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）</a></dt><dt>Xtend， <a class="indexterm" href="#xpand_reference_extension">EXTENSION</a></dt><dd><dl><dt>评论， <a class="indexterm" href="#N10E05">评论</a></dt><dt>文件扩展名， <a class="indexterm" href="#N10DE7">Xtend文件</a></dt><dt>语言， <a class="indexterm" href="#Xtend_language">Xtend</a></dt></dl></dd><dt>XtendComponent， <a class="indexterm" href="#N11067">WorkflowComponent</a></dt><dd><dl><dt>建议， <a class="indexterm" href="#N110FA">工作流程配置</a></dt></dl></dd><dt>XtendFacade， <a class="indexterm" href="#N11023">从Java调用扩展</a></dt></dl></div></div></div></div></body></html>