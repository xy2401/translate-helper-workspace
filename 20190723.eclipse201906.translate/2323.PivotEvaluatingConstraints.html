<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>评估约束和查询</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="PivotProgrammersGuide.html" title="Unified or Pivot Programmers Guide"></link>
<link rel="prev" href="PivotParsingConstraints.html" title="Parsing Constraints and Queries"></link>
<link rel="next" href="PivotParsingDocuments.html" title="Parsing OCL Documents"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">评估约束和查询</h1>
<div class="section" title="评估约束和查询">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="PivotEvaluatingConstraints"></a>评估约束和查询</h2>
</div>
</div>
</div>
<p>在<a class="link" href="PivotParsingConstraints.html" title="解析约束和查询">Parsing Constraints中</a> ，我们看到了如何使用<code class="code">OCL</code> Facade来解析文本OCL约束或查询表达式以给出其<code class="code">ExpressionInOCL</code>编译表示。解析约束很有意思，但使用<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/utilities/Query.html" target="_new"><code class="code">Query</code></a> API对它们进行评估会更有用。
			</p>
<div class="section" title="OCL查询">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLQuery2"></a> OCL查询</h3>
</div>
</div>
</div>
<p><a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/utilities/Query.html" target="_new"><code class="code">Query</code></a>类包装最小的<code class="code">ExpressionInOCL</code>解析结果以提供评估功能。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6315-query.png"></div>
<p>
				
</p>
<p><code class="code">Query</code>封装了一个<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/evaluation/EvaluationEnvironment.html" target="_new"><code class="code">EvaluationEnvironment</code></a>它将上下文变量的运行<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/evaluation/EvaluationEnvironment.html" target="_new"><code class="code">EvaluationEnvironment</code></a>提供给OCL解释器。使用以下方法设置和检索这些上下文变量：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">add(TypedElement, Object)</code> ：添加TypedElement-to-value绑定</p>
</li>
<li class="listitem">
<p>
							
<code class="code">replace(TypedElement, Object)</code> ：替换现有绑定</p>
</li>
<li class="listitem">
<p>
							
<code class="code">remove(TypedElement)</code> ：删除绑定</p>
</li>
<li class="listitem">
<p>
							
<code class="code">getValueOf(TypedElement)</code> ：获取绑定值</p>
</li>
</ul>
</div>
<p>.bq Eclipse OCL的Ecore / UML绑定使用String而不是TypedElement来支持名称到值的绑定。使用TypedElement而不是String可以避免同一名称根据上下文引用多个变量。.P</p>
<p>主要关注的上下文变量是<code class="code">self</code>并且在操作约束中，是与其参数对应的变量。
				</p>
<p>OCL评估的一个重要考虑因素是<code class="code">allInstances()</code>操作，它获取分类器的整个范围。对于数据类型，这是一个简单的问题： <code class="code">Enumeration</code>的范围已明确定义，其他类型的<code class="code">DataType</code>的范围未定义。对于<code class="code">Class</code>扩展区， <code class="code">OCL</code>句柄引用一个<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/evaluation/ModelManager.html" target="_new"><code class="code">ModelManager</code></a> ，该模型管理器提供对用户模型的访问。默认的<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/pivot/internal/evaluation/PivotModelManager.html" target="_new"><code class="code">PivotModelManager</code></a>懒惰地从包含评估的上下文元素的EMF <code class="code">ResourceSet</code>计算类的范围。
				</p>
<p>因此，在可选地设置上下文变量的值（除了<code class="code">self</code> ; <code class="code">Query</code>负责这个）和范围映射之后，只需构造一个查询并使用它来计算表达式或检查约束：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6315-check-all.png"></div>
<p>

					
<a class="ulink" href="../references/6315-check-all.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
<div class="section" title="对象表示">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Objectrepresentations"></a>对象表示</h3>
</div>
</div>
</div>
<p>上面的示例使用<code class="code">evaluateUnboxed()</code>以便返回值为unboxed并与Classic Ecore / UML OCL绑定兼容。
				</p>
<p>OCL的Pivot绑定支持三种不同的Java表示。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>盒装供内部使用</p>
</li>
<li class="listitem">
<p>unboxed用于传统的API兼容性</p>
</li>
<li class="listitem">
<p>Ecore for Ecore API兼容性</p>
</li>
</ul>
</div>
<table id="N15A14">
<tr>
						
<th>OCL</th>
						<th>拆箱</th>
						<th>Ecore元</th>
						<th>盒装</th>
					
</tr>
<tr>
						
<td>布尔</td>
						<td>布尔</td>
						<td>布尔</td>
						<td>布尔</td>
					
</tr>
<tr>
						
<td>串</td>
						<td>串</td>
						<td>串</td>
						<td>串</td>
					
</tr>
<tr>
						
<td>整数</td>
						<td>整型/长/ BigDecimal的</td>
						<td>整型/长/ BigDecimal的</td>
						<td>IntegerValue</td>
					
</tr>
<tr>
						
<td>真实</td>
						<td>浮点/双精度</td>
						<td>浮点/双精度</td>
						<td>RealValue</td>
					
</tr>
<tr>
						
<td>宾语</td>
						<td>EObject</td>
						<td>EObject</td>
						<td>EObject</td>
					
</tr>
<tr>
						
<td>类型</td>
						<td>EClassifier</td>
						<td>EClassifier</td>
						<td>TypeValue</td>
					
</tr>
<tr>
						
<td>空值</td>
						<td>空值</td>
						<td>空值</td>
						<td>空值</td>
					
</tr>
<tr>
						
<td>无效</td>
						<td>InvalidValueException</td>
						<td>InvalidValueException</td>
						<td>InvalidValueException</td>
					
</tr>
<tr>
						
<td>采集</td>
						<td>采集</td>
						<td>的EList</td>
						<td>CollectionValue</td>
					
</tr>
<tr>
						
<td>袋</td>
						<td>袋</td>
						<td>的EList</td>
						<td>BagValue</td>
					
</tr>
<tr>
						
<td>序列</td>
						<td>名单</td>
						<td>的EList</td>
						<td>SequenceValue</td>
					
</tr>
<tr>
						
<td>OrderedSet</td>
						<td>OrderedSet</td>
						<td>的EList</td>
						<td>OrderedSetValue</td>
					
</tr>
<tr>
						
<td>组</td>
						<td>组</td>
						<td>的EList</td>
						<td>设定值</td>
					
</tr>
</table>
<p>只要<code class="code">Object.equals(Object)</code>的Java语义与<code class="code">OclAny::_'='(OclAny)</code>的OCL语义不同，就会使用盒装表示。
				</p>
<p>当需要与Ecore / UML绑定类似的表示时，使用未装箱的表示。</p>
<p>Ecore表示用于与Ecore EStructuralFeature值或EOperation参数和返回的所有交换。</p>
</div>
<div class="section" title="多重评估">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MultipleEvaluations"></a>多重评估</h3>
</div>
</div>
</div>
<p><code class="code">Query</code> API的一个优点是查询的评估环境可以重复用于多个评估，如上所述。任何分类器的范围仅计算一次。但是，为方便起见，在只需要一次评估的情况下， <code class="code">OCL</code>类提供了快捷方式：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6315-check-one.png"></div>
<p>

					
<a class="ulink" href="../references/6315-check-one.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
<div class="section" title="Succint评估">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="SuccintEvaluations"></a> Succint评估</h3>
</div>
</div>
</div>
<p><code class="code">Query</code> API还提供了处理多个元素的方法。上面的第一个例子可以更简洁地写成：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/6315-check-quick.png"></div>
<p>

					
<a class="ulink" href="../references/6315-check-quick.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
</div>
</body>
</html>
