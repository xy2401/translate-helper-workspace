<html dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><title>架构意识</title><link href="book.css" type="text/css" rel="stylesheet"></link><link href="book.css" type="text/css" rel="stylesheet"></link><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></meta><link rel="home" href="index.html" title="usermanual"></link><link rel="up" href="ch02.html" title="How to feed Psychopath XPath expressions"></link><link rel="prev" href="ch02.html" title="How to feed Psychopath XPath expressions"></link><link rel="next" href="ch02s03.html" title="How to use the XPath 2.0 grammar with PsychoPath"></link></head><body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" title="架构意识"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="Schema_Aware"></a>架构意识</h2></div></div></div><div class="literallayout"><p>/ **<br>*首先加载并选择性地验证XML文档<br>* /<br>//从XML文档创建一个InputStream<br>InputStream = new FileInputStream（“XPexample.xml”）;<br>
</p></div><div class="literallayout"><p>SchemaFactory schemaFactory = new XMLSchemaFactory（）;<br>URL schemaURL = new File（“XPexample.xsd”）。toURL（）;<br>Schema jaxpschema = schemaFactory.newSchema（schemaURL）;<br>
</p></div><div class="literallayout"><p>//初始化Xerces DOM加载器。<br>DOMLoader loader = new XercesLoader（jaxpschema）;<br>loader.set_validating（真）;<br>
</p></div><div class="literallayout"><p>//（可选）设置标志以验证XML文档<br>// loader.set_validating（validate）;<br>//加载XML文档并存储DOM根目录<br>Document doc = loader.load（is）;<br>
</p></div><div class="literallayout"><p>//使用具有适当默认值的构建器初始化StaticContext。<br>StaticContextBuilder scb = new StaticContextBuilder（）;<br>scb.withNamespace（“xs”，“http://www.w3.org/2001/XMLSchema”）;<br>scb.withTypeModel（new XercesTypeModel（doc））;<br>
</p></div><div class="literallayout"><p>/ **<br>*将XPath 2.0表达式解析为可执行表达式，包括<br>*静态检查和验证。<br>* /<br>String xpathText =“for $ elem in // * [.xs：normalizedString的实例] return concat（local-name（$ elem），'：'，$ elem / text（））”;<br>XPath2Expression expr = new Engine（）。parseExpression（xpathText，scb）;<br>
</p></div><div class="literallayout"><p>//评估XPath 2.0表达式，存储结果<br>//在ResultSequence中<br>ResultSequence rs = expr.evaluate（new DynamicContextBuilder（scb），<br>new Object [] {doc}）;<br>
</p></div><div class="literallayout"><p>for（int i = 0; i &lt;rs.size（）; ++ i）{<br>System.out.println（“＃”+ i +“：”+ rs.value（i））;<br>}<br>
</p></div><p>XPath 2.0将所有内容定义为一系列项，包括表达式的参数和操作的结果。因此，XPath表达式求值的总体结果也是一系列项。PsychoPath使用ResultSequence类作为Collections包装器来存储这些序列，因此，评估的结果也是这种类型。ResultSequence由零个或多个项组成;项目可以是节点或简单值。“你好，世界！”是长度为1的单个值的示例。一般序列可以写成（“a”，“s”，“d”，“f”）。</p><p>下面描述了从ResultSequence类中提取某些项目的详细信息，以及可能在ResultSequence上应用的不同操作的详细信息。考虑'rs'是ResultSequence，然后：</p><p>//将返回序列中的元素数量</p><div class="literallayout"><p>//'Hello World！'的案例表达式大小= 1。<br>
</p></div><div class="literallayout"><p>rs.size（）;<br>
</p></div><div class="literallayout"><p>//将返回序列中的第n个元素，在本例中为<br>//'Hello World！'，如果n = 0，那么它将返回<br>// “你好，世界！”。<br>
</p></div><div class="literallayout"><p>rs.value（N）;<br>
</p></div><div class="literallayout"><p>//如果序列为空，则返回true。<br>rs.empty（）;<br>
</p></div><div class="literallayout"><p>//将返回序列的第一个元素，<br>//在这个例子中，它将返回xs：“Hello World！”的字符串<br>rs.firstValue（）<br>
</p></div><p>但是，提取的所有项目都是类型的“本机”值（静态称为Object），需要将其转换为实际的子类型。</p><p>某些操作总是返回特定类型，并且使用此知识，可以立即提取所提取的项目。在我们的示例“Hello World！”中返回一个字符串（很容易就知道它在引号''里面），所以这可以安全地输出：</p><div class="literallayout"><p>String string =（String）（rs.value（0））;<br>
 <br>
</p></div><p>有关如何使用示例将提取的项目从Object转换为实际子类型的详细信息，请参阅下一节“如何在语法中使用每个生产”。作为替代方案，您可以致电</p><div class="literallayout"><p>ItemType itype = rs.itemType（n）;<br>这将返回结果序列中第n项的类型。<br>
</p></div><p>
</p></div></body></html>