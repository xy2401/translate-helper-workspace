<html >
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>语言实施</title>
	<link href="book.css" rel="stylesheet" type="text/css">
	<link href="code.css" rel="stylesheet" type="text/css">
	<link rel="home" href="index.html" title="">
</head>
<body >

<h1 id="runtime-concepts">语言实施</h1>

<p>本章介绍<a href="301_grammarlanguage.html">语法语言</a>未涵盖的与平台无关的语言功能。</p>

<p>本章中的所有代码示例都以Xtend语言提供，因为它比Java更适合这些任务。有关更多详细信息，请参阅<a href="http://www.xtend-lang.org">Xtend文档</a> 。对于Java开发人员来说，它非常容易学习，因为基础知识是相似的，您只需要了解其他强大的概念。</p>

<h2 id="code-generation">代码生成</h2>

<p>一旦你掌握了语言，你可能想要用它做一些事情。有两个选项，您可以编写一个检查AST的解释器并根据它执行某些操作，或者将您的语言转换为另一种编程语言或配置文件。在本节中，我们将展示如何为基于Xtext的语言实现代码生成器。</p>

<h3 id="igenerator2">IGenerator2</h3>

<p>如果您使用您的语言的默认MWE工作流并且您没有使用Xbase，则会为您提供一个回调存根，它通过扩展<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/AbstractGenerator.java">AbstractGenerator</a>基类来实现<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/IGenerator2.java">IGenerator2</a> 。它有一个方法，只要DSL文件发生变化，就会从构建器基础结构中调用，否则应该进行翻译。传递给此方法的三个参数是：</p>

<ul>
  <li>要处理的资源</li>
  <li><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/IFileSystemAccess2.java">IFileSystemAccess2的</a>一个实例</li>
  <li><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/IGeneratorContext.java">IGeneratorContext的</a>一个实例</li>
</ul>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/IFileSystemAccess2.java">IFileSystemAccess2</a> API在代码生成器可以运行的不同文件系统上进行抽象。当在Eclipse中的增量构建基础结构内触发代码生成器时，底层文件系统是Eclipse提供的，当代码生成器在Eclipse外部执行时，比如在无头构建中，它是<code>java.io.File</code> 。</p>

<p>用于<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/Statemachine.xtext">状态机示例</a>的代码生成器的非常简单的实现可以是：</p>

<pre><code class="language-xtend">class StatemachineGenerator extends AbstractGenerator {
    
    override doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        fsa.generateFile("relative/path/AllTheStates.txt", '''
            «FOR state : resource.allContents.filter(State).toIterable»
                State «state.name»
            «ENDFOR»
        ''')
    }
    
}
</code></pre>

<h3 id="output-configurations">输出配置</h3>

<p>您不希望在代码生成器中处理平台甚至安装依赖路径，而是希望能够使用一些基本的出口根配置代码生成器，其中应放置不同的生成文件。这就是输出配置的目的。</p>

<p>默认情况下，每种语言都有一个插座，指向<code>&lt;project-root&gt;/src-gen/</code> 。这里的文件被视为完全派生，并且在生成新文件时将由编译器自动删除。如果您需要其他插座或希望使用其他默认配置，则需要实现接口<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/generator/IOutputConfigurationProvider.java">IOutputConfigurationProvider</a> 。它很容易理解，默认实现可以让您对如何实现它有一个很好的了解。</p>

<p>通过此实现，您可以使用首选项布置基本默认值，这些默认值可由工作区或项目级别的用户更改。</p>

<h2 id="validation">验证</h2>

<p>静态分析是开发编程语言时最有趣的方面之一。如果您的语言用户在输入时获得了丰富的反馈，他们将不胜感激。在Xtext中，基本上有三种不同的验证。</p>

<h3 id="automatic-validation">自动验证</h3>

<p>语言的某些实现方面（例如语法，范围）会对文档或语义模型有效所需的内容产生影响。Xtext会自动处理这个问题。</p>

<h4 id="syntactical-validation">Lexer / Parser：语法验证</h4>

<p>解析器自动验证任何文本输入的语法正确性。错误消息由底层解析器技术生成。可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java">ISyntaxErrorMessageProvider</a> API来自定义这些消息。可以使用公共EMF API从资源中检索任何语法错误： <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java"><code>Resource.getErrors()</code></a>和<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java"><code>Resource.getWarnings()</code></a></p>

<h4 id="linking-validation">链接器：交叉引用验证</h4>

<p>可以一般性地检查任何损坏的交叉引用。由于交叉引用解析是懒惰地完成的（参见<a href="#linking">链接</a> ），任何损坏的链接也会被懒惰地解析。如果要验证所有链接是否有效，则必须浏览模型，以便解析所有已安装的EMF代理。这在编辑器中自动完成。</p>

<p>与语法错误类似，将报告任何不可解析的交叉链接，并且可以通过<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java"><code>Resource.getErrors()</code></a>和<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java"><code>Resource.getWarnings()</code></a></p>

<h4 id="concrete-syntax-validation">Serializer：具体语法验证</h4>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java">IConcreteSyntaxValidator</a>验证语法隐含的所有约束。对于要序列化的模型，必须满足这些约束。</p>

<p>例：</p>

<pre><code class="language-xtext">MyRule:
    ({MySubRule} "sub")? (strVal+=ID intVal+=INT)*;
</code></pre>

<p>这意味着几个限制：</p>

<ol>
  <li>类型：此规则仅允许<em>MyRule</em>和<em>MySubRule的</em>实例。禁止使用子类型，因为解析器从不实例化未知的子类型。</li>
  <li>特点：万一<em>MyRule的</em>和<em>MySubRule</em>有<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EStructuralFeature.java">EStructuralFeatures</a>除了<em>strVal</em>和<em>INTVAL，</em>只有<em>strVal</em>和<em>INTVAL</em>可能有<a href="#transient-values">非瞬态值</a> 。</li>
  <li>数量：必须满足以下条件： <code>strVal.size() == intVal.size()</code> 。</li>
  <li>值：必须可以<a href="#value-converter">将所有值转换</a>为使用的终端规则<em>ID</em>和<em>INT的</em>有效令牌。</li>
</ol>

<p>具体语法验证器的典型用例是在使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource的</a>非Xtext编辑器中进行<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">验证</a> 。例如，在组合GMF和Xtext时就是这种情况。另一个用例是当“手动”（不是由解析器）修改语义模型然后再次序列化时。由于序列化程序很难提供有意义的错误消息，因此在序列化之前默认执行具体的语法验证器。文本Xtext编辑器本身<em>不是</em>有效的用例。这里，解析器确保满足所有语法约束。因此，额外运行具体语法验证器没有任何价值。</p>

<p>具体的语法验证器有一些限制，因为它将语法视为声明，这是解析器并不总是这样做的。</p>

<ul>
  <li>包含已分配操作的语法规则（例如<code>{MyType.myFeature=current}</code> ）被忽略。未分配的行动（例如<code>{MyType}</code> ）。</li>
  <li>通过未分配的规则调用委托给包含已分配操作的一个或多个规则的语法规则将被忽略。</li>
  <li>列表功能中的订单无法验证。例如<code>Rule: (foo+=R1 foo+=R2)*</code>意味着<em>foo</em>应该以交替的顺序包含<em>R1</em>和<em>R2的</em>实例。</li>
</ul>

<p>要使用具体的语法验证，您可以让Guice注入一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java">IConcreteSyntaxValidator</a>实例并直接使用它。此外，还有一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxEValidator.java">适配器</a>允许使用具体的语法验证器作为<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EValidator.java">EValidator</a> 。例如，您可以通过添加以下内容在运行时模块中启用它：</p>

<pre><code class="language-xtend">@SingletonBinding(eager = true)
def Class&lt;? extends ConcreteSyntaxEValidator&gt; bindConcreteSyntaxEValidator() {
    return ConcreteSyntaxEValidator
}
</code></pre>

<p>要自定义错误消息，请参阅<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxDiagnosticProvider.java">IConcreteSyntaxDiagnosticProvider</a>和子类<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxDiagnosticProvider.java">ConcreteSyntaxDiagnosticProvider</a> 。</p>

<h3 id="custom-validation">自定义验证</h3>

<p>除了上述类型的验证（或多或少自动完成）之外，您还可以指定特定于Ecore模型的其他约束。Xtext语言生成器将为您提供两个Java类。第一个是为<em>src-gen /</em>生成的抽象类，它扩展了库类<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java">AbstractDeclarativeValidator</a> 。这个只是注册该验证器引入约束的EPackages。另一个类是该抽象类的子类，并生成到<em>src /</em>文件夹以供您编辑。这就是你把约束放进去的地方。</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java">AbstractDeclarativeValidator</a>的目的是允许您以声明方式编写约束 - 正如类名已经建议的那样。这不是编写详尽的if-else结构或扩展生成的EMF开关，只需将<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/Check.java">Check</a> annotation添加到任何方法，它将在验证发生时自动调用。此外，您可以通过声明类型化参数来说明相应约束方法的类型。这也可以避免任何类型转换。除了验证方法的反射调用之外，AbstractDeclarativeValidator还提供了一些方便的断言。</p>

<p>Check annotation有一个参数，可用于声明何时应运行检查： <em>FAST</em>将在文件被修改时运行， <em>NORMAL</em>检查将在保存文件时运行，并且当通过菜单选项显式验证文件时将运行<em>EXPENSIVE</em>检查。</p>

<p>总而言之，这与JUnit的工作方式非常相似。这是一个用Xtend编写的例子：</p>

<pre><code class="language-xtend">class DomainmodelValidator extends AbstractDomainmodelValidator {
    
    @Check
    def void checkNameStartsWithCapital(Entity entity) {
        if (!Character.isUpperCase(entity.name.charAt(0))) {
            warning("Name should start with a capital", 
                DomainmodelPackage.Literals.TYPE__NAME)
        }
    }
}
</code></pre>

<p>您可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/IResourceValidator.java">IResourceValidator</a>以编程方式验证给定资源。例：</p>

<pre><code class="language-xtend">@Inject IResourceValidator resourceValidator

def void checkResource(Resource resource) {
    val issues = resourceValidator.validate(resource,
            CheckMode.ALL, CancelIndicator.NullImpl)
    for (issue: issues) {
        switch issue.severity {
            case ERROR:
                println("ERROR: " + issue.message)
            case WARNING:
                println("WARNING: " + issue.message)
        }
    }
}
</code></pre>

<p>您还可以针对个别验证错误和警告实施快速修复。有关详细信息，请参阅<a href="310_eclipse_support.html#quick-fixes">快速修复部分</a> 。</p>

<h2 id="linking">链接</h2>

<p>链接功能允许在Xtext语法中指定交叉引用。链接需要以下内容：</p>

<ol>
  <li>声明中的<a href="301_grammarlanguage.html#cross-references">交叉引用</a>声明（或至少在Ecore模型中）</li>
  <li>链接语义的规范（通常通过<a href="#scoping">作用域API提供</a> ）</li>
</ol>

<h3 id="lazy-linking">懒惰链接</h3>

<p>Xtext默认使用延迟链接，我们鼓励用户坚持这一点，因为它提供了许多优点，其中一个优点是在不必加载所有可传递引用的资源的所有场景中都提高了性能。此外，它自动解决了一个链接依赖于其他链接的情况（不支持循环链接依赖关系）。</p>

<p>解析给定的输入字符串时，请说</p>

<p><code>ref Entity01</code></p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/lazy/LazyLinker.java">LazyLinker</a>首先创建一个EMF代理并将其分配给相应的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java">EReference</a> 。在EMF中，代理由<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a>描述， <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a>指向真实的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a> 。在延迟链接的情况下，存储的URI包括在分析时给出的上下文信息，即包含交叉引用的EObject，实际的EReference，列表索引（如果它是多值交叉引用）和string表示具体语法中的交叉链接。后者通常对应于引用的EObject的名称。在EMF中，URI包含有关包含EObject的资源的信息以及所谓的片段部分，该部分用于在该资源中查找EObject。解析EMF代理时，会询问当前的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/ResourceSet.java">ResourceSet</a> 。资源集使用第一部分来获取（即，如果尚未加载则加载）资源。然后，要求资源根据URI中的片段返回EObject。实际的交叉引用解析由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/lazy/LazyLinkingResource.java">LazyLinkingResource.getEObject（String）</a>完成，它接收片段并委托给<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/ILinkingService.java">ILinkingService</a>的实现。默认实现依次委托给<a href="#scoping">作用域API</a> 。</p>

<p>链接服务的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/impl/DefaultLinkingService.java">简单实现</a>随Xtext一起提供，并用作默认语法。通常，使用<a href="#scoping">作用域API</a>可以最好地描述链接行为的任何必要的自定义。</p>

<h2 id="scoping">作用域</h2>

<p>使用作用域API，可以定义哪个元素可以通过给定的引用引用。例如，使用实体示例，功能包含对类型的交叉引用：</p>

<pre><code class="language-domainexample">datatype String

entity HasAuthor {
    author: String
}
</code></pre>

<p>功能的语法规则如下所示：</p>

<pre><code class="language-xtext">Feature:
    (many?='many')? name=ID ':' type=[Type];
</code></pre>

<p>语法声明对于引用<em>类型，</em>只允许类型为<em>Type的</em>实例。但是，这个简单的声明并没有说明在哪里找到类型。这是范围的责任。</p>

<p>一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>负责提供<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java">的iScope</a>给定上下文<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a>和<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java">的EReference</a> 。返回的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java">IScope</a>应包含给定对象和交叉引用的所有目标候选者。</p>

<pre><code class="language-java">public interface IScopeProvider {

    /**
     * Returns a scope for the given context. The scope
     * provides access to the compatible visible EObjects
     * for a given reference.
     *
     * @param context the element from which an element shall be
     *        referenced
     * @param reference the reference to be used to filter the
     *        elements.
     * @return {@link IScope} representing the inner most
     *         {@link IScope} for the passed context and reference.
     *         Note for implementors: The result may not be
     *         &lt;code&gt;null&lt;/code&gt;. Return
     *         &lt;code&gt;IScope.NULLSCOPE&lt;/code&gt; instead.
     */
    IScope getScope(EObject context, EReference reference);

}
</code></pre>

<p>单个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java">IScope</a>表示范围链接列表的元素。这意味着范围可以嵌套在外部范围内。每个范围的工作方式类似于符号表或映射，其中键是字符串，值是所谓的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription</a> ，它实际上是真实EObject的抽象描述。为了为模型元素创建IEObjectDescriptions，类<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/Scopes.java">Scopes</a>非常有用。</p>

<p>举一个具体的例子，让我们来处理以下简单的语法。</p>

<pre><code class="language-xtext">grammar org.xtext.example.mydsl.MyScopingDsl with
                                      org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyScopingDsl"

Root:
    elements+=Element;

Element:
    'element' name=ID ('extends' superElement=[Element])?;

</code></pre>

<p>如果要定义<em>superElement</em>交叉引用的范围，则以下Xtend代码是一种方法。</p>

<pre><code class="language-xtend">override getScope(EObject context, EReference reference) {
    // We want to define the Scope for the Element's superElement cross-reference
    if (context instanceof Element
            &amp;&amp; reference == MyDslPackage.Literals.ELEMENT__SUPER_ELEMENT) {
        // Collect a list of candidates by going through the model
        // EcoreUtil2 provides useful functionality to do that
        // For example searching for all elements within the root Object's tree
        val rootElement = EcoreUtil2.getRootContainer(context)
        val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Element)
        // Create IEObjectDescriptions and puts them into an IScope instance
        return Scopes.scopeFor(candidates)
    }
    return super.getScope(context, reference);
}
</code></pre>

<p>Xtext附带的IScope有不同的有用实现。我们想在这里只提一些。</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/MapBasedScope.java">MapBasedScope</a>具有查找某个名称的地图效率。如果您更喜欢处理Multimaps， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/MultimapBasedScope.java">MultimapBasedScope</a>应该适合您。对于某些元素应从现有范围中过滤掉的情况， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/FilteringScope.java">FilteringScope</a>是正确的方法。由于作用域可以嵌套，我们强烈建议仅将FilteringScope用于没有嵌套作用域的叶作用域。</p>

<p>回到我们的例子，FilteringScope的一个可能的场景可能是从候选列表中排除context元素，因为它不应该是它自身的超级元素。</p>

<pre><code class="language-xtend">override getScope(EObject context, EReference reference) {
    if (context instanceof Element
            &amp;&amp; reference == MyDslPackage.Literals.ELEMENT__SUPER_ELEMENT) {
        val rootElement = EcoreUtil2.getRootContainer(context)
        val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Element)
        val existingScope = Scopes.scopeFor(candidates)
        // Scope that filters out the context element from the candidates list
        return new FilteringScope(existingScope, [getEObjectOrProxy != context])
    }
    return super.getScope(context, reference);
}
</code></pre>

<h3 id="global-scopes">全球范围和资源描述</h3>

<p>在上面的简单范围示例中，我们没有跨模型文件的引用。也没有像命名空间这样的概念会使范围更复杂一些。基本上，在同一资源中声明的每个<em>元素</em>的名称都是可见的。但是，在现实世界中，事情很可能并不那么简单：如果您想在不同文件中重用某些声明的元素并且想要在不同用户之间共享这些元素，该怎么办？您可能希望引入某种跨资源引用。</p>

<p>定义从当前资源外部可见的内容是全局范围的责任。顾名思义，全局范围由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java">IGlobalScopeProvider</a>的实例提供。用于存储其元素的数据结构（称为索引）将在下一节中介绍。</p>

<h4 id="resource-descriptions">资源和EObject描述</h4>

<p>为了使一个文件的元素可以从另一个文件中引用，您需要将它们作为所谓的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription的</a>一部分导出。</p>

<p>一个IResourceDescription包含有关资源本身的信息，这主要是其<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a> ，出口清单<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObjects</a>的形式<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription</a> S，以及关于传出交叉引用和它引用合格的名称信息。交叉引用仅包含已解析的引用，而导入的限定名称列表也包含无法解析的名称。Xtext的索引基础结构利用此信息来计算依赖资源的传递性外壳。</p>

<p>对于用户，尤其是在作用域的上下文中，最重要的信息是导出的EObject列表。IEObjectDescription存储实际EObject的URI，其<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/QualifiedName.java">QualifiedName</a>以及其<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java">EClass</a> 。此外，可以使用<em>用户数据</em>映射导出任意信息。下图概述了描述类及其关系。</p>

<p><img src="images/index_datamodel.png" alt="Xtext索引的数据模型"></p>

<p>使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription的默认实现配置语言<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">。Manager</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/DefaultResourceDescriptionStrategy.java">DefaultResourceDescriptionStrategy</a> ，负责计算导出的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescriptions</a>列表。Manager针对每个<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java">资源</a>迭代整个EMF模型，并要求ResourceDescriptionStrategy为每个EObject计算IEObjectDescription。ResourceDescriptionStrategy在对象上应用来自<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">IQualifiedNameProvider</a>的<code>getQualifiedName(EObject obj)</code> ，如果它具有限定名称，则创建IEObjectDescription并将其传递回Manager，后者将其添加到导出对象列表中。如果EObject没有限定名称，则认为该元素不能从资源外部引用，因此不会编入索引。如果您不喜欢此行为，则可以实现并绑定自己的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IDefaultResourceDescriptionStrategy.java">IDefaultResourceDescriptionStrategy</a>实现。</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">IQualifiedNameProvider</a>有两种不同的默认实现。两者都通过查找<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java">EAttribute</a> ' <em>名称</em> '来工作。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/SimpleNameProvider.java">SimpleNameProvider</a>只返回普通值，而<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.java">DefaultDeclarativeQualifiedNameProvider</a>将简单名称与其父导出的EObject的限定名称连接起来。这有效地模拟了大多数基于命名空间的语言（如Java）的限定名称计算。它还允许以声明方式覆盖名称计算：只需在子类中添加名为<code>qualifiedName</code>方法，并为每个方法赋予一个参数，其中包含您希望为其计算名称的元素类型。</p>

<p>如前所述，默认实现策略导出IQualifiedNameProvider可以为其提供名称的每个模型元素。这是一个很好的起点，但是当你的模型变得更大并且你有很多它们时，索引会变得越来越大。在大多数情况下，只有一小部分模型应该从外部可见，因此只需要在索引中有一小部分。为此，请绑定<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IDefaultResourceDescriptionStrategy.java">IDefaultResourceDescriptionStrategy</a>的自定义实现，并仅为要从其所包含的资源外部引用的元素创建索引表示。在资源中，只要具有名称，对这些过滤元素的引用仍然是可能的。</p>

<p>除了导出的元素之外，索引还包含<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IReferenceDescription.java">IReferenceDescription</a> ，其中包含引用who的信息。它们是通过IResourceDescription创建的。经理和IDefaultResourceDescriptionStrategy也是如此。如果存在引用另一个模型元素的模型元素，则IDefaultResourceDescriptionStrategy将创建一个IReferenceDescription，其中包含引用元素（ <em>sourceEObjectURI</em> ）和引用元素（ <em>targetEObjectURI</em> ）的URI。这些IReferenceDescriptions对于查找引用和计算受影响的资源非常有用。</p>

<p>如上所述，为了计算资源的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription</a> ，框架会询问<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription。管理</a>委托给IDefaultResourceDescriptionStrategy。要在<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/QualifiedName.java">QualifiedName</a>及其String表示形式之间进行转换，可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameConverter.java">IQualifiedNameConverter</a> 。这是一些Xtend代码，展示了如何做到这一点：</p>

<pre><code class="language-xtend">@Inject IResourceServiceProvider.Registry rspr
@Inject IQualifiedNameConverter converter

def void printExportedObjects(Resource resource) {
    val resServiceProvider = rspr.getResourceServiceProvider(resource.URI)
    val manager = resServiceProvider.getResourceDescriptionManager()
    val description = manager.getResourceDescription(resource)
    for (eod : description.exportedObjects) {
        println(converter.toString(eod.qualifiedName))
    }
}
</code></pre>

<p>为了获得<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">管理器</a> ，最好询问相应的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java">IResourceServiceProvider，</a>如上所示。这是因为每种语言可能具有完全不同的实现，并且您可能会从一种语言引用另一种语言，因此您无法重用第一语言的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">管理器</a> 。</p>

<p>现在我们知道如何从其他资源导出元素，我们需要了解如何将这些导出的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescriptions</a>提供给引用资源。这是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java">全局范围</a>的责任，将在下一节中介绍。</p>

<p>如果您想查看索引中的内容，可以使用导航菜单条目中的“打开模型元素”对话框。</p>

<h4 id="index-based">基于外部配置的全局范围</h4>

<p>除了明确引用导入的资源之外，另一种选择是使用某种外部配置来定义从资源外部可见的内容。例如，Java使用类路径的概念来定义包含可引用元素的容器（jar和类文件夹）。在Java的情况下，这些条目的顺序也很重要。</p>

<p>要在Xtext中启用对此类全局范围的支持，必须将<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/DefaultGlobalScopeProvider.java">DefaultGlobalScopeProvider</a>绑定到<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java">IGlobalScopeProvider</a>接口。默认情况下，Xtext利用类路径机制，因为它设计得很好，并且已被大多数用户理解。JDT和PDE提供的用于配置类路径的可用工具增加了更多价值。但是，这只是一个默认设置：您可以在不使用Java的情况下重用基础结构，并且可以独立于JDT。</p>

<p>为了了解“世界”中可用的内容，依赖于外部配置的全局范围提供者需要读取该配置并能够找到某个<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java">EReference的</a>所有候选<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EReference.java">者</a> 。如果您不想强制用户拥有反映可引用<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a>的实际限定名称的文件夹和文件名结构，则必须<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">预先</a>加载所有资源并将其保留在内存中或记住所有信息。解决交叉引用所需的。在Xtext中，信息由所谓的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription提供</a> 。</p>

<h5 id="containers">关于索引，容器及其经理</h5>

<p>Xtext附带一个索引，该索引记住所有<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription</a>及其<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescription</a>对象。在IDE上下文中（即运行编辑器等时），索引由增量项目构建器更新。与此相反，在非UI环境中，您通常不必处理更改，因此基础结构可以更简单。在这两种情况下，全局索引状态由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescriptions.java">IResourceDescriptions</a>的实现保存（请注意复数形式！）。UI场景中的绑定单例甚至可以识别未保存的编辑器更改，这样所有链接都会发生在最新的可能未保存的资源版本中。您将在<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui.shared/src/org/eclipse/xtext/ui/shared/internal/SharedModule.java">SharedModule</a>的UI场景中找到全局索引的Guice配置。</p>

<p>该索引基本上是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription</a>实例的平面列表。由于类路径限制，索引本身不知道可见性约束。而不是那样，它们由引用语言通过所谓的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">IContainers定义</a> ：虽然Java可能通过<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">ClassLoader.loadResource（）</a>加载资源（即使用类路径机制），但另一种语言可以使用文件系统加载相同的资源路径。</p>

<p>因此，资源所属容器的信息取决于引用上下文。因此， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java">IResourceServiceProvider</a>提供了另一个有趣的服务，称为<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">IContainer。经理</a>对于给定的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescription</a> ，Manager会为您提供<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">IContainer</a>以及从那里可见的所有IContainer的列表。请注意， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescriptions.java">索引</a>是在所有语言之间全局共享的，而添加容器语义的Manager可能会因语言而异。下面的方法列出了从给定可见的所有资源<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java">的资源</a> ：</p>

<pre><code class="language-xtend">@Inject IContainer.Manager manager
 
def void printVisibleResources(Resource resource, IResourceDescriptions index) {
    val descr = index.getResourceDescription(resource.URI)
    for (visibleContainer : manager.getVisibleContainers(descr, index)) {
        for (visibleResourceDesc : visibleContainer.resourceDescriptions) {
            println(visibleResourceDesc.URI)
        }
    }
}
</code></pre>

<p>Xtext提供了两个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">IContainer实现<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">。与Guice绑定的Manager</a> ：默认绑定是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/SimpleResourceDescriptionsBasedContainerManager.java">SimpleResourceDescriptionsBasedContainerManager</a> ，它假定所有<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java">IResourceDescriptions</a>都在一个公共容器中。如果你不关心容器支持，你可以使用这个。或者，您可以绑定<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/StateBasedContainerManager.java">StateBasedContainerManager</a>和另一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/IAllContainersState.java">IAllContainersState</a> ，它跟踪可用容器集及其可见性关系。</p>

<p>Xtext提供了一些管理容器的策略：如果您正在运行Eclipse工作台，则可以基于Java项目及其类路径或基于纯Eclipse项目来定义容器。在Eclipse之外，您可以提供一组要扫描模型的文件系统路径。所有这些仅在引用语言的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/IAllContainersState.java">IAllContainersState</a>的绑定实例中不同。这些将在以下部分中详细描述。</p>

<p><img src="images/index_container.png" alt="IContainer管理"></p>

<h5 id="jdt-based-containers">基于JDT的容器管理器</h5>

<p>由于JDT是Eclipse功能，因此这种基于JDT的容器管理仅在UI方案中可用。它假设所谓的<a href="http://help.eclipse.org/luna/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/IPackageFragmentRoot.html">IPackageFragmentRoots</a>为容器。JDT中的IPackageFragmentRoot是Java模型元素树的根。它通常指的是</p>

<ul>
  <li>Java项目的源文件夹，</li>
  <li>引用的jar，</li>
  <li>引用的Java项目的类路径条目，或</li>
  <li>导出的所需PDE插件包。</li>
</ul>

<p>因此，对于要引用的元素，其资源必须位于调用者Java项目的类路径上，并且必须将其导出（如上所述）。</p>

<p>由于这个策略允许重用许多不错的Java东西，如jar，OSGi，maven等，它是默认的一部分：你不必重新配置任何东西以使其工作。然而，如果你搞砸了什么，请确保你绑定</p>

<pre><code class="language-xtend">def Class&lt;? extends IContainer.Manager&gt; bindIContainer$Manager() {
    return StateBasedContainerManager
}
</code></pre>

<p>在运行时模块和</p>

<pre><code class="language-xtend">def Provider&lt;IAllContainersState&gt; provideIAllContainersState() {
    return org.eclipse.xtext.ui.shared.Access.getJavaProjectsState()
}
</code></pre>

<p>在引用语言的Eclipse UI模块中。后者看起来比普通绑定更困难，因为我们必须将全局单例绑定到Guice提供者。<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/containers/StrictJavaProjectsState.java">StrictJavaProjectsState</a>要求所有元素都在类路径上，而默认的<a href="https://github.com/eclipse/xtext-eclipse/blob/master/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/containers/JavaProjectsState.java">JavaProjectsState</a>也允许非源文件夹中的模型。</p>

<h5 id="project-based-containers">基于Eclipse项目的容器</h5>

<p>如果基于类路径的机制不适用于您的情况，则Xtext提供基于普通Eclipse项目的备用容器管理器：每个项目充当容器，项目引用（ <em>属性→项目引用</em> ）是可见容器。</p>

<p>在这种情况下，运行时模块应该使用如上所示的StateBasedContainerManager，Eclipse UI模块应该绑定</p>

<pre><code class="language-xtend">def Provider&lt;IAllContainersState&gt; provideIAllContainersState() {
    return org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState()
}
</code></pre>

<h5 id="resource-set-containers">基于资源集的容器</h5>

<p>如果你需要<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java">IContainer。管理器</a>独立于Eclipse项目，可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/ResourceSetBasedAllContainersState.java">ResourceSetBasedAllContainersState</a> 。这个可以配置容器句柄到资源URI的映射。</p>

<h3 id="local-scoping">本地范围</h3>

<p>我们现在知道如何在Xtext中定义可引用元素的外部世界。尽管如此，并非所有环境都具备全球名称。而不是那样，每个上下文通常可以具有不同的范围。如前所述，范围可以嵌套，即范围可以包含父范围的元素以及它自己的元素。当父和子范围包含具有相同名称的不同元素时，父范围的元素通常将<em>被子</em>范围中的元素<em>遮蔽</em> 。</p>

<p>为了说明这一点，让我们来看看Java：Java定义了多种范围（对象范围，类型范围等）。对于Java，可以创建范围层次结构，如以下示例中所述：</p>

<pre><code class="language-java">// file contents scope
import static my.Constants.STATIC;

public class ScopeExample { // class body scope
  private Object field = STATIC;

  private void method(String param) { // method body scope
    String localVar = "bar";
    innerBlock: { // block scope
      String innerScopeVar = "foo";
      Object field = innerScopeVar;
      // the scope hierarchy at this point would look like this:
      //  blockScope{field,innerScopeVar}-&gt;
      //  methodScope{localVar, param}-&gt;
      //  classScope{field}-&gt; ('field' is shadowed)
      //  fileScope{STATIC}-&gt;
      //  classpathScope{
      //      'all qualified names of accessible static fields'} -&gt;
      //  NULLSCOPE{}
      //
    }
    field.add(localVar);
  }
}
</code></pre>

<p>实际上，类路径范围也应该反映类路径条目的顺序。例如：</p>

<pre><code class="language-java">classpathScope{stuff from bin/}
-&gt; classpathScope{stuff from foo.jar/}
-&gt; ...
-&gt; classpathScope{stuff from JRE System Library}
-&gt; NULLSCOPE{}
</code></pre>

<p>请在<a href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html">此博客文章中</a>找到此背后的动机和一些其他详细信息。</p>

<h3 id="namespace-imports">导入的命名空间感知范围</h3>

<p>导入的名称空间感知范围基于限定名称和名称空间。它为您的语言添加了命名空间支持，这与Scala和C＃中的命名空间相似。Scala和C＃都允许在一个文件中包含多个嵌套包，并且您可以为每个命名空间放置导入，这样导入的名称只能在该命名空间中可见。请参阅域模型示例：其作用域提供程序扩展了<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java">ImportedNamespaceAwareLocalScopeProvider</a> 。</p>

<h4 id="importing-namespaces">导入命名空间</h4>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java">ImportedNamespaceAwareLocalScopeProvider</a>使用名称<em>importedNamespace</em>查找<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EAttribute.java">EAttributes</a>并将它们解释为import语句。</p>

<pre><code class="language-xtext">PackageDeclaration:
    'package' name=QualifiedName '{'
        (elements+=AbstractElement)*
    '}';

AbstractElement:
    PackageDeclaration | Type | Import;

QualifiedName:
    ID ('.' ID)*;

Import:
    'import' importedNamespace=QualifiedNameWithWildcard;
  
QualifiedNameWithWildcard:
    QualifiedName '.*'?;
</code></pre>

<p>支持末尾带或不带通配符的限定名称。对于导入限定名称，可以使用简单名称，例如Java，其中<code>import java.util.Set</code>可以引用<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html">java.util。设置</a>被其简单的名称<em>设置</em> 。与Java相反，导入对于整个文件不是活动的，而是仅针对其声明的命名空间及其子命名空间。这就是为什么你可以在示例DSL中编写以下内容：</p>

<pre><code class="language-domainexample">package foo {
    import bar.Foo
    entity Bar extends Foo {
    }
}

package bar {
    entity Foo {}
}
</code></pre>

<p>当然，包中声明的元素也可以通过简单的名称引用：</p>

<pre><code class="language-domainexample">package bar {
    entity Bar extends Foo {}
    entity Foo {}
}
</code></pre>

<h2 id="value-converter">价值转换器</h2>

<p>注册值转换器以将解析的文本转换为数据类型实例，反之亦然。主挂钩是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverterService.java">IValueConverterService</a> ，具体实现可以通过运行时<a href="302_configuration.html#guicemodules">Guice模块</a>注册。只需覆盖运行时模块中的相应绑定，如下例所示：</p>

<pre><code class="language-xtend">override Class&lt;? extends IValueConverterService&gt; bindIValueConverterService() {
    return MySpecialValueConverterService
}
</code></pre>

<p>注册附加值转换器的最简单方法是使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractDeclarativeValueConverterService.java">AbstractDeclarativeValueConverterService</a> ，它允许通过带注释的方法声明性地注册<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java">IValueConverter</a> 。</p>

<pre><code class="language-xtend">@ValueConverter(rule = "MyRuleName")
def IValueConverter&lt;MyDataType&gt; getMyRuleNameConverter() {
    return new MyValueConverterImplementation()
}
</code></pre>

<p>如果使用公共终端语法<code>org.eclipse.xtext.common.Terminals</code>应扩展<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/common/services/DefaultTerminalConverters.java">DefaultTerminalConverters</a>并通过添加相应的方法来覆盖或添加值转换器。除了默认实现中明确定义的转换器之外，还为每个可用的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EDataType.java">EDataType</a>注册了委派转换器。委托转换器重用相应的EMF <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EFactory.java">EFactory</a>的功能。</p>

<p>许多语言引入了限定名称的概念，即由分隔符分隔的名称空间组成的名称。由于这是一个常见的用例，Xtext为限定名称提供了可扩展的转换器实现。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/QualifiedNameValueConverter.java">QualifiedNameValueConverter</a>可以优雅地处理注释和空格，并且能够为限定名称的每个段使用适当的值转换器。这允许单独引用的段。domainmodel示例显示了如何使用它。</p>

<p>如果出现问题， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java">IValueConverter</a>的协议允许抛出<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/ValueConverterException.java">ValueConverterException</a> 。如果该值无法转换为有效字符串，则异常将被解析器传播为语法错误，或者由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxValidator.java">ConcreteSyntaxValidator</a>传播为验证问题。在实现自定义值转换器时， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractLexerBasedConverter.java">AbstractLexerBasedConverter</a>非常有用。如果转换器需要知道它当前使用的规则，它可以实现接口<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java">RuleSpecific</a> 。框架将设置规则，以便实现可以在之后使用它。</p>

<h2 id="serialization">序列化</h2>

<p>序列化是将EMF模型转换为其文本表示的过程。因此，序列化补充了解析和lexing。</p>

<p>在Xtext中，序列化过程分为以下几个步骤：</p>

<ol>
  <li>验证语义模型。这是可选的，默认情况下启用，由<a href="#concrete-syntax-validation">具体语法验证程序完成</a> ，可以在<a href="#save-options">保存选项中</a>关闭。</li>
  <li>将模型元素与语法规则匹配并创建标记流。这是由<a href="#parse-tree-constructor">解析树构造函数完成的</a> 。</li>
  <li>将注释与语义对象相关联。这是由<a href="#comment-associater">注释关联</a>器完成的。</li>
  <li>将节点模型中的现有节点与令牌流中的标记相关联。</li>
  <li><a href="#hidden-token-merger">将现有空白</a>行和换行符<a href="#hidden-token-merger">合并</a>到令牌流中。</li>
  <li>使用<a href="#formatting">格式化程序</a>添加更多所需的空白区域或替换所有空白区域。</li>
</ol>

<p>调用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource.save（..）</a>时会调用序列化。此外， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java">Serializer</a>还提供与资源无关的序列化支持。触发序列化的另一种情况是应用具有语义修改的<a href="310_eclipse_support.html#quick-fixes">快速修复</a> 。将文本编辑器内容保存到磁盘时， <em>不会</em>调用序列化。</p>

<h3 id="serialization-contract">合约</h3>

<p>序列化合同表示将一个模型保存（序列化）到其文本表示然后再加载（解析），产生一个等于原始模型的新模型。请注意，这<em>并不</em>意味着加载文本表示和序列化回产生相同的文本表示。但是，序列化算法尝试尽可能多地恢复信息。也就是说，如果解析的模型未在内存中修改，则序列化输出通常将等于先前的输入。不幸的是，对于每一个案例都无法确保这一点。以下示例中显示了几乎不可能的用例：</p>

<pre><code class="language-xtext">MyRule:
  (xval+=ID | yval+=INT)*;
</code></pre>

<p>给定的<em>MyRule</em>读取<em>ID</em> - 和<em>INT  -</em>元素，它们可能在文本表示中以任意顺序出现。但是，在序列化模型时，将首先写入所有<em>ID</em>元素，然后写入所有<em>INT</em>元素。如果顺序很重要，可以通过将所有元素存储在同一列表中来保存 - 这可能需要将<em>ID</em>包装 - 和<em>INT</em> -elements存储到其他对象中。</p>

<h3 id="roles-of-the-semantic-model-and-the-node-model-during-serialization">序列化过程中语义模型和节点模型的作用</h3>

<p>序列化文档表示语义模型的状态。但是，如果有可用的节点模型（即语义模型已由解析器创建），则为序列化程序</p>

<ul>
  <li>从节点模型中保留<a href="#hidden-token-merger">现有的空格</a> 。</li>
  <li>保留节点模型中的<a href="#comment-associater">现有注释</a> 。</li>
  <li>保留交叉引用的表示：如果可以通过多个名称标识交叉引用的对象（即，作用域返回同一对象的多个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java">IEObjectDescriptions</a> ），则序列化程序会尝试保留输入文件中使用的名称。</li>
  <li>保留值的表示形式：对于值<a href="#value-converter">转换器</a>处理的<a href="#value-converter">值</a> ，序列化程序检查转换为值的文本表示是否等于语义模型中的值。如果是这样，则保留文本表示。</li>
</ul>

<h3 id="parse-tree-constructor">解析树构造函数</h3>

<p>解析树构造函数通常不需要自定义，因为它是从<a href="301_grammarlanguage.html">Xtext语法</a>自动派生的。但是，查看它以了解其错误消息及其运行时性能会很有帮助。</p>

<p>为了使序列化成功，解析树构造函数必须能够<em>使用</em>待序列化EMF模型的每个非瞬态元素。在此上下文中， <em>消耗</em>意味着将元素写入模型的文本表示。这可能会变成一个不那么容易实现的要求，因为语法通常会引入EMF模型的隐式约束，如<a href="#concrete-syntax-validation">具体语法验证器所述</a> 。</p>

<p>如果无法序列化模型，则抛出<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/XtextSerializationException.java">XtextSerializationException</a> 。可能的原因如下：</p>

<ul>
  <li>无法使用模型元素。这可能有以下原因/解决方案：<ul>
      <li>模型元素不应存储在模型中。</li>
      <li>语法需要一个消耗模型元素的赋值。</li>
      <li><a href="#transient-values">瞬态值服务</a>可用于指示不应使用此模型元素。</li>
    </ul>
  </li>
  <li>语法中的赋值没有相应的模型元素。如果模型元素未<em>设置</em>或<em>等于</em>其默认值，则默认瞬态值服务会将模型元素视为瞬态元素。但是，如果语法约束需要能够序列化另一个模型元素，则解析树构造函数可以序列化默认值。以下解决方案可能有助于解决此类情况：<ul>
      <li>应该将模型元素添加到模型中。</li>
      <li>语法中的赋值应该是可选的。</li>
    </ul>
  </li>
  <li>模型元素的类型与语法中的类型不同。模型元素的类型必须与语法规则的返回类型或操作的类型相同。不允许使用子类型。</li>
  <li><a href="#value-converter">值转换</a>失败。值转换器可以通过抛出<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/conversion/ValueConverterException.java">ValueConverterException</a>来指示值不可序列化。</li>
  <li>此位置不允许使用枚举字面值。如果引用的枚举规则仅列出实际枚举的文字的子集，则会发生这种情况。</li>
</ul>

<p>要理解解析树构造函数的错误消息和性能问题，重要的是要知道它实现了回溯算法。这基本上意味着语法用于指定树的结构，其中一个路径（从根节点到叶节点）是特定模型的有效序列化。解析树构造函数的任务是找到此路径 - 条件是在遍历此路径时消耗所有模型元素。解析树构造函数的策略是首先采用最有希望的分支（消耗最多模型元素的分支）。如果分支导致死角（例如，如果需要消耗模型中不存在的模型元素），则解析树构造函数返回路径，直到可以采用不同的分支。这种行为有两个后果：</p>

<ul>
  <li>如果出现错误，解析树构造函数只找到死角但没有叶子。它无法分辨哪个死胡同实际上是错误的。因此，错误消息列出了最长路径的死角，序列化的片段以及此时路径无法继续的原因。开发者必须自己判断哪个原因是实际错误。</li>
  <li>出于性能原因，解析树构造函数首先采用最有希望的分支并尽早检测到错误的分支是至关重要的。实现此目的的一种方法是避免使用许多返回相同类型的规则，并且这些规则在语法中的同一备选内容中调用。</li>
</ul>

<h3 id="save-options">选项</h3>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/SaveOptions.java">SaveOptions</a>可以传递给<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource.save（options）</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java">Serializer.serialize（..）</a> 。可用选项包括：</p>

<ul>
  <li><strong>格式化。</strong> 默认值： <code>false</code> 。如果启用，则<a href="#formatting">格式化程序</a>作业将在序列化期间确定所有空白区域信息。如果禁用，格式化程序仅为可以从节点模型保留空白空间信息的位置定义空白区域信息。例如，插入新模型元素或没有节点模型时。</li>
  <li><strong>证实。</strong> 默认值： <code>true</code> ：在序列化模型之前运行<a href="#concrete-syntax-validation">具体语法验证程序</a> 。</li>
</ul>

<h3 id="comment-associater">保留节点模型的注释</h3>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ICommentAssociater.java">ICommentAssociater将</a>注释与语义对象相关联。这在语义模型中的元素移动到不同位置并且模型被序列化的情况下是重要的，人们期望将注释移动到文档中的新位置。</p>

<p>哪个评论属于哪个语义对象肯定是一个非常主观的问题。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/DefaultCommentAssociater.java">默认实现的</a>行为如下，但可以自定义：</p>

<ul>
  <li>如果在注释之前和同一行中存在语义标记，则注释与此标记的语义对象相关联。</li>
  <li>在所有其他情况下，注释与下一个对象的语义对象相关联。</li>
</ul>

<h3 id="transient-values">瞬态值</h3>

<p>瞬态值是不持久的值或模型元素（写入序列化阶段的文本表示）。如果模型包含无法使用当前语法序列化的模型元素，则使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITransientValueService.java">ITransientValueService</a>将其标记为瞬态<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITransientValueService.java">至关重要</a> ，否则序列化将失败。默认实现将所有模型元素标记为瞬态，即<code>eStructuralFeature.isTransient()</code>或不是<code>eObject.eIsSet(eStructuralFeature)</code> 。默认情况下，如果值等于默认值，EMF将为<code>false</code>返回<code>eIsSet(..)</code> 。</p>

<h3 id="unassigned-text">未分配的文本</h3>

<p>如果存在不驻留在赋值中的数据类型规则或终端规则的调用，则默认情况下，序列化程序不知道用于序列化的值。</p>

<p>例：</p>

<pre><code class="language-xtext">PluralRule:
  'contents:' count=INT Plural;

terminal Plural:
  'item' | 'items';
</code></pre>

<p>此示例的有效模型是<code>contents 1 item</code>或<code>contents 5 items</code> 。但是，它没有存储在语义模型的关键字<em>的</em> <em>项目</em>或<em>项目</em>是否已被解析。这是因为规则调用<em>Plural</em>未分配。但是， <a href="#parse-tree-constructor">解析树构造函数</a>需要决定在序列化期间写入哪个值。可以通过自定义<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.java">IValueSerializer.serializeUnassignedValue（EObject，RuleCall，INode）</a>来做出此决定。</p>

<h3 id="cross-reference-serializer">交叉参考序列化器</h3>

<p>交叉引用序列化程序指定将哪些值写入文本表示以进行交叉引用。可以通过实现<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenSerializer.java">ICrossReferenceSerializer来自</a>定义此行为。默认实现委托给各种其他服务，例如<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>或<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/linking/impl/LinkingHelper.java">LinkingHelper，</a>每个服务都可能是更好的自定义位置。</p>

<h3 id="hidden-token-merger">合并白色空间</h3>

<p>在<a href="#parse-tree-constructor">解析树构造函数</a>完成其工作以创建要写入文本表示的令牌流并且<a href="#comment-associater">注释关联</a>器完成其工作之后，来自节点模型的现有空白空间被合并到流中。</p>

<p>策略如下：如果两个令牌在流中相互跟随，并且节点模型中的相应节点也相互跟随，则保持其间的空白信息。在所有其他情况下，由<a href="#formatting">格式化程序</a>来计算新的空白区域信息。</p>

<h3 id="token-stream">令牌流</h3>

<p><a href="#parse-tree-constructor">解析树构造函数</a>和<a href="#formatting">格式化程序</a>使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenStream.java">ITokenStream</a>作为输出，后者也使用它作为输入。这允许链接两个组件。令牌流可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/TokenStringBuffer.java">TokenStringBuffer</a>转换为<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String，</a>使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/WriterTokenStream.java">WriterTokenStream</a>转换为<a href="http://docs.oracle.com/javase/8/docs/api/java/io/Writer.html">Writer</a> 。</p>

<pre><code class="language-java">public interface ITokenStream {

  void flush() throws IOException;
  void writeHidden(EObject grammarElement, String value);
  void writeSemantic(EObject grammarElement, String value);
}
</code></pre>

<h2 id="formatting">格式化</h2>

<p>格式化（又称漂亮打印）是重新排列文档中的文本以提高可读性而不改变文档的语义值的过程。因此，格式化程序负责在文本中排列换行符，缩进，空格等以强调其结构，但不应该以影响语义模型的方式更改文档。</p>

<p>实际的格式化是通过构建文本替换列表来完成的。文本替换描述了一个新文本，它应该替换文档的现有部分，由偏移和长度描述。应用文本替换将未格式化的文档转换为格式化文档。</p>

<p>要以编程方式调用格式化程序，您需要实例化一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/FormatterRequest.java">请求</a>并将其传递给<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/IFormatter2.java">格式化程序</a> 。格式化程序将返回文本替换列表。文档修改本身可以由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/regionaccess/ITextRegionRewriter.java">ITextRegionRewriter</a>执行。</p>

<p>格式化程序的实现者应扩展<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/AbstractFormatter2.java">AbstractFormatter2</a>并为应格式化的模型元素添加调度方法。如果对象的子节点也应该被格式化，则必须递归调用格式例程。</p>

<p>以下示例说明了该模式。PackageDeclaration的实例与当前的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/IFormattableDocument.java">formattable文档</a>一起传递给format方法。在这种情况下，包名称由单个空格包围，花括号后跟一个新行和增加的缩进等。该包中的所有元素也应该被格式化，因此<code>format(..)</code>在这些上被调用为好。</p>

<pre><code class="language-xtend">def dispatch void format(PackageDeclaration p, extension IFormattableDocument doc) {
    p.regionFor.feature(PACKAGE_DECLARATION__NAME).surround[oneSpace]
    interior(
        p.regionFor.keyword('{').append[newLine],
        p.regionFor.keyword('}'),
        [indent]
    )
    for (element : p.elements) {
        format(element, doc)
        element.append[setNewLines(1, 1, 2)]
    }
}
</code></pre>

<p>API的设计方式允许通过调用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/IHiddenRegionFormatter.java">IHiddenRegionFormatter</a>上的方法以声明方式描述格式，该方法在<code>prepend</code> ， <code>surround</code>或<code>append</code>调用中可用，以指定格式规则。这可以按任意顺序完成 - 基础结构将重新排序所有配置，以便从文档的顶部到底部执行它们。如果基于配置的方法不足以满足特定用例，则该<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/IFormattableDocument.java">文档</a>还接受与给定范围相关联的命令性逻辑。可以直接添加到文档的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/ITextReplacer.java">ITextReplacer</a>允许对与其关联的区域中的文本执行各种修改。</p>

<p>有关API的更多详细信息可<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/package-info.java">在org.eclipse.xtext.formatting2包中</a>以<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting2/package-info.java">JavaDoc的形式获得</a> 。</p>

<h2 id="encoding">字符编码</h2>

<p>编码，又名。 <em>字符集</em> ，描述字符编码为字节的方式，反之亦然。着名的标准编码是<em>UTF-8</em>或<em>ISO-8859-1</em> 。可以通过调用<a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">Charset.availableCharsets（）</a>来确定可用编码列表。<a href="http://download.oracle.com/javase/1.5.0/docs/guide/intl/encoding.doc.html">API文档中</a>还有一个编码列表及其规范的Java名称。</p>

<p>不幸的是，每个平台和/或口语往往在越南或<em>MacIceland</em>在冰岛语中定义自己的本地编码，如<em>Cp1258</em>在Windows在Mac OS X。</p>

<p>在Eclipse工作区中，文件，文件夹，项目可以具有单独的编码，这些编码存储在每个项目的隐藏文件<em>.settings / org.eclipse.core.resources.prefs</em>中。如果资源没有显式编码，则它会以递归方式从父级继承该资源。Eclipse选择本机平台编码作为工作空间根目录的默认值。您可以在Eclipse首<em>选项</em>首<em>选项→工作区→默认文本编码中</em>更改默认工作<em>区编码</em> 。如果您在不同的平台上进行开发，则应考虑为文本或代码文件选择明确的通用编码，尤其是在使用特殊字符时。</p>

<p>虽然Eclipse允许定义和检查文件的编码，但您的文件系统通常不会。给定一个任意文本文件，没有一般策略来说明它是如何编码的。如果将Eclipse项目部署为jar（甚至是插件），则未存储在文件本身中的任何编码信息也将丢失。某些语言显式定义文件的编码，如XML文件的第一个处理指令。大多数语言没有。其他意味着固定编码或为字符文字提供增强的语法，例如Java中的unicode转义序列<em>\ uXXXX</em> 。</p>

<p>由于Xtext是关于文本建模的，它允许在各个地方调整编码。</p>

<h3 id="encoding-at-language-design-time">在语言设计时编码</h3>

<p>默认情况下， <em>New Xtext Project</em>向导创建的插件以工作空间标准编码进行编码。对于Xtext在那里生成的所有文件也是如此。如果您想更改它，例如因为您的语法使用/允许特殊字符，您应该在创建后手动设置这些项目的属性中的编码。在为语法添加特殊字符之前执行此操作，或者至少确保在编码更改后正确读取语法。要告诉Xtext生成器以相同的编码生成文件，请在工作流中设置encoding属性，例如</p>

<pre><code class="language-mwe2">component = XtextGenerator {
    configuration = {
        code = {
            encoding = "UTF-8"
        }
    ...
</code></pre>

<h3 id="encoding-at-language-runtime">语言运行时编码</h3>

<p>由于每种语言都能以不同方式处理编码问题，因此Xtext在此处提供服务。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java">IEncodingProvider</a>具有单个方法<code>getEncoding(URI)</code>来定义具有给定URI的资源的编码。用户可以实施自己的策略，但请记住，这不是一个长期运行的方法。如果编码存储在模型文件本身中，则应该以简单的方式提取，例如从XML文件的第一行开始。默认实现返回独立方案中的默认Java字符集。</p>

<p>在Eclipse UI场景中，当存在工作空间时，用户将期望模型文件的编码可以与工作空间中的其他文件相同的方式设置。因此，Eclipse上下文中<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java">IEncodingProvider</a>的默认实现返回文件在工作空间中的文件的工作空间编码，并委托给所有其他资源的运行时实现，例如jar中的模型或部署的插件。请记住，一旦离开此工作区，您将丢失工作区编码信息，例如部署项目。</p>

<p>除非您想为所有语言模型强制执行统一编码，否则我们建议仅覆盖运行时服务。它使用绑定注释<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/service/DispatchingProvider.java">@Runtime</a>绑定在运行时模块中：</p>

<pre><code class="language-xtend">override configureRuntimeEncodingProvider(Binder binder) {
    binder.bind(IEncodingProvider)
          .annotatedWith(DispatchingProvider.Runtime)
          .to(MyEncodingProvider)
}
</code></pre>

<p>对于统一编码，将普通<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java">IEncodingProvider</a>绑定到所有模块中的相同实现。在Eclipse UI模块中，您可以使用与上面类似的代码，但使用<em>DispatchingProvider。Ui</em>而不是<em>Runtime</em> 。</p>

<h3 id="encoding-of-an-xtextresource">XtextResource的编码</h3>

<p>默认情况下， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a>使用您的语言的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java">IEncodingProvider</a> 。您可以通过在加载和保存时传递选项来覆盖它，例如</p>

<pre><code class="language-xtend">myXtextResource.load(#{XtextResource.OPTION_ENCODING -&gt; "UTF-8"})
</code></pre>

<p>要么</p>

<pre><code class="language-xtend">myXtextResource.save(#{XtextResource.OPTION_ENCODING -&gt; "ISO-8859-1"})
</code></pre>

<h2 id="testing">单元测试</h2>

<p>自动化测试对于软件产品的可维护性和质量至关重要。这就是强烈建议您为您的语言编写单元测试的原因。Xtext项目向导为此目的创建测试项目，这简化了基本语言实现的设置过程以及特定于平台的集成。它支持为JUnit 4或JUnit 5创建测试的选项。根据您的选择，您的测试布局会有所不同。</p>

<h3 id="creating-a-simple-test-class">创建一个简单的测试类</h3>

<p>JUnit 4的测试基础架构的核心是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/XtextRunner.java">XtextRunner</a>和特定于语言的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/IInjectorProvider.java">IInjectorProvider</a> 。两者都必须通过类注释来提供。您的测试用例应使用<a href="https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/Test.java">org.junit进行注释<a href="https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/Test.java">。测试</a>静态导入<a href="https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/Assert.java">org.junit。断言</a>使您的测试更具可读性。</p>

<pre><code class="language-xtend">import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.junit.runner.RunWith
import org.junit.Test
import static org.junit.Assert.*
import org.example.domainmodel.DomainmodelInjectorProvider

@InjectWith(DomainmodelInjectorProvider)
@RunWith(XtextRunner)
class ParserTest {
    @Test void simple() {
        assertTrue(true)
    }
}
</code></pre>

<p>此配置将确保您可以在测试类中使用依赖项注入，并且在每次测试之前正确填充全局EMF注册表并进行清理。</p>

<p>JUnit 5的测试类看起来非常相似。而不是跑步者JUnit 5有一个<a href="https://junit.org/junit5/docs/current/user-guide/#extensions">扩展</a>的概念。虽然JUnit 4每个测试类只能有一个运行器，但JUnit 5可能有多个扩展。XtextRunner的替代品是新的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/extensions/InjectionExtension.java">InjectionExtension</a> 。仍然需要特定于语言的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/IInjectorProvider.java">IInjectorProvider</a> 。而不是<code>org.junit.Test</code>你必须用<a href="https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Test.java">org.junit.jupiter.api注释你的案例<a href="https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Test.java">。测试</a>并从<a href="https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java">org.junit.jupiter.api导入方法<a href="https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java">。断言</a> 。JUnit 5的简单测试类将如下所示：</p>

<pre><code class="language-xtend">import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.junit.jupiter.api.extension.ExtendWith
import org.junit.jupiter.api.Test
import static org.junit.jupiter.api.Assertions.*
import org.example.domainmodel.DomainmodelInjectorProvider

@InjectWith(DomainmodelInjectorProvider)
@ExtendWith(InjectionExtension)
class ParserTest {
    @Test void simple() {
        assertTrue(true)
    }
}
</code></pre>

<h3 id="testing-the-parser">测试解析器</h3>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/util/ParseHelper.java">ParseHelper</a>类允许将任意字符串解析为AST模型。之后可以遍历和检查AST模型本身。</p>

<pre><code class="language-xtend">import org.eclipse.xtext.testing.util.ParseHelper
...

@Inject ParseHelper&lt;Domainmodel&gt; parser

@Test
def void parseDomainmodel() {
    val model = parser.parse('''
        entity MyEntity {
            parent: MyEntity
        }
    ''')
    val entity = model.elements.head as Entity
    assertSame(entity, entity.features.head.type)
}
</code></pre>

<h3 id="test-validators">测试验证器</h3>

<p>使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/validation/ValidationTestHelper.java">ValidationTestHelper</a>测试验证非常简单：</p>

<pre><code class="language-xtend">...
 
@Inject extension ParseHelper
@Inject extension ValidationTestHelper

@Test
def void testLowercaseName() {
    val model = "entity foo {}".parse
    model.assertWarning(DomainmodelPackage.Literals.ENTITY, null,
            "Name should start with a capital")
}
</code></pre>

<p>请参阅该助手类中的各种<em>断言</em>方法以探索测试功能。您可以断言给定模型具有上述示例中的特定问题，或断言它没有问题。</p>

<h3 id="testing-multiple-languages">测试多种语言</h3>

<p>如果除了主语言之外，您的测试还需要使用其他语言来引用/到您的主语言，那么您必须先将相关资源解析并加载到同一个ResourceSet中，以便进行交叉引用解析。</p>

<p>由于您的主要语言（例如DomainmodelInjectorProvider）的默认生成的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.testing/src/org/eclipse/xtext/testing/IInjectorProvider.java">IInjectorProvider</a>不知道任何其他依赖语言，因此必须明确初始化它们。建议的模式是在<em>* .test</em>项目中创建生成的<em>MyLanguageInjectorProvider</em>的新子类，并确保依赖语言正确地进行了非正式化。然后你可以在测试的<em>@InjectWith中</em>使用这个新的注入器提供器而不是原来的注入器提供器：</p>

<pre><code class="language-xtend">class MyLanguageWithDependenciesInjectorProvider extends MyLanguageInjectorProvider {
    override internalCreateInjector() {
        MyOtherLangLanguageStandaloneSetup.doSetup
        return super.internalCreateInjector
    }
}

// @RunWith(XtextRunner) // JUnit 4
@ExtendWith(InjectionExtension) // JUnit 5
@InjectWith(MyLanguageWithDependenciesInjectorProvider)
class YourTest {
    ...
}
</code></pre>

<p>您不应在独立设置中为引用语言创建注入器。请注意，对于无头代码生成用例，Maven插件配置了多个设置，因此通常没有问题。</p>

<p>您可能还需要初始化不是由Xtext语言生成的导入的ecore模型。这应该通过使用显式<em>MyModelPackage.eINSTANCE.getName（）;</em>在各自语言的StandaloneSetup类的<em>doSetup（）</em>方法中。请注意，强烈建议您遵循此模式，而不是仅在* Test类中使用<em>@Before</em>方法，因为内部技术原因只要您有一个以上的<em>@Test</em>就不再有效。</p>

<pre><code class="language-xtend">class MyLanguageStandaloneSetup extends MyLanguageStandaloneSetupGenerated {

    def static void doSetup() {
        if (!EPackage.Registry.INSTANCE.containsKey(MyPackage.eNS_URI))
            EPackage.Registry.INSTANCE.put(MyPackage.eNS_URI, MyPackage.eINSTANCE);
        new MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration
    }

}
</code></pre>

<p>这仅适用于引用依赖于导入的Ecore模型和基于它们的语言，这些模型和语言可以在测试中使用。来自混合语法的继承依赖项已经自动列在生成的超类中，并且不需要为这些进行任何操作。</p>

<hr>

<p><strong><a href="305_xbase.html">下一章：与Java集成</a></strong></p>


</body>
</html>