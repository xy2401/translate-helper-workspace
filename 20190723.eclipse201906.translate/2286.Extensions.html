<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>扩展（在Unified / Pivot OCL原型中）</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="Tutorials.html" title="Tutorials">
<link rel="prev" href="OCLInterpreterTutorial.html" title="Working with Classic OCL">
<link rel="next" href="Installation.html" title="Installing the Eclipse OCL Examples and Editors">
</head>
<body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">扩展（在Unified / Pivot OCL原型中）</h1>
<div class="section" title="扩展（在Unified / Pivot OCL原型中）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Extensions"></a>扩展（在Unified / Pivot OCL原型中）</h2>
</div>
</div>
</div>
<p>本节重点介绍Pivot OCL原型的一些OCL扩展。</p>
<div class="section" title="楷模">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Models"></a>楷模</h3>
</div>
</div>
</div>
<p>抽象语法类和接口是使用标准EMF工具从Pivot.ecore自动生成的。Pivot.ecore是由OMG的UML.xmi和原型OCL.uml模型的自定义QVTo转换自动生成的。这给出了一定程度的UML对齐。</p>
<p>标准库由OCL-2.5.oclstdlib定义，可以使用OCLstdlib Xtext编辑器。因此，库被建模。</p>
<p>使用标准EMF工具从Ecore modesl自动生成Concrete Syntax类和编辑器。从UML模式自动生成Ecore模型1仍在进行中。</p>
<p>语法由Xtext模型定义。</p>
<p>运行时Value类和接口部分由Values.ecore生成。完全自动生成仍在进行中。</p>
<p>还有代码生成中间体的模型。</p>
</div>
<div class="section" title="XMI">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="XMI"></a> XMI</h3>
</div>
</div>
</div>
<p>抽象语法模型使用* .oclas文件扩展名作为标准XMI完全可持久化。Pivot.oclas和OCL-2.5.oclas模型构成了Eclipse OCL发行版的一部分。</p>
<p>通过孤立包解决了诸如Sequence（String）之类的合成类型的交换问题，其中保持了每个单例的单例副本。</p>
<p>完整OCL的开放类允许其他功能的问题通过CompleteModel / CompletePackage / CompleteClass添加到抽象语法中来解决，以便CompleteClass可以聚合许多普通的类;一个来自主用户（UML / Ecore）模型，任何数量的进一步（Compete OCL或OCLstdlib）; ays。</p>
<p>OppositePropertyCallExp类解决了引用不可通过的对立面的问题。</p>
<p>通过向IterateExp / IteratorExp添加referIteration属性来解决对建模迭代的引用问题。</p>
<p>通过规范化UML表示以利用常规的类/属性用法来解决引用Stereotype属性的问题。</p>
<p>通过规范化UML表示以利用常规的类/属性用法来解决对关联属性的引用问题。</p>
</div>
<div class="section" title="模板">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Templates"></a>模板</h3>
</div>
</div>
</div>
<p>在OMG OCL中，诸如Sequence（String）之类的类型神奇地关联String和T的错误定义概念。在UML中，因此UML对齐的枢轴OCL，String是一个TemplateParameter，其中诸如TemplateParameterSubstitution之类的其他类定义了绑定。将魔术T用于库类是针对任意用户类和操作的。像UML一样的jusr。 cource的模板类型符合，因为在OCL中所有值都是不可变的，Set（Integer）符合Sert（Real）和Set（OclAny）。这可能会有点令人惊讶，因为拼写错误可能不会立即导致类型错误，而是带有推断的OclAny错误的表达式。使用hovertext检查表达式类型。</p>
</div>
<div class="section" title="可扩展性">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Extensibility"></a>可扩展性</h3>
</div>
</div>
</div>
<p>Eclipse QVTd项目扩展了Pivot OCL，以支持QVTc和QVTr。因此，模型是可扩展的，但不是那么容易。相当需要Java编程。真正的可扩展性和单一的模块化OCL Standrad库仍在进行中。</p>
</div>
<div class="section" title="操作重载">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OperationOverloading"></a>操作重载</h3>
</div>
</div>
</div>
<p>UML和OCL之间关于操作重载的降压在Pivot OCL中通过对具有匹配签名的大多数派生的实现实现Java样式的动态调度来解决。</p>
</div>
<div class="section" title="定型">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Stereotypes"></a>定型</h3>
</div>
</div>
</div>
<p>关于base_XXX和extension_XXX属性的UML规范hinyts与ElementExtension lass一起使用，以模拟Stereotype的实例。因此，无需借助Eclipse UML2的专有getXXX Java API，就可以实现Typesafe构造型导航。</p>
</div>
<div class="section" title="安全导航">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="SafeNavigation"></a>安全导航</h3>
</div>
</div>
</div>
<p>UML [1]和[？]利用多重性来区分可空和非空对象并诊断不安全的导航。为了使这个有用，可以通过将例如Set（String [* | 1]）定义为具有无界[*]集合多重性和never-null [1]元素多样性的字符串集来扩展无空集合。额外的？和“？ - &gt;”安全导航操作员避免无效。有关详细信息，请参阅<a class="ulink" href="http://www.eclipse.org/modeling/mdt/ocl/docs/publications/OCL2015SafeNavigation/SafeNavigation.pdf" target="_new">OCL中的安全导航</a> 。
				</p>
</div>
<div class="section" title="反射">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Reflection"></a>反射</h3>
</div>
</div>
</div>
<p>在Pivot OCL中，oclType（）libary方法具有pivot :: Class返回类型，允许进一步导航以对用户元模型进行反射访问。</p>
</div>
<div class="section" title="Lambda表达式">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LambdaExpressions"></a> Lambda表达式</h3>
</div>
</div>
</div>
<p>OCL总是有隐藏的lambda表达式来定义iteratpr主体。Pivot OCL对这些进行了处理，以便标准库使用模板化的LambdaType作为其建模的一部分。变量和参数可以使用LamabdaType，因此提供完整的lambda表达式功能。</p>
</div>
<div class="section" title="地图（K，V）">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MapKV"></a>地图（K，V）</h3>
</div>
</div>
</div>
<p>Map类型提供熟悉的功能，包括一组具有关联值的键。</p>
<p>与所有其他OCL类型一样，Map类型是不可变的;因此，没有<span class="bold"><strong>放置</strong></span>或<span class="bold"><strong>设置</strong></span>操作，而是可以通过将键值对与旧映射<span class="bold"><strong>包括</strong></span>在一起来创建新映射。
				</p>
<p>可以使用<span class="bold"><strong>at</strong></span>访问Map的内容，其对于未知密钥返回无效，其方式与有序集合对于未知索引返回无效的方式相同。
				</p>
<p>可以使用新的Map Literal语法显式创建Map。因此， <span class="bold"><strong>Map（整数，字符串）{1 &lt; - 'one'，2 &lt; - 'two'}</strong></span>创建一个Integer到String的Map，其中<span class="bold"><strong>'one'</strong></span>绑定到<span class="bold"><strong>1</strong></span> ， <span class="bold"><strong>'two'</strong></span>绑定到<span class="bold"><strong>2</strong></span> 。可以省略类型<span class="bold"><strong>（整数，字符串）</strong></span>参数化。
					允许<span class="bold"><strong>null</strong></span>但不是<span class="bold"><strong>无效</strong></span>值作为键和值。
				</p>
<p>新的<span class="bold"><strong>collectBy</strong></span>迭代可用于从集合或映射构造映射。<span class="bold"><strong>collectBy</strong></span>的迭代器定义键和定义值的主体的值。例如， <span class="bold"><strong>序列{1..10}  - &gt; collectBy（i | i + i）}</strong></span>构建从值1到10到偶数值2到20的映射。
				</p>
<p>使用映射键作为（主）迭代器，大多数标准集合迭代操作都可用于Maps。可以使用新的绑定到语法指定辅助值迭代器。因此， <span class="bold"><strong>Map {1 &lt;-1,2 &lt;-4,3 &lt;-9}  - &gt; reject（k &lt;-v | k = 2或v = 9}</strong></span>定义了三个条目映射的拒绝迭代，主迭代器<span class="bold"><strong>k</strong></span>在一组键和一个辅助共迭代器<span class="bold"><strong>v</strong></span>上绑定到每个键的值。正文导致第二个条目带有键2，第三个条目值为9，只留下一个条目映射。
				</p>
<div class="section" title="细节">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Details"></a>细节</h4>
</div>
</div>
</div>
<p>OCL元模型由MapLiteralExp和MapType扩展。新的抽象IterableType捕获CollectionType和MapType的可迭代通用性，而不使map成为集合。</p>
<p>OCL标准库定义了新的Map操作和新的Collection :: collectBy itetation。</p>
<p>OCL语法通过MapLiteralExp语法和所有迭代器的绑定到共迭代器语法进行扩展。</p>
<p>OCL运行时由MapValue和抽象IteravleValue扩展，以捕获与CollectionValue的共性。</p>
</div>
</div>
</div>
</body>
</html>