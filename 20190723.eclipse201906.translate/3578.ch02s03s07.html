<html ><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>比较</title><link href="book.css" type="text/css" rel="stylesheet"><link href="book.css" type="text/css" rel="stylesheet"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="usermanual"><link rel="up" href="ch02s03.html" title="How to use the XPath 2.0 grammar with PsychoPath"><link rel="prev" href="ch02s03s06.html" title="Range expressions"><link rel="next" href="ch02s03s08.html" title="Conditional Expressions"></head><body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" title="比较"><div class="titlepage"><div><div><h3 class="title"><a name="Comparisons"></a>比较</h3></div></div></div><p>最简单的比较运算符是<span class="bold"><strong>eq</strong></span> ， <span class="bold"><strong>ne</strong></span> ， <span class="bold"><strong>lt</strong></span> ， <span class="bold"><strong>le</strong></span> ， <span class="bold"><strong>gt</strong></span> ， <span class="bold"><strong>ge</strong></span> 。这些比较两个相同类型的原子值，例如两个整数，两个日期或两个字符串。（在当前版本的PsychoPath中尚未实施排序规则）。如果操作数不是原子值，则会引发错误。
				</p><p>运营商<span class="bold"><strong>='''</strong></span> ，！=' <span class="italic">，'</span> &lt;=' <span class="italic">，'</span> &gt; <span class="bold"><strong>，'''&lt;</strong></span>和<span class="bold"><strong>&gt; =</strong></span>可以比较任意序列。如果两个序列中的任何一对项具有指定的关系，则结果为true，例如，如果<span class="italic">$ A</span>中的项目等于<span class="italic">$ B中的</span>某个项目，则<span class="italic">$ A = $ B</span>为真。</p><p>运营商<span class="bold"><strong>是</strong></span>和<span class="bold"><strong>状态并没有</strong></span>测试操作数是否代表相同的（相同的）节点。例如，如果第一个标题子元素是具有<span class="italic">@note</span>属性的第一个子元素，则<span class="italic">标题<a class="ulink" href="1" target="_top">1</a>为* <a class="ulink" href="@note" target="_top">@note</a> <a class="ulink" href="1" target="_top">1</a></span>为真。如果任一操作数是空序列，则结果为空序列（通常将其视为false）。
				</p><p>运算符<span class="bold"><strong>&lt;&lt;</strong></span>和<span class="bold"><strong>&gt;&gt;</strong></span>测试一个节点是否在文档顺序中位于另一节点之前或之后。考虑这个XML文档（XPexample.xml）：&lt;source lang =“xml”&gt;</p><div class="literallayout"><p>&lt;书&gt;<br>&lt;title&gt;作为一只狗是一份全职工作&lt;/ title&gt;<br>&lt;作者&gt; Charles M. Schulz &lt;/ author&gt;<br>&lt;字符&gt;<br>&lt;名称&gt;史努比&lt;/名称&gt;<br>&lt;friend-of&gt; Peppermint Patty &lt;/ friend-of&gt;<br>&lt;因为&gt; 1950年10月4日&lt;/因为&gt;<br>&lt;年龄&gt; 2 &lt;/年龄&gt;<br>&lt;qual&gt;外向的beagle &lt;/ qualification&gt;<br>&lt;/字符&gt;<br>&lt;字符&gt;<br>&lt;name&gt; Peppermint Patty &lt;/ name&gt;<br>&lt;因为&gt; 1966年8月22日&gt; /因为&gt;<br>&lt;年龄&gt; 4 &lt;/年龄&gt;<br>&lt;qual&gt; bold，brash and tomboyish &lt;/ qualification&gt;<br>&lt;/字符&gt;<br>&lt;/书&gt;<br>
</p></div><p> </p><p>此文件符合以下架构（XPexample.xsd）：</p><p>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</p><div class="literallayout"><p>&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”<br>将elementFormDefault = “合格”&gt;<br>
</p></div><div class="literallayout"><p>&lt;xs：element name =“book”&gt;<br>&lt;XS：的complexType&gt;<br>&lt;XS：序列&gt;<br>&lt;xs：element ref =“title”/&gt;<br>&lt;xs：element ref =“author”/&gt;<br>&lt;xs：element maxOccurs =“unbounded”ref =“character”/&gt;<br>&lt;/ XS：序列&gt;<br>&lt;/ XS：的complexType&gt;<br>&lt;/ XS：元件&gt;<br>
</p></div><div class="literallayout"><p>&lt;xs：element name =“title”type =“characterName”&gt; &lt;/ xs：element&gt;<br>
</p></div><div class="literallayout"><p>&lt;xs：element name =“author”type =“characterName”&gt; &lt;/ xs：element&gt;<br>
</p></div><div class="literallayout"><p>&lt;xs：element name =“character”&gt;<br>&lt;XS：的complexType&gt;<br>&lt;XS：序列&gt;<br>&lt;xs：element ref =“name”/&gt;<br>&lt;xs：element ref =“friend-of”minOccurs =“0”/&gt;<br>&lt;xs：element ref =“since”/&gt;<br>&lt;xs：element ref =“age”/&gt;<br>&lt;xs：element ref =“qualified”/&gt;<br>&lt;/ XS：序列&gt;<br>&lt;/ XS：的complexType&gt;<br>&lt;/ XS：元件&gt;<br>&lt;xs：element name =“name”type =“characterName”/&gt;<br>&lt;xs：element name =“friend-of”type =“characterName”/&gt;<br>&lt;xs：element name =“since”type =“xs：date”/&gt;<br>&lt;xs：element name =“age”type =“xs：nonNegativeInteger”/&gt;<br>&lt;xs：element name =“qualification”type =“xs：string”/&gt;<br>
</p></div><div class="literallayout"><p>&lt;xs：simpleType name =“characterName”&gt;<br>&lt;xs：restriction base =“xs：normalizedString”&gt;<br>&lt;xs：minLength value =“1”/&gt;<br>&lt;/ XS：限制&gt;<br>&lt;/ XS：的simpleType&gt;<br>&lt;/ XS：模式&gt;<br>
</p></div><p> </p><p>
					<span class="bold"><strong>
						<span class="italic">例子：</span>
					</strong></span> 
				</p><div class="literallayout"><p>书/字符[name =“史努比”]＆lt;＆lt;书/字符[name =“Peppermint Patty”]<br>
</p></div><p> 

					<span class="bold"><strong>结果：</strong></span> 
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>xs：布尔值：true</p></li></ol></div><div class="literallayout"><p>书/字符[name =“Peppermint Patty”]＆lt;＆lt;书/字符[名称=“史努比”]<br>
</p></div><p> 

					<span class="bold"><strong>结果：</strong></span> 
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>xs：布尔值：false</p></li></ol></div></div></body></html>