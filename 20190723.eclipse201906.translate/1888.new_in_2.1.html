<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" gtc:encodedoriginal="PCFET0NUWVBFIEhUTUwgUFVCTElDICItLy9XM0MvL0RURCBIVE1MIDQuMCBUcmFuc2l0aW9uYWwvL0VOIj4=">
<html >
<head>
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/nn.css">
	<title>OTDT 2.1  - 新的和值得注意的</title>
</head>
<body >
<h1>OTDT 2.1  - 新的和值得注意的</h1>
<!--div class="navigation"><i>Status: 2.1 M7</i></div-->
<div class="navigation">在此页面上： <!--a href="#metrics">&bull; Metrics Plug-in</a--> <!--a href="#configuration">&bull; Configuration</a--> <a href="#views">•视图/对话框</a> <a href="#assist">•内容辅助</a> <!--a href="#refactor">&bull; Refactoring</a--> <a href="#formatting">•格式化</a> <a href="#debug">•运行/调试</a> <a href="#language">•语言</a> <!--a href="#api">&bull; API</a--> <a href="#compiler">•编译器</a> <a href="#otre">•运行时</a> <!--a href="#otequinox">&bull; OT/Equinox</a--> <a href="#releng">•发布工程</a>  
</div>
<table cellpadding="10" cellspacing="0" width="100%">
  <colgroup>
  <col width="20%">
  <col width="80%">
  </colgroup>
  <tbody>
<td><!--
  <tr><td colspan="2" id="NAME"><h2>HEADING</h2></td></tr>
  <tr>
    <td><p align="right"><b>DESC</b><br>
        <span class="since">since&nbsp;0.7.1</span><br>
        <a class="buglink" title="TITLE" href="https://bugs.eclipse.org/308029">308029</a></p></td>
    <td><p>
    		
    	</p>
    	<p><img alt="TEXT" src="../images/screenshots/NN07/.png"></p>
    	<p></p>
    </td>
  </tr>
  <div class="listbox"><div class="listing"><pre><code class="keyword">public team class</code> <font color="blue">MyTeam</font> {
}</pre></div></div>
-->
  <tr></tr></td><td colspan="2" id="views"><h2>视图和对话框</h2></td>
  <tr>
    <td><p align="right"><b>提升呼叫层次结构</b><br>
        <span class="since">从2.1M6开始</span><br>
        <a class="buglink" title="CallHierarchy应该考虑提升为角色实例创建" href="https://bugs.eclipse.org/301314">301314</a></p></td>
    <td><p>以前，角色构造函数的调用层次结构是不完整的，因为可以通过提升按需构建角色。为了可视化这种隐式行为，调用层次结构已被扩展，以考虑提升作为角色提升构造函数的调用。
    	</p>
    	<p><img alt="调用角色构造的层次结构" src="../images/screenshots/NN21/callHierarchyLifting.png"></p>
    	<p>这里为角色类型<code>Item</code>打开了调用层次结构，以查找实例化的所有路径。调用层次结构显示callin绑定<code>earchCredit &lt;- after book</code>因为它可能会触发将<code>Segment</code>提升到其<code>Item</code>角色。</p>
    </td>
  </tr>
  <tr><td colspan="2" id="assist"><h2>内容辅助</h2></td></tr>
  <tr>
    <td><p align="right"><b>将签名添加到方法绑定</b><br>
        <span class="since">从2.1M2开始</span><br>
        <a class="buglink" title="[辅助]使添加签名更加灵活，可以防止模糊的方法绑定" href="https://bugs.eclipse.org/355274">355274</a></p></td>
    <td><p>现有的快速辅助“向方法绑定添加签名”已得到改进，因此即使无法解析其基本方法，也可以在无签名方法绑定上使用它。如果基类具有方法绑定中提到的名称的多个方法，则收集所有匹配的基本方法，将最佳匹配插入编辑器中，并且在链接模式中提供其他匹配作为替代。
    	</p>
    	<p>所以，如果在调用助手之前你有：</p>
    	<p><img alt="模糊基础方法" src="../images/screenshots/NN21/AmbiguousBaseMethod.png"></p>
    	<p>您可以调用辅助作为quickfix（例如，从错误悬停），产生此更改：</p>
    	<p><img alt="添加签名快速帮助" src="../images/screenshots/NN21/AddSignaturesAssist.png"></p>
    	<p>您可以从列表中选择合适的基本方法。</p>
    	<p><strong>提示：</strong>如果方法绑定的签名不正确，您可以先删除签名（使用快速辅助），然后让这个新的辅助插入正确的签名。</p>
    </td>
  </tr>
  <tr>
    <td><p align="right"><b>从隐式超级角色实现抽象方法</b><br>
        <span class="since">从2.1M3开始</span><br>
        <a class="buglink" title="[quickfix]从tsuper实现抽象方法" href="https://bugs.eclipse.org/348574">348574</a></p></td>
    <td><p>现有的快速辅助“添加未实现的方法”已经扩展，也适用于那些从超级团队中的相应角色<b>隐式继承的</b>抽象方法。
    	</p>
    	<p>针对角色类的错误现在提供了快速修复：</p>
    	<p><img alt="必须实现..抽象方法" src="../images/screenshots/NN21/ImplementFromTSuper.png"></p>
    	<p>调用快速修复（例如，从错误悬停）产生此更改：</p>
    	<p><img alt="“添加未实现的方法”快速修复的结果" src="../images/screenshots/NN21/ImplementFromTSuper1.png"></p>
    </td>
  </tr>
  <tr>
    <td><p align="right"><b>改进了基础进口的处理</b><br>
        <span class="since">从2.1M5开始</span><br>
        <a class="buglink" title="改善基础进口的处理" href="https://bugs.eclipse.org/356003">356003</a></p></td>
    <td><p>OT / J中使用所谓的“基础导入”来区分那些仅作为当前团队中角色的基类导入的类，不允许在团队实施中直接使用及其角色（参见<a class="otjldlink" href="http://www.objectteams.org/def/1.3/s2.html#s2.1.2.d">OTJLD§2.1） .2（d）</a> ）。伞虫356003列出了几个单独的改进，以使内容辅助，向导和重构更好地了解基本导入的语义规则。在所有这些情况下，现在都会创建正确的基本导入或常规导入，并且如果重构要求，则会正确更新基本导入。
    	</p>
    </td>
  </tr>
  <tr><td colspan="2" id="formatting"><h2>格式化</h2></td></tr>
  <tr>
    <td><p align="right"><b>OT / J的基本代码格式</b><br>
        <span class="since">从2.1M5开始</span><br>
        <a class="buglink" title="Formatter在大团队上无声地失败" href="https://bugs.eclipse.org/331731">331731</a></p></td>
    <td><p>在以前的版本中，对OT / J的代码格式化的支持是不完整的，并且某些构造（如<code class="keyword">precedence</code>出现使格式化程序无声地失败。从2.1 M5开始，OT / J的代码格式现在通常适用于所有语言结构。对于所有语法元素，结果可能不是最佳的，因为没有为callin / callout等元素引入特殊首选项选项。但是，不反对默认格式样式的用户现在可以依赖角色和团队的自动格式。
    	</p>
    </td>
  </tr>
<td><!--
  <tr><td colspan="2" id="refactor"><h2>Refactoring</h2></td></tr>
-->
  <tr></tr></td><td colspan="2" id="language"><h2>语言</h2></td>
  <tr>
    <td><p align="right"><b>Java 7支持</b><br>
        <span class="since">从2.1M1开始</span><br>
        <a class="buglink" title="升级到Java7" href="https://bugs.eclipse.org/353894">353894</a></p></td>
    <td><p>从2.1 M1开始，OT / J已经与Java 7集成，即OT / J编译器也支持<a href="http://www.eclipse.org/jdt/ui/r3_8/Java7news/whats-new-java-7.html">Java 7中引入的</a>所有<a href="http://www.eclipse.org/jdt/ui/r3_8/Java7news/whats-new-java-7.html">新功能</a> 。
    	</p>
    </td>
  </tr>
  <tr>
    <td><p align="right"><b>@Override用于静态角色方法</b><br>
        <span class="since">从2.1M3开始</span><br>
        <a class="buglink" title="[编译器]支持@Override用于静态角色方法" href="https://bugs.eclipse.org/359894">359894</a></p></td>
    <td><p>沿着隐式继承，角色甚至可以从其隐式超级角色覆盖静态方法。现在可以使用<code>@Override</code>注释记录此<code>@Override</code> ，这将导致编译器检查声明的覆盖是否实际发生：</p>
    	<p>
    	</p><div class="listbox"><div class="listing"><pre><code class="keyword">public team class</code> T0 {
   <code class="keyword">protected class</code> R {
       <code class="keyword">static int</code> zork() { return 0;}
   }
}
<code class="keyword">public team class</code> T1 <code class="keyword">extends</code> T0 {
   <code class="annotation">@Override</code>
   <code class="keyword">protected class</code> R { 
       <code class="annotation">@Override</code> <code class="comment">// OK</code>
       <code class="keyword">static int</code> zork() { return 1;}

       <code class="annotation">@Override</code> <code class="comment">// <b style="color:red;">ERROR</b></code>
       <code class="keyword">static void</code> bar() { }
   }
}</pre></div></div>
    	
    </td>
  </tr>
  <tr>
    <td><p align="right"><b>基类作为方法返回</b><br>
        <span class="since">从2.1M6开始</span><br>
        <a class="buglink" title="[编译器] [otjld]考虑允许基本导入类型作为团队方法的返回类型" href="https://bugs.eclipse.org/370273">370273</a></p></td>
    <td><p>不允许在团队或角色的主体中提及基本导入的类。但是，团队方法可能希望返回一个角色，然后在途中应该降低该角色。以前，这种降低是不可能的，因为无法提及基本类型（通过其简单的名称）。对于团队方法返回类型的特定情况，已删除此限制。
    	</p>
    	<p>
    	</p><div class="listbox"><div class="listing"><pre><code class="keyword">import base</code> some.pack.Base; // <span style="color:red">base import restricts usage of "Base"</span>
<code class="keyword">public team class</code> T {
   <code class="keyword">protected class</code> R <code class="keyword">playedBy</code> Base { }
   <code class="keyword">private </code> R r;
   <code class="keyword">public</code> <b style="color:blue">Base</b> getObject() {
       <code class="keyword">return this</code>.r; // <span style="color:green">applies lowering</span> 
   } 
}</pre></div></div>
    	
    </td>
  </tr>
  <tr><td colspan="2" id="debug"><h2>运行/调试</h2></td></tr>
  <tr>
    <td><p align="right"><b>使用OT / Equinox简化启动</b><br>
        <span class="since">从2.1M4开始</span><br>
        <a class="buglink" title="[debug]使OT / Equinox启动位置无关" href="https://bugs.eclipse.org/366315">366315</a></p></td>
    <td><p>OT / Equinox使用片段实现，该片段充当Equinox的<em>框架扩展</em> 。到目前为止，这要求OT / Equinox束位于同一位置，也就是<code>org.eclipse.osgi</code>所在的位置。这可能使调试OT / Equinox本身变得困难，因为所有提到的捆绑包都必须设置为物理存储在工作空间中的项目。
    	</p>
    	<p>此限制已被删除，即，可以从工作空间解析OT / Equinox包，同时从基础平台解析<code>org.eclipse.osgi</code> 。
    	</p>
    </td>
  </tr>  
  <tr>
    <td><p align="right"><b>热代码替换</b><br>
        <span class="since">从2.1M7开始</span><br>
        <a class="buglink" title="[debug]支持团队/角色/基地的热代码替换" href="https://bugs.eclipse.org/378176">378176</a><br>
        <a class="buglink" title="支持OT / Equinox的热代码替换" href="https://bugs.eclipse.org/378195">378195</a></p></td>
    <td><p>以前，在调试OT / J或OT / Equinox应用程序时，无法动态应用对正在运行的应用程序的源代码所做的更改，因为JVM会检测签名不匹配。这是因为在热代码替换期间没有使用对象团队字节码转换器。
    	</p>
    	<p>这已通过启用对象团队转换器重新编织已加载的类来解决。此外，对于OT / Equinox调试启动，已经开发了一种新的Java代理来触发编织以进行热代码替换（Equinox中的底层适配器挂钩不支持）。对于所有OT / Equinox调试启动，此代理程序将自动添加到Java命令行。
    	</p>
    	<p>因此，现在可以直接查看源代码更改的效果，即使在编织类中也无需重新启动应用程序。请注意，热代码替换受JVM限制为不影响任何签名的更改。
    	</p>
    </td>
  </tr>  
<td><!--
  <tr><td colspan="2" id="api"><h2>API</h2></td></tr>
-->
  <tr></tr></td><td colspan="2" id="compiler"><h2>编译器</h2></td>
  <tr><td><p align="right"><b>报告多个callins</b><br>
        <span class="since">从2.1M2开始</span><br>
        <a class="buglink" title="当两个角色同时捕获相同的方法时产生警告" href="https://bugs.eclipse.org/314610">314610</a></p></td>
    <td><p>当两个独立的callin绑定影响相同的基本方法时，这<em>可能</em>会导致意外行为。因此，报告新警告以警告用户这种情况：</p>
  		<p><img alt="多个callin绑定正在影响方法foo（）" src="../images/screenshots/NN21/MultipleCallins.png"></p>
  		<p>如警告消息中所述，此诊断仅在完整构建期间重新计算，因为此计算需要整个系统分析。
  		</p>
  		<p>使用左侧标尺中的callin标记导航到可能存在冲突的callin绑定以进行检查（对于callin标记和警告标记之间的混乱感到遗憾）：</p>
  		<p><img alt="OT / J callin绑定导航" src="../images/screenshots/NN21/GotoCallin.png"></p>
  	</td>
  </tr>

  <tr><td colspan="2" id="otre"><h2>对象团队运行时环境</h2></td></tr>
  <tr>
    <td><p align="right"><b>内存优化</b><br>
        <span class="since">从2.1M2开始</span><br>
        <a class="buglink" title="[otre]类RepositoryAccess正在浪费内存" href="https://bugs.eclipse.org/355328">355328</a></p></td>
    <td><p>可以显着降低OTRE的内存消耗。来自BCEL的给定类保留了加载类的完整结构，可以将其简化为更紧凑的格式。测量显示该数据结构减少到大约。原始尺寸的1％。
    	</p>
    </td>
  </tr>  
  <tr>
    <td><p align="right"><b>性能优化</b><br>
        <span class="since">从2.1M2开始</span><br>
        <a class="buglink" title="[otre]避免因急切创建_OT $ roleSet而导致性能下降" href="https://bugs.eclipse.org/355263">355263</a></p></td>
    <td><p>编织到每个基类中的内部数据结构被急切地初始化，从而导致性能损失。可以完全删除这种急切的初始化，已经实现了延迟初始化。对于创建了大量基础对象的情况，其中没有创建任何角色，这导致最多3.5的加速（来自微基准）。
    	</p>
    </td>
  </tr>  
  
  <tr><td colspan="2" id="releng"><h2>发布工程</h2></td></tr>
  <tr><td><p align="right"><b>来源捆绑</b><br>
        <span class="since">从2.1M6开始</span><br>
        <a class="buglink" title="创建源包和功能" href="https://bugs.eclipse.org/370650">370650</a></p></td>
    <td><p>我们现在发布一个额外的（可选）功能<code>org.eclipse.objectteams.otdt.source.feature</code> ，其中包含所有Object Teams插件的源代码，以支持浏览二进制插件，其中插件项目位于工作空间中依靠。
    	</p>
  	</td>
  </tr>
  
</tbody></table>
</body>