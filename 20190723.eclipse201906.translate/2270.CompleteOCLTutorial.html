<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>完成OCL教程</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="Tutorials.html" title="Tutorials"></link>
<link rel="prev" href="Tutorials.html" title="Tutorials"></link>
<link rel="next" href="SafeNavigationTutorial.html" title="Safe navigation tutorial"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">完成OCL教程</h1>
<div class="section" title="完成OCL教程">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="CompleteOCLTutorial"></a>完成OCL教程</h2>
</div>
</div>
</div>
<p>本教程已针对Eclipse Mars更新：Eclipse 4.5，EMF 2.11，OCL 6.0。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一些截图可能会略微过时。</p>
</li>
</ul>
</div>
<div class="section" title="概观">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Overview2"></a>概观</h3>
</div>
</div>
</div>
<p>在这个例子中你会</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>获取完整OCL语言的概述</p>
</li>
<li class="listitem">
<p>将完整的OCL文档加载到第三方应用程序中</p>
</li>
<li class="listitem">
<p>增强派生属性的Ecore验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证Ecore模型</p>
</li>
<li class="listitem">
<p>增强UML验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证UML模型</p>
</li>
<li class="listitem">
<p>增强Xtext验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证Xtext语法</p>
</li>
</ul>
</div>
</div>
<div class="section" title="完整的OCL实用程序">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLUtility"></a>完整的OCL实用程序</h3>
</div>
</div>
</div>
<p>OCL本身几乎没用，因为没有任何模型可以操作，约束无法达到很大的效果。</p>
<p>使OCL有用的最简单方法是在模型中嵌入OCL表达式，以丰富具有更复杂行为的模型的基本结构特征。OCLinEcore为Ecore模型提供此功能。Papyrus为UML模型提供了类似的功能。</p>
<p>本教程介绍了完整的OCL语言，该语言可用于提供补充预先存在的元模型的独立文档。</p>
</div>
<div class="section" title="加载完成OCL教程示例项目">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadCompleteOCLTutorialExampleProject"></a>加载完成OCL教程示例项目</h3>
</div>
</div>
</div>
<p>本教程的所有材料都可以作为CompleteOCLTutorial示例项目的一部分提供，您可以通过使用Project Explorer的右键上下文菜单选择<span class="bold"><strong>New</strong></span> then <span class="bold"><strong>Example ...</strong></span>来加载它。这应该给出<span class="bold"><strong>New Example</strong></span>对话框，您可以在其中选择<span class="bold"><strong>OCL（OCL约束语言）插件</strong></span>和<span class="bold"><strong>Complete OCL Tutorial</strong></span> ，然后选择<span class="bold"><strong>Next</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-new-complete-ocl-tutorial1.png"></div>
<p>
				
</p>
<p>然后<span class="bold"><strong>完成</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-new-complete-ocl-tutorial2.png"></div>
<p>
				
</p>
<p>如果您没有看到这些示例项目，请按照<a class="link" href="Installation.html" title="Installing the Eclipse OCL Examples and Editors">安装OCL编辑器</a>的<a class="link" href="Installation.html" title="安装Eclipse OCL示例和编辑器">说明进行操作</a> 。
				</p>
<p>生成的项目有一些测试文件。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-complete-ocl-tutorial-project.png"></div>
<p>
				
</p>
</div>
<div class="section" title="完整的OCL语言概述">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-language"></a>完整的OCL语言概述</h3>
</div>
</div>
</div>
<p>完整的OCL语言在本文档的<a class="link" href="CompleteOCL.html" title="完整的OCL语言">完整OCL</a>部分中有详细描述。在本教程中，我们将仅提供该语言的简要概述。如果尚未打开，请双击<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>以显示以下文本，其中提供了完整OCL语法的许多重要方面的示例。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-content.png"></div>
<p>
				
</p>
<div class="section" title="进口申报">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="importdeclarations"></a>进口申报</h4>
</div>
</div>
</div>
<p>导入语句是OMG规范中的一个严重遗漏，因为没有它，任何将完整OCL约束与外部模型对齐的尝试都依赖于特定于实现的魔法。因此，import语句是Eclipse OCL扩展，可能是未来OCL规范修订的一部分。</p>
<p>可以存在零个或多个import语句来指定外部模型元素的URI以及这些元素的别名。在示例中：</p>
<div class="literallayout">
<p>
<code class="code">import ecore：'http：//www.eclipse.org/emf/2002/Ecore#/'<br>

</code>
</p>
</div>
<p></p>
<p>
						
<code class="code">http://www.eclipse.org/emf/2002/Ecore</code>指定Ecore元模型的URI， <code class="code">#/</code>是导航到根元素（即Ecore包）的片段URI。<code class="code">ecore</code>指定此包的别名，该别名恰好与包的名称相同。在Complete OCL文档中，导入的模型元素可以通过其别名引用。
					</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>使用Ecore和UML绑定时，使用完整OCL文档的Java API支持需要特定于实现的魔法;必须通过调用代码将导入的模型加载到包注册表中。不使用导入语句。</p>
<p>在Juno发布之前，不了解import语句，因此Pivot和Ecore / UML绑定之间存在使用冲突。使用Xtext编辑器准备完整的OCL文档，或使用Pivot模型和Xtext解析器所需的import语句。但是重新使用Ecore和UML LPG解析器需要删除import语句。</p>
<p>在Juno中，LPG解析器忽略了import语句，因此它们可能会被保留。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="包上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="packagecontextdeclaration"></a>包上下文声明</h4>
</div>
</div>
</div>
<p>包上下文声明可以包括补充补充包中的模型元素的声明。</p>
<div class="literallayout">
<p>
<code class="code">包ecore<br>

<br>...<br>

<br>endpackage<br>

</code>
</p>
</div>
<p></p>
<p>这指定额外的完整OCL声明将补充<code class="code">ecore</code>包的预先存在的声明。
					</p>
<p>多个包上下文声明可用于补充多个包。</p>
<p>如果后续分类器上下文声明具有标识包的完全限定名称，则可以省略包上下文声明。</p>
</div>
<div class="section" title="分类器上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="classifiercontextdeclaration"></a>分类器上下文声明</h4>
</div>
</div>
</div>
<p>分类器上下文声明引入了补充分类器中的后续模型元素的声明。</p>
<div class="literallayout">
<p>
<code class="code">上下文EModelElement<br>

</code>
</p>
</div>
<p></p>
<p>分类器上下文由<code class="code">context</code>或<code class="code">endpackage</code>终止。
					</p>
</div>
<div class="section" title="功能定义">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="featuredefinitions"></a>功能定义</h4>
</div>
</div>
</div>
<p>可以定义其他操作和属性以在完整OCL文档中使用。可以使用这些特征，就好像它们是补充元模型的一部分一样。</p>
<div class="literallayout">
<p>
<code class="code">def：asError（verdict：Boolean）：Boolean =<br>如果判决然后是真的其他null endif<br>

<br>def：hasDerivation：Boolean = eAnnotations-&gt; select（source.startsWith（<br>'http://www.eclipse.org/emf/2002/Ecore/OCL'）） - &gt; notEmpty（）<br>

</code>
</p>
</div>
<p></p>
<p>定义以新功能名称开头，然后是操作参数和功能类型，后跟一个评估操作或属性的OCL表达式。</p>
<p>对于诸如<code class="code">hasDerivation</code>的属性，属性定义<code class="code">hasDerivation</code>与无参数操作定义<code class="code">hasDerivation()</code>之间的差异非常小。属性定义和用法是两个字符更短，可能看起来更自然。操作定义的优点是它可以在派生类中重载。
					</p>
</div>
<div class="section" title="类不变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="classinvariants"></a>类不变量</h4>
</div>
</div>
</div>
<p>可以对互补的元模型强加不变量。不变量包含不变量的名称，后跟一个OCL表达式，当满足不变量时，该表达式计算为true。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsTransient：hasDerivation意味着瞬态<br>

</code>
</p>
</div>
<p></p>
<p>在已加载补充完整OCL文档的应用程序中验证模型时，将执行这些不变量。在<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;Load Document Menu Action">OCL-&gt;加载文档菜单操作中</a>解释了这一点的<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;加载文档菜单操作">重要性</a> 。
					</p>
<p>通过使用let变量或重新使用<code class="code">hasDerivation</code> helper属性，可以显着增强约束的可读性。
					</p>
</div>
<div class="section" title="自定义消息">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="custommessages"></a>自定义消息</h4>
</div>
</div>
</div>
<p>Eclipse OCL支持对不变量的两个扩展，允许自定义验证失败消息和严重性。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsVolatile（<br>必须为派生特征'+ self.toString（））指定'“volatile”：<br>asError（hasDerivation意味着volatile）<br>

</code>
</p>
</div>
<p></p>
<p>不变名称后面可以是带括号的OCL表达式，该表达式计算要用作验证失败消息的String。</p>
<p>验证失败的严重性可以由不变表达式评估的非真值控制。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="code">false</code>返回表示警告严重性</p>
</li>
<li class="listitem">
<p><code class="code">null</code>返回表示错误严重性</p>
</li>
<li class="listitem">
<p><code class="code">invalid</code>返回表示致命严重性</p>
</li>
</ul>
</div>
<p>有关详细<a class="link" href="Integration.html#Integration-Messages" title="Custom Validation Messages">信息</a> ，请参阅<a class="link" href="Integration.html#Integration-Messages" title="自定义验证消息">自定义验证消息</a> 。
					</p>
</div>
<div class="section" title="操作和属性上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="operationandpropertycontextdeclarations"></a>操作和属性上下文声明</h4>
</div>
</div>
</div>
<p>完整的OCL还允许完成补充元模型中的不完整操作或属性声明。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可以为属性指定初始值表达式或派生值约束。</p>
</li>
<li class="listitem">
<p>可以为操作指定正文表达式和前置条件/后置条件约束。</p>
</li>
</ul>
</div>
<p>这些设施的用途有限，因为OCLinEcore避免了对不完整元模型的需求。</p>
</div>
</div>
<div class="section" title="OCL-&gt;加载文档菜单操作">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadCompleteOCLResource"></a> OCL-&gt;加载文档菜单操作</h3>
</div>
</div>
</div>
<p>上面的主要免责声明是，完整OCL仅补充了已加载完整OCL的应用程序中的补充元模型。</p>
<p>在Juno发布之前，这意味着Complete OCL仅可用于自定义Java应用程序，因为没有标准建模应用程序会加载补充文档。</p>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作使完整的OCL文档可以加载到各种应用程序中。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-load-complete-ocl-resource-menu.png"></div>
<p>
				
</p>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作被添加到应用程序的右按钮菜单中，可从当前选择访问ResourceSet。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>已经观察到额外的菜单操作并不总是立即可用，因此如果您没有看到它，请<span class="bold"><strong>按Esc</strong></span>取消菜单，选择与模型对象相对应的内容并再次右键单击。
					</p>
</blockquote>
</div>
<p></p>
<p>在火星中，合适的应用是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一个由Ecore元模型生成的编辑器</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>样本Ecore编辑器</p>
</li>
<li class="listitem">
<p>UML模型编辑器</p>
</li>
<li class="listitem">
<p>Papyrus模型编辑器</p>
</li>
<li class="listitem">
<p>你的模型编辑器</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>由Xtext生成的编辑器</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>Xtext编辑器</p>
</li>
<li class="listitem">
<p>MWE2编辑器</p>
</li>
<li class="listitem">
<p>OCLinEcore编辑器</p>
</li>
<li class="listitem">
<p>你的DSL编辑器</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作激活“ <span class="bold"><strong>加载完成OCL文档”</strong></span>对话框，您可以在其中浏览已注册的完整OCL文档，文件系统或工作区，以便加载一个或多个完整的OCL文档，或者通常可以更方便地拖动和从操作系统资源管理器或Eclipse Explorer中删除它们。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-load-complete-ocl-resource-dialog.png"></div>
<p>
				
</p>
<p>单击<span class="bold"><strong>确定</strong></span>后加载文档。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>在幕后，有必要围绕所有补充包安装全局包装器。这些包装器对已请求补充的ResourceSet敏感，因此尽管这会对在其他应用程序中使用补充包产生很小的性能损失，但它不应影响其他应用程序的功能行为。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="示例Ecore的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-EcoreComplements"></a>示例Ecore的完整OCL补充</h3>
</div>
</div>
</div>
<p>Sample Ecore Editor已经获得了许多有用的验证规则，因此对于许多用户而言，仅调用<span class="bold"><strong>Validate</strong></span>就足够了。但如果不是呢？也许您有一些希望应用的样式约定。也许内置规则是不够的。
				</p>
<p>在Juno和<span class="bold"><strong>OCL-&gt; Load Document</strong></span>功能之前，您唯一的选择是查看Ecore编辑器并创建自定义变体。现在，您可以使用Complete OCL扩展Sample Ecore Editor。
				</p>
<p>我们将重新访问我们刚刚检查过的<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>文档，并使用它来纠正Sample Ecore Editor对派生属性的不适当检查。该文档提供了六个不变量，其中至少有三个检测用户在Indigo发布周期中遇到的问题。
				</p>
<div class="section" title="DerivationIsVolatile">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsVolatile"></a> DerivationIsVolatile</h4>
</div>
</div>
</div>
<p>EMF代码生成模板具有<code class="code">volatile</code>的简单处理。非易失性变量具有由<code class="code">get</code>操作返回的关联字段。这会覆盖可能提供的任何派生。
					</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsVolatile：asError（hasDerivation意味着volatile）<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断如果EStructuralFeature具有派生，则还存在volatile声明以避免忽略派生。</p>
<p>此问题非常严重，基本表达式包含在<code class="code">asError</code>操作中，以将默认的<code class="code">true</code> / <code class="code">false</code> okay / warning severity转换为<code class="code">true</code> / <code class="code">null</code> okay / error severity。
					</p>
</div>
<div class="section" title="DerivationIsTransient">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsTransient"></a> DerivationIsTransient</h4>
</div>
</div>
</div>
<p>EMF代码生成模板具有类似的简单<code class="code">transient</code>处理。非瞬态变量将序列化为模型保存的一部分。这通常不合适，因为派生值是多余的，并且可以在再次加载模型时重新计算。
					</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsTransient：hasDerivation意味着瞬态<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断由于默认的非瞬态声明而导致派生未被序列化。</p>
</div>
<div class="section" title="DerivationIsNotComposed">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsNotComposed"></a> DerivationIsNotComposed</h4>
</div>
</div>
</div>
<p>组成由EMF直接处理，并且不清楚定义组成的替代含义是否合适。很可能EMF不允许使用备用语义。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsNotComposed：asError（hasDerivation意味着不包含）<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断派生是否试图指定备用组合语义，并在发生这种情况时报告错误。</p>
</div>
<div class="section" title="DerivationWithOppositeHasOppositeDerivation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationWithOppositeHasOppositeDerivation"></a> DerivationWithOppositeHasOppositeDerivation</h4>
</div>
</div>
</div>
<p>对立面也由EMF直接处理，但可以替换此功能。但是，如果替换了正向功能，则EMF的默认反向功能不太可能是合适的。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationWithOppositeHasOppositeDerivation：<br>hasDerivation和eOpposite &lt;&gt; null意味着eOpposite.hasDerivation<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断重新定义相反的前向语义的派生也重新定义了相应的反向语义。</p>
</div>
<div class="section" title="DerivationIsUninitialized">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsUninitialized"></a> DerivationIsUninitialized</h4>
</div>
</div>
</div>
<p>可以将属性的初始值指定为简单默认值或派生表达式。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsUninitialized：<br>hasDerivation意味着defaultValue.oclIsUndefined（）<br>

</code>
</p>
</div>
<p></p>
<p>我们希望通过默认值诊断派生表达式的遮挡。</p>
</div>
<div class="section" title="DerivationDoesNotResolveProxies">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationDoesNotResolveProxies"></a> DerivationDoesNotResolveProxies</h4>
</div>
</div>
</div>
<p>派生表达式不是引用。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationDoesNotResolveProxies：<br>hasDerivation意味着不是resolveProxies<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们可以诊断EMF代理解析逻辑是否未被抑制。</p>
</div>
</div>
<div class="section" title="使用额外的完整OCL验证Ecore">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-EcoreValidation"></a>使用额外的完整OCL验证Ecore</h3>
</div>
</div>
</div>
<p>在上<a class="link" href="CompleteOCLTutorial.html#CompleteOCLTutorial-EcoreComplements" title="示例Ecore的完整OCL补充">一节中，</a>我们描述了额外的完整OCL验证约束，以检测派生属性的样本Ecore诊断不足的问题。我们现在将这些约束应用于测试文件。
				</p>
<p>选择<span class="bold"><strong>EcoreTestFile.ecore</strong></span>并使用右键菜单<span class="bold"><strong>打开</strong></span> <span class="bold"><strong>With With</strong></span> <span class="bold"><strong>&gt; Sample Ecore Model Editor</strong></span> 。这可能是使用左键双击的默认设置，但如果使用OCLinEcore编辑器打开，则所需的验证将不起作用（在Juno中）。
				</p>
<p>现在右键单击Sample Ecore Editor窗格，如<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;加载文档菜单操作">OCL-&gt; Load Document Menu Action中所述，</a>并加载<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span> 。编辑器树中显示了一个额外的资源。
				</p>
<p>选择一个模型元素（如<span class="bold"><strong>Bad</strong></span>包）并使用右键菜单调用<span class="bold"><strong>Validate</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-validation.png"></div>
<p>
				
</p>
<p>这显示错误。根据约束的评估顺序，您可能还会看到一个或两个警告。您应该使用“ <a class="link" href="ValidityView.html" title="有效性观点（Luna中的新内容）">有效性视图”</a>查看所有故障。
				</p>
<p>如果我们现在使用OCLinEcore编辑器打开<span class="bold"><strong>EcoreTestFile.ecore</strong></span> ，我们可以看到<span class="bold"><strong>瞬态</strong></span> <span class="bold"><strong>和易失性</strong></span>关键字确实缺失。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-oclinecore.png"></div>
<p>
				
</p>
</div>
<div class="section" title="编辑完整的OCL">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-Updating"></a>编辑完整的OCL</h3>
</div>
</div>
</div>
<p>您可以编辑完整OCL以试验备用约束或消息。</p>
<p>然而，完整的OCL补充了元模型，EMF不支持元模型的实时修改。因此，必须重新启动Sample Ecore Editor并重新加载修改后的Complete OCL文档才能利用这些更改。</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>在将来的版本中可能会出现这种解决方案。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="示例UML的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-UMLComplements"></a>示例UML的完整OCL补充</h3>
</div>
</div>
</div>
<p><a class="link" href="CompleteOCLTutorial.html#CompleteOCLTutorial-EcoreValidation" title="使用额外的完整OCL验证Ecore">使用额外的完整OCL验证Ecore中</a>描述的Sample Ecore Editor验证的扩展适用于EMF工具生成的任何树编辑器。
				</p>
<p><span class="bold"><strong>ExtraUMLValidation.ocl</strong></span>文件提供了一个非常简单的样式检查，类名以大写字母开头。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-uml-content.png"></div>
<p>
				
</p>
<p>导入UML元模型并为Class分类器指定不变量，该分类器完全限定以避免需要周围的包上下文声明。</p>
<p>您可以使用UML模型编辑器打开<span class="bold"><strong>PapyrusTestFile.uml</strong></span> ，加载<span class="bold"><strong>ExtraUMLValidation.ocl</strong></span> ，选择<span class="bold"><strong>模型</strong></span> ，然后以与Ecore示例相同的方式<span class="bold"><strong>验证</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-uml-validation.png"></div>
<p>
				
</p>
<p>遗憾的是，Papyrus UML编辑器不使用EValidator框架，因此将完整的OCL文档加载到Papyrus中无法增强验证功能。要使用其他完整OCL功能，您可以在UML模型编辑器中加载和验证，然后启动Papyrus编辑器，然后在图表元素上显示问题标记。或者，您可以与Papyrus同时使用<a class="link" href="ValidityView.html" title="有效性观点（Luna中的新内容）">Validity View</a> 。
				</p>
</div>
<div class="section" title="示例Xtext的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-XtextComplements"></a>示例Xtext的完整OCL补充</h3>
</div>
</div>
</div>
<p>Xtext编辑器使用EValidator，因此可以将完整的OCL文档加载到Xtext编辑器中，包括Xtext本身，以提供增强的验证。</p>
<p><span class="bold"><strong>ExtraXtextValidation.ocl</strong></span>文件提供了一些演示样式检查。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-xtext-content.png"></div>
<p>
				
</p>
<p>导入Xtext根包并在<span class="bold"><strong>xtext</strong></span>包的包声明上下文中，为四个类提供不变量。这些都是约束如何使用Xtext模型的示例。不建议用户将所有这些约束用于真正的语法。
				</p>
<div class="section" title="NoAnonymousImports">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="NoAnonymousImports"></a> NoAnonymousImports</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context ReferencemMetamodel<br>inv NoAnonymousImports：别名&lt;&gt; null<br>

</code>
</p>
</div>
<p></p>
<p>此不变量诊断是否有任何import语句省略<code class="code">as xxxx</code>模型名称。
					</p>
</div>
<div class="section" title="NoActions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="NoActions"></a> NoActions</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">上下文行动<br>inv NoActions：false<br>

</code>
</p>
</div>
<p></p>
<p>只要使用<code class="code">{xxx}</code>操作语句，此不变量就会诊断出来。
					</p>
</div>
<div class="section" title="CamelCaseName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="CamelCaseName"></a> CamelCaseName</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context ParserRule<br>inv CamelCaseName：name.matches（'[AZ] [A-Za-z] *'）<br>

</code>
</p>
</div>
<p></p>
<p>此不变量验证解析器规则的名称以大写字母开头并仅使用字母。</p>
</div>
<div class="section" title="UpperName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="UpperName"></a> UpperName</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context xtext :: TerminalRule<br>inv UpperName：name = name.toUpperCase（）<br>

</code>
</p>
</div>
<p></p>
<p>此不变量验证终端规则的名称是否为大写。</p>
<p>您可以使用Xtext Editor打开<span class="bold"><strong>XtextTestFile.xtext</strong></span> ，加载<span class="bold"><strong>ExtraXtextValidation.ocl</strong></span> ，然后以与Ecore示例相同的方式<span class="bold"><strong>验证</strong></span> 。
					</p>
<p>其他验证在编辑器中显示为警告标记。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4300-extra-xtext-validation.png"></div>
<p>
					
</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>不幸的是，Xtext对于其Concrete Syntax树没有一个很好的toString（）方法，所以错误元素的描述有点不优雅。</p>
</blockquote>
</div>
<p></p>
<p>您可以编辑Xtext测试文件以删除import语句中的“as ecore”，并查看其他完整OCL约束是否有助于编辑器的持续功能。</p>
</div>
</div>
<div class="section" title="完整的OCL编辑器">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLEditor"></a>完整的OCL编辑器</h3>
</div>
</div>
</div>
<p>将为现有或新的* .ocl文件自动调用Complete OCL编辑器。您可以使用<span class="bold"><strong>New-&gt; File</strong></span>或部分内容文件使用<span class="bold"><strong>New-&gt; Other ...</strong></span>后跟<span class="bold"><strong>OCL</strong></span>和<span class="bold"><strong>Complete OCL File</strong></span>创建一个空文件。该编辑器基于Xtext，因此您可以在许多其他Eclipse编辑器中找到大多数工具。
				</p>
</div>
<div class="section" title="皇家和忠诚的例子">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="RoyalandLoyalExample"></a>皇家和忠诚的例子</h3>
</div>
</div>
</div>
<p>皇家和忠诚的例子首先由Jos Warmer和Anneke Kleppe在<span class="emphasis"><em>“对象约束语言：让你的模型为MDA做好准备”中提供</em></span> ，随后在许多教程中使用。该示例提供了完整OCL和基本OCL的实质示例。通过调用<span class="bold"><strong>New-&gt; Example ...-&gt; OCL（Object Constraint Language）插件</strong></span>可以获得这些模型。
				</p>
</div>
<div class="section" title="摘要">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Summary2"></a>摘要</h3>
</div>
</div>
</div>
<p>为了说明如何使用Complete OCL，我们有</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>检查了完整的OCL语言</p>
</li>
<li class="listitem">
<p>检查约束以纠正导出特征的Ecore验证不充分</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强Ecore模型的验证</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强UML模型的验证</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强Xtext语法的验证</p>
</li>
</ul>
</div>
</div>
</div>
</body>
</html>