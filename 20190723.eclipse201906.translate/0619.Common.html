<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>GEF通用开发人员文档</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<p>
			<em>非维基读者注意：本文档是从GEF@github.com维基生成的 - 如果您有更正或补充，如果您可以将它们贡献给<a href="https://github.com/eclipse/gef/wiki/Common" target="doc_external">原始维基页面，</a>那将非常棒</em> 。
		</p>
		<h2 id="introduction">介绍</h2>
		<p><span style="color:#5b8e92"><a href="Common.html">Common</a></span>组件提供了所有其他GEF组件可能使用的关键概念和基础结构。它内部由单个<strong><a href="Common.html#common">Common</a></strong>模块组成。
		</p>
		<p>
			<img alt="" border="0" src="images/common/components.common.jpeg">
		</p>
		<hr>
		<h2 id="common">共同</h2>
		<ul>
			<li>
				<strong>功能：org.eclipse.gef.common</strong>
			</li>
			<li>
				<strong>bundle：org.eclipse.gef.common</strong>
			</li>
		</ul>
		<p>在<a href="Common.html#common">通用</a>的模块<a href="Common.html">共同</a>提供了以下包中的基本抽象和相关的支持类：</p>
		<ul>
			<li>
				<a href="Common.html#activate">激活</a> ： <em>可激活</em>对象和相关支持类的一般抽象</li>
			<li>
				<a href="Common.html#adapt">Adapt</a> ： <em>适应性</em>对象和相关支持类的一般抽象</li>
			<li>
				<a href="Common.html#adaptinject">适应。注入</a> ：基于<a href="https://github.com/google/guice" target="doc_external">Google Guice</a>的支持，用于在适应性对象上注入和确定适配器</li>
			<li>
				<a href="Common.html#attributes">属性</a> ：属性存储的一般抽象</li>
			<li>
				<a href="Common.html#beansbinding">豆子。绑定</a> ： <a href="Common.html#beansproperty">Beans提供的属性的JavaFX样式绑定<a href="Common.html#beansproperty">。财产</a> 。
			</li>
			<li>
				<a href="Common.html#beansproperty">豆子。属性</a> ： <a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的 JavaFX样式属性<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>以及JavaFX的Set，List和Map集合属性的替换</li>
			<li>
				<a href="Common.html#beansvalue">豆子。值</a> ：与集合提供的<a href="Common.html#collections">集合</a>相关的可观察值抽象以及与<a href="Common.html#beansproperty">Bean提供的属性相关的可写值抽象<a href="Common.html#beansproperty">。财产</a> 。
			</li>
			<li>
				<a href="Common.html#collections">集合</a> ： <a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的 JavaFX样式可观察集合<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合和相关的侦听器抽象。
			</li>
			<li>
				<a href="Common.html#dispose">Dispose</a> ： <em>一次性</em>对象的一般抽象</li>
			<li>
				<a href="Common.html#reflect">反映</a> ：用于使用Java Reflection的实用程序类</li>
			<li>
				<em> </em>
			</li>
		</ul>
		<h3 id="activate">启用</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.activate</strong>
			</li>
		</ul>
		<p><a href="Common.html#activate">Activate</a>包为维护活动状态的对象（ <a href="Common.html#iactivatable">IActivatable</a> ）和支持类（ <a href="Common.html#activatablesupport">ActivatableSupport</a> ）提供了一般抽象，可以将其用作委托，简单地实现对其合同的<a href="Common.html#iactivatable">IActivatable赋予</a> 。
		</p>
		<h4 id="iactivatable">IActivatable</h4>
		<p><code>IActivatable</code>保持“活动”状态，可以激活和停用。<code>IActivatable</code>的活动状态通过（可观察的） <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyBooleanProperty.html" target="doc_external">javafx.beans.property公开。ReadOnlyBooleanProperty</a> ，因此侦听器可以轻松地观察活动状态。
		</p>
		<h4 id="activatablesupport">ActivatableSupport</h4>
		<p>为了强制执行<a href="Common.html#iactivatable">IActivatable的</a>实现者， <a href="Common.html#iactivatable">请</a>遵循上述合同，可以使用<code>ActivatableSupport</code> 。它没有正式实现<a href="Common.html#iactivatable">IActivatable</a>接口，但为其所有方法提供了实现，因此可以简单地用作委托，如下所示：</p>
		<pre><code>public class MyActivatable实现IActivatable {//创建委托私有ActivatableSupport acs = new ActivatableSupport（this）; public void activate（）{acs.activate（null / * pre-activation hook * /，this :: doActivate / * post-activation hook * /）; } ...}</code></pre>
		<hr>
		<h3 id="adapt">适应</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.adapt</strong>
			</li>
		</ul>
		<p><a href="Common.html#adapt">Adapt</a>包提供了对<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">org.eclipse.core.runtime的现代化解释<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">。IAdaptable</a> 。这个扩展背后的动机和简短的概述在<a href="http://nyssen.blogspot.de/2014/11/iadaptable-gef4s-interpretation-of.html" target="doc_external">IAdaptable中</a>给出<a href="http://nyssen.blogspot.de/2014/11/iadaptable-gef4s-interpretation-of.html" target="doc_external">-  GEF的经典解释</a> 。具体而言， <a href="Common.html#adapt">Adapt</a>提供的增强功能包括：</p>
		<ol>
			<li>可以通过<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect注册和检索适配器<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">。TypeToken</a>键作为Class键的替代，它确保具有参数化类型的适配器也可以以类型安全的方式注册和检索，而不仅仅是通过其原始类型。例如，一个适配器实例<em>A1</em>参数化类型<em>A &lt;T1&gt;</em>的和<em>a2</em> <em>A</em>型<em>&lt;T2&gt;</em>的一个实例都可以在注册<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a> 。<a href="MVC.html">MVC</a>组件在注册提供者（即提供者&lt;？）时会密切利用这一点。扩展IGeometry&gt;和提供者&lt;？扩展IFXAnchor&gt;可以同时在IVisualPart注册。
			</li>
			<li>可以（可选地）通过提供附加角色密钥来注册和检索适配器，其允许在<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>处注册多个相同类型的适配器（使用不同的角色）。例如，类型<em>A的</em>适配器实例<em>a1</em>和<em>a2</em>都可以使用不同的角色在adaptable上注册。在注册提供者时， <a href="MVC.html">MVC</a>组件再次使用它。不同的几何提供商（提供商&lt;？扩展IGeometry&gt;）例如通过向各个提供者注册各自的角色来注册用于选择和悬停反馈。
			</li>
			<li>适配器可以通过实现相应的后接口（ <a href="Common.html#iadaptablebound">IAdaptable ，请求）对它们在其注册的相应<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>进行反向引用<a href="Common.html#iadaptablebound">。绑定</a> ）。同样，这在<a href="MVC.html">MVC中</a>被广泛使用，其中例如IBehavior或IPolicy需要知道它注册的主机IVisualPart。
			</li>
			<li>IAdaptable支持注册属性更改侦听器，以便在注册或取消注册适配器时得到通知。</li>
		</ol>
		<p>除了<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ， <a href="Common.html#iadaptablebound">IAdaptable。Bound</a>和<a href="Common.html#iadaptable-adapterkey">AdapterKey</a>抽象形式化了现代化的自适应模式，该软件包还提供了一个支持类（ <a href="Common.html#adaptablesupport">AdaptableSupport</a> ）来实现符合其合同的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ，以及一个独立的实现（ <a href="Common.html#adapterstore">AdapterStore</a> ）。
		</p>
		<h4 id="iadaptable-adapterkey">IAdaptable，AdapterKey</h4>
		<p><code>IAdaptable</code>提供了注册适配器的功能，并通过类型键（ <a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang）的组合来检索它们<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。Class</a>或<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect。TypeToken</a> ）和（可选） <a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang。字符串</a>角色，它们组合在<code>AdapterKey</code> 。可以选择使用<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect。TypeToken</a>而不是简单的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang。类</a>密钥，支持使用参数化类型的类型安全检索适配器。与附加（可选）角色的组合使得可以在<code>IAdaptable</code>处注册多个相同类型的适配器。
		</p>
		<p>Eclipse Core Runtime <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">org.eclipse.core.runtime提供的“传统”getAdapter（Class &lt;T&gt;）方法<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">。这里的IAdaptable</a>只是一个简便的操作，它将检索用相应的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang注册的单个适配器<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。类</a>键和<em>默认</em>角色（或在给定的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang下注册的唯一适配器<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。类</a>密钥，如果该类型密钥只有一个适配器）。
		</p>
		<p>在从<code>IAdaptable</code>检索适配器之前，必须注册它们。注册再次包含一个角色（如果未提供角色，则使用“默认”角色），并且可能需要通过<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect获取有关实际适配器类型的其他信息<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">。TypeToken</a> 。如果无法从注册的适配器实例本身推断出这种附加类型信息（参数化类型就是这种情况）。
		</p>
		<p>因此，现在可以通过各种方式注册和检索适配器：</p>
		<pre><code>//在'default'角色下注册并检索原始类型'A'的适配器'a'（不需要输入信息）adaptable.setAdapter（a）; A = adaptable.getAdapter（A.class）; //在'default'角色下注册并检索参数化类型'A &lt;T&gt;'的适配器'a'（需要输入信息）adaptable.setAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，a）; A &lt;T&gt; a = adaptable.getAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}）; //在角色'a1'下注册并检索原始类型'A'的适配器'a'（不需要输入信息）adaptable.setAdapter（a，“a1”）; A = adaptable.getAdapter（AdapterKey.get（A.class，“a1”））; //在角色'a1'下注册并检索参数化类型'A &lt;T&gt;'的适配器'a'（需要输入信息）adaptable.setAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，a，“a1” ）; A = adaptable.getAdapter（AdapterKey.get（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，“a1”））;</code></pre>
		<p>为了正式支持通知侦听器注册和取消注册适配器， <code>IAdaptable</code>通过<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">javafx.collections提供其适配器<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">。ObservableMap</a>和（不可修改的） <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapProperty.html" target="doc_external">javafx.beans.property。ReadOnlyMapProperty</a> 。
		</p>
		<h4 id="iadaptable-bound">IAdaptable的。界</h4>
		<p>要形式化适配器可能需要获取<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>的后引用， <code>IAdaptable.Bound</code>接口被引入。如果适配器实现此接口，则适配器注册的适应性负责提供适配器的后向引用，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {public &lt;T&gt; void setAdapter（T adapter）{...if（适配器instanceof IAdaptable。约束）{（（IAdaptable。绑定&lt;A&gt;）适配器）.setAdaptable（this）; ...} public &lt;T&gt; void unsetAdapter（T adapter）{...if（适配器instanceof IAdaptable。约束）{（（IAdaptable。绑定&lt;A&gt;）适配器）.setAdaptable（null）; } ...} ...}</code></pre>
		<h4 id="adaptablesupport">AdaptableSupport</h4>
		<p>为了强制执行<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实施者，请遵循上述合同，可以使用<code>AdaptableSupport</code> 。它没有正式实现<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>接口，但为其所有方法提供了实现，因此可以简单地用作委托，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {//创建委托私有AdaptableSupport &lt;MyAdaptable&gt; ads = new AdaptableSupport &lt;MyAdaptable&gt;（this）; public &lt;T&gt; T getAdapter（AdapterKey &lt;T&gt; key）{return ads.getAdapter（key）; } ...}</code></pre>
		<h4 id="adapterstore">AdapterStore</h4>
		<p><code>AdaptableStore</code>是一个可以独立使用的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现。
		</p>
		<hr>
		<h3 id="adapt-inject">适应。注入</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.adapt.inject</strong>
			</li>
		</ul>
		<p><a href="Common.html#adaptinject">适应。Inject</a>包含基于<a href="https://github.com/google/guice" target="doc_external">Google Guice</a>的支持，用于将适配器注入<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> 。也就是说，如果<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现在其&lt;T&gt; setAdapter（TypeToken &lt;T&gt;，T，String）方法上提供@InjectAdapters注释，并且在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com中提供了使用@AdapterMap注释限定的相应适配器（映射）绑定<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。 google.inject。模块</a> ，适配器实例可以自动注入<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实例。需要指出的是，各种适配器（映射）绑定是以多态方式进行评估的，即具体的自适应也将注入所有注册其超类型的适配器。
		</p>
		<p>除了对适配器的基本注入支持之外，该包还支持通过专用的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">com.google.inject对在<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>的（传递）上下文中注入的所有对象进行作用域<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">。范围</a> （ <a href="Common.html#adaptablescope-adaptablescopes">AdaptableScope</a> ）。
		</p>
		<h4 id="adapterinjectionsupport-adaptabletypelistener-adapterinjector">AdapterInjectionSupport，AdaptableTypeListener，AdapterInjector</h4>
		<p>要启用将适配器注入<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ，特定的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/spi/TypeListener.html" target="doc_external">com.google.inject.spi。需要在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中注册TypeListener</a> （ <code>AdaptableTypeListener</code> ） <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> 。为确保正确完成此操作，请使用相应的支持<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject。提供了模块</a> ，即<code>AdapterInjectionSupport</code> ，可以轻松集成到自定义的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中。模块</a>如下：</p>
		<pre><code>public class MyModule extends AbstractModule {@Override protected void configure（）{// register adapter map injection support install（new AdapterInjectionSupport（））; ...}}</code></pre>
		<p>这将确保<code>AdaptableTypeListener</code>正确注册（并自行注入）。<code>AdaptableTypeListener</code>将注册专用的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/MembersInjector.html" target="doc_external">com.google.inject。在它遇到的所有合适的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现上的MembersInjector</a> （ <code>AdapterInjector</code> ）。
		</p>
		<h4 id="injectadapters">@InjectAdapters</h4>
		<p>在相应的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现中指定注入点（即&lt;T&gt; setAdapter（TypeToken &lt;T&gt;，T，String）方法是通过添加@InjectAdapters注释来实现的，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {@InjectAdapters public &lt;T&gt; void setAdapter（TypeToken &lt;T&gt; adapterType，T adapter，String role）{...}}</code></pre>
		<h4 id="adaptermap-adaptermaps">AdapterMap，AdapterMaps</h4>
		<p>指定要注入的适配器是通过<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中的映射绑定来执行的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> ，使用@AdapterMap注释进行限定。如果无法从适配器实例本身或相应的绑定推断出要注册的适配器的实际类型，则必须通过所有绑定中使用的<a href="Common.html#iadaptable-adapterkey">AdapterKey</a>提供有关实际适配器类型的信息。在可以从实例或绑定本身推断出适配器的类型的情况下，可以省略它。
		</p>
		<pre><code>公共类MyModule扩展AbstractModule {@Override protected void configure（）{...//获取一个map binder来绑定各个IAdaptable类型的适配器。MapBinder &lt;AdapterKey &lt;？&gt;，Object&gt; adapterMapBinder = AdapterMaps.getAdapterMapBinder（binder（），MyAdaptable.class）; //为每个MyAdaptable实例添加带有'default'角色的原始类型'A'的适配器'a'的适配器（映射）绑定; //类型信息可以省略，因为它可以从适配器实例adapterMapBinder.addBinding（AdapterKey.defaultRole（））。toInstance（a）; //添加适配器（map）绑定，用于将具有角色'r'的原始类型'A'的实例绑定到每个MyAdaptable实例; //类型信息可以省略，因为它可以从绑定adapterMapBinder.addBinding（AdapterKey.role（“r”）。to（A.class）; //为绑定适配器'a'添加适配器（map）绑定推断出来参数化类型'A &lt;T&gt;'对每个MyAdaptable实例具有'default'角色; //类型信息是必需的，因为它不能从适配器实例推断，也不能从绑定adapterMapBinder.addBinding推断（AdapterKey.get（new TypeToken） &lt;A &lt;T &gt;&gt;（）{}））。toInstance（a）; ...}}</code></pre>
		<p>在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中正确启用适配器映射注入时<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> ，通过<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Injector.html" target="doc_external">com.google.inject创建的所有合适的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实例<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Injector.html" target="doc_external">。Injector</a> ，它知道各自的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject。模块</a> ，将被注入。
		</p>
		<p>为此，可以将<code>@AdapterMap</code>与Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/name/Named.html" target="doc_external">@Named</a> <code>@AdapterMap</code>进行比较，只与<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang进行比较。类</a>而不是<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang。使用字符串</a>键。但是， <code>@AdapterMap</code>更强大，因为它们是多态的。也就是说，如果为特定的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>指定了绑定，让我们说'A'，它将被评估为'A'的所有子类型的实例，只要它们适合注入（即它们直接或通过继承）提供适合注入适配器的相应方法）。这是一个非常强大的机制，由<a href="MVC.html">MVC</a>组件密集使用。它允许为某些抽象基类型注册某些适配器，以便为每个具体子类型注入相应的适配器实例。
		</p>
		<p>此外，适配器映射绑定可以是有条件的，通过使用（传递）自适应类型和角色对它们进行限定。然后仅在要注入的自适应适配器链中存在指定类型的适应性（其本身在特定角色下适应）的情况下才评估相应的绑定。潜在的用例是为各个查看者中的可视部分绑定不同的行为和策略：</p>
		<pre><code>//内容查看器中与GeometricShapePart相关的绑定bindGeometricShapePartAdaptersInContentViewerContext（AdapterMaps.getAdapterMapBinder（binder（），GeometricShapePart.class，AdapterKey.get（IViewer.class，CONTENT_VIEWER_ROLE）））; //调色板查看器中与GeometricShapePart相关的绑定bindGeometricShapePartAdapterInPaletteViewerContext（AdapterMaps.getAdapterMapBinder（binder（），GeometricShapePart.class，AdapterKey.get（IViewer.class，PALETTE_VIEWER_ROLE）））;</code></pre>
		<p>如果适配器映射绑定是有条件的，则AdapterInjector会推迟其注入，直到建立完整的自适应适配器链。</p>
		<h4 id="adaptablescope-adaptablescopes">AdaptableScope，AdaptableScopes</h4>
		<p><code>AdaptableScope</code>是一个Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">com.google.inject。范围</a>绑定到一个<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实例。它可用于在注入期间对对象实例（不限于适配器）进行范围调整。要启用此功能，绑定必须是“作用域”，并且必须在触发注入适配器之前为相应的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实例输入范围（使用<code>AdaptableScopes</code>支持类最好支持）。
		</p>
		<p>范围绑定可以简单地在Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中执行<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a>如下：</p>
		<pre><code>公共类MyModule扩展AbstractModule {@Override protected void configure（）{...//在IAdaptable'A'的上下文中，重用一个'B'binder（）类型的实例.bind（B.class）.in（AdaptableScopes.typed（A.class））; ...}}</code></pre>
		<p>通过AdapterInjector在内部执行相应的AdaptableScope。</p>
		<hr>
		<h3 id="attributes">属性</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.common.attributes</strong>
			</li>
		</ul>
		<p><a href="Common.html#attributes">Attributes</a>包提供基于字符串键（对象）属性的抽象。
		</p>
		<h4 id="iattributestore">IAttributeStore</h4>
		<p><code>IAttributeStore</code>是一种通用抽象，为存储和检索<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Object.html" target="doc_external">java.lang提供支持<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Object.html" target="doc_external">。通过<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang的 对象</a>属性<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">。字符串</a>键以（可观察的）映射属性的形式。
		</p>
		<h4 id="iattributecopier">IAttributeCopier</h4>
		<p><code>IAttributeCopier</code>是复制器的通用抽象，可以将属性从一个<a href="Common.html#iattributestore">IAttributeStore</a>传输/复制到另一个。它提供静态<code>NULL_COPY</code>和<code>SHALLOW_COPY</code>默认复制器实现。
		</p>
		<hr>
		<h3 id="beans-binding">豆子。捆绑</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.binding</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansbinding">豆子。绑定</a>包为<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect提供绑定实现<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合，以及JavaFX（内部）表达式助手类的替换，由<a href="Common.html#beansproperty">Beans提供的JavaFX属性替换类使用<a href="Common.html#beansproperty">。财产</a> 。
		</p>
		<hr>
		<h3 id="beans-property">豆子。属性</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.property</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansproperty">豆子。Property</a>包为<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect提供（可观察的）属性抽象和实现<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合，以及JavaFX的list，set和map属性基类的<a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapPropertyBase.html" target="doc_external">替换 （ <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlyMapPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyListPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlyListPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlySetPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlySetPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleMapProperty.html" target="doc_external">javafx.beans.property。SimpleMapProperty</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleListProperty.html" target="doc_external">javafx.beans.property。SimpleListProperty</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleSetProperty.html" target="doc_external">javafx.beans.property。SimpleSetProperty</a> ）。
		</p>
		<p>关于如何使用<a href="Common.html#beansproperty">Beans提供的属性的一个很好的概述<a href="Common.html#beansproperty">。属性</a>在<a href="http://nyssen.blogspot.de/2016/04/gef4-common-collections-and-properties.html" target="doc_external">GEF Common Collections and Properties中给出 -  Guava为FX</a> 。</p>
		<hr>
		<h3 id="beans-value">豆子。值</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.value</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansvalue">豆子。Value</a>包提供与<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect相关的ObservableValue和WritableValue抽象<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合。这些是由<a href="Common.html#collections">Collections</a>和<a href="Common.html#beansproperty">Beans提供的可观察集合和属性实现的<a href="Common.html#beansproperty">。财产</a> 。
		</p>
		<hr>
		<h3 id="collections">集合</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.collections</strong>
			</li>
		</ul>
		<p><a href="Common.html#collections">Collections</a>包提供了<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合以及一个实用程序类，通过它可以实例化这些可观察集合以及JavaFX可观察集合（修复某些问题）的替换。
		</p>
		<p>有关如何使用Collections提供的<a href="Common.html#collections">集合的详细</a>概述以及有关JavaFX提供的集合的添加和变通方法的一些见解，请参阅<a href="http://nyssen.blogspot.de/2016/04/gef4-common-collections-and-properties.html" target="doc_external">GEF Common Collections和Properties  -  Guava goes FX</a> 。</p>
		<h4 id="collectionutils">CollectionUtils</h4>
		<p>
			<code>CollectionUtils</code>是一个增强<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">javafx.collections的实用程序类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">。FXCollections</a> 。它提供静态实用程序方法来为<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect创建可观察的等效项<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a> ，以及提供的JavaFX集合的替换类。
		</p>
		<h4 id="observablemultiset-observablemultisetwrapper-unmodifiableobservablemultisetwrapper">ObservableMultiset，ObservableMultisetWrapper，UnmodifiableObservableMultisetWrapper</h4>
		<p>
			<code>ObservableMultiset</code>是<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。具有JavaFX可观察集合风格的Multiset</a> 。有两个具体的（内部）实现， <code>ObservableMultisetWrapper</code>以及<code>UnmodifiableObservableMultisetWrapper</code> ，它们不应该直接访问，而是可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的实用程序操作创建。
		</p>
		<h4 id="observablesetmultimap-observablesetmultimapwrapper-unmodifiableobservablesetmultimapwrapper">ObservableSetMultimap，ObservableSetMultimapWrapper，UnmodifiableObservableSetMultimapWrapper</h4>
		<p>
			<code>ObservableSetMultimap</code>是<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">。SetMultimap</a>采用JavaFX可观察集合的样式。有两个具体的（内部）实现， <code>ObservableSetMultimapWrapper</code>以及<code>UnmodifiableObservableSetMultimapWrapper</code> ，它们不应该直接访问，而是可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的实用程序操作创建。
		</p>
		<h4 id="multisetlistenerhelper-setmultimaplistenerhelper">MultisetListenerHelper，SetMultimapListenerHelper</h4>
		<p>的<code>MultisetListenerHelper</code>和<code>SetMultimapListenerHelper</code>是由内部使用（内部）委托类<a href="Common.html#observablemultiset-observablemultisetwrapper-unmodifiableobservablemultisetwrapper">ObservableMultiset</a>和<a href="Common.html#beansbinding">\ #ObservableSetMultimap，ObservableSetMultimapWrapper，UnmodifiableObservableSetMultimapWrapper | ObservableSetMultimap]]，以及[豆中的相关属性和绑定。捆绑</a>和<a href="Common.html#beansproperty">豆类。维护和通知已注册听众的属性</a> 。
		</p>
		<h4 id="observablelistwrapperex">ObservableListWrapperEx</h4>
		<p>
			<code>ObservableListWrapperEx</code>是<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">javafx.collections返回的ObservableListWrapper的（内部）替换类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">。FXCollections</a>在其效用函数中与可观察列表相关。它可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的各种实用方法构建。
		</p>
		<h4 id="listlistenerhelperex-setlistenerhelperex-maplistenerhelperex">ListListenerHelperEx，SetListenerHelperEx，MapListenerHelperEx</h4>
		<p><code>ListListenerHelperEx</code> ， <code>SetListenerHelperEx</code>和<code>MapListenerHelperEx</code>是（内部）委托类，它们替换为<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableList.html" target="doc_external">javafx.collections提供的JavaFX实现在内部使用的相应委托类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableList.html" target="doc_external">。ObservableList</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableSet.html" target="doc_external">javafx.collections。ObservableSet</a>和<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">javafx.collections。ObservableMap</a> 。它们由<a href="Common.html#observablelistwrapperex">ObservableListWrapperEx</a>以及<a href="Common.html#beansbinding">Beans提供的替换使用<a href="Common.html#beansbinding">。捆绑</a>和<a href="Common.html#beansproperty">豆类。财产</a> 。
		</p>
		<hr>
		<h3 id="dispose">部署</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.dispose</strong>
			</li>
		</ul>
		<p><a href="Common.html#dispose">Dispose</a>包为<a href="Common.html#dispose">处理</a>时需要通知的对象提供抽象（ <a href="Common.html#idisposable">IDisposable</a> ）。
		</p>
		<h4 id="idisposable">IDisposable的</h4>
		<p>需要处理<code>IDisposable</code> 。虽然<code>IDisposable</code>封装了处理时必须执行的必要步骤，但处理的启动留给了客户。
		</p>
		<hr>
		<h3 id="reflect">反映</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.reflect</strong>
			</li>
		</ul>
		<p><a href="Common.html#reflect">Reflect</a>包提供了一个实用程序类（ <a href="Common.html#reflectionutils">ReflectionUtils</a> ），它在Java反射的上下文中提供了便利操作。
		</p>
		<h4 id="types">类型</h4>
		<p><code>Types</code>实用程序为处理不同的TypeToken实现提供支持。
		</p>
		<h4 id="reflectionutils">ReflectionUtils</h4>
		<p><code>ReflectionUtils</code>实用程序支持通过Java反射获取和设置私有字段的值。
		</p>
	</body>
</html>