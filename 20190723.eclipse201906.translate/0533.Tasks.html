<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>EGit用户指南 - 任务</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">任务</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="以前" border="0" src="../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Reference.html" title="参考">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">概念</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">参考</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Tasks">任务</h1>
		<h2 id="Creating_Repositories">创建存储库</h2>
		<h3 id="Considerations_for_Git_Repositories_to_be_used_in_Eclipse">在Eclipse中使用的Git存储库的注意事项</h3>
		<h4 id="The_short_story">短篇小说</h4>
		<p>使用EGit设置Git存储库时，有两个建议用于创建“生产”（而不是“游乐场”）存储库：</p>
		<ul>
			<li>不要在Eclipse工作区中创建存储库。
				<ul>
					<li>克隆或创建存储库时要小心。</li>
					<li>确保正确使用Git共享向导。</li>
				</ul>
			</li>
			<li>不要以root用户身份使用Eclipse项目创建存储库。
				<ul>
					<li>确保正确使用Git共享向导。</li>
				</ul>
			</li>
		</ul>
		<p>在克隆或创建存储库期间指定工作空间文件夹时，会发生第一个错误。</p>
		<p>当您在工作区中手动创建的Eclipse项目使用Git共享向导时，如果不采取预防措施（在最新版本中已修复该向导），则会发生这两个错误。</p>
		<p>您将在下面找到这些建议的一些动机。</p>
		<h4 id="The_longer_story">更长的故事</h4>
		<h5 id="Eclipse_Workspace_and_Repository_working_directory">Eclipse Workspace和Repository工作目录</h5>
		<p>Git存储库可以以不同的方式创建，例如通过从现有存储库克隆，从头开始创建，或使用EGit共享向导。</p>
		<p>在任何情况下（除非你创建一个“裸”存储库，但这里没有讨论），新的存储库本质上是本地硬盘上的一个文件夹，其中包含“工作目录”和元数据文件夹。元数据文件夹是名为“.git”的专用子文件夹，通常称为“.git-folder”。它包含实际的存储库（即提交，引用，日志等）。</p>
		<p>元数据文件夹对Git客户端完全透明，而工作目录用于将当前检出的存储库内容公开为工具和编辑器的文件。</p>
		<p>通常，如果要在Eclipse中使用这些文件，则必须以某种方式将它们导入Eclipse工作空间。为此，最简单的方法是检入.project文件，“导入现有项目”向导可以从中轻松创建项目。因此，在大多数情况下，包含Eclipse项目的Repository的结构看起来类似于以下内容：</p>
		<p>
			<img border="0" src="images/EGit-0.12-SetupRepo-RepoStructureTwoProjects.jpg">
		</p>
		<h5 id="Implications">启示</h5>
		<p>以上含有以下含义：</p>
		<ul>
			<li>将项目作为存储库的根文件夹可能不是一个好主意。</li>
		</ul>
		<dl>
			<dd>原因是您永远无法将另一个项目添加到此存储库，因为.project文件将占用根文件夹;你仍然可以将项目添加为子文件夹，但是这种项目嵌套已知会在整个地方引起很多问题。要添加另一个项目，您必须将项目移动到存储库中的子文件夹，并将第二个项目添加为另一个子文件夹，然后才能提交此更改。</dd>
		</dl>
		<ul>
			<li>将您的存储库保留在Eclipse Workspace之外是个好主意。</li>
		</ul>
		<dl>
			<dd>有几个原因：</dd>
		</dl>
		<dl>
			<dd>新的Repository会将Eclipse工作区的完整文件夹结构视为（潜在）内容。这可能会导致性能问题，例如在提交之前计算更改时（例如，将扫描完整的.metadata文件夹）;通常，工作空间将包含死文件夹（例如已删除的项目），这些文件在语义上与EGit无关，但不能轻易排除。</dd>
		</dl>
		<dl>
			<dd>元数据（.git-）文件夹将是Eclipse Workspace的子文件夹。目前还不清楚这是否会导致Eclipse不必要的文件夹遍历。</dd>
		</dl>
		<dl>
			<dd>您可以通过销毁Eclipse Workspace轻松销毁存储库。</dd>
		</dl>
		<h3 id="Creating_a_new_empty_Git_Repository">创建一个新的空Git存储库</h3>
		<p>您可以先创建项目并在之后共享。共享项目向导支持创建Git存储库（请参阅<a href="http://wiki.eclipse.org/EGit/User_Guide/Sharing#Adding_a_project_to_version_control" title="EGit /用户指南/共享＃Adding_a_project_to_version_control" target="egit_external">将项目添加到版本控制</a> ）。
		</p>
		<p>您还可以从Git存储库视图创建一个新的空Git存储库（请参阅<a href="#Creating_a_Repository" title="例如：It / User_Guide＃Creating_a_Repository">创建存储库</a> ）。
		</p>
		<h3 id="Creating_a_Git_Repository_for_multiple_Projects">为多个项目创建Git存储库</h3>
		<p>您可以在公共目录下创建多个项目，然后一次性为所有项目创建公共存储库：</p>
		<ul>
			<li>在公共目录下创建Eclipse项目（例如a，b，c）（例如<span style="font-family:monospace">/ repos / examples /</span> ）</li>
			<li>选择所有项目（a，b，c），然后在上下文菜单中单击<b>Team&gt; Share Project&gt; Git</b>
			</li>
			<li>按<b>下一步</b>
			</li>
			<li>选择所有项目（a，b，c）</li>
			<li>由于已选择多个项目，向导会自动将默认存储库位置向上移动到父文件夹<span style="font-family:monospace">/ repos / examples /</span></li>
			<li>单击<b>Create Repository</b>并<b>Finish</b>
			</li>
		</ul>
		<p>
			<br>
		</p>
		<h2 id="Starting_from_existing_Git_Repositories">从现有的Git存储库开始</h2>
		<p>为了在Eclipse工作台中使用Git存储库的内容，必须将包含的文件和文件夹作为项目导入。原则上，这个导入可以使用通用的“New Project”或“Import ...”向导来完成，因为Git Repository的工作目录只是本地文件系统中的普通目录。但是，新创建的项目仍然需要与Git手动共享。“从Git导入项目”向导集成了项目导入和共享，并提供了一些额外的便利。</p>
		<h3 id="Starting_the_import_wizard">启动导入向导</h3>
		<p>要启动向导，请单击<b>Git中的Import&gt; Git&gt; Projects</b> 。
		</p>
		<p>如果您在干净的工作区中启动，则第一页将显示一个空列表：</p>
		<p>
			<img border="0" src="images/Egit-0.9-import-projects-select-repository.png">
		</p>
		<p>在继续之前，您需要将一个或多个Git存储库添加到列表中。如果列表中已有存储库，则此步骤是可选的。</p>
		<h3 id="Cloning_or_adding_Repositories">克隆或添加存储库</h3>
		<p>有两种方法可以将Git存储库添加到列表中：</p>
		<ol>
			<li>克隆远程存储库</li>
			<li>从本地文件系统添加现有存储库</li>
		</ol>
		<h4 id="Cloning_a_Repository">克隆存储库</h4>
		<p>如果从远程存储库开始，则使用第一个选项。克隆操作会将该存储库复制到本地文件系统。要启动克隆向导，请单击<b>克隆....</b><a href="#Cloning_Remote_Repositories" title="EGit /用户指南#Cloning_Remote_Repositories">克隆远程存储库</a>中更详细地描述了克隆向导。成功完成克隆操作后，新克隆的存储库将自动显示在列表中。
		</p>
		<h4 id="Adding_a_Repository">添加存储库</h4>
		<p>如果您已在本地文件系统中安装了存储库，则第二个选项很有用，例如，因为您之前已经克隆过它，您是从头创建它，或者是从其他地方复制它。单击<b>添加...</b> ;并选择本地文件系统中的目录。按<b>搜索</b>以触发扫描此目录中包含的Git存储库。如果找到Git存储库，则会列出它们，您可以选择要添加的存储库：</p>
		<p>
			<img border="0" src="images/Egit-0.11-import-projects-add-dialog.png">
		</p>
		<p>成功完成后，存储库列表应包含一些存储库：</p>
		<p>
			<img border="0" src="images/Egit-0.11-import-projects-filled-list.png">
		</p>
		<h3 id="Selecting_a_Repository_from_the_List">从列表中选择存储库</h3>
		<p>您现在可以选择存储库并单击“ <b>下一步”</b> 。在以下向导页面上，您将决定如何导入项目。
		</p>
		<h3 id="Importing_projects">导入项目</h3>
		<p>此页面提供了一个带有单选按钮的组，允许您选择向导和目录树，可选择允许您在工作目录中选择一个文件夹。</p>
		<p>
			<img border="0" src="images/Egit-0.11-import-projects-select-wizard.png">
		</p>
		<h3 id="Wizard_for_project_import">项目导入向导</h3>
		<h4 id="Import_Existing_Projects">导入现有项目</h4>
		<p>如果选中此单选按钮，向导将扫描本地文件系统中的<tt>.project</tt>文件并显示找到的项目。这是最舒适的解决方案，如果将<tt>.project</tt>文件签入存储库，则应使用此解决方案。</p>
		<h5 id="Limiting_the_Scope_for_Project_Import">限制项目导入的范围</h5>
		<p>在这种情况下，底部的目录树是活动的。您可以通过选择此树中的文件夹来限制搜索<tt>.project</tt>文件，否则将扫描存储库的完整工作目录。在下一页上，将显示找到的项目列表（如果有）。这与通用的“ <b>导入现有项目”</b>向导非常相似，但具有一些额外的过滤功能：</p>
		<p>
			<img border="0" src="images/Egit-0.9-import-projects-select-projects.png">
		</p>
		<h4 id="Use_the_New_Projects_Wizard">使用“新建项目向导”</h4>
		<p>选择此选项后，将打开通用“新建项目”向导。完成“新建项目”向导后，“从Git导入项目”向导将恢复并协助共享您刚刚创建的项目。</p>
		<p>在这种情况下，底部的目录树处于非活动状态，因为该选择与“新建项目”向导无关。</p>
		<h4 id="Import_as_General_Project">导入为一般项目</h4>
		<p>当既没有<tt>.project</tt>文件也没有合适的“New Project”向导时，此选项会很有用。如果选择，向导将生成<tt>.project</tt>文件并将项目指向Repository工作目录的文件夹。结果是“一般项目”。</p>
		<p>默认情况下，新生成的项目将指向存储库的工作目录。通过从底部的目录树中选择一些文件夹，您可以为该文件夹生成项目。</p>
		<p>单击“ <b>下一步”</b>打开一个简单的对话框，输入新项目的名称和目录：</p>
		<p>
			<img border="0" src="images/Egit-0.9-import-projects-general-project.png">
		</p>
		<p>默认情况下，建议的项目名称与目录名称匹配。&lt;br /&gt;</p>
		<h2 id="Working_with_remote_Repositories">使用远程存储库</h2>
		<h3 id="Cloning_Remote_Repositories">克隆远程存储库</h3>
		<p>使用Git克隆向导，您可以使用不同的传输协议克隆远程存储库。</p>
		<p>可以使用“从Git导入项目”向导启动向导<br>

			<b>文件&gt;导入...&gt; Git&gt; Git中的项目&gt;下一步&gt;克隆URI&gt;下一步</b>
		</p>
		<p>或使用<b>克隆一个Git存储库</b>工具栏按钮或视图菜单从“Git存储库视图”（在<a href="#Managing_Repositories" title="例如：It / User_Guide＃Managing_Repositories">管理存储库中</a>描述）。
		</p>
		<h4 id="Repository_Selection">存储库选择</h4>
		<p>在向导的第一页上，输入远程存储库的位置：</p>
		<p>
			<img border="0" src="images/Egit-0.9-clone-wizard-url-page.png">
		</p>
		<ul>
			<li>
				<b>URI</b> - 远程存储库的完整URI或文件系统上的路径。该字段自动与其他字段同步。
				<br>请注意，您可以使用“ <b>本地文件...”</b>按钮浏览本地目录，并且URI字段通过提供以前使用的值来提供内容辅助</li>
			<li>
				<b>主机</b> - 远程主机的名称，如果从文件系统克隆，则为空。
			</li>
			<li>
				<b>存储库路径</b> - 远程存储库或文件系统的路径。
			</li>
			<li>
				<b>协议</b> - 下面描述的协议之一。
			</li>
			<li>
				<b>端口</b> - 端口号。
			</li>
			<li>
				<b>用户</b> - 用于身份验证的用户名。
			</li>
			<li>
				<b>密码</b>用于身份验证的密码。
			</li>
			<li>
				<b>存储在Secure Store中</b>是否将密码保存在Eclipse安全存储中。
			</li>
		</ul>
		<p>支持以下协议：</p>
		<ul>
			<li>
				<b>file</b> - 文件系统对存储库的访问。
			</li>
			<li>
				<b>ftp</b> - <a href="http://tools.ietf.org/html/rfc959" target="egit_external">文件传输协议</a>
			</li>
			<li>
				<b>git</b> - 最有效的内置git协议（默认端口9418）。该协议不提供身份验证。通常用于对存储库的匿名读取访问。
			</li>
			<li>
				<b>http</b> - <a href="http://tools.ietf.org/html/rfc2616" target="egit_external">超文本传输协议</a>可以通过防火墙进行隧道传输。
			</li>
			<li>
				<b>https</b> - <a href="http://tools.ietf.org/html/rfc2818" target="egit_external">超文本传输协议安全</a>可以通过防火墙进行隧道传输。
			</li>
			<li>
				<b>sftp</b> - <a href="http://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol" target="egit_external">SSH文件传输协议</a>
			</li>
			<li>
				<b>ssh</b> -  Git over <a href="http://tools.ietf.org/html/rfc4251" target="egit_external">secure shell（SSH）</a>协议。通常用于对存储库进行身份验证的写访问。
			</li>
		</ul>
		<p>
			<br>

			<b>注意：</b>如果您位于防火墙后面，则可能需要配置代理设置（ <b>“首选项”&gt;“常规”&gt;“网络连接”</b> ）。许多HTTP代理被配置为阻止包含用户名（和/或密码）的URL，例如<a href="http://fred:topsecret@egit.eclipse.org/egit.git" target="egit_external">http：// fred：topsecret@egit.eclipse.org/egit.git</a>因此建议使用底部的<i>用户</i> <i>密码</i>字段向导页面，凭据将作为HTTP标头传输。
		</p>
		<h4 id="Branch_Selection">分支选择</h4>
		<p>在下一页上，选择要从远程存储库克隆的分支：</p>
		<p>
			<img border="0" src="images/Egit-0.11-clone-wizard-branch-page.png">
		</p>
		<p>如果您不确定需要哪个分支，只需点击“全选”即可。</p>
		<p>您可以通过使用列表上方的文本控件键入来按名称过滤分支。但请注意，已检查的分支将始终显示在列表中，即它们不会被过滤。</p>
		<h4 id="Local_Destination">本地目的地</h4>
		<p>在下一页上，定义要在本地文件系统上存储存储库的位置，并定义一些初始设置。</p>
		<p>
			<img border="0" src="images/Egit-0.9-clone-wizard-destination-page.png">
		</p>
		<ul>
			<li>
				<b>目录</b> - 将包含Git存储库的目录。如果它还不存在，它将由向导创建。
			</li>
			<li>
				<b>初始分支</b> - 选择此处将创建哪个本地分支并最初签出。
			</li>
			<li>
				<b>远程名称</b> - 定义远程存储库的名称。默认为“origin”。
			</li>
		</ul>
		<p>可以在“首选项菜单” <b>窗口&gt;“团队”&gt;“Git”&gt;“默认存储库”文件夹中</b>配置用于存储Git存储库的默认根路径

			<br>
		</p>
		<p>如果您正在使用<a href="https://www.gerritcodereview.com/" target="egit_external">Gerrit Code Review</a>并且希望相应地配置存储库，则可以在此页面上按<b>Finish</b>或按<b>Next</b> 。
		</p>
		<h4 id="Cloning_from_specific_locations">从特定位置克隆</h4>
		<p>EGit的克隆向导可以通过其他插件进行扩展，以便在托管git存储库的特定后端上搜索存储库。目前这样的扩展可用于Github，很快就可用于Gerrit。两者都需要安装相应的Mylyn连接器。然后，Gerrit Mylyn连接器扩展还将配置与Gerrit一起工作的远程存储库。这也可以稍后从Git存储库视图中完成或更改，请参阅<a href="#Gerrit_Configuration">Gerrit配置</a> 。
		</p>
		<p>安装此类扩展后，将打开克隆向导，其中包含一个选择页面，您可以在其中选择要克隆的存储库的不同来源：</p>
		<p>
			<img border="0" src="images/Egit-1.3-CloneSources.png">
		</p>
		<h3 id="Pushing_to_other_Repositories">推送到其他存储库</h3>
		<h4 id="Pushing_to_upstream">推向上游</h4>
		<p>如果您正在使用具有所谓“ <a href="#Upstream_Configuration">上游配置</a> ”的本地分支，则最方便的推送方式依赖于此上游配置。
		</p>
		<p>通常，基于远程跟踪分支创建本地分支。由于远程跟踪分支与远程关联，并且远程包含访问相应远程存储库所需的信息，因此可以在创建本地分支时自动创建此上游配置（有关详细信息，请参阅<a href="#Branching">分支</a> ）。
		</p>
		<p>当从本地分支向上游推送时，推送不需要其他参数，因此可以在不显示基于存储的上游配置的另一对话的情况下执行。</p>
		<p>要推送上游，右键单击项目并选择<b>Team&gt; Push to upstream</b>或右键单击Repositories View中的Repository，然后单击<b>Push to upstream</b> 。<a href="Reference.html#Git_Workbench_Toolbar_and_Git_Workbench_Menu">Git Command Group中</a>还有一个动作。
			<br>
		</p>
		<p>选择动作后立即执行推送。完成后，将显示一个确认对话框，显示有关推送数据和/或错误消息的信息：</p>
		<p>
			<img border="0" src="images/Egit-0.11-PushResultDialog.png">
		</p>
		<h5 id="Configuring_upstream_push">配置上游推送</h5>
		<p>可以使用确认对话框中的“Configure ...”按钮（参见上文）或右键单击项目并选择<b>Team&gt; Remote&gt; Configure push to upstream ...来配置上游推送</b> 。
		</p>
		<p>将显示配置对话框，以配置推送URI和相应的分支映射（RefSpecs）：</p>
		<p>
			<img border="0" src="images/Egit-3.1-ConfigurePushToUpstream.png">
		</p>
		<p>该对话框分为三个主要部分。在上半部分，显示了有关当前检出的分支及其跟随的远程信息。通常，本地分支是基于远程跟踪分支创建的，该分支自动配置本地分支跟踪该远程跟踪分支。</p>
		<p>在此特定示例中，有一条警告消息，指出有几个分支使用名为“origin”的远程分支。这意味着推送配置中的更改将影响所有这些分支，而不仅仅是分支字段中显示的分支。将鼠标移到警告上以在工具提示中显示这些分支。</p>
		<p>URI组包含两个控件，一个URI字段和一个Push URI列表。如果列表为空，则URI字段中的URI将用于Push，如果Push URIs列表中至少有一个条目，则将使用列表中的URI。应该注意的是，如果Push URIs列表为空并且在此对话框中更改了URI，则新URI也将用于Pull，因此在执行此操作时应小心。</p>
		<p>RefMapping Group允许为Push <a href="Reference.html#Refspecs">指定</a>一个或多个RefSpec（参见<a href="Reference.html#Refspecs">Refspecs</a> ）。
		</p>
		<p>“添加”将打开一个小向导，有助于创建RefSpec。您还可以将剪贴板中的RefSpec粘贴到列表中。</p>
		<p>单击“高级”控件将显示/隐藏“编辑（高级...）”按钮，该按钮允许更复杂的RefSpec编辑，类似于下面的<a href="#Push_Wizard">推送向导</a> 。
		</p>
		<p>下方按钮栏中的按钮允许您保存更改并立即执行推送，保存更改而不提取，干运行（推送而不保存配置），还原更改和取消。</p>
		<h4 id="Direct_Push">直推</h4>
		<p>或者，您可以在远程推送规范上使用<a href="#Direct_Fetch_and_Push_Support">直接推送支持</a> 。
		</p>
		<h4 id="Push_Wizard">推送向导</h4>
		<p>最强大（但也最复杂）的方法是使用推送向导<br> 
			<b>团队&gt;远程&gt;推...</b>
		</p>
		<h5 id="Push_URI">推送URI</h5>
		<ul>
			<li>如果您已在存储库视图中配置了推送规范，则还可以使用<b>配置的远程存储库</b>下的下拉列表在此处选择它。如果正确配置了此遥控器的推送规范（即至少有一个URI和参考规范），将启用“ <b>完成”</b>按钮。
			</li>
			<li>否则，请单击“ <b>自定义URI”，</b>然后输入要推送到的上游存储库的URI。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-destination-page.png">
		</p>
		<h5 id="Push_Ref_Specifications">按参考规格</h5>
		<p>有关更多说明，另请参阅<a href="Reference.html#Refspecs">Refspecs</a> 。
		</p>
		<p>单击<b>下一步</b> 
			<br>如果这是您第一次通过ssh连接到此存储库，则必须接受远程存储库的主机密钥</p>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-accept-hostkey.png">
		</p>
		<p>如果您的ssh密钥受密码保护（建议使用），则必须在此处输入密码</p>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-ssh-passphrase.png">
		</p>
		<p>单击<b>添加所有分支规范</b>
		</p>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-refspec-allbranches.png">
		</p>
		<p>这是一种方便的方法，用于声明您希望将本地分支名称映射到要将更改推送到的上游存储库中的相同分支名称。</p>
		<p>单击“ <b>添加所有标签规范”</b> ，将本地标签1：1映射到要推送到的存储库中的标签。
		</p>
		<p>如果要以不同的方式将本地分支映射到上游存储库中的分支，可以按以下方式定义更详细的映射规范</p>
		<ul>
			<li>输入源和目标引用，或从下拉列表中选择已存在的分支</li>
			<li>单击<b>添加规格</b>
			</li>
		</ul>
		<p>这会将新定义的映射传输到<b>推送</b>列表<b>规范</b>
		</p>
		<p>
			<b>其他常见推送规格：</b>
		</p>
		<ul>
			<li>如果你想根据你的昵称<i>joe</i>命名你推送的分支，你可以将<tt>refs / heads / *</tt>映射到<tt>refs / heads / joe / *</tt> 。如果多个用户想要在共同使用的公共存储库中的个人分支上发布其本地分支，这将非常有用。
			</li>
			<li>另一种常见的映射是将源ref <tt>HEAD</tt>映射到目标<tt>refs / heads / master</tt> 。这意味着您希望将当前<tt>HEAD</tt> （当前可能指向任何本地主题分支）映射到上游主分支。</li>
		</ul>
		<h5 id="Delete_Ref_Specifications">删除参考规格</h5>
		<p>要删除目标存储库中的ref，请从下拉列表<b>Remote ref to delete中</b>选择要删除的ref，然后单击<b>Add Spec</b> 。这将在<b>推送</b>列表的<b>规格中</b>创建相应的条目。或者，您可以键入要删除的引用的规范，这也可以使用通配符。按“删除参考规范”将删除目标存储库中的匹配参考。
		</p>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-delete-refspec.png">
		</p>
		<h5 id="Conflicting_Push_Ref_Specifications">推送参考规格冲突</h5>
		<p>如果添加多个冲突的Push Ref规范，它们将标记为红色，通过删除或编辑冲突的规范来解决此问题。也可以在列表<b>规格中</b>就地编辑规格
		</p>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-refspec-conflict.png">
		</p>
		<h5 id="Push_Confirmation">推送确认</h5>
		<p>单击<b>下一步</b>
		</p>
		<p>这将打开Push Confirmation对话框，显示预览，哪些更改将被推送到目标存储库。如果这与您的预期不符，请单击“上<b>一步”</b>并相应地更正推送规格。
		</p>
		<ul>
			<li>对于ref更新，要推送的提交范围将以<tt><b>&lt;SHA1-from&gt; .. &lt;SHA1-to&gt;</b></tt>格式显示，例如<tt><b>d97f5a2e..adfdbfd2</b></tt>表示<tt><b>将推送d97f5a2e</b></tt>和<tt><b>adfdbfd2</b></tt>之间的所有提交。
			</li>
			<li>对于目标存储库中尚不存在的引用<tt><b>[new branch]</b></tt>或<tt><b>[new tag]</b></tt> 。
			</li>
			<li>对于将被删除的引用<tt><b>[删除]</b></tt>显示。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-push-wizard-confirm-push.png">
		</p>
		<ul>
			<li>如果要确保在此预览中看到的内容也是推送这些更改时所获得的内容，请选中“ <b>如果远程引用未在平均时间内更改”</b>复选框，则选中“ <b>仅推送”</b> 。
			</li>
			<li>如果您只想在执行推送后获得报告（如果结果与此预览不同），请选中“ <b>仅当显示最终报告对话框与此确认报告不同时”</b>复选框。
			</li>
		</ul>
		<h5 id="Push_Result_Report">推送结果报告</h5>
		<p>单击<b>完成</b>
		</p>
		<p>根据您选择的选项，将显示推送结果报告对话框。它显示推送到远程的提交列表。</p>
		<p>
			<img border="0" src="images/Egit-3.1-PushConfirmationDialog.png">
		</p>
		<p>在底部的框中，显示来自远程服务器的推送确认消息。如果有任何错误，您将在此处找到来自远程服务器的错误消息。要查看给定列表条目的消息，只需在列表中选择它即可。</p>
		<p>单击“ <b>确定”</b>关闭对话框。
			<br>
			<br>
		</p>
		<h3 id="Fetching_from_other_Repositories">从其他存储库中获取</h3>
		<h4 id="Fetching_from_upstream">从上游获取</h4>
		<p>如果您正在使用具有所谓“ <a href="#Upstream_Configuration">上游配置</a> ”的本地分支，则最方便的获取方式依赖于此上游配置。
		</p>
		<p>通常基于远程跟踪分支创建本地分支。由于远程跟踪分支与远程关联，并且此远程包含访问远程存储库所需的信息，因此可以在创建本地分支时自动创建此上游配置（有关详细信息，请参阅<a href="#Branching">分支</a> ）。
		</p>
		<p>从上游获取时，此持久配置可用于自动获取，而无需在对话框中提供其他参数。</p>
		<p>要从上游获取，请单击项目上的<b>团队&gt;从上游获取，</b>或单击存储库视图中存储库中的<b>上游获取</b> 。<a href="Reference.html#Git_Workbench_Toolbar_and_Git_Workbench_Menu">Git Command Group中</a>还有一个动作。
		</p>
		<p>选择动作后立即执行提取。完成后，将显示一个确认对话框，显示有关所获取数据和/或错误消息的信息：</p>
		<p>
			<img border="0" src="images/Egit-3.1-FetchResultDialog.png">
		</p>
		<h5 id="Configuring_fetch_from_upstream">配置从上游获取</h5>
		<p>可以使用确认对话框中的“配置...”按钮（参见上文）或通过单击项目上的<b>团队&gt;远程&gt;从上游配置提取来配置上游提取</b> 。
		</p>
		<p>将显示配置对话框，用于配置提取URI和分支映射（RefSpecs）：</p>
		<p>
			<img border="0" src="images/Egit-3.1-ConfigureFetchFromUpstream.png">
		</p>
		<p>该对话框分为三个主要部分。在上半部分，显示了有关当前检出的分支及其跟随的远程信息。</p>
		<p>URI字段可用于添加/更改提取URI。</p>
		<p>RefMapping Group允许为Fetch <a href="Reference.html#Refspecs">指定</a>一个或多个RefSpec（参见<a href="Reference.html#Refspecs">Refspecs</a> ）。
		</p>
		<p>“添加”按钮将打开一个小向导，帮助创建RefSpec。您还可以将剪贴板中的RefSpec粘贴到列表中。</p>
		<p>单击“高级”控件将显示/隐藏“编辑（高级...）”按钮，该按钮允许进行更复杂的RefSpec编辑，类似于<a href="#Fetch_Wizard">获取向导</a> 。
		</p>
		<p>下方按钮栏中的按钮允许您保存更改并立即进行提取，保存更改而不提取，干运行（获取而不保存配置），还原更改以及取消。</p>
		<h4 id="Direct_Fetch">直接获取</h4>
		<p>获取的另一种方法是在远程的获取规范上使用<a href="#Direct_Fetch_and_Push_Support">直接获取支持</a> 。
		</p>
		<h4 id="Fetch_Wizard">获取向导</h4>
		<p>最强大（但也是最复杂）的方法是使用获取向导<br>

			<b>团队&gt;获取......</b>
		</p>
		<ul>
			<li>如果您已在存储库视图中配置了获取规范，则还可以使用<b>配置的远程存储库</b>下的下拉列表在此处选择它。如果正确配置了此远程的获取规范（即至少具有一个URI和ref规范），则将启用“ <b>完成”</b>按钮。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-fetch-wizard-source-page.png">
		</p>
		<ul>
			<li>否则，请单击“ <b>自定义URI”，</b>然后输入要从中获取更改的上游存储库的URI。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-fetch-wizard-source-url-page.png">
		</p>
		<h5 id="Fetch_Ref_Specifications">获取参考规格</h5>
		<p>有关更多说明，另请参阅<a href="Reference.html#Refspecs">Refspecs</a> 。
		</p>
		<p>单击<b>下一步</b> 
			<br>单击<b>添加所有分支规范</b>
		</p>
		<p>
			<img border="0" src="images/Egit-0.9-fetch-wizard-refspec.png">
		</p>
		<p>这是一种方便的方法，用于声明您希望将要从1：1更改的上游存储库中的分支名称映射到相同的本地分支名称。</p>
		<ul>
			<li>单击编辑字段<b>Destination Ref</b>并将路径段<i>choose_remote_name</i>替换为<i>要从中</i>获取的上游存储库的符号名称。
			</li>
			<li>您的存储库克隆的存储库的默认远程名称是<tt><b>origin</b></tt> 。默认情况下，此远程控制器的主映射从<tt><b>refs / heads / master</b></tt>映射到<tt><b>refs / remotes / origin / master</b></tt> 。
			</li>
			<li>如果您想要在本地存储库中另外跟踪Joe的存储库中的分支，您可以将其存储库<tt><b>refs / heads / *中</b></tt>的分支映射到以下跟踪分支<tt><b>refs / remotes / joe / *</b></tt> 。
			</li>
			<li>如果您只想允许快进更新，请取消选择<b>强制更新，</b>如果您还想允许非快进更改，请选择此选项。
			</li>
			<li>单击<b>强制更新所有参考</b>以在所有规格上设置强制更新选项</li>
			<li>单击<b>删除所有规格</b>以从列表<b>规格中</b>删除所有规格<b>以获取</b>
			</li>
		</ul>
		<ul>
			<li>单击“ <b>添加所有标签规范”</b> ，将要从1：1获取的存储库中的标签标签映射到本地标签。
			</li>
		</ul>
		<p>如果要以不同的方式将上游存储库中的分支或标记映射到本地分支，可以通过以下方式定义更详细的映射规范</p>
		<ul>
			<li>输入源（源存储库中的ref）和目标引用（跟踪本地存储库中的分支或标记）或从下拉列表中选择已存在的分支</li>
			<li>单击<b>添加规格</b>
			</li>
		</ul>
		<p>这会将新定义的映射传输到列表<b>规范以进行提取</b>
		</p>
		<h5 id="Fetch_Result_Report">获取结果报告</h5>
		<p>单击<b>完成</b>
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-FetchWizardResult.png">
		</p>
		<p>将显示一个获取结果对话框。</p>
		<ul>
			<li>对于ref更新，将显示已提取的列表提交。</li>
			<li>对于之前在本地存储库中不存在的引用<tt><b>[new branch]</b></tt>或<tt><b>[new tag]</b></tt> 。
			</li>
			<li>对于已删除的引用<tt><b>[已删除]</b></tt>显示。
			</li>
		</ul>
		<p>
			<br>
		</p>
		<h3 id="Pulling_New_Changes_from_Upstream_Branch">从上游分支拉出新的变化</h3>
		<ul>
			<li>在Package Explorer中右键单击项目，然后选择<b>Team&gt; Pull</b>或右键单击Git Repositories视图中的存储库，并选择<b>Pull</b>以从本地分支正在跟踪的上游分支中提取新更改。如果从多个存储库中选择资源，这也适用。
			</li>
			<li>每当您基于远程跟踪分支创建本地分支时，EGit都可以配置跟踪关系，以便随后的提取将获取然后合并或重新绑定（根据此跟踪关系的配置）来自跟踪的上游分支的更改;有关详细信息，请参阅<a href="#Branching">分支</a>
			</li>
		</ul>
		<p>EGit尚不支持Ad-hoc选择要从中拉出的上游分支。</p>
		<p>可用替代品包括：</p>
		<ul>
			<li>从外部eclipse运行<b>git pull</b> （但<a href="http://marc.info/?l=git&amp;m=123924844219075" target="egit_external">要注意Windows</a> ）</li>
			<li>如果您没有进行本地更改或想要放弃本地更改，请使用<b>团队&gt;重置...</b>
			</li>
		</ul>
		<p>
			<br>
			<br>
		</p>
		<h2 id="Working_with_Gerrit">与Gerrit合作</h2>
		<p>如果您正在使用<a href="https://www.gerritcodereview.com/" target="egit_external">Gerrit Code Review</a> ，EGit允许您方便地从Gerrit服务器推送和获取更改。
		</p>
		<h3 id="Enabling_Gerrit_for_a_repository">为存储库启用Gerrit</h3>
		<p>当使用<code>http</code> ， <code>https</code>或<code>ssh</code> URI从Gerrit服务器在EGit中克隆存储库时，EGit将自动设置克隆以与Gerrit一起使用。存储库克隆配置为使得</p>
		<ul>
			<li>获取也从Gerrit获取评论笔记，</li>
			<li>默认情况下推送会提交审核，并且</li>
			<li>提交消息会自动获得Gerrit <code>Change-Id</code>除非他们已经有了。</li>
		</ul>
		<p>如果在EGit中使用从EGit之外的Gerrit服务器克隆的存储库，则可能无法设置克隆，以便EGit将其识别为Gerrit存储库。除非先配置存储库，否则EGit中的Gerrit操作不会出现在任何菜单中。为此，打开Git Repositories视图并向下浏览到代表您要使用的Git存储库服务器的<b>Remote</b> ，然后选择<b>Gerrit Configuration ...。</b>
		</p>
		<h3 id="Pushing_a_change_to_a_Gerrit_Code_Review_Server">将更改推送到Gerrit代码审查服务器</h3>
		<p>右键单击项目，选择<b>Team&gt; Remote&gt; Push to Gerrit ...</b>或右键单击Repositories View中的Repository节点，然后选择<b>Push to Gerrit ...</b>
		</p>
		<p>将出现一个对话框，允许您选择或输入URI和分支名称：</p>
		<p>
			<img border="0" src="images/Egit-4.4-PushChangeToGerritDialog.png">
		</p>
		<ul>
			<li>在URI组合中，选择或输入指向Gerrit实例的URI;组合将预填充在当前存储库的任何远程中定义的所有URI;此外，您可以在此字段中键入任何URI</li>
			<li>在Gerrit Branch字段中，输入分支的名称以选择要将更改推送到的审阅队列</li>
			<li>（可选）启用主题并输入主题标识符。EGit建议推送本地分支的最后一个使用主题，或本地分支名称。</li>
		</ul>
		<p>该对话框还为Gerrit分支提供内容辅助。只需按“Ctrl + Space”激活它（查看悬停在Gerrit Branch字段附近的小灯泡装饰器上时出现的工具提示）。将显示当前存储库的远程跟踪分支。请注意，此内容辅助已被过滤，因此，为了查看所有提案，您需要确保在请求内容辅助之前将Gerrit Branch字段设置为空。</p>
		<p>单击<b>Finish后</b> ，当前签出的提交将被推送到指定的Gerrit分支。此外，稍后再次打开对话框时，将记住URI和Gerrit Branch值并再次建议。
		</p>
		<p>当并行处理不同的Gerrit分支时（例如，在开发和修复之间频繁切换），这允许更大的灵活性。</p>
		<h4 id="Pushing_as_Draft">推动草案</h4>
		<p>“Push to Gerrit”向导中的“refs / for”是一个组合下拉框;单击它并选择“refs / drafts”而不是“refs / for” <a href="https://gerrit-review.googlesource.com/Documentation/intro-user.html#drafts" target="egit_external">将草稿更改推送到Gerrit</a> 。
		</p>
		<h4 id="Editing_a_change">编辑更改</h4>
		<p>当一个更改被推送到Gerrit并且审阅者建议进行一些改进时，必须上载用于更改的新补丁集。首先，编辑提交：</p>
		<ul>
			<li>如果您有一个对应于一个更改的提交，则可以修改提交（请参阅<a href="#Amending_Commits">修改提交</a> ）。
			</li>
			<li>如果您有多个依赖提交并且需要编辑除最后一个提交以外的提交，则可以执行交互式rebase（请参阅<a href="#Interactive_Rebase">Interactive Rebase</a> ）。或者，查看您要编辑的提交，修改它然后在顶部挑选后面的提交（这是交互式rebase为您做的）。
			</li>
		</ul>
		<p>然后再次推到同一个分支。Gerrit将检测到您正在更新现有更改并将添加新的修补程序集。</p>
		<h3 id="Fetching_a_change_from_a_Gerrit_Code_Review_Server">从Gerrit Code Review Server获取更改</h3>
		<p>右键单击项目，然后选择<b>Team&gt; Remote&gt; Fetch from Gerrit ...</b>或右键单击Repositories View中的Repository节点，然后选择<b>从Gerrit中获取...</b>
		</p>
		<p>将出现一个对话框，允许您选择或输入URI和更改以及一些其他选项：</p>
		<p>
			<img border="0" src="images/Egit-3.1-FetchChangeFromGerritDialog.png">
		</p>
		<ul>
			<li>在URI组合中，选择或输入指向Gerrit实例的URI;组合将预填充在当前存储库的任何远程中定义的所有URI;此外，您可以在此字段中键入任何URI</li>
			<li>在“更改”字段中，您必须输入更改的全名;您可以从Gerrit Web UI获取此值，使用下面描述的内容辅助，或使用以下模式构建名称：<br>“refs / changes /”+（更改号码的最后两位数字）+ / +（更改号码）+ / +（修订号）</li>
			<li>在“获取后执行的操作”中，您可以决定在获取更改后要执行的操作;您可以创建和签出指向更改的分支，创建和签出指向更改的标记，或者只是检查更改（从而使HEAD分离）;获取后，最后一个选项不执行任何操作，但您将能够在FETCH_HEAD中找到与更改相关的提交（转到存储库视图并在存储库的References节点下找到FETCH_HEAD，请参阅<a href="#Inspecting_References">检查引用</a> ）。
				<br>对话框建议分支或标记的名称，但可以根据需要覆盖。
				<br>由于EGit目前不支持删除标签，我们建议暂时使用本地分支而不是标签。由于“存储库”视图允许使用“/”作为层次结构分隔符对分支进行分组，因此在处理大量更改时，建议的名称可以非常方便。
			</li>
		</ul>
		<p>该对话框还提供了更改的内容辅助，而不是繁琐的复制粘贴或手动输入更改ID。只需按“Ctrl + Space”即可激活此功能（请参阅将鼠标悬停在“更改”字段附近的小灯泡装饰器上时出现的工具提示）。将联系Gerrit服务器并获取所有可用更改并显示在内容辅助对话框中：</p>
		<p>
			<img border="0" src="images/Egit-0.11-ContentAssistGerritChange.png">
		</p>
		<p>列表将在更改字段中使用您的输入进行过滤。在内容辅助中选择更改后，“更改”字段将填充正确的信息。</p>
		<p>您还可以在打开<b>从Gerrit中获取...</b>向导之前，将下载命令从Gerrit WebUI复制到剪贴板。这将自动使用获取此更改所需的值填充对话框。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-GerritDownloadCommand.png">
		</p>
		<p>如果剪贴板包含指向Gerrit更改的Web URL，或者此类URL的更改编号部分（由“/”分隔的数字），或者更改，则更改字段也会自动填充（并触发内容辅助）数。</p>
		<h2 id="Working_with_Gitflow">使用Gitflow</h2>
		<p>如果您使用的是Gitflow（ <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="egit_external">http://nvie.com/posts/a-successful-git-branching-model/</a> ），则EGit允许您使用Gitflow操作，管理功能，发行版和修补程序分支。安装“Git Integration for Eclipse  -  Gitflow支持”功能，以便安装EGit的Gitflow集成。
		</p>
		<h3 id="Enabling_Gitflow_for_a_repository">为存储库启用Gitflow</h3>
		<p>除非为Gitflow配置了选定的存储库，否则不会显示Gitflow操作。为此，在Git Repositories视图中打开存储库上下文菜单，然后选择<b>Init Git Flow</b> 。

			<img border="0" src="images/Egit-4.0-git_flow_init-repository_node_right_click.png">
		</p>
		<p>如果您的存储库已由另一个客户端为Gitflow配置，则可以跳过此步骤。</p>
		<h3 id="Starting_a_feature.2Frelease.2Fhotfix">启动功能/发行版/修补程序</h3>
		<p>右键单击存储库，选择<b>Git Flow</b> ，然后选择相应的启动命令。
		</p>
		<p>
			<img border="0" src="images/Egit-4.0-git_flow-repository_node_right_click.png">

			<img border="0" src="images/Egit-4.0-git_flow_submenu-repository_node_right_click.png">
		</p>
		<p>将出现一个对话框，允许您输入Gitflow分支的名称，自动添加正确的前缀。</p>
		<h3 id="Starting_release_from_a_commit_other_than_HEAD">从HEAD以外的提交开始发布</h3>
		<p>转到EGit History视图，右键单击要从中启动发布的提交。在上下文菜单中，转到<b>Git Flow</b> ，然后<b>从commit &lt;sha1&gt;中</b>选择<b>Start release</b> 。

			<img border="0" src="images/Egit-4.0-git_flow_start_release_from_history_view_context_menu.png">
		</p>
		<h2 id="Inspecting_the_state_of_the_Repository">检查存储库的状态</h2>
		<h3 id="Label_Decorations">标签装饰</h3>
		<p>标签装饰在Git版本控制下显示有关资源的Git特定信息。它们出现在显示模型对象的所有视图中，如Package Explorer，Project Explorer，Navigator和Hierarchy View。</p>
		<p>可以在“ <b>常规”&gt;“外观”&gt;“标签装饰</b> <b>”</b>下的“首选项”菜单（“ <b>窗口”&gt;“首选项”</b> ）中全局打开Git标签装饰，可以在“ <b>窗口”&gt;“首选项”&gt;“团队”&gt;“Git”&gt;“标签装饰</b> ”下的<b>“首选项”中</b>修改更详细的设置。
		</p>
		<p>有两种不同类型的标签装饰：文本装饰和图标装饰。</p>
		<h4 id="Text_Decorations">文字装饰</h4>
		<p>文本装饰显示在文本标签的左侧或右侧。可以在“ <b>文本装饰”</b>选项卡上的“ <b>团队”&gt;“Git”&gt;“标签装饰</b> ”下的“首选项”对话框中配置它们。例如，脏资源的默认值是其名称左侧的<tt><b>&gt;</b></tt> 。
		</p>
		<p>这些是默认设置：</p>
		<p>
			<img border="0" src="images/01-TextDecorations.png">
		</p>
		<p>对于文件和文件夹，有变量<tt>“name”</tt> ， <tt>“dirty”</tt>和<tt>“staged”</tt> 。 <tt>“脏”</tt>和<tt>“上演”</tt>是旗帜;如果它们为true，则显示冒号后面的文本。</p>
		<p>对于项目，还有其他变量<tt>“repository”</tt> ， <tt>“branch”</tt>和<tt>“branch_status”</tt> 。<tt>“repository”</tt>变量显示<tt>存储库</tt>的名称。</p>
		<p><tt>“branch”</tt>变量显示当前检出的分支的名称。如果没有签出分支，则装饰显示提交的缩写名称（前七个字符后跟省略号）。如果标记和/或远程分支指向此提交，则应用“最佳猜测”启发式来显示此信息：标记优先于远程分支，如果应用多个标记，则显示最新的标记。如果有多个远程分支或标签没有修改日期，则应用字母排序，并显示最后一个。示例：签出的提交<tt><b>e49f576 ...</b></tt>指的是存储库的标记<tt><b>v.0.7.1</b></tt> ， <tt><b>例如</b></tt> ：<br>
		</p>
		<p>
			<img border="0" src="images/03-ExampleDecoration.png">
		</p>
		<p><tt>“branch_status”</tt>变量显示本地分支的状态与设置为上游的远程跟踪分支的比较：</p>
		<ul>
			<li>↑N  - 本地分支有<i>N个</i>提交，但尚未在远程跟踪分支上。这可以理解为“N承诺推送”。
			</li>
			<li>↓M  - 远程跟踪分支具有不在本地分支上的<i>M次</i>提交。这可以解读为“M提交合并/ rebase”。
			</li>
			<li>↑N↓M  - 本地分支和远程跟踪分支已经发散（上述两个分支都适用）。</li>
			<li>- 如果本地分支和远程跟踪分支具有相同的状态，则为空。</li>
		</ul>
		<p>状态变量可以与前导空格一起使用，如下所示： <tt>{branch_status}</tt> 。这导致仅在状态不为空时才添加空间。</p>
		<h4 id="Icon_Decorations">图标装饰</h4>
		<p>图标装饰显示在标签前面显示的图标的右下角。可以在“ <b>图标装饰</b> ”选项卡上的“ <b>团队”&gt;“Git”&gt;“标签装饰</b> ”下的“首选项”对话框中配置它们。
		</p>
		<p>这些是默认装饰：</p>
		<p>
			<img border="0" src="images/02-IconDecorations.png">
		</p>
		<ul>
			<li>
				<b>脏（文件夹）</b> - 文件夹下面至少有一个文件是脏的;这意味着它在工作树中的变化既不在索引中也不在存储库中。
			</li>
			<li>
				<b>tracked</b> - 资源是Git存储库已知的，因此受版本控制。
			</li>
			<li>
				<b>未跟踪</b> -  Git存储库不知道该资源，并且在显式添加之前不会对其进行版本控制。
			</li>
			<li>
				<b>忽略</b> -  Git团队提供者<b>忽略</b>该资源。<b>Team&gt; Ignored Resources</b> ，“derived”标志和<tt>.gitignore</tt>文件中的设置下的首选项设置被考虑在内。
			</li>
			<li>
				<b>dirty</b> - 资源在工作树中的更改既不在索引中也不在存储库中。
			</li>
			<li>
				<b>staged</b> - 资源已添加到索引中的更改。请注意，目前只能在提交对话框中通过资源的上下文菜单添加对索引的更改。
			</li>
			<li>
				<b>partial-staged</b> - 资源具有添加到索引的更改以及工作树中既未到达索引也未提交到存储库的其他更改。有关如何执行此操作，请参阅<a href="Reference.html#Partial_Staging">Git Staging视图中的部分暂存</a> 。
			</li>
			<li>
				<b>添加</b> - 资源尚未到达存储库中的任何提交，但已被新添加到Git存储库，以便将来进行跟踪。
			</li>
			<li>
				<b>已删除</b> - 暂存资源以从Git存储库中删除。
			</li>
			<li>
				<b>冲突</b> - 文件存在合并冲突。
			</li>
			<li>
				<b>assume-valid</b> - 资源具有“假定未更改”标志。这意味着Git停止检查工作树文件是否有可能的修改，因此您需要手动取消设置该位以在更改工作树文件时告诉Git。另请参阅<a href="Reference.html#Menu_Actions">假设未更改的操作</a> 。
			</li>
		</ul>
		<h3 id="Commit_Dialog">提交对话框</h3>
		<p>提交对话框中显示所有已修改跟踪文件的状态摘要。通过双击文件，将在比较对话框中显示要提交的更改。由于EGit当前总是提交工作树的内容（对应于命令行上的git commit -a），因此比较对话框将比较工作树和最后一次提交。

			<br>
			<br>
		</p>
		<h3 id="Comparing_Content">比较内容</h3>
		<p>在日常工作中，您通常希望查看上次提交，索引和当前工作树之间的更改。为此，请在项目资源管理器或导航器中选择资源（项目，文件夹或文件），然后右键单击“ <b>比较”</b>下的操作。
		</p>
		<p>要分析特定提交的内容，您应该使用更好地支持此任务的<a href="Reference.html#History_View">历史记录视图</a> ，请参阅任务<a href="#Inspecting_Commits">检查提交</a> 。
		</p>
		<h4 id="Compare_editor_and_Synchronize_View">比较编辑器和同步视图</h4>
		<p>如果在单个文件上使用<b>Compare With</b>的任何子菜单操作，将显示比较编辑器，否则（从EGit 3.1开始）将打开<a href="Reference.html#Synchronize_View">同步视图</a> ，以便您浏览更改;通过在此视图中双击已更改的文件，将为此文件打开比较编辑器。在“同步视图”的工具栏中，您可以选择要用于显示正在检查的更改的“同步模型”。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-SynchronizeSwitchModel.png">
		</p>
		<h4 id="Compare_working_tree_with_last_commit">将工作树与上次提交进行比较</h4>
		<p>可以从上下文菜单<b>Compare With&gt; HEAD revision</b>查看当前工作目录中的资源与当前分支中的最后一次提交之间的差异。“提交”对话框中也提供了此功能。双击“提交”对话框中的条目可打开比较对话框。
		</p>
		<h4 id="Comparing_Working_Tree_with_Index">将工作树与索引进行比较</h4>
		<p>可以从上下文菜单<b>Compare With&gt; Git Index</b>查看当前工作树和索引（基于当前所选资源）之间的差异。
		</p>
		<h4 id="Comparing_Working_Tree_with_a_branch.2C_a_tag_or_a_reference">将工作树与分支，标记或引用进行比较</h4>
		<ul>
			<li>选择资源</li>
			<li>右键单击“ <b>比较”&gt;“分支”，“标记”或“参考”...</b>
			</li>
			<li>选择分支，标签或参考</li>
		</ul>
		<h4 id="Comparing_Working_Tree_with_Any_Commit">将工作树与任何提交进行比较</h4>
		<h5 id="From_the_project_explorer:">从项目资源管理器：</h5>
		<ul>
			<li>选择资源</li>
			<li>右键单击<b>Compare With&gt; Commit ...</b>
			</li>
			<li>从提交图中选择一个提交</li>
		</ul>
		<h5 id="From_the_history_view_.28files_only.29:">从历史记录视图（仅限文件）：</h5>
		<ul>
			<li>在包资源管理器中选择一个文件</li>
			<li>右键单击<b>团队&gt;在历史记录中显示</b>或<b>与比较&gt;历史...</b>
			</li>
			<li>在提交图中选择一个提交</li>
			<li>从上下文菜单中选择<b>与工作树比较</b>
			</li>
			<li>这将打开一个比较对话框，显示所选提交与当前工作树之间的更改</li>
		</ul>
		<h4 id="Comparing_Two_Commits">比较两个提交</h4>
		<ul>
			<li>在Package Explorer中选择一个资源</li>
			<li>单击<b>团队&gt;在历史记录中显示</b>或<b>与比较&gt;历史记录...</b> （后者仅用于文件）</li>
			<li>在提交图中选择两个提交</li>
			<li>右键单击“相互<b>比较”</b>
			</li>
			<li>这将打开一个比较对话框，显示两个选定提交之间的更改</li>
			<li>您也可以通过右键点击打开一个Git树比较视图<b>在树相互比较</b>
			</li>
		</ul>
		<h4 id="Comparing_Index_with_HEAD_or_Any_Other_Commit">将指数与HEAD或任何其他提交进行比较</h4>
		<p>您可以使用分段视图将索引与HEAD进行比较。双击“Staged Changes”窗格中显示的文件，将其Index版本与HEAD版本进行比较。Index和另一个提交之间的比较尚未实现。</p>
		<p>
			<br>
		</p>
		<h3 id="Comparing_with_Branches_.28Synchronize.29">与分支比较（同步）</h3>
		<p>通过选择要比较的项目并单击<b>Compare With&gt; Branch，Tag或Reference，</b>可以查看工作树（包括未提交的更改）与分支或标记之间的差异（自EGit 3.1起）。在开始比较之前，将针对您选择的资源过滤结果。
		</p>
		<p>您还可以通过单击项目上的动态菜单<b>Team&gt; Synchronize</b>并选择要同步工作树的<i>Ref</i>来与分支进行比较。如果Git存储库包含多个Eclipse项目，则选择一个项目就足够了， <b>同步视图</b>也将包括所有其他项目。
		</p>
		<p>
			<img border="0" src="images/Egit-1.0-synchronize-dynamic.png">
		</p>
		<p>如果要与动态菜单中未列出的Ref同步，请单击<b>Team&gt; Synchronize&gt; Other ....</b>然后在“同步向导”中单击要同步的存储库的目标列，并选择要与之比较的Ref。
		</p>
		<p>
			<img border="0" src="images/Egit-1.0-synchronize-custom.png">
		</p>
		<p>单击“在比较中包括本地未提交的更改”时，还会显示本地的，尚未暂存的更改以及已经分阶段的更改。</p>
		<p>也可以一次比较多个存储库。在这种情况下，在“同步向导”中为每个存储库选择要与之比较的Ref。</p>
		<h3 id="Quickdiff">Quickdiff</h3>
		<p>您可以启用快速差异支持并在文本编辑器中查看更改，而不是使用比较编辑器。

			<br>可以通过<b>常规&gt;编辑器&gt;文本编辑器&gt;快速差异</b>首选项页面启用此功能：</p>
		<p>
			<img border="0" src="images/04-QuickDiffPreferences.png">
		</p>
		<p>然后，差异注释将显示在编辑器的左侧：</p>
		<p>
			<img border="0" src="images/05-QuickDiffInEditor.png">
		</p>
		<p>如果将鼠标移到注释上，则会看到要比较的版本的内容：</p>
		<p>
			<img border="0" src="images/06-QuickDiffInEditorPopup.png">
		</p>
		<p>默认情况下，比较是针对HEAD的。您可以从历史记录视图中的提交的上下文菜单（ <b>显示在&gt;历史记录中</b> ）中确定要与之比较的版本，即所谓的quickdiff基线。有三个菜单条目：</p>
		<ul>
			<li>
				<b>快速差异 - &gt;将基线重置为HEAD的第一个父级</b> - 与HEAD之前的第一个提交进行比较。</li>
			<li>
				<b>快速差异 - &gt;将基线重置为HEAD</b> - 与HEAD进行比较。</li>
			<li>
				<b>快速差异 - &gt;设置为基线</b> - 与选定的提交进行比较</li>
		</ul>
		<p>
			<br>
		</p>
		<h3 id="Inspecting_Commits">检查提交人</h3>
		<p>检查给定的提交</p>
		<ul>
			<li>从包浏览器的上下文菜单中选择<b>Team&gt; Show in History</b>
			</li>
			<li>选择要检查的提交</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-3.1-ViewDiffInHistory.png">
		</p>
		<h4 id="View_Diff_for_a_Commit">查看提交的差异</h4>
		<p>历史记录视图在左下窗格中显示差异。选择右下方窗格中的文件会显示此文件的差异。</p>
		<h4 id="Showing_the_contents_of_a_Commit">显示提交的内容</h4>
		<p>双击右下方窗格中文件的行为取决于比较模式切换按钮的状态。如果它打开，将打开一个比较编辑器，它将当前提交中的文件内容与祖先提交中的内容进行比较;如果它关闭，将打开一个编辑器，显示当前提交中的文件内容。</p>
		<h2 id="Committing_Changes">承诺变更</h2>
		<p>git版本控制下的项目修改通过提交保存在git历史记录中。从从git存储库检出的状态开始修改项目，直到达到满意的状态，然后将所有这些更改作为单个提交提交到存储库中。每个提交代表存储库中存储的所有文件的定义良好的快照。</p>
		<h3 id="Modifying_the_content">修改内容</h3>
		<p>要修改已经与Git共享的项目，请在Eclipse中或直接在文件系统中修改或删除文件。没有必要事先告诉Git这些操作。应该受版本控制的新文件必须明确放在Git版本控制之下：</p>
		<ul>
			<li>单击<b>团队&gt;</b>在文件的上下文菜单中<b>添加</b></li>
		</ul>
		<p>或者，您可以在“提交”对话框中显示未跟踪的文件，并选中“ <b>显示未跟踪的文件”</b>复选框以选中它们以包含在提交中。
		</p>
		<p>标签装饰器，例如在Package Explorer视图中，显示：</p>
		<ul>
			<li>尚未受到git版本控制的未跟踪文件（标有“？“）</li>
			<li>已添加的文件（标有“+”）</li>
			<li>修改过的文件（在文件名前面标有“&gt;”）</li>
		</ul>
		<p>有关详情，请参阅<a href="#Label_Decorations">标签装饰</a> 。
		</p>
		<p>以下是Package Explorer中的示例：</p>
		<ul>
			<li>一个提交的文件</li>
			<li>在工作树中修改但尚未为下次提交暂存的文件</li>
			<li>修改过的文件已经为下一次提交暂存了</li>
			<li>新下载的文件，首次包含在下一次提交中</li>
			<li>一个不受git版本控制的文件</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-label-decorators.png">
		</p>
		<h3 id="Committing">提交</h3>
		<p>有两种方法可以使用EGit提交更改：</p>
		<ul>
			<li>使用<b>暂存视图</b> ，或</li>
			<li>使用<b>提交对话框</b> 。
			</li>
		</ul>
		<p>提交对话框被视为已弃用，可能会在将来的版本中删除。从EGit 4.4开始， <b>Team&gt; Commit ...</b>上下文菜单操作默认打开登台视图而不是提交对话框。
		</p>
		<p>此行为暂时可在全局<b>首选项&gt;团队&gt; Git&gt;提交</b>首选项中进行配置。
		</p>
		<p>
			<img border="0" src="images/Egit-4.5-CommittingPreferences.png">
		</p>
		<p>如果选中“使用分段视图提交而不是提交对话框”（默认设置），则<b>团队&gt;提交...</b>操作将打开分段视图。如果未选中，将打开提交对话框。
		</p>
		<p>如果使用临时视图，则可以使用“自动暂存所提交的所选资源”选项，因为EGit 4.5确定在调用<b>Team&gt; Commit ...</b>时是否应自动暂存所选文件。这将暂存所选资源中包含的所有更改。它使行为与提交对话框的工作方式更加一致：在提交对话框中，可以检查或取消选中单个文件以包含在提交中，并且默认情况下会选中所选文件。在暂存视图中，您可以通过暂存更改来编写提交，并且仅提交暂存的更改。因此，在使用分段视图时，自动分段会在提交中自动包含所选文件。
		</p>
		<p>“包括选定的未跟踪文件”选项确定提交中是否包含尚未存在于git存储库中的所选文件（在提交对话框中检查，或者如果启用了自动暂存，则在分段视图中自动暂存）。</p>
		<h4 id="Committing_with_the_Staging_View">使用暂存视图进行提交</h4>
		<p>使用EGit创建提交的首选方法是<a href="Reference.html#Git_Staging_View">分段视图，</a>因为它始终显示所选存储库的当前git状态，并允许分阶段（添加到git索引）和unstage（从git索引中删除）修改后的文件。双击<b>Unstaged Changes</b>窗格中的文件，将其与git索引进行比较，双击<b>Staged Changes</b>窗格中的文件，将其索引版本与HEAD进行比较。在暂存视图中，您可以逐步编辑提交消息，因为它是视图而不是模式编辑器。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingView.png">
		</p>
		<h4 id="Committing_using_Commit_Dialog">使用提交对话框提交</h4>
		<p>要提交更改，请单击项目中资源的上下文菜单中的<b>Team&gt; Commit ....</b>
		</p>
		<p>Git跟踪对整个存储库所做的所有更改，捕获该存储库中所有版本控制文件的修改，而不是关于这些文件是否驻留在同一个Eclipse项目中。</p>
		<p>一旦触发提交，将弹出<b>提交对话框</b></p>
		<p>
			<img border="0" src="images/Egit-0.9-commit-dialog.png">
		</p>
		<p>选择要提交的更改，输入提交消息并创建提交，在提交消息文本字段中按<b>Ctrl + Enter</b> （在Mac OS X上<b>输入</b> <b>Command + Enter</b> ），或单击<b>提交</b> 。
		</p>
		<h4 id="Commit_Message">提交消息</h4>
		<p>在“暂存视图”或“提交”对话框中，指定描述更改的提交消息。</p>
		<p>最好使用简短的第一行来开始消息，该行总结了更改后跟一个空行然后是消息正文。为了确保git命令行工具能够很好地格式化这些消息，不应将行格式化得太宽（这由灰色垂直线表示）。</p>
		<p>
			<img border="0" src="images/Egit-0.9-commit-dialog-spell-quickfix.png">
		</p>
		<p>Eclipse拼写检查器会检查提交消息文本是否有错误。拼写检查器可以通过Eclipse <b>首选项&gt;常规&gt;编辑器&gt;文本编辑器&gt;拼写进行配置</b> 。按<b>Ctrl + 1</b>打开快速修复程序，这可能有助于解决拼写错误。
		</p>
		<p>
			<img border="0" src="images/Egit-1.2-commit-dialog-path-assist.png">
		</p>
		<p>提交消息编辑器支持提交对话框的“文件”部分中显示的文件名的内容辅助，可以按Ctrl + Space激活。</p>
		<p></p><div id="Footer_Tags"></div>

			<b>页脚标记</b>

			<br>在提交消息的最后一段（即最后一个空白行之后），可选的页脚标记可能如下：<pre style="width:40em">错误：3176更改ID：I267b97ecccb5251cec54cec90207e075ab50503e报告人：Joe Developer &lt;joe@dev.org&gt;签名：William Shakespeare &lt;will.from@the.past&gt;</pre>
		<p>这些标记的语义是项目或工具特定的</p>
		<ul>
			<li>如果错误跟踪系统中有一个条目要提交更改，最好将其作为错误标记添加到此处</li>
			<li>
				<a href="https://www.gerritcodereview.com/" target="egit_external">Gerrit Code Review</a>使用<i>Change-Id：</i> footer将审核过程中发生的变化的不同补丁集与最终接受的补丁相关联。要生成Gerrit Change-Id，请单击<b>Comprit Change-Id以进行Gerrit Code Review</b> ;将在提交时生成ID，直到那时将null Change-Id显示为占位符。使用EGit配置参数<b>gerrit.createchangeid</b>设置为true，始终预先选择Commit对话框中的相应复选框。可以在存储库级别，系统级别或用户级别设置此参数。有关更多信息，请参阅<a href="http://wiki.eclipse.org/EGit/User_Guide#Repository_Configuration" target="egit_external">存储库配置</a> 。
			</li>
			<li>许多项目使用<i>Signed-off-by：</i> footer创建正式的声明记录，签名作者根据项目的许可和IP规则提供了更改。通过这种方式，可以在技术层面捕获项目不断发展的代码库的IP来源。请参阅Linux内核项目使用的<a href="http://elinux.org/Developer_Certificate_Of_Origin" target="egit_external">Developer Origin of Origin</a> 。如果设置了<b>Team&gt; Git&gt; Commit Dialog中</b>的EGit首选项<b>Insert Signed-off-by</b> ，则始终预先选择Commit Dialog中的相应复选框。
			</li>
		</ul>
		<p>
			<b>选择要提交的更改</b>
		</p>
		<ul>
			<li>在<b>暂存视图中</b>单击“ <b>提交”时</b> ，将仅<b>提交</b> <b>暂存的</b>更改。本机git命令行以相同的方式工作。所有未分级的更改都将保持不变并保留在您的工作目录中。此功能通常用于将对一组文件所做的修改分成不同的提交。
			</li>
			<li>在“ <b>提交”对话框中</b>单击“ <b>提交”时</b> ，可以使用每个文件前面的复选框来决定是否要将其更改包含在新提交中。如果清除文件前面的复选框，则对该文件的更改将不会包含在提交中。eclipse工作区中的本地文件仍将包含修改，使您有机会通过后续提交提交这些更改。
			</li>
		</ul>
		<p>
			<b>一个例子：</b>想象一下，自上次提交以来你已经修复了A.java中的一个bug，并且你已经为B.java添加了一个新方法。这两个修改在逻辑上彼此独立，因此您可能希望在两个独立的提交中提交它们。在这种情况下，您启动提交，从提交的文件集中取消选择B.java，并指定仅描述A.java中的错误修复的提交消息。成功第一次提交后，您只需再次调用commit，即将出现的对话框将显示B.java中的其余更改。现在，您指定一个描述添加方法的提交消息，并完成第二次提交。
		</p>
		<p>在提交对话框中，如果选中“显示未跟踪文件”复选框，则添加到项目中的新文件（如果未显式添加到版本控制中）（请参阅“修改内容”）将在提交对话框中列出。如果选择列表中这些文件前面的复选框，则会在按下提交按钮后将其添加到存储库并提交。由<tt>.gitignore</tt>文件排除的文件不会在此处显示。如果您的存储库中没有此类未跟踪文件的其他更改，则默认情况下会选中“ <b>显示未</b>跟踪文件”复选框。
		</p>
		<h4 id="Amending_Commits">修改提交</h4>
		<p>如果您在提交更改时发现错过了某些内容，则可以解决此问题：再次打开暂存视图或提交对话框，并指定当前提交将“修改”当前分支中的上一个提交。然后，新提交将替换前一个提交。此功能通常用于在将错误提交发布到其他存储库之前对其进行更正。</p>
		<p>
			<b>注意：</b>如果提交已经发布到共享存储库，请不要修改提交，因为如果他们已经根据已发布的更改进行了更改，则可能会打扰其他人。
		</p>
		<p>
			<b>修改示例：</b>

			<br>想象一下，您已经对包含拼写错误的文件进行了更改</p>
		<p>
			<img border="0" src="images/EGit-Typo.png">
		</p>
		<p>提交更改后，您会检测到拼写错误。为了纠正这个错字和相应的提交，你只需修复源文件中的拼写错误</p>
		<p>
			<img border="0" src="images/EGit-Corrected.png">
		</p>
		<p>然后再次打开Staging View或Commit Dialog并选择工具栏中的<b>Amend Previous Commit</b>图标。
		</p>
		<p>
			<img border="0" src="images/EGit_Amend_Commit_Button.png">
		</p>
		<p>然后将先前提交的提交消息（您要替换的提交消息）填入“提交消息”字段。这使您不仅可以纠正版本控制文件内容中的错误，还可以在描述更改的提交消息中更正错误（例如拼写错误）。</p>
		<p>作为修改的替代方法，您可以将更正的版本作为后续提交提交。但是第一个包含拼写错误的提交对任何人都没用，为了不使用不需要的提交弄乱你的项目的历史，你应该修改提交。</p>
		<p>请注意，修改已发布到其他存储库的提交可能会导致问题。将提交推送到远程存储库或者由其他人克隆本地存储库后，您应该非常小心地修改提交。在这种情况下，发布第二个提交来纠正第一个提交可能是一个更好的解决方案。否则通知所有其他人您修改了已发布的提交，以便他们可以做出相应的反应。</p>
		<h2 id="Reverting_Changes">还原变更</h2>
		<h3 id="Reverting_changes_in_the_working_tree">还原工作树中的更改</h3>
		<h4 id="Replace_with_File_in_Git_Index">替换为Git索引中的文件</h4>
		<p>对于一组选定的文件，可以还原尚未提交但尚未暂存的更改。在Package Explorer或类似视图中选择文件，然后单击<b>Git Index中的Replace With&gt; File</b> 。
		</p>
		<h4 id="Replace_with_HEAD">用HEAD替换</h4>
		<p>单击<b>替换为&gt; HEAD</b>以使用HEAD版本替换所选文件。您还可以使用<b>重置与</b>选项<b>很难</b>强行重置您的存储库的整个工作树回到头状态提交（参见下面的“重置当前的头”）。此操作将还原工作树和索引中的所有更改。
		</p>
		<h4 id="Replace_with_Branch.2C_Tag_or_Reference">替换为分支，标记或参考</h4>
		<p>单击<b>替换为&gt;分支，标记或引用</b> ，将所选文件替换为与分支，标记或引用对应的版本。
		</p>
		<h4 id="Replace_with_Commit">替换为Commit</h4>
		<p>单击<b>替换为&gt;提交</b>将所选文件替换为与所选提交对应的版本。
		</p>
		<h4 id="Replace_with_Previous_Revision">替换为上一版本</h4>
		<p>已经暂存或甚至已提交的更改可以通过将其替换为上一次提交中的版本来“还原”。在Package Explorer或类似视图中选择单个资源，然后单击<b>Replace With&gt; Previous Revision</b> 。存储库将确定修改所选资源的最后一次提交，并提供使用此提交的内容替换工作空间资源。
		</p>
		<p>这主要用于从提交中“删除”单个文件（在提交恢复的工作空间资源时，它们将从当前提交中有效地删除）。即使这也适用于文件夹和项目，使用“以前的版本”替换文件夹或项目的结果可能是意外的。</p>
		<h3 id="Revert_using_quickdiff">使用quickdiff还原</h3>
		<p>quickdiff功能可用于将单个更改还原为文件。您可以按行，阻止（更改行的范围）或选择进行恢复。选择所有文本，然后<b>选择还原选择</b>以还原整个文件。
		</p>
		<h3 id="Reverting_changes_introduced_by_a_specific_commit">还原特定提交引入的更改</h3>
		<p>可以通过在当前检出的提交之上自动创建的新提交来还原由给定提交引入的更改。要恢复的提交不必为此进行检查。</p>
		<p>在History View中选择commit，打开上下文菜单并选择<b>Revert Commit</b> 。这将通过在当前检出的提交之上创建新提交来恢复所选提交引入的更改。
		</p>
		<h3 id="Resetting_your_current_HEAD">重置您当前的HEAD</h3>
		<p>Git提供了将当前分支的HEAD重置为任何其他提交的可能性。它可以选择重置索引和工作树以匹配该提交。请注意，此操作会影响整个存储库中的所有文件和文件夹。</p>
		<p>您可以选择进行硬重置，混合重置和软重置。</p>
		<ul>
			<li>
				<b>soft</b> -  HEAD现在指向新提交，索引和工作树不变</li>
			<li>
				<b>混合</b> - 现在HEAD指向新提交，索引更新，工作树不变</li>
			<li>
				<b>很难</b> -  HEAD现在指向新提交，索引和工作树都会更新</li>
		</ul>
		<h4 id="Reset_to_specific_branch_or_tag">重置为特定分支或标记</h4>
		<p>在项目上选择<b>Team  - &gt; Reset ....</b>这将打开一个对话框，您可以在其中选择分支或标记。
		</p>
		<h4 id="Reset_to_a_specific_commit">重置为特定提交</h4>
		<p>在“历史记录”视图中选择提交，然后打开上下文菜单。在这里您可以找到<b>硬复位</b> ， <b>混合复位</b>和<b>软复位</b>条目。
		</p>
		<h4 id="Revert_all_local_and_staged_changes">还原所有本地和分阶段的更改</h4>
		<p>这可以使用硬重置来完成。如果您使用选项<b>hard</b>重置为当前HEAD（通常是分支上的最后一次提交），则将当前签出的分支重置为此提交，并使用HEAD的内容覆盖工作树和索引。您可以通过三种方式执行此操作：</p>
		<ul>
			<li>在项目上选择<b>Team&gt; Reset ....</b>在对话框中选择HEAD或当前分支，然后将单选按钮切换为<b>硬盘</b> 。
			</li>
			<li>右键单击并在“存储库”视图中的任何分支或标记上选择“ <b>重置...</b> ”。这将打开一个对话框，让您决定重置类型。在这里选择<b>努力</b> 。
			</li>
			<li>在历史记录视图中打开HEAD提交上下文菜单，然后选择<b>Hard Reset</b> 。
			</li>
		</ul>
		<p>
			<br>
		</p>
		<h2 id="Branching">分枝</h2>
		<h3 id="General_remarks_about_branches">关于分支的一般评论</h3>
		<p>如果不使用本地分支，则提交对本地存储库的更改是不切实际的（请参阅上面的概念部分）。此外，通过使用几个不同的分支，可以通过在这些分支之间切换来并行地处理不同的变化。</p>
		<p>因此，在开始更改本地存储库之前，第一步通常是创建本地分支。本地分支“基于”提交或远程跟踪分支。</p>
		<p>在使用远程存储库时，建议使用第二个选项，因为它通过向新的本地分支添加所谓的“上游配置”，简化了将本地更改与远程更改同步的任务。</p>
		<p>有关详细信息，请参阅<a href="#Branch_Creation_Dialog">分支创建对话</a>
		</p>
		<h4 id="Upstream_configuration">上游配置</h4>
		<p>基于本地跟踪分支的每个本地分支可以具有指示远程存储库，远程分支和所谓的拉取策略的一些附加配置。有关详细信息，请参阅<a href="#Branch_Creation_Dialog">分支创建对话</a>
		</p>
		<p>通常，在基于远程跟踪分支创建本地分支时会自动创建此配置。但是，可以在<a href="#Repository_Configuration">存储库配置中</a>显示和编辑它，也可以单击“存储库视图”中分支上的“ <b>显示”&gt;“属性</b> ”。
		</p>
		<h3 id="Checking_out_an_existing_Branch">签出现有分支机构</h3>
		<h4 id="From_the_team_menu_on_a_project_node:">从项目节点上的团队菜单：</h4>
		<ul>
			<li>选择<b>Team&gt; Switch To ...</b>并从列表中选择一个分支名称</li>
		</ul>
		<p>如果分支太多，则列表不会显示所有分支。在这种情况下</p>
		<ul>
			<li>选择<b>团队&gt;切换到...&gt;其他...</b>
			</li>
			<li>在对话框中，选择分支，标记或引用</li>
			<li>单击<b>确定</b>
			</li>
		</ul>
		<h4 id="From_the_Git_Repositories_View">从Git存储库视图</h4>
		<ul>
			<li>单击分支节点上的<b>Checkout</b></li>
			<li>或双击分支节点</li>
		</ul>
		<h4 id="From_the_History_View">从历史视图</h4>
		<ul>
			<li>单击具有分支标签的提交上的<b>Checkout</b></li>
			<li>如果多个分支指向提交，则会让您决定要检出哪个分支。</li>
		</ul>
		<h3 id="Creating_a_New_Local_Branch">创建新的本地分支</h3>
		<p>这始终使用“ <a href="#Branch_Creation_Dialog">分支创建”对话框完成</a> 。通过选中对话框上的复选框，可以选择检出新创建的分支。
		</p>
		<h4 id="From_the_team_menu">从团队菜单</h4>
		<ul>
			<li>选择<b>团队&gt;切换到...&gt;新分支....</b>
			</li>
			<li>在对话框中，选择分支，标记或引用。</li>
			<li>单击“ <b>创建分支...”</b> 。
			</li>
			<li>将打开“ <a href="#Branch_Creation_Dialog">分支创建”对话框</a> 。
			</li>
		</ul>
		<h4 id="From_the_Repositories_View">从存储库视图</h4>
		<ul>
			<li>在“分支”节点或任何“分支”，“标记”或“引用”节点上选择“ <b>创建分支...</b> ”。
			</li>
			<li>将打开“ <a href="#Branch_Creation_Dialog">分支创建”对话框</a> 。
			</li>
		</ul>
		<h4 id="From_the_History_View_2">从历史视图</h4>
		<ul>
			<li>选择<b>创建分支...</b>
			</li>
			<li>将打开“ <a href="#Branch_Creation_Dialog">分支创建”对话框</a></li>
		</ul>
		<h3 id="Renaming_an_Existing_Branch">重命名现有分支</h3>
		<h4 id="From_the_Team_menu_on_a_Project_node">从项目节点上的“团队”菜单中</h4>
		<ul>
			<li>选择<b>团队&gt;高级&gt;重命名分支...</b>
			</li>
			<li>在分支选择对话框中，选择要重命名的分支</li>
			<li>输入新分支名称，然后单击“ <b>确定”</b>
			</li>
		</ul>
		<h4 id="From_the_Repositories_View_2">从存储库视图</h4>
		<ul>
			<li>打开Git存储库视图</li>
			<li>选择<b>重命名分支...</b>或在要重命名的分支上按F2</li>
			<li>输入新分支名称，然后单击“ <b>确定”</b>
			</li>
		</ul>
		<h4 id="From_the_History_View_3">从历史视图</h4>
		<ul>
			<li>在具有分支标签的提交上选择“ <b>重命名分支...</b> ”</li>
			<li>输入新分支名称，然后单击“ <b>确定”</b>
			</li>
		</ul>
		<h3 id="Deleting_a_Branch">删除分支</h3>
		<p>以下所有操作都显示与以下相同的行为：</p>
		<ul>
			<li>无法删除当前签出的分支</li>
			<li>如果删除分支可能导致数据丢失，则会显示必须确认的警告<ul>
					<li>如果分支指向当前检出的提交无法访问的提交，则EGit会假定潜在的数据丢失</li>
				</ul>
			</li>
		</ul>
		<h4 id="From_the_Team_Menu_on_a_Project_node">从项目节点上的“团队菜单”中</h4>
		<ul>
			<li>选择<b>团队&gt;高级&gt;删除分支...</b>
			</li>
			<li>从显示的对话框中选择要删除的分支，然后按<b>确定</b>
			</li>
		</ul>
		<h4 id="From_the_Repositories_View_3">从存储库视图</h4>
		<ul>
			<li>打开Git存储库视图</li>
			<li>在要<b>删除的分支</b>上选择“ <b>删除</b>分支”</li>
		</ul>
		<h4 id="From_the_History_View_4">从历史视图</h4>
		<ul>
			<li>在具有分支标签的提交上选择“ <b>删除</b>分支”</li>
			<li>如果多个分支指向提交，将显示一个选择对话框，您可以在其中选择要删除的分支</li>
		</ul>
		<h3 id="Branch_Creation_Dialog">分支创建对话框</h3>
		<p>有几个操作可用于创建本地分支。所有这些操作都使用Branch Creation对话框：</p>
		<p>
			<img border="0" src="images/Egit-3.5-CreateBranchDialog.png">
		</p>
		<p>输入要创建的本地分支的名称。如果选择了一个远程跟踪分支的源分支，则EGit将建议创建具有相同名称的新本地分支。</p>
		<p>单击<b>选择...</b>以选择新分支应基于的源分支。通常，这是一个远程跟踪分支，但它可以是存储库中的任何分支或提交（如果您正在使用远程存储库，则不建议选择本地分支）。如果要将新分支基于提交而没有分支引用，则单击“历史记录视图”中显示的提交中的“ <b>创建分支...</b> ”。
		</p>
		<p>选择源分支时，您可以配置新分支的“上游配置”，这在获取和推送时很有用，尤其是在拉取时。根据所选选项，可以选择以下配置：</p>
		<ul>
			<li>“将上游提交合并到本地分支”：拉动时，将从上游获取更改，并更新远程跟踪分支。然后，当前本地分支将与新更改合并。如果新分支基于远程跟踪分支，则这是默认设置（但此默认设置可能会被特定存储库配置覆盖）</li>
			<li>“将本地分支的Rebase提交到上游”：当提取时，将从上游获取新的更改，并且将更新远程跟踪分支。然后将当前本地分支重新定位到更新的远程跟踪分支</li>
			<li>如果取消选中“配置上游推送和拉动”选项）：拉动时，不会对新分支进行特定的上游配置;但是，如果存在默认远程（名为“origin”的远程），则pull将尝试使用此远程的配置;如果新分支不基于远程跟踪分支，则这是默认值</li>
		</ul>
		<p>您可以在<a href="#Repository_Configuration">存储库配置中</a>查看和编辑上游配置，也可以在“存储库视图”中的分支上选择“ <b>显示”&gt;“属性</b> ”。
		</p>
		<p>EGit还支持git配置参数<code>branch.autosetuprebase</code> ，如果您想默认使用rebase pull策略，则将其设置为<code>always</code> 。如果在存储库配置中设置此选项，则将其用于基于此存储库中的远程跟踪分支创建的所有本地分支，如果在用户配置中设置它，则它将用于所有存储库。</p>
		<p>在下半部分，您可以决定是否立即检出新分支。</p>
		<h3 id="Configure_Branch_Dialog">配置分支对话框</h3>
		<p>
			<img border="0" src="images/Egit-3.5-ConfigureBranchDialog.png">
		</p>
		<p>单击“存储库视图”中分支上的“ <b>配置分支...</b> ”以更改本地分支的上游配置。选择哪个远程（“。”表示本地存储库）和所选本地分支应该跟踪的分支。如果要拉动本地分支到达跟踪分支的新更改，请选中“Rebase”，否则pull将合并到达跟踪分支的新更改。
		</p>
		<h2 id="Merging">合并</h2>
		<p>合并包含来自另一个分支或标记的更改，因为它们的历史记录从当前分支分叉到当前已检出的分支。</p>
		<h3 id="Merging_a_branch_or_a_tag_into_the_current_branch">将分支或标记合并到当前分支中</h3>
		<p>您可以从以下位置触发合并</p>
		<ul>
			<li>历史观</li>
			<li>团队菜单</li>
			<li>Git存储库视图</li>
		</ul>
		<h4 id="Starting_merge_from_the_History_View">从历史记录视图开始合并</h4>
		<p>这是启动合并的推荐视图，因为它显示了存储库的历史记录。确保在历史记录视图的工具栏中选中切换按钮<b>显示存储库中的所有更改</b>并<b>显示所有分支和标记</b> 。这可确保您查看存储库的完整历史记录，以确定要合并的分支。选择包含要合并的分支或标记标签的提交，然后单击“ <b>合并”</b> 。
		</p>
		<h4 id="Starting_merge_from_the_Team_menu">从“团队”菜单开始合并</h4>
		<p>在Package Explorer或Navigator中，打开项目节点上的上下文菜单。选择<b>团队&gt;合并...</b>
		</p>
		<p>现在合并对话框打开：</p>
		<p>
			<img border="0" src="images/Egit-3.1-MergeDialog.png">
		</p>
		<p>在对话框中，选择要与当前分支合并的分支或标记。此对话框还允许您选择合并壁球和快进选项。</p>
		<h4 id="Starting_merge_from_the_Git_Repositories_View">从Git存储库视图开始合并</h4>
		<p>如果已签出本地分支，则可以从任何分支和标记节点以及存储库节点触发合并。有关更多详细信息，请参阅<a href="#Merging_a_Branch_or_a_Tag">合并分支或标记</a> 。
		</p>
		<h4 id="Merge_options">合并选项</h4>
		<p>EGit可识别以下用于合并的快进配置选项，这些选项用于所有分支：</p>
		<pre class="source-ini">[merge] ff = true | false | only</pre>
		<p>如果只想为某个分支配置它，请使用以下命令：</p>
		<pre class="source-ini">[branch“name”] mergeoptions = --ff | --no-ff | --ff-only</pre>
		<dl>
			<dt>快进选项</dt>
			<dt>ff = true或mergeoptions = --ff</dt>
			<dd>当合并解析为快进时，仅更新分支指针，而不创建合并提交。这是默认行为。</dd>
		</dl>
		<dl>
			<dt>ff = false或mergeoptions = --no-ff</dt>
			<dd>即使合并解析为快进，也要创建合并提交。</dd>
		</dl>
		<dl>
			<dt>ff = only或mergeoptions = --ff-only</dt>
			<dd>拒绝合并并中止合并操作，除非当前HEAD已经是最新的，或者合并可以作为快进解决。</dd>
		</dl>
		<p>从团队菜单“Team&gt; Merge ...”开始合并时，您可以在合并对话框中设置快进，压缩或无提交合并选项：</p>
		<p>
			<img border="0" src="images/Egit-3.4-merge-options.png">
		</p>
		<h4 id="Possible_merge_results">可能的合并结果</h4>
		<p>按下“合并”按钮后，可能会出现以下情况：</p>
		<ul>
			<li>
				<i>已经是最新的</i> ：您当前的分支指向一个提交，其中选定的分支或标记为前一个。在这种情况下，没有任何改变。
			</li>
			<li>
				<i>快进</i> ：您当前的分支指向提交，该提交是所选分支或标记的前身。在这种情况下，移动分支并指向选定的分支或标记;这个新的HEAD被签出到工作树。使用远程存储库时，快进非常常见：更新远程跟踪分支时，与相应分支的合并通常是快进的。您可以通过获取远程分支（例如origin / master）并将其合并到相应的本地分支（例如master）来执行pull。
			</li>
			<li>
				<i>真正的合并</i> ：当上述条件都不适用时，egit会触发提交的合并。有两种可能的结果：如果没有冲突发生，当前分支将指向新创建的合并提交;如果发生冲突，冲突的文件将使用标签装饰器标记（请参阅<a href="#Resolving_a_merge_conflict">解决合并冲突，</a>以便在<a href="#Resolving_a_merge_conflict">发生合并冲突</a>时进一步执行操作）。
			</li>
		</ul>
		<h5 id="Merge_Result_dialog">合并结果对话框</h5>
		<p>合并的结果总结在一个对话框中：</p>
		<p>
			<img border="0" src="images/Egit-3.1-MergeResultDialog.png">
		</p>
		<p>在第一行，您可以看到合并的结果。可能的结果是“已经是最新的”，“快进”，“合并”，“冲突”或“失败”。“失败”的可能原因可能是工作目录中存在冲突的更改。</p>
		<p>在第二行，您会看到新的HEAD提交，以便成功合并（已经是最新的，快进的或合并的）。</p>
		<p>在表中，您可以看到合并的提交。</p>
		<h3 id="Resolving_a_merge_conflict">解决合并冲突</h3>
		<p>合并可能导致需要用户操作的冲突。当文件内容无法自动合并时就是这种情况。这些冲突在分段视图中标有标签修饰。使用分段视图来查找具有冲突的文件以便解决它们非常方便，因为分段视图仅显示已修改的文件，因此您不必浏览所有资源，只需要注意那些可能需要您注意解决的资源。冲突。</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingViewConflicts.png">
		</p>
		<p>此外，冲突资源在项目浏览器或包资源管理器视图等导航树中进行修饰</p>
		<p>
			<img border="0" src="images/Egit-0.10-merge-conflict.png">
		</p>
		<p>文件内容中的合并冲突以文本冲突标记呈现（有关详细信息，请参阅<a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html#_how_conflicts_are_presented" target="egit_external">http://www.kernel.org/pub/software/scm/git/docs/git-merge.html#_how_conflicts_are_presented</a> ）。
		</p>
		<h4 id="Using_Merge_Tool">使用合并工具</h4>
		<ul>
			<li>选择显示红色冲突标签装饰器的顶级资源</li>
			<li>单击<b>团队&gt;合并工具</b>
			</li>
			<li>选择合并模式<i>使用冲突文件的HEAD（最后一个本地版本），</i>然后单击“ <b>确定”</b>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-select-merge-mode.png">
		</p>
		<ul>
			<li>合并编辑器打开，在左窗格中显示工作树版本，在右窗格中显示要合并的版本</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-merge-tool.png">
		</p>
		<ul>
			<li>编辑工作树版本，直到您满意为止</li>
			<li>
				<b>团队&gt;添加</b>合并的资源以将冲突标记为已解决</li>
			<li>通过<b>Team&gt; Commit提交</b>合并<b>提交</b>
			</li>
		</ul>
		<h4 id="Manual_conflict_resolution">手动解决冲突</h4>
		<p>要解决冲突，您必须执行以下步骤：</p>
		<ul>
			<li>导航到冲突的资源</li>
			<li>编辑冲突资源的内容</li>
			<li>告诉EGit使用<b>Team&gt; Add</b>解决冲突
			</li>
			<li>使用<b>Team&gt; Commit提交</b>冲突解决方案
			</li>
		</ul>
		<h4 id="Finding_conflicting_files">查找冲突的文件</h4>
		<p>包含冲突文件的存储库具有附加到存储库名称的文本标签装饰器“| Conflicts”。包含此类冲突资源的冲突资源和文件夹会触发冲突标签。</p>
		<p>
			<img border="0" src="images/Conflicts.png">
		</p>
		<p>Alternativley，很容易找到暂存区域中所有冲突文件的列表。打开<b>Git Staging</b>视图。左侧将显示与装饰器冲突的文件。 <img border="0" src="images/Git_merge_conflict.png">
		</p>
		<h4 id="Editing_conflicting_files">编辑冲突的文件</h4>
		<p>在文件内容中，发生一对冲突变化的区域标有标记&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt;。=======之前的部分通常是你的一方，之后的部分通常是他们的一面（参见<a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html#_how_conflicts_are_presented" target="egit_external">http://www.kernel.org/pub/software/scm/git/docs/git-merge。 html＃_how_conflicts_are_presented</a>了解更多详情）。
		</p>
		<p>在编辑器中打开文件，编辑内容并保存编辑器。</p>
		<p>请注意，此步骤不是必需的。EGit不会检查内容以确定冲突是否已解决。下一步是相关的一步。</p>
		<h4 id="Adding_conflict_resolution_to_the_git_index">将冲突解决方案添加到git索引</h4>
		<p>编辑完文件后，可以在暂存视图中单击“ <b>添加到索引”</b> ，或单击“ <b>团队”&gt;“添加”</b>将冲突解决方案<b>添加</b>到git索引。这也将相应的冲突标记为已解决。
		</p>
		<p>解决所有冲突后，文本存储库标签修饰将更改为“已合并”。没有冲突标记了。</p>
		<p>
			<img border="0" src="images/ResolvedConflicts.png">
		</p>
		<h4 id="Committing_a_merge">提交合并</h4>
		<p>当存储库处于“合并”状态时（如附加到存储库名称的文本标签装饰器“| Conflicts”所示），最终可以提交合并。</p>
		<p>在暂存视图中，您可能希望从合并操作生成的标准合并提交消息中删除冲突备注，并在必要时更新提交消息。然后单击“ <b>提交”</b>以提交冲突解决方案。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingViewConflictsResolved.png">
		</p>
		<p>如果要使用“提交”对话框提交冲突解决方案，请单击导航树中任意位置的“ <b>团队”&gt;“提交...”</b> 。与正常提交相比，打开提交对话框的外观略有不同：</p>
		<ul>
			<li>提交消息区域预先填充标准合并提交消息。</li>
			<li>无法修改先前的提交。</li>
			<li>无法添加未跟踪的文件。</li>
			<li>无法取消选中复选框。这可以保证所有已解决的冲突都已提交。</li>
		</ul>
		<p>按“提交”按钮后，合并完成。</p>
		<h3 id="Aborting_Merge">中止合并</h3>
		<p>如果合并导致冲突，您可以通过硬重置到当前分支来中止合并。这可以在状态“冲突”和状态“合并”中完成，即在您解决冲突之前和之后。</p>
		<p>硬重置可以从团队菜单，Git存储库视图或历史记录视图完成。有关更多详细信息，请参阅<a href="#Revert_all_local_and_staged_changes">还原所有本地和分阶段更改</a> 。
		</p>
		<p>
			<br>
		</p>
		<h2 id="Rebasing">垫底</h2>
		<h3 id="Rebase_Introduction">Rebase简介</h3>
		<p>Rebase将一系列提交应用于给定的提交。典型的情况是在“主题”分支上开发某些功能，该分支是在某个时间点从“主”分支创建的。当“主题”更新时，例如来自其他开发人员的更改，而“主题”仍在开发中，可能有必要将这些更改合并到“主题”中。
			<br>
		</p>
		<p>假设我们通过从master创建“topic”分支来开始“topic”的开发。此时，“主”和“主题”都指向提交“E”。当第一次提交（“A”）添加到“topic”时，存储库的提交历史记录如下所示：<br>
		</p>
		<pre>一个主题/ D --- E大师</pre>
		<p>现在，我们假设有一些关于“主题”的提交以及更多关于“master”的提交（例如，“master”可能会跟踪一些远程存储库，并且该远程存储库中的某些更改已被拉入“主”）：<br>
		</p>
		<pre>A --- B --- C主题/ D --- E --- F --- G主人</pre>
		<p>现在，为了将“主”中的变化合并到“主题”中，将“主题”的重新基础转换为“主”将产生<br>
		</p>
		<pre>A' -  B' -  C'主题/ D --- E --- F --- G主人</pre>
		<p>
			<br>从技术上讲，“主题”中包含但未在“主”中包含的提交顺序将逐一应用于“主”之上（即，采用樱桃挑选）。
			<br>
		</p>
		<p>请注意，提交A，B，C既不会丢失也不会更改，而是会创建一个新的提交链A'，B'，C'，其具有与原始提交相同的更改和提交消息（但不同的提交ID）。旧提交A，B，C仍在对象数据库中，但不再可见，因为它们不再可从任何分支到达。A'，B'，C'与旧的不同，因为它们现在还包含变化F和G.</p>
		<h3 id="Rebase.2C_A_Simple_Example">Rebase，一个简单的例子</h3>
		<p>让我们看一些简单的例子：我们有一个文本文件“FamousWords.txt”，它最初可能有一些像</p>
		<pre>第1章曾几何时......第二章是或不是</pre>
		<p>现在，在“topic”中，创建了两个提交，第一个提交法语翻译到第2章，另一个添加德语翻译：</p>
		<p>首次更改“主题”后：<br>
		</p>
		<pre>第1章曾几何时......第二章是或不是pas pas pas re re</pre>
		<p>在“主题”中进行第二次更改后：<br>
		</p>
		<pre>第1章曾几何时......第二章是否成为Sein oder nicht sein</pre>
		<p>同时，通过添加两个将法语和德语翻译添加到第1章的提交，在“master”中更改了文件：<br>
		</p>
		<pre>第1章曾几何时......Ilétaitunefois Es war einmal第2章是或不是</pre>
		<p>提交历史记录如下所示：</p>
		<p>
			<img border="0" src="images/EGit-0.10-MergeDemoHistory.png">
		</p>
		<p>现在，如果“主题”被重新命名为“主”，则主题中的两个更改将按照与“主题”演变期间应用的顺序相同的顺序应用。</p>
		<p>结果是“FamousWords.txt”的合并版本：<br>
		</p>
		<pre>第1章曾几何时......Ilétaitunefois Es war einmal Chapter 2成为或不成为Setre ou nepasêtreSeinoder nicht sein</pre>
		<p>以及在当前“master”之上具有“topic”提交历史的提交历史记录：<br>
		</p>
		<p>
			<img border="0" src="images/EGit-0.10-MergeDemoHistoryAfterRebase.png">
		</p>
		<h3 id="The_Real_World:_Rebase_Conflicts">真实世界：Rebase冲突</h3>
		<p>到目前为止，我们假设“主题”中的更改可以自动合并为“主”。然而，在现实世界中，您可能会遇到在rebase期间遇到冲突。现在，如果要挑选的提交包含与“master”中的更改冲突的更改，则在应用冲突更改后，rebase操作会中断;冲突以通常的方式（使用冲突标记）可视化，用户有机会决定是否</p>
		<ul>
			<li>手动解决这些冲突，</li>
			<li>跳过当前提交，或</li>
			<li>彻底中止了</li>
		</ul>
		<p>如果选择了<b>Resolve Conflicts</b> ，并且手动解决了冲突，则必须“添加”更改，然后可以恢复rebase，即将应用链中的下一个提交。
		</p>
		<p>如果选择了<b>Skip</b> ，则将恢复冲突的更改，并将应用链中的下一个提交。
		</p>
		<p>如果选择<b>Abort</b> ，则将完全回滚rebase操作，在rebase启动之前将Repository恢复到其原始状态。重复此过程，直到成功应用或跳过最后一次提交。最后，“topic”分支将更改为指向最后一次提交。
		</p>
		<p>为了更好地理解“跳过”，让我们回顾上面的介绍。如果我们假设提交“B”导致与当前“主”的一些冲突，则用户可能决定简单地跳过“B”;然后，rebase之后的新提交历史将如下所示：</p>
		<pre>一个' -  C'主题/ D --- E --- F --- G主人</pre>
		<h3 id="Starting_Rebase">启动Rebase</h3>
		<p>
			<b>在历史记录视图中：</b>
		</p>
		<ul>
			<li>签出要重新分支的分支</li>
			<li>选择要为已签出分支重新定义的提交。此提交将成为所有提交重新提交的新基础</li>
			<li>单击<b>Rebase</b>
			</li>
		</ul>
		<p>
			<b>在Git Repositories View：</b> On Repository节点中， <b>Rebase ...</b>打开一个对话框，要求用户选择未签出的分支;然后将当前签出的分支重新定位到所选分支。在“分支”节点（本地和远程跟踪分支，但不在当前已检出的分支上）， <b>Rebase</b>立即将当前签出的分支重新绑定到选定的分支上：</p>
		<p>
			<img border="0" src="images/EGit-0.10-StartRebaseFromRepoView.png">
		</p>
		<h3 id="Rebase_Confirmation_Dialog">Rebase确认对话框</h3>
		<p>如果Rebase成功，将显示确认对话框;勾选复选框可以抑制此对话框; Git首选项页面上的首选项允许再次显示对话框。如果禁止该对话框，则会将“Information”消息写入Eclipse日志。</p>
		<h3 id="Rebase_Conflicts">Rebase冲突</h3>
		<p>如果在rebase期间发生冲突，则会显示一个对话框，其中提供有关导致冲突的提交的一些信息。通过选择单选按钮，您可以决定是否</p>
		<ul>
			<li>启动合并工具以手动解决冲突</li>
			<li>跳过当前提交</li>
			<li>彻底放弃了篮板</li>
			<li>什么都不做（返回工作台），这相当于击中“Escape”：</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-3.1-RebaseResultWizard.png">
		</p>
		<p>除非在对话框中选择了“ <b>跳过”</b>或“ <b>中止”</b> ，否则必须通过编辑冲突文件手动解决冲突。完成编辑后，必须通过将文件添加到git索引来声明文件已解析。
		</p>
		<p>如果您取消了rebase向导，则查找具有冲突的文件的最简单方法是使用Staging View。点击<b>合并工具</b>与冲突，打开该文件合并工具的文件。也可以从“团队”菜单中的相应条目启动“合并工具”。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingViewOpenMergeTool.png">
		</p>
		<p>编辑文件，直到您对冲突解决方案感到满意为止，然后在暂存视图中的相应条目上单击<b>添加到索引</b> 。这将解决冲突，并标志着冲突得到解决。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingViewMarkResolved.png">
		</p>
		<p>解决所有冲突后，将启用“ <b>继续”</b>操作。要继续由于冲突而停止的rebase操作，请单击Staging View中的<b>Continue</b>按钮，或单击Repositories View中存储库节点上的<b>Rebase&gt; Continue</b> 。
		</p>
		<p>
			<img border="0" src="images/Egit-3.1-StagingViewRebaseButtons.png">
		</p>
		<p>如果您想跳过导致冲突的提交而不是解决冲突，请单击“ <b>跳过”</b> 。
		</p>
		<p>如果要中止正在进行的rebase操作，请单击“ <b>中止”</b> 。这会将所有内容恢复到开始rebase之前的状态。
		</p>
		<h3 id="Aborting_Rebase">中止Rebase</h3>
		<p>只要存储库处于“重新启动”状态，用户就可以使用存储库节点上提供的菜单操作“Rebase&gt; Abort”来中止Git存储库视图中的rebase。</p>
		<h2 id="Interactive_Rebase">交互式Rebase</h2>
		<h3 id="Synopsis">概要</h3>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseView.png">
		</p>
		<p>交互式rebase允许使用rebase计划中定义的以下操作快速编辑一系列提交：</p>
		<ul>
			<li>
				<b>选择</b>定义提交的顺序，移动选择条目启用重新排序</li>
			<li>
				<b>跳过</b>删除提交</li>
			<li>
				<b>编辑</b>以修改提交</li>
			<li>
				<b>reword</b>编辑提交的消息</li>
			<li>
				<b>压缩</b>以使用其前任提交压缩提交并包括其提交消息</li>
			<li>
				<b>修复</b>将提交的差异压缩到其前任中，丢弃压缩的提交消息</li>
		</ul>
		<p>
			<b>警告：</b>不要重写您已经在远程存储库上发布的提交，除了实验或审查分支以外，它被认为是一种不好的做法，因为您的同事可能已将他们的工作基于这些已发布的提交，并且您将迫使他们重写他们的变化。虽然它是审查分支上经常使用的工具，例如，当使用Gerrit进行返工时，必须根据审核反馈进行改进。
		</p>
		<h3 id="Starting_interactive_rebase">启动交互式rebase</h3>
		<p>首先签出包含要编辑的提交系列的本地分支（此处为分支<i>toRebase</i> ）。然后打开此存储库的历史记录视图，并在要重写的最早提交之前的提交上单击<b>Interactive Rebase</b> 。通常这是一个原点/主要点。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-StartInteractiveRebase.png">
		</p>
		<p>这将打开新视图<b>Git Interactive Rebase，</b>显示使用要在修订操作期间处理它们的顺序中按拓扑顺序修改的提交填充的rebase计划。所有提交的初始操作是<b>Pick</b> ，它会挑选相应的提交。请注意，EGit还会将HEAD重新排序到编辑列表中第一个之前的提交，以便为存储库准备变基。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-StartedInteractiveRebase.png">
		</p>
		<h3 id="Planning_rebase">规划变革</h3>
		<p>这里是最初的rebase计划，第一个应用于倒带HEAD的提交首先进行，然后所有其他提交将按照单击“开始”时应用的顺序进行重新设置。</p>
		<p>
			<img border="0" src="images/Egit-3.2-PlanInteractiveRebase.png">
		</p>
		<p>接下来，我们准备rebase计划，使用箭头按钮上下移动提交以重新排序提交，并选择我们要应用于要调整的提交的rebase操作。</p>
		<p>在这个例子中，我首先对提交进行了重新排序，以便新的计算器操作的实现紧接在提交相应操作的提交之前。</p>
		<p>
			<b>这是我要在这一系列提交中修改的内容：</b>
		</p>
		<p>我想跳过提交“TODO列表”，因为它包含我在实现操作时使用的私有待办事项列表，我不再需要它了。我需要修改提交“添加除法操作”，因为它是错误的，这是通过相应的测试显示的，这是在稍后的更改中实现的，因此我选择操作<b>编辑</b>这里提交“添加乘法操作”显然在提交消息中有拼写错误标题，所以我选择<b>Reword</b> 。我想将de7647b压缩到它的前身，因为将JavaDoc修复与其描述的实现分开是没有意义的，因此我选择<b>Squash</b>将其与其前身压缩。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseView.png">
		</p>
		<h3 id="Executing_interactive_rebase">执行交互式rebase</h3>
		<p>完成规划后，单击“ <b>开始”</b>以开始执行rebase命令。EGit将处理计划并在您已选择需要干预的操作的提交处停止，以交互方式编辑相应的提交。
		</p>
		<p>在我们的小例子中，rebase第一次在提交“添加除法运算”时停止，因为我们发信号通知我们要编辑它。最后选择的提交以粗体突出显示。此时，跳过提交“TODO列表”的第一步已经处理完毕，并且此提交不再出现在我们执行rebase时重写的提交系列中。由于我们想修改它，所以提交“添加除法操作”已经被挑选出来了。请注意，EGit已在分段视图中选择了“修改”选项，以便准备修改此提交。</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseEdit.png">
		</p>
		<p>现在我们修复此提交中的错误，分阶段修复错误所需的更改，必要时调整提交消息，然后单击<b>Commit</b>以修改错误提交。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseAmend.png">
		</p>
		<p>让我们看一下历史视图，看看生成的提交图。HEAD现在指向重写的固定提交“添加除法运算”，请注意其SHA1与其原始版本不同，因为我们重写了提交以修复错误。</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseHistoryAfterEdit.png">
		</p>
		<p>接下来，我们单击<b>继续</b>以继续处理rebase计划。Rebase选择提交“Divide test”和“Add multiply opration”并再次停止引发提交消息编辑器，以便我们可以在后一次提交的提交消息中修复拼写错误。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseReword.png">
		</p>
		<p>编辑提交消息以修复拼写错误并单击“ <b>确定”</b>以修改提交消息并恢复处理。
		</p>
		<p>Rebase选择接下来的3次提交，将提交“添加电源”和“修复javadoc for power operation”压缩到一个新提交中并再次停止，以便我们可以准备新提交的提交消息。它的初始化与提交的消息串联被压扁。</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseSquash.png">
		</p>
		<p>编辑压缩提交的消息，然后单击“ <b>确定”</b>以继续处理。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseSquashMessage.png">
		</p>
		<p>Rebase选择最终提交“Power test”并成功完成。</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseFinished.png">
		</p>
		<p>最后，让我们在历史记录视图中再次查看以检查交互式rebase命令的结果。比较现在包含在分支“toRebase”中的重写提交系列与仍然可见的旧提交系列，因为我已将另一个本地分支“start”放在那里以保持旧系列可见。</p>
		<p>
			<img border="0" src="images/Egit-3.2-InteractiveRebaseHistoryAfterRebase.png">
		</p>
		<h3 id="Safety_Instructions">安全指导</h3>
		<p>如果在这个多步骤过程中碰巧出错，您可以始终点击<b>Abort</b>以停止正在进行的rebase操作并回滚到起点。
		</p>
		<p>当你开始使用这个功能时，最好在起点上放置第二个本地分支（正如我在这个例子中所示），以便在你熟悉这个强大的git命令之前更明显地发生了什么。</p>
		<h3 id="Rebase_with_auto-stashing">重新启动自动存储</h3>
		<p>EGit还支持Git配置选项<b>rebase.autostash</b> 。设置此选项<b>rebase.autostash = true</b>可在rebase操作开始之前自动创建临时存储，并在操作结束后应用它。这意味着您可以在脏工作树上运行rebase和交互式rebase。但是， <b>谨慎使用：</b>成功重组后的最终存储应用程序可能会导致非平凡的冲突。
		</p>
		<h2 id="Cherry_Picking">采摘樱桃</h2>
		<h3 id="Cherry-pick_Introduction">樱桃挑选介绍</h3>
		<p>分支<i>stable-1.0</i>上的给定提交<i>C</i>包含一组您希望在分支<i>主机</i>上的当前开发中集成的更改。
		</p>
		<pre>A  -  B  -  C  -  D稳定-1.0 / D --- E --- F --- G主HEAD</pre>
		<p>Cherry-选择提交<i>C</i>以在当前检出的分支<i>主机</i>的头部提交之上创建新的提交<i>C'</i> 。
			然后， <i>C'</i>将包含在<i>C中</i>执行的更改，这些更改应用于当前检出的分支<i>主机</i>的HEAD。
		</p>
		<pre>A  -  B  -  C  -  D稳定-1.0 / D --- E --- F --- G  -  C'主HEAD</pre>
		<h3 id="Cherry-pick_Example">樱桃采摘示例</h3>
		<p>您目前正在处理分支“feature2”（HEAD）。在另一个分支中有一个提交“功能1”。
			<br>您希望将提交“功能1”执行的更改集成到分支“功能2”的当前开发中。
		</p>
		<ul>
			<li>在历史记录视图中，选择提交“功能1”，然后单击<b>Cherry-pick</b> ：</li>
		</ul>
		<p>
			<img border="0" src="images/CherryPick1.png">
		</p>
		<ul>
			<li>结果，您在当前分支“功能”的顶端获得一个新提交“功能1”，其中包含“功能1”的更改：</li>
		</ul>
		<p>
			<img border="0" src="images/CherryPick2.png">
		</p>
		<ul>
			<li>采摘樱桃会遇到冲突。在这种情况下，冲突标记将呈现在受影响的源中：</li>
		</ul>
		<p>
			<img border="0" src="images/CherryPick3.png">
		</p>
		<ul>
			<li>打开暂存视图以快速查找冲突的文件。</li>
			<li>点击<b>合并工具</b>与冲突要打开的文件合并工具，此文件</li>
			<li>通过以与<a href="#Resolving_a_merge_conflict">解决合并冲突</a>中所述相同的方式编辑相应的源来<a href="#Resolving_a_merge_conflict">解决冲突</a>
			</li>
			<li>
				<b>添加</b>您编辑的文件以标记已解决的冲突</li>
			<li>
				<b>承诺</b>解决冲突</li>
		</ul>
		<p>
			<br>
		</p>
		<h2 id="Tagging">标记</h2>
		<h3 id="Creating_a_Tag">创建标签</h3>
		<ul>
			<li>打开历史记录视图，然后在要标记的提交上单击“ <b>创建标记...</b> ”</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-3.1-CreateTagDialog.png">
		</p>
		<ul>
			<li>输入标签名称</li>
			<li>输入标签消息</li>
			<li>单击“ <b>确定”</b>以创建带注释的标记</li>
		</ul>
		<p>也可以从团队菜单创建标签，单击<b>团队&gt;高级&gt;标签...</b> ，输入标签名称和消息，选择要标记的提交（默认为HEAD），然后单击<b>确定</b> 。</p>
		<h3 id="Replacing_an_Existing_Tag">替换现有标记</h3>
		<p>如果您标记了错误的提交或最终出现某种拼写错误该怎么办？</p>
		<ul>
			<li>如果你还没有推出它，只需更换标签就可以了。</li>
			<li>
				<b>如果它已经发布，你不应该替换标签，</b>而是使用新名称，否则你必须告诉每个获得旧标签的人用你的更新标签手动替换它。这是因为，Git没有（也不应该）改变用户背后的标签。因此，如果某人已经获得了旧标签，那么在树上执行git pull不应该只是让它们覆盖旧的标签。
			</li>
		</ul>
		<p>因此，如果您的旧标签尚未推送，您可以通过以下方式更正它：</p>
		<ul>
			<li>在历史记录视图中，单击要放置标记的提交上的<b>标记....</b></li>
		</ul>
		<p>
			<img border="0" src="images/Egit-3.1-ReplaceExistingTag.png">
		</p>
		<ul>
			<li>从现有标记列表中选择要替换的标记</li>
			<li>或者在“标记名称”字段中键入您要查找的标记的任何部分，这会将现有标记的列表过滤到包含您键入的字符串的那些标记，然后选择要替换的标记</li>
			<li>标记复选框<b>强制替换现有标记</b>
			</li>
			<li>更改标签，然后按<b>确定</b>
			</li>
		</ul>
		<h3 id="Deletion_of_tags">删除标签</h3>
		<p>要删除标记，请选择要删除的标记，然后单击“ <b>删除标记”</b> 。
		</p>
		<p>
			<b>注意：</b>删除已在公共服务器上发布的标记是一种不好的做法，一些Git服务器甚至不允许删除标记以确保通常标记的版本的可追溯性。另请参阅tag命令的Git参考文档中的<a href="http://schacon.github.com/git/git-tag.html" target="egit_external">“重新标记”部分</a> 。
		</p>
		<h3 id="Light-weight_and_Signed_Tags">轻量级和签名标签</h3>
		<p>轻量级标签显示在“存储库”视图和“创建标签”对话框中，但无法进行编辑。标签在存储库视图中显示为蓝色图标，带注释的标签用黄色人物装饰。</p>
		<p>
			<img border="0" src="images/Egit-1.1-tags.png">
		</p>
		<p>在历史记录视图中，标记显示为黄色标签。</p>
		<p>
			<img border="0" src="images/Egit-1.1-tags-history.png">
		</p>
		<p>EGit尚不支持签名标签，而是使用命令行<tt><b>git tag -s</b></tt> 。
		</p>
		<p>
			<br>
		</p>
		<h2 id="Patches">补丁</h2>
		<h3 id="Creating_Patches">创建补丁</h3>
		<p>“补丁是一种软件，旨在解决计算机程序或其支持数据的问题或更新”（ <a href="http://en.wikipedia.org/wiki/Patch_(software)" target="egit_external">维基百科</a> ）。补丁文件包含一组资源更改的描述，这些更改可以自动应用于另一个eclipse工作空间或git存储库。
		</p>
		<p>eclipse（ <b>Team&gt; Apply Patch</b> ）和git（ <tt><b>git apply</b></tt>或<tt><b>git am</b></tt>在命令行中）使用的补丁格式是不同的。可以在EGit中创建两种类型的补丁。
		</p>
		<h4 id="Create_a_Patch_from_a_Commit">从提交创建修补程序</h4>
		<p>这是分布式版本控制系统的最常见用例。开发人员对本地功能或错误修复分支进行更改，并希望将此更改导出到修补程序文件中。</p>
		<p>它可以从历史视图中完成：</p>
		<p>
			<img border="0" src="images/Egit-0.0-create-patch-menu.png">
		</p>
		<p>补丁文件将包含历史记录视图中提交与其父级之间的差异。请注意，历史记录视图的过滤器也适用于修补程序创建。</p>
		<h4 id="Patch_Wizard">补丁向导</h4>
		<p>向导由两页组成。第一页允许您选择补丁的位置：</p>
		<p>
			<img border="0" src="images/Egit-0.0-create-patch-dialog.png">
		</p>
		<p>补丁文件的名称是从提交消息的第一行创建的。</p>
		<p>在第二页上，您可以更改修补程序格式。</p>
		<p>目前有一个复选框： <b>以git补丁格式导出</b> 。
		</p>
		<ul>
			<li>如果你不检查它（这是默认值），可以使用eclipse <b>Apply Patch ...</b>向导<b>应用补丁</b> 。这些路径是相对于eclipse项目的，不包含前缀（如git命令行中的<tt><b>git format-patch --no-prefix</b></tt> ）。
			</li>
			<li>如果你检查它，补丁将看起来像git命令行上的git <tt><b>format-patch --no-stat</b></tt>的结果。
			</li>
		</ul>
		<p>目前没有生成二进制差异。</p>
		<h3 id="Applying_Patches">应用补丁</h3>
		<p>目前，EGit无法以git格式应用补丁。可以使用<b>Team&gt; Apply Patch ...</b>使用标准Eclipse（统一差异）格式<b>应用补丁</b> 。Git补丁可能包含重命名和二进制差异的非标准扩展。当前版本的EGit不会生成这些扩展。
		</p>
		<p>
			<br>
		</p>
		<h2 id="Managing_Repositories">管理存储库</h2>
		<p>“Git存储库视图”是促进同时处理多个存储库（即在一个Eclipse工作区内）的主要UI元素。</p>
		<p>可以使用菜单路径打开此视图<br> 
			<b>窗口&gt;显示视图&gt;其他...&gt; Git&gt; Git存储库</b>
		</p>
		<p>它也是使用菜单路径提供的“Git Repository Exploring”透视图的一部分<br> 
			<b>Window&gt; Open Perspective&gt; Other ...&gt; Git Repository Exploring</b>
		</p>
		<p>如果您的工作区中已经有与Git存储库共享的项目，则可以使用<br>
			<b>团队&gt;在存储库视图中显示</b>
		</p>
		<p>在任何资源上打开视图。</p>
		<h3 id="Adding_Repositories_to_the_Git_Repositories_View">将存储库添加到Git存储库视图</h3>
		<p>最初，Git存储库视图为空。为了向其添加存储库，有以下几种选择：</p>
		<ol>
			<li>手动从本地文件系统添加存储库</li>
			<li>克隆存储库并自动将克隆的存储库添加到视图中</li>
			<li>在本地文件系统上创建存储库</li>
			<li>通过将Git存储库路径粘贴到视图来添加存储库</li>
		</ol>
		<h4 id="Adding_a_Repository_manually">手动添加存储库</h4>
		<p>您可以将本地文件系统中的存储库添加到Git存储库视图而不进行克隆。如果您要设置新的Eclipse工作区并希望重新使用Git存储库，这将非常有用。使用视图工具栏中的<b>添加现有Git存储库</b>按钮：</p>
		<p>
			<img border="0" src="images/RepoMgrAddRepositoryIcon.png">
		</p>
		<p>将出现一个对话框，提示您输入本地文件系统的目录。选择正确的目录后，可以单击“ <b>搜索”</b>按钮以查看此目录中的Git存储库列表。然后，您可以选择一些或所有找到的存储库，并使用<b>确定</b>将它们添加到视图中：</p>
		<p>
			<img border="0" src="images/Egit-0.11-import-projects-add-dialog.png">
		</p>
		<h4 id="Cloning_a_Repository_2">克隆存储库</h4>
		<p>要克隆存储库，请参阅<a href="#Cloning_a_Repository">克隆远程存储库</a> 。成功执行克隆操作后，新克隆的存储库应自动显示在Git存储库视图中。
		</p>
		<p>您还可以使用视图工具栏中的<b>克隆一个Git存储库</b>按钮来启动克隆向导：</p>
		<p>
			<img border="0" src="images/RepoMgrCloneRepositoryIcon.png">
		</p>
		<p>请参阅<a href="#Cloning_a_Repository">克隆远程存储库</a>有关如何使用向导的信息。
		</p>
		<h4 id="Creating_a_Repository">创建存储库</h4>
		<p>您可以在本地文件系统上创建一个新的空存储库。如果您以后想要在此存储库下创建一个或多个新项目，这将非常有用。另一个用例是创建一个新的裸存储库，您可以在其中推送。使用视图工具栏中的<b>Create a new Git Repository</b>按钮：</p>
		<p>
			<img border="0" src="images/RepoMgrCreateRepositoryIcon.png">
		</p>
		<p>将出现一个对话框，您可以在其中选择目录：</p>
		<p>
			<img border="0" src="images/RepoMgrCreateRepositoryDialog.png">
		</p>
		<p>如果选中<b>Create as Bare Repository</b>复选框<b>，</b>则新存储库将没有工作目录。然后，您只能通过从另一个存储库推送更改来添加内容。
		</p>
		<h4 id="Adding_a_Repository_using_Copy_and_Paste">使用复制和粘贴添加存储库</h4>
		<p>作为一种快捷方式，还可以将剪贴板中的Git存储库的本地文件系统路径粘贴到此视图中。为此，将Git存储库的路径（其<code>.git</code>文件夹的完整路径）复制到剪贴板，然后在视图面板上打开上下文菜单：</p>
		<p>
			<img border="0" src="images/RepoMgrPasteRepositoryPath.png">
		</p>
		<p>或单击主菜单中的<b>编辑&gt;粘贴</b> （或相应的键盘快捷键）。如果剪贴板内容不合适，将显示错误弹出窗口，否则添加的存储库应自动显示。
		</p>
		<p>在使用某些存储库填充视图后，它应如下所示：</p>
		<p>
			<img border="0" src="images/RepoMgrViewWithRepos.png">
		</p>
		<h3 id="Removing_Repositories">删除存储库</h3>
		<h4 id="Removing_a_Repository_from_the_Repositories_View">从存储库视图中删除存储库</h4>
		<p>要从存储库视图中删除存储库，请选择存储库并单击“删除存储库”</p>
		<p>
			<img border="0" src="images/Egit-0.10-RemoveRepository.png">
		</p>
		<h4 id="Deleting_a_Repository">删除存储库</h4>
		<p>要删除存储库，请在“存储库视图”中选择它，然后单击“删除存储库”。</p>
		<p>
			<img border="0" src="images/Egit-0.10-DeleteRepository.png">
		</p>
		<p>然后确认您要删除存储库，并确定是否要从Eclipse工作区中删除存储库中包含的项目的存储库工作目录。</p>
		<p>
			<img border="0" src="images/Egit-3.1-DeleteRepository.png">
		</p>
		<p>
			<br>
		</p>
		<h3 id="Structure_of_the_Git_Repositories_View">Git存储库视图的结构</h3>
		<p>以下屏幕截图显示了Git存储库视图的最顶层两个级别：</p>
		<p>
			<img border="0" src="images/Egit-0.11-RepoViewTopLevel.png">
		</p>
		<p>根节点表示存储库本身。节点文本指示存储库的名称及其在本地文件系统中的位置。“分支”和“标签”节点允许浏览和操纵标签和分支。“引用”节点列出了不是分支或标记的其他引用，最明显的是“HEAD”和“FETCH_HEAD”符号引用（请参阅<a href="Reference.html#Git_References">Git引用</a> ）。
		</p>
		<p>“工作目录”节点显示本地文件系统上工作目录的位置和结构（仅在开发或非裸存储库的情况下，对于裸存储库，此节点始终是叶子）。</p>
		<p>最后，“Remotes”节点允许浏览和操作用于Fetch和Push的远程配置。</p>
		<h3 id="Functions_of_the_Git_Repositories_View">Git存储库视图的功能</h3>
		<h4 id="Project_Import">项目导入</h4>
		<p>为了使用Git存储库的内容，必须以项目的形式将其文件和文件夹导入Eclipse工作区。虽然Git Clone向导允许在克隆后直接进行此类导入，但Git Repositories View允许独立于克隆操作触发项目导入。</p>
		<p>“导入项目...”上下文菜单位于“存储库”节点以及“工作目录”节点和“工作目录”节点本身的任何“文件夹”节点上：</p>
		<p>
			<img border="0" src="images/Egit-0.11-ImportProjectsFromRepoView.png">
		</p>
		<p>在几个节点上提供<b>Import Projects ...</b>操作的基本原理是，用于导入项目的一些向导可以考虑文件系统目录，例如<b>Import Existing Projects</b>向导。如果从“存储库”或“工作目录”节点启动导入，则存储库的工作目录将设置为上下文，否则将与当前选定的“文件夹”节点对应的目录。
		</p>
		<p>“ <a href="#Use_the_New_Projects_Wizard">使用新项目向导”</a>中讨论了项目导入的详细信息。
		</p>
		<h4 id="Branch_and_Tag_Support">分支和标记支持</h4>
		<p>“Branches”节点允许创建，浏览，签出和删除本地和远程分支。“标签”节点允许浏览和签出标签。“分支”节点和“标签”节点都允许将分支或标签合并到当前检出的分支中，并且还与当前检出的分支同步。</p>
		<p>为了更好的可读性，分支分别在本地和远程分支的两个子节点中组织，只显示缩短的名称，例如，不是<tt>“refs / heads / master”，</tt>你会在“Local <tt>”</tt>下找到一个条目<tt>“master”</tt>分支“节点，而不是<tt>”refs / remotes / origin / master“</tt>缩短的名称<tt>”origin / master“</tt>显示在”Remote Branches“节点下。同样，通过省略<tt>“refs / tags /”</tt>前缀缩短标签名称：</p>
		<p>
			<img border="0" src="images/RepoMgrBranchesAndTags.png">
		</p>
		<h5 id="Check-out_of_Branches_and_Tags">退房分行和标签</h5>
		<p>可以通过双击相应节点或选择相应的上下文菜单条目来检出分支和标签。</p>
		<h5 id="Creation_and_Deletion_of_Branches">创建和删除分支</h5>
		<p>可以使用“ <a href="#Branch_Creation_Dialog">分支创建”对话框</a>创建本地分支。通过右键单击任何“Branch”和“Tag”节点上的“Branches”，“Local Branches”打开向导。
		</p>
		<p>使用相应的上下文菜单条目完成分支删除。</p>
		<h5 id="Rebasing_2">垫底</h5>
		<p>通过右键单击任何（本地或远程跟踪）分支节点上的<b>Rebase</b> ，可以触发将当前已检出的分支重新定位到另一个分支。
		</p>
		<h5 id="Merging_a_Branch_or_a_Tag">合并分支或标记</h5>
		<p>如果已签出本地分支，则可以从任何分支和标记节点以及存储库节点触发合并。有关<a href="#Merging">合并</a>功能的更多详细信息，请参阅<a href="#Merging">合并</a> 。
		</p>
		<ul>
			<li>当您选择除当前签出的分支或任何标记节点之外的任何分支节点时，使用“ <b>合并”</b>直接触发合并到当前签出的分支。
			</li>
		</ul>
		<ul>
			<li>选择存储库节点或当前已检出的分支时，请使用“ <b>合并...”</b>打开合并对话框。合并对话框在<a href="#Merging_a_branch_or_a_tag_into_the_current_branch">将分支或标记合并到当前分支中进行了描述</a> 。
			</li>
		</ul>
		<h5 id="Synchronizing_with_a_Branch_or_a_Tag">与分支或标记同步</h5>
		<p>您可以将HEAD中的更改与任何其他分支或标记中所做的更改进行比较。右键单击并在任何分支或标记上选择“ <b>同步...</b> ”。然后打开eclipse同步视图，其中包含HEAD中包含的更改的表示，但不包含其他分支或标记（传出更改）或反之（传入更改）。有关更多详细信息，请参阅同步功能的文档。
		</p>
		<h5 id="Determining_the_Checked-out_Branch">确定已签出的分支机构</h5>
		<p>有两种方法可以确定当前检出的分支或标记：已检出的分支/标记节点用一个小的复选标记进行修饰，“符号引用”节点下的“HEAD”条目显示了（完整）的名称。签出分支：</p>
		<p>
			<img border="0" src="images/RepoMgrCheckedOutBranch.png">
		</p>
		<h5 id="Resetting_to_a_Branch_or_a_Tag">重置为分支或标记</h5>
		<p>右键单击并在任何分支或标记上选择“ <b>重置...</b> ”。这将打开一个对话框，让您决定重置类型。有关更多详细信息，请参阅<a href="#Resetting_your_current_HEAD">重置当前HEAD</a> 。
		</p>
		<h5 id=".22Detached.22_HEAD">“独立”头</h5>
		<p>如果HEAD是“分离的”，即未指向本地分支的尖端而是指向提交或标记，则树中不会出现任何或多个“签出”标记，因为任何数量的远程分支或标记都可能指向当前签出的提交。您的HEAD分离时所处的状态不会被任何分支记录（这很自然 - 您不在任何分支上）。</p>
		<h4 id="Inspecting_References">检查参考文献</h4>
		<p>References节点显示除分支和标签之外的一些引用（列表是动态的，取决于存储库的当前状态）：</p>
		<p>
			<img border="0" src="images/Egit-0.11-RepoViewReferencesNode.png">
		</p>
		<p>如果Reference是符号，即指向另一个Reference，则显示目标引用的名称，后跟引用目标的对象ID。如果引用不是符号，则仅显示对象ID。</p>
		<p>在上面的示例中，HEAD是指向分支“refs / heads / master”的符号引用（即分支“master”被检出“，而FETCH_HEAD直接指向commit 226a7f ....</p>
		<p>右键单击“参考： <b>结帐”</b> （除非“参考”已经签出）和“ <b>创建分支</b> <b>...”，可以执行以下操作</b> 。
		</p>
		<h4 id="Browsing_the_Working_Directory">浏览工作目录</h4>
		<p>“工作目录”节点可视化Git存储库的本地文件系统结构。也可以在文件上打开文本编辑器：</p>
		<p>
			<img border="0" src="images/RepoMgrOpenTextEditor.png">
		</p>
		<p>或者，可以通过将文件从工作目录拖动到编辑器区域来打开文件。</p>
		<p>此外，在所有文件和文件夹节点以及“存储库”节点上，都提供了一个选项，用于将（特定于文件系统的）路径复制到剪贴板。当需要路径时，这有时很有用，例如使用文件浏览器打开目录或在视图实例之间复制和粘贴存储库（请参阅上面有关如何将存储库添加到视图中的信息）。使用“ <b>编辑”&gt;“复制”</b> （或相应的键盘快捷键）也可以使用“ <b>复制到剪贴板”</b>操作。
		</p>
		<h4 id="Repository_Configuration">存储库配置</h4>
		<p>与Eclipse中的通用“属性”视图集成允许查看和编辑Git配置（全局和特定于存储库的配置）。如果“属性”视图已打开，则在选择“存储库”节点时会自动更新。使用下拉框（屏幕截图中的左侧红框），您可以在存储库配置的显示，全局配置和聚合两者的视图之间切换。如果视图显示“存储库配置”或“全局配置”，则可以使用“ <b>编辑”</b>按钮（屏幕截图中的右侧红框）打开编辑器对话框。编辑器对话框与首选项页面<b>Team&gt; Git&gt; Configuration</b>具有相同的功能。
		</p>
		<p>在Git Repositories视图中，上下文菜单中有一个<b>Properties</b>操作，它将打开一个允许编辑Repository Configuration的配置对话框。这里，可以添加，更改或删除键值对。“ <b>打开”</b>按钮允许在文本编辑器中打开“存储库配置”文件。
		</p>
		<h4 id="Remote_Repositories">远程存储库</h4>
		<p>“遥控器”节点允许浏览和编辑远程配置。每个远程配置都有一个名称以及推送规范，获取规范或两者。如果选择“远程配置”节点或其任何子节点，则“ <b>属性”</b>视图将显示“远程配置”的摘要。在此示例中：有一个名为“origin”的远程配置，它只有一个获取规范，但没有推送规范：</p>
		<p>
			<img border="0" src="images/RepoMgrRemoteConfig.png">
		</p>
		<p>提供菜单操作以添加，配置和删除远程配置以及获取和推送规范。</p>
		<h5 id="Direct_Fetch_and_Push_Support">直接提取和推送支持</h5>
		<p>可以在远程节点以及相应的“Fetch”和“Push”节点上直接执行fetch和push（即没有向导）：</p>
		<p>
			<img border="0" src="images/RepoMgrSimpleFetch.png">
		</p>
		<p>请注意，fetch或push操作将立即在异步作业中执行;完成后，您将看到一个显示获取结果的确认弹出窗口。</p>
		<p>“Fetch”节点包含所谓的提取规范，“Push”节点包含所谓的推送规范。</p>
		<p>克隆存储库时会创建默认的提取规范。您可以使用菜单项<b>Configure Fetch ...</b>编辑获取规范。这会打开一个向导。在第一页上，您可以编辑Fetch URI。在第二页，您可以确定获取参考规范，请参阅<a href="#Fetch_Ref_Specifications">获取参考规范</a> 。
		</p>
		<p>您可以使用菜单条目<b>Configure Push ...</b>创建或编辑推送规范。这会打开一个向导。在第一页上，您可以编辑推送URI。如果指定了fetch，则提取URI将自动包含在推送规范中，并且不需要额外的Push URI。在第二页上，您可以确定推送参考规格，请参阅<a href="#Push_Ref_Specifications">推送参考规格</a> 。
		</p>
		<h5 id="Adding_a_Remote_Configuration">添加远程配置</h5>
		<p>这是使用“Remotes”节点上的上下文菜单操作完成的。启动向导，询问新配置的名称以及是否配置Fetch，Push或两者：</p>
		<p>
			<img border="0" src="images/RepoMgrNewRemote.png">
		</p>
		<p>如果选中了<b>Configure Fetch</b>复选框，则下一个向导页面将要求获取要从中获取的存储库的URI：</p>
		<p>
			<img border="0" src="images/Egit-0.9-repo-view-createRemoteWizardFetch.png">
		</p>
		<p>单击“ <b>更改...”</b>以打开一个允许您选择URI的对话框。下一步是为获取URI定义远程规范。有关详细信息，请参阅<a href="#Fetch_Ref_Specifications">获取参考规范</a> 。
		</p>
		<p>如果选中了“ <b>配置推送”</b>复选框，则下一个向导页面将询问要推送到的存储库的URI。这实际上是一个列表，因为您可以一次推送到多个存储库。单击<b>添加....</b>使用与上面相同的对话框将URI添加到列表中。您可以通过在列表中标记URI并点击“ <b>删除”</b>来删除URI。如果已经定义了提取URI，则此步骤是完全可选的。在这种情况下，提取URI也将用于推送。如果在此步骤中定义了至少一个推送URI，则它将覆盖提取URI。在此示例中，已存在提取URI，因此即使列表中没有Push URI，也会启用“ <b>下一步”</b>按钮：</p>
		<p>
			<img border="0" src="images/Egit-0.9-repo-view-createRemoteWizardPush.png">
		</p>
		<p>下一步是为推送URI定义远程规范。有关详细信息，请参阅<a href="#Push_Ref_Specifications">推送参考规范</a>
		</p>
		<p>完成后，将显示新的远程配置：</p>
		<p>
			<img border="0" src="images/RepoMgrRemoteCreated.png">
		</p>
		<h5 id="Changing_Remote_Configurations">更改远程配置</h5>
		<p>还可以使用上下文菜单添加，删除或更改现有远程配置的获取/推送规范。</p>
		<h5 id="Gerrit_Configuration">Gerrit配置</h5>
		<p>如果您使用<a href="https://www.gerritcodereview.com/" target="egit_external">Gerrit Code Review</a>作为远程存储库服务器，则可以</p>
		<ul>
			<li>指定用于将更改推送到代码审查的推送配置</li>
			<li>指定获取配置以从Gerrit获取审阅注释</li>
			<li>默认情况下，配置存储库以在“提交”对话框中选择“ <b>计算更改 - 用于Gerrit代码检查的ID”</b>选项</li>
		</ul>
		<p>从Remote的上下文菜单中选择<b>Gerrit Configuration ....</b>这将打开一个包含一个页面的向导：</p>
		<p>
			<img border="0" src="images/Egit-2.1-clone-wizard-gerrit-page.png">
		</p>
		<ul>
			<li>单击“ <b>完成”后</b> ，向导<b>会将</b>存储库配置参数<b>gerrit.createchangeid设置</b>为<i>true</i> 。这样可以确保默认情况下选中“提交”对话框中的<b>Gerrit Code Review</b>复选框<b>Compute Change-Id</b> 。请参阅<a href="http://wiki.eclipse.org/EGit/User_Guide#Commit_Message" target="egit_external">提交消息</a>了解详细信
			</li>
		</ul>
		<ul>
			<li>如果要在以后配置自动Change-Id插入，可以使用存储库配置编辑器（ <b>Preferences&gt; Team&gt; Git&gt; Configuration</b> ）将配置参数<b>gerrit.createchangeid</b>设置为true。如果您希望对所有存储库进行此配置，则可以将其放入〜/ .gitconfig中，然后您不需要为您正在处理的每个新存储库重复此配置。
			</li>
		</ul>
		<ul>
			<li>此外，向导会在您的提取规范中添加refspec“refs / notes / *：refs / notes / *”。Gerrit在git notes中存储有关审阅的数据。使用此refspec，当您从此远程获取时，将自动获取这些审阅数据，它们将显示在提交查看器中。</li>
		</ul>
		<ul>
			<li>在<b>Push URI</b>部分中，您可以配置用于默认推送配置的URI。它是根据您克隆的URI预先填充的。如果使用git协议进行克隆，协议将自动更改为ssh，并自动添加默认的Gerrit ssh端口29418。对于需要用户的协议，为方便起见，存在用户字段。
			</li>
		</ul>
		<ul>
			<li><b>Push Configuration</b>部分有一个字段<b>Destination Branch</b> 。在这里，您应该输入目标分支的名称，其中将提交Gerrit代码审查工作流程中接受的更改。这会在克隆向导中指定的远程的推送配置中生成条目<tt>HEAD：refs / for / &lt;branchname&gt;</tt> 。
			</li>
		</ul>
		<ul>
			<li>已为Gerrit配置的存储库与绿色Gerrit装饰器一起显示</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-3.1-RepositoryGerritDeco.png">
		</p>
		<h3 id="Refresh">刷新</h3>
		<p>视图会定期自动刷新。工具栏中的“ <b>刷新”</b>按钮允许触发立即刷新：</p>
		<p>
			<img border="0" src="images/RepoMgrRefresh.png">
		</p>
		<h3 id="Link_with_Selection">与选择链接</h3>
		<p>如果启用了<b>带选择</b>切换的<b>链接，</b>则将自动显示与当前工作台选择对应的文件或文件夹：</p>
		<p>
			<img border="0" src="images/RepoMgrLinkWithSelection.png">
		</p>
		<h3 id="Link_with_Editor">与编辑链接</h3>
		<p>如果启用了<b>带编辑器</b>切换的<b>链接，</b>则将自动显示与当前活动编辑器对应的文件或文件夹：</p>
		<p>
			<img border="0" src="images/RepoMgrLinkWithEditor.png">
		</p>
		<h3 id="Hierarchical_Branch_Layout">分层分支布局</h3>
		<p>如果启用了“ <b>分层分支布局”</b>切换，则分支将以分层布局显示，使用斜杠（/）作为层次分隔符：</p>
		<p>
			<img border="0" src="images/RepoMgrHierarchicalBranchLayout.png">
		</p>
		<p>这对于组织大量分支很有帮助。</p>
		<h3 id="Bare_Repositories">光秃秃的存储库</h3>
		<p>“Bare”Git存储库（与“开发”或“标准”存储库相对）根据定义没有工作目录，因此与工作目录（签出，项目导入，浏览工作目录）相关的所有操作都不可用于这样的存储库。存储库的“Bare-ness”在“工作目录”节点上可视化，该节点始终是一个叶子：</p>
		<p>
			<img border="0" src="images/RepoMgrBareRepository.png">
		</p>
		<p>只有通过推送更改才能更改裸存储库。</p>
		<h3 id="Removing_Repositories_from_the_Git_Repositories_View">从Git存储库视图中删除存储库</h3>
		<p>这是作为“存储库”节点上的菜单操作提供的。请注意，这不会删除存储库，只是从视图中删除节点。如果工作空间中有项目位于存储库的工作目录中，系统将提示用户确认从Eclipse工作空间中删除这些项目。</p>
		<h3 id="Showing_Repository_in_Related_Views">在相关视图中显示存储库</h3>
		<h4 id="Show_in_History">在历史中显示</h4>
		<p>命令<b>显示在&gt;历史记录</b>中将打开<a href="Reference.html#History_View">历史视图，</a>显示所选存储库中的所有更改。
		</p>
		<h4 id="Show_in_Reflog">在Reflog中显示</h4>
		<p><b>Show in&gt; Reflog中</b>的命令将打开<a href="Reference.html#Git_Reflog_View">Git Reflog视图，</a>显示所选存储库的Git reflog。
		</p>
		<h4 id="Show_in_Properties">在属性中显示</h4>
		<p>命令<b>Show in&gt; Properties</b>将打开<a href="#Repository_Configuration">Properties视图，</a>显示所选存储库的属性。
		</p>
		<p>
			<br>
		</p>
		<h2 id="Working_with_Tasks">使用任务</h2>
		<p>自EGit 0.11起，与Mylyn的第一次集成可用于支持使用任务存储库。</p>
		<h3 id="Installation">安装</h3>
		<p>您需要安装“EGit Mylyn”功能才能使用EGit Mylyn集成。这也需要安装Mylyn。</p>
		<h3 id="Commit_Message_Template">提交消息模板</h3>
		<ul>
			<li>在<b>Preferences&gt; Tasks&gt; Team</b>下配置Mylyn提交消息模板，然后编辑<b>Commit Comment Template</b> 。
			</li>
			<li>使用以下变量以及任何文本来更改提交消息。
				<ul>
					<li>connector.task.prefix，repository.kind，repository.url，task.assignee，task.cc，task.description，task.id，task.key，task.keywords，task.lastmodified，task.notes，task.priority， task.product，task.reporter，task.resolution，task.status，task.summary，task.type，task.url，task.completiondate，task.creationdate，task.reminderdate</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-configure-commit-template.png">
		</p>
		<ul>
			<li>在提交更改之前，使用Mylyn UI激活相应的任务。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-activate-task.png">
		</p>
		<ul>
			<li>启动提交对话框时，EGit将使用提交消息模板预先填充提交消息。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-commit-using-template.png">
		</p>
		<p>有关如何使用任务的更多信息，请参阅<a href="http://wiki.eclipse.org/index.php/Mylyn/User_Guide" target="egit_external">Mylyn用户指南</a> 。
		</p>
		<h2 id="Viewing_Commits">查看提交</h2>
		<p>Egit commit viewer允许在Eclipse编辑器区域中打开提交。</p>
		<p>EGit commit viewer显示以下提交信息：</p>
		<ul>
			<li>提交标签<ul>
					<li>打开父提交的链接</li>
					<li>作者</li>
					<li>修订者</li>
					<li>信息</li>
					<li>指向此提交的标签列表</li>
					<li>提交存在的分支列表</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Commit-editor-commit-page-egit-4.6.png">
		</p>
		<ul>
			<li>差异标签<ul>
					<li>只读文本编辑器，带有文件差异的输出，内容大纲链接到编辑器。</li>
					<li>可以从<b>首选项</b> &gt; <b>常规</b> &gt; <b>外观</b> &gt; <b>颜色和字体</b> &gt; <i>Git</i>文件夹配置查看器中用于突出显示行的<b>颜色</b> 。
					</li>
					<li>编辑器文本查看器右侧的概述标尺显示所有添加或删除的行的彩色注释。</li>
					<li>通过单击概览标尺中的注释，或通过全局Eclipse工具栏中的“转到下一个注释”/“转到上一个注释”操作，可以在“黑客”（添加或删除的线条更改）之间快速导航（默认情况下）键盘快捷键是“Crtl / Cmd-。”和“Shift-Ctrl / Cmd-。”）。</li>
					<li>块头中的行号以及文件diff头中的文件名是用于在编辑器中打开旧版本或新版本或当前工作树版本的超链接，或者显示旧版本和旧版本之间的双向差异。新版本。后者也可以在文件diff标题中的“diff”一词上出现（以“diff --git”开头）。这些链接仅在适用的情况下可用;例如，由于在这种情况下没有旧版本，因此没有链接为添加的文件打开旧版本。</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Commit-editor-diff-page-egit-4.6.png">
		</p>
		<ul>
			<li>备注选项卡<ul>
					<li>所有Git注意到提交</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Commit-editor-notes-page-egit-4.6.png">
		</p>
		<h3 id="Tagging_a_commit">标记提交</h3>
		<ul>
			<li>从提交查看器工具栏中选择“创建标记”图标<ul>
					<li>将打开“标记”对话框，允许您从提交中创建标记。</li>
				</ul>
			</li>
		</ul>
		<h3 id="Creating_a_branch_from_a_commit">从提交创建分支</h3>
		<ul>
			<li>从提交查看器工具栏中选择“创建分支”图标。
				<ul>
					<li>将打开“分支”对话框，允许您从提交中创建新分支</li>
				</ul>
			</li>
		</ul>
		<h3 id="Checking_out_a_commit">检查提交</h3>
		<p>这将检查提交查看器中显示的提交。提交将被签出， <a href="#.22Detached.22_HEAD">HEAD将被分离</a> 。
		</p>
		<h3 id="Cherry_picking_a_commit">樱桃采摘提交</h3>
		<p>将提交查看器中显示的提交引入的更改应用于当前检出的提交或分支之上。</p>
		<h3 id="Opening_the_commit_viewer">打开提交查看器</h3>
		<p>可以从以下位置打开提交查看器：</p>
		<ul>
			<li>历史视图表上下文菜单</li>
			<li>双击Pull / Fetch对话框结果表中的提交</li>
			<li>
				<a href="#Open_commit_dialog">打开提交对话框</a>
			</li>
			<li>
				<a href="#Finding_the_author_of_each_line_in_a_file">责备注释弹出窗口</a>
			</li>
			<li>
				<a href="#Reflog_View">Reflog视图</a>
			</li>
		</ul>
		<h2 id="Searching_for_commits">正在搜索提交</h2>
		<p>EGit支持搜索提交。</p>
		<h3 id="Git_Search_page">Git搜索页面</h3>
		<p>可以从标准Eclipse搜索对话框中的<b>Git搜索</b>选项卡搜索提交。
		</p>
		<p>此对话框支持搜索Git提交的不同字段中存在的文本或模式，例如消息，作者行，提交者行，提交的SHA-1 ID，其父级以及与之关联的树。 。</p>
		<p>
			<img border="0" src="images/Git-search-page.png">
		</p>
		<h3 id="Browsing_Search_Results">浏览搜索结果</h3>
		<p>提交搜索结果显示在标准Eclipse搜索视图中。在树模式下，结果按存储库分组。双击“搜索”视图中的<a href="#Viewing_Commits">提交</a>将在<a href="#Viewing_Commits">提交查看器</a>中将其打开。
		</p>
		<p>
			<img border="0" src="images/Git-search-results.png">
		</p>
		<h3 id="Launching_Git_Search">启动Git搜索</h3>
		<p>可以通过从Eclipse工具栏上的“搜索”下拉列表中选择Git搜索选项来打开Git搜索页面。</p>
		<p>
			<img border="0" src="images/Git-search-dropdown.png">
		</p>
		<h3 id="Open_commit_dialog">打开提交对话框</h3>
		<p>EGit有一个类似于Mylyn <b>Open Task</b>和核心“ <i>Open Resource</i> ”对话框的<b>Open Git Commit</b>对话框。该对话框在每个已配置的Git存储库中搜索输入到过滤器框中的分支，标记或提交SHA-1，并显示匹配的提交。
		</p>
		<p>
			<img border="0" src="images/Git-open-commit.png">
		</p>
		<p>可以通过选择Eclipse导航工具栏上的<b>Open Git Commit</b>按钮<b>打开</b>该对话框。
		</p>
		<p>
			<img border="0" src="images/Git-open-commit-toolbar.png">
		</p>
		<h2 id="Finding_the_author_of_each_line_in_a_file">查找文件中每行的作者</h2>
		<p>EGit支持在编辑器标尺内显示<i>git blame</i>信息。
		</p>
		<p>选择<b>Team</b> &gt; <b>Show Revision Information</b>对文件选择的操作将打开编辑器并显示注释标尺，其中包含文件中每行的提交和作者信息。将鼠标悬停在标尺上将显示一个弹出窗口，显示提交ID，作者，提交者，提交消息以及此提交在所选块上应用的差异。
		</p>
		<p>可以从标尺上下文菜单中的<b>Revisions</b>子菜单配置blame注释编辑器标尺的外观。
		</p>
		<p>
			<img border="0" src="images/Egit-3.2-BlameImprovements.png">
		</p>
		<p>单击“ <b>打开提交”</b>以在<a href="#Viewing_Commits">提交查看器中</a>打开提交，单击<b>“在历史记录</b>中显示”以在“历史记录视图”中显示提交。单击<b>show annotations</b>以显示悬停中显示的提交的父提交的注释。
		</p>
		<h2 id="Working_with_Submodules">使用子模块</h2>
		<p>您可以在这个<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="egit_external">Git社区书章节中</a>阅读更多关于Git子模块以及它们如何工作的内容。
		</p>
		<h3 id="Cloning_Repositories_with_Submodules">使用子模块克隆存储库</h3>
		<p>子模块是嵌套在父存储库中的存储库。因此，在进行父存储库的克隆时，必须克隆子模块存储库，以便文件/文件夹在父存储库的工作目录中可用。</p>
		<p>检查从<b>Git</b>的<b>克隆</b>精灵<i>克隆子模块</i>按钮将父库完成的克隆后，克隆所有子模块的存储库。
		</p>
		<p>
			<img border="0" src="images/Egit-13-clone-submodules-wizard.png">
		</p>
		<h3 id="Browsing_Submodules">浏览子模块</h3>
		<p>对于包含子模块的存储库， <b>Git存储库</b>视图中显示了一个<i>子模块</i>节点。
		</p>
		<p>给定父存储库中的所有子模块都显示在此节点下，以及有关当前检出的提交的信息。</p>
		<p>
			<img border="0" src="images/Egit-13-submodules-node.png">
		</p>
		<h3 id="Adding_a_Submodule">添加子模块</h3>
		<p>您可以通过在<b>Git Repositories</b>视图中选择<b>存储库</b>并选择<i>Add Submodule</i>上下文菜单选项，将新的子模块添加到存储库。
		</p>
		<p>向导将提示输入要添加的子模块的路径和URL。输入的路径将相对于父存储库的工作目录，URL将用于在本地克隆存储库。</p>
		<p>完成向导后，子模块将被克隆，添加到索引中，子模块将在<i>.gitmodules</i>文件以及父存储库的<i>.git / config</i>文件中注册。
		</p>
		<h3 id="Updating_Submodules">更新子模块</h3>
		<p>有两个操作可用于更新子模块， <i>更新子模块</i>和<i>同步子模块</i> 。
		</p>
		<p>选择<i>子模块</i>上的<i>Update Submodule</i>操作将检查父存储库中该子模块的索引中引用的提交。如果已在父存储库的<i>.git / config</i>文件中的所选子模块的配置部分的<i>更新</i>字段中配置了该命令，则此命令还将执行合并或rebase。
		</p>
		<p>在<i>子模块</i>上选择<i>Sync Submodule</i>操作将从父存储库工作目录的根目录中的<i>.gitmodules</i>文件中的当前值更新子模块使用的远程URL。
		</p>
		<h2 id="Team_Project_Sets">团队项目集</h2>
		<p>Git团队提供商支持团队项目集（ <tt>.psf</tt>文件）。</p>
		<h3 id="Import">进口</h3>
		<p>要导入现有项目集，请使用“ <i>导入...”</i>向导，然后从“ <i>团队”中</i>选择“ <i>团队项目集”</i> 。
		</p>
		<p>然后，您可以选择包含导入定义的文件，并可选择将导入的项目添加到工作集。</p>
		<p>在下一步中，将克隆存储库，导入和连接项目。这可能需要一段时间，具体取决于存储库的大小。</p>
		<h3 id="Export">出口</h3>
		<p>要为现有Git项目创建项目集文件，请选择已连接到Git团队提供程序的项目/工作集。</p>
		<p>然后打开<i>Export ...</i>向导并从<i>Team中</i>选择<i>Team Project Set</i> 。在那里，您可以选择仅导出工作集或项目，并可以优化您的选择。在下一步中，选择输出路径并完成向导。
		</p>
		<h3 id="Format">格式</h3>
		<p>您也可以手动编辑<tt>.psf</tt>文件。每个项目都有一个如下所示的条目：</p>
		<pre>&lt;project reference =“1.0，git：//egit.eclipse.org/egit.git,master,org.eclipse.egit”/&gt;</pre>
		<p>值以逗号分隔，具有以下含义：</p>
		<ol>
			<li>格式化版本</li>
			<li>Git存储库URL</li>
			<li>最初签出的分行名称</li>
			<li>要导入的项目的路径（包含<tt>.project的</tt>文件夹），相对于存储库</li>
		</ol>
		<p>每个项目都有一个条目。因此，对于同一存储库中的多个项目，请为具有相同存储库URL的每个项目创建此类条目。导入足够智能，只能克隆每个存储库一次。</p>
		<p>如果存储库在根目录中包含项目，请使用<tt>。</tt>作为项目路径。</p>
		<h2 id="GIT_LFS_Support">GIT LFS支持</h2>
		<p>当安装了可选的JGit LFS支持包“Git的Java实现 - 可选的LFS支持”时，EGIT中包含对GIT LFS的部分支持。当使用具有强大LFS远程的SSH协议（即GitHub或带有LFS插件的Gerrit）时，此支持最有效。</p>
		<p>要启用EGit的LFS支持，请通过按“全局启用LFS支持”按钮全局启用它（对于当前用户）：</p>
		<p>
			<img border="0" src="images/EGit-5.0_LFS_enable_globally.png">
		</p>
		<p>...或者配置Eclipse以自动确保Eclipse启动时启用LFS支持。选中“自动配置LFS ...”复选框：</p>
		<p>
			<img border="0" src="images/EGit-5.0_LFS_enable_automatically.png">
		</p>
		<p>...或 - 仅为单个存储库启用内置LFS支持 - 右键单击存储库并选择“在本地启用LFS”</p>
		<p>
			<img border="0" src="images/EGit-5.0_LFS_enable_locally.png">
		</p>
		<p>请注意，如果尚未安装JGit LFS支持，则会禁用某些操作。如果已在更全局范围内启用LFS支持，则不会显示“在本地启用LFS”操作。</p>
		<p>一旦直接或间接为存储库启用LFS支持，您就可以像往常一样处理文件，更具体地说，这些用例应该起作用：</p>
		<ol>
			<li>从LFS服务器获取LFS对象（请注意，尚未实现HTTP身份验证，因此SSH效果最佳，因为这提供了一种进行身份验证的机制）。</li>
			<li>将LFS对象推送到LFS服务器（适用于HTTP身份验证的相同说明）。</li>
			<li>暂存和提交由LFS管理的文件（通过.gitattributes）。</li>
			<li>签出LFS管理的文件</li>
			<li>从GIT历史记录中查看LFS托管文件的内容</li>
			<li>比较历史记录中LFS托管文件的实际文件内容</li>
		</ol><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="以前" border="0" src="../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="User-Guide.html" title="EGit用户指南">
						<img alt="EGit用户指南" border="0" src="../../images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Reference.html" title="参考">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">概念</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">参考</td>
			</tr>
		</table>
	</body>
</html>