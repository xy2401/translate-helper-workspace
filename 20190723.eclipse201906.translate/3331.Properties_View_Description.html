<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Properties_View_Description</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingPropertiesViews">指定属性视图</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingPropertiesViews">指定属性视图</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#properties_view_description">属性视图说明</a>
						<ol style="list-style:disc">
							<li>
								<a href="#common_attributes">共同属性</a>
							</li>
							<li>
								<a href="#additional_services">额外服务</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#categories">分类</a>
					</li>
					<li>
						<a href="#pages">网页</a>
						<ol style="list-style:disc">
							<li>
								<a href="#page-toolbar-action">工具栏操作</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#groups">组</a>
						<ol style="list-style:disc">
							<li>
								<a href="#group-toolbar-action">工具栏操作</a>
							</li>
							<li>
								<a href="#widgets-from-domain-class">来自Domain Class的小部件</a>
							</li>
							<li>
								<a href="#group_styles">团体风格</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#widgets">小工具</a>
						<ol style="list-style:disc">
							<li>
								<a href="#text">文字/文字区域</a>
							</li>
							<li>
								<a href="#button">按键</a>
							</li>
							<li>
								<a href="#label">标签</a>
							</li>
							<li>
								<a href="#checkbox">复选框</a>
							</li>
							<li>
								<a href="#select">选择</a>
							</li>
							<li>
								<a href="#radio_group">广播组</a>
							</li>
							<li>
								<a href="#hyperlink">超链接</a>
							</li>
							<li>
								<a href="#reference">参考</a>
							</li>
							<li>
								<a href="#list">名单</a>
							</li>
							<li>
								<a href="#basic_custom_widgets">基本自定义小部件</a>
							</li>
							<li>
								<a href="#advanced_custom_widgets">高级自定义小部件</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#dynamic_mappings">动态映射</a>
					</li>
					<li>
						<a href="#containers_and_layout">容器和布局</a>
					</li>
					<li>
						<a href="#styling">造型</a>
						<ol style="list-style:disc">
							<li>
								<a href="#widgets_styles">小部件样式</a>
							</li>
							<li>
								<a href="#colors">颜色</a>
							</li>
							<li>
								<a href="#conditional_styles">条件样式</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#validation_rules">验证规则</a>
						<ol style="list-style:disc">
							<li>
								<a href="#page_semantic_validation_rule">页面语义验证规则</a>
							</li>
							<li>
								<a href="#group_semantic_validation_rule">组语义验证规则</a>
							</li>
							<li>
								<a href="#group_property_validation_rule">组属性验证规则</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#extensibility_features">可扩展性功能</a>
						<ol style="list-style:disc">
							<li>
								<a href="#extends">扩展</a>
							</li>
							<li>
								<a href="#overrides">覆盖</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#extension_points">扩展点</a>
						<ol style="list-style:disc">
							<li>
								<a href="#advanced_custom_widgets_extension_points">高级自定义窗口小部件的扩展点</a>
							</li>
							<li>
								<a href="#tab_filtering">标签过滤</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>从版本4.0开始，Sirius支持使用许多功能（如复杂样式，验证，上下文等）定义属性视图。</p>
		<p>属性视图在VSM中以与其他Sirius表示类似的方式定义。VSM中的配置元素标识它们应用于的语义模型中的元素的子集，并与它们关联，这些小部件将在Eclipse <em>Properties View中</em>可见，以查看和编辑元素的属性。
		</p>
		<p>该配置<em>将</em>语义元素<em>映射</em>到一些属性视图元素。在运行时，每个活动属性元素（页面，组，窗口小部件）将在属性视图中生成零个或多个元素，具体取决于当前与属性元素的定义匹配的语义元素的数量。每当当前选择更改时，Sirius将根据活动窗口小部件自动重新计算应在属性视图中显示哪些元素，并在属性视图中创建或删除必要的元素。
		</p>
		<p>只要所选元素是打开的会话的一部分，即在Sirius编辑器内选择的任何元素或在打开的会话中从<em>Model Explorer</em>视图中选择，就会启用Sirius属性视图。
		</p>
		<p>请注意，如果您对Sirius定义的属性视图（可选）支持已正确安装但未在VSM中指定任何内容，则Sirius将应用默认通用规则为模型元素提供规范属性视图。只要您指定自己的配置（如本文档中所述），默认规则将被忽略，而有利于您的配置。请参阅<a href="#default_rules">下文</a> ，了解两种方法的组合方式。
		</p>
		<p>由于有三个特定的菜单项，您可以在设计的根元素下创建<em>属性视图</em>描述。
		</p>
		<p>
			<img border="0" src="images/new-properties.png">
		</p>
		<ul>
			<li>第一个菜单用于创建空白的<em>属性视图</em>描述。使用此菜单，您将从头开始创建<em>属性视图</em>定义。
			</li>
			<li>第二个菜单可以直接在odesign内复制默认规则。虽然功能强大，但这些默认规则对于新用户来说可能非常复杂。</li>
			<li>第三个菜单可以创建一个新的<em>属性视图</em> ，它将扩展默认规则。使用此机制，您可以利用所有默认规则，并且您可以轻松添加新规则。
			</li>
		</ul>
		<h2 id="properties_view_description">属性视图说明</h2>
		<p>通过创建<em>Properties View Description</em>元素（直接位于VSM的顶级<a href="../general/Specifying_Viewpoints.html#vsm_organization"><em>Group</em></a>元素下）及其子元素（描述窗口小部件，操作，布局等）来配置<em>Properties视图</em> 。
		</p>
		<p>与<a href="../../Glossary.html#VSM"><em>VSM中的</em></a>许多元素一样， <em>视图扩展描述</em>具有可选的<em>标识符</em> ，该<em>标识符</em>应该是唯一的。
		</p>
		<p>在<em>Properties View Description</em>元素中，您可以创建：</p>
		<ul>
			<li>
				<a href="#categories"><em>类别</em></a> ，仅为了方便指定其规范而存在;</li>
		</ul>
		<p>在<em>Category</em>元素中，您可以创建：</p>
		<ul>
			<li>
				<a href="#pages"><em>页面</em></a> ，对应“标签”;</li>
			<li>
				<a href="#groups"><em>组</em></a> ，表示页面/选项卡中包含实际小部件的命名部分;</li>
			<li>
				<a href="#overrides"><em>覆盖</em></a> ，允许覆盖现有属性视图描述的一部分。
			</li>
		</ul>
		<p>建议将<em>属性视图描述</em>与它将表示的语义元素的元模型显式关联。您可以在“ <em>属性视图描述”</em>的“ <em>元模型”</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p>所有不同类型的属性视图元素的描述共享相同的共同原则：</p>
		<ul>
			<li>使用配置属性的组合（参见下文）选择语义模型的一些元素。这些元素称为<em>目标</em> ，每个元素都有一个这种类型的小部件来表示它。
			</li>
			<li>属性视图的图形方面由<em>样式</em>定义。Sirius提供了丰富的可能样式，本文档稍后将对其进行描述。
			</li>
			<li>（可选）可以定义属性视图元素的行为，具体取决于窗口小部件类型（文本字段的版本，超链接或按钮的单击操作...）。</li>
		</ul>
		<p id="context">
			<strong>语境。</strong> 每个属性视图元素都在VSM的<em>上下文</em>中定义。在运行时，相应的<em>上下文元素</em>将是与属性视图元素描述相关联的语义元素。此上下文元素用作起点，以确定应在属性视图上创建属性视图元素描述的哪些实例：</p>
		<ol>
			<li>首先，从上下文元素开始评估描述的<em>语义候选表达式</em> 。它应该在语义模型中返回一组（可能是空的）元素。
			</li>
			<li>然后使用描述中指定的<em>域类</em>过滤此候选列表：仅保留作为指定类的实例的候选。
			</li>
			<li>最后，对剩余候选者中的每一个评估元素的可选<em>前提条件表达式</em> 。它应该返回一个布尔值。仅保留谓词返回true值的候选项，并且实际上将在属性视图上生成一个元素。
			</li>
		</ol>
		<p>指定属性视图时，应记住此评估顺序。特别是，为了避免性能问题，您应该：</p>
		<ul>
			<li>使用<em>语义候选表达式</em>限制模型元素的数量。
			</li>
			<li>避免在<em>语义候选表达式中</em>测试实例类型（在过滤<em>域类</em>时，无论如何都会这样做）。
			</li>
			<li>使用<em>域类中</em>最具体的类型。
			</li>
			<li>避免在<em>Precondition Expression中进行</em>导航和长时间计算。
			</li>
		</ul>
		<p>
			<strong>属性视图元素定义。</strong> 属性视图支持几种不同类型的元素，这些元素将在以下各节中介绍。他们是：</p>
		<ul>
			<li>
				<a href="#pages">页面</a> ，表示属性视图可以包含节的<strong>选项卡</strong> 。
			</li>
			<li>
				<a href="#groups">基团</a> ，其表示属性视图<strong>部，</strong>其能够包含窗口小部件。
			</li>
			<li>
				<a href="#widgets">小部件</a>描述了支持的不同类型的小部件，如文本，按钮，标签，复选框，无线电组......
			</li>
			<li>
				<a href="#dynamic_mappings">动态映射</a>用于高级场景，其中要显示的窗口小部件集不能静态地知道，而是必须在运行时计算。
			</li>
			<li>
				<a href="#containers_and_layout">容器和布局</a>用于组织和布局多个相关的小部件。
			</li>
			<li>
				<a href="#overrides">覆盖</a>用于覆盖现有属性视图描述的属性视图。
			</li>
		</ul>
		<p id="default_rules">
			<strong>默认属性查看规则。</strong> 如果没有找到用户选择的元素的属性视图定义，则Sirius将应用默认规则，这些规则尝试为大多数用户模型提供可用（如果是通用）结果。只要你定义为您的建模<em>一些</em>自定义的规则， <em>只有</em>这些自定义的规则将适用，而默认的将被忽略。如果要为某些特定类型混合某些元素和自定义元素的默认规则，您可以：</p>
		<ul>
			<li>扩展VSM中的默认规则模型：从VSM模型的顶级元素中，选择“ <em>新建属性”&gt;“扩展默认属性视图”</em> 。这将允许您通过“扩展机制”#extensibility_features重新定义默认规则的行为。
			</li>
			<li>在VSM中导入默认规则模型的副本：从VSM模型的顶级元素中，选择“ <em>新建属性”&gt;“导入默认属性视图”</em> 。
			</li>
			<li>添加自定义规则（页面和组），并可选择更新默认规则以不应用为您提供更多特定视图的元素（通常通过修改默认<em>页面</em>的<em>前提条件表达式</em> ），以便从顶级元素执行此操作在VSM模型中，选择“ <em>新建属性”&gt;“新建默认属性视图”</em> 。
			</li>
		</ul>
		<p>
			<strong>遗产Sirius Tabs。</strong> 默认情况下，即使您已定义自定义属性视图，在普通属性网格中显示所选元素的原始属性的遗留<em>Semantic</em>和<em>Default</em>选项卡仍然可见（当选择来自Sirius表示时， <em>Semantic</em>选项卡可见;从<em>Model Explorer中</em>选择时显示<em>默认</em>选项卡）。如果要隐藏这些旧版标签并仅显示自定义标签，可以通过更改<em>Sirius&gt; Sirius属性视图</em>类别中的首选项来实现。
		</p>
		<h3 id="common_attributes">共同属性</h3>
		<p>以下属性主要由所有属性视图元素描述（页面，组，容器，窗口小部件）共享。</p>
		<p id="identifier">
			<strong>标识符。</strong> 每个属性视图元素描述都定义了一个可选属性<em>Identifier</em> 。它可用于在VSM编辑器中以及以编程方式访问/修改VSM模型的高级自定义方案中区分相同类型的元素。
		</p>
		<p id="domain_class">
			<strong>域类。</strong> 可选的<em>Domain Class</em>属性是由属性视图元素定义表示的语义元素的类型。域类名的语法可以是基本名称，如<code>Package</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml.Package</code> ，或完全限定的URI，如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Package</code> 。<br>空<em>Domain类</em>意味着所定义的元素将适用于任何类型的任何模型元素。默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新属性视图元素。
		</p>
		<p id="precondition_expression">
			<strong>前提表达。</strong> 您可以使用<em>Precondition Expression</em>来更改此设置。如果指定了这样的表达式，则将在用户选择的语义元素的<a href="#context">上下文</a>中对其进行求值，并且仅当表达式返回<code>true</code>将属性视图元素应用于该语义元素。
		</p>
		<p id="label_expression">
			<strong>标签表达。</strong> 此表达式用于计算描述元素的标签文本（通常显示在窗口小部件的左侧）。<em>Label表达式</em>在语义元素的上下文中计算，并应返回一个字符串。如果未指定表达式，则默认标签为空。
		</p>
		<p id="help_expression">
			<strong>帮助表达。</strong> 使用“ <em>帮助”表达式</em>指定属性视图元素的帮助文本，该<em>表达式</em>在语义元素的上下文中进行计算，并应返回字符串。它将显示为与窗口小部件关联的问号图标上的工具提示。
		</p>
		<p id="is_enabled_expression">
			<strong>启用表达式。</strong> 可以启用或禁用每个窗口小部件（使其可见但只读）。<em>Is Enabled Expression</em>在语义元素的上下文中进行计算，并应返回一个布尔值。它未指定表达式，默认为<em>true</em> （表示小部件已启用）。
		</p>
		<p id="semantic_candidate_expression">
			<strong>语义候选表达。</strong> <em>语义候选表达式</em>定义由属性视图元素表示的模型元素。
		</p>
		<p id="styles">
			<strong>样式。</strong> 每种属性视图元素都支持一组丰富的可能<a href="#styling">样式</a> 。
		</p>
		<p>要查找每个属性的一些文档，您还可以参考编辑器中每个属性的“问号”图标上可用的工具提示。</p>
		<p>以下是窗口小部件配置（本例中为单行<a href="#text">文本</a> ）的示例，其中说明了一些常见属性：</p>
		<p>
			<img border="0" src="images/basic-properties-example-vsm.png">
		</p>
		<p><em>文本元素名称（不可编辑）</em>元素具有完全相同的配置，但其<em>Label表达式</em>为<code>Name (read-only):</code>并且其<em>Is Enabled Expression</em>设置为<code>aql:false</code> 。
		</p>
		<p>以下是为图元素呈现的结果属性视图：</p>
		<p>
			<img border="0" src="images/basic-properties-example-diagram.png"> 
		</p>
		<p>我们在每个小部件的左侧看到两个标签表达式，帮助图标显示当用户将鼠标指针放在它们上时计算出的<em>帮助表达式</em> ，以及实际的小部件。由于<em>启用了表达式</em> ，第二个文本小部件被禁用（由于浅蓝色背景可见）。
		</p>
		<h3 id="additional_services">额外服务</h3>
		<p>除了<code>self</code> ，它表示在其上计算表达式的当前上下文元素，在<em>Property View Description中</em>定义的每个表达式都可以访问另一个名为<code>input</code>特殊变量，该变量提供了一些额外的服务。对于给定的用户选择， <code>input</code>的值在<em>属性视图描述中的</em>每个位置都是相同的;它对应于用户选择的内容的描述符，并且可以用于获取上下文信息。
		</p>
		<p>
			<strong><code>input</code>服务。
			</strong>
		</p>
		<ul>
			<li>
				<code>input.getOriginalSelection()</code> ：在任何解包或解释之前返回用户选择的原始raw元素。这可能不是一个模范元素;例如，对于Sirius图，这将是一个<code>EditPart</code> 。
			</li>
			<li>
				<code>input.getSemanticElement()</code> ：返回与选择关联的主要语义元素。这将对应于<em>Page</em>内的<code>self</code>变量，但是在一个组内部<code>self</code>可能具有不同的值，使用了<em>语义候选表达式</em> ，因此该服务可用于从任何地方获得“原始自我”。
			</li>
			<li>
				<code>input.getAllSemanticElements()</code> ：返回与选择关联的<em>所有</em>语义模型元素，而不仅仅是主要元素。如果有的话，这将包括额外的<code>DRepresentationElement#semanticElements</code> 。
			</li>
			<li>
				<code>input.emfEditServices(EObject)</code> ：提供一个句柄，用于在参数中指定的模型元素上调用“EMF Edit”相关服务。有关可在结果上调用的服务列表，请参见下文。
			</li>
			<li>
				<code>input.context()</code> ：提供一个句柄来调用其他服务，以获取有关选择的整体上下文的更多信息。请参阅下面的fot可以在结果上调用的服务列表。
			</li>
		</ul>
		<p>
			<strong><code>input.emfEditServices(EObject)</code> 。
			</strong>在下面的描述中， <code>obj</code>指定传递给<code>emfEditServices()</code>的<code>EObject</code>实例。
		</p>
		<ul>
			<li>
				<code>getChoiceOfValues(EStructuralFeature)</code> ：返回<code>obj</code>的指定特征的所有可能值，由其<code>IItemPropertyDescriptor</code>定义。
			</li>
			<li>
				<code>getDescription(EStructuralFeature)</code> ：返回<code>obj</code>的指定特征的（文本）描述，由其<code>IItemPropertyDescriptor</code>定义。
			</li>
			<li>
				<code>getEStructuralFeatures()</code> ：返回默认情况下将在属性视图中显示的<code>obj</code>所有功能。这忽略了瞬态，派生和包含功能。
			</li>
			<li>
				<code>getImage()</code> ：返回用于<code>obj</code>的图像（图标），由其<code>IItemLabelProvider</code>定义。
			</li>
			<li>
				<code>getText()</code> ：返回用于<code>obj</code>的文本表示，由其<code>IItemLabelProvider</code>定义。
			</li>
			<li>
				<code>getText(EStructuralFeature)</code> ：如果没有定义显示名称，则返回<code>obj</code>的指定特征的“显示名称”，如其<code>IItemPropertyDescriptor</code>所定义，或者返回特征本身的文本表示（由其自己的<code>IItemLabelProvider</code>定义）。
			</li>
			<li>
				<code>isMultiline(EStructuralFeature)</code> ：检查<code>obj</code>的指定特征（假定是文本的）是否应该在多条线上表示，如其<code>IItemPropertyDescriptor.isMultiLine()</code>方法所定义。
			</li>
			<li>
				<code>needsCheckboxWidget(EStructuralFeature)</code> ：检查<code>obj</code>的指定特征是否可以由复选框小部件表示（即它是单值<code>boolean</code>或<code>java.lang.Boolean</code> ）。
			</li>
			<li>
				<code>needsTextWidget(EStructuralFeature)</code> ：检查<code>obj</code>的指定特征是否可以由文本（或文本区域）小部件表示（即它是单值字符串，数字或日期）。
			</li>
			<li>
				<code>setValue(EStructuralFeature, Object)</code> ：将<code>obj</code>的指定特征的值设置为给定值。这是一个围绕<code>EObject.eSet()</code>的瘦包装器，只应在widget操作中使用，因为它修改了模型。它只处理基本情况;如果可能，应优先考虑显式模型操作或定制服务。
			</li>
		</ul>
		<p>
			<strong><code>input.context()</code>上的服务。
			</strong>
		</p>
		<ul>
			<li>
				<code>mainSemanticElement()</code> ：返回与选择关联的主要语义元素。这相当于<code>input.getSemanticElement()</code> 。
			</li>
			<li>
				<code>allSemanticElements()</code> ：返回与选择关联的<em>所有</em>语义模型元素，而不仅仅是主要元素。这相当于<code>input.getAllSemanticElements()</code> 。
			</li>
			<li>
				<code>representation()</code> ：返回选择当前输入的<code>DRepresentation</code>实例，如果从<em>Model Explorer中</em>选择了元素，则返回<em>null</em> 。
			</li>
			<li>
				<code>semanticDecorator()</code> ：返回已选择的<code>DSemanticDecorator</code>实例。
			</li>
			<li>
				<code>session()</code> ：在完成选择的上下文中返回<code>Session</code> 。这是一个Java对象，只能由其他（自定义）Java服务使用。
			</li>
		</ul>
		<h2 id="categories">分类</h2>
		<p><em>类别</em>用于对<a href="#pages">页面</a>和<a href="#groups">组</a>进行排序。该类别不代表最终用户属性视图中的任何内容，该类别仅为说明者订购规范的方便性而存在。例如，可以创建<em>重用</em>类别以存储将由不同<a href="#pages">页面</a>和<a href="../general/Model_Operations.html#dialogandwizard">对话框</a>使用的所有组。
			<br>可以创建类别</p>
		<h2 id="pages">网页</h2>
		<p><em>页面</em>用于表示属性视图中的<strong>Tab</strong> 。
		</p>
		<p>
			<img alt="属性可以组织在单独的选项卡中，由页面描述元素定义" title="属性可以组织在单独的选项卡中，由页面描述元素定义" border="0" src="images/pages.png"> 
		</p>
		<p>通过在“ <em>属性视图描述”中</em>创建<em>页面</em>元素来配置<em>页面</em> 。在上图中，已经从VSM定义了两个<em>常规</em>和<em>层次结构</em>页面。它们出现在Sirius提供的标准选项卡上方（ <em>Semantic</em> ， <em>Advanced</em>等）。
		</p>
		<p>与其他属性视图元素非常相似，您必须指定<a href="#identifier"><em>标识符</em></a> ， <a href="#domain_class"><em>域类</em></a> ， <a href="#precondition_expression"><em>前提条件表达式</em></a> ， <a href="#label_expression"><em>标签表达式</em></a> ， <a href="#semantic_candidate_expression"><em>语义候选表达式</em></a> 。
		</p>
		<p>一个页面的定义如下所述的一般规则<a href="#properties_view_description">以上</a> ，以确定哪些页面应被创建的语义元素。
		</p>
		<p>页面的内容由它引用的<a href="#groups"><em>组</em></a>定义，这些<a href="#groups"><em>组</em></a>直接在“ <em>属性视图描述”</em>下定义。这些组在页面中按照其在VSM中的组参考列表中的顺序进行排序。</p>
		<h3 id="page-toolbar-action">工具栏操作</h3>
		<p>页面还可以定义工具栏操作，这些操作将用于在页面工具栏中创建按钮，以便最终用户轻松执行某些操作。<em>工具栏操作</em>可以通过返回<em>Tooltip表达式</em>的字符串来获得<em>工具提示</em> 。它们还包含一个<em>初始操作，</em>用于定义用户单击按钮时要执行的模型操作。最后， <em>工具栏操作</em>可以通过<em>Image表达式</em>获得<em>图像</em> 。<em>Image表达式</em>必须返回具有以下结构PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif。如果未提供或未找到图像，将使用默认图像。
		</p>
		<h2 id="groups">组</h2>
		<p><em>组</em>用于表示属性视图选项卡中的<strong>节</strong> 。
		</p>
		<p>
			<img alt="在选项卡内，属性可以在可折叠部分中分组" title="在选项卡内，属性可以在可折叠部分中分组" border="0" src="images/groups.png">
		</p>
		<p>通过在“ <em>属性视图描述”中</em>创建<em>组</em>元素来配置<em>组</em> 。只有在相应<em>页面</em>引用的组中，组才会在选项卡中可见。默认情况下，新创建的<em>Group</em>元素不是任何页面的一部分，因此您<em>必须</em>将其显式添加到应该出现的<em>Pages</em> 。可以根据需要在尽可能多的<em>页面</em>定义中引用单个<em>组</em>定义;这允许在不同页面之间共享公共部分。
		</p>
		<p>与其他属性视图元素非常相似，您必须指定<a href="#identifier"><em>标识符</em></a> ， <a href="#domain_class"><em>域类</em></a> ， <a href="#precondition_expression"><em>前提条件表达式</em></a> ， <a href="#label_expression"><em>标签表达式</em></a> ， <a href="#semantic_candidate_expression"><em>语义候选表达式</em></a> ， <a href="#styles"><em>样式</em></a> ， <a href="#conditional_styles"><em>条件样式</em></a> 。
		</p>
		<p>一组的定义如下所述的一般规则<a href="#properties_view_description">以上</a> ，以确定其中一组应该被创建的语义元素。
		</p>
		<p>组可以包含<a href="#widgets"><em>窗口小部件</em></a> ，用于组织它们的<a href="#containers_and_layout"><em>容器</em></a>和<a href="#validation_rules"><em>验证规则</em></a> ，所有这些都在组描述（ <em>新</em> <a href="#widgets"><em>窗口小</em></a> <em>部件&gt;容器|文本...</em>和<em>新建&gt;组验证</em> ）中定义。
		</p>
		<h3 id="group-toolbar-action">工具栏操作</h3>
		<p>组还可以定义工具栏操作，这些操作将用于在组的工具栏中创建按钮，以便最终用户轻松执行某些操作。<em>工具栏操作</em>可以通过返回<em>Tooltip表达式</em>的字符串来获得<em>工具提示</em> 。它们还包含一个<em>初始操作，</em>用于定义用户单击按钮时要执行的模型操作。最后， <em>工具栏操作</em>可以通过<em>Image表达式</em>获得<em>图像</em> 。<em>Image表达式</em>必须返回具有以下结构PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif。如果未提供或未找到图像，将使用默认图像。
		</p>
		<h3 id="widgets-from-domain-class">来自Domain Class的小部件</h3>
		<p>
			<img alt="为EClass的每个结构特征轻松创建一个小部件" title="为EClass的每个结构特征轻松创建一个小部件" border="0" src="images/widget-from-domain-class.png">
		</p>
		<p>通过指定组的<em>Domain Class</em>并通过在组的相关容器上指定元模型（如Properties View对象），您将可以访问用于为每个组创建窗口小部件的默认版本的新上下文操作。您的<em>域类的</em>结构特征。您可以一次创建所有小部件，也可以只创建所需的小部件。odesign中生成的配置受到默认规则的启发，因此所有EString属性都将由文本小部件处理，所有EBoolean属性都由复选框处理，等等。</p>
		<h3 id="group_styles">团体风格</h3>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a> 。本节仅介绍特定于组的方面。
		</p>
		<p>对于组，您可以定义以下样式属性：</p>
		<ul>
			<li>
				<em>背景颜色</em> ：您可以使用标准或用户定义调色板中的<a href="#colors">颜色</a>指定背景颜色。
			</li>
			<li>
				<em>条形样式</em> ：用于定义截面样式。有3种不同的风格： <code>TITLE BAR</code> ， <code>SHORT TITLE BAR</code> ， <code>NO TITLE</code> （请参阅下面的第一个表格，了解这些风格的幻灯片）。
			</li>
			<li>
				<em>默认扩展</em> ：此标志用于定义是否应初始扩展或折叠该部分。
			</li>
			<li>
				<em>字体名称表达式</em> ：用于计算要使用的字体的名称。
			</li>
			<li>
				<em>字体大小表达式</em> ：表示要在点中使用的字体大小。
			</li>
			<li>
				<em>前景色</em> ：您可以使用标准或用户定义的调色板中的<a href="#colors">颜色</a>指定前景色。
			</li>
			<li>
				<em>切换样式</em> ：用于定义切换的样式。有3种不同的切换： <code>TWISTIE</code> ， <code>TREE NODE</code> ， <code>NONE</code> （有关这些样式的说明，请参见下面的第二个表格）。
			</li>
		</ul>
		<p>下表说明了组中可用的不同<em>栏样式</em>和<em>切换样式</em> ：</p>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/group-style-titlebar.png">
				</td>
				<td>
					<img border="0" src="images/group-style-short-titlebar.png">
				</td>
				<td>
					<img border="0" src="images/group-style-no-title.png">
				</td>
			</tr>
			<tr>
				<th>
					<code>标题栏</code>
				</th>
				<th>
					<code>SHORT TITLE BAR</code>
				</th>
				<th>
					<code>无题</code>
				</th>
			</tr>
		</table>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/group-style-toggle-twistie.png">
				</td>
				<td>
					<img border="0" src="images/group-style-toggle-treenode.png">
				</td>
				<td>
					<img border="0" src="images/group-style-toggle-none.png">
				</td>
			</tr>
			<tr>
				<th>
					<code>伸缩按钮</code>
				</th>
				<th>
					<code>树节点</code>
				</th>
				<th>
					<code>没有</code>
				</th>
			</tr>
		</table>
		<h2 id="widgets">小工具</h2>
		<p>窗口小部件用于表示属性视图中的模型元素，对于大多数窗口小部件，允许用户编辑所述元素。窗口小部件可以直接显示在组内， <a href="#dynamic_mappings">动态映射中</a>或<a href="#containers_and_layout">容器</a>内部，在这种情况下，您可以指定特定的<a href="#containers_and_layout">布局</a> ，该<a href="#containers_and_layout">布局</a>将用于以图形方式组织容器内的所有窗口小部件。
		</p>
		<p>小部件的定义如下所述的一般规则<a href="#properties_view_description">以上</a> ，以确定哪些小窗口应被创建的语义元素。
		</p>
		<p>与其他属性视图元素非常相似，您可以指定小部件的<a href="#label_expression"><em>标签表达式</em></a> ， <a href="#help_expression"><em>帮助表达式</em></a> ， <a href="#is_enabled_expression"><em>启用表达式</em></a> ， <a href="#styles"><em>样式</em></a> ， <a href="#conditional_styles"><em>条件样式</em></a> 。
		</p>
		<h3 id="text">文字/文字区域</h3>
		<p>“ <em>文本”</em>窗口小部件用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>单行文本</strong> 。
		</p>
		<p>
			<img border="0" src="images/widget-text.png">
		</p>
		<p><em>文本区域</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>多行文本</strong> 。
		</p>
		<p>
			<img border="0" src="images/widget-textarea.png">
		</p>
		<p>文本/文本区域的定义如下所述的一般规则<a href="#widgets">以上</a>来确定哪些文本应当创建的语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于文本和文本区域，您必须定义<em>值表达式</em> ，该<em>值</em>用于计算文本字段中显示的文本，并应返回一个字符串。如果未指定表达式，则默认值为空字符串。表达式在语义目标元素的上下文中进行评估。
		</p>
		<p>对于文本区域，必须定义<em>行计数</em> ，该<em>行计数</em>表示文本区域的高度（以<em>行数</em>表示）。
		</p>
		<h4 id="edit_text">文字版</h4>
		<p>要在发生更改时定义文本的行为，您只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与小部件内直接包含的<em>Begin</em>元素内的版本相关联的行为。
		</p>
		<p>在<em>Begin</em>下定义的操作可以使用<code>newValue</code>变量，该变量表示用户输入的值（作为字符串）。根操作在语义目标元素的上下文中执行。
		</p>
		<p>当焦点离开小部件时，Sirius会自动调用编辑操作。对于单行<em>文本</em>小部件，当用户<em>按Enter键</em>时也会触发编辑操作。请注意，如果在执行编辑操作时发生错误，则会取消对基础模型的操作的整体效果，并记录错误。
		</p>
		<h4 id="text_styles">文本/文本区域样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。本节仅介绍特定于文本的方面。
		</p>
		<p>文本样式的责任之一是描述如何格式化文本字段。可以使用以下属性：</p>
		<ul>
			<li>
				<em>字体名称表达式</em> ：用于计算用于文本字段的字体名称。
			</li>
			<li>
				<em>字体大小表达式</em> ：表示要在点中使用的字体大小。
			</li>
			<li>
				<em>背景颜色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定文本字段的背景颜色。
			</li>
			<li>
				<em>前景色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定文本字段的前景色。
			</li>
			<li>
				<em>字体格式</em> ：用于指定字体样式属性（粗体和/或斜体和/或下划线和/或穿透）。
			</li>
		</ul>
		<p>以下是文本和文本区域小部件的示例，其中一些样式属性已自定义：</p>
		<p>
			<img alt="具有自定义样式的Text和TextArea小部件" title="具有自定义样式的Text和TextArea小部件" border="0" src="images/widget-text-styling.png">
		</p>
		<h3 id="button">按键</h3>
		<p><em>Button</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>按钮</strong> ，可用于触发模型上的任意（可配置）操作。
		</p>
		<p>
			<img alt="按钮小部件的示例" title="按钮小部件的示例" border="0" src="images/widget-button.png">
		</p>
		<p>一个按钮的定义如下所述的一般规则<a href="#widgets">以上</a> ，以确定哪个按钮应该创建语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于按钮，您必须定义<em>按钮标签表达式</em> ，该<em>表达式</em>用于计算按钮上显示的标签，并应返回一个字符串。如果未指定表达式，则默认值为空字符串。您还可以使用图像<em>表达式</em>指定图像。可以使用图像代替按钮标签或与其一起使用。<em>Image表达式</em>应返回一个结构为PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif</p>
		<h4 id="pushed_button">单击时执行的行为</h4>
		<p>要在单击按钮时定义按钮的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。根操作在语义目标元素的上下文中执行。
		</p>
		<h4 id="button_styles">按钮样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="label">标签</h3>
		<p><em>标签</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>不可编辑文本</strong> 。
		</p>
		<p>这是一个显示两个标签小部件的示例：</p>
		<p>
			<img alt="标签小部件的示例" title="标签小部件的示例" border="0" src="images/widget-label.png">
		</p>
		<p>标签的定义如下所述的一般规则<a href="#widgets">以上</a> ，以确定哪个标签所创建的语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于标签，您必须定义<em>值表达式</em> ，用于计算描述中显示的文本。<em>Value Expression</em>可以返回任何类型的对象，但显示的结果将是对<code>Object.toString()</code>的调用结果。如果要自定义结果的显示方式，可以在值表达式中返回字符串或使用“ <em>显示表达式”</em> 。<em>Display Expression</em>可以使用变量<code>value</code>访问<em>Value Expression</em>的结果，它应该返回一个字符串。如果未指定表达式，则默认值为空字符串。
		</p>
		<h4 id="label_actions">小部件操作</h4>
		<p><em>Label</em>可以选择定义一个或多个<em>Widget动作</em> ，它们被创建为<em>Label</em>元素的子元素（ <em>New&gt; Widget Action</em> ）。每个操作都有一个<em>Label Expression</em>和一个由内部包含的<a href="../general/Model_Operations.html">模型操作</a>定义的行为。如果存在，操作将呈现为标签本身右侧的按钮。按钮的文本由<em>Label Expression</em>定义，并由模型操作推送时的行为。您还可以使用图像<em>表达式</em>指定图像。可以使用图像代替标签或与其一起使用。<em>Image表达式</em>应返回一个结构为PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif</p>
		<h4 id="label_styles">标签样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。本节仅介绍特定于文本的方面。
		</p>
		<p>标签样式的责任之一是描述如何形成描述。可以使用以下属性：</p>
		<ul>
			<li>
				<em>字体名称表达式</em> ：用于计算用于描述的字体名称。
			</li>
			<li>
				<em>字体大小表达式</em> ：表示要在点中使用的字体大小。
			</li>
			<li>
				<em>背景颜色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定描述的背景颜色。
			</li>
			<li>
				<em>前景色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定描述的前景色。
			</li>
			<li>
				<em>字体格式</em> ：用于指定字体样式属性（粗体和/或斜体和/或下划线和/或穿透）。
			</li>
		</ul>
		<p>
			<img alt="具有自定义样式的标签示例" title="具有自定义样式的标签示例" border="0" src="images/widget-label-styling.png">
		</p>
		<h3 id="checkbox">复选框</h3>
		<p><em>复选框</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>复选框</strong> 。
		</p>
		<p>
			<img alt="复选框小部件的示例" title="复选框小部件的示例" border="0" src="images/widget-checkbox.png">
		</p>
		<p>复选框的定义遵循上述一般规则<a href="#widgets">，</a>以确定应为其创建复选框的语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于复选框，您必须定义<em>Value Expression</em> ，用于计算复选框的已选中/未选中状态，因此应返回一个布尔值（返回<em>true</em>以显示选中的复选框）。
		</p>
		<h4 id="checkbox_change_value">改变价值</h4>
		<p>要在用户单击时定义复选框的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。
		</p>
		<p>在<em>Begin</em>下定义的操作可以使用<code>newValue</code>变量，该变量表示用户设置的值作为布尔值;如果之前取消选中该复选框，并且用户单击它以检查它，则为<em>true</em> ，否则为<em>false</em> 。请注意，如果在执行编辑操作时发生错误，则会对基础模型上的操作产生影响，并记录错误。
		</p>
		<h4 id="checkbox_styles">复选框样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="select">选择</h3>
		<p><em>Select</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>组合框</strong> 。
		</p>
		<p>
			<img alt="选择小部件的示例" title="选择小部件的示例" border="0" src="images/widget-select.png">
		</p>
		<p>一个选择的定义描述如下的一般规则<a href="#widgets">以上</a>以确定选择应创建的量，语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于选择，您必须定义：</p>
		<ul>
			<li><em>候选表达式</em> ，用于计算组合中可用的候选项，并应返回用户可从中选择选择值的元素列表。
			</li>
			<li><em>候选显示表达式</em> ，用于计算为组合中的每个可能候选项显示的标签，因此应返回一个字符串。<em>候选显示表达式</em>可以使用表示当前评估的元素的<code>candidate</code>变量。
			</li>
			<li><em>Value Expression</em> ，用于计算在组合中选择的元素，并应返回一个对象，该对象应该是<em>Candidates Expression</em>返回的集合的元素。
			</li>
		</ul>
		<h4 id="select_change_value">改变价值</h4>
		<p>要在用户选择其他元素时定义<em>Select</em>的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。
		</p>
		<p>在<em>Begin</em>下定义的表达式可以使用<code>newValue</code>变量，该变量表示用户选择的值。请注意，如果在执行编辑操作时发生错误，则会取消对基础模型的操作的整体效果，并记录错误。
		</p>
		<h4 id="select_styles">选择样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="radio_group">广播组</h3>
		<p><em>无线电</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>无线电组</strong> 。
		</p>
		<p>
			<img alt="无线电组窗口小部件的示例" title="无线电组窗口小部件的示例" border="0" src="images/widget-radio.png">
		</p>
		<p>无线电基团定义如下描述的一般规则<a href="#widgets">以上</a> ，以确定哪个无线电组应该创建语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于无线电组，您必须定义：</p>
		<ul>
			<li><em>候选表达式</em> ，用于计算无线电组中可用的候选者，并应返回用户可从中选择无线电组值的元素列表。
			</li>
			<li><em>候选显示表达式</em> ，用于计算为无线电组中每个可能候选者显示的标签，因此应该返回一个字符串。<em>候选显示表达式</em>可以使用表示当前评估的元素的<code>candidate</code>变量。
			</li>
			<li><em>Value Expression</em> ，用于计算在单选组中选择的元素，并应返回一个对象，该对象应该是<em>Candidates Expression</em>返回的集合的元素。
			</li>
		</ul>
		<h4 id="radio_change_value">改变价值</h4>
		<p>要在选择更改时定义单选按钮组的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的编辑关联的行为。
		</p>
		<p>在<em>Begin</em>下定义的表达式可以使用<code>newValue</code>变量，该变量表示用户选择的值。请注意，如果在执行编辑操作时发生错误，则会取消对基础模型的操作的整体效果，并记录错误。
		</p>
		<h4 id="radio_styles">电台风格</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="hyperlink">超链接</h3>
		<p><em>超链接</em>用于表示<a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a>的<strong>超链接</strong> 。
		</p>
		<p>
			<img alt="超链接小部件的示例" title="超链接小部件的示例" border="0" src="images/widget-hyperlink.png">
		</p>
		<p>一个超链接的定义如下所述的一般规则<a href="#widgets">以上</a> ，以确定其中的超链接应该创建语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于超链接，您必须定义用于计算显示的超链接的<em>值表达式</em> 。<em>Value Expression</em>可以返回任何类型的对象，但显示的结果将是调用<em>java.lang的结果<em>。Object＃toString（）</em> 。如果要自定义结果的显示方式，可以在值表达式中返回String或使用“ <em>显示表达式”</em> 。<em>Display Expression</em>可以使用名为<code>value</code>的变量访问<em>Value Expression</em>的结果，它应该返回一个String。
		</p>
		<h4 id="hyperlink_click_on_value">单击时执行的行为</h4>
		<p>要在单击超链接时定义超链接的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。
		</p>
		<h4 id="hyperlink_actions">小部件操作</h4>
		<p><em>超链接</em>可以选择定义一个或多个<em>Widget动作</em> ，这些<em>动作</em>创建为<em>Hyperlink</em>元素的子元素（ <em>New&gt; Widget Action</em> ）。每个操作都有一个<em>Label Expression</em>和一个由内部包含的<a href="../general/Model_Operations.html">模型操作</a>定义的行为。如果存在，操作将呈现为标签本身右侧的按钮。按钮的文本由<em>Label Expression</em>定义，并由模型操作推送时的行为。您还可以使用图像<em>表达式</em>指定图像。可以使用图像代替按钮标签或与其一起使用。<em>Image表达式</em>应返回一个结构为PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif</p>
		<h4 id="hyperlink_styles">超链接样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。本节仅介绍特定于超链接的方面。
		</p>
		<p>超链接样式的责任之一是描述如何格式化超链接。可以使用以下属性：</p>
		<ul>
			<li>
				<em>字体名称表达式</em> ：用于计算用于文本字段的字体名称。
			</li>
			<li>
				<em>字体大小表达式</em> ：表示要在点中使用的字体大小。
			</li>
			<li>
				<em>背景颜色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定文本字段的背景颜色。
			</li>
			<li>
				<em>字体格式</em> ：用于指定字体样式属性（粗体和/或斜体和/或穿透）。
			</li>
		</ul>
		<h3 id="reference">参考</h3>
		<p><em>Reference</em>用于表示模型中引用的值。
		</p>
		<p><em>Reference</em>小部件的配置很少。除了<em>Label Expression</em> ， <em>Help Expression</em>和<em>Is Enabled Expression</em>等所有小部件上的标准属性，您只需指定：</p>
		<ul>
			<li>
				<em>引用所有者表达式</em> ：可选，默认为<code>var:self</code> 。如果指定，则将对表达式返回的元素（而不是当前表达式）返回对display的引用。
			</li>
			<li>
				<em>引用名称表达式</em> ：这应返回一个字符串，该字符串指定要显示的<em>EReference</em>的名称。它可以是固定字符串或计算表达式。
			</li>
		</ul>
		<p><em>Reference</em>小部件的外观将取决于对显示的引用是单值还是多值：</p>
		<p>
			<img alt="显示单值引用的Reference小部件" title="显示单值引用的Reference小部件" border="0" src="images/reference-single-value.png">
		</p>
		<p>
			<img alt="显示多值引用的引用窗口小部件" title="显示多值引用的引用窗口小部件" border="0" src="images/reference-multiple-value.png">
		</p>
		<p>如上所述， <em>Reference</em>小部件的可配置性很小，它使用标准EMF功能确定其所有行为：</p>
		<ul>
			<li>使用<code>eGet</code>反射获得参考值。
			</li>
			<li>使用相应的<code>IItemLabelProvider</code>自动确定参考值的文本表示和图标。
			</li>
			<li>操作按钮的行为被硬编码以在选择diffrente值（来自模型中的现有元素）时执行标准操作，创建新实例以设置为值，移除元素或向上/向下移动多值参考中的元素。</li>
		</ul>
		<p>如果需要更具体的行为，则需要使用<em>超链接</em> （对于单个值）或使用<em>列表</em>窗口小部件（对于多个值）以及实现所需行为的自定义操作。
		</p>
		<p>以与超链接和列表小部件类似的方式，可以在参考小部件上定义<em>初始操作</em> ，以便在用户单击小部件时执行一些模型操作。如果配置了<em>初始操作</em> ，则窗口小部件的单值版本将使用超链接而不是常规标签。
		</p>
		<h4 id="reference_styles">参考样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="list">名单</h3>
		<p><em>List</em>用于表示<a href="#containers_and_layout">包含</a> <a href="#groups">组</a>或<a href="#containers_and_layout">容器中</a> <strong>按钮</strong>的<strong>列表</strong> 。
		</p>
		<p>根据参数配置，当定义<a href="#list_actions"><em>Widget动作</em></a>时，由于列表和多个按钮，将表示列表<a href="#list_actions"><em>小部件</em></a> 。
		</p>
		<p>列表的定义遵循上述一般规则<a href="#widgets">，</a>以确定应为其创建列表的语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于列表，您必须定义：</p>
		<ul>
			<li><em>Value Expression</em> ，用于计算要显示的元素，并应返回一个对象。
			</li>
			<li><em>显示表达式</em> ，用于计算文本字段中显示的文本，并应返回一个字符串。它在语义目标元素的上下文中进行评估，并且可以访问与要显示的元素对应的变量<code>value</code> 。
			</li>
			<li><a href="#list_actions"><em>Widget Actions</em></a>用于将某些按钮与文本字段相关联。
			</li>
		</ul>
		<h4 id="list_on_click_operation">单击时执行的行为</h4>
		<p>要定义行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。名为<code>onClickEventKind</code>的变量可用于确定单击或双击是否触发了操作。如果单击一下，如果双击，变量的值为“SINGLE_CLICK”和“DOUBLE_CLICK”。
		</p>
		<p>在<em>Begin</em>下定义的表达式可以使用<code>selection</code>变量，该变量表示用户选择的值。此变量将包含所选值的列表。
		</p>
		<h4 id="list_actions">小部件操作</h4>
		<p>列表可以包含表示与列表字段关联的<strong>按钮的</strong> <em>操作</em> 。
		</p>
		<p>对于操作，您必须定义<em>Label Expression</em> ，用于计算按钮上显示的标签，并应返回一个字符串。如果未指定表达式，则默认值等于<code>...</code>您还可以使用图像<em>表达式</em>指定图像。可以使用图像代替按钮标签或与其一起使用。<em>Image表达式</em>应返回一个结构为PROJECT_NAME / IMAGE_PATH的字符串。例如：org.eclipse.sirius.sample.basicfamily.design/icons/Delete_16x16.gif</p>
		<h4 id="list_action_pushed_button">行动推按钮</h4>
		<p>要在按下按钮时定义按钮的行为，只需使用所有标准<a href="../general/Model_Operations.html">模型操作</a>指定与<em>Begin</em>元素内的版本关联的行为。
		</p>
		<p>在<em>Begin</em>下定义的表达式可以使用<code>selection</code>变量，该变量表示用户在列表字段中选择的值。请注意，即使当前只选择了一个元素， <code>selection</code>也始终是一个集合。
		</p>
		<h4 id="list_styles">列表样式</h4>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。
		</p>
		<h3 id="basic_custom_widgets">基本自定义小部件</h3>
		<p>如果没有预定义样式符合您的需要，则使用<em>自定义描述</em> 。自定义小部件使用Java实现，并使用<code>org.eclipse.eef.ide.ui.eefLifecycleManagerProvider</code>扩展点。
		</p>
		<p>自定义窗口小部件的定义遵循上述一般规则<a href="#widgets">，</a>以确定应为其创建自定义窗口小部件的语义元素。它在语义目标元素的上下文中进行评估。
		</p>
		<p>对于自定义小部件， <em>标识符</em>是必需的。它用于查找使用扩展点贡献的小部件。
		</p>
		<p>有关如何实际实现自己的基本自定义小部件的<a href="../../developer/extensions-properties_provide_custom_widget_basic.html">信息</a> ，请参阅<a href="../../developer/extensions-properties_provide_custom_widget_basic.html">参考文档</a> 。
		</p>
		<h5 id="basic_custom_widgets_expression">自定义表达/操作</h5>
		<p>定义自定义窗口小部件时，可以定义自定义窗口小部件实现将使用的某些自定义表达式或操作。
			<br>在这种情况下， <em>标识符</em>是必需的。它将在Java代码中用于查找与VSM一起提供的表达式/操作。</p>
		<h5 id="basic_custom_widgets_styles">自定义样式</h5>
		<p>有关如何定义样式的一般介绍，请参阅<a href="#styling">样式</a>部分，包括<a href="#conditional_styles">条件样式</a>和<a href="#widgets_styles">窗口小部件样式</a>部分，以查找有关窗口小部件特定内容的详细信息。本节仅介绍特定于文本的方面。
		</p>
		<h3 id="advanced_custom_widgets">高级自定义小部件</h3>
		<p>需要使用非常通用的<em>自定义表达式/操作</em>来配置基本自定义小部件，这使得它们与标准小部件不同且难以使用。任何可在标准窗口小部件上的VSM编辑器属性表中直接访问的配置属性都需要具有确切预期标识符的特定<em>自定义表达式</em> 。
		</p>
		<p>可以改进自定义小部件以更好地与VSM编辑器集成，以使其配置看起来和感觉像任何标准小部件。对于说明符的观点，这些小部件的配置遵循与默认小部件相同的原则。</p>
		<p>有关如何实际实现自己的高级自定义小部件的<a href="../../developer/extensions-properties_provide_custom_widget_advanced.html">信息</a> ，请参阅<a href="../../developer/extensions-properties_provide_custom_widget_advanced.html">参考文档</a> 。
		</p>
		<h2 id="dynamic_mappings">动态映射</h2>
		<p>动态映射用于高级场景，其中要显示的窗口小部件集不能静态地知道，而是必须在运行时计算。动态映射包含条件小部件定义，每个条件小部件定义可以在运行时被零实例化或多次实例化。</p>
		<p><em>动态映射For</em>可以直接显示在组描述中，也可以显示在<a href="#containers_and_layout">容器内</a> ，在这种情况下，您可以指定特定的<a href="#containers_and_layout">布局</a> 。您必须指定一个<em>Iterable Expression</em> ，它计算要迭代的元素列表。还必须定义<em>Iterator</em>属性，并且该属性对应于可在<em>For中</em>访问的迭代变量的名称。<em>动态映射</em>内部您可以创建任意数量的<em>动态映射If</em> ，它定义<em>谓词表达式</em>并且可以包含<strong>一个小部件</strong> 。
		</p>
		<p>在运行时，对于用户选择的给定输入元素，Sirius将评估<em>可迭代表达式</em> ，然后对于返回的每个元素将实例化<em>动态映射中</em>定义的小部件， <em>如果</em>其谓词成立。
		</p>
		<p>即使您未在VSM中指定任何<em>属性视图描述</em> ，动态映射机制也是Sirius用于提供默认属性视图的机制。<br>如果我们采用Sirius实施的默认规则之一，我们有：</p>
		<ul>
			<li><em>动态映射用于</em>定义为可<code>aql:self.eClass().eAllStructuralFeatures</code> <em>表达式</em> ： <code>aql:self.eClass().eAllStructuralFeatures</code>这意味着获取当前eClass可用的所有结构特征。
			</li>
			<li><em>迭代器</em>设置为<code>eStructuralFeature</code> 。
				<ul>
					<li><em>动态映射如果</em> <em>Predicate Expression</em>等于<code>aql:eStructuralFeature.eType.instanceTypeName = 'java.lang.String'</code> ，这意味着我们只是将结构特征序列化为String。请注意，在谓词表达式中，我们使用变量<code>eStructuralFeature</code> ，它被定义为<em>迭代器</em> 。
						<ul>
							<li>在这种情况下，我们将使用我们设置的<em>Text小部件</em>来表示结构特征：<ul>
									<li>
										<em>标签表达式</em> ： <code>aql:eStructuralFeature.name.toUpperFirst() + ':'</code>表示获取结构特征的名称，大写第一个字母并在末尾添加<code>:</code> 。
									</li>
									<li>
										<em>值表达式</em> ： <code>aql:self.eGet(eStructuralFeature.name)</code> ，表示获取与给定结构特征关联的值。
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>由于这种机制，我们定义了元模型中的所有<code>String</code>元素都将用文本字段表示。
		</p>
		<p>一些<em>Iterable Expression</em>可以返回一个结果，该结果可以根据模型的结构而改变，与上面的示例相反， <em>Iterable Expression</em> <code>aql:self.eClass().eAllStructuralFeatures</code>将仅使用元模型的结构。如果<em>Iterable Expression</em>利用模型的状态，则可能需要在执行<em>Iterable Expression</em>时刷新用户界面，因此对于这种情况，您可以在<em>动态映射</em>上将布尔<em>强制刷新</em>设置为true以指示动态映射的存在应该触发完全刷新。
		</p>
		<h2 id="containers_and_layout">容器和布局</h2>
		<p>Sirius提供了一个默认算法，用于在属性视图中执行所有控件的自动布局。如果默认算法不符合您的需要，您可以直接在VSM中为备用布局指定一些参数。为此，您必须首先创建一个<em>Container</em> ，其中包含将应用布局的所有小部件，然后创建和配置容器用于组织其子小部件的布局：</p>
		<p id="fill_layout">
			<em>填充布局</em>可以水平或垂直组织容器内的元素（可在<em>Fill布局</em>元素上配置）。
		</p>
		<p id="grid_layout">
			<em>网格布局</em>可以使用固定数量的列（可在<em>Grid布局</em>元素上配置）来组织元素，可以选择使用所有列具有相同的宽度。
		</p>
		<h2 id="styling">造型</h2>
		<p>样式定义属性视图元素的图形外观。Sirius支持丰富的可能样式集，包括可以根据底层模型元素的当前状态动态更改的<a href="#conditional_styles">条件样式</a> 。如果未定义样式，则Sirius将应用默认样式。
			<br>可以通过在属性视图元素描述下创建样式来重新定义默认样式。
		</p>
		<h3 id="widgets_styles">小部件样式</h3>
		<p>窗口小部件样式的责任之一是描述如何格式化标签。可以使用以下属性：</p>
		<ul>
			<li>
				<em>标签字体名称表达式</em> ：用于计算用于<em>标签的字体名称</em> 。
			</li>
			<li>
				<em>标签字体大小表达式</em> ：指示要在点中使用的字体大小。
			</li>
			<li>
				<em>标签背景颜色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定<em>标签的背景颜色</em> 。
			</li>
			<li>
				<em>标签前景颜色</em> ：您可以使用<a href="#colors">颜色</a>子元素指定<em>标签的前景颜色</em> 。
			</li>
			<li>
				<em>标签字体格式</em> ：用于指定字体样式属性（粗体和/或斜体和/或下划线和/或穿透）。
			</li>
		</ul>
		<p>
			<img alt="标签上可能的样式自定义示例" title="标签上可能的样式自定义示例" border="0" src="images/label-styles.png">
		</p>
		<h3 id="colors">颜色</h3>
		<p>每当您必须为样式指定颜色时，您可以使用任何一种预定义的系统颜色或您在<em>用户调色板中</em>自己定义的<em>颜色</em> 。有关详细信息，请参阅<a href="../general/Colors.html">颜色的常规部分</a> 。
		</p>
		<h3 id="conditional_styles">条件样式</h3>
		<p>条件样式使得可以为单个属性视图元素支持不同的图形方面。用于呈现元素的实际样式是根据模型元素的当前状态动态确定的。</p>
		<p>要使用条件样式，必须添加一个或多个条件样式。每个条件样式都与指定为谓词的条件相关联。如果属性视图元素上存在条件样式，则会在描述中按其出现顺序测试它们的条件。选择条件为真的第一个。如果没有条件样式条件为真，则使用默认样式。</p>
		<h2 id="validation_rules">验证规则</h2>
		<p>可以指定三种验证规则。可用的各种验证规则之间的主要区别在于验证消息的位置（在页面，组或窗口小部件上）。所有验证规则都可以包含用于确定验证规则是否已被破坏的<code>auditExpression</code> ，这是由于<code>auditExpression</code>应该返回一个布尔值，指示规则的验证是否成功。验证规则还可以包含修复程序，以便解决发现的问题。这些验证修复程序具有名称和修复表达式，一旦最终用户选择快速修复，它将执行。修复表达式不必返回任何内容。所有这些表达式都可以访问变量<code>self</code> ，即页面或组的语义候选表达式的结果，并<code>input</code>视图的输入。
		</p>
		<h3 id="page_semantic_validation_rule">页面语义验证规则</h3>
		<p>页面语义验证规则用于定义链接到页面的验证规则。</p>
		<h3 id="group_semantic_validation_rule">组语义验证规则</h3>
		<p>组语义验证规则用于定义链接到组的验证规则。</p>
		<h3 id="group_property_validation_rule">组属性验证规则</h3>
		<p>组属性验证规则用于定义链接到特定窗口小部件的验证规则。</p>
		<h2 id="extensibility_features">可扩展性功能</h2>
		<p>Sirius特别支持扩展和覆盖属性视图描述，而无需修改原始视图描述。目的是能够重用或修改属性视图的一部分。它退出两个不同的概念来定制属性视图描述： <a href="#extends">扩展</a>和<a href="#overrides">覆盖</a> 。
		</p>
		<p>请注意，这两种机制都可用于自定义在其他项目中定义的属性视图描述。要允许从VSM引用到其他建模器中定义的元素，必须先在VSM编辑器中<em>加载</em>它们，否则您将看不到作为扩展/覆盖目标所需的元素。要加载外部VSM，请右键单击VSM编辑器内的任意位置，然后选择“ <em>加载资源...”</em> 。将出现一个对话框，询问要加载的模型的URI（您要引用的<code>.odesign</code>文件）。有几种形式的URI是可能的：</p>
		<ul>
			<li>如果您的工作区中没有自定义插件，则必须使用语法<code>platform:/plugin/&lt;projectName&gt;/&lt;path&gt;/&lt;to&gt;/&lt;example&gt;.odesign</code>手动输入URI <code>platform:/plugin/&lt;projectName&gt;/&lt;path&gt;/&lt;to&gt;/&lt;example&gt;.odesign</code> ，for示例<code>platform:/plugin/org.eclipse.emf.ecoretools.design/description/ecore.odesign</code> 。
			</li>
			<li>如果要扩展的VSM已存在于开发工作区中，则可以使用“ <em>浏览工作区...”</em>按钮将其选中。
			</li>
		</ul>
		<p>请注意，在后一种情况下（从工作区中选择VSM），如果要直接从开发环境测试建模器，请在测试会话中确保<strong>从工作区中</strong>选择扩展的VSM，因为这是您自己的VSM指的是，而不是也可以从您的插件中获取的那个。在视点选择对话框中，除了普通视点图标外，工作区中的版本还将具有一个小文件夹装饰器。一旦将所有内容部署为插件（这是最终用户的名义案例），这种区别就会消失，一切都应该正常工作。
		</p>
		<p>还需要注意的是，如果你在你的项目<em>中的</em>自定义定义在另一个项目<em>B</em>中定义的属性意见defintions，你应该确保申报项目<em>A</em>的依赖<code>MANIFEST.MF</code> ，否则将有可能为用户<em>安装</em> ，而不必<em>B</em>可用，这将阻止<em>A</em>正常工作。
		</p>
		<h3 id="extends">扩展</h3>
		<p><a href="#pages">页面</a>可以扩展在其他位置定义的另一个页面（在另一个<a href="#categories">类别</a>或另一个属性视图描述中）。此机制用于<em>专门化</em> （修改或重用）现有页面。此功能适用于<a href="#pages">页面</a> ， <a href="#groups">组</a> ， <a href="#containers_and_layout">容器</a> ， <a href="#dynamic_mappings">动态映射</a>和<a href="#widgets">小部件</a> 。
		</p>
		<p>“ <code>Extend</code>选项卡用于指定：</p>
		<p id="extends">
			<strong>延伸。</strong> 用于指定继承的元素，由于组合框可以选择现有元素。在树编辑器中，继承是可见的，因为元素的命名如下： <em>页面A</em> <strong>扩展了</strong> <em>页面B.</em>注意，当前的规范编辑器允许选择当前定义的元素，这将导致运行时的无限循环。
			<br>默认情况下，如果未在extends元素中设置这些字段，则使用来自扩展元素的值设置“ <code>General</code>选项卡字段的值。如果在extends元素中编辑了其中一个属性，则它将<strong>覆盖</strong>继承的值。对单值包含元素应用相同的行为。例如，如果<em>组A</em>定义<em>样式A</em>并使用<em>样式B</em>扩展<em>组B</em> ，则用于呈现<em>组A</em>的样式是在<em>组A</em>下定义的<em>样式</em> ，即<em>样式A</em>而不是<em>组B中的</em> <em>样式</em> 。<br>如果说明符在扩展页面的<code>General</code>选项卡中定义：</p>
		<ul>
			<li>
				<code>Label Expression</code> ， <code>Domain Class</code> ， <code>Semantic Candidate Expression</code>或<code>Precondition Expression</code> ，这些值将<strong>覆盖</strong>扩展描述中定义的值。值得注意的是，表达式是在当前扩展元素的上下文中进行计算的，就像您从“ <code>General</code>选项卡中定义了表达式一样。
			</li>
			<li>
				<code>Groups</code>将<strong>聚合</strong>到引用<code>Page</code>定义的组。
			</li>
			<li>
				<code>Page Validations</code>将<strong>聚合</strong>到引用的<code>Page Description</code>定义的验证。
			</li>
			<li>对于包含的情况，例如<code>Group</code>包含的<code>Text</code> ，包含的元素由扩展描述继承。
			</li>
		</ul>
		<p id="filters">
			<strong>过滤表达式。</strong> 根据元素种类存在不同的过滤器。这些过滤器用于<strong>过滤</strong>哪些继承元素可见。<em>Filter表达式</em>在语义元素的上下文中计算，并且应该返回boolean：true，继承的元素是可见的，false是过滤的。
			<br>如果未指定表达式，则所有继承的元素都将可见。
			<br>对于每个<em>Filter表达式</em> ，都有一个变量可用于表示可以过滤的元素。可以通过一直返回<code>false</code>来过滤所有继承的元素。在这种情况下，在当前描述下定义的元素将<strong>覆盖</strong>扩展描述中定义的元素。
			<br>例如，如果<em>页面A</em>扩展另一个<em>页面B</em> ，则“ <code>Extends</code>选项卡允许定义：</p>
		<ul>
			<li><code>Filter Groups Expression</code>用于<strong>过滤</strong>页面下可见的继承组。<code>groupDescription</code>变量可用于检查是否必须过滤组。
			</li>
			<li><code>Filter Validation Rules Expression</code>用于<strong>过滤</strong>页面下使用的继承验证规则。<code>validationRuleDescription</code>变量可用于检查是否必须过滤规则。
			</li>
		</ul>
		<p>下面是一些扩展机制的使用示例：</p>
		<ul>
			<li>
				<strong>重用小部件</strong> ：在此示例中，我们要指定类的属性视图，并且接口都定义名称属性。定义<em>类名</em>文本小部件以表示属性视图中<em>类</em>的<em>Name</em>属性。此小组件在“ <em>常规”</em>选项卡中定义：<ul>
					<li><em>标签表达式</em>等于<code>Name:</code> ，</li>
					<li><em>帮助表达式</em>等于<code>The name of the element</code> ，</li>
					<li><em>Value Expression</em>等于<code>aql:self.name</code> ，</li>
					<li>更改值操作使用新输入的值设置<code>name</code>功能。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<img alt="继承的文本窗口小部件定义的示例" title="继承的文本窗口小部件定义的示例" border="0" src="images/reuse-widget-general-tab.png"> 
		</p>
		<p>接口还有一个<em>Name</em>属性，必须在其属性视图中显示，然后为了定义接口的属性，我们只需创建一个扩展<code>Class Name Widget</code>的新文本小<code>Class Name Widget</code> 。
			<br>不需要为<code>Interface Name Widget</code>设置其他字段和更改值操作，所有值都将从<code>Class Name Widget</code>继承。
		</p>
		<p>
			<img alt="扩展定义的示例" title="扩展定义的示例" border="0" src="images/reuse-widget-extends-tab.png"> 
		</p>
		<p>
			<img alt="窗口小部件定义的重用示例" title="窗口小部件定义的重用示例" border="0" src="images/reuse-widget-general2-tab.png"> 
		</p>
		<ul>
			<li>
				<strong>重用页面</strong> ：扩展机制的另一种用法是结合<a href="../general/Model_Operations.html#dialogandwizard">使用对话框和向导</a> 。目的是从对话框中提供属性元素的版本，对话框和属性视图中应该提供相同的属性。为元模型的所有元素定义属性视图。然后定义一个新工具，当从图中双击节点映射时，该工具将打开一个对话框。此对话框显示的属性与从图中选择元素时表示的属性相同。为此，该对话框定义了一个页面，该页面扩展了属性视图定义中定义的页面。
			</li>
		</ul>
		<p>
			<img alt="在对话框中重用页面定义的示例" title="在对话框中重用页面定义的示例" border="0" src="images/reuse-page.png">
		</p>
		<ul>
			<li>
				<strong>自定义默认规则</strong> ：扩展机制的最后一个示例是自定义Sirius提供的<a href="#default_rules">默认规则</a> 。对于此用例，目的是覆盖默认规则的内容，以便将选项卡标签从<em>Main</em>重命名为<em>General</em> 。由于VSM模型的顶级元素提供了“ <em>新建属性”&gt;“扩展默认属性视图”</em>菜单，因此可以扩展默认规则。这会自动创建一个扩展默认规则的新页面。然后可以覆盖默认规则页面的<em>标签表达式</em>以设置期望标签<em>General</em>而不是默认标签<em>Main</em>
			</li>
		</ul>
		<p>
			<img alt="默认规则扩展的示例" title="默认规则扩展的示例" border="0" src="images/customize-default-rules-extends.png">
		</p>
		<p>
			<img alt="自定义默认规则的示例" title="自定义默认规则的示例" border="0" src="images/customize-default-rules-general.png"> 
		</p>
		<h3 id="overrides">覆盖</h3>
		<p><a href="#extends">扩展</a>机制和<a href="#overrides">覆盖</a>机制之间的主要区别在于，扩展机制允许重用属性视图规范的某些部分，另一方面， <a href="#overrides">覆盖</a>机制允许替换属性视图规范的某些部分。
			<br>这意味着当您定义覆盖描述时，它将完全替换引用的描述，当说明符不可能修改原始描述时，必须使用此描述。
		</p>
		<p>可以在“ <em>新建覆盖”</em>菜单中的<a href="#categories">类别</a>下创建覆盖元素。
		</p>
		<p>页面覆盖可以扩展在其他位置定义的另一个页面（在另一个<a href="#categories">类别</a>或另一个属性视图描述中）。此机制用于<em>替换</em>现有页面。可以定义：</p>
		<ul>
			<li>页面覆盖： <em>页面覆盖</em>是一个页面，因此定义了与<a href="#pages">页面</a>相同的功能，</li>
			<li>组覆盖： <em>组覆盖</em>是一个组，因此定义了与<a href="#groups">组</a>相同的功能，</li>
			<li>容器覆盖： <em>容器覆盖</em>是一个容器，因此定义了与<a href="#containers_and_layout">容器</a>相同的功能，</li>
			<li>动态映射覆盖： <em>动态映射覆盖</em>是一种动态映射，因此定义了与<a href="#dynamic_mappings">动态映射</a>相同的功能，</li>
			<li>窗口小部件覆盖：窗口<em>小部件覆盖</em>是一个窗口小部件，因此定义了与<a href="#widgets">窗口小部件</a>相同的功能。
			</li>
		</ul>
		<p>“ <code>Override</code>选项卡用于指定：</p>
		<p id="override">
			<strong>覆盖。</strong> 由于组合框可用于指定重写元素，因此可以选择现有元素。在树编辑器中，继承是可见的，因为元素的命名如下： <em>页面A</em> <strong>扩展了</strong> <em>页面B.</em>注意，当前的规范编辑器允许选择当前定义的元素，这将导致运行时的无限循环。
			<br>默认情况下，如果未在extends元素中设置这些字段，则使用来自重写元素的值设置“ <code>General</code>选项卡字段的值。如果在extends元素中编辑了其中一个属性，则它将<strong>覆盖</strong>继承的值。对单值包含元素应用相同的行为。例如，如果<em>组A</em>定义<em>样式A</em>并使用<em>样式B</em>扩展<em>组B</em> ，则用于呈现<em>组A</em>的样式是在<em>组A</em>下定义的<em>样式</em> ，即<em>样式A</em>而不是<em>组B中的</em> <em>样式</em> 。<br>如果说明符在扩展页面的<code>General</code>选项卡中定义：</p>
		<ul>
			<li>
				<code>Label Expression</code> ， <code>Domain Class</code> ， <code>Semantic Candidate Expression</code>或<code>Precondition Expression</code> ，这些值将<strong>覆盖</strong>扩展描述中定义的值。值得注意的是，表达式是在当前扩展元素的上下文中进行计算的，就像您从“ <code>General</code>选项卡中定义了表达式一样。
			</li>
			<li>
				<code>Groups</code>将<strong>聚合</strong>到引用<code>Page</code>定义的组。
			</li>
			<li>
				<code>Page Validations</code>将<strong>聚合</strong>到引用的<code>Page Description</code>定义的验证。
			</li>
			<li>对于包含的情况，例如<code>Group</code>包含的<code>Text</code> ，包含的元素由扩展描述继承。
			</li>
		</ul>
		<p id="filters">
			<strong>过滤表达式。</strong> 根据元素种类存在不同的过滤器。这些过滤器用于<strong>过滤</strong>哪些继承元素可见。<em>Filter表达式</em>在语义元素的上下文中计算，并且应该返回boolean：true，继承的元素是可见的，false是过滤的。
			<br>如果未指定表达式，则所有继承的元素都将可见。
			<br>对于每个<em>Filter表达式</em> ，都有一个变量可用于表示可以过滤的元素。可以通过一直返回<code>false</code>来过滤所有继承的元素。在这种情况下，在当前描述下定义的元素将<strong>覆盖</strong>扩展描述中定义的元素。
			<br>例如，如果<em>页面A</em>扩展另一个<em>页面B</em> ，则“ <code>Extends</code>选项卡允许定义：</p>
		<ul>
			<li><code>Filter Groups Expression</code>用于<strong>过滤</strong>页面下可见的继承组。<code>groupDescription</code>变量可用于检查是否必须过滤组。
			</li>
			<li><code>Filter Validation Rules Expression</code>用于<strong>过滤</strong>页面下使用的继承验证规则。<code>validationRuleDescription</code>变量可用于检查是否必须过滤规则。
			</li>
		</ul>
		<p>如果某个元素被许多覆盖定义覆盖，则应用规范中遇到的第一个元素。</p>
		<h2 id="extension_points">扩展点</h2>
		<h3 id="advanced_custom_widgets_extension_points">高级自定义窗口小部件的扩展点</h3>
		<p>集成和高级自定义小部件实现需要扩展几个扩展点：</p>
		<ul>
			<li>
				<code>org.eclipse.emf.edit.childCreationExtenders</code> ：为窗口小部件的自定义配置DSL生成元模型时，请确保正确配置EMF的<code>childCreationExtenders</code>机制，以便Sirus VSM编辑器将看到您的自定义窗口小部件类型并允许它们在<em>新的</em>上下文菜单。
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.descriptionConverter</code> ：此扩展点允许您参与将Sirius端VSM模型转换为EEF DSL。使用此机制，您可以为EEF运行时转换您在Sirius Properties DSL中提供的新元素。</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.descriptionLinkResolver</code> ：如果转换模型需要一些转换后步骤来执行全局链接解析，则可能需要此扩展点作为<code>descriptionConverter</code>补充。
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.descriptionPreprocessor</code> ：此扩展点允许您参与将具有<a href="#extensibility_features">可扩展性</a>的Sirius端VSM模型的预处理转换为<em>扁平的</em> Sirius端VSM模型。
			</li>
		</ul>
		<p>有关更多详细信息，请参阅每个文档。以及有关如何实际实现自己的高级自定义小部件的完整详细信息<a href="../../developer/extensions-properties_provide_custom_widget_advanced.html">的参考文档</a> 。
		</p>
		<h3 id="tab_filtering">标签过滤</h3>
		<p>Sirius内部用于呈现属性视图的EEF运行时具有对过滤属性选项卡的编程支持，您可能希望在上下文中隐藏这些选项卡。例如，如果您提供在Sirius中动态定义的替代版本，您可能希望过滤掉一些静态定义的旧选项卡。</p>
		<p>此功能目前尚未通过Sirius VSM公开，但您仍可以通过实现<code>org.eclipse.eef.properties.ui.api.来使用它<code>org.eclipse.eef.properties.ui.api.IEEFTabDescriptorFilter</code>接口，并在EEF中定义的<code>org.eclipse.eef.properties.ui.eefTabDescriptorFilter</code>扩展点中注册您的实现。</p>
		<p>该接口定义了一个方法<code>boolean filter(IEEFTabDescriptor tabDescriptor)</code> ，该<code>boolean filter(IEEFTabDescriptor tabDescriptor)</code>将被调用以显示每个候选选项卡。如果注册的<code>IEEFTabDescriptorFilter</code>中至少有一个指示应过滤选项卡，则不会显示该选项卡。
		</p>
		<p>有关更多详细信息，请参阅EEF扩展点文档。</p>
	</body>
</html>