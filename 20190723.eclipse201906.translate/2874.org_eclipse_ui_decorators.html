<html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>装饰</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">装饰</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.decorators<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>2.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于将装饰器添加到订阅装饰器管理器的视图。从2.1开始，有一个轻量级装饰器的概念，它将处理装饰器的图像管理。也可以声明一个轻量级的装饰器，它在启用时只需覆盖一个图标，不需要插件的实现。<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.decorator">装饰</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.decorator">装饰器</a> （ <a href="#e.description">描述</a> ？， <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST装饰</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">objectClass CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">适应性（真|假）</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">轻量级（true | false）</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">位置（TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT | UNDERLAY | REPLACE）&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 将用于标识此装饰器的唯一名称。</li>
<li><b>label</b> - 将在工作台窗口菜单中用于表示此装饰器的可翻译名称。</li>
<li><b>class</b> - 实现<samp>org.eclipse.jface.viewers的类的完全限定名称<samp>。ILabelDecorator</samp>如果<b><i>轻量级</i></b>为false或<samp>org.eclipse.jface.viewers。如果轻量级为true， 则为ILightweightLabelDecorator</samp> 。默认值为false。如果没有<b><i>类</i></b>元素，则假定它是轻量级的。在没有装饰器类的情况下，这被认为是声明性的。当使用<code>IDecoratorManager#update()</code>更改这些值时，需要显式更新具有基于会话属性，持久属性或项目描述值（如性质）的启用的声明式装饰器。
<br>如果标签装饰器为装饰创建图像描述符，则必须确保将相同的实例用于相同的装饰对象，或者使用相应地实现<code>#equals</code>和<code>#hashCode</code>的图像描述符实现。</li>
<li><i style="color:red">不推荐使用的</i> <b>objectClass</b> - 将应用此装饰器的类的完全限定名称。在2.1中弃用。将此值作为启用的一部分。</li>
<li><b>adaptable</b> - 一个标志，指示可以适应除objectClass之外的对象的类型是否应使用此对象贡献。对于非轻量级装饰器，如果objectClass适应IResource，则此标志仅具有效果。对于轻量级装饰器，只要通过适配器管理器定义适应性，就支持对任何objectClass的适应性（请参阅类org.eclipse.runtime。IAdapterManager）。默认值为false。</li>
<li><b>state</b> - 一个标志，指示装饰器是否默认打开。默认值为false。</li>
<li><b>轻量级</b> - 轻量级标志表示装饰器是声明式的或实现<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。</li>
<li><b>icon</b> - 如果装饰器是<b><i>轻量级的</i></b>并且未指定<b><i>类，</i></b>则这是要应用的叠加图像的路径</li>
<li><b>location</b> - 如果装饰器是<b><i>轻量级的，</i></b>这是应用装饰器的位置。默认为BOTTOM_RIGHT。在3.4中添加了一个新的可能值REPLACE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！元素<a name="e.description">描述</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个可选的子元素，其主体应包含提供装饰器简短描述的文本。这将显示在Decorators首选项页面中，因此建议包含此选项。默认值为空String。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是装饰器的示例：<p>一个完整的装饰。插件开发人员必须处理自己的图像支持。
</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。DecoratorContributor“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>


<p>轻量级装饰。有一个具体的类，但由于它是一个ILightweightLabelDecorator，它只需要提供文本和ImageDescriptor，因此不需要资源处理。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。LightweightDecoratorContributor“</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p>一个声明性的轻量级装饰器。没有具体的类，因此它提供了一个图标和一个象限来应用该图标。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.declarative.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Declarative Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“ icons / full / declarative.png“</span> <span class="code SchemaTag">location =</span> <span class="code SchemaCstring">”TOP_LEFT“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>class</samp>属性的值必须是实现<samp>org.eclipse.jface.viewers的类的完全限定名<samp>。ILabelDecorator</samp> （如果轻量级为false）或<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。声明性装饰器不需要任何插件激活，应尽可能使用。非轻量级装饰器最终将被弃用。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>插件可以使用此扩展点来添加要应用于使用装饰器管理器作为其标签装饰器的视图的新装饰器。要使用装饰器管理器，请使用IViewPart.getDecoratorManager（）的结果作为DecoratingLabelProvider实例的装饰器。资源导航器目前正在使用它。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2014 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html>