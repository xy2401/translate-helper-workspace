<html  xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Architecture_Overview</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css">
		<link type="text/css" rel="stylesheet" href="../resources/custom.css">
	</head>
	<body >
		<h1 id="SiriusArchitectureOverview">Sirius建筑概述</h1>
		<p>Sirius是一个为任何领域开发和使用图形模型编辑器的平台。它基于Eclipse平台，特别是基于EMF的Eclipse Modeling堆栈。 Sirius平台本身与域无关，因为只要可以使用EMF进行描述，它就可以用于为任何业务域创建建模器。<br>Sirius有两类用户：</p>
		<ol>
			<li> 
				<strong>架构师</strong>使用Sirius为其特定的业务领域开发建模者，前提是他们使用EMF的Ecore定义了他们的域。
			</li>
			<li>
				<strong>最终用户</strong>使用生成的建模器来创建，查看，编辑和一般操纵其域的实际业务模型。
			</li>
		</ol>
		<p>Sirius的一般架构如下图所示，反映了这种分裂：</p>
		<img border="0" src="images/Sirius_High-Level_Architecture_Overview.png"> 
		<p>在Eclipse和EMF之上，Sirius由两个主要部分组成。</p>
		<p>Sirius <strong>工具</strong> （在图的右侧）是建筑师使用的部件。它提供了一个环境，可以在其中指定要为最终用户提供的建模者。该规范通过配置<em>描述模型</em>以声明方式完成。对于每个建模者，架构师必须在描述模型中指定：</p>
		<ol>
			<li>
				<em>什么</em>在建模器中表示，即域模型的哪些元素应该是可见的;</li>
			<li>这些元素应该如何<em>看</em> ，即视觉样式信息;</li>
			<li>这些元素应该如何<em>表现</em> ，即最终用户可以使用哪些工具和交互模式来修改业务模型，以及每个工具的行为方式。
			</li>
		</ol>
		<p>Sirius Tooling为建筑师提供了一个完整，易用的环境来创建这些规范。结果是一组（一组） <em>描述模型</em> ，可选地带有一些附带的Java代码，可以部署为普通的Eclipse插件。
		</p>
		<p>Sirius <strong>运行时</strong> （在图的左侧）是最终用户使用的部分，以及由架构师生成的建模器定义。最终用户不需要Sirius工具就可以使用基于Sirius的建模器。运行时负责<em>解释</em>建模器描述模型并向用户呈现看起来和表现如描述中所指定的实际建模器。
			<br>为此，运行时使用<em>表示模型</em> （和相应的元模型），它根据建模者规范中配置的内容描述最终用户业务模型的具体表示（即哪些具体业务元素是代表，以及他们如何看待）。这些表示模型由Sirius运行时使用刷新算法生成，该算法使用建模器定义中定义的规则生成业务数据到表示域的“投影”。
			<br>然后，表示模型在<em>图形编辑器中</em>显示给最终用户，并集成到Eclipse工作台中。通过编辑器，最终用户可以根据建模师规范中架构师定义的规则来可视化他的业务模型。最终用户还<em>可以</em>与所表示的模型<em>进行交互</em> ，但仅限于架构师配置的方式。当用户与编辑器中的表示交互时，一些交互（例如，拖放和图上的元素）可以触发架构师定义的行为，这将以与业务规则一致的方式修改基础业务模型。每当修改业务模型时，Sirius都会重新启动刷新算法，该算法是增量的：不是为更新的业务模型的状态创建新的表示模型，而是更新现有模型并仅更改需要它的部分。然后，最终用户可以立即在编辑器中看到他的更改的效果。
		</p>
		<p>
			<img border="0" src="images/Sirius_Representation_Refresh-Sync.png">
		</p>
		<p>刷新算法的一个重要特性是它们不仅在业务模型的变化方面是增量的，而且在建模器描述模型本身的变化方面也是增量的。这就产生了Sirius最重要和最显着的特征之一：支持建筑师对建模者的动态和增量开发，并提供实时反馈。在实践中，这意味着当架构师正在开发新的建模器定义（或更改现有的定义器）时，他可以同时打开建模器的定义（使用Sirius工具），并且还可以打开示例表示，并且每当他更改建模者的定义并保存它，更新的定义由运行时自动拾取并通过发出刷新立即考虑。</p>
		<p>除了<em>运行时</em>与<em>工具</em>拆分之外，Sirius架构还将平台的核心部分与特定于<em>方言的扩展</em>分开，后者独立于任何特定类型的表示。处理特定类型表示的每种方言都建立在核心架构之上。例如，默认情况下，Sirius支持三种不同的方言：图表，表格和树。使用Sirius核心部件公开的公共API，其他方可以实现更多方言。
			<br>每种方言都为核心中的架构元素提供了自己的特定扩展：</p>
		<ol>
			<li>表示元模型用方言自己的概念扩展。例如，图表可以在这些节点之间具有节点和连接。</li>
			<li>扩展核心描述元模型以支持这些特定概念的定义。然后必须扩展工具环境以允许架构师指定这些新概念（通常，这部分主要可以从描述元模型的结构推断出并因此自动生成）。</li>
			<li>每种方言都必须提供自己的刷新算法（尽管Sirius核心提供了一些通用代码来促进这一点）。</li>
			<li>最后，每个方言必须实现用于向最终用户呈现其表示的编辑器，并允许它们与它们进行交互。这是方言利用其他框架和技术的地方，例如GMF，用于渲染图表。</li>
		</ol>
		<p>本文档中描述的Sirius体系结构具有以下重要属性：</p>
		<ul>
			<li>工具与运行时分离：最终用户的运行时间更小（更多），没有UI“污染”特定于架构师的概念;运行时并不关心建模器定义的产生方式：使用标准工具，使用完全独立开发的替代工具，由程序生成......唯一的要求是生成的定义符合元模型。</li>
			<li>将核心与方言特定部分分离：将某些方言所需的技术依赖性从核心中分离出来;允许安装仅包含所有支持方言的子集;扩展;通过使标准方言成为核心的普通客户，使我们对我们的API“诚实”：标准方言不（或至少不应）拥有对外部开发的方言无法访问的核心功能的特权访问;核心仍然提供了共享常见抽象和代码的好地方，这导致方言中的代码更少，更好的集成以及跨不同类型的表示的更均匀的最终用户体验。</li>
		</ul>
	</body>
</html>