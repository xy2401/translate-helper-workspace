<html lang="zh-Hans" >
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>新的和值得注意的</title>
<link rel="stylesheet" href="asset?aid=0">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="article" >
<div id="header">
<h1>新的和值得注意的</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>此页面包含有关VIATRA各种版本的详细信息，包括各种版本之间的主要新功能和迁移说明。</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#viatra-22">VIATRA 2.2</a></li>
<li><a href="#viatra-21">VIATRA 2.1</a></li>
<li><a href="#viatra-20">VIATRA 2.0</a></li>
<li><a href="#viatra-17">VIATRA 1.7</a></li>
<li><a href="#viatra-16">VIATRA 1.6</a></li>
<li><a href="#viatra-15">VIATRA 1.5</a></li>
<li><a href="#viatra-14">VIATRA 1.4</a></li>
<li><a href="#viatra-13">VIATRA 1.3</a></li>
<li><a href="#viatra-12">VIATRA 1.2</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-22"><a class="link" href="#viatra-22">VIATRA 2.2</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2019年6月19日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/2.2.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/2.2.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_new_and_noteworthy"><a class="link" href="#_new_and_noteworthy">新的和值得注意的</a></h3>
<div class="sect3">
<h4 id="_license_change_to_epl_v2_0"><a class="link" href="#_license_change_to_epl_v2_0">许可证更改为EPL v2.0</a></h4>
<div class="paragraph">
<p>从2.2版开始，VIATRA将使用EPL v2.0作为其许可。有关此更改的详细信息，请参阅<a href="https://www.eclipse.org/legal/epl-2.0/" class="bare">https://www.eclipse.org/legal/epl-2.0/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_code_mining_in_query_editor"><a class="link" href="#_code_mining_in_query_editor">查询编辑器中的代码挖掘</a></h4>
<div class="paragraph">
<p>VIATRA 2.2引入了一组代码挖掘，以提供有关已开发模式的额外内联信息。目前，启用了两个信息源：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/22_codemining.png" alt="代码挖掘在行动中" width="605" height="144">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>如果缺少，则显示推断的参数类型。仍然建议始终指定参数类型（例如，使用适当的快速修复程序来生成它们），但显示缺失的值可能仍然有用。</p>
</li>
<li>
<p>在模式调用的情况下，还会显示被调用参数的名称，从而更容易理解更复杂的调用，尤其是具有未命名变量的调用。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/22_codemining_prefs.png" alt="用于启用代码挖掘的首选项页面" width="624" height="266">
</div>
</div>
<div class="paragraph">
<p>代码挖掘仅在使用Eclipse Photon或更新版本时可用;但是，对于2.2版本，我们认为代码挖掘是实验性的：在未来版本中，我们可能会在提供挖掘时更新，无论是性能还是可用性问题。由于这个原因，默认情况下关闭代码挖掘;如果感兴趣，可以使用适当的偏好设置打开它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="_easier_parameter_creation_in_query_editor"><a class="link" href="#_easier_parameter_creation_in_query_editor">查询编辑器中更容易创建参数</a></h4>
<div class="paragraph">
<p>为了简化以前创建的模式的修改，编辑器可以通过适当的内容辅助和基于快速修复的增强功能轻松地将现有的局部变量转换为参数。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/22_add_parameter.png" alt="一次性变量的快速修复支持添加参数" width="614" height="126">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/22_ca_parameter.png" alt="内容辅助为参数提供现有变量" width="507" height="83">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_batch_transformation_api_refresh"><a class="link" href="#_batch_transformation_api_refresh">批量转换API刷新</a></h4>
<div class="paragraph">
<p>批量转换API已更新，以便为几乎完全由数据依赖性控制的转换提供更好的支持。这些转换的控制流程通常是微不足道的 - 规则是逐个执行的，直到没有更多匹配为止。此行为与事件驱动的转换非常相似，主要区别在于这些转换不会对基础模型中的更改执行，而是手动触发。</p>
</div>
<div class="paragraph">
<p>API收到了多个小的增强功能来支持这种转换：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>引入了新的语句变体，可以处理转换组或转换的所有规则。</p>
</li>
<li>
<p>添加了一个新的语句类型<code>hasCurrent</code> ，它返回是否可以触发一组给定的规则。</p>
</li>
<li>
<p>更新了规则过滤器的处理，以处理可由转换语句覆盖的默认过滤器。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_2_2"><a class="link" href="#_migrating_to_viatra_2_2">迁移到VIATRA 2.2</a></h3>
<div class="sect3">
<h4 id="_batch_transformation_api"><a class="link" href="#_batch_transformation_api">批量转换API</a></h4>
<div class="paragraph">
<p>在2.2版之前，错误地忽略了批转换规则的过滤器设置，并且仅考虑了在语句中定义的过滤器。在2.2版中，过滤器按以下方式处理：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果转换规则和语句都没有定义过滤器，则会考虑模式的所有匹配项。</p>
</li>
<li>
<p>如果转换规则或语句定义过滤器（但不是两者），则使用该过滤器。</p>
</li>
<li>
<p>如果转换规则和语句都定义了过滤器，则语句定义的过滤器将覆盖默认过滤器。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当定义转换规则过滤器但使用无过滤语句时，此行为可能会更改现有转换的行为：在这种情况下，将应用默认规则过滤器。在这种情况下，应删除不必要的默认过滤器;或者，如果需要，可以使用新过滤器在激活规则时覆盖默认过滤器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_api_break_in_the_query_test_framework"><a class="link" href="#_api_break_in_the_query_test_framework">查询测试框架中的API中断</a></h4>
<div class="paragraph">
<p>在2.2版之前，主测试类<code>ViatraQueryTest</code>有一个字段<code>accessMap</code>用于存储普通Java类型到其处理程序对象的映射，以便创建快照。在2.2版中，鼓励提供此序列化信息和进一步序列化信息的方式是单个<code>SnapshotHelper</code>实例的形式，在创建测试用例的同时进行初始化。</p>
</div>
<div class="paragraph">
<p><strong>细节</strong> ：字段<code>accessMap</code>和API方法<code>withClasses</code>用于更新映射已被删除。相反，可以（并且应该）在调用第一个方法<code>test</code>提供SnapshotHelper，以进行测试用例初始化。因此， <code>test</code>现在有一个新的签名，它接受一个SnapshotHelper实例。例如，在测试用例初始化时，通常可以在现场创建一个帮助程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">ViatraQueryTest.test(SomeQuerySpecification.instance, new SnapshotHelper(accessMap, customEMFSerializerMap))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-21"><a class="link" href="#viatra-21">VIATRA 2.1</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2018年12月19日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/2.1.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/2.1.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_new_and_noteworthy_2"><a class="link" href="#_new_and_noteworthy_2">新的和值得注意的</a></h3>
<div class="sect3">
<h4 id="_graphical_query_editor"><a class="link" href="#_graphical_query_editor">图形查询编辑器</a></h4>
<div class="paragraph">
<p>VIATRA 2.1包含一个基于Sirius的模型查询的实验图形编辑器。由图形编辑器创建的查询将转换为现有的文本语法，然后使用现有的运行时和IDE功能进行处理。有关详细信息，请参阅<a href="graphical-queries.html">文档页面</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_other_language_features"><a class="link" href="#_other_language_features">其他语言功能</a></h4>
<div class="paragraph">
<p>缺少变量类型的严重性增加到警告。这种变化的原因是明确声明参数类型有助于提高模式的可读性，并在类型错误的情况下帮助精确的错误定位。但是，为避免破坏现有模式声明，此类缺失类型不会被视为错误。但是，在将来的版本中，此类缺失声明可能被视为错误，因此建议添加缺少的声明（例如，使用适当的快速修复功能）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_updated_headless_pattern_parser"><a class="link" href="#_updated_headless_pattern_parser">更新了无头模式分析器</a></h4>
<div class="paragraph">
<p>VIATRA的无头模式解析器组件已更新，能够维护一组可更新的查询规范，对于在更新查询的建模工具中集成自定义查询评估功能非常有用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_2_1"><a class="link" href="#_migrating_to_viatra_2_1">迁移到VIATRA 2.1</a></h3>
<div class="sect3">
<h4 id="_conflict_resolution_between_transformation_rules"><a class="link" href="#_conflict_resolution_between_transformation_rules">转换规则之间的冲突解决</a></h4>
<div class="paragraph">
<p>InvertedDisappearancePriorityConflictResolver中的默认规则优先级在版本2.1中从0更改为1。这种变化的动机是，在0优先级的情况下，添加和删除将具有与解析器的目标相反的优先级。</p>
</div>
<div class="paragraph">
<p>这是一个突破性的变化，因为使用优先级'0'和'1'的转换可能会改变它们的内部行为。为避免这种情况，建议不要对此冲突解决程序使用优先级“0”。</p>
</div>
</div>
<div class="sect3">
<h4 id="_updated_transformation_rule_creation"><a class="link" href="#_updated_transformation_rule_creation">更新了转换规则创建</a></h4>
<div class="paragraph">
<p>在2.1版之前，BatchTransformationRuleFactory和EventDrivenTransformationRuleFactory类的<code>createRule</code>方法是无参数的，并且在<code>precondition</code>方法中提供了查询规范。当使用具有高级类型推断的基于JVM的语言（例如Xtend或Kotlin）来编写转换时，这很好用，但是当用Java创建转换时，它变得很麻烦，因为需要某些类型转换来正确初始化规则。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，创建了新的<code>createRule</code>方法，期望将查询规范输入作为参数，从而替换旧的<code>createRule</code>和<code>precondition</code>方法。为了合并此API，旧呼叫被标记为已弃用，但仍可在VIATRA 2.1中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_changed_hybridization_behaviour_in_the_local_search_query_backend"><a class="link" href="#_changed_hybridization_behaviour_in_the_local_search_query_backend">在本地搜索查询后端中更改了杂交行为</a></h4>
<div class="paragraph">
<p>为了使行为更具可预测性，本地搜索查询引擎的默认配置不再允许混合模式匹配与模式调用之间的增量查询后端相结合，即，如果使用LS计算调用者模式，则在此期间调用者模式也是如此匹配器调用。要启用混合匹配，本地搜索后端可以从增量后端请求调用模式的结果（如果被调用者被声明为<code>incremental pattern</code> ），请使用显式启用此配置的配置，例如<code>LocalSearchHints.getDefaultGenericHybrid()</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_query_runtime_ui_project_introduced"><a class="link" href="#_query_runtime_ui_project_introduced">查询运行时UI项目介绍</a></h4>
<div class="paragraph">
<p>为了支持在没有工具依赖性的情况下重用模型连接器，IModelConnector接口及其所有用途已移至新的<code>org.eclipse.viatra.query.runtime.ui</code>插件，并已相应地重命名。VIATRA提供的所有适配器都已更新，以提供新接口，少数现有用户应该请求<code>org.eclipse.viatra.query.runtime.ui.modelconnector.实例<code>org.eclipse.viatra.query.runtime.ui.modelconnector.而是IModelConnector</code> 。新实现的行为方式与以前完全相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_facet_editor_integration_removed"><a class="link" href="#_facet_editor_integration_removed">删除了Facet Editor集成</a></h4>
<div class="paragraph">
<p>VIATRA包含了几年的组件，以确保我们的IDE功能（如查询结果视图）与Facet编辑器配合使用，最初由EMF Facet项目提供，而不是后来的MoDisco项目。鉴于这些编辑器仅被谨慎使用，并且MoDisco离开同时发布，我们已决定不再支持此编辑器。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-20"><a class="link" href="#viatra-20">VIATRA 2.0</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2018年6月27日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/2.0.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/2.0.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_new_and_noteworthy_3"><a class="link" href="#_new_and_noteworthy_3">新的和值得注意的</a></h3>
<div class="sect3">
<h4 id="_new_language_features"><a class="link" href="#_new_language_features">新语言功能</a></h4>
<div class="paragraph">
<p>从版本2.0开始，可以计算给定模式的匹配的传递闭包和自反传递闭包。使用此构造，以下两个模式是等效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">/** Old syntax, using transitive closure and multiple bodies */
pattern superclassOrSelf1(cl : Class, sup : Class) {
  cl == sup;
} or {
  find superclass+(cl, sup);
}

/** New syntax, note the '*' symbol in the find constraint */
pattern superclassOrSelf2(cl : Class, sup : Class) {
  find superclass*(cl, sup);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果被调用模式仅包含单个约束，则另一个新功能是模式调用的简化语法。这对于更容易的否定，传递闭包计算和聚合也很有用。以下示例展示了此功能可用于降低现有模式复杂性的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern simpleNegation(i : Identifiable) {
	Identifiable(i); // not necessary, only added for readability
	neg HostInstance(i);  // note there is no `find` keyword here
}

pattern applicationTypeWithoutHostedInstance(at : ApplicationType, hi : HostInstance) {
	neg HostInstance.applications.type(hi, at);
}

pattern countHostInstances(n : java Integer) {
	n == count HostInstance(_);
}

pattern sumAvailableCPU(n : java Integer) {
	n == sum HostInstance.availableCpu(_, #c);
}

pattern reachableStates(s1 : State, s2 : State) {
	State.outgoingTransitions.targetState*(s1, s2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>VIATRA 2.0还引入了一个新的聚合器，用于计算模式匹配中找到的数字的平均值。例如，以下模式可用于计算一组实例上的平均CPU值数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern avgCPU(n : java Double) {
    n == avg find availableCPU(_, #v);
}

private pattern availableCPU(host : HostInstance, value : java Integer) {
	HostInstance.availableCpu(host, value);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_query_editing"><a class="link" href="#_query_editing">查询编辑</a></h4>
<div class="paragraph">
<p>在VIATRA 2.0中增强了悬浮式帮助支持，具体来说，现在很多元素都显示悬浮，而之前没有，包括EClass和EReference类型和变量引用。此外，现在计算这些悬停应该更有效，从而在大量模式和/或复杂元模型层次结构的情况下产生更好的性能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/20_hover_eclass.png" alt="将鼠标悬停在EClass上" width="429" height="207">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/20_hover_ereference.png" alt="将鼠标悬停在EReferences上" width="568" height="271">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/20_hover_varref.png" alt="悬停在变量引用上" width="670" height="129">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_updated_pattern_matcher_api"><a class="link" href="#_updated_pattern_matcher_api">更新了模式匹配器API</a></h4>
<div class="paragraph">
<p>模式匹配器API已更新，以依赖Java 8功能，如Streams和Optionals。这允许模式匹配的功能样式处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String applicationIdentifiers = ApplicationTypesMatcher.on(engine)
        .streamAllMatches()
        .map(ApplicationTypesMatch::getAT)
        // Calculate the identifier
        .map(ApplicationType::getIdentifier)
        //Provide a comma separated string of identifiers
        .collect(Collectors.joining(", "));</code></pre>
</div>
</div>
<div class="paragraph">
<p>VIATRA查询引擎还支持设置默认的基于搜索的后端实例和默认缓存后端实例，从而允许进一步自定义引擎的运行时行为。通过以前使用的<code>ViatraQueryEngineOptions</code>类可以使用新功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="_improved_ui_support_for_recursive_query_evaluation"><a class="link" href="#_improved_ui_support_for_recursive_query_evaluation">改进了对递归查询评估的UI支持</a></h4>
<div class="paragraph">
<p>对于想要通过查询结果视图评估<a href="#recursion">递归查询的</a>用户，我们自豪地报告现在可以在UI上选择<a href="#recursion-dred">删除和重新启动（DRED）</a>评估模式（特别是VIATRA查询资源管理器的首选项页面）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_p2_repository_structure_update"><a class="link" href="#_p2_repository_structure_update">p2存储库结构更新</a></h4>
<div class="paragraph">
<p>删除此版本中的各种功能使我们重新考虑了我们的p2存储库的内容。以前我们使用了一个包含所有版本的复合存储库，但从版本2.0中删除的功能在其早期版本中显示可能令人困惑。为了更好地处理这种情况（以及更好的性能），我们引入了<code>/latest</code> p2存储库，并简化了分类。</p>
</div>
<div class="paragraph">
<p>关于这些更改， <a href="http://eclipse.org/viatra/download.html">下载页面</a>也已更新。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_2_0"><a class="link" href="#_migrating_to_viatra_2_0">迁移到VIATRA 2.0</a></h3>
<div class="sect3">
<h4 id="_dependency_updates"><a class="link" href="#_dependency_updates">依赖关系更新</a></h4>
<div class="paragraph">
<p>VIATRA 2.0更新了其依赖项的最低要求版本。这允许清理一些代码，但可能需要更新目标要求。最重要的更新：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>最低Java版本：Java 8（以前需要Java 7）</p>
</li>
<li>
<p>最低Eclipse平台版本：4.5  -  Mars（以前版本3.7  - 使用Indigo）</p>
</li>
<li>
<p>最小Xtext版本：2.12（以前版本2.9使用）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_code_generator_updates"><a class="link" href="#_code_generator_updates">代码生成器更新</a></h4>
<div class="paragraph">
<p>在VIATRA 2.0中，更新了查询代码生成器的默认行为以减少生成的文件数。这意味着，不会生成<code>.util</code>包，匹配和匹配器代码将作为嵌入式子类生成，并且不再生成匹配处理器。</p>
</div>
<div class="paragraph">
<p>如有必要，可以依靠VQL编译器设置来设置旧的生成器行为。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/17_viatra_compiler.png" alt="17 viatra编译器">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deprecated_code_removal"><a class="link" href="#_deprecated_code_removal">不推荐使用的代码删除</a></h4>
<div class="paragraph">
<p>标记为已弃用的所有代码都已从代码库中删除。另外，除去了其他组分</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CEP已被删除</p>
</li>
<li>
<p>Xcore集成已被删除</p>
</li>
<li>
<p>已删除C ++本地搜索实现</p>
</li>
<li>
<p>已删除示例查询</p>
</li>
<li>
<p>EVM-JDT集成已被删除</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_emf_independent_pattern_language_project"><a class="link" href="#_removal_of_emf_independent_pattern_language_project">删除EMF独立模式语言项目</a></h4>
<div class="paragraph">
<p>VIATRA 2.0删除了对不依赖EMF元模型但保留VQL语言结构的查询语言的支持。根本不使用此功能，但会显着增加语言维护成本。VIATRA框架的大多数用户根本不应受到影响，但下面列出了所有相关的API更改。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>项目<code>org.eclipse.viatra.patternlanguage</code> ， <code>org.eclipse.viatra.patternlanguage.ui</code>和<code>org.eclipse.viatra.patternlanguage.tests</code>分别与他们的EMF特定对应项合并，分别是<code>org.eclipse.viatra.patternlanguage.emf</code> ， <code>org.eclipse.viatra.patternlanguage.emf.ui</code>和<code>org.eclipse.viatra.patternlanguage.emf.tests</code> 。</p>
</li>
<li>
<p>表示AST的EMF模型已合并为一个简单的EMF模型，并转移到一个新的包：</p>
</li>
<li>
<p>元模型可以使用nsURI <code><a href="http://www.eclipse.org/viatra/query/patternlanguage/emf/PatternLanguage" class="bare">http://www.eclipse.org/viatra/query/patternlanguage/emf/PatternLanguage</a></code></p>
</li>
<li>
<p>所有生成的类都可以从<code>org.eclipse.viatra.query.patternlanguage.emf.vql</code>包中获得。</p>
</li>
<li>
<p>生成的类结构与以前的版本相同。</p>
</li>
<li>
<p>扩展名<code>org.eclipse.viatra.patternlanguage.annotations</code>和<code>org.eclipse.viatra.patternlanguage.whitelist</code>被移入了patternlanguage.emf项目，因此它的ID被更新为<code>org.eclipse.viatra.patternlanguage.emf.annotations</code>和<code>org.eclipse.viatra.patternlanguage.emf.whitelist</code>分别是<code>org.eclipse.viatra.patternlanguage.emf.whitelist</code> 。</p>
</li>
<li>
<p><code>CorePatternLanguageHelper</code>和<code>EMFPatternLanguageHelper</code>类合并为一个共享的<code>PatternLanguageHelper</code>类。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reduction_of_guava_uses"><a class="link" href="#_reduction_of_guava_uses">减少番石榴的使用</a></h4>
<div class="paragraph">
<p>在一些情况下，API中可以看到诸如函数或谓词之类的Guava类型。在VIATRA 2.0中，删除了简单的方法调用（通过直接方法引用处理），而其余的调用则替换为Java 8标准库中内置的替代方法。以下类别和方法受到影响：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PQueries#parameterDirectionPredicate</code> ：返回Java 8谓词</p>
</li>
<li>
<p><code>PQueries#queryNameFunction</code> ：可以用<code>PQuery::getFullyQualifiedName</code>的方法引用<code>PQuery::getFullyQualifiedName</code></p>
</li>
<li>
<p><code>PQueries#parameterNameFunction</code> ：可以用<code>PParameter::getName</code>的方法引用替换</p>
</li>
<li>
<p><code>PQueries#queryOfReferenceFunction</code> ：可以用<code>IQueryReference::getReferredQuery</code>的方法引用替换</p>
</li>
<li>
<p><code>PQueries#directlyReferencedQueriesFunction</code> ：返回Java 8函数</p>
</li>
<li>
<p><code>PQueries#queryStatusPredicate</code> ：返回Java 8谓词</p>
</li>
<li>
<p><code>CorePatternLanguageHelper#getReferencedPatternsTransitive</code>接受Java 8谓词作为参数</p>
</li>
<li>
<p><code>ConflictSetIterator</code>接受Java 8谓词作为构造函数参数</p>
</li>
<li>
<p><code>BatchTransformationStatements#fireUntil</code>接受Java 8谓词作为条件</p>
</li>
<li>
<p><code>RecordingJob</code>不再记录表中所有创建的命令;如果要访问创建的命令，则应使用新的命令记录器实例初始化RecordingJob，该实例将在执行后通知每个命令</p>
</li>
<li>
<p><code>QueryResultMultimap</code>和<code>EVMBasedQueryResultMultimap</code>类为查询匹配提供了Multimap接口;鉴于这些年来它们的用途有限，只是被删除了。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_unnecessary_xtend_library_dependencies"><a class="link" href="#_removal_of_unnecessary_xtend_library_dependencies">删除不必要的Xtend库依赖项</a></h4>
<div class="paragraph">
<p>转换API使用Xtend标准库中的<code>Pair</code>类来依赖<code>→</code> （映射到）运算符来定义基于名称映射的过滤器。在2.0版中，底层代码已更改为依赖于<code>Map.Java标准库中的Entry</code>类。</p>
</div>
<div class="paragraph">
<p>以下方法受此更改影响：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MatchParameterFilter</code>接受一个Map Entries数组而不是Xtend Pairs</p>
</li>
<li>
<p><code>BatchTransformationStatements</code>接受一个Map Entries数组而不是Xtend Pairs作为各种方法的参数</p>
</li>
<li>
<p><code>EventDrivenTransformationBuilder#filter</code>接受一组Map Entries而不是Xtend Pairs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要迁移代码，您可以执行以下操作之一：</p>
</div>
<div class="paragraph">
<p><strong>如果您正在使用Xtend代码，并且<code>"name" → value</code>语法不再编译，请在标头中添加以下import声明： <code>import static extension org.eclipse.viatra.transformation.runtime.emf.transformation.TransformationExtensions。</code></strong>*如果您没有使用Xtend，或者您不想依赖映射到运算符，只需使用调用<code>new SimpleEntry&lt;&gt;("name", value)</code>来实例化这些条目。</p>
</div>
</div>
<div class="sect3">
<h4 id="_null_parameters_and_return_values"><a class="link" href="#_null_parameters_and_return_values">空参数和返回值</a></h4>
<div class="paragraph">
<p>如果找不到可能的值，VIATRA中的一些API返回null。鉴于VIATRA 2.0依赖于Java 8，这些API被重新设计为返回<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional</a>值。</p>
</div>
<div class="paragraph">
<p>受影响的方法如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PQueryHeader＃getFirstAnnotationByName</p>
</li>
<li>
<p>CorePatternLanguageHelper＃getFirstAnnotationByName</p>
</li>
<li>
<p>CorePatternLanguageHelper＃getParameterByName</p>
</li>
<li>
<p>ViatraQueryMatcher＃getOneArbitraryMatch</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要返回<code>null</code>值的旧行为，则可以使用<code>Optional.orElse</code>调用，例如<code>query.getFirstAnnotationByName("Constraint").orElse(null);</code></p>
</div>
<div class="paragraph">
<p><code>QueryEvaluationHint</code>类的构造函数已更新：之前它已使用设置<code>Map</code>和可选查询后端（可能为null）进行实例化。从版本2.0开始，构造函数不接受查询后端的null，但提供了另一种构造函数，可以通过新的枚举来选择它，而应该选择默认的后端。<code>ViatraQueryEngineOptions</code>新的搜索和缓存后端设置需要进行此更改。</p>
</div>
</div>
<div class="sect3">
<h4 id="_imatchprocessor_removal"><a class="link" href="#_imatchprocessor_removal">IMatchProcessor删除</a></h4>
<div class="paragraph">
<p>IMatchProcessor接口的所有用法都替换为对<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">Consumer</a>类型的引用。生成的匹配处理器（如果已启用）也会实现Consumer接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling_consolidation"><a class="link" href="#_exception_handling_consolidation">异常处理合并</a></h4>
<div class="paragraph">
<p>在VIATRA 2.0之前，Query组件的各种API抛出了一组不同的已<strong>检查</strong>异常：ViatraQueryException，ViatraBaseException和QueryProcessingException（以及它们的专用版本）。对于2.0版，这些异常以两种方式更新：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>所有这些现在都是运行时异常，因此无需显式捕获它们。这样可以更容易地将查询处理代码放入lambda表达式中，但是，这使得完全由开发人员负责处理这些异常。</p>
</li>
<li>
<p>它们现在都有一个称为ViatraQueryRuntimeException的公共基本异常 - 如果合适，此类可以在catch块中的任何位置使用。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_dependency_updates_in_query_runtime"><a class="link" href="#_dependency_updates_in_query_runtime">查询运行时中的依赖关系更新</a></h4>
<div class="paragraph">
<p>在此版本中，重新组织了<code>org.eclipse.viatra.query.runtime</code>插件的依赖项。对于使用<code>org.eclipse.viatra.query.runtime.feature</code> （在Eclipse环境中）或<code>viatra-query-runtime</code>功能（可从Maven存储库获得）部署查询运行时的用户，这不会导致任何问题，因为它们将部署所有必需的插件。</p>
</div>
<div class="paragraph">
<p>在其他情况下，如果使用特定于后端的代码，则可能需要将<code>org.eclipse.viatra.query.runtime.rete</code>和<code>org.eclipse.viatra.query.runtime.localsearch</code>插件作为附加依赖项添加到开发的代码中;如果需要（例如在非Equinox OSGi环境中），可能需要通过显式添加相应的条目来调用<code>ViatraQueryEngineOptions#setSystemDefaultBackends()</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_api_break_in_transitive_closure_library"><a class="link" href="#_api_break_in_transitive_closure_library">Transitive Closure Library中的API中断</a></h4>
<div class="paragraph">
<p>此API中断更改会影响org.eclipse.viatra.query.runtime.base.itc Java库的用户，以便对自定义图数据源进行增量传递闭包计算。</p>
</div>
<div class="paragraph">
<p><strong>不受影响</strong> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>vql中传递闭包语言元素的用户。</p>
</li>
<li>
<p><code>TransitiveClosureHelper</code>用户提供EMF引用的传递闭包。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>细节</strong> ：我们在内部重写了传递闭包服务的几个算法和数据结构类，以提高内存效率。特别是，我们改变了如何表示多个传入/传出图形边缘的方式，如接口<code>IGraphDataSource</code>和<code>IBiDirectionalGraphDataSource</code> （图形观察者接口未更改）中可见。</p>
</div>
<div class="paragraph">
<p>旧接口（自1.6起）使用了<code>java.util.将顶点Map</code>为键，将正整数表示为并行边的计数值，而在新版本中，多集编码为<code>org.eclipse.viatra.query.runtime.matchers.util.IMemoryView</code> 。为了便于迁移旧客户端和实现者，可以在<code>org.eclipse.viatra.query.runtime.matchers.util.中获得旧表示和新表示之间的转换<code>org.eclipse.viatra.query.runtime.matchers.util.IMemoryView#asMap</code>和<code>org.eclipse.viatra.query.runtime.matchers.util.IMemoryView#fromMap</code> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-17"><a class="link" href="#viatra-17">VIATRA 1.7</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2017年12月13日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.7.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.7.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_optimizations_in_query_runtime"><a class="link" href="#_optimizations_in_query_runtime">查询运行时中的优化</a></h3>
<div class="paragraph">
<p>在VIATRA 1.7期间，查询引擎的内存使用情况以多种方式进行了优化，确保新版本需要高达50％的稳定内存来索引其内容。这种减少主要通过使用<a href="http://eclipse.org/collections">Eclipse Collections</a>框架提供的紧凑集合并创建自定义元组实现来实现。</p>
</div>
<div class="paragraph">
<p>进一步的更改还有助于减少在基于搜索的模式匹配期间创建的临时对象，或通过更智能的前提条件检查在转换中提供更快的响应。</p>
</div>
</div>
<div class="sect2">
<h3 id="_updated_generated_code_structure"><a class="link" href="#_updated_generated_code_structure">更新生成的代码结构</a></h3>
<div class="paragraph">
<p>传统上，VIATRA为每个查询生成四个不同的Java类：（1） <em>查询规范</em>类，（2） <em>匹配</em>类，（3） <em>匹配</em>类和（4） <em>匹配处理器</em>类，每个类都放在一个单独的文件中。对于具有许多模式定义的项目，生成这些文件会变得昂贵。</p>
</div>
<div class="paragraph">
<p>为了减少生成的文件数量，VIATRA 1.7提供了两个新的代码生成选项，它为每个模式只创建一个java文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>生成嵌套类</strong> ：匹配，匹配和匹配处理器类生成为查询规范的嵌套类;查询规范重命名为具有与原始模式相同的限定名称。</p>
</li>
<li>
<p><strong>不生成匹配和匹配器类</strong> ： <strong>不生成</strong>特定于模式的匹配，生成匹配器和匹配处理器类，但重用通用实现。仅在不直接从代码查询查询但仅在VIATRA验证等通用框架中使用查询时，才建议使用此模式。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在VIATRA 1.7中，为了向后兼容，默认情况下将第三个设置称为<strong>Generate</strong> ，使用前一个结构的<strong>单独类</strong> 。对于VIATRA 2.0，计划使用嵌套类作为默认选择。可以在VIATRA查询语言编译器设置中检查此设置（可用作全局Eclipse首选项页面或项目属性页面）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/17_viatra_compiler.png" alt="17 viatra编译器">
</div>
</div>
<div class="paragraph">
<p>此外，如果不使用，则可以禁用特定于模式的匹配处理器的生成。无论是生成嵌套类还是单独类，都会关闭生成。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cps_demonstrator_application"><a class="link" href="#_cps_demonstrator_application">CPS演示器应用程序</a></h3>
<div class="paragraph">
<p>VIATRA 1.7包含一个演示应用程序，可用于查看转换框架的大多数功能。该应用程序包括编辑器中包含的示例项目和转换。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该应用程序可以下载多个平台： <a href="http://download.eclipse.org/viatra/examples/cps/application/org.eclipse.viatra.examples.cps.application.product-win32.win32.x86_64.zip">Windows（64位）</a> ， <a href="http://download.eclipse.org/viatra/examples/cps/application/org.eclipse.viatra.examples.cps.application.product-macosx.cocoa.x86_64.zip">macOS</a> ， <a href="http://download.eclipse.org/viatra/examples/cps/application/org.eclipse.viatra.examples.cps.application.product-linux.gtk.x86_64.zip">Linux（GTK 64位）</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_additional_issues"><a class="link" href="#_additional_issues">其他问题</a></h3>
<div class="paragraph">
<p>有关VIATRA 1.7的已修复问题的完整列表，请参阅<a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.7.0/bugs" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.7.0/bugs</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_1_7"><a class="link" href="#_migrating_to_viatra_1_7">迁移到VIATRA 1.7</a></h3>
<div class="paragraph">
<p>更好的内存使用的原因之一是<a href="http://eclipse.org/collections">Eclipse Collections</a>框架提供的紧凑集合。因此，VIATRA的所有用户都必须在类路径上提供这些类。如果通过Maven或p2管理依赖项，则不需要额外的步骤，因为应该自动处理此传递依赖项。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-16"><a class="link" href="#viatra-16">VIATRA 1.6</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2017年6月28日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.6.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.6.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_model_query_evaluation"><a class="link" href="#_model_query_evaluation">模型查询评估</a></h3>
<div class="paragraph">
<p>VIATRA 1.6提供了一些新功能，旨在更好地兼容更广泛的用例。一般来说，VIATRA应该以与之前相同的方式开箱即用，但是有些设置允许在某些情况下进行更精细的调整。</p>
</div>
<div class="paragraph">
<p>EMF API的自定义实现（例如，当手动修改生成的代码时）可能违反EMF API合同，并发送<strong>不正确的通知</strong> （例如，重复的模型删除事件）;例如，如果存在引发异常的自定义EMF适配器，则会出现类似情况。在以前版本的VIATRA中，这导致从查询后端抛出奇怪的异常。在版本1.6中，模型索引器识别大多数这些情况，并提供更准确的错误消息来描述发生的情况。通过关闭<strong>严格通知模式</strong> ，也可以告诉索引器忽略（更具体地说，仅记录）这些不正确的通知，如下所示。</p>
</div>
<div id="v16-strictnotifications" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">BaseIndexOptions options = new BaseIndexOptions().withStrictNotificationMode(false);
ResourceSet rSet = new ResourceSetImpl();
EMFScope scope = new EMFScope(rSet, options);
ViatraQueryEngine engine = ViatraQueryEngine.on(scope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果查询范围设置为整个模型的子集（例如，资源集中只有一个EMF资源），则引擎范围内的模型元素可能具有指向范围之外的元素的引用;这些被称为<strong>悬空边缘</strong> 。以前版本的VIATRA假设模型是独立的，没有悬垂的边缘;如果模型没有此属性，则未指定查询引擎的行为（可能是不正确的匹配集）。在VIATRA 1.6中，通过添加一个丢弃此假设的新索引器模式来清除此行为，并且（以较低的性能成本）始终将所有索引边的两端都检查为范围内。为避免出现意外，默认情况下会使用新行为，但如有必要，可以通过手动更改相应的基本索引选项来访问旧行为，如下所示。对于新代码，我们建议使用该选项来删除无悬空假设，因为它在很多情况下提供了更一致和直观的结果;在未来的VIATRA版本中，这将是新的默认值。</p>
</div>
<div id="v16-danglingfree" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">BaseIndexOptions options = new BaseIndexOptions().withDanglingFreeAssumption(false);
ResourceSet rSet = new ResourceSetImpl();
EMFScope scope = new EMFScope(rSet, options);
ViatraQueryEngine engine = ViatraQueryEngine.on(scope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>高级查询API现在包含一项功能，允许用户在增量查询后端暂时“关闭”查询结果维护。在这样的代码块期间，仅更新基本模型索引器，查询结果保持陈旧，直到块结束。优点是，当以部分撤消自身的方式更改模型时，可以节省大量执行时间，例如，移除然后重新添加模型的大部分。</p>
</div>
<div id="v16-delay" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AdvancedViatraQueryEngine engine = ...
engine.delayUpdatePropagation(new Callable&lt;Void&gt;() {
    @Override
    public Void call() throws Exception {
        // perform extensive changes in model that largely cancel each other out
        return null;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，VIATRA 1.6包括<a href="http://dl.acm.org/citation.cfm?id=170066">Delete和REDerive（DRed）</a>算法，作为评估递归查询的实验性选择。以前，只有在VQL模式（或模式与其自身）之间存在循环依赖关系的条件下才能完全支持递归查询，但在这些模式的各个匹配之间不存在循环依赖关系。即使所有涉及的模式调用都是正的（简单<code>find</code>约束），这种循环也可能导致更改后的结果维护不正确。现在可以通过启用DRed来放宽此限制。只要所有递归调用都是正的（即，在递归循环中没有否定或聚合），DRed在执行时间中有一个小的惩罚，保证任意递归模式结构的正确结果维护。请注意，对于传递闭包这种非常常见的特殊情况，专用语言元素（传递模式调用）仍然可能更有效。DRed仍处于试验阶段，默认情况下已关闭;可以使用查询评估提示<code>ReteHintOptions.deleteRederiveEvaluation</code>手动启用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_code_generator_updates_2"><a class="link" href="#_code_generator_updates_2">代码生成器更新</a></h3>
<div class="imageblock">
<div class="content">
<img src="./images/releases/16_query_codegen_options.png" alt="16个查询codegen选项">
</div>
</div>
<div class="paragraph">
<p>对于针对除Eclipse插件之外的其他环境的用户，现在可以禁止<strong>更新MANIFEST.MF和plugin.xml</strong>文件。更新捆绑包清单以确保导出包含查询规范的所有包，而查询规范注册表使用plugin.xml文件在运行时加载所有模式。</p>
</div>
<div class="paragraph">
<p>此设置可用作工作区级别首选项或每个项目设置。默认情况下，这些设置已打开（因此每个版本都会更新这两个文件），从而保持与先前版本的兼容性。</p>
</div>
<div class="paragraph">
<p>另一个重大变化涉及<strong>私人模式的处理</strong> 。如果预期私有模式不会在同一个vql文件中的模式调用之外使用，则生成的代码不需要生成所有类型安全的包装器。但是，为了使用查询测试API使私有模式可测试，生成的QuerySpecification类被移动到专用包，如果它们可以公开，而不将它们导出到查询包的所有用户。</p>
</div>
<div class="paragraph">
<p>在Ecore和genmodel文件中描述的复杂元模型中，通常<strong>在</strong>具有绝对或工作空间相对URL的<strong>文件之间</strong>存在<strong>交叉引用</strong> 。使用maven编译器编译VIATRA查询时，无法自动解析这些URL。EMF使用URI转换器来定义此类源和目标模型元素之间的映射。从VIATRA 1.6开始，您现在可以使用<code>uriMappings</code>配置元素指定通过<code>platform:/resource</code> URI引用的元模型的位置。有关详细信息，请参阅<a href="http://wiki.eclipse.org/VIATRA/UserDocumentation/Build#viatra-maven-plugin">此Wiki页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_query_test_framework_updates"><a class="link" href="#_query_test_framework_updates">查询测试框架更新</a></h3>
<div class="imageblock">
<div class="content">
<img src="./images/releases/16_query_coverage_report.png" alt="16个查询覆盖率报告">
</div>
</div>
<div class="paragraph">
<p>VIATRA的查询测试功能得到了扩展，可支持更广泛的模型和查询。这需要测试定义DSL的新自定义选项，包括支持非默认EMF资源作为模型，并在查询结果快照中使用更通用的Java类型。有关这些功能的更详细定义，请<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryTestFramework">参阅文档</a> 。</p>
</div>
<div class="paragraph">
<p>在测试模式时，您可以测量其<strong>测试覆盖率</strong> （类似于EclEmma对Java代码所做的操作）。这意味着您可以在评估查询期间查看模式中描述的哪些约束。可以将报告报告为HTML文件，该文件立即显示哪些模式需要更多测试。有关详细信息，请参阅<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryTestFramework#Coverage_analysis_and_reporting">功能的文档</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_documentation_updates"><a class="link" href="#_documentation_updates">文档更新</a></h3>
<div class="imageblock">
<div class="content">
<img src="./images/releases/16_query_explain_message.png" alt="16查询说明消息">
</div>
</div>
<div class="paragraph">
<p>为了便于开始使用VIATRA，我们添加了一个<a href="http://www.eclipse.org/viatra/documentation/tutorial.html">教程</a> ，它提供了查询和转换开发的示例。为了使该教程可供更多用户使用，此文档也包含在平台帮助中。</p>
</div>
<div class="paragraph">
<p>据报道，查询编辑器中与可枚举和非可枚举引用相关的一些<strong>错误消息</strong>难以理解。在此版本中，错误消息已更新，并且还添加了快速修复程序，以更新消息的详细说明。在未来的版本中，我们计划扩展此支持，以使其他错误消息更容易理解。</p>
</div>
</div>
<div class="sect2">
<h3 id="_gef5_based_visualization"><a class="link" href="#_gef5_based_visualization">基于GEF5的可视化</a></h3>
<div class="imageblock">
<div class="content">
<img src="./images/releases/16_rete_visualizer.png" alt="16 rete visualizer">
</div>
</div>
<div class="paragraph">
<p>基于图形的组件，特别是<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/RETE_Visualizer">Rete可视化</a> <a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/LocalSearch_DebuggerTooling">器</a> ， <a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/LocalSearch_DebuggerTooling">本地搜索调试器</a>和<a href="http://wiki.eclipse.org/VIATRA/Addon/VIATRA_Viewers">Viewers</a>的<a href="http://wiki.eclipse.org/VIATRA/Addon/VIATRA_Viewers">图形可视化支持</a> ，已经更新，依赖于最新的GEF 5.0版（Eclipse Oxygen提供）。这导致更新的基于JavaFX的显示以及默认情况下可用于这些组件的其他错误修正。</p>
</div>
<div class="paragraph">
<p>遵循GEF5将来使用这些功能的依赖关系，需要安装JavaFX（可从Java 8获得）和e（fx）clipse。</p>
</div>
</div>
<div class="sect2">
<h3 id="_complex_event_processing"><a class="link" href="#_complex_event_processing">复杂事件处理</a></h3>
<div class="paragraph">
<p>VIATRA CEP以前只支持原子事件的<strong>事件参数</strong> 。从现在开始，复杂事件也可以参数化，完全支持事件组合。此外，查询事件也被参数化，参数直接从引用的查询的参数导出。</p>
</div>
<div class="paragraph">
<p>例如，请<a href="https://github.com/viatra/viatra-cep-examples/tree/master/minimal-samples/QueryEvent">从此处</a>查看这些示例事件。给出以下查询：</p>
</div>
<div id="v16-cep-parameters" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern hasContainer(contained: EClass, container: EClass) = {
	EClass.eStructuralFeatures(container, ref);
	EReference.containment(ref, true);
	EReference.eType(ref, contained);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以定义一个参数化的查询事件，并将其组成一个参数化的复杂事件：</p>
</div>
<div id="v16-parameterizedevent" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">queryEvent addContainer(contained:EObject, container:EObject)
	as hasContainer(contained, container) found

complexEvent addContainer2(cned:EObject, container1:EObject, container2:EObject) {
	as (addContainer(cned, container1) -&gt; addContainer(cned, container2))
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_design_space_exploration"><a class="link" href="#_design_space_exploration">设计空间探索</a></h3>
<div class="paragraph">
<p>VIATRA-DSE获得了一些增量更新和错误修复。</p>
</div>
<div class="paragraph">
<p>添加了一种称为<strong>最佳优先搜索的</strong>新探索算法，最终将探索整个设计空间（如果它是有限的），并始终以最佳选择继续进行。它可以使用<code>Strategies.createBestFirstStrategy(int maxDepth)</code>进行实例化。它还有两种配置可能性： <code>continueIfHardObjectivesFulfilled()</code> （因此如果找到解决方案则不会回溯）和<code>goOnOnlyIfFitnessIsBetter()</code> （因此它不会立即探索同样好的状态，只有更好的状态）。目前它是在没有多线程的情况下实现的。</p>
</div>
<div class="paragraph">
<p>实用程序函数<code>DesignSpaceExplorer.saveModels()</code>将所有解决方案保存为EMF模型。有关详细信息，请参阅API doc</p>
</div>
<div class="paragraph">
<p><code>DepthHardObjective</code>已被引入，为解决方案提供最小和最大深度标准。可以使用<code>Objectives.createDepthHardObjective()</code>进行实例化。</p>
</div>
<div class="paragraph">
<p>通过更好的回溯机制改善了性能：当探索策略重置为探索设计空间的其他区域的其他轨迹，并且如果新旧轨迹以相同的规则应用程序开始，那么它将仅回溯到它们的最后一个共同的国家。</p>
</div>
<div class="sect3">
<h4 id="_additional_issues_2"><a class="link" href="#_additional_issues_2">其他问题</a></h4>
<div class="paragraph">
<p>有关VIATRA 1.6的已修复问题的完整列表，请参阅<a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.6.0/bugs" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.6.0/bugs</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_1_6"><a class="link" href="#_migrating_to_viatra_1_6">迁移到VIATRA 1.6</a></h3>
<div class="sect3">
<h4 id="_recommended_new_indexing_option_for_handling_dangling_edges"><a class="link" href="#_recommended_new_indexing_option_for_handling_dangling_edges">推荐用于处理悬空边缘的新索引选项</a></h4>
<div class="paragraph">
<p>此版本中引入了一个关于悬空边缘的新过滤器选项（即指向查询引擎范围之外的对象的引用）。旧版本假设没有任何这样的悬空边缘，因此没有应用过滤器来拒绝涉及这种悬空边缘的查询匹配。在某些情况下，这导致了令人惊讶的结果。为了获得更可预测的结果和更直接的语义，我们现在允许用户关闭此假设，以便执行适当的检查（性能略有降低）。</p>
</div>
<div class="paragraph">
<p>对于新代码以及任何遇到悬空边缘不可预测性问题的现有用户，我们建议使用新引入的选项来放弃悬空假设。在未来的VIATRA版本中，这将是新的默认版本。</p>
</div>
<div id="v16-dangling-migration" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">BaseIndexOptions options = new BaseIndexOptions().withDanglingFreeAssumption(false);
ResourceSet rSet = new ResourceSetImpl();
EMFScope scope = new EMFScope(rSet, options);
ViatraQueryEngine engine = ViatraQueryEngine.on(scope);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_api_break_in_transitive_closure_library_2"><a class="link" href="#_api_break_in_transitive_closure_library_2">Transitive Closure Library中的API中断</a></h4>
<div class="paragraph">
<p>此API中断更改会影响org.eclipse.viatra.query.runtime.base.itc Java库的用户，以便对自定义图数据源进行增量传递闭包计算。</p>
</div>
<div class="paragraph">
<p><strong>不受影响</strong> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>vql中传递闭包语言元素的用户。</p>
</li>
<li>
<p><code>TransitiveClosureHelper</code>用户提供EMF引用的传递闭包。</p>
</li>
<li>
<p>图表表示的用户<code>org.eclipse.viatra.query.runtime.base.itc.graphimpl.Graph</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>详细信息</strong> ：我们已经改变了如何在接口<code>IGraphDataSource</code>和<code>IBiDirectionalGraphDataSource</code>表示多个传入/传出图形边缘的方式。旧接口使用了<code>java.util.顶点List</code> （并行边表示为列表中的多个条目），而新接口使用<code>java.util.将顶点Map</code>为键，将正整数Map</code>为平行边的计数值。图形观察器界面未更改。</p>
</div>
</div>
<div class="sect3">
<h4 id="_dependency_changes_related_to_guava"><a class="link" href="#_dependency_changes_related_to_guava">与番石榴有关的依赖性变化</a></h4>
<div class="paragraph">
<p>在氧气释放系列中，有多种版本的番石榴可供选择。为了确保VIATRA使用单个Guava版本，所有框架项目现在都使用包导入导入Guava，并为导出Guava包的所有包设置相应的“使用”约束。</p>
</div>
<div class="paragraph">
<p>对于使用VIATRA框架的项目，一切都应该像以前一样工作。但是，如果存在多个Guava版本冲突的问题，请检查您的任何类是否在其API上具有Guava类型（例如，检查超类，参数和返回类型;最常见的候选项是Predicate和Function实例）。如果有任何此类情况，则需要执行以下步骤以确保单个Guava版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用适当的包导入声明替换<code>com.google.guava</code>所需的包声明。</p>
</li>
<li>
<p>对于在其API上包含Guava类的每个包导出声明，添加一个使用约束，如下所示： <code>org.eclipse.viatra.query.runtime.emf; uses:="com.google.common.collect",</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关该问题的更多详细信息，并且一般使用约束违规，请查看<a href="http://blog.springsource.com/2008/10/20/understanding-the-osgi-uses-directive/" class="bare">http://blog.springsource.com/2008/10/20/understanding-the-osgi-uses-directive/</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-15"><a class="link" href="#viatra-15">VIATRA 1.5</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2016年12月21日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.5.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.5.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_support_for_more_number_literals_in_query_language"><a class="link" href="#_support_for_more_number_literals_in_query_language">在查询语言中支持更多数字文字</a></h3>
<div class="paragraph">
<p>现在，VIATRA查询语言直接支持Xtend支持的所有数字文字（详见<a href="https://eclipse.org/xtend/documentation/203_xtend_expressions.html#number-literals">文档</a> ）。</p>
</div>
<div id="v15-literals" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern circleConstantDiameter1(c : Circle) {
  Circle.diameter(c, 3l);
  Circle.area(c, 9.42f);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performance_improvements"><a class="link" href="#_performance_improvements">性能改进</a></h3>
<div class="sect3">
<h4 id="_performance_tuning_with_functional_dependencies"><a class="link" href="#_performance_tuning_with_functional_dependencies">具有功能依赖性的性能调优</a></h4>
<div class="paragraph">
<p>版本1.5引入了模式变量之间功能依赖性的极大改进的推断，这可能显着影响查询评估性能。</p>
</div>
<div class="paragraph">
<p>现在，人们还可以使用<code>@FunctionalDependency</code>批注手动指定其他依赖关系规则，以表达特定于域的洞察力。请参阅下面的语法示例：</p>
</div>
<div id="v15-functionaldependencies" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">// Here the first annotation is superfluous, as it is inferred automatically anyway
// The second annotation expresses valuable domain knowledge though
@FunctionalDependency(forEach = house, unique = street, unique = houseNumber)
@FunctionalDependency(forEach = street, forEach = houseNumber, unique = house)
pattern address(house: House, street: Street, houseNumber: java Integer) {
	Street.houses(street, house);
	House.number(house, houseNumber);
}

// Houses are either on a Street or on a Road, but not both at the same time;
//  however Viatra is not smart enough (yet) to figure that out.
// In disjunctive patterns, all dependencies have to be specified manually!
@FunctionalDependency(forEach = house, unique = location)
pattern locatedOnThoroughfare(house: House, location: Thoroughfare) {
	Street.houses(location, house);
} or {
	Road.houses(location, house);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多细节<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/AdvancedPatterns#Functional_dependencies">在这里</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_further_optimizations_in_the_incremental_query_evaluator"><a class="link" href="#_further_optimizations_in_the_incremental_query_evaluator">增量查询评估程序中的进一步优化</a></h4>
<div class="paragraph">
<p>在许多情况下，现在可以更有效地处理模式中的常量值（更准确地说是恒定值过滤）。在专有代码库中，特别是对于大量使用此功能的整个查询包，我们观察到Rete的内存占用减少了15-30％。</p>
</div>
<div class="paragraph">
<p>作为额外的次要内存改进，默认情况下，eval / check表达式的结果不再在Rete中缓存。如果某些此类表达式涉及特别昂贵的计算，则可以使用<code>ReteHints</code>类中引入的相应提示选项全局或基于每个模式恢复原始缓存行为。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_remote_debugging_support_added_to_the_viatra_model_transformation_debugger"><a class="link" href="#_remote_debugging_support_added_to_the_viatra_model_transformation_debugger">为VIATRA模型转换调试器添加了远程调试支持</a></h3>
<div class="paragraph">
<p>VIATRA模型转换调试器（在VIATRA 1.3.0中引入）经历了一系列架构和后端相关的更改。目前，0.15.0版本的调试器现在允许用户连接到远程VIATRA模型转换，同时保持以前版本中引入的用户体验。这样，可以更直接地分析在远程JVM实例上运行的模型转换。</p>
</div>
<div class="videoblock">
<div class="content">
<iframe src="https://www.youtube.com/embed/TaLvKgfxQNg#?rel=0" frameborder="0" allowfullscreen=""></iframe>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_project_dependencies_in_query_maven_plugin"><a class="link" href="#_using_project_dependencies_in_query_maven_plugin">在Query Maven插件中使用项目依赖项</a></h3>
<div class="paragraph">
<p>您现在可以在配置中使用“useProjectDependencies”，而不是将元模型添加为Maven依赖项。当元模型不可用作Maven工件时，这尤其有用。</p>
</div>
<div id="v15-maven" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;source lang="xml"&gt;
&lt;configuration&gt;
  &lt;!-- in addition to existing configuration --&gt;
  &lt;useProjectDependencies&gt;true&lt;/useProjectDependencies&gt;
&lt;configuration&gt;
&lt;/source&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅以下<a href="http://wiki.eclipse.org/VIATRA/UserDocumentation/Build#viatra-maven-plugin">Wiki页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_migration_to_viatra_1_5"><a class="link" href="#_migration_to_viatra_1_5">迁移到VIATRA 1.5</a></h3>
<div class="sect3">
<h4 id="_internal_api_changes"><a class="link" href="#_internal_api_changes">内部API更改</a></h4>
<div class="sect4">
<h5 id="_vql_abstract_syntax"><a class="link" href="#_vql_abstract_syntax">VQL抽象语法</a></h5>
<div class="paragraph">
<p><code>IntValue</code>和<code>DoubleValue</code> EClasses已从patternlanguage元模型中删除。其功能由引用Xbase编号文字的新<code>NumberValue</code> EClass提供。</p>
</div>
</div>
<div class="sect4">
<h5 id="_hint_system_compatibility_break"><a class="link" href="#_hint_system_compatibility_break">提示系统兼容性中断</a></h5>
<div class="paragraph">
<p>提示系统在1.5版中再次更改。如果您仅通过LocalSearchHints便捷类和该类创建的QueryEvaluationHint实例使用提示，那么您现有的代码应保持与1.5版兼容。</p>
</div>
<div class="paragraph">
<p>主要的变化是查询评估提示选项不再由字符串标识，而是由类型安全的QueryHintOption的静态实例标识。此类提示选项可以由查询评估程序后端定义（请参阅ReteHintOptions和LocalSearchOptions），并且将来可能会有多个后端共享的选项。</p>
</div>
<div class="paragraph">
<p>随着更改，以下已弃用的方法和字段已完全删除：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LocalSearchRuntimeBasedStrategy.plan（PBody，Logger，Set，IQueryMetaContext，IQueryRuntimeContext，Map）</code></p>
</li>
<li>
<p><code>IQueryBackendHintProvider.getHints（PQuery）</code></p>
</li>
<li>
<p><code>IQueryBackendHintProvider。默认</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，以下类和方法已被新近弃用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LocalSearchHintKeys</code></p>
</li>
<li>
<p><code>QueryEvaluationHint（IQueryBackendFactory，Map）</code></p>
</li>
<li>
<p><code>QueryEvaluationHint.getBackendHints（）</code></p>
</li>
<li>
<p><code>QueryPerformanceTest.getQueryBackendFactory（）</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-14"><a class="link" href="#viatra-14">VIATRA 1.4</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2016年9月30日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.4.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.4.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_local_search_support_during_query_evaluation"><a class="link" href="#_local_search_support_during_query_evaluation">查询评估期间的本地搜索支持</a></h3>
<div class="paragraph">
<p>在1.4版本中，先前引入的本地搜索支持得到了极大的增强：修复了一些错误和性能问题，而VIATRA Query的其余部分提供了更好的集成。在版本1.4中，计划程序和运行时被认为可以用于生产，而未来版本的未来增强仍在计划中。</p>
</div>
<div class="paragraph">
<p>对于这个版本，我们已经有了性能基准测试，表明基于本地搜索的模式匹配可以在模型转换到Rete期间提供相当的性能，同时需要更少的内存。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/releases/14_benchmark_ls_time.png" alt="14个基准时间">
</div>
</div>
<div class="paragraph">
<p>有关更详细的文档，请参阅<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/API/LocalSearch" class="bare">http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/API/LocalSearch</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_query_language_improvements"><a class="link" href="#_query_language_improvements">查询语言改进</a></h3>
<div class="sect3">
<h4 id="_java_type_references"><a class="link" href="#_java_type_references">Java类型引用</a></h4>
<div class="paragraph">
<p>查询语言现在允许<em>Java类型约束</em> ，既可以作为参数类型，也可以作为模式体中的变量类型约束。建议的用例是作为（a） <code>eval()</code>或（b）聚合表达式的结果的查询参数应使用其Java类型进行注释。可以通过在前缀中添加关键字<code>java</code>来引用Java类型名称，当然还可以使用命名空间导入。因此，例如，可以按如下方式键入查询参数： <code>no: java Integer</code> 。<a href="https://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryLanguage#Pattern_Structure">查询语言语法指南</a>中介绍了用法基础知识。</p>
</div>
<div id="v14-javatype" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern cpus(hi : HostInstance, no : java Integer) {
	HostInstance.availableCpu(hi, no);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aggregators"><a class="link" href="#_aggregators">聚合器</a></h4>
<div class="paragraph">
<p>除了先前支持的<code>count</code>关键字之外，现在还有几个可用的新<strong>聚合</strong>器（包括<code>sum</code> ， <code>min</code>和<code>max</code> ，以及用户定义聚合器的API），用于根据被调用模式的匹配计算聚合值。<a href="https://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryLanguage#Advanced_Pattern_Constraints">查询语言语法指南</a>中介绍了用法基础知识。</p>
</div>
<div id="v14-aggregator" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern sumCPUs(s : java Integer) {
	s == sum find cpus(_hi2, #_);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parameter_direction_support"><a class="link" href="#_parameter_direction_support">参数方向支持</a></h4>
<div class="paragraph">
<p>参数可以选择标记为传入（ <code>in</code> ），传出（ <code>out</code> ）。<strong>必须</strong>在模式匹配器初始化时绑定传入参数，而传出参数则<strong>不能</strong> 。为了向后兼容，未标记的参数既不是传入的也不是传出的：它们在被调用时可能是绑定的或未绑定的。在1.4版中，Rete引擎忽略参数方向，但本地搜索引擎使用它来决定在匹配器准备期间创建的计划集。</p>
</div>
<div id="v14-parameterdir" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern cpus(in hi : HostInstance, out no : java Integer) {
	HostInstance.availableCpu(hi, no);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_search_engine_declaration"><a class="link" href="#_search_engine_declaration">搜索引擎声明</a></h4>
<div class="paragraph">
<p>模式可以选择声明为仅本地搜索（ <code>search</code> ）或仅限Rete（ <code>incremental</code> ），为运行时提供应该为此模式初始化模式匹配器的提示。如果未定义，则使用引擎的默认提示（默认情况下为Rete）;并且可以使用高级查询引擎API重新定义。</p>
</div>
<div class="paragraph">
<p>值得注意的是，查询引擎可以覆盖这些声明，例如，如果它们无法执行。</p>
</div>
<div id="v14-backend" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">search pattern minCPUs(n : java Integer) {
	n == min find cpus(_hi1, #_);
}

incremental pattern sumCPUs(s : java Integer) {
	s == sum find cpus(_hi2, #_);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_development_environment_improvements"><a class="link" href="#_query_development_environment_improvements">查询开发环境改进</a></h3>
<div class="paragraph">
<p>我们已经毕业了全新的查询开发视图，它们取代了Query Explorer。这些视图是作为VIATRA 1.3（ <a href="http://viatra.net/news/2016/7/viatra-13-released">带视频的博客文章</a> ）和转换开发视角的一部分引入的。对于此版本，我们的目标是在新视图中包含所有重要功能，这些功能仅在之前通过查询资源管理器提供（ <a href="http://bugs.eclipse.org/499995">错误499995</a>列出了相关问题）。如果您已经打开了透视图，我们建议您重置它（右键单击透视图标并选择“重置”），因为我们已经移动了视图以使其更有意义。</p>
</div>
<div id="File:VIATRA-Query-UI-Registry-Results-Model-Engine_details.png" class="paragraph">
<p>最重要的新功能如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>显示位置适用于查询，匹配器，匹配和参数值</p>
</li>
<li>
<p>改进树中的标签（重用EMF模型元素的特定于域的图标）</p>
</li>
<li>
<p>可以通过“属性”视图进行匹配集筛选<span class="image"><img src="./images/releases/14_query-ui-matcher_filter.png" alt="14查询ui matcher过滤器"></span></p>
</li>
<li>
<p>拖放并双击以从Query Registry加载到Query Results中</p>
</li>
<li>
<p>HiDPI图标，用于高分辨率，缩放显示。</p>
</li>
<li>
<p>将现有托管查询引擎加载到“查询结果”视图中<span class="image"><img src="./images/releases/14_query-ui-open_managed_engine.png" alt="14查询ui打开托管引擎"></span></p>
</li>
<li>
<p>引擎详细信息的树视图，包括模型，引擎选项，基本索引选项<span class="image"><img src="./images/releases/14_managed_engine_selection.png" alt="14管理引擎选择"></span></p>
</li>
<li>
<p>从查询结果中删除单个匹配器</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_base_indexer_enhancements"><a class="link" href="#_base_indexer_enhancements">基本索引器增强功能</a></h3>
<div class="paragraph">
<p>在1.4版中， <a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/API/BaseIndexer">基本索引器</a>在几个方面得到了增强：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通配符模式可以在构建之后设置：现在可以要求现有基本索引器索引模型中的所有内容</p>
</li>
<li>
<p>统计索引：Base现在只能存储模型统计信息，而不是索引模型实例。这对于本地搜索非常有用，因为计划生成这些统计数据非常有用，但需要的内存较少。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些增强功能在查询运行时中非常有用（并且受本地搜索要求的驱动），但也可用于外部用途。</p>
</div>
</div>
<div class="sect2">
<h3 id="_design_space_explorer_enhancements"><a class="link" href="#_design_space_explorer_enhancements">Design Space Explorer增强功能</a></h3>
<div class="ulist">
<ul>
<li>
<p>设置日志记录级别的方法： <code>OFF</code> ， <code>WARN</code> ， <code>BASIC</code> ， <code>VERBOSE_STRATEGY</code>和<code>VERBOSE_FULL</code></p>
</li>
<li>
<p>如果探索以异步方式启动，则可以通过以下方法停止：stopExploration（），stopExplorationAsync（），waitForTerminaition（）。</p>
</li>
<li>
<p>现在，进化探索策略可以在多线程上运行。</p>
</li>
<li>
<p>深度优先搜索策略可以继续从解决方案中探索。</p>
</li>
<li>
<p>轻微的性能增强。</p>
</li>
<li>
<p>更新了wiki以及代码中的文档： <a href="https://wiki.eclipse.org/VIATRA/DSE/UserGuide/API" class="bare">https</a> ： <a href="https://wiki.eclipse.org/VIATRA/DSE/UserGuide/API" class="bare">//wiki.eclipse.org/VIATRA/DSE/UserGuide/API</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_other_issues"><a class="link" href="#_other_issues">其他问题</a></h3>
<div class="paragraph">
<p>版本1.4还具有大量的引擎盖下更改，最重要的是更新的提示系统，以实现查询引擎的细粒度参数化。通常，此更改对于现有用户应该是不可见的;有关可能的迁移问题，请参阅下面的迁移指南</p>
</div>
<div class="paragraph">
<p>总共有更多，在此版本中修复了70个问题，有关详细信息，请参阅<a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.4.0/bugs" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.4.0/bugs</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_1_4"><a class="link" href="#_migrating_to_viatra_1_4">迁移到VIATRA 1.4</a></h3>
<div class="sect3">
<h4 id="_language_updates"><a class="link" href="#_language_updates">语言更新</a></h4>
<div class="paragraph">
<p>查询语言引入了一些新的关键字，即<code>in</code> ， <code>out</code> ， <code>search</code>和<code>incremental</code> 。必须使用^符号转义具有此名称的变量和类型。另一方面， <code>count</code>不再是关键字，因此对于将来的版本，其引用不需要转义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_user_interface_updates"><a class="link" href="#_user_interface_updates">用户界面更新</a></h4>
<div class="paragraph">
<p>查询开发UI已大大更新。可能值得查看新的VIATRA视角;对于透视图的现有用户，重置透视图可能是有意义的，因为它已在版本1.4中重新设计。</p>
</div>
</div>
<div class="sect3">
<h4 id="_internal_engine_api_changes"><a class="link" href="#_internal_engine_api_changes">内部引擎API更改</a></h4>
<div class="sect4">
<h5 id="_localsearch_internal_api_changes"><a class="link" href="#_localsearch_internal_api_changes">LocalSearch内部API更改</a></h5>
<div class="paragraph">
<p>方法<code>LocalSearchPlanner.initializePlanner(PQueryFlattener, Logger, IQueryMetaContext, IQueryRuntimeContext, PBodyNormalizer, LocalSearchRuntimeBasedStrategy, POperationCompiler, Map&lt;String,Object&gt;)</code>已被删除。初始化由构造函数执行，该构造函数具有以下签名： <code>LocalSearchPlanner(LocalSearchBackend, Logger, PlannerConfiguration)</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_hint_system_refactor"><a class="link" href="#_hint_system_refactor">提示系统重构</a></h5>
<div class="paragraph">
<p>在VIATRA 0.9中引入了初步提示系统，可以提供查询评估的提示。在1.4版本中，这个提示系统得到了扩展;但是，VIATRA 1.4无法处理使用旧版本VIATRA生成的查询的提示。如果要使用提示，请使用1.4重新生成查询。</p>
</div>
</div>
<div class="sect4">
<h5 id="_updated_runtime_context_api"><a class="link" href="#_updated_runtime_context_api">更新的运行时上下文API</a></h5>
<div class="paragraph">
<p><code>IQueryRuntimeContext</code>接口扩展了一些与Base indexer的使用相关的新方法。对于将来，建议实现者不直接实现此类，而是依赖新的<code>AbstractQueryRuntimeContext</code>基类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_dse_api_breaks"><a class="link" href="#_dse_api_breaks">DSE API中断</a></h5>
<div class="paragraph">
<p>三个DSE插件（ <code>dse.api</code> ， <code>dse.base</code> ， <code>dse.designspace</code> ）已重新<code>dse.designspace</code>为单个插件： <code>org.eclipse.viatra.dse</code> 。应该相应地更新清单文件。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-13"><a class="link" href="#viatra-13">VIATRA 1.3</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2016年7月7日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.3.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.3.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_neon_compatibility"><a class="link" href="#_neon_compatibility">霓虹兼容性</a></h3>
<div class="paragraph">
<p>由于多种原因，早期版本的VIATRA与Eclipse Neon版本不完全兼容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>VIATRA 1.3是第一个与Xtext 2.10兼容的版本。</p>
</li>
<li>
<p>Neon中的JFace数据绑定需要Java 1.8。但是，为了与旧版本兼容，VIATRA使用旧版本进行编译，但确保它与当前版本兼容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，VIATRA仍然可以与Indigo版本之前的旧平台版本兼容。</p>
</div>
</div>
<div class="sect2">
<h3 id="_query_development_environment_update"><a class="link" href="#_query_development_environment_update">查询开发环境更新</a></h3>
<div class="paragraph">
<p>我们引入了<strong>转换开发</strong>视角，使VIATRA用户更容易专注于开发查询和转换。透视图将打开并布置最重要的视图，并包含所有VIATRA相关功能的视图和新向导快捷方式。</p>
</div>
<div class="paragraph">
<p>我们还在开发一种新的查询开发方法，它将取代当前Query Explorer的单一功能。您可以安装单独的功能<strong>VIATRA查询浏览器</strong> （孵化）来试用新的<em>查询注册表</em>和<em>查询结果</em>视图。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>两个视图都与“属性”视图相关联，以提供有关所选元素的其他信息。</p>
</li>
<li>
<p>Query Registry视图显示所有已注册和工作区查询，而无需直接从模式编辑器加载它们。</p>
</li>
<li>
<p>与查询资源管理器类似，可以将模型和查询加载到“查询结果”视图中。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_query_by_example_create_queries_based_on_selected_model_elements"><a class="link" href="#_query_by_example_create_queries_based_on_selected_model_elements">按示例查询：根据选定的模型元素创建查询</a></h3>
<div class="paragraph">
<p>此示例中包含一个简单查询（QBE），这是一个简化查询开发的新功能。这个新工具主要针对想要定义查询的用户，但只熟悉建模语言的具体语法（即通过图形或文本编辑器呈现的视图），而不是其抽象语法的复杂细节（元模型， EPackgage）。</p>
</div>
<div class="paragraph">
<p>QBE不允许手动编写.vql文件，而是允许用户使用“示例”指定查询 - 在模型编辑器或查看器中突出显示的EMF实例对象的选择（支持EMF树编辑器和图形编辑器）。QBE工具将发现所选元素在模型中如何相互关联，并生成.vql查询，该查询将查找以相似方式排列的模型元素组。</p>
</div>
<div class="paragraph">
<p>新推出的<strong>Query by Example</strong>视图允许用户控制（a）识别在开放模型文件中选择的元素作为示例的过程，（b）微调解释示例的选项，以及（c）导出结果查询.vql代码。导出的查询可以加载到Query Explorer（或新的Query Results视图）中进行评估和测试;如有必要，仍可在“按示例查询”视图中进行调整（例如，添加或删除其他约束）。</p>
</div>
<div class="paragraph">
<p>可以通过从VIATRA存储库中选择<em>VIATRA Query-by-Example</em> （Incubation）插件来安装该功能。有关详细信息，请查看CMSEBA'14 <a href="https://www.cs.york.ac.uk/es/cmseba/papers/Bergmann.pdf">Graph Query by Example中的论文</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_model_transformation_debugger_prototype"><a class="link" href="#_model_transformation_debugger_prototype">模型转换调试器原型</a></h3>
<div class="paragraph">
<p>VIATRA 1.3.0现在具有<strong>模型转换调试器</strong>的第一个原型，旨在帮助开发和调试基于VIATRA的模型转换。调试器支持以下主要功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>允许转换开发人员观察给定VIATRA转换的内部状态以及关联的模型实例。</p>
<div class="ulist">
<ul>
<li>
<p>在具有“属性”支持的树视图中显示与转换关联的模型实例。</p>
</li>
<li>
<p>使用当代Eclipse视图显示模型转换的活动激活。</p>
</li>
<li>
<p>使用Eclipse Variables视图显示要执行的下一个激活的前提条件参数。</p>
</li>
</ul>
</div>
</li>
<li>
<p>允许转换开发人员控制VIATRA模型转换的执行。</p>
<div class="ulist">
<ul>
<li>
<p>支持各种VIATRA转换特定断点的定义，这些断点与Eclipse Debug框架集成。</p>
</li>
<li>
<p>用户可以通过标准的Eclipse Debugging控件控制执行转换（Step over（F6），Resume（F8））。</p>
</li>
<li>
<p>用户可以定义接下来应该执行哪个转换规则激活，通过转换覆盖默认决策bade。</p>
</li>
</ul>
</div>
</li>
<li>
<p>与Eclipse Debug框架集成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>应该注意，在其当前状态下，调试器仅处理与调试器本身在同一JVM中运行的VIATRA转换。将在未来版本中引入JVM间通信。</p>
</div>
<div class="paragraph">
<p>详细的用户指南是VIATRA主要文档的一部分，可通过以下链接访问： <a href="http://static.incquerylabs.com/projects/viatra/viatra-docs/ViatraDocs.html#_viatra_debugger" class="bare">http</a> ：//static.incquerylabs.com/projects/viatra/viatra-docs/ViatraDocs.html#_viatra_debugger</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_issues_2"><a class="link" href="#_other_issues_2">其他问题</a></h3>
<div class="paragraph">
<p>版本1.3还具有大量的引擎盖下更改，最重要的是重写<em>类型推断器</em> ，其工作方式基本相同，但提供更精确的错误消息。通常，此更改对于现有用户应该是不可见的;有关可能的迁移问题，请参阅下面的迁移指南</p>
</div>
<div class="paragraph">
<p>这种变化的另一个重要领域是本地搜索的增强功能。修复了与各个领域的错误规划或计划执行有关的若干问题;对于下一个版本，计划在该领域进一步增强。</p>
</div>
<div class="paragraph">
<p>此版本中修复了70多个问题，详见<a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.3.0/bugs" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.3.0/bugs</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_to_viatra_1_3"><a class="link" href="#_migrating_to_viatra_1_3">迁移到VIATRA 1.3</a></h3>
<div class="sect3">
<h4 id="_query_specification_registry"><a class="link" href="#_query_specification_registry">查询规范注册表</a></h4>
<div class="paragraph">
<p>我们引入了一个全新的查询规范注册表并弃用了旧版本。<code>org.eclipse.viatra.query.runtime.extensibility.用户<code>org.eclipse.viatra.query.runtime.extensibility.QuerySpecificationRegistry</code>类应该读取JavaDoc以获取有关如何迁移到新的<code>org.eclipse.viatra.query.runtime.registry.详细信息<code>org.eclipse.viatra.query.runtime.registry.QuerySpecificationRegistry</code>实现。</p>
</div>
<div class="paragraph">
<p>有关新注册表的详细信息，请阅读<a href="http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/API/Advanced#Query_specification_registry" class="bare">http://wiki.eclipse.org/VIATRA/Query/UserDocumentation/API/Advanced#Query_specification_registry</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_type_inferrer_in_pattern_language"><a class="link" href="#_type_inferrer_in_pattern_language">在模式语言中键入inferrer</a></h4>
<div class="paragraph">
<p>重写了VIATRA查询语言的类型推导者;在大多数情况下，它应该与以前的版本完全相同，但有以下区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果返回某些数据类型（如字符串或整数），有时旧的推理器会将Object计算为其返回类型。新版本现在计算正确的类型。此行为由<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/plugins/org.eclipse.viatra.integration.uml/src/org/eclipse/viatra/integration/uml/derivedfeatures/DerivedFeatures.vql#n1197">UML分类器</a>的计算<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/plugins/org.eclipse.viatra.integration.uml/src/org/eclipse/viatra/integration/uml/derivedfeatures/DerivedFeatures.vql#n1197">QualifiedName派生特性提供</a> ：在版本1.2中，name参数返回Object，而在1.3中它正确计算为String。</p>
</li>
<li>
<p>在类型推断期间，模式的变量需要具有单个可识别类型。如果需要，将计算最接近的公共超类型，但是，如果该参数不是唯一的，则会引发错误。在复杂的继承层次结构的情况下，旧的推理器实现有时不会检测到这个最接近的公共超类型不是唯一的，而是选择一个。在这种情况下，新推导者会抛出错误，需要手动声明参数类型。对于这些情况，可以使用快速修复手动插入任何可能的类型。</p>
</li>
<li>
<p><strong>已知问题</strong> ：如果模式具有多个检查和eval表达式，则类型推导者有时无法在其他表达式中正确推断eval表达式的返回类型。错误消息有点误导，因为将对象输入检查表达式是完全合法的，因此只有错误输入的表达式才会检测到问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以在表达式中使用类型转换来解决该问题。请参阅以下（人工）示例：</p>
</div>
<div id="v13-typeinferrer" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern t4_erroneous(n) {
  check(n &gt; 2); //Error 1: '&gt; cannot be resolved'; Error 2: 'Check expression must return boolean'
  n == eval(2);
}

pattern t4_fixed(n) {
  check((n as Integer)&gt; 2);
  n == eval(2);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-12"><a class="link" href="#viatra-12">VIATRA 1.2</a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">发布日期</dt>
<dd>
<p>2016年4月28日</p>
</dd>
<dt class="hdlist1">更多信息</dt>
<dd>
<p><a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.2.0" class="bare">https://projects.eclipse.org/projects/modeling.viatra/releases/1.2.0</a></p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_combined_emf_incquery_and_viatra"><a class="link" href="#_combined_emf_incquery_and_viatra">结合EMF-IncQuery和VIATRA</a></h3>
<div class="paragraph">
<p>VIATRA 1.2包括EMF-IncQuery的高性能查询引擎，并包含一个事件驱动的转换引擎。此共享堆栈支持各种任务的开发，包括批处理和事件驱动的转换，复杂事件处理和设计空间探索概念。</p>
</div>
<div class="paragraph">
<p>将所有元素集中在一个项目中可以实现各个组件之间的紧密集成，从而提供更好的用户体验。</p>
</div>
</div>
<div class="sect2">
<h3 id="_graduation_of_the_transformation_engine"><a class="link" href="#_graduation_of_the_transformation_engine">转型引擎的毕业</a></h3>
<div class="paragraph">
<p>在VIATRA 1.2中，支持批处理和事件驱动转换的转换API已经逐步实现：API已经稳定，添加了使用文档。有关详细信息，请参阅<a href="https://wiki.eclipse.org/VIATRA/Transformation" class="bare">https://wiki.eclipse.org/VIATRA/Transformation</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_issues_3"><a class="link" href="#_other_issues_3">其他问题</a></h3>
<div class="paragraph">
<p>不计算EMF-IncQuery的合并，VIATRA 1.2主要是修复版本，修复了<a href="https://projects.eclipse.org/projects/modeling.viatra/releases/1.2.0/bugs">80多个不同的问题</a> ，从而为编写模型查询和转换创建了更稳定的环境。</p>
</div>
</div>
<div class="sect2">
<h3 id="_migrating_from_emf_incquery_1_1_to_viatra_1_2"><a class="link" href="#_migrating_from_emf_incquery_1_1_to_viatra_1_2">从EMF-IncQuery 1.1迁移到VIATRA 1.2</a></h3>
<div class="paragraph">
<p>从版本1.2开始，EMF-IncQuery作为Viatra Query合并到Viatra项目中。合并涉及完全删除org.eclipse.incquery命名空间，从而使所有依赖于EMF-IncQuery的代码与Viatra Query API不兼容。此外，在合并期间，清理现有代码库，删除所有现有的已弃用代码，并重命名一些类以与新命名约定保持一致。</p>
</div>
<div class="sect3">
<h4 id="_the_migrator_tool"><a class="link" href="#_the_migrator_tool">迁移工具</a></h4>
<div class="paragraph">
<p>为了简化迁移过程，Viatra 1.2中包含一个迁移器工具，以尽可能减少手动重构。</p>
</div>
</div>
<div class="sect3">
<h4 id="_usage"><a class="link" href="#_usage">用法</a></h4>
<div class="paragraph">
<p>可以在适用的Java / EMF-IncQuery项目的“配置”上下文菜单中访问该工具。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>更新Viatra查询项目</em> ： <em>查询项目的</em>迁移（EMF-IncQuery 0.8.0-1.1.0）</p>
<div class="ulist">
<ul>
<li>
<p>更新项目依赖项</p>
</li>
<li>
<p>更新查询描述文件</p>
</li>
<li>
<p>更新查询规范扩展</p>
</li>
<li>
<p>更新EMF-IncQuery API的使用</p>
</li>
<li>
<p><strong>重要提示</strong> ：此项目在已经是VIATRA Query项目的项目中不可用</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>替换EMF-IncQuery API用法</em> ：迁移Java和Xtend项目</p>
<div class="ulist">
<ul>
<li>
<p>更新EMF-IncQuery API的使用</p>
</li>
<li>
<p>安全多次调用</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_remaining_manual_tasks_after_migration"><a class="link" href="#_remaining_manual_tasks_after_migration">迁移后剩余的手动任务</a></h4>
<div class="ulist">
<ul>
<li>
<p>Maven构建不会迁移。</p>
</li>
<li>
<p>在1.2.0中删除了<a href="https://www.eclipse.org/viatra/javadoc/releases/incquery-1.1.0/deprecated-list.html">EMF-IncQuery 1.1.0</a>中不推荐使用的API。必须手动迁移这些API用法;查找版本1.1 javadoc以获取有关更新的提示。</p>
</li>
<li>
<p>从语言中删除了不推荐使用的模式注释和注释参数;它们需要从查询定义中手动更新或删除。</p>
</li>
<li>
<p>重新生成除查询规范之外的生成的插件扩展，但不删除旧的扩展。这些应手动删除。</p>
</li>
<li>
<p>静态方法调用和枚举文字的类名应手动重命名，例如<code>AdvancedIncQueryEngine.createUnmanagedEngine()</code> → <code>AdvancedViatraQueryEngine.createUnmanagedEngine()</code>或<code>IncQueryActivationStateEnum.UPDATED</code> → <code>CRUDActivationStateEnum.更新</code></p>
</li>
<li>
<p>该工具不迁移重命名的方法和字段:(不完整列表;一般对IncQuery的引用已更改;如果编译错误，则在内容辅助中查找类似命名的方法）</p>
<div class="ulist">
<ul>
<li>
<p><code>Schedulers.getIQEngineSchedulerFactory</code> →`Schedulers.getQueryEngineSchedulerFactory ^</p>
</li>
<li>
<p><code>ExecutionSchemas.createIncQueryExecutionSchema</code> → <code>ExecutionSchemas.createViatraQueryExecutionSchema</code></p>
</li>
<li>
<p><code>IncQueryActivationStateEnum。APPEARED</code> → <code>CRUDActivationStateEnum.CREATED</code></p>
</li>
<li>
<p><code>IncQueryActivationStateEnum。DISAPPEARED</code> → <code>CRUDActivationStateEnum.DELETED</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_a_detailed_list_of_changes"><a class="link" href="#_a_detailed_list_of_changes">详细的更改列表</a></h4>
<div class="paragraph">
<p>合并期间完成的更改<a href="https://docs.google.com/spreadsheets/d/1gvu-iWx57z5wCd0HBTdidhuYUmBqfTgEIDIRwuW_vaE/edit?usp=sharing">记录在电子表格中</a> ;这里我们描述主要的变化。</p>
</div>
<div class="sect4">
<h5 id="_project_renaming"><a class="link" href="#_project_renaming">项目重命名</a></h5>
<div class="paragraph">
<p>来自EMF-IncQuery项目的项目是（a）从<code>org.eclipse.incquery</code>移动到<code>org.eclipse.viatra</code>名称空间; （b）引入子组件以分成VIATRA项目的新组件，以便于理解。电子表格中带有粗体名称的项目有一些非平凡的重命名。</p>
</div>
</div>
<div class="sect4">
<h5 id="_class_renaming"><a class="link" href="#_class_renaming">类重命名</a></h5>
<div class="paragraph">
<p>除了将所有项目移动到org.eclipse.viatra命名空间之外，还会重命名一些类，原因如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有出现的EMF-IncQuery或IncQuery都被重命名以满足新的项目名称。</p>
</li>
<li>
<p>EVM中与匹配事件相关的一些类被推广到CRUD样式的事件模型中。语义与先前版本中的语义相同，它们仅被重命名以表明它们可以在其他域中重用。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_pattern_language_updates"><a class="link" href="#_pattern_language_updates">模式语言更新</a></h5>
<div class="paragraph">
<p>语言使用的文件扩展名从<code>eiq</code>更新为<code>vql</code> （VIATRA查询语言）， <code>eiqgen</code>为'vqgen'。迁移器工具会自动更新这些文件扩展名。此外，删除了一些不推荐使用的注释和注释参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>删除<code>@PatternUI</code>注释，改为使用<code>@QueryExplorer</code> 。</p>
</li>
<li>
<p>而不是<code>@QueryExplorer</code>注释的<code>display</code>参数，只有<code>checked</code>参数可用。</p>
</li>
<li>
<p><code>@Constraint</code>注释的<code>location</code>参数将替换为<code>key</code>参数。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_viatra_databinding_addon"><a class="link" href="#_viatra_databinding_addon">VIATRA数据绑定插件</a></h5>
<div class="paragraph">
<p>如以下<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=489228">错误</a>中所述，已删除DatabindingAdapter和GenericDatabindingAdapter类。它们的功能已被<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/addon/plugins/org.eclipse.viatra.addon.databinding.runtime/src/org/eclipse/viatra/addon/databinding/runtime/adapter/MatcherProperties.java">MatcherProperties</a>类取代。它有一组静态方法，可以根据查询规范创建可观察值和值属性。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>