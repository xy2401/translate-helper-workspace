<html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s3.html" rel="prev">&lt;&lt;§3标注绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s5.html" rel="next">§5团队激活&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s4">
            <div class="headl">
               <div class="headr">
                  <h1>§4Callin绑定</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s4.html">§4Callin绑定</a></li>
                  <li><a href="#s4.1">§4.1Callin方法绑定</a></li>
                  <li><a href="#s4.2">§4.2Callin修饰符（之前，之后，替换）</a></li>
                  <li><a href="#s4.3">§4.3基本呼叫</a></li>
                  <li><a href="#s4.4">§4.4Callin参数映射</a></li>
                  <li><a href="#s4.5">§4.5升降</a></li>
                  <li><a href="#s4.6">§4.6覆盖访问限制</a></li>
                  <li><a href="#s4.7">§4.7使用静态方法绑定Callin</a></li>
                  <li><a href="#s4.8">§4.8Callin优先权</a></li>
                  <li><a href="#s4.9">§4.9Callin继承</a></li>
                  <li><a href="#s4.10">§4.10通用callin绑定</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>callin结合的概念</h3>
               <p>Callin绑定实现了与callout绑定相反方向的转发（参见<a href="s3.html" title="§3标注绑定" class="sect">§3</a> ）。这两个术语都是从角色的角度选择的，角色控制着与相关基础对象的通信。从技术上讲，callin绑定相当于将其他代码（触发器）编织到现有的基本方法中。
                  		
               </p>
               <div class="line"></div>
               <div class="term">呼唤</div>
               <div class="termdesc">可以通过callin绑定<strong>拦截</strong>基类<em>的方法</em> （ <em>基本方法“调用”角色</em> ）。
               </div>
               <div class="line"></div>
               <div class="term">/前后/替换</div>
               <div class="termdesc">修饰符<strong>之前，之后，替换</strong>控制原始方法和callin方法的组成。
               </div>
               <div class="line"></div>
               <div class="term">激活</div>
               <div class="termdesc">根据<a href="s5.html" title="§5团队激活" class="sect">§5，</a> Callin绑定可能是活动的或非活动的。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s4.1">
               <h2 class="sect">§4.1Callin方法绑定<a class="img" href="s4.1.html" title="PermaLinkto§4.1Callin方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="syntax">→语法§A.3.3</a></div>
               <div class="subsect depth3" id="s4.1.a">
                  <h4 class="subsect">（a） <span class="title">方法呼叫拦截</span><a class="img" href="s4.1.a.html" title="PermaLink到（a）方法调用拦截"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色方法可以通过callin绑定拦截对基本方法的调用。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.b">
                  <h4 class="subsect">（b） <span class="title">先决条件：类绑定</span><a class="img" href="s4.1.b.html" title="PermaLink到（b）先决条件：类绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定要求封闭类是根据<a href="s2.1.html" title="§2.1播放了关系" class="sect">§2.1</a>绑定到基类的角色类。一个<em>unliftable</em>作用（见<a href="s2.3.4.a.html" title="§2.3.4。（a）潜在的模糊性" class="sect">§2.3.4。（一）</a> ）不应该定义呼唤绑定。在这种情况下，只能在子角色中安全地引入callin绑定（通过适当改进的<code>playedBy</code>子句）消除提升转换的歧义。
                     			
                  </p>
                  <p>对于极端情况，可以通过使用<code>"hidden-lifting-problem"</code>标记来抑制相应的错误来覆盖上述规则（参见<a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ）。这将允许定义callin绑定，即使对于不可操作的角色，期望通过<a href="s2.3.4.b.html" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4</a>中所述的模式之一仍然可以取消提升<a href="s2.3.4.b.html" title="§2.3.4。（b）明确的歧义" class="sect">。（b）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.c">
                  <h4 class="subsect">（c） <span class="title">Callin声明</span><a class="img" href="s4.1.c.html" title="永久链接到（c）Callin声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定使用给定的基本方法组成现有的角色方法。它可能出现在允许使用功能声明的任何位置的角色类中。它表示为</p>
                  <div class="listing plain"><pre><i>role_method_designator</i> <b>&lt; -</b> <i>callin_modifier</i> <i>base_method_designator;</i></pre></div>
                  <p>就像callout绑定一样，方法指示符可能包含也可能不包含参数列表和返回类型但不包含修饰符;此外，每个方法指示符必须完全唯一地选择一种方法（参见<a href="s3.1.c.html" title="§3.1。（c）各种方法指示符" class="sect">§3.1。（c）</a> ）。
                     <br>对于<em>callin修饰符，</em>见<a href="#s4.2" title="§4.2Callin修饰符（之前，之后，替换）" class="sect">下文（§4.2）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.d">
                  <h4 class="subsect">（d） <span class="title">多种基本方法</span><a class="img" href="s4.1.d.html" title="PermaLink（d）多种基本方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>基础方法指示符还可以列举方法列表。如果在一个callin声明中绑定了多个基本方法，则此绑定中的所有签名通常必须符合。
                     		<br>但是，角色可能会忽略基本方法中的<em>无关参数</em> 。
                     	    <br>对于<em>结果类型，</em>存在不同的规则，具体取决于应用的callin修饰符（参见下一个）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.e">
                  <h4 class="subsect">（e） <span class="title">命名为callin绑定</span><a class="img" href="s4.1.e.html" title="PermaLink到（e）命名为callin绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>任何callin绑定都可以用名称标记。callin绑定的名称用于声明<em>优先级</em> （ <a href="#s4.8" title="§4.8Callin优先权" class="sect">§4.8</a> ）。命名的callin绑定<em>会覆盖</em>具有相同名称的任何继承的callin绑定（显式和隐式（ <a href="s1.3.1.html" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ））。
                     			<br>在同一角色类中多次使用相同的callin名称是错误的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.f">
                  <h4 class="subsect">（f） <span class="title">召集决赛</span><a class="img" href="s4.1.f.html" title="永久链接到（f）Callin to final"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>绑定到最终基本方法时，必须通过声明最终方法的确切基类来扮演封闭角色。即，不允许callin绑定到从基类的超类继承的最终方法。这是因为没有子类可能具有具有不同语义的最终方法的版本。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.g">
                  <h4 class="subsect">（g） <span class="title">宣布的例外情况</span><a class="img" href="s4.1.g.html" title="PermaLink到（g）声明的例外"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果要由callin绑定的角色方法在其<tt>throws</tt>子句中声明任何未由相应的基本方法声明的异常，则会出错。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.h">
                  <h4 class="subsect">（h） <span class="title">封闭课程的方法</span><a class="img" href="s4.1.h.html" title="PermaLink to（h）封闭类的方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在callin绑定<code>before</code>或<code>after</code> ，左手侧可以替代地解析为封闭类而不是当前角色的方法。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.i">
                  <h4 class="subsect">（i） <span class="title">致电建设者</span><a class="img" href="s4.1.i.html" title="永久链接到（i）Callin到构造函数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定可以通过使用构造函数的源名称（与基类的名称相同）来引用绑定基类的构造函数。在这种情况下，只允许绑定<strong>后</strong> （ <a href="#s4.2.a" title="§4.2。（a）方法构成" class="sect">§4.2。（a）</a> ）。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.2">
               <h2 class="sect">§4.2Callin修饰符（之前，之后，替换） <a class="img" href="s4.2.html" title="PermaLinkto§4.2Callin修饰符（before，after，replace）"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <div class="subsect depth3" id="s4.2.a">
                  <h4 class="subsect">（a） <span class="title">方法构成</span><a class="img" href="s4.2.a.html" title="永久链接到（a）方法组合"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>通过在绑定声明的“ <code>&lt;-</code> ”标记<strong>之前，之后</strong>或<strong>替换</strong>之后添加一个修饰符来控制方法组成的类型。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.2.b">
                  <h4 class="subsect">（b） <span class="title">添加剂组合物</span><a class="img" href="s4.2.b.html" title="PermaLink（b）添加剂组合物"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><code>before</code>和<code>after</code>修饰符具有在基本方法的开头或结尾添加对角色方法的调用的效果。<br>在这种情况下，没有数据从角色传输到基础，因此如果角色方法有结果，则始终会忽略此方法。
                     			
                  </p>
                  <h5 class="listing">示例代码（Callin）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>团队</b> <b>类</b>公司{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>受保护的</b> <b>类</b>员工<b>playBy</b> Person {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>public</b> <b>void</b> recalculateIncome（）{...}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>重新计算收入<em><b>&lt; -</b>在</em>生日<em>之后</em> ; <span class="comment">// callin绑定</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <p>第4行声明了第3行定义的角色方法<code>recalculateIncome()</code>的callin绑定。结合第2行中的角色绑定，这具有以下效果：</p>
                     <ul>
                        <li><strong>在</strong>方法<code>Person.haveBirthday</code>的每次调用<strong>之后</strong> ，调用方法<code>Company.recalculateIncome</code> 。
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="subsect depth3" id="s4.2.c">
                  <h4 class="subsect">（c） <span class="title">更换组合物</span><a class="img" href="s4.2.c.html" title="PermaLink to（c）替换成分"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><code>replace</code>修饰符<em>仅</em>导致调用role方法，替换base方法。
                     	    <br>在这种情况下，如果基本方法声明了结果，则应由role方法提供。callin绑定中返回值的特殊情况在<a href="#s4.3.e" title="§4.3.(e) Fragile callin binding" class="sect">§4.3</a>中讨论<a href="#s4.3.e" title="§4.3。（e）脆弱的愈伤组织结合" class="sect">。（e）</a></p>
               </div>
               <div class="subsect depth3" id="s4.2.d">
                  <h4 class="subsect">（d） <span class="title">Callin方法</span><a class="img" href="s4.2.d.html" title="永久链接到（d）Callin方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由callin替换绑定绑定的角色方法必须具有修饰符<code>callin</code> 。此修饰符仅允许用于角色类的方法。<br>只能调用<code>callin</code>修饰符的方法</p>
                  <ul>
                     <li>通过callin替换绑定</li>
                     <li>通过来自最重要的callin方法的<code>super</code>或<code>tsuper</code>调用。
                     </li>
                  </ul>
                  <p><code>callin</code>方法是非法的</p>
                  <ul>
                     <li>直接打电话，</li>
                     <li>使用标注绑定绑定，和</li>
                     <li>使用callin绑定<code>before</code>或<code>after</code>绑定到基本方法。
                     </li>
                  </ul>
                  <p>尽管有这些规则，但是当前角色扮演的第二级角色可以使用任何形式的callin绑定来拦截callin方法的执行。</p>
                  <p>callin方法不能覆盖常规方法，反之亦然，但是，使用另一个callin方法覆盖一个callin方法是合法的，动态绑定适用于callin方法，就像常规方法一样。
                     	    <br>callin方法不得使用<code>public</code> ， <code>protected</code>或<code>private</code>任何修饰符声明其可见性。由于callin方法只能通过callin绑定调用，因此可见性控制不会有用。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.3">
               <h2 class="sect">§4.3基本呼叫<a class="img" href="s4.3.html" title="PermaLinkto§4.3Base调用"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.5.3" title="§A.5.3BaseCall" class="syntax">→语法§A.5.3</a></div>
               <p>具有<code>callin</code>修饰符的角色方法应包含一个<em>基本调用</em> ，该<em>调用</em>使用特殊名称<code>base</code>来调用原始基本方法（原始意味着：在替换之前）。
                  		
               </p>
               <div class="subsect depth3" id="s4.3.a">
                  <h4 class="subsect">（a） <span class="title">语法</span><a class="img" href="s4.3.a.html" title="PermaLink到（a）语法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>基本调用的语法是<code>base.m()</code> ，它类似于超级调用。<code>base.m()</code>调用必须使用与封闭方法相同的名称和签名。这再次遵循规则，除了绑定声明之外，角色永远不应显式使用基本名称。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.b">
                  <h4 class="subsect">（b） <span class="title">缺少基本呼叫</span><a class="img" href="s4.3.b.html" title="永久链接到（b）缺少基本呼叫"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>对于每个callin方法，编译器使用一些流分析来检查是否将在每个执行路径上调用基本调用（分析非常类似于关于最终变量的明确赋值的分析 - <a href="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html" class="ext">JLS§16</a> ）。如果在每个路径（明确缺失）或某些路径（可能缺少）上缺少基本调用，编译器将发出警告。callin方法也可以使用<code>super.m()</code>或<code>tsuper.m()</code>来调用其显式或隐式超级版本，而不是直接调用基本调用（参见<a href="s1.3.1.f.html" title="§1.3.1。（f）tsuper" class="sect">§1.3.1。（f）</a> ）。在这种情况下，流分析将可传递地包括被调用的super / tsuper版本。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.c">
                  <h4 class="subsect">（c） <span class="title">重复的基本呼叫</span><a class="img" href="s4.3.c.html" title="PermaLink到（c）重复的碱基调用"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callin方法包含多个基本调用，则编译器会发出警告，如果这将导致所有路径（肯定是重复的）或某些路径（可能重复）上的重复基本调用调用。流量分析中还包括super / tsuper调用（参见4.3（b））。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.d">
                  <h4 class="subsect">（d） <span class="title">参数隧道</span><a class="img" href="s4.3.d.html" title="永久链接到（d）参数隧道"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果基本方法的参数多于组成它的callin方法，则从原始调用到基本调用隐式传递其他参数（原始意味着：在拦截之前）。即，调用<code>base.m()</code>可以无形地传递调用者提供的其他参数，但是对于角色方法是隐藏的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.e">
                  <h4 class="subsect">（e） <span class="title">脆弱的愈伤组织结合</span><a class="img" href="s4.3.e.html" title="PermaLink（e）脆弱的callin结合"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果一个角色方法返回void，但绑定的基本方法声明了一个非void结果，则报告为一个<em>脆弱的callin绑定</em> ：结果仍然可以由基本调用提供，但省略基本调用可能会导致问题，具体取决于返回类型：</p>
                  <ul>
                     <li>对于引用返回类型，在这种情况下将返回<code>null</code> 。
                     </li>
                     <li>在原始返回类型的情况下，这将在运行时导致<code>ResultNotProvidedException</code> 。
                     </li>
                  </ul>
                  <p>如果脆弱的callin绑定中涉及的callin方法肯定没有基本调用，则会出错。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.f">
                  <h4 class="subsect">（f） <span class="title">基地超级电话</span><a class="img" href="s4.3.f.html" title="永久链接到（f）基本超级呼叫"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callin方法<code>rm</code>绑定到基本方法<code>B1.m</code> ，而后者又覆盖了继承的方法<code>B0.m</code> （ <code>B0</code>是<code>B1</code>的超类），则callin方法可以使用特殊形式的基本调用表示为</p>
                  <div class="listing plain"><pre><strong>base.super</strong> .rm（）;</pre></div>
                  <p>这种基本超级调用调用绑定基本方法的超级方法，这里是<code>B0.m</code>此调用不受任何进一步的callin绑定的影响。
                     			
                  </p>
                  <p>基本超级调用绕过原始方法<code>B1.m</code>以及将由常规基本调用触发的其他callin绑定。因此，此构造的任何应用程序都会通过解封装警告进行标记（请参阅<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ）。
                     			
                  </p>
               </div>
               <div class="note">
                  <h5>评论：</h5>基本调用可以在尚未绑定的callin方法中进行。这些方法不知道子角色将绑定到它们的基本方法的名称。多个基本方法也可以绑定到同一个callin方法。因此使用角色方法自己的名称和签名。语言实现将方法名称和签名转换回最初调用的基本方法。
                  		
               </div>
               <h5 class="listing">示例代码（基本调用）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>class</b> ValidatorRole <b>playingBy</b> Po <b>int</b> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <em>callin</em> <b>void</b> checkCoordinate（ <b>int</b> value）{</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>if</b> （值&lt;0）</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>      <em>base</em> .checkCoordinate（-value）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>其他</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>      <em>base</em> .checkCoordinate（value）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>checkCoordinate <b>&lt; -</b> <b>替换</b> setX，setY;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <ul>
                     <li>第2行定义了一个callin方法，它绑定到基类<code>Point</code>两个方法（见第8行）。
                     </li>
                     <li>如果为正（第3行），则检查传递给setX或setY的值。
                     </li>
                     <li>第4行和第6行显示原始方法的调用（基本调用）。当第6行传递原始值时，在否定情况下（第4行），传递的值为正。
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="s4.4">
               <h2 class="sect">§4.4Callin参数映射<a class="img" href="s4.4.html" title="PermaLinkto§4.4Callin参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <div class="subsect depth3" id="s4.4.a">
                  <h4 class="subsect">（a） <span class="title">一般案例参数映射</span><a class="img" href="s4.4.a.html" title="PermaLink到（a）一般案例参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>映射callin参数和结果类型的规则主要与callout绑定（第<a href="s3.2.html" title="§3.2标注参数映射" class="sect">3.2节</a> ）相同，除了反转<code>-&gt;</code>和<code>&lt;-</code>标记以及交换左侧和右侧。
                     	    <br>使用<code>before</code> Callin绑定没有结果映射。对于callin绑定<code>after</code> <code>result</code> ，请参见下面的<a href="#s4.4.c" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.4.b">
                  <h4 class="subsect">（b） <span class="title">callin取代绑定的限制</span><a class="img" href="s4.4.b.html" title="PermaLink to（b）callin替换绑定的限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>参数映射的右侧可以是没有进一步计算的基本方法参数的简单名称，也可以是<em>不</em>包含任何基本方法参数的任意表达式。
                     		<br>每个基本方法参数必须在一个参数映射中显示为简单名称，或者根本不映射。在后一种情况下，原始参数被“隧道化”到基本调用，这意味着，callin方法不会看到参数，但它会按预期传递给基本方法。
                     <br>如果基本方法声明了结果，那么</p>
                  <ul>
                     <li>如果role方法也声明了结果，则<code>result</code>必须映射到自身：<br><code>结果 - &gt;结果</code></li>
                     <li>如果角色方法没有声明结果，则可以将任意表达式映射到结果：<br><code><em>表达</em> - &gt;结果</code><br>如果在这种情况下不存在结果映射，则基本调用的结果是“隧道”并传递给原始调用者（参见上面的<a href="#s4.3.e" title="§4.3。（e）脆弱的愈伤组织结合" class="sect">脆弱的callin绑定（§4.3。（e））</a> ）。
                        
                     </li>
                  </ul>
                  <p>这些规则确保这些绑定在基本调用时是可逆的（ <a href="#s4.3" title="§4.3基本呼叫" class="sect">§4.3</a> ）。
                     			
                  </p>
                  <p>如上所述，一个绝对没有基本调用的callin方法不允许使用脆弱的callin绑定（ <a href="#s4.3.e" title="§4.3。（e）脆弱的愈伤组织结合" class="sect">§4.3。（e）</a> ）（ <a href="#s4.3.b" title="§4.3。（b）缺少基本呼叫" class="sect">§4.3。（b）</a> ）。如果使用结果映射提供基本结果，则callin替换绑定不易碎。
                     			
                  </p>
                  <p>与返回void的基本方法绑定的callin方法不得声明非void结果。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.4.c">
                  <h4 class="subsect">（c） <span class="title">绘制基本方法的结果</span><a class="img" href="s4.4.c.html" title="PermaLink到（c）映射基本方法的结果"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在<code>after</code> callin绑定之后，参数映射的右侧可以使用标识符<code>result</code>来引用基本方法的结果。
                     	
                  </p>
                  <p>但是，callin <code>after</code>绑定不会<em>影响</em>基本方法的结果，因此在callin绑定之后不允许使用<code>-&gt;</code>标记进行映射。对于<code>before</code>使用<code>-&gt;</code>标记的映射已经被<a href="#s4.4.a" title="§4.4.(a) General case parameter mapping" class="sect">§4.4</a>排除了<a href="#s4.4.a" title="§4.4。（a）一般案例参数映射" class="sect">。（a）</a></p>
               </div>
               <div class="subsect depth3" id="s4.4.d">
                  <h4 class="subsect">（d） <span class="title">多种基本方法</span><a class="img" href="s4.4.d.html" title="PermaLink（d）多种基本方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>列出多个基本方法的callin绑定可以使用仅具有以下限制的参数映射：如果应映射任何基本参数，则此参数在所有列出的基本方法指示符中必须具有相同的名称和类型。但是，如果使用单独的callin绑定，则可以定义绑定到相同角色方法的不同基本方法的不同参数映射。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.5">
               <h2 class="sect">§4.5升降<a class="img" href="s4.5.html" title="PermaLinkto§4.5提升和降低"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <p>有关基本定义，请参见<a href="s2.2.html" title="§2.2降低" class="sect">§2.2</a>和<a href="s2.3.html" title="§2.3提升" class="sect">§2.3</a> 。
                  <br>（以下规则是<a href="s3.3.html" title="§3.3升降" class="sect">§3.3</a>中反向形式的规则）</p>
               <div class="subsect depth3" id="s4.5.a">
                  <h4 class="subsect">（a） <span class="title">呼叫目标翻译</span><a class="img" href="s4.5.a.html" title="永久链接到（a）呼叫目标翻译"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由于callin绑定而调用角色方法首先将基础对象<strong>提升</strong>到callin绑定的角色类，以便获得有效的调用目标。这就是为什么不能在由于<em>潜在的约束歧义</em>而无法<em>释放的</em>角色中定义callin绑定的原因（参见上面的<a href="s2.3.4.a.html" title="§2.3.4.(a) Potential ambiguity" class="sect">§4.1。（</a> <a href="#s4.1.b" title="§4.1。（b）先决条件：类绑定" class="sect">b）</a>和<a href="s2.3.4.a.html" title="§2.3.4。（a）潜在的模糊性" class="sect">§2.3.4。（a）</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.b">
                  <h4 class="subsect">（b） <span class="title">参数翻译</span><a class="img" href="s4.5.b.html" title="PermaLink to（b）参数转换"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在callin执行期间，角色方法期望角色对象的每个参数都被隐式<strong>提升</strong>到声明的角色类。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.c">
                  <h4 class="subsect">（c） <span class="title">结果翻译</span><a class="img" href="s4.5.c.html" title="PermaLink到（c）结果翻译"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>从callin方法返回角色对象会隐式<strong>降低</strong>此对象。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.d">
                  <h4 class="subsect">（d） <span class="title">打字规则</span><a class="img" href="s4.5.d.html" title="永久链接到（d）键入规则"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果右侧符合左侧，则通过参数映射（由参数位置隐式或由<code>with</code>子句显式）可以<strong>很好地键入</strong></p>
                  <ul>
                     <li>类型相等</li>
                     <li>隐式原始类型转换</li>
                     <li>亚型多态性</li>
                     <li>翻译多态性，这里： <em>提升</em> ;<br>但是，在<code>replace</code>绑定中，智能提升算法（第<a href="s2.3.3.a.html" title="§2.3.3。（a）静态调整" class="sect">2.3.3节（a）</a> ）的步骤1不适用</li>
                     <li><em>或者</em>通过上述的组合。
                     </li>
                  </ul>
                  <p>如果左侧的值根据上面给出的规则符合右侧，则结果映射（由<code>with</code>子句隐式或显式）是良好类型的，除了这里的转换多态性应用<em>降低</em>而不是提升。
                  </p>
                  <p>这些规则定义了<a href="s2.3.html" title="§2.3提升" class="sect">§2.3中</a>介绍的<strong>翻译多态性</strong> 。
                     			
                  </p>
                  <p>另外，在<code>replace</code> callin绑定时，参数和返回类型的兼容性必须在两个方向上保持。因此，从上面的转换列表中，替换绑定不能应用子类型多态或原始类型转换。如果需要更大的灵活性，可以按照<a href="#s4.10" title="§4.10通用callin绑定" class="sect">§4.10中的</a>定义使用类型参数。
                     	    	
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.e">
                  <h4 class="subsect">（e） <span class="title">角色阵列</span><a class="img" href="s4.5.e.html" title="PermaLink到（e）角色数组"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>对于作为参数<a href="s2.3.d.html" title="§2.3.(d) Lifting of arrays" class="sect">§2.3</a>的角色数组<a href="s2.3.d.html" title="§2.3。（d）提升阵列" class="sect">。（d）相应地</a>适用。对于数组，返回值<a href="s2.2.e.html" title="§2.2。（e）降低阵列" class="sect">§2.2。（e）</a>适用。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.f">
                  <h4 class="subsect">（f） <span class="title">基本电话</span><a class="img" href="s4.5.f.html" title="永久链接到（f）基本呼叫"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>对于基本调用，这些规则再次反转，即基本调用的行为类似于标注绑定。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.6">
               <h2 class="sect">§4.6覆盖访问限制<a class="img" href="s4.6.html" title="PermaLinkto§4.6覆盖访问限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <p>Callin绑定也可能提到不可访问的方法（参见解封装<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ）。由于反向调用方向，这仅适用于<code>callin</code>方法中的基本调用。基本调用可以无限制地访问受保护的基本方法。还允许访问具有私有或默认可见性的基本方法，但是由编译器警告发出信号。
                  		
               </p>
               <div class="note">
                  <h5>评论：</h5>对不可访问的基本方法的基本调用被认为是无害的，因为这是最初预期的方法执行。
                  		
               </div>
               <div class="subsect depth3" id="s4.6.a">
                  <h4 class="subsect">（a） <span class="title">超级班的私人方法</span><a class="img" href="s4.6.a.html" title="PermaLink to（a）来自超类的私有方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><em>（参见<a href="s3.4.d.html" title="§3.4。（d）超级班的私人方法" class="sect">§3.4。（d）</a> ）</em>如果callin绑定应绑定到私有基本方法，则必须使用<code>playedBy</code>在当前角色类绑定<code>playedBy</code>类中定义该方法。
                     <br>如果私有基本功能必须确实是callin-bound，则必须定义由定义私有功能的确切基类播放的角色类。然后可以将绑定到子基类的另一个角色定义为第一个角色的子类。它将继承callin绑定，通过它可以访问所需的功能。
                     
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.7">
               <h2 class="sect">§4.7使用静态方法绑定Callin <a class="img" href="s4.7.html" title="PermaLinkto§4.7与静态方法的Callin绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <p>callin绑定的正常情况是指双方的非静态方法（基础和角色）。此外，在Java中，内部类不能定义静态方法。以下规则放宽了这两个限制：</p>
               <div class="subsect depth3" id="s4.7.a">
                  <h4 class="subsect">（a） <span class="title">静态角色方法</span><a class="img" href="s4.7.a.html" title="PermaLink（a）静态角色方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色类可以定义静态方法（另见<a href="s1.2.1.f.html" title="§1.2.1。（f）静态角色方法" class="sect">§1.2.1。（f）</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.b">
                  <h4 class="subsect">（b） <span class="title">将静态绑定到静态</span><a class="img" href="s4.7.b.html" title="PermaLink to（b）将静态绑定到静态"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定可以将静态角色方法绑定到一个或多个静态基本方法。但是，将静态基本方法绑定到非静态角色方法是错误的，因为这样的绑定需要提升未提供的基础对象。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.c">
                  <h4 class="subsect">（c） <span class="title">之前/之后</span><a class="img" href="s4.7.c.html" title="PermaLink（c）之前/之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>除了上述内容之外，callin绑定<code>before</code>和<code>after</code>还可以将静态角色方法绑定到非静态基本方法。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.d">
                  <h4 class="subsect">（d） <span class="title">更换</span><a class="img" href="s4.7.d.html" title="PermaLink（d）替换"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>与上面的<a href="#s4.7.c" title="§4.7。（c）之前/之后" class="sect">§4.7。（c）</a>相反， <code>replace</code> callin绑定不能将静态角色方法绑定到非静态基本方法。
                     			
                  </p>
               </div>
               <p>下表总结了上面定义的组合：</p>
               <table border="2" class="sep" cellpadding="5" width="80%">
                  <tr class="z1">
                     <td colspan="2" rowspan="2" align="right"><strong>&lt; -</strong>  
                     </td>
                     <td colspan="2" align="center" rowspan="1"><strong>基本方法</strong></td>
                  </tr>
                  <tr class="z1">
                     <td align="center" rowspan="1" colspan="1">静态的</td>
                     <td align="center" rowspan="1" colspan="1">非静态</td>
                  </tr>
                  <tr class="z2">
                     <td rowspan="2" align="center" class="z1" colspan="1"><strong>角色<br>方法</strong></td>
                     <td align="center" class="z1" rowspan="1" colspan="1">静态的</td>
                     <td rowspan="1" colspan="1"><span class="green">好</span></td>
                     <td rowspan="1" colspan="1"><code>before/after</code> ： <span class="green">好的</span><br><code>replace</code> ： <span class="error">非法</span></td>
                  </tr>
                  <tr class="z2">
                     <td align="center" class="z1" rowspan="1" colspan="1">非静态</td>
                     <td rowspan="1" colspan="1"><span class="error">非法</span></td>
                     <td rowspan="1" colspan="1"><span class="green">好</span></td>
                  </tr>
               </table>
               <div class="subsect depth3" id="s4.7.e">
                  <h4 class="subsect">（e） <span class="title">没有压倒一切</span><a class="img" href="s4.7.e.html" title="永久链接到（e）没有覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>由于静态方法不是动态绑定的，因此<i>覆盖</i>不适用于普通语义。关于callin绑定，这具有以下结果（假设<code>RMid</code>扮演的角色<code>BMid</code>加上其超类<code>BSuper</code>及其子类<code>BSub</code> 。
                     			
                  </p>
                  <ol>
                     <li>如果静态基方法<code>BMid.m</code>被callin绑定绑定，则这对<code>BSub</code>任何方法<code>m</code>都没有影响。
                     </li>
                     <li>如果一个呼唤结合提到的方法<code>m</code> ，其不存在于<code>BMid</code>但解析为在静态方法<code>BSuper</code>结合仅影响调用作为<code>BMid.m()</code>但不是<code>BSuper.m()</code> 。如果后一个调用也应该受到影响，则callin绑定必须出现在绑定到<code>BSuper</code>的角色类中，而不是<code>BMid</code> 。</li>
                     <li>为了绑定具有相同签名的两个静态基本方法，一个在另一个的子类中定义，必须定义两个角色，其中一个角色优化另一个角色的<code>playedBy</code>子句（例如： <code>public class RSub extends RMid playedBy BSub</code> ）。现在，每个角色都可以绑定到其直接基类中可访问的静态基本方法。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="s4.8">
               <h2 class="sect">§4.8Callin优先权<a class="img" href="s4.8.html" title="PermaLink至§4.8Callin优先级"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <div class="syntaxlink"><a href="sA.8.html" title="§A.8优先声明" class="syntax">→语法§A.8</a></div>
               <p>如果来自同一团队的多个callins引用相同的基本方法并且具有相同的callin修饰符（ <code>before</code> ， <code>after</code>或<code>replace</code> ），则必须使用优先声明声明callin绑定应被触发的顺序。
                  		
               </p>
               <div class="subsect depth3" id="s4.8.a">
                  <h4 class="subsect">（a） <span class="title">优先权声明</span><a class="img" href="s4.8.a.html" title="永久链接到（a）优先声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>优先级声明由关键字<code>precedence</code>后跟一个引用callin绑定的名称列表组成<a href="#s4.1.e" title="§4.1.(e) Named callin binding" class="sect">（</a>有关命名的callin绑定，请参阅<a href="#s4.1.e" title="§4.1。（e）命名为callin绑定" class="sect">§4.1。（e）</a> ）。
                     		
                  </p>
                  <div class="listing plain"><pre><b>优先级</b> callinBinding1，callinBinding2;</pre></div>
                  <p>优先声明仅在角色或团队类中合法。<br>优先级声明中元素的顺序决定了它们在调度期间的<strong>优先级</strong> ，类似于基于激活多个团队实例的优先级（第<a href="s5.1.html" title="§5.1团队激活的影响" class="sect">5.1节</a> ）。这意味着<code>before</code>使用最高优先级触发器<code>before</code>和<code>replace</code>绑定<code>before</code> ，而<code>after</code>具有最高优先级的绑定<code>after</code>触发最后。对于绑定优先级（与基于类的优先级相反，参见<a href="#s4.8.c" title="§4.8。（c）基于类的优先顺序" class="sect">下面的§4.8。（c）</a> ），它引用绑定<code>after</code> ，优先级声明还必须使用<code>after</code>关键字来提醒程序员执行顺序与文本顺序相反。
                     			
                  </p>
                  <div class="listing plain"><pre>importantExecuteLast <b>之后的</b> <b>优先级</b> ，lessImportantExecuteEarlier;</pre></div>
               </div>
               <div class="subsect depth3" id="s4.8.b">
                  <h4 class="subsect">（b） <span class="title">合格和不合格的名称</span><a class="img" href="s4.8.b.html" title="PermaLink to（b）合格和不合格的名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在角色类中，callin绑定可以由其非限定名称引用。团队类中的优先声明必须使用声明角色类的名称限定callin名称。具有嵌套团队的团队可以连接角色类名称。合格的callin名称的元素用“。”分隔。
                     		<br>callin绑定必须在限定前缀指定的角色中找到，或者在非限定名称的封闭角色中找到，或者在此角色的任何超类中找到（包括隐式超类<a href="s1.3.1.html" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.c">
                  <h4 class="subsect">（c） <span class="title">基于类别的优先权</span><a class="img" href="s4.8.c.html" title="PermaLink到（c）基于类的优先级"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在团队级别，优先级声明可能包含角色类名称，而没有明确提及callin绑定，以便引用该角色的所有callin绑定。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.d">
                  <h4 class="subsect">（d） <span class="title">多重优先权陈述</span><a class="img" href="s4.8.d.html" title="PermaLink到（d）多个优先级语句"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>所有优先级声明都在最外层的团队中收集。在该级别，使用C3算法<a href="#fn3-c3-algorithm" class="int">[3]</a>合并涉及相同基本方法的所有优先级声明。合并优先级声明时，嵌套声明的优先级高于外部声明。对于在相同嵌套级别的多个声明，词法排序确定优先级。
                     			
                  </p>
                  <p>在任何时候，C3算法将确保合并后的结果顺序与每个单独的优先声明一致。声明不能由C3算法合并的不兼容优先级列表是错误的。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.e">
                  <h4 class="subsect">（e）具有<span class="title">约束力</span><a class="img" href="s4.8.e.html" title="永久链接到（e）绑定覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>优先声明可能与重写callin绑定相冲突（参见<a href="#s4.1.e" title="§4.1。（e）命名为callin绑定" class="sect">§4.1。（e）</a> ）：对于每一个callin绑定覆盖另一个callin绑定的callin绑定，优先声明不适用，因为动态绑定已经选择了一个callin捆绑。
                     		<br>在优先声明中<i>明确提到</i>这样一对重写的callin绑定是错误的。
                     		<br>当基于类的优先级声明<i>隐式引用</i>被同一优先级声明中的任何其他callin绑定覆盖的callin绑定时，这不会影响这一事实，即最具体的callin绑定会覆盖不太具体的callin绑定。
                     			
                  </p>
               </div>
               <h5 class="listing">Callin绑定示例</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>类</b>双对数<b>在</b> <b>playedBy</b>数据<b>基</b> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>callin</b> <b>void</b> log（String what）{</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>System.out.println（“输入”+什么）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>base.log（what.toLowerCase（））;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>System.out.println（“离开”+什么）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>void</b> log（String what） <b>&lt; -</b> <b>replace</b> <b>void</b> login（String uid，String passwd）</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    <b>与</b> {what <b>&lt; -</b> uid}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>（ <b>新</b>数据库（））。login（“Admin”，“Passwd”）;</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <p>如果callin绑定处于活动状态（参见<a href="s5.html" title="§5团队激活" class="sect">§5</a> ），则：</p>
                  <ul>
                     <li>第10行中的调用被角色<code>LogLogin</code>方法<code>log</code>拦截。
                     </li>
                     <li>的通话对象<code>log</code>是类型的角色<code>LogLogin</code>其通过提升原始呼叫目标（类型的创建<code>Database</code> ）来<code>LogLogin</code> 。
                     </li>
                     <li>只有参数<code>uid</code>传递给<code>log</code> （绑定到形式参数<code>what</code> ）。
                     </li>
                     <li>在方法<code>log</code> ，基本调用（第4行）调用原始方法传递修改后的uid（转换为小写，参见第4行）和未修改的密码，由于第8行中的参数映射，该密码对callin方法隐藏。
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="s4.9">
               <h2 class="sect">§4.9Callin继承<a class="img" href="s4.9.html" title="PermaLinkto§4.9Callin继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <p>本节定义了callin绑定和callin方法如何与继承相关。
                  		
               </p>
               <div class="sect depth3" id="s4.9.1">
                  <h3 class="sect">§4.9.1基础侧继承<a class="img" href="s4.9.1.html" title="PermaLinkto§4.9.1基本侧继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s4.9">↑§4.9</a></span></h3>
                  <p>通常，callin绑定会影响其绑定碱基的所有子类型。具体来说，如果绑定到基类型<code>B</code>的角色类型<code>R</code>定义了callin绑定<code>rm &lt;- <i>callin_modifier</i> bm</code> ，则以下规则适用：</p>
                  <div class="subsect depth4" id="s4.9.1.a">
                     <h4 class="subsect">（a） <span class="title">对子类的影响</span><a class="img" href="s4.9.1.a.html" title="PermaLink（a）对子类的影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>callin绑定还影响作为<code>B</code>的子类型的任何类型<code>BSub</code>实例。如果<code>BSub</code>覆盖绑定的基本方法<code>bm</code> ， <code>BSub</code>覆盖的版本通常也会受到影响。但是，如果<code>bm</code>从其超级版本<a href="#s4.9.3.b" title="§4.9.3.(b) Capturing covariant base methods" class="sect">协同</a>重新定义返回类型，则callin绑定必须明确指定协变子类版本是否也应受到影响（参见<a href="#s4.9.3.b" title="§4.9.3。（b）捕获协变基方法" class="sect">§4.9.3。（b）</a> ）。
                        
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.1.b">
                     <h4 class="subsect">（b） <span class="title">对超级班级没有影响</span><a class="img" href="s4.9.1.b.html" title="PermaLink到（b）对超类没有影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>即使方法<code>bm</code>从超类继承或覆盖继承的方法，绑定也不会影响任何超类型<code>B</code>的实例。这确保了由于callin绑定而调度到角色方法总是提供至少具有在角色的<code>playedBy</code>子句中声明的类型的基本实例。
                        
                     </p>
                  </div>
                  <p>有关静态方法的相应定义，请参见<a href="#s4.7.e" title="§4.7。（e）没有压倒一切" class="sect">§4.7。（e）</a> 。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="s4.9.2">
                  <h3 class="sect">§4.9.2角色侧继承<a class="img" href="s4.9.2.html" title="PermaLinkto§4.9.2角色侧继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s4.9">↑§4.9</a></span></h3>
                  <p><code>R</code>任何子类型都继承了给定的callin绑定（用于覆盖绑定，参见<a href="#s4.8.e" title="§4.8。（e）绑定覆盖" class="sect">§4.8。（e）</a> ）。如果子角色覆盖角色方法<code>rm</code>则在触发callin绑定时将考虑动态分派。
                     
                  </p>
               </div>
               <div class="sect depth3" id="s4.9.3">
                  <h3 class="sect">§4.9.3协变返回类型<a class="img" href="s4.9.3.html" title="PermaLinkto§4.9.3协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s4.9">↑§4.9</a></span></h3>
                  <p>从版本5开始，Java支持对方法返回类型的协变重定义（参见<a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.5" class="ext">JLS 8.4.5</a> ）。<code>callin</code>方法<em>不</em>支持此功能（ <a href="#s4.9.3.a" title="§4.9.3。（a）没有协变的callin方法" class="sect">§4.9.3。（a）</a> ）。如果具有协同重新定义返回类型的基本方法将受到callin绑定的约束，则后续规则将确保保留类型安全性。必须考虑两个<em>限制</em>因素：</p>
                  <ol>
                     <li>当callin方法发出基本调用或调用其tsuper版本时，此调用必须生成一个值，该类型的类型与封闭方法声明的返回类型兼容。
                        				
                     </li>
                     <li>如果替换绑定角色方法返回的值不是基本调用的结果，则必须确保返回值实际满足绑定基本方法的声明签名。
                        				
                     </li>
                  </ol>
                  <div class="subsect depth4" id="s4.9.3.a">
                     <h4 class="subsect">（a） <span class="title">没有协变的callin方法</span><a class="img" href="s4.9.3.a.html" title="永久链接到（a）没有协变的callin方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>使用<code>callin</code>修饰符声明的覆盖继承方法的方法不得重新定义与继承方法相关的返回类型。这反映了这样一个事实，即继承的callin绑定在绑定到新的重写角色方法时应保持类型安全。将协变角色方法绑定到原始基本方法将破坏上面的约束（1）。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.3.b">
                     <h4 class="subsect">（b） <span class="title">捕获协变基方法</span><a class="img" href="s4.9.3.b.html" title="PermaLink to（b）捕获协变基本方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>如果callin绑定确实不仅影响指定的基本方法，而且还覆盖了协同重新定义返回类型的覆盖版本，则绑定必须指定基本方法的返回类型，并在类型名称后附加“+”，如</p>
                     <div class="listing plain"><pre><b>void</b> rm（） <b>&lt; -</b> <b>在</b> <em>RT +</em> bm（）之前;</pre></div>
                     <p>没有“+”符号，绑定只会捕获其返回类型正好是<code>RT</code>基本方法;通过附加“+”，也接受<code>RT</code>子类型作为声明的返回类型。
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.3.c">
                     <h4 class="subsect">（c） <span class="title">协变替换绑定</span><a class="img" href="s4.9.3.c.html" title="PermaLink到（c）协变替换绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>当使用<a href="#s4.9.3.b" title="§4.9.3。（b）捕获协变基方法" class="sect">§4.9.3。（b）</a>的语法在与<code>replace</code>修饰符的callin绑定中捕获具有协变返回类型的基本方法时，必须使用free类型参数指定role方法，如下所示：</p>
                     <div class="listing plain"><pre><em>&lt;E <b>extends</b> RT&gt; E</em> rm（） <b>&lt; -</b> <b>替换</b> RT + bm（）;</pre></div>
                     <p>此callin绑定引用的角色方法<code>rm</code>必须使用类型参数使用相同类型的返回类型。从这种方法返回的唯一可能的类型<code>E</code>非空值是base-call或tsuper-call提供的值。<br>此规则强制执行上面的约束（2）。<br>请注意，此规则在<a href="#s4.10" title="§4.10通用callin绑定" class="sect">§4.10中</a>进一步概括。
                        				
                     </p>
                     <h5 class="listing">绑定参数角色方法</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>公共</b> <b>类</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>SuperBase foo（）{ <b>返回</b>此; }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>    <b>void</b> check（）{System.out.print（“OK”）; }</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">五</td>
                              <td><pre><b>公共</b> <b>类</b> SubBase <b>扩展</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>@覆盖</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>SubBase foo（）{ <b>return</b> this; }</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">8</td>
                              <td><pre>    <b>void</b> print（）{System.out.print（“SubBase”）; }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">9</td>
                              <td><pre>字符串测试（）{</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">10</td>
                              <td><pre>。this.foo（）打印（）; <span class="comment">// print（）需要一个SubBase</span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">11</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">12</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">13</td>
                              <td><pre></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">14</td>
                              <td><pre><b>公共</b> <b>团队</b> <b>班</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">15</td>
                              <td><pre>    <b>受保护的</b> <b>类</b> R <b>playingBy</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">16</td>
                              <td><pre>        <b>callin</b> &lt;E <b>extends</b> SuperBase&gt; E ci（）{</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">17</td>
                              <td><pre>E result = base.ci（）;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">18</td>
                              <td><pre>result.check（）; <span class="comment">//通过类型绑定的SuperBase在E上提供check（）</span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">19</td>
                              <td><pre>			<b>返回</b>结果;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">20</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">21</td>
                              <td><pre>&lt;E <b>extends</b> SuperBase&gt; E ci（） <b>&lt; -</b> <b>替换</b> SuperBase + foo（）;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">22</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">23</td>
                              <td><pre>}</pre></td>
                           </tr>
                        </table>
                     </div>
                     <div class="codecomment">
                        <h5>说明：</h5>
                        <ul>
                           <li>第7行中的方法<code>SubBase.foo</code>将返回类型从<code>SuperBase</code> （继承版本）重新定义为<code>SubBase</code> ，因此像第10行中的方法调用这样的客户端必须安全地假设返回值始终符合<code>SubBase</code> 。
                              						
                           </li>
                           <li>第21行中的callin绑定通过将<code>SuperBase+</code>指定为预期的返回类型，显式捕获了两个版本的<code>foo</code> 。因此，如果<code>MyTeam</code>的实例在第10行的方法调用中处于活动状态，则即使静态地知道此调用返回<code>SubBase</code>类型的值，也会截获对<code>foo</code>调用。
                              						
                           </li>
                           <li>第16-20行中的callin方法具有静态未知的返回类型，但返回类型由类型变量<code>E</code> 。由于已知基本调用具有与其封闭方法完全相同的签名，因此基本调用提供的值与<code>E</code>类型相同，因此可以从<code>ci</code>安全地返回。
                              							<em>注意，</em>没有其他非空值可以具有类型<code>E</code></li>
                           <li>通过指定<code>SuperBase</code>作为上界类型<code>E</code>的呼唤方法<code>ci</code>可以调用在类型中声明的任何方法<code>SuperBase</code>上类型的任何值<code>E</code> 。有关示例，请参阅第18行的<code>check</code>电话。
                              						
                           </li>
                        </ul>
                        <p><em>顺便指出，上述例子中使用类型<code>SuperBase</code>在散漫方式：角色内<code>R</code>此类型使用约束<code>playedBy</code> <strong>和</strong>相同类型也直接使用（作为上限<code>E</code> ）。这被认为是错误的样式，如果使用基本导入导入<code>SuperBase</code> ，则禁止使用它（ <a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ）。在这里，这个规则被忽略只是为了保持示例小。
                              						</em></p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s4.10">
               <h2 class="sect">§4.10通用callin绑定<a class="img" href="s4.10.html" title="PermaLinkto§4.10Genericcallin bindings"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4</a></span></h2>
               <p>如<a href="#s4.5.d" title="§4.5。（d）打字规则" class="sect">§4.5中所述。（d）</a>替换绑定不支持任一方向的子类型多态性。另一方面，如果这些基本方法具有不同的签名，则将几个基本方法绑定到相同的<code>callin</code>方法可能需要更多的灵活性。这就是类型参数的用武之地，允许通用的<code>callin</code>方法及其与具有不同签名的基本方法的绑定。<br>请注意，此规则是规则<a href="#s4.9.3.c" title="§4.9.3。（c）协变替换绑定" class="sect">§4.9.3。（c）</a>的概括。
                  		
               </p>
               <p>此外，任何callin绑定（before，replace，after）都可以声明一个或多个类型参数，用于传播绑定基本方法的类型参数（ <a href="#s4.10.e" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ）。
                  		
               </p>
               <div class="subsect depth3" id="s4.10.a">
                  <h4 class="subsect">（a） <span class="title">新鲜型参数</span><a class="img" href="s4.10.a.html" title="PermaLink to（a）Fresh类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callin方法声明了用于捕获协变返回类型的类型参数<code>&lt;T&gt;</code> ，则此类型<code>T</code>可用于指定恰好一个参数的类型或返回类型。如果在<code>callin</code>方法的多个位置使用类型参数，则它不被视为<em>新类型参数</em> ，因此不能绑定到协变返回类型（参见<a href="#s4.10.d" title="§4.10。（d）绑定到类型参数" class="sect">§4.10。（d）</a> ）。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.10.b">
                  <h4 class="subsect">（b） <span class="title">类型界限</span><a class="img" href="s4.10.b.html" title="PermaLink到（b）类型边界"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定的类型参数可以由<code>&lt;T extends C&gt;</code>的上限界定。在这种情况下， <code>T</code>只能由符合上限<code>C</code>类型实例化。</p>
               </div>
               <div class="subsect depth3" id="s4.10.c">
                  <h4 class="subsect">（c） <span class="title">通用替换绑定</span><a class="img" href="s4.10.c.html" title="PermaLink到（c）Generic替换绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>根据上述规则的通用<code>callin</code>方法使用替换绑定来绑定，该绑定声明相同数量的类型参数，其中标识绑定的类型参数及其callin方法。如果<code>callin</code>方法为其类型参数声明了边界，那么应该替换绑定。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.10.d">
                  <h4 class="subsect">（d） <span class="title">绑定到类型参数</span><a class="img" href="s4.10.d.html" title="PermaLink到（d）绑定到类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以使用新类型参数来捕获要绑定的基本方法中的任意类型。对于每个绑定的基本方法，可以不同地实例化类型参数。通过这种类型参数实例化，角色和基本签名中的类型实际上是相同的，从而满足双向可替换性的要求。
                     			
                  </p>
               </div>
               <p>在通用<code>callin</code>方法的主体内，不必遵循进一步的规则，因为新类型变量实际上保证，角色方法不能用不同的对象替换原始值（初始参数或基本调用结果），因为没有类型存在，保证符合类型参数。但是，类型绑定允许角色方法调用所提供对象的方法。
                  		
               </p>
               <h5 class="listing">通用替换绑定</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>班</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>    <b>受保护的</b> <b>类</b> R <b>playingBy</b>数字{</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>        <b>callin</b> &lt;E <b>extends</b> Shape，F <b>extends</b> Shape&gt; E ci（F arg）{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>E result = base.ci（arg）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>            <span class="error">result = arg; //非法，类型E和F是不可通约的</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>            <span class="error">arg =结果; //非法，类型E和F是不可通约的</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>            <b>int</b> size = arg.getSize（）; <span class="comment">// getSize（）可通过类型绑定Shape在F上使用</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>result.resize（大小）; <span class="comment">//通过类型绑定Shape在E上可以使用resize（）</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>            <b>返回</b>结果; <span class="comment">//只存在两个合法值： <code>result</code>和<code>null</code></span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>&lt;E <b>延伸</b>形状，F <b>延伸</b>形状&gt;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>E ci（F arg） <b>&lt; -</b> <b>替换</b> Rectangle getBoundingBox（Shape original），</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre>矩形拉伸（方形原创）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>说明：</h5>这些声明生成两个版本的<code>callin</code>方法<code>ci</code> ：<ol>
                     <li><code>矩形ci（形状arg）</code></li>
                     <li><code>矩形ci（方形arg）</code></li>
                  </ol>在<code>callin</code>方法中，以下观察结果如下：<ul>
                     <li>第5行对于第一个签名是非法的，因为<code>Shape</code>不符合<code>Rectangle</code></li>
                     <li>第6行对于第二个签名是非法的，因为<code>Rectangle</code>不符合<code>Square</code></li>
                     <li>其他一切都是类型安全的。</li>
                  </ul>
               </div>
               <div class="subsect depth3" id="s4.10.e">
                  <h4 class="subsect">（e） <span class="title">传播类型参数</span><a class="img" href="s4.10.e.html" title="永久链接到（e）传播类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callin绑定绑定到泛型基本方法，则必须通过使用类型参数声明callin绑定，将基本方法的任何类型参数传播到角色方法中。通过将基本方法的类型参数与callin绑定的类型变量匹配，该通用性通过callin绑定传播。
                     			
                  </p>
                  <div class="listing  frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>class</b> MyBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>&lt;T&gt; T getIt（T it）{ <b>return</b> it; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>	<b>受保护的</b> <b>类</b> MyRole <b>playingBy</b> MyBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>		<b>callin</b> &lt;U&gt; U rm（U a）{ <b>return</b> base.rm（a）; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>&lt;U&gt; U rm（U a） <b>&lt; -</b> <b>替换</b> U getIt（U it）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>说明：</h5>callin绑定声明了一个类型参数<code>&lt;U&gt;</code> ，它用于匹配<code>getIt</code>签名中所有出现的<code>T</code>因此， <code>rm</code>的实现使用类型<code>U</code> ，其方式与<code>getIt</code>使用<code>T</code>完全相同。</div>
               </div>
            </div>
            <div class="aux" id="aux4.2">
               <h4 class="aux"><span class="toplink"><a href="#s4">未决</a></span>问题： <span class="toplink"><a href="#s4">↑§4</a></span></h4>
               <p>用于指定基本方法集的查询语言（ <a href="#s4.1.d" title="§4.1。（d）多种基本方法" class="sect">§4.1。（d）</a> ）尚未最终确定。在这个版本的OTJLD的<a href="s8.html" title="§8加入点查询" class="sect">§8</a>充当将确定在未来的一个连接点查询语言部分的占位符。
               </p>
            </div>
            <div class="aux" id="aux4.1">
               <h4 class="aux">参考文献： <span class="toplink"><a href="#s4">↑§4</a></span></h4>
               <p id="fn3-c3-algorithm">[3] Kim Barrett，Bob Cassels，Paul Haahr，David A. Moon，Keith Playford，P。Tucker Withington。<em>Dylan的单调超类线性化</em> 。OOPSLA '96：关于面向对象编程，系统，语言和应用的第11届ACM SIGPLAN会议论文集，第69-82页，1996年。
                  		
               </p>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s3.html" rel="prev">&lt;&lt;§3标注绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s5.html" rel="next">§5团队激活&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>