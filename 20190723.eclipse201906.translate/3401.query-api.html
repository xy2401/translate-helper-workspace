<html lang="zh-Hans" >
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>VIATRA查询运行时</title>
<link rel="stylesheet" href="asset?aid=0">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article" >
<div id="header">
<h1>VIATRA查询运行时</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本文档概述了VIATRA Query的Java API，描述了可帮助您将其集成到任何Java应用程序中的功能。此页面是详细的技术文档，有关基本用法信息，请参阅<a href="tutorial.html#_using_queries_programmatically">入门教程</a> 。</p>
</div>
<div class="paragraph">
<p>使用VIATRA查询API的最典型方法是使用VIATRA查询项目的“src-gen”文件夹中生成的代码。这个生成的代码提供了对Java代码中大多数VIATRA Query功能的简单和类型安全的访问。</p>
</div>
<div class="paragraph">
<p>VIATRA Query还支持“动态”通用API，允许在不依赖生成代码的情况下使用模式。通用API与“生成的”API的基类共享功能，并且对于大多数情况，两者之间没有性能差异。这个经验法则的一个值得注意的例外是<code>check() expressions</code> ，其中通过生成的API调用的生成代码将执行Java代码而不是解释Xbase。</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#_most_important_classes_and_their_relationships">1。最重要的课程和他们的关系</a>
<ul class="sectlevel2">
<li><a href="#_match">1.1。比赛</a></li>
<li><a href="#sec-querymatcher">1.2。匹配</a></li>
<li><a href="#_query_specification">1.3。查询规范</a></li>
</ul>
</li>
<li><a href="#_lifecycle_management">2。生命周期管理</a></li>
<li><a href="#_typical_programming_patterns">3。典型的编程模式</a>
<ul class="sectlevel2">
<li><a href="#_loading_an_instance_model_and_executing_a_query">3.1。加载实例模型并执行查询</a></li>
<li><a href="#_using_the_matchprocessor">3.2。使用MatchProcessor</a></li>
<li><a href="#_matching_with_partially_bound_input_parameters">3.3。与部分绑定的输入参数匹配</a></li>
<li><a href="#_initialization_of_pattern_groups">3.4。模式组的初始化</a></li>
</ul>
</li>
<li><a href="#_parsing_patterns">4。解析模式</a></li>
<li><a href="#_viatra_query_base">5。VIATRA查询库</a>
<ul class="sectlevel2">
<li><a href="#_extracting_reachability_paths_from_transitive_closure">5.1。从传递闭包中提取可达性路径</a></li>
</ul>
</li>
<li><a href="#sec-query-scopes">6。查询范围</a>
<ul class="sectlevel2">
<li><a href="#_using_filtered_input_models_during_pattern_matching">6.1。在模式匹配期间使用过滤的输入模型</a></li>
</ul>
</li>
<li><a href="#_pattern_matching_with_local_search">7。与本地搜索匹配的模式</a>
<ul class="sectlevel2">
<li><a href="#sec-localsearch">7.1。使用本地搜索</a></li>
<li><a href="#_parameterizing_local_search">7.2。参数化本地搜索</a></li>
<li><a href="#_cost_function">7.3。成本函数</a></li>
<li><a href="#_known_limitations">7.4。已知限制</a></li>
</ul>
</li>
<li><a href="#sec-query-hints">8。提供查询评估提示</a></li>
<li><a href="#_query_specification_registry">9。查询规范注册表</a>
<ul class="sectlevel2">
<li><a href="#_basic_usage">9.1。基本用法</a></li>
<li><a href="#_advanced_usage">9.2。高级用法</a></li>
</ul>
</li>
<li><a href="#_performance_tuning_and_special_engine_modes">10。性能调整和特殊引擎模式</a>
<ul class="sectlevel2">
<li><a href="#_query_groups_and_coalescing_model_traversals">10.1。查询组和合并模型遍历</a></li>
<li><a href="#_delaying_query_result_updates">10.2。延迟查询结果更新</a></li>
<li><a href="#_run_once_query_engine">10.3。一次运行查询引擎</a></li>
</ul>
</li>
<li><a href="#_logging_in_viatra_query">11。登录VIATRA查询</a>
<ul class="sectlevel2">
<li><a href="#_configuration_problems">11.1。配置问题</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_most_important_classes_and_their_relationships"><a class="link" href="#_most_important_classes_and_their_relationships">1。最重要的课程和他们的关系</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于每个模式定义，VIATRA查询工具都会生成几个类：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">QuerySpecification</dt>
<dd>
<p>表示API规范的VQL文件中的模式。不需要用于基本查询，仅用于通用API和微调设置。</p>
</dd>
<dt class="hdlist1">比赛</dt>
<dd>
<p>将查询规范的参数绑定到模型中的元素;表示查询的单个结果或过滤结果</p>
</dd>
<dt class="hdlist1">匹配</dt>
<dd>
<p>提供检索查询结果的功能</p>
</dd>
<dt class="hdlist1">MatchProcessor</dt>
<dd>
<p>用于处理功能样式的查询结果（类似于Java Stream处理）。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_match"><a class="link" href="#_match">1.1。比赛</a></h3>
<div class="paragraph">
<p><strong>Match对象</strong>表示模式的单个匹配，即对象的元组，其成员指向与模式匹配的实例模型（或标量值）的对应元素。它本质上是一个数据传输对象，用于从VIATRA Query中提取查询结果信息，使用SQL类比，您可以将其视为查询结果集的一个“行”。生成的字段对应于模式标头参数。</p>
</div>
<div class="paragraph">
<p>您还可以使用<strong>Match</strong>对象为查询指定固定的输入参数（而其他字段可以不指定） - 类似于接受输入参数绑定的“准备好的”SQL语句。在这种情况下，输入Match将充当过滤器（掩码），您查询的结果也将是此类的实例（其中参数已经具有输入中给出的值）。有关详细信息，请参阅下面的TODO。</p>
</div>
<div class="paragraph">
<p>下面的代码示例显示了为<strong>applicationInstances</strong>模式生成的<code>ApplicationInstancesMatch</code>类（使用单个参数AI）。生成的类通过<code>BasePatternMatch</code>内部实现类实现接口<code>IPatternMatch</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">模式匹配器返回的不可变匹配从不包含null作为参数值。可变匹配，例如为过滤创建的匹配使用null来表示未设置的值;但这些匹配永远不会从匹配器返回。
</td>
</tr>
</table>
</div>
<div id="query-api-match" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public abstract class ApplicationInstancesMatch extends BasePatternMatch {
  /** getters and setters for each parameter */
  public ApplicationInstance getAI();
  public void setAI(final ApplicationInstance pAI);

  public String prettyPrint();
  public int hashCode();
  public boolean equals(final Object obj);

  /** "reflective" calls **/
  public ApplicationInstancesQuerySpecification specification();
  public String patternName();
  public List&lt;String&gt; parameterNames();
  public Object get(final String parameterName);
  public boolean set(final String parameterName, final Object newValue);
  public Object[] toArray();
  public ApplicationInstancesMatch toImmutable();

  /* Mutable and immutable match instantiation */
  public static ApplicationInstancesMatch newEmptyMatch();
  public static ApplicationInstancesMatch newMutableMatch(final ApplicationInstance pAI);
  public static ApplicationInstancesMatch newMatch(final ApplicationInstance pAI);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec-querymatcher"><a class="link" href="#sec-querymatcher">1.2。匹配</a></h3>
<div class="paragraph">
<p><strong>Matcher</strong>是VIATRA Query API的主要入口点，具有特定于模式的查询方法。它提供了对VIATRA Query的三个主要功能的访问：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，它提供<strong>了</strong>为给定的查询引擎<strong>初始化模式匹配器</strong>的方法。</p>
</li>
<li>
<p>在引擎初始化之后，Matcher提供<strong>getter方法来检索匹配集的内容</strong> 。为了便于迭代匹配集，它还提供了一种便捷方法（ <code>forEachMatch</code> ），因为这是我们观察中最常见的用例。当然它包含其他方便的功能（例如： <code>countMatches</code> ， <code>hasMatch</code> ）来帮助集成。</p>
</li>
<li>
<p>最后，它提供了以事件驱动的方式有效<strong>跟踪匹配集中的变化的</strong>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的示例生成的源代码演示了从运行示例为<strong>eClassNames</strong>模式生成的<strong>ApplicationInstancesMatcher</strong>类。matcher类实现了ViatraQueryMatcher泛型接口，其实现代码扩展了<code>BaseGeneratedMatcher</code>内部类，继承了几个有用的方法。在下面的清单中，我们展示了一些实际上不是生成代码的一部分的方法，但是符合<code>ViatraQueryMatcher</code>接口并且可以通过<code>BaseGeneratedMatcher</code>继承来<code>BaseGeneratedMatcher</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">VIATRA的模式匹配器API永远不会返回null，但会将null作为输入参数处理。这意味着，处理匹配时无需检查null。
</td>
</tr>
</table>
</div>
<div id="query-api-matcher" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class EClassNamesMatcher implements ViatraQueryMatcher&lt;EClassNamesMatch&gt; {
  /** factory method **/
  public static ApplicationInstancesMatcher on(final ViatraQueryEngine engine);

  /** access to match set **/
  public Collection&lt;ApplicationInstancesMatch&gt; getAllMatches(); // inherited
  public Collection&lt;ApplicationInstancesMatch&gt; getAllMatches(final ApplicationInstance pAI);
  public Stream&lt;ApplicationInstancesMatch&gt; streamAllMatches(); // inherited
  public Stream&lt;ApplicationInstancesMatch&gt; streamAllMatches(final ApplicationInstance pAI);
  public Optional&lt;ApplicationInstancesMatch&gt; getOneArbitraryMatch(); // inherited
  public Optional&lt;ApplicationInstancesMatch&gt; getOneArbitraryMatch(final ApplicationInstance pAI);
  public boolean hasMatch(); // inherited
  public boolean hasMatch(final ApplicationInstance pAI);
  public int countMatches(); // inherited
  public int countMatches(final ApplicationInstance pAI);

  /** Retrieve the set of values that occur in matches.**/
  public Set&lt;ApplicationInstance&gt; getAllValuesOfAI() {}

  /** iterate over matches using a lambda **/
  public void forEachMatch(Consumer&lt;? super EClassNamesMatch&gt; processor); // inherited
  public void forEachMatch(final ApplicationInstance pAI, final Consumer&lt;? super ApplicationInstancesMatch&gt; processor);
  public void forOneArbitraryMatch(Consumer&lt;? super EClassNamesMatch&gt; processor); // inherited
  public boolean forOneArbitraryMatch(final ApplicationInstance pAI, final Consumer&lt;? super ApplicationInstancesMatch&gt; processor) {}

  /** Returns a new (partial) Match object for the matcher.
   *  This can be used e.g. to call the matcher with a partial match. **/
  public ApplicationInstancesMatch newMatch(final ApplicationInstance pAI);

  /** Access query specification */
  public static IQuerySpecification&lt;ApplicationInstancesMatcher&gt; querySpecification();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从VIATRA 2.0开始，匹配器API也返回匹配流。这些流可用于在功能上处理流，极大地扩展了自早期版本以来可用的forEachMatch调用提供的类似功能。此外，依赖这些流可以提供更好的性能：（1）使用这些流不需要复制匹配集，并且（2）允许模式匹配器推迟匹配集计算，直到下一个匹配是必要的。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果在匹配处理期间更改了基础模型，则新的基于Stream的API无法处理。如果需要匹配集的快照，则要么依赖类似的<code>getAllMatches()</code>调用，要么在最终用户代码中收集流的结果。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_query_specification"><a class="link" href="#_query_specification">1.3。查询规范</a></h3>
<div class="paragraph">
<p>特定于模式的规范，可以以类型安全的方式实例化Matcher类。您可以通过Matcher类的specification（）方法获取它的实例。实例化Matcher的推荐方法是使用<code>ViatraQueryEngine</code> 。在这两种情况下，如果模式已经注册（在Notifier方法的情况下具有相同的根），则仅创建指向现有引擎的轻量级引用。</p>
</div>
<div class="paragraph">
<p>代码示例扩展了BaseGeneratedQuerySpecification类。</p>
</div>
<div id="query-api-queryspecification" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * A pattern-specific query specification that can instantiate EClassNamesMatcher in a type-safe way.
 */
public final class ApplicationInstancesQuerySpecification extends BaseGeneratedEMFQuerySpecification&lt;ApplicationInstancesMatcher&gt; {

  /** Singleton instance access */
  public static ApplicationInstancesQuerySpecification instance();

  /** Instantiate matches and matchers */
  public ApplicationInstancesMatcher instantiate();
  public ApplicationInstancesMatch newEmptyMatch();
  public ApplicationInstancesMatch newMatch(final Object... parameters);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lifecycle_management"><a class="link" href="#_lifecycle_management">2。生命周期管理</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在VIATRA Query中，所有模式匹配（查询评估）都在<strong>ViatraQueryEngine</strong>实例中执行， <strong>这些</strong>实例通过用户友好生成的公共API类访问。可以通过<strong>EngineManager</strong>单例类访问和管理与模式关联的<strong>ViatraQueryEngine</strong> ，以跟踪和操纵其生命周期。</p>
</div>
<div class="paragraph">
<p>ViatraQueryEngine使用Scope实现进行实例化，该实现描述了查询应该使用的模型。默认情况下，对于EMF，建议使用包含EMF模型的ResourceSet初始化EMFScope实例。有关范围的更多详细信息，请参阅<a href="#sec-query-scopes">查询范围</a> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，对于每个范围， <strong>都会</strong>创建一个托管的<strong>ViatraQueryEngine</strong> ，由通过生成的API访问VIATRA Query功能的所有对象共享。 <strong>ViatraQueryEngine</strong>附加到作用域， <strong>只要模型本身存在</strong> ， <strong>它就会保留在堆上</strong> 。它将监听源自给定模型的更新通知，以保持实时结果。如果释放对模型的所有引用（例如卸载资源）， <strong>ViatraQueryEngine</strong>也可以被垃圾收集（只要没有其他入站引用）。</p>
</div>
<div class="paragraph">
<p>总之，对于大多数（基本）方案，应遵循以下工作流程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>初始化/加载模型</p>
</li>
<li>
<p>初始化您的<strong>ViatraQueryEngine</strong>实例</p>
</li>
<li>
<p>初始化模式匹配器或模式匹配器组并使用它们</p>
</li>
<li>
<p>如果您释放模型和<strong>ViatraQueryEngine</strong>实例，则垃圾收集器将释放所有资源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级方案（如果您希望在更精细的级别管理生命周期），您可以选择创建<strong>非托管</strong> ViatraQueryEngines并独立于实例模型处理它们。但是对于大多数用例，我们建议使用托管引擎，这是默认和优化的行为，因为这些引擎可以共享公共索引和缓存以节省内存和CPU时间。<strong>EngineManager</strong>确保同一模型根（通告程序）对象不会有重复的引擎。创建非托管引擎将为您带来一些额外的好处，但是应该应用其他注意事项。</p>
</div>
<div class="paragraph">
<p>如果要从引擎中删除匹配器，可以在其上调用<code>wipe()</code>方法。它丢弃任何模式匹配器缓存并忘记已知模式。但是，直接构建在底层EMF模型上的基本索引保留在内存中，以便在构建新模式匹配器时重用。如果您不想再使用它，请调用<code>dispose()</code> ，以完全断开并拆除发动机。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">切勿在任何未明确创建的引擎上打电话或处理;任何在引擎上创建的匹配器都变得无法使用。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_typical_programming_patterns"><a class="link" href="#_typical_programming_patterns">3。典型的编程模式</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在下文中，我们提供了简短的源代码示例（带有一些解释），涵盖了VIATRA Query API支持的最重要的用例。</p>
</div>
<div class="sect2">
<h3 id="_loading_an_instance_model_and_executing_a_query"><a class="link" href="#_loading_an_instance_model_and_executing_a_query">3.1。加载实例模型并执行查询</a></h3>
<div id="query-api-loadmodelandquery" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// get all matches of the pattern
// initialization
// phase 1: (managed) ViatraQueryEngine
ViatraQueryEngine engine = ViatraQueryEngine.on(new EMFScope(resource /* or resourceSet */));
// phase 2: the matcher itself
EObjectMatcher matcher = EObjectMatcher.on(engine);
// get all matches of the pattern
Collection&lt;EObjectMatch&gt; matches = matcher.getAllMatches();
// process matches, produce some output
StringBuilder results = new StringBuilder();
prettyPrintMatches(results, matches);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_matchprocessor"><a class="link" href="#_using_the_matchprocessor">3.2。使用MatchProcessor</a></h3>
<div class="paragraph">
<p>使用MatchProcessor，您可以非常轻松地迭代模式的匹配：</p>
</div>
<div id="query-api-matchprocessor" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">matcher2.forEachMatch(new EClassNamesProcessor() {
 @Override
 public void process(EClass c, String n) {
  results.append("\tEClass: " + c.toString() + "\n");
 }
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matching_with_partially_bound_input_parameters"><a class="link" href="#_matching_with_partially_bound_input_parameters">3.3。与部分绑定的输入参数匹配</a></h3>
<div class="paragraph">
<p>VIATRA查询查询的一个重要方面是它们是<strong>双向的</strong> ，因为它们接受输入绑定，使用给定的输入约束过滤/投影结果集。以下示例说明了匹配处理器与输入绑定的用法，该输入绑定将结果集限制为第二个参数（EClass的名称）取值“A”的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">matcher2.forEachMatch( matcher2.newMatch(null, "A") , new EClassNamesProcessor() {
 @Override
 public void process(EClass c, String n) {
  results.append("\tEClass with name A: " + c.toString() + "\n");
 }
});

// alternatively:
matcher2.forEachMatch(null, "A" , new EClassNamesProcessor() {
 @Override
 public void process(EClass c, String n) {
  results.append("\tEClass with name A: " + c.toString() + "\n");
 }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>输入绑定可用于所有匹配结果集方法。</p>
</div>
<div class="paragraph">
<p>此外<strong>，getAllValuesOf ...</strong>方法允许你执行结果集的参数之一的预测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// projections
for (EClass ec: matcher2.getAllValuesOfc(matcher2.newMatch(null,"A")))
{
 results.append("\tEClass with name A: " + ec.toString() + "\n");
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_initialization_of_pattern_groups"><a class="link" href="#_initialization_of_pattern_groups">3.4。模式组的初始化</a></h3>
<div class="paragraph">
<p>使用模式组对性能很重要。默认情况下，当第一次通过<strong>ViatraQueryEngine</strong>访问匹配器时，VIATRA Query会执行实例模型的遍历。如果您希望使用多个模式匹配器，最好使用生成的模式组类并准备ViatraQueryEngine以执行组合遍历（具有最小的额外开销），以便任何其他Matcher初始化避免重新遍历。</p>
</div>
<div id="query-api-groupinit" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// phase 1: (managed) ViatraQueryEngine
ViatraQueryEngine engine = ViatraQueryEngine.on(new EMFScope(resource));
// phase 2: the group of pattern matchers
HeadlessQueries patternGroup = HeadlessQueries.instance();
patternGroup.prepare(engine);
// from here on everything is the same
EObjectMatcher matcher = EObjectMatcher.on(engine);
// get all matches of the pattern
Collection&lt;EObjectMatch&gt; matches = matcher.getAllMatches();
prettyPrintMatches(results, matches);
// ... //
// matching with partially bound input parameters
// because EClassNamesMatcher is included in the patterngroup, *no new traversal* will be done here
EClassNamesMatcher matcher2 = EClassNamesMatcher.on(engine);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parsing_patterns"><a class="link" href="#_parsing_patterns">4。解析模式</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA提供了一个API来解析文本中的模式，并从中创建查询规范，这些规范可以与生成的查询规范类似地使用。这是基于<strong>通用</strong>模式匹配器API，它在两个关键方面与生成的API不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它可用于应用查询和使用其他VIATRA查询功能， <strong>而无需</strong>生成代码并将生成的包加载到运行配置中。换句话说，您只需要提供基于EMF的内存中表示（Pattern类的一个实例）</p>
</li>
<li>
<p>从某种意义上说，通用API不是“类型安全的”，因为模式变量的Java类型是未知的，需要动态处理（通常通过类型转换）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要使用此API，必须将<code>org.eclipse.viatra.query.patternlanguage.emf</code>插件中的代码添加到类路径中（在独立应用程序中，依赖于Maven依赖项<code>org.eclipse.viatra:viatra-query-language</code> ）。这将为您的应用程序添加更多的传递依赖关系，最值得注意的是Xtext和Google Guice。
</td>
</tr>
</table>
</div>
<div id="query-api-genericapi" class="listingblock">
<div class="title">使用Pattern Parser API</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final StringBuilder results = new StringBuilder();
Resource resource = loadModel(modelURI);

// Initializing Xtext-based resource parser (once per Java application)
new EMFPatternLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();

// Parse pattern definition
PatternParsingResults parseResults = PatternParserBuilder.instance()
        .parse("import \"http://org.eclipse.viatra/model/cps\" \n"
                + "\n"
                + "pattern hostIpAddress(host: HostInstance, ip : java String) {\n"
                + "    HostInstance.nodeIp(host,ip);\n"
                + "}");
ViatraQueryEngine engine = ViatraQueryEngine.on(new EMFScope(resource));

parseResults.getQuerySpecification("hostIpAddress").ifPresent(specification -&gt; {
    ViatraQueryMatcher&lt;?&gt; matcher = engine.getMatcher(specification);
    prettyPrintMatches(results, matcher.getAllMatches());
});

return results.toString();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在VIATRA 2.1中，模式解析器API已更新，以支持更高级的情况，例如更新以前加载的模式（有关详细信息，请参见下文）。在以前的版本中，可以通过调用<code>PatternParser.parser().parse(…​)</code>来初始化模式解析器，但在VIATRA 2.1版中不推荐使用此调用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>图案解析器可以在两种模式进行初始化：一个<em>基本模式</em> （调用任一初始化<code>parse</code>或<code>build</code>的方法<code>PatternParserBuilder</code>类不支撑在被加载之后更新查询定义;而在<em>高级模式</em> （与初始化<code>buildAdvanced</code>的方法<code>PatterParserBuilder</code> ）可以更新先前加载的规范，并根据需要更新（并重新验证）生成的查询规范。鉴于<em>高级模式</em>所需的基础架构更复杂，建议依赖<em>基本模式，</em>除非真正需要重新分析模式，例如在用户可以指定具有复杂依赖关系的自定义查询的环境中集成VIATRA时。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_viatra_query_base"><a class="link" href="#_viatra_query_base">5。VIATRA查询库</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA Query提供了一个名为Base的轻量级索引器库，旨在为查询EMF模型提供一些有用的（有些甚至可以说是关键的）功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>沿EReferences反向导航</p>
</li>
<li>
<p>按属性值/类型查找并递增跟踪所有模型元素（即沿EAttributes反向导航）</p>
</li>
<li>
<p>逐步计算给定引用类型的传递可达性（即EMF模型的传递闭包）</p>
</li>
<li>
<p>获取和跟踪给定EClass的所有（直接）实例</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>VIATRA Query Base的要点是以递增的方式提供所有这些，这意味着一旦查询评估程序附加到EMF模型，只要它保持附加，就可以立即检索查询结果（作为查询结果）缓存自动更新）。VIATRA Query Base是一个轻量级的小型Java库，可以轻松集成到任何基于EMF的工具，因为它可以独立使用，而不需要VIATRA Query的其余部分。</p>
</div>
<div class="paragraph">
<p>我们知道某些功能可以在一些Ecore实用程序类中找到（例如ECrossReferenceAdapter）。这些标准实现是非增量的，因此在需要高查询评估性能的场景（例如，动态良好性验证或实时视图维护）中不能很好地扩展。VIATRA查询库还有一个在其他地方不存在的重要特性：它包含非常有效的传递闭包实现，可用于例如在非常大的EMF实例模型中递增地维护可达性区域。</p>
</div>
<div class="sect2">
<h3 id="_extracting_reachability_paths_from_transitive_closure"><a class="link" href="#_extracting_reachability_paths_from_transitive_closure">5.1。从传递闭包中提取可达性路径</a></h3>
<div class="paragraph">
<p>除了支持在模型中的节点之间查询可达性信息之外，TransitiveClosureHelper类还提供了检索节点对之间的路径的功能。<code>getPathFinder</code>方法返回<code>IGraphPathFinder</code>对象，该对象公开以下操作：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Deque &lt;V&gt; getPath（V sourceNode，V targetNode）</code></dt>
<dd>
<p>返回从源节点到目标节点的任意路径（如果存在）。</p>
</dd>
<dt class="hdlist1"><code>Iterable &lt;Deque &lt;V &gt;&gt; getShortestPaths（V sourceNode，V targetNode）</code></dt>
<dd>
<p>返回从源节点到目标节点的最短路径集合（如果存在）。</p>
</dd>
<dt class="hdlist1"><code>Iterable &lt;Deque &lt;V &gt;&gt; getAllPaths（V sourceNode，V targetNode）</code></dt>
<dd>
<p>返回从源节点到目标节点的路径集合（如果存在）。</p>
</dd>
<dt class="hdlist1"><code>Iterable &lt;Deque &lt;V &gt;&gt; getAllPathsToTargets（V sourceNode，Set &lt;V&gt; targetNodes）</code></dt>
<dd>
<p>返回从源节点到任何目标节点（如果存在）的路径集合。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在内部，这些操作使用深度优先搜索遍历，并依赖于由传递闭包组件递增维护的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec-query-scopes"><a class="link" href="#sec-query-scopes">6。查询范围</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA Query使用<strong>Scopes</strong>的概念来定义整个模型以搜索结果。对于EMF模型的查询，EMFScope类定义了这样的范围。初始化ViatraQueryEngine时，需要通过创建EMFScope的新实例来指定此范围。</p>
</div>
<div class="paragraph">
<p>此实例可以从一个或多个Notifier实例创建（ResourceSet：包括存储在ResourceSet中的所有模型元素; Resource：包括相应Resource内的所有元素; EObject：包括对象本身的包含子树中的所有元素）。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，建议将整个ResourceSet作为查询范围包含在内;但是，如果需要，可以</p>
</div>
<div class="sect2">
<h3 id="_using_filtered_input_models_during_pattern_matching"><a class="link" href="#_using_filtered_input_models_during_pattern_matching">6.1。在模式匹配期间使用过滤的输入模型</a></h3>
<div class="paragraph">
<p>在某些情况下，在模式匹配期间不包括ResourceSet中的所有资源是有益的，但考虑多个。此类情况可能包括Xtext / Xbase语言或基于<a href="http://www.jamopp.org/index.php/JaMoPP">JaMoPP</a>的实例，这些实例包含表示Java库类的资源。</p>
</div>
<div class="paragraph">
<p>在EMF模型的情况下，EMFScope实例还可以通过向VIATRA查询引擎提供过滤器实现来设置一些基本索引选项，以过滤掉由Base Indexer和Rete网络索引的包含子树。这些选项包括IBaseIndexResourceFilter和IBaseIndexObjectFilter实例，它们可分别用于过滤掉整个资源或包含子树。</p>
</div>
<div class="paragraph">
<p>示例用法（通过过滤掉JaMoPP引用的Java类）：</p>
</div>
<div id="query-runtime-filteredscope" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ResourceSet resourceSet = ...; //Use a Resource Set as the root of the engine
BaseIndexOptions options = new BaseIndexOptions().withResourceFilterConfiguration(new IBaseIndexResourceFilter() {

  @Override
  public boolean isResourceFiltered(Resource resource) {
    // PathMap URI scheme is used to refer to JDK classes
    return "pathmap".equals(resource.getURI().scheme());
  }
});
//Initializing scope with custom options
EMFScope scope = new EMFScope(resourceSet, options);
ViatraQueryEngine engine = ViatraQueryEngine.on(scope);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用此API时需要考虑一些问题：</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>如果过滤掉资源或包含子树，则会将其完全过滤掉。无法重新添加一些较低级别的内容。</p>
</li>
<li>
<p>如果查询范围设置为整个模型的子集（例如，资源集中只有一个EMF资源），则引擎范围内的模型元素可能具有指向范围之外的元素的引用;这些被称为<strong>悬空边缘</strong> 。以前版本的VIATRA假设模型是独立的，没有悬垂的边缘;如果模型没有此属性，则查询引擎的行为是“未指定”（可能是不正确的匹配集）。在VIATRA 1.6中，通过添加一个丢弃此假设的新索引器模式来清除此行为，并且（以较低的性能成本）始终将所有索引边的两端都检查为范围内。为了向后兼容，默认情况下使用旧行为，但您可以使用相应的基本索引选项手动更改此行为，如下所示。对于新代码，我们建议使用此选项来删除无悬空假设，因为它在很多情况下提供更一致和直观的结果;在未来的VIATRA版本中，这将是新的默认值。</p>
</li>
</ul>
</div>
<div id="query-runtime-danglingfree" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">BaseIndexOptions options = new BaseIndexOptions().withDanglingFreeAssumption(false);
ResourceSet rSet = new ResourceSetImpl();
EMFScope scope = new EMFScope(rSet, options);
ViatraQueryEngine engine = ViatraQueryEngine.on(scope);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_matching_with_local_search"><a class="link" href="#_pattern_matching_with_local_search">7。与本地搜索匹配的模式</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>从版本0.9开始，除了基于Rete的增量引擎之外，还有可能引用替代搜索引擎;版本1.0包括可与VIATRA查询匹配器API一起使用的基于本地搜索的搜索算法。</p>
</div>
<div class="paragraph">
<p>从版本1.4开始，本地搜索引擎被认为是稳定的，并且用户被鼓励在增量性不重要的应用程序中使用它。本地搜索引擎重用VIATRA Query中使用的相同匹配器API。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>什么时候本地搜索最有益？</p>
<div class="ulist">
<ul>
<li>
<p>单个，批量评估模型</p>
</li>
<li>
<p>内存限制很严重，Rete网络不适合内存</p>
</li>
<li>
<p>当所有调用都绑定了一个或多个参数时，会导致简单的遍历</p>
</li>
</ul>
</div>
</li>
<li>
<p>更难的案例</p>
<div class="ulist">
<ul>
<li>
<p>重复模型执行</p>
</li>
<li>
<p>查询评估需要昂贵的模型遍历（考虑迭代模型中的所有实例）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="sec-localsearch"><a class="link" href="#sec-localsearch">7.1。使用本地搜索</a></h3>
<div class="paragraph">
<p>要执行的最重要的步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>向可选插件<code>org.eclipse.viatra.query.runtime.localsearch</code>添加依赖项</p>
</li>
<li>
<p>初始化匹配器实例时，明确要求基于本地搜索的匹配器：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>IQuerySpecification&lt;?&gt; specification = ...;
QueryEvaluationHint hint = LocalSearchHints.getDefault().build();
AdvancedViatraQueryEngine.from(queryEngine).getMatcher(specification, hint);</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>或者，将本地搜索设置为查询引擎的默认值：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>// Access the default local search hint
QueryEvaluationHint localSearchHint = LocalSearchHints.getDefault().build();

// Build an engine options with the local search hint
ViatraQueryEngineOptions options = ViatraQueryEngineOptions.
		defineOptions().
		withDefaultHint(localSearchHint).
                withDefaultBackend(localSearchHint.getQueryBackendFactory()). // this line is needed in 1.4 due to bug 507777
		build();

//Access the query engine
ViatraQueryEngine queryEngine = ViatraQueryEngine.on(scope, options);</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>初始化之后，可以在本地搜索引擎上使用现有<a href="#sec-querymatcher">模式匹配器API</a>构造。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也可以使用<code>search</code>声明VQL文件中的本地搜索要执行的特定模式，尽管此设置可能会被匹配器创建时提供的提示覆盖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">search pattern minCPUs(n : java Integer) {
	n == min find cpus(_hi1, #_);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parameterizing_local_search"><a class="link" href="#_parameterizing_local_search">7.2。参数化本地搜索</a></h3>
<div class="paragraph">
<p>通过<a href="#sec-query-hints">提示机制</a>可以对规划器算法进行参数化。目前（版本1.7），使用<code>LocalSearchHints</code>构建器类可以获得以下提示：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">使用Base</dt>
<dd>
<p>允许/禁止在运行时使用索引。它的价值可能是<code>true</code>或<code>false</code> 。默认值为<code>true</code> 。</p>
</dd>
<dt class="hdlist1">行数</dt>
<dd>
<p>内部参数，值越大通常意味着计划生成时间越长，潜在的搜索计划成本越低。它的值可能是正<code>int</code> ，默认值是4。</p>
</dd>
<dt class="hdlist1">成本函数</dt>
<dd>
<p>计划员使用的成本函数。必须实现org.eclipse.viatra.query.runtime.localsearch.planner.cost。ICostFunction</p>
</dd>
<dt class="hdlist1">展平调用谓词</dt>
<dd>
<p>在计划之前，控制哪种模式组合调用的谓词应该被展平。通过嘲笑所有被称为模式的扁平化。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>例如，要禁用基本索引的使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQuerySpecification&lt;?&gt; specification = ...;
QueryEvaluationHint hint = LocalSearchHints.getDefault().setUseBase(false).build();
AdvancedViatraQueryEngine.from(queryEngine).getMatcher(specification, hint);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cost_function"><a class="link" href="#_cost_function">7.3。成本函数</a></h3>
<div class="paragraph">
<p>默认成本函数基于模型的统计结构来估计操作成本，该统计结构是使用基本索引获得的。即使USE_BASE_INDEX设置为false，也是如此，在这种情况下，会创建一个计划，该计划在执行时不依赖于基本索引。从1.4.0开始，与实例索引相比，基本索引只能提供更少开销的统计信息。为了避免在规划阶段使用基本索引，可以将成本函数替换为另一个实现。为此，提供了两种替代实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VariableBindingBasedCostFunction</code>使用它绑定的变量数来估算运营成本。此成本函数通常会导致执行性能降低。</p>
</li>
<li>
<p>抽象类<code>StatisticsBasedConstraintCostFunction</code>可用于提供来自不同源的模型统计信息，例如以前填充的映射：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final Map&lt;IInputKey, Long&gt; statistics = ..
QueryEvaluationHint hint = LocalSearchHints.getDefault().setCostFunction(new StatisticsBasedConstraintCostFunction(){
  public long countTuples(IConstraintEvaluationContext input, IInputKey supplierKey){
    return statistics.get(supplierKey);
  }
}).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果预计在规划阶段之后改变模型，则建议使用后者，以确保规划基于类似于执行模式的实际结构的实际模型统计。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们计划在更高版本中提供一种更简单的方法来设置模型统计数据;这种设置可能会改变。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_known_limitations"><a class="link" href="#_known_limitations">7.4。已知限制</a></h3>
<div class="ulist">
<ul>
<li>
<p>本地搜索匹配器无法在模式匹配上提供更改通知。如果询问，则抛出UnsupportedOperationException。</p>
</li>
<li>
<p>从版本1.4开始，不可能将不同的模式匹配算法组合用于评估单个模式。整个搜索必须使用Rete或基于本地搜索的算法。</p>
</li>
<li>
<p>本地搜索引擎当前无法执行递归查询。有关更多详细信息，请参见<a href="http://bugs.eclipse.org/458278" class="bare">http://bugs.eclipse.org/458278</a> 。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec-query-hints"><a class="link" href="#sec-query-hints">8。提供查询评估提示</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以使用评估提示将额外信息传递给VIATRA Query的运行时，例如有关模型结构或评估要求的信息。在1.4版本中，这些提示的处理得到了极大的增强，允许以下方式传递提示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>可以使用静态方法<code>AdvancedQueryEngine#createUnmanagedEngine(QueryScope, ViatraQueryEngineOptions)</code>使用默认提示初始化Query引擎。查询引擎选项中提供的提示是所有匹配器使用的默认提示，但可以使用以下选项覆盖。</p>
</li>
<li>
<p>可以使用提示扩展模式定义，例如，用于模式语言中的后端选择。这些提示将生成到生成的查询规范代码中。</p>
</li>
<li>
<p>通过查询引擎访问新模式匹配器时，可能会使用<code>AdvancedQueryEngine#getMatcher(IQuerySpecification, QueryEvaluationHint)</code>显示进一步的覆盖提示。此类提示会覆盖引擎默认值和模式默认提示。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在版本1.4中，提示主要用于微调<a href="#sec-localsearch">基于本地搜索的模式匹配器</a> ，但它们的使用正在逐渐扩展。有关查询后端提供的提示选项，请参阅<code>ReteHintOptions</code>和<code>LocalSearchHints</code>类。从2.0开始，UI上也提供了<a href="#recursion-dred">删除和重新启动（DRED）</a>提示选项。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_query_specification_registry"><a class="link" href="#_query_specification_registry">9。查询规范注册表</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>自“VIATRA 1.3”以来可用的查询规范注册表用于管理由多个连接器提供的查询规范，这些连接器可以动态地添加和删除规范。用户可以通过视图读取注册表的内容，这些视图在连接器更改注册表时也会动态更新。</p>
</div>
<div class="sect2">
<h3 id="_basic_usage"><a class="link" href="#_basic_usage">9.1。基本用法</a></h3>
<div class="paragraph">
<p>注册表的最常见用法是根据其完全限定名称获取已注册的查询规范。您可以通过单例实例访问注册表：</p>
</div>
<div id="query-runtime-registry-usage" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQuerySpecificationRegistry registry = org.eclipse.viatra.query.runtime.registry.QuerySpecificationRegistry.getInstance();
IQuerySpecification&lt;?&gt; specification = registry.getDefaultView().getEntry("my.registered.query.fqn").get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认视图允许您访问注册表的内容，返回的条目是查询规范的提供程序，在通过get（）方法请求时返回它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_usage"><a class="link" href="#_advanced_usage">9.2。高级用法</a></h3>
<div class="sect3">
<h4 id="_views"><a class="link" href="#_views">9.2.1。查看</a></h4>
<div class="paragraph">
<p>要获得注册表的始终最新视图，您可以：*请求将包含标记为包含在此视图中的规范的<strong>默认</strong>视图（例如，通过查询规范扩展点注册的查询）*创建可能的新<strong>视图</strong>使用过滤器或工厂来定义视图中应包含哪些规范</p>
</div>
<div id="query-api-registry-views" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQuerySpecificationRegistry registry = QuerySpecificationRegistry.getInstance();
// access default view
IDefaultRegistryView defaultView = registry.getDefaultView();

// create new view
IRegistryView simpleView = registry.createView();

// create filtered view
IRegistryView filteredView = registry.createView(new IRegistryViewFilter() {
  @Override
  public boolean isEntryRelevant(IQuerySpecificationRegistryEntry entry) {
    // return true to include in view
  }
});

// create specific view instance
boolean allowDuplicateFQNs = false;
IRegistryView ownView = registry.createView(new IRegistryViewFactory() {
  return new AbstractRegistryView(registry, allowDuplicateFQNs) {
    @Override
    protected boolean isEntryRelevant(IQuerySpecificationRegistryEntry entry) {
      // return true to include in view
    }
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>获得视图实例后，可以通过从视图中请求条目或添加将在视图更改时通知的侦听器来访问注册表的内容。</p>
</div>
<div class="paragraph">
<p>默认视图还添加了一些其他实用程序，这些实用程序也可以通过限制其中包含的内容来实现。默认视图将仅包含明确标记为包含的条目，并且不允许具有相同完全限定名称的不同规范。作为回报，您可以通过其FQN请求单个条目（因为最多可以存在一个条目），并且还请求包含所有条目的查询组。</p>
</div>
</div>
<div class="sect3">
<h4 id="_listening_to_view_changes"><a class="link" href="#_listening_to_view_changes">9.2.2。倾听视图的变化</a></h4>
<div class="paragraph">
<p>创建视图后，注册表的内容可能会更改。当您访问视图以获取其条目时，它将始终返回注册表的当前状态。如果您希望在视图内容发生更改时收到通知，则可以向视图添加侦听器：</p>
</div>
<div id="query-api-registry-listener" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQuerySpecificationRegistry registry = QuerySpecificationRegistry.getInstance();
IRegistryView myView = registry.createView();
IQuerySpecificationRegistryChangeListener listener = new IQuerySpecificationRegistryChangeListener() {
  @Override
  public void entryAdded(IQuerySpecificationRegistryEntry entry) {
    // process addition
  }

  @Override
  public void entryRemoved(IQuerySpecificationRegistryEntry entry) {
    // process removal
  }
});
myView.addViewListener(listener);

// when you don't need to get notifications any more
myView.removeViewListener(listener);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>重要说明：</strong>您的代码必须保留对您的视图的引用，否则将被垃圾回收。注册表使用对创建的视图的弱引用，以使用户不必手动处理视图。</p>
</div>
</div>
<div class="sect3">
<h4 id="_adding_specifications_to_the_registry"><a class="link" href="#_adding_specifications_to_the_registry">9.2.3。向注册表添加规范</a></h4>
<div class="paragraph">
<p>注册表通过源提供规范。您可以添加自己的源连接器作为源，并动态添加和删除自己的规范。</p>
</div>
<div id="query-api-registry-addspecification" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQuerySpecificationRegistry registry = QuerySpecificationRegistry.getInstance();
// initialize your connector
IRegistrySourceConnector connector;

// add connector
boolean sourceAdded = registry.addSource(connector);

// [...]

// remove your source when needed
boolean sourceRemoved = registry.removeSource(connector);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经为最常见的用例提供了一些连接器实现。例如，您可以使用查询规范的简单添加和删除方法创建连接器：</p>
</div>
<div id="query-api-registry-connectors" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IRegistrySourceConnector connector = new SpecificationMapSourceConnector("my.source.identifier", true /* include these in default view; fqn clashes are errors */);

IQuerySpecification&lt;?&gt; specification = /* available from somewhere */

IQuerySpecificationProvider provider = new SingletonQuerySpecificationProvider(specification);

// add specification to source
connector.addQuerySpecificationProvider(provider);

// remove specification by FQN
connector.removeQuerySpecificationProvider(specification.getFullyQualifiedName());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认视图假定在那里加载的所有查询都有一个限定名称。如果无法确保这一点，则不应将源添加到默认视图中，并相应地创建特定视图。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance_tuning_and_special_engine_modes"><a class="link" href="#_performance_tuning_and_special_engine_modes">10。性能调整和特殊引擎模式</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_query_groups_and_coalescing_model_traversals"><a class="link" href="#_query_groups_and_coalescing_model_traversals">10.1。查询组和合并模型遍历</a></h3>
<div class="paragraph">
<p>如果初始化需要索引当前引擎实例尚未构建索引的某些EMF类型的新查询，则VIATRA引擎的基本索引将遍历整个范围以构建索引。如果避免这种昂贵的重新遍历，它可以产生很大的不同，并且引擎仅遍历模型一次以构建所有查询的索引。</p>
</div>
<div class="paragraph">
<p>执行此操作最简单的方法是使用&lt;code&gt; IQueryGroup.prepare（engine）&lt;/ code&gt;进行一组查询。为每个查询文件生成这样的组，并且可以使用&lt;code&gt; GenericQueryGroup &lt;/ code&gt;手动组装任何其他自定义组。</p>
</div>
<div id="query-api-group-prepare" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IQueryGroup queries = ...
ViatraQueryEngine engine = ...
queries.prepare(engine);</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于高级用例，可以直接控制任意代码块中的索引遍历，以便将任何索引构造合并为单个遍历：</p>
</div>
<div id="query-api-coalesce" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ViatraQueryEngine engine = ...
engine.getBaseIndex().coalesceTraversals(new Callable&lt;Void&gt;() {
    @Override
    public Void call() throws Exception {
        // obtain matchers, etc.
        return null;
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delaying_query_result_updates"><a class="link" href="#_delaying_query_result_updates">10.2。延迟查询结果更新</a></h3>
<div class="paragraph">
<p>从1.6版开始，高级查询API现在包含一项功能，允许用户在增量查询后端暂时“关闭”查询结果维护。在这样的代码块期间，仅更新基本模型索引器，查询结果保持陈旧，直到块结束。优点是，当以部分撤消自身的方式更改模型时，可以节省大量执行时间，例如，移除然后重新添加模型的大部分。</p>
</div>
<div id="query-api-delayupdates" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AdvancedViatraQueryEngine engine = ...
engine.delayUpdatePropagation(new Callable&lt;Void&gt;() {
    @Override
    public Void call() throws Exception {
        // perform extensive changes in model that largely cancel each other out
        return null;
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_once_query_engine"><a class="link" href="#_run_once_query_engine">10.3。一次运行查询引擎</a></h3>
<div class="paragraph">
<p>此页面描述了如何使用VIATRA Query进行一次性查询评估，这在以下情况下非常有用：*您需要较少（稳态）内存消耗而不是增量评估。*您派生的函数不是[[VIATRA / Addon / Query_Based_Features＃Well-behaving_structural_features | well-behaving]]，但您希望将它们包含在查询中。*您喜欢VIATRA Query的查询语言，但您不需要增量评估，批处理性能优于查询使用之间的模型修改开销之和。</p>
</div>
<div class="paragraph">
<p>这些场景现在由“一次运行”查询引擎支持，该查询引擎将对给定查询执行评估并返回匹配集，然后处理Rete网络和基本索引以释放内存。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">VIATRA提供的<a href="#sec-localsearch">本地搜索引擎</a>应该在这些情况下表现更好，建议使用它。此功能早于本地搜索支持，并保留以实现向后兼容。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_example"><a class="link" href="#_example">10.3.1。例</a></h4>
<div class="paragraph">
<p>这个页面的最新示例源代码可以在Git中找到： <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/minilibrary" class="bare">http</a> ： <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/minilibrary" class="bare">//git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/minilibrary</a>最值得注意的是，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式可以在<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/minilibrary/org.eclipse.viatra.query.runtime.runonce.tests/src/org/eclipse/viatra/query/runtime/runonce/tests/eiqlibrary.vql">eiqlibrary.vql</a>中找到</p>
</li>
<li>
<p>并在<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/minilibrary/org.eclipse.viatra.query.runtime.runonce.tests/src/org/eclipse/viatra/query/runtime/runonce/tests/RunOnceTest.java">RunOnceTest.java</a>中找到API使用示例</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_usage"><a class="link" href="#_usage">10.3.2。用法</a></h4>
<div class="sect4">
<h5 id="_run_once_then_dispose"><a class="link" href="#_run_once_then_dispose">10.3.2.1。运行一次然后处置</a></h5>
<div class="paragraph">
<p>一次运行查询引擎的API非常简单，只需使用适当的范围（EObject，Resource或ResourceSet）使用构造函数实例化引擎，并使用查询规范调用getAllMatches：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RunOnceQueryEngine engine = new RunOnceQueryEngine(notifier);
// using generated query specification
Collection&lt;SumOfPagesInLibraryMatch&gt; allMatches = engine.getAllMatches(SumOfPagesInLibraryMatcher.querySpecification());
// if you only have Pattern object
IQuerySpecification&lt;ViatraQueryMatcher&lt;IPatternMatch&gt;&gt; specification = (IQuerySpecification&lt;ViatraQueryMatcher&lt;IPatternMatch&gt;&gt;) QuerySpecificationRegistry.getOrCreateQuerySpecification(BooksWithMultipleAuthorsMatcher.querySpecification().getPattern());
Collection&lt;IPatternMatch&gt; matches = engine.getAllMatches(specification);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，每次调用getAllMatches都将完全遍历模型，索引查询所需的类，功能和数据类型，收集匹配集而不是处理索引。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_re_sampling"><a class="link" href="#_automatic_re_sampling">10.3.3。自动重新采样</a></h4>
<div class="paragraph">
<p>在许多情况下，派生特征只是查询的一小部分，最好在构建索引后保留它们。但是，在这种情况下，我们需要一种方法来更新索引的所有派生特征的值。</p>
</div>
<div class="paragraph">
<p>一次性运行查询引擎通过在返回匹配结果之前监听模型修改和更新值来支持自动重新采样。以下示例显示了如何启用此模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RunOnceQueryEngine engine = new RunOnceQueryEngine(notifier);
engine.setAutomaticResampling(true); // enable re-sampling mode
Collection&lt;SumOfPagesInLibraryMatch&gt; allMatches = engine.getAllMatches(SumOfPagesInLibraryMatcher.querySpecification());
// some model modification
// only re-sampling of derived features, not complete traversal
allMatches = engine.getAllMatches(SumOfPagesInLibraryMatcher.querySpecification());</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不再需要自动重新采样，则可以将其关闭。在这种情况下，保持增量更新的引擎将从内存中删除。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">engine.setAutomaticResampling(false); // disable re-sampling mode, indices removed</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果派生特征的值在没有任何模型修改的情况下发生变化（不推荐），您可以告诉引擎下次运行重新采样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">engine.resampleOnNextCall();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_logging_in_viatra_query"><a class="link" href="#_logging_in_viatra_query">11。登录VIATRA查询</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA Query使用log4j记录错误消息和一些跟踪信息。如果需要调试应用程序并希望查看这些消息，可以在不同的层次结构级别设置日志级别。由于我们使用标准log4j，您可以使用配置文件或通过API调用配置日志记录。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有记录器都是顶级默认记录器的<code>ViatraQueryLoggingUtil.getDefaultLogger()</code> ，可以从<code>ViatraQueryLoggingUtil.getDefaultLogger()</code>访问，只需调用<code>setLevel(Level.DEBUG)</code>在返回的记录器上查看所有消息（当然你也可以使用其他级别）。</p>
</li>
<li>
<p>每个引擎都有自己的记录器，它与Base Index和匹配器共享。如果要查看与所有引擎相关的所有消息，请调用<code>ViatraQueryLoggingUtil.getLogger(ViatraQueryEngine.class)</code>并设置级别。</p>
</li>
<li>
<p>其他一些类也使用他们自己的记录器并使用相同的方法，他们根据他们的类获得记录器，因此检索该记录器并设置级别也将起作用。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_configuration_problems"><a class="link" href="#_configuration_problems">11.1。配置问题</a></h3>
<div class="paragraph">
<p>log4j使用属性文件作为其根记录器的配置。但是，由于此配置通常由应用程序开发人员提供，因此我们不会将其打包在VIATRA Query中。这意味着如果未提供配置，您可能会在控制台上遇到以下情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre> log4j:WARN No appenders could be found for logger (org.eclipse.viatra.query.runtime.util.ViatraQueryLoggingUtil).
 log4j:WARN Please initialize the log4j system properly.</pre>
</div>
</div>
<div class="paragraph">
<p>有几种情况可能会发生这种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>您安装了Xtext SDK</strong> ，它有一个名为org.eclipse.xtext.logging的插件片段，它提供了log4j配置。确保在运行时配置中选择了片段。</p>
</li>
<li>
<p><strong>您正在使用VIATRA Query的工具而没有Xtext SDK</strong> ，您将看到上述警告，但由于patternlanguage.emf插件还将注册器注入VIATRA Query的记录器，因此将正确显示日志消息。</p>
</li>
<li>
<p><strong>您只使用</strong>没有Xtext依赖关系<strong>的VIATRA Query的运行时部分</strong> 。您必须提供自己的属性文件（独立执行）或片段（OSGi执行），请参阅<a href="http://www.eclipsezone.com/eclipse/forums/t99588.html" class="bare">http://www.eclipsezone.com/eclipse/forums/t99588.html</a></p>
</li>
<li>
<p>或者，如果您只是想确保日志消息出现在控制台中，无论其他配置发生了什么，您都可以调用<code>ViatraQueryLoggingUtil.setupConsoleAppenderForDefaultLogger()</code> ，它将完全按照其名称所述。由于appender和日志级别是分开的，因此您仍需要在要查看消息的记录器上设置日志级别。</p>
</li>
<li>
<p>如果您希望完全关闭记录器，请调用<code>ViatraQueryLoggingUtil.getDefaultLogger().setLevel(Level.OFF);</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>