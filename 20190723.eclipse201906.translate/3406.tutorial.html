<html lang="zh-Hans" >
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>VIATRA入门</title>
<link rel="stylesheet" href="asset?aid=0">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article" >
<div id="header">
<h1>VIATRA入门</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://www.eclipse.org/viatra/">VIATRA</a>是一个开源模型转换框架，专注于模型查询的有效评估，并支持各种转换工作流程。本文档包含一个开始查询和转换开发的教程。</p>
</div>
<div class="paragraph">
<p>本教程依赖于<a href="https://github.com/viatra/viatra-docs/blob/master/cps/Home.adoc">CPS Demonstrator应用程序</a> 。CPS演示器被指定涵盖模型驱动工程中的常规工作流程，其中系统（1）首先在源模型中描述，然后（2）自动模型到模型变换用于导出目标模型。最后，（3）执行模型到文本的转换以从目标域生成代码。此外，可以自动创建源域模型的模型生成器可以支持组件的正确性测试和性能评估。本教程仅使用转换问题的一个子集，因为其主要目标是说明VIATRA环境的基础知识。有关更复杂的转换示例，请咨询原始演示器。</p>
</div>
<div class="paragraph">
<p>我们希望读者熟悉Eclipse插件开发的基础知识，更具体地说是创建插件项目和定义基本的UI扩展（如命令）。此外，我们期望对基于EMF的建模有基本的了解。如果需要，请查看<a href="http://www.vogella.com/tutorials/EclipsePlugin/article.html" class="bare">http://www.vogella.com/tutorials/EclipsePlugin/article.html</a>上的插件开发教程或<a href="http://www.vogella.com/tutorials/EclipsePlugin/article.html" class="bare">http://www.vogella.com/tutorials/EclipseEMF/article上</a>的EMF教程<a href="http://www.vogella.com/tutorials/EclipseEMF/article.html" class="bare">。 html</a>有关这些主题的简短介绍。</p>
</div>
<div class="paragraph">
<p>本教程包含一个<strong>快速设置指南</strong> ，然后介绍<strong>模型查询开发</strong>及其在<strong>查询运行时中</strong>的用法。然后，涵盖了<strong>批处理</strong>和<strong>事件驱动的转换</strong> 。</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#environment">1。设置教程</a></li>
<li><a href="#_domains">2。域</a>
<ul class="sectlevel2">
<li><a href="#_cyber_physical_system">2.1。网络物理系统</a></li>
<li><a href="#_deployment">2.2。部署</a></li>
<li><a href="#_traceability">2.3。可追溯性</a></li>
</ul>
</li>
<li><a href="#_query_development">3。查询开发</a>
<ul class="sectlevel2">
<li><a href="#_using_the_query_development_environment">3.1。使用查询开发环境</a></li>
<li><a href="#_using_queries_programmatically">3.2。以编程方式使用查询</a></li>
</ul>
</li>
<li><a href="#_model_transformation_development">4。模型转型发展</a>
<ul class="sectlevel2">
<li><a href="#_batch_transformations">4.1。批量转换</a></li>
<li><a href="#_event_driven_transformations">4.2。事件驱动的转换</a></li>
<li><a href="#_debugging_model_transformations">4.3。调试模型转换</a></li>
</ul>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="environment"><a class="link" href="#environment">1。设置教程</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本教程是为2.0.0版（2018年6月28日发布）编写的。VIATRA 2.0可从Simultaneous Release Train p2存储库（ <a href="http://download.eclipse.org/releases/photon" class="bare">http://download.eclipse.org/releases/photon</a> ）获得;对于旧版本或旧版本，请使用<a href="http://download.eclipse.org/viatra/updates/release/2.0.0" class="bare">http://download.eclipse.org/viatra/updates/release/2.0.0上</a>的发行版p2存储库</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/install.png" alt="安装窗口">
</div>
<div class="title">图1。安装窗口</div>
</div>
<div class="paragraph">
<p>为了加快安装速度，您可以<em>在安装期间</em>取消选择“ <em>联系所有更新站点...”</em>字段，但可能需要手动安装所需的<em>Eclipse集合</em>和<em>Xtext运行时</em>功能。</p>
</div>
<div class="paragraph">
<p>本文档假定CPS元模型已安装到Eclipse实例中。它们可从p2存储库<a href="http://download.eclipse.org/viatra/examples/cps" class="bare">http://download.eclipse.org/viatra/examples/cps获得</a></p>
</div>
<div class="paragraph">
<p>VIATRA定义了一个名为<code>Transformation Development</code>的自定义透视图，其中包含一些视图和快捷方式，可以更轻松地开发查询和转换。本教程的其余部分期望选择此透视图;如果使用不同的视角，相应的视图和向导仍然可以在其标准的相应位置中使用。</p>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect1">
<h2 id="_domains"><a class="link" href="#_domains">2。域</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cyber_physical_system"><a class="link" href="#_cyber_physical_system">2.1。网络物理系统</a></h3>
<div class="paragraph">
<p>CPS域指定应用程序和主机类型及其对应用程序的实例，请求和要求以及对主机的应用程序的资源要求。应用程序类型具有状态机，通过状态和转换来描述它们的行为。最后，可以将应用程序实例分配给可以相互通信的主机实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_ecore.png" alt="网络物理系统模型Ecore图">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>主机实例具有唯一的节点IP地址。</p>
</li>
<li>
<p>应用程序实例具有唯一标识符。</p>
</li>
<li>
<p>状态机可以定义初始状态。</p>
</li>
<li>
<p>转换可以指定用于发送或等待信号的动作。可以通过提供应用类型（具有其ID）和信号标识符来发送信号，同时通过指定其标识符来等待信号。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_deployment"><a class="link" href="#_deployment">2.2。部署</a></h3>
<div class="paragraph">
<p>在部署模型中，主机实例包含在其上运行的应用程序，而每个应用程序都具有状态和转换的行为。当触发的转换等待它们发送的信号且应用程序类型正确时，该行为具有当前状态并且转换可以触发其他转换。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/deployment_ecore.png" alt="部署模型Ecore图">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_traceability"><a class="link" href="#_traceability">2.3。可追溯性</a></h3>
<div class="paragraph">
<p>可追溯性模型描述了CPS与部署模型之间的对应关系。可追溯性存储在一组引用零，一个或多个CPS和部署元素的跟踪中。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/traceability_ecore.png" alt="可追溯性模型Ecore图">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_query_development"><a class="link" href="#_query_development">3。查询开发</a></h2>
<div class="sectionbody">
<div style="page-break-after:always"></div>
<div class="sect2">
<h3 id="_using_the_query_development_environment"><a class="link" href="#_using_the_query_development_environment">3.1。使用查询开发环境</a></h3>
<div class="paragraph">
<p>VIATRA框架中的约束和条件使用基于图形模式的语言表示。这种声明形式允许对复杂条件进行非常紧凑的定义，同时仍然可以基于Rete算法提供实时查询评估。</p>
</div>
<div class="paragraph">
<p>在下文中，我们将概述查询开发环境，从查询定义开始，然后是查询评估支持。然后，我们通过创建越来越复杂的查询来了解各种语言元素。</p>
</div>
<div class="paragraph">
<p>图形模式对<em>命名</em>查询进行编码，其中一些<em>参数</em>被定义为模式<em>主体</em>的<em>分离</em> ，而每个主体由一<em>组</em>约束组成。称为<em>匹配集</em>的图形模式的结果是一<em>组</em> （模型元素）元组，其中元素满足在至少一个模式体中定义的所有约束。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">模式语言总是适用于集合：约束和匹配集都没有排序;和匹配集永远不会包含具有完全相同的模型元素的多个元组。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_define_your_first_query"><a class="link" href="#_define_your_first_query">3.1.1。定义您的第一个查询</a></h4>
<div class="paragraph">
<p>要定义查询，首先必须使用Eclipse的标准<em>New Project Wizard</em>创建<em>VIATRA Query Project</em> 。这些项目是专门的Eclipse插件项目，具有预先配置的VIATRA依赖项和初始化的查询生成器。必须将查询规范添加到项目的Java类路径中，更具体地说，添加到Java包中。根据这些观察结果，第一个查询的创建包括以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用任何名称在主机Eclipse中创建一个新的VIATRA Query项目。本教程将假定以下名称： <code>org.eclipse.viatra.examples.cps.queries</code> 。</p>
</li>
<li>
<p>将<code>org.eclipse.viatra.examples.cps.model</code>添加到插件依赖项中，以使CPS元模型可用于项目。</p>
</li>
<li>
<p>创建Java包以存储查询。本教程将假设一个名为<code>org.eclipse.viatra.examples.cps.queries</code> 。</p>
</li>
<li>
<p>使用VIATRA类别中的“ <code>New Query Definition</code>向导在名为的包中创建新的查询定义。本教程假定查询文件名为<code>CPSQueries.vql</code> 。</p>
</li>
<li>
<p>填写第一个查询：</p>
<div id="vql-first" class="listingblock">
<div class="title">queries.vql</div>
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">// Java package declaration, must match the container of the file
package org.eclipse.viatra.examples.cps.queries

// EPackage import
import "http://org.eclipse.viatra/model/cps"

// Pattern declaration
pattern hostIpAddress(host: HostInstance, ip : java String) {
    // Type constraint stating that variables 'host' and 'ip' are connected via a 'nodeIp' attribute
    HostInstance.nodeIp(host,ip);
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>查看模式头，我们看到这个模式有两个参数，意味着它的结果将是一对值，第一个从模型中选择一个<code>HostInstance</code> ，而第二个是一个<code>String</code>文字。这些元素之间的连接由单个约束描述，确保<code>ip</code>变量存储相应<code>HostInstance</code>的<code>nodeIp</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_evaluate_queries_in_the_query_results_view"><a class="link" href="#_evaluate_queries_in_the_query_results_view">3.1.2。在查询结果视图中评估查询</a></h4>
<div class="paragraph">
<p>VIATRA包含一个视图，用于评估各种编辑器的查询结果，并对编辑器中的更改做出反应。</p>
</div>
<div class="paragraph">
<p>“ <strong>查询结果”</strong>视图是调试图形模式的主要工具。通过选择“ <em>窗口/显示视图/查询结果”</em>打开视图，或者只需按<span class="keyseq"><kbd>CTRL</kbd> + <kbd>3</kbd></span>快捷键并开始键入视图的名称。该视图允许加载模型和查询，并自动显示（和更新）查询结果。与已安装的元模型一起，还包含一个示例实例模型，将作为示例在本教程中使用。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/generate_cps_example.png" alt="生成CPS示例">
</div>
<div class="title">图2。初始化示例CPS演示器项目</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>打开我们的示例实例模型（/org.eclipse.viatra.examples.cps.instances/example.cyberphysicalsystem）</p>
</li>
<li>
<p>确保在“查询结果”视图的工具栏中选择“ReteEngine”</p>
</li>
<li>
<p>然后按'从活动编辑器加载模型'（工具栏上的第一个按钮）</p>
</li>
<li>
<p>打开查询规范（vql文件）</p>
</li>
<li>
<p>然后按“从活动编辑器加载查询”按钮</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此时，“ <em>查询结果”</em>视图应包含新创建的模式的匹配项。使用示例模型，您可以看到模式有6个匹配项，每个匹配项都包含一个HostInstance-IP地址对。请注意，“ <em>查询结果”</em>视图提供实时结果：通过更新模型编辑器文件中的模型，例如添加新主机实例或更改其IP地址，结果会自动更新。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/queryresultview.png" alt="查询结果在行动中查看">
</div>
<div class="title">图3。查询结果视图</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未启用“从活动编辑器加载模型”按钮，则表示当前编辑器不包含模型，或者VIATRA不了解编辑器类型。默认情况下，支持EMF树编辑器;其他编辑器类型（如图形编辑器）由其他集成插件支持，例如可从VIATRA存储库获得的GMF或Graphiti集成。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_define_additional_queries"><a class="link" href="#_define_additional_queries">3.1.3。定义其他查询</a></h4>
<div class="paragraph">
<p>在下文中，我们定义了一组模式，用于说明查询语言的其他功能。每个模式都会有一个简短的定义，然后是代码本身和一些关于模式如何工作的评论。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>列出IP地址为空字符串的所有<code>HostInstance</code>元素</p>
<div class="ulist">
<ul>
<li>
<p>与第一种模式类似，此模式仍由单个约束组成。模式约束可以引用Java文字，例如直接的空字符串或数字。此模式在示例模型中应该没有匹配项，因为默认情况下所有实例都设置了非空IP地址。</p>
</li>
<li>
<p>请注意，如果您创建新的<code>HostInstance</code>元素，它将不会出现在匹配结果中。发生这种情况是因为在EMF中未设置且空属性不同（类似于空字符串与Java中的空值之间的差异）。您可以使用<code>neg find</code>构造编写一个查找缺少属性值的模式（请参阅后面的内容）。</p>
<div id="vql-emptyipaddress" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern emptyIpAddress(host: HostInstance) {
    HostInstance.nodeIp(host, "");
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出共享公共IP地址的所有<code>HostInstance</code> - <code>HostInstance</code>对</p>
<div class="ulist">
<ul>
<li>
<p>这种模式更复杂，因为它有三个参数和三个约束。前两个描述了我们看到的相似类型约束。该模式还使用<code>!比较变量<code>host1</code>和<code>host2</code>的值<code>!=</code> （ <em>不等于</em> ）运算符（ <code>==</code>运算符也可用）。</p>
<div id="vql-sameipaddress" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern sameIpAddress(host1 : HostInstance, host2 : HostInstance, commonIp : java String) {
    HostInstance.nodeIp(host1, commonIp);
    HostInstance.nodeIp(host2, commonIp);
    host1!=host2;
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出所有具有<code>HostInstance</code>不正确的IPv4地址的<code>HostInstance</code>元素（例如，不是用点分隔的四个数字）</p>
<div class="ulist">
<ul>
<li>
<p>IP地址字符串的格式良好验证需要特定的验证块，称为<code>check</code>表达式，您可以在其中编写各种<em>Xbase</em>表达式，行为与Java类似，并从项目的类路径访问Java类。在这种情况下，地址值的良好形成用正则表达式评估表示。</p>
</li>
<li>
<p>值得注意的是，检查表达式<strong>必须</strong>是无副作用的，并且只能在属性变量上调用。</p>
<div id="vql-ipformatinvalid" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern ipFormatInvalid(host : HostInstance, ip : java String) {
    HostInstance.nodeIp(host,ip);
    check (
        !ip.matches("^[\\d\\.]+")
    );
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出通过<code>Transition</code>元素连接的<code>State</code>元素</p>
<div class="ulist">
<ul>
<li>
<p>模式体可能使用模式参数以外的变量，例如本例中的变量<code>transition</code> 。这些变量称为局部变量。</p>
</li>
<li>
<p>重要的是要注意，如果两个状态之间存在多个转换，则匹配集仍将仅包括一对状态，因为局部变量不包括在匹配元组中。如果需要所有边，则还应将相应的转换变量声明为参数。</p>
<div id="vql-connectedto" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern connectedTo(state: State, other: State){
    // There exists a transition from `state` to `other`
    State.outgoingTransitions(state, transition);
    Transition.targetState(transition, other);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出以前任何一个条件都失败的错误主机实例。</p>
<div class="ulist">
<ul>
<li>
<p>可以使用模式体之间的<code>or</code>关键字来表示析取。如果至少一个实体具有匹配，则模型元素元组包含在模式的匹配集中。请注意，如果多个实体匹配相同的元组，则模式的匹配集仍将仅包含元组一次（ <em>设置语义</em> ）。</p>
</li>
<li>
<p>可以使用<code>find</code>约束重用模式，这意味着必须从源匹配被调用模式表示的所有条件。</p>
</li>
<li>
<p>此模式还包括<em>一次性</em> （或不关心）变量，从字符“_”开始。这样的声明描述了一个变量，我们只关注它的存在而不是它的价值。</p>
<div id="vql-badhost" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern badHost(host : HostInstance, ip : java String) {
    find sameIpAddress(host, _other, ip);
} or {
    HostInstance.nodeIp(host, ip);
    find emptyIpAddress(host);
} or {
    find ipFormatInvalid(host, ip);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出所有良好的主机实例（既不符合不正确的条件）</p>
<div class="ulist">
<ul>
<li>
<p>由<code>neg find</code>关键字表示的负模式组合用于定义负面条件。这与<code>find</code>约束类似，但值得注意的例外是，如果与所选参数的badHost存在任何匹配，则主机模式无法匹配。</p>
</li>
<li>
<p>在调用主体的其他地方没有使用的负模式调用的那些实际参数是<em>普遍量化的</em> ，这意味着调用模式仅在调用模式的变量不能绑定到匹配元素时才匹配。</p>
<div id="vql-goodhost" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern goodHost(host : HostInstance, ip : java String) {
    HostInstance.nodeIp(host, ip);
    neg find badHost(host, _);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出每个HostInstance的应用程序数</p>
<div class="ulist">
<ul>
<li>
<p>模式可以标记为私有，使模式本身仅在定义的源文件中可见。减少了这些模式的生成代码（例如，不包括生成的Match和Matcher类，以便于访问）。</p>
</li>
<li>
<p>可以使用<code>count find</code>表达式计算模式的匹配。此类表达式的值是使用所选匹配数找到的匹配数。</p>
<div id="vql-countapplications" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">private pattern allocatedApplications(host : HostInstance, app : ApplicationInstance) {
    HostInstance.applications(host, app);
}

pattern countApplications(host : HostInstance, m : java Integer) {
    m == count find allocatedApplications(host, _);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>列出可从其初始状态（直接或间接）到达的状态机的所有状态</p>
<div class="ulist">
<ul>
<li>
<p>使用先前引入的connectedTo模式的传递闭包来计算可达状态。</p>
<div id="vql-reachablestate" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern reachableState(sm :StateMachine, state: State){
    // The initial state of the statemachine is reachable
    StateMachine.initial(sm, state);
} or {
    StateMachine.initial(sm, initial);
    // Ensure the state is indeed included in the state machine; unnecessary in a well-formed model
    StateMachine.states(sm, state);
    // The + symbol after the pattern name represents transitive closure
    find connectedTo+(initial, state);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_validation"><a class="link" href="#_validation">3.1.4。验证</a></h4>
<div class="paragraph">
<p>VIATRA提供了基于框架模式语言创建验证规则的工具。可以在各种EMF实例模型上评估这些规则，并且在违反约束时，将在Eclipse Problems View中自动创建标记。</p>
</div>
<div class="paragraph">
<p><strong>@Constraint</strong>注释可用于从图形模式中派生验证规则作为验证规则。规则的模式标识错误的模型元素，而注释参数提供有关如何在用户界面中呈现结果的信息。注释使用以下参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>key：</em>用于确定需要将约束违规附加到哪些对象的参数列表。</p>
</li>
<li>
<p><em>message：</em>找到约束违规时要显示的消息。该消息可以引用$ symbols或其EMF功能之间的参数变量，例如$ Param1.name $。</p>
</li>
<li>
<p><em>严重性：</em> “警告”或“错误”</p>
</li>
<li>
<p><em>targetEditorId：</em> Eclipse编辑器ID，其中验证框架应将自身注册到上下文菜单。如果在启动验证时始终使用约束，则使用`*`作为通配符。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要查找特定的编辑器ID，我们可以使用<em>插件选择间谍</em>工具和<span class="keyseq"><kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>F1</kbd></span>快捷键。对于一些通用编辑器，例如<strong>Sample Reflective Ecore Editor</strong> ，默认情况下框架提供了这样的注册选项，不需要手动注册。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div id="vql-constraint" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Constraint(targetEditorId = "org.eclipse.viatra.examples.cps.cyberPhysicalSystem.presentation.CyberPhysicalSystemEditorID",
            severity = "error",
            message = "The ip address is not unique",
            key = {host1})
pattern sameIpAddress(host1: HostInstance, host2: HostInstance, commonIp : java String) {
    HostInstance.nodeIp(host1, commonIp);
    HostInstance.nodeIp(host2, commonIp);
    host1!=host2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将这样的约束注释添加到图形模式时，代码生成器初始化验证项目，该项目包括并注册从框架模式派生的规则。可以通过打开新的运行时Eclipse实例来尝试这些规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启动包含工作空间中所有项目的新<code>Eclipse application</code> 。</p>
</li>
<li>
<p>在新启动的Eclipse实例中，在模型编辑器中打开一个错误的实例模型（确保编辑器与添加到<code>targetEditorId</code>参数的编辑器相同）。</p>
</li>
<li>
<p>从<strong>VIATRA验证</strong>下的弹出菜单项<strong>开始验证</strong> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关查看<a href="https://www.vogella.com/tutorials/EclipsePlugin/article.html">vogella.com</a>上的<a href="https://www.vogella.com/tutorials/EclipsePlugin/article.html">Eclipse IDE插件开发教程的</a>更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_more_complex_queries"><a class="link" href="#_more_complex_queries">3.1.5。更复杂的查询</a></h4>
<div class="paragraph">
<p>本节介绍了一组更复杂的查询，这些查询对于引入剩余语言功能（如聚合器）非常有用，同时说明了查询语言允许分解更复杂条件的方式。</p>
</div>
<div class="sect4">
<h5 id="_calculate_the_maximum_number_of_instances"><a class="link" href="#_calculate_the_maximum_number_of_instances">3.1.5.1。计算最大实例数</a></h5>
<div class="paragraph">
<p>通过组合相关特征的值和<em>最大</em>函数的<em>计数</em> ，可以找到模型中定义的实例最多的应用程序类型。<code>sumNumberOfInstances</code>帮助程序模式使用<code>ApplicationType.instances</code>功能的<code>count</code>调用（请注意那里省略了<code>find</code>关键字）。此功能从VIATRA 2.0开始提供，并允许减少简单帮助程序模式的数量，如本教程前面介绍的模式<code>hostIpAddress</code> 。</p>
</div>
<div class="paragraph">
<p>在模式的匹配集中可用计数后，可以使用<code>max find</code>构造轻松计算最大值。</p>
</div>
<div id="vql-maximumNumberOfInstances" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern maximumNumberOfInstances(at : ApplicationType, max : java Integer) {
	max == max find sumNumberOfInstances(at, #);
}

pattern sumNumberOfInstances(at : ApplicationType, n : java Integer) {
	n == count ApplicationType.instances(at, _);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_check_memory_requirements_of_a_host"><a class="link" href="#_check_memory_requirements_of_a_host">3.1.5.2。检查主机的内存要求</a></h5>
<div class="paragraph">
<p>CPS元模型显式存储应用程序的需求，以及主机实例的自由资源值和总资源值。但是，检查应用程序要求以及空闲值和总值是否一致需要进行检查。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/cps_resources.png" alt="CPS元模型中的要求">
</div>
<div class="title">图4。元模型中的需求处理</div>
</div>
<div class="paragraph">
<p>在下面的示例中，我们关注内存要求，但可以为CPU或HDD要求提供类似的查询。我们试图强制执行的<code>FREE MEMORY + SUM(MEMORY OF DEPLOYED APPLICATIONS) = TOTAL MEMORY</code>约束如下： <code>FREE MEMORY + SUM(MEMORY OF DEPLOYED APPLICATIONS) = TOTAL MEMORY</code> 。</p>
</div>
<div class="paragraph">
<p>该模式需要两个辅助模式：其中一个（ <code>applicationTypeRequirementRAM</code> ）负责收集所选<code>Application Type</code>的RAM需求，另一个（ <code>totalMemoryRequirements</code> ）总结所选应用程序实例的所有内存需求。</p>
</div>
<div class="paragraph">
<p>使用这些帮助程序模式， <code>invalidMemoryRequirement</code>模式执行另外两个步骤：（1）它<em>总结</em>了模式<code>totalMemoryRequirements</code>关于分配给主机实例的应用程序实例的结果，以及（2） <em>检查</em>这三个要求是否一致。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">主机实例最多分配给一个应用程序，因此不需要在<code>invalidMemoryRequirement</code>模式中总结所有应用程序的要求。但是，将此元素添加到查询中说明了如果需要多级汇总，如何正确使用<code>sum</code> 。
</td>
</tr>
</table>
</div>
<div id="vql-invalidMemoryRequirement" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern invalidMemoryRequirement(h : HostInstance, available : java Integer, allocated : java Integer, total : java Integer) {
	HostInstance.availableRam(h, available);
	HostInstance.totalRam(h, total);
	allocated == sum find totalMemoryRequirements(h, _, #);
	check(total != allocated + available);
}

private pattern totalMemoryRequirements(h : HostInstance, ai : ApplicationInstance, ram : java Integer) {
	HostInstance.applications(h, ai);
	ApplicationInstance.type(ai, at);
	ram == sum find applicationTypeRequirementRAM(at, #);
}

private pattern applicationTypeRequirementRAM(at : ApplicationType, ram : java Integer) {
	ApplicationType.requirements(at, req);
	ResourceRequirement.requiredRam(req, ram);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_references"><a class="link" href="#_references">3.1.6。参考</a></h4>
<div class="ulist">
<ul>
<li>
<p><a href="query-language.html">模式语言</a></p>
</li>
<li>
<p><a href="addons.html#viatra-validation">验证框架</a></p>
</li>
<li>
<p><a href="addons.html#viatra-qbf">基于查询的功能</a></p>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect2">
<h3 id="_using_queries_programmatically"><a class="link" href="#_using_queries_programmatically">3.2。以编程方式使用查询</a></h3>
<div class="paragraph">
<p>VIATRA Query提供了一个API，用于在各种模型上执行查询，包括支持监听匹配集更改。但是，由于增量评估依赖于索引，因此API还涵盖运行时的生命周期管理。API的核心元素是查询引擎，负责加载查询规范，设置索引和提供匹配结果。代码生成器支持此方法，该代码生成器为图形模式创建运行时表示，并提供类型安全的API以访问VIATRA代码。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/query_runtime.png" alt="查询运行时">
</div>
<div class="title">图5。VIATRA Query的运行时组件概述</div>
</div>
<div class="paragraph">
<p>要开始使用VIATRA Query API，我们必须提供（1）表示模型的Scope和（2）一组查询规范。初始化范围的最简单方法是简单地将EMF ResourceSet包装在新的EMFScope实例中。对于查询规范，可以使用生成的匹配器类作为示例，请参见以下内容。</p>
</div>
<div class="paragraph">
<p>通常，VIATRA Query项目中生成的代码基于（1）查询规范类，表示运行时API的原始VQL规范，与原始模式规范共享限定类名。每个查询规范包括（2）每个模式定义的匹配和匹配嵌套子类（推荐用于一般用法）。最后，（3）每个文件的一个组类，可用于将所有查询初始化，使用与原始vql文件相同的Java类名。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/query_generated_code.png" alt="查询生成的代码">
</div>
<div class="title">图6。查询生成代码的结构</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">VIATRA 2.0中更改了默认生成的API结构。在VIATRA 2.0查询规范，匹配和匹配器生成到单独的类之前。本教程的其余部分依赖于新一代架构;使用旧模式需要在代码中进行一些更新，特别是匹配和matcher类引用相应地更新。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_initialize_a_headless_application"><a class="link" href="#_initialize_a_headless_application">3.2.1。初始化无头应用程序</a></h4>
<div class="paragraph">
<p>为了说明VIATRA Query API的用法，我们将创建一个无头Eclipse应用程序，并通过前一部分中编写的一个查询执行它。这样的应用程序是使用扩展点<code><code>org.eclipse.core.runtime.applications</code></code>注册的Java类（需要<code><code>org.eclipse.core.runtime</code></code>包作为依赖项）。</p>
</div>
<div id="query-runtime-app-extension" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;extension id="queryrunner" point="org.eclipse.core.runtime.applications"&gt;
  &lt;application cardinality="singleton-global" thread="main" visible="true"&gt;
    &lt;run class="org.eclipse.viatra.examples.cps.queries.runner.QueryRunner"/&gt;
  &lt;/application&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><code>IApplication</code></code>接口需要实现两种方法，称为<code><code>start</code></code>和<code><code>stop</code></code> 。在我们的例子中，我们只使用start（并返回0来标记成功执行），stop是不必要的。</p>
</div>
<div id="query-runtime-app-code" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class QueryRunner implements IApplication {

	@Override
	public Object start(IApplicationContext context) throws Exception {
        // Return value 0 is considered as a successful execution on Unix systems
		return 0;
	}

	@Override
	public void stop() {
        // Headless applications do not require specific stop steps
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过专门选择以前创建的扩展，可以将创建的应用程序作为Eclipse应用程序启动。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/run_headless_application.png" alt="运行无头应用程序">
</div>
<div class="title">图7。运行Query Runner应用程序</div>
</div>
</div>
<div class="sect3">
<h4 id="_initializing_a_query_engine"><a class="link" href="#_initializing_a_query_engine">3.2.2。初始化查询引擎</a></h4>
<div class="paragraph">
<p>要初始化查询引擎，作为第一步，必须加载EMF范围。这可以使用以下代码段完成（期望模型文件被复制到查询项目的根目录中）：</p>
</div>
<div id="query-runtime-scope" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private EMFScope initializeModelScope() {
	ResourceSet rs = new ResourceSetImpl();
	rs.getResource(URI.createPlatformPluginURI("org.eclipse.viatra.examples.cps.queries/example.cyberphysicalsystem", true), true);

	return new EMFScope(rs);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们有一个模型范围，它可以用于初始化托管查询引擎。<code><code>ViatraQueryEngine.on</code></code>方法的内部实现确保只为每个范围创建一个查询引擎，并且查询引擎将与支持模型一起处理，使其成为常见情况的首选实现。</p>
</div>
<div class="paragraph">
<p>此外，建议使用将要使用的所有查询准备引擎。为此，生成的查询组（每个查询文件一个）包含一个<code><code>prepare</code></code>方法，该方法创建模式匹配器所需的所有索引，只需要进行一轮模型遍历。</p>
</div>
<div id="query-runtime-prepare" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private ViatraQueryEngine prepareQueryEngine(EMFScope scope) {
	// Access managed query engine
    ViatraQueryEngine engine = ViatraQueryEngine.on(scope);

    // Initialize all queries on engine
	CPSQueries.instance().prepare(engine);

	return engine;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果要加载多个查询组，请创建一个包含所有模式的通用模式组，或创建一个coalesce遍历块，您可以使用<code><code>engine.getBaseIndex().coalesceTraversals()</code></code>方法一起执行多个prepare语句。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_pattern_matcher_api"><a class="link" href="#_the_pattern_matcher_api">3.2.3。模式匹配器API</a></h4>
<div class="paragraph">
<p>使用所有查询引擎的最简单方法是询问查询的所有匹配项。模式匹配器的<code><code>getAllMatches</code></code>方法返回一<strong>组</strong>匹配对象，这些对象允许对其参数进行命名引用</p>
</div>
<div id="query-runtime-printallmatches" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printAllMatches(ViatraQueryEngine engine ) {
	// Access pattern matcher
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	// Get and iterate over all matches
	for (HostIpAddress.Match match : matcher.getAllMatches()) {
		// Print all the matches to the standard output
		System.out.println(match.getHost());
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用<code><code>on</code></code>方法多次请求相同的匹配器是安全的。虽然返回的匹配器实例可能不同，但在内部它们重用相同的索引。鉴于匹配者本身是无国籍的，他们可以安全地使用和忘记，并在稍后再次要求它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也可以使用与<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">消费者</a>匹配的更实用的样式处理。</p>
</div>
<div id="query-runtime-printAllMatches2" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printAllMatches2(ViatraQueryEngine engine) {
    HostIpAddressMatcher matcher = HostIpAddressMatcher.on(engine);
    matcher.forEachMatch(new HostIpAddressProcessor() {

        @Override
        public void process(HostInstance pHost, String pIp) {
            System.out.println(pHost);
        }
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以通过lambda表达式简化如下：</p>
</div>
<div id="query-runtime-printAllMatches3" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printAllMatches3(ViatraQueryEngine engine ) {
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	for (HostInstance hi : matcher.getAllValuesOfhost()) {
		System.out.println(hi);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查和处理仅一次匹配通常是有益的。因此，可以使用<code><code>getOneArbitraryMatch</code></code>方法请求单个匹配。为了处理给定匹配器在当前模型中没有匹配<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Optional.html">项的</a>情况，此方法返回一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Optional.html">Optional</a>实例。</p>
</div>
<div id="query-runtime-printonematch" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printOneMatch(ViatraQueryEngine engine) {
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	// getOneArbitraryMatch returns an optional
	matcher.getOneArbitraryMatch()
		//Print out the match only if available
		.ifPresent(match -&gt; System.out.println(match.getHost()));
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content"><code><code>getOneArbitraryMatch</code></code>返回的匹配既不是随机的也不是确定的，而是未指定的。<em>通常</em>在同一模型上重复调用它（没有任何模型更新）会返回相同的匹配，但这也不能保证。另一方面，在同一模型上重新启动应用程序<em>通常会</em>更改返回的匹配项。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在2.0版之前，如果没有匹配项， <code><code>getOneArbitraryMatch</code></code>返回<code><code>null</code></code> 。如有必要，请不要忘记处理此案例。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>生成的匹配器还包括一些访问参数值的方法。例如，在<code><code>hostIpAddress</code></code>模式的情况下，有一个<code><code>getAllValuesOfip</code></code>方法，它返回参数<code><code>ip</code></code>找到的所有值。</p>
</div>
<div id="query-runtime-printalladdresses" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printAllAddresses(ViatraQueryEngine engine) {
    HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
    for (String ip : matcher.getAllValuesOfip()) {
        System.out.println(ip);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">如果有多个主机具有相同的IP地址，则<code><code>getAllValuesOfip()</code></code>调用将仅返回每个IP地址一次。这与始终返回集合的所有其他API一致。如果需要重复，则必须手动处理所有匹配项。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>所有匹配器功能都支持使用常量过滤匹配。通过使用非空值设置一些过滤器参数，我们声明我们只对所选参数等于给定值的匹配感兴趣。</p>
</div>
<div id="query-runtime-printfilteredmatches" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printFilteredMatches(ViatraQueryEngine engine) {
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	for (HostIpAddress.Match match : matcher.getAllMatches(null, "152.66.102.1")) {
		System.out.println(match);
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">无论接收空值的输入值如何， <code><code>getAllmatches</code></code> （和类似操作）都不会返回具有<code><code>null</code></code>值的匹配项。如果没有匹配项满足所有设置参数，则返回的集合将为空。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果必须重用过滤条件，则可以创建可变匹配，其中相应地设置过滤值。这种方法对于使用命名的setter也很有用（例如，如果要设置多个String参数）或者不想写<code><code>null</code></code>文字。</p>
</div>
<div id="query-runtime-printfilteredmatches2" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printFilteredMatches(ViatraQueryEngine engine) {
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	for (HostIpAddress.Match match : matcher.getAllMatches(null, "152.66.102.1")) {
		System.out.println(match);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果我们只对是否存在满足查询的匹配感兴趣，或者我们想知道有多少匹配，则匹配器具有计算这些匹配的方法。这两种方法都可以与过滤器匹配组合使用。</p>
</div>
<div id="query-runtime-countmatches" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void printCounts(ViatraQueryEngine engine) {
	HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);
	System.out.println(matcher.countMatches());
	System.out.println(matcher.hasMatch(null, null));
	System.out.printf("Count matches with ip 152.66.102.3: %d %n", matcher.countMatches(null, "152.66.102.3"));
    System.out.printf("Has matches with ip 152.66.102.13: %b %n", matcher.hasMatch(null, "152.66.102.13"));
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要求has / count调用紧接着处理所述匹配，通常最好直接调用<code><code>getAllMatches</code></code>或<code><code>getOneArbitraryMatch</code></code> ，并使用它们计算count / existence。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_query_engine_features"><a class="link" href="#_advanced_query_engine_features">3.2.4。高级查询引擎功能</a></h4>
<div class="paragraph">
<p>有些情况下标准引擎生命周期不合适，例如模型不会被卸载但我们希望通过释放索引来节省内存。此外，还有一些功能，如提示处理或匹配更新侦听器支持，未添加到基本实现以保持其API清洁。</p>
</div>
<div id="query-runtime-prepareadvanced" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private AdvancedViatraQueryEngine prepareAdvancedQueryEngine(EMFScope scope) {
    AdvancedViatraQueryEngine engine = AdvancedViatraQueryEngine.createUnmanagedEngine(scope);

    // Initialize all queries on engine
    CPSQueries.instance().prepare(engine);

    return engine;
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">不要忘记使用<code><code>AdvancedQueryEngine.dispose()</code></code>方法手动处理非托管引擎。如果要使用托管查询引擎但使用高级功能，则可以使用<code><code>AdvancedQueryEngine.from(engine)</code></code>调用;但是， <strong>请勿</strong>丢弃此类发动机。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_react_to_match_updates"><a class="link" href="#_react_to_match_updates">3.2.4.1。反应以匹配更新</a></h5>
<div class="paragraph">
<p>高级查询引擎的一个特征是允许监听变化，例如为模式匹配器注册匹配更新监听器。当为模式匹配器设置的匹配与变化的方向一起改变时，触发这样的监听器。</p>
</div>
<div id="query-runtime-changelistener" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IMatchUpdateListener&lt;HostIpAddress.Match&gt; listener = new IMatchUpdateListener&lt;HostIpAddress.Match&gt;() {

    @Override
    public void notifyAppearance(HostIpAddress.Match match) {
        System.out.printf("[ADD] %s %n", match.prettyPrint());
    }

    @Override
    public void notifyDisappearance(HostIpAddress.Match match) {
        System.out.printf("[REM] %s %n", match.prettyPrint());

    }
};

private void addChangeListener(AdvancedViatraQueryEngine engine) {
    HostIpAddress.Matcher matcher = HostIpAddress.Matcher.on(engine);

    try {
        // fireNow = true parameter means all current matches are sent to the listener
        engine.addMatchUpdateListener(matcher, listener, true);
        // execute model manipulations
        matcher.getOneArbitraryMatch()
        	.ifPresent(match -&gt; match.getHost().setNodeIp("123.123.123.123"));
    } finally {
        // Don't forget to remove listeners if not required anymore
        engine.removeMatchUpdateListener(matcher, listener);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过使用<code><code>fireNow</code></code>参数的<code><code>true</code></code>值注册匹配更新侦听器，我们确保将所有现有匹配项发送到侦听器。如果我们只想考虑将来的更新，请将该参数设置为false。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>查看输出时，setNodeIp调用将导致两个更改：第一个表示删除旧匹配（主机 - 旧IP对），而第二个表示添加新匹配（主机 - 新IP对） ）。通常，模型更新通常经常会导致多个匹配更改（即使在单个模式上）。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">使用匹配更新侦听器时要非常小心，因为有时在模型索引处于不一致状态时会调用它们。因此，请勿更新基础模型，也不要执行进一步的模型查询。如果需要这样的情况，请延迟执行后续阶段。更好的是，您可以依赖VIATRA的转换API，确保仅在索引处于一致状态时执行规则。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_query_backends_and_hints"><a class="link" href="#_query_backends_and_hints">3.2.4.2。查询后端和提示</a></h5>
<div class="paragraph">
<p>高级查询引擎还允许使用称为<strong>提示的</strong>非默认设置初始化模式。这些提示最重要的功能是允许设置模式匹配器后端，并且可以更改其他特定于后端的设置。</p>
</div>
<div class="paragraph">
<p>除了基于Rete的增量查询评估外，VIATRA还包括一种基于本地搜索的方法。默认情况下，使用Rete，但通过添加<code><code>org.eclipse.viatra.query.runtime.localsearch</code></code>包作为项目的依赖项，可以使用<code><code>LocalSearchHints</code></code>类生成特定于本地搜索的评估提示。类似的， <code><code>ReteHintOptions</code></code>类中提供了特定于Rete的提示。特定于后端的提示超出了本教程的范围，有关更多详细信息，请参阅相应的VIATRA文档或Javadoc。</p>
</div>
<div id="query-runtime-localsearch" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void queryWithLocalSearch(AdvancedViatraQueryEngine engine) {
	// Prepares a hint for local search
    QueryEvaluationHint hint = LocalSearchHints.getDefault().build();
    // Ensures that local search is used for matching
    HostIpAddress.Matcher matcher = engine.getMatcher(HostIpAddress.instance(), hint);

    // The local search backend features the same API as the Rete backend
    for (HostIpAddress.Match match : matcher.getAllMatches()) {
        System.out.println(match.prettyPrint());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如您所看到的，在初始化之后，可以使用与基于Rete的后端相同的后端查询基于本地搜索的后端，但是，它会在查询时计算结果，而不是依赖于先前缓存的结果。这意味着，通常初始化基于本地搜索的匹配器更便宜（在内存和准备时间），但收集结果更昂贵。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">顾名思义，查询引擎可能会忽略<strong>提示</strong> ，例如，如果设置了错误的配置，或者引擎知道具有更好性能的功能等效方式。有关提示的详细信息，请参阅LocalSearchHints和ReteHintOptions类。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在某些方面，当前（版本2.0）本地搜索后端的行为与原始的基于Rete的算法不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持递归查询。尝试使用递归初始化查询会导致运行时错误。</p>
</li>
<li>
<p>该算法无法提供更改通知，因此禁止在基于本地搜索的查询上注册MatchUpdateListener。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">VIATRA的本地搜索后端几乎与基于Rete的后端在功能上兼容，但具有非常不同的性能特征。如果性能至关重要，请确保理解两种算法，以便为手头的问题选择合适的算法。
</td>
</tr>
</table>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_model_transformation_development"><a class="link" href="#_model_transformation_development">4。模型转型发展</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于模型转换开发，可以使用Java API，允许将转换无缝集成到任何Java应用程序中。但是，为了增强可读性，我们建议使用更高级别的JVM语言，因为它允许将转换定义为此宿主语言的内部DSL。</p>
</div>
<div class="paragraph">
<p>在本教程中，我们依靠<a href="https://eclipse.org/xtend/">Xtend语言</a>来托管VIATRA转换DSL，我们依靠其扩展方法和类型推断支持来减少不必要的元素。但是，其他基于JVM的语言也可以以相似的效率使用（例如，在<a href="https://kotlinlang.org/">Kotlin中，</a>请参阅<a href="https://gist.github.com/doczir/bfe95c470599c5b8e60b400b80f92ea2" class="bare">https://gist.github.com/doczir/bfe95c470599c5b8e60b400b80f92ea2</a> ）。</p>
</div>
<div class="sect2">
<h3 id="_batch_transformations"><a class="link" href="#_batch_transformations">4.1。批量转换</a></h3>
<div class="paragraph">
<p>此练习可帮助受众使用VIATRA Transformation API创建简单的批量转换。转换将把CPS模型中的主机和应用程序转换为部署模型。练习还包括注册初始化转换的菜单命令。</p>
</div>
<div class="sect3">
<h4 id="_create_transformation"><a class="link" href="#_create_transformation">4.1.1。创造转型</a></h4>
<div class="paragraph">
<p>对于转换，我们必须创建一个<em>VIATRA查询项目</em> （ <a href="#_query_development">查询开发教程中</a>的一个也可以重用），并创建一个名为<em>CpsXformM2M.vql</em>的新查询文件来存储我们想要在转换中使用的模式，具体如下内容：</p>
</div>
<div id="bmt-queries" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">import "http://org.eclipse.viatra/model/cps"
import "http://org.eclipse.viatra/model/deployment"
import "http://org.eclipse.viatra/model/cps-traceability"

pattern hostInstance(hostInstance : HostInstance) {
    HostInstance(hostInstance);
}

pattern applicationInstance(
    appType : ApplicationType,
    appInstance : ApplicationInstance
) {
    HostInstance.applications(_, appInstance);
    ApplicationType.instances(appType, appInstance);
}

/**
 * Traceability link access
 */
pattern cps2depTrace(
    cps2dep : CPSToDeployment,
    trace : CPS2DeploymentTrace,
    cpsElement : Identifiable,
    depElement : DeploymentElement
) {
    CPSToDeployment.traces(cps2dep, trace);
    CPS2DeploymentTrace.cpsElements(trace, cpsElement);
    CPS2DeploymentTrace.deploymentElements(trace, depElement);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在Xtend中创建转换类</p>
<div class="ulist">
<ul>
<li>
<p>使用向导创建新的<em>模型转换</em></p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/transformation_wizard.png" alt="转型向导">
</div>
<div class="title">图8。模型转换向导 - 创建新转换</div>
</div>
</li>
<li>
<p>设置转换的名称，然后单击“下一步”</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/batch_transformation_wizard_name.png" alt="批量转换向导名称">
</div>
<div class="title">图9。模型转换向导 - 新批转换的名称</div>
</div>
</li>
<li>
<p>将转换类型设置为<em>BatchTransformation</em> ，然后单击Finish</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/batch_transformation_wizard_type.png" alt="批量转换向导类型">
</div>
<div class="title">图10。模型转换向导 - 新转换的类型</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在创建的文件中，我们必须注册一些扩展方法，更具体地说是我们使用的查询（ <code><code>CpsXformM2m</code></code> ，VQL文件使用的名称）和我们想要引用的EMF EPackages（这里是部署和可跟踪性包）。已经注册了一些其他扩展方法，例如转换规则构建器和模型操作API。</p>
</div>
<div id="bmt-codeextensions" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/** VIATRA Query Pattern group **/
val extension CpsXformM2M cpsXformM2M = CpsXformM2M.instance

/** EMF metamodels **/
val extension DeploymentPackage depPackage = DeploymentPackage.eINSTANCE
val extension TraceabilityPackage trPackage = TraceabilityPackage.eINSTANCE</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>构造函数也将初始化转换（替换生成的转换）</p>
<div class="ulist">
<ul>
<li>
<p>它假定已经创建了资源和跟踪模型</p>
</li>
<li>
<p>IModelManipulations实现用于使模型访问可替换，这样，相同的转换可用于资源集是事务性的情况。其初始化自动生成到<code>createTransformation</code>方法中。</p>
<div id="bmt-init" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val CPSToDeployment cps2dep

new(CPSToDeployment cps2dep, ViatraQueryEngine engine) {
    this.cps2dep = cps2dep
    resource = cps2dep.deployment.eResource
    this.engine = engine
    prepare(engine)
    createTransformation
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>转换将保持活动状态，直到调用<code>dispose</code> （在类中有生成的<code>dispose</code>方法）</p>
</li>
<li>
<p>创建规则以为每个HostInstances生成DeploymentHosts</p>
<div class="ulist">
<ul>
<li>
<p><code>BatchTransformationRuleFactory</code>扩展为规则定义提供构建器API</p>
</li>
<li>
<p>VIATRA查询用作规则的前提条件，这意味着每次更改时给定模式都会激活规则，从而允许相应地更新输出。</p>
<div id="bmt-rule-structure" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val hostRule = createRule.precondition(HostInstance.instance).action[/*Action part*/].build</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>指定规则触发时要运行的操作。它将在输出模型中创建转换后的<code>DeploymentHost</code>元素，以及关联源<code>HostInstance</code>和目标<code>DeploymentHost</code>的跟踪元素：</p>
<div id="bmt-hostrule" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val hostRule = createRule(HostInstance.instance).action[
    val cpsHostInstance = it.hostInstance
    val nodeIp = cpsHostInstance.nodeIp
    println('''Mapping host with IP: «nodeIp»''')

    /** Create &amp; initialize DeploymentHost in output model **/
    val depHost = cps2dep.deployment.createChild(deployment_Hosts, deploymentHost) =&gt; [
        set(deploymentHost_Ip, nodeIp)
    ]

    /** Create trace element in trace model **/
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, cpsHostInstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, depHost)
    ]

    println('''Mapped with IP: «nodeIp»''')
].build</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在2.1版之前， <code>createRule</code>方法是无参数的，并且必须在<code>precondition</code>方法中提供查询规范。这是因为旧的API在普通Java（而不是Xtend或Kotlin）中编写转换时需要一些意外的类型转换。这种方法在VIATRA 2.1中仍然可用，但它被标记为已弃用。
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>为<code>ApplicationInstance</code>对象创建<code>DeploymentApplication</code>元素的规则看起来很相似。它必须找到从分配源<code>ApplicationInstance</code>的<code>HostInstance</code>创建的<code>DeploymentHost</code> ，因此它假定<code>hostRule</code>已经触发：</p>
<div id="bmt-apprule" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val applicationRule = createRule(ApplicationInstance.instance).action[
    val cpsApplicationInstance = it.appInstance
    val appId = cpsApplicationInstance.identifier
    println('''Mapping application with ID: «appId»''')

    /* Find the DeploymentHost created from the HostInstance to which the source ApplicationInstance is allocated */
    val cpsHostInstance = cpsApplicationInstance.allocatedTo
    val depHost = engine.cps2depTrace.getAllValuesOfdepElement(null, null, cpsHostInstance).filter(DeploymentHost).head
    /* Create &amp; initialize DeploymentApplication in this DeploymentHost */
    val deploymentApplication = depHost.createChild(deploymentHost_Applications, deploymentApplication) =&gt; [
        set(deploymentApplication_Id, appId)
    ]

    /* Create trace element in trace model */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, cpsApplicationInstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, deploymentApplication)
    ]

    println('''Mapped application with ID: «appId»''')
].build</code></pre>
</div>
</div>
</li>
<li>
<p>使用上面定义的规则实现执行转换的方法：</p>
<div class="ulist">
<ul>
<li>
<p>由于我们使用非增量（整个模型总是在模型更改时重新转换），输出和跟踪模型将在任何规则触发之前被清除</p>
</li>
<li>
<p>注意按正确的顺序解雇规则</p>
<div id="bme-execute" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">def execute() {
    println('''Executing transformation on: Cyber-physical system: «cps2dep.cps.identifier»''')
    /* Clear output &amp; trace model for batch transformation**/
    cps2dep.deployment.hosts.clear
    cps2dep.traces.clear
    /* Fire transformation rules**/
    hostRule.fireAllCurrent
    applicationRule.fireAllCurrent
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_create_a_menu_command_to_execute_the_transformation"><a class="link" href="#_create_a_menu_command_to_execute_the_transformation">4.1.2。创建菜单命令以执行转换</a></h4>
<div class="ulist">
<ul>
<li>
<p>使用以下附加依赖项创建UI插件：</p>
<div id="bmt-ui-dependencies" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">org.eclipse.ui,
com.incquerylabs.course.cps.viatra.batch;bundle-version="0.1.0",
org.eclipse.viatra.examples.cps.traceability;bundle-version="0.1.0",
org.eclipse.viatra.query.runtime;bundle-version="1.2.0"</code></pre>
</div>
</div>
</li>
<li>
<p>创建处理程序实现</p>
<div id="bmt-handler" class="listingblock">
<div class="title">TransformHandler.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TransformHandler extends AbstractHandler implements IHandler {

    ViatraQueryEngine engine;
    CPS2DeploymentTransformationViatra transformation;

    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        IStructuredSelection selection =
            (IStructuredSelection) HandlerUtil.getCurrentSelection(event);

        CPSToDeployment tracemodel =
            (CPSToDeployment) selection.getFirstElement();

        if (engine == null){
            try {
                engine = ViatraQueryEngine.on(
                            new EMFScope(
                                tracemodel.eResource().getResourceSet()));
                transformation = new CPS2DeploymentTransformationViatra(tracemodel,
                                                                engine);
            } catch (ViatraQueryException e) {
                throw new ExecutionException(e.getMessage(), e);
            }
        }
        transformation.execute();

        return null;
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>在<code>plugin.xml</code>的<code>CPSToDeployment</code>元素的上下文菜单中注册处理程序：</p>
<div id="bmt-command" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;extension point="org.eclipse.ui.commands"&gt;
    &lt;command
        defaultHandler="com.incquerylabs.course.cps.viatra.batch.ui.TransformHandler"
        id="com.incquerylabs.course.cps.viatra.batch.ui.command"
        name="Transform"&gt;
    &lt;/command&gt;
&lt;/extension&gt;
&lt;extension point="org.eclipse.ui.menus"&gt;
    &lt;menuContribution allPopups="false"
            locationURI="popup:org.eclipse.ui.popup.any?after=additions"&gt;
        &lt;command commandId="com.incquerylabs.course.cps.viatra.batch.ui.command"
                style="push"&gt;
            &lt;visibleWhen checkEnabled="false"&gt;
                &lt;with variable="selection"&gt;
                    &lt;count value="1"&gt;
                    &lt;/count&gt;
                    &lt;iterate&gt;
                        &lt;adapt type="org.eclipse.viatra.examples.cps.traceability.CPSToDeployment"&gt;
                        &lt;/adapt&gt;
                    &lt;/iterate&gt;
                &lt;/with&gt;
            &lt;/visibleWhen&gt;
        &lt;/command&gt;
    &lt;/menuContribution&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_execute_the_transformation"><a class="link" href="#_execute_the_transformation">4.1.3。执行转换</a></h4>
<div class="ulist">
<ul>
<li>
<p>启动<em>Eclipse应用程序</em></p>
</li>
<li>
<p>创建一个通用资源项目</p>
</li>
<li>
<p>如果您已有资源，请在其中复制<code>.cyberphysicalsystem</code>资源，或创建新的<em>CyberPhysicalSystem模型</em></p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example1.png" alt="viatraIncr example1">
</div>
<div class="title">图11。使用.cyberphysicalsystem资源的项目</div>
</div>
</li>
<li>
<p>创建部署模型</p>
<div class="ulist">
<ul>
<li>
<p>根元素应该是<em>部署</em></p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example2.png" alt="viatraIncr example2">
</div>
<div class="title">图12。新的部署模型</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>创建可跟踪性模型</p>
<div class="ulist">
<ul>
<li>
<p>根元素应为<em>CPS To Deployment</em></p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example3.png" alt="viatraIncr example3">
</div>
<div class="title">图13。新的可追溯性模型</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>在Traceability编辑器中，在上下文菜单中使用<em>Load Resources ...加载</em> CPS和Deployment模型</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example4.png" alt="viatraIncr example4">
</div>
<div class="title">图14。将必要的资源加载到可跟踪性模型中</div>
</div>
</li>
<li>
<p>在属性视图中设置可跟踪性模型的CPS和部署参考</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example5.png" alt="viatraIncr example5">
</div>
<div class="title">图15。设置可跟踪性模型的引用</div>
</div>
</li>
<li>
<p>在部署模型中创建新的<em>HostType</em> ， <em>HostInstance</em> ， <em>ApplicationType</em>和<em>ApplicationInstance</em></p>
</li>
<li>
<p>使用创建的命令执行转换（在Traceability模型根的上下文菜单上）</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatrabatch.png" alt="viatrabatch">
</div>
<div class="title">图16。上下文菜单中的转换命令</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_2"><a class="link" href="#_references_2">4.1.4。参考</a></h4>
<div class="ulist">
<ul>
<li>
<p>VIATRA Transformation API： <a href="transformations.html" class="bare">transformations.html</a></p>
</li>
<li>
<p>进一步的转换示例： <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">https</a> ： <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">//wiki.eclipse.org/VIATRA/Transformation/Examples</a></p>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect2">
<h3 id="_event_driven_transformations"><a class="link" href="#_event_driven_transformations">4.2。事件驱动的转换</a></h3>
<div class="paragraph">
<p>此练习使观众能够使用VIATRA Transformation API创建简单的事件驱动转换。转换将基于CPS模型创建（然后在活动时逐步更新）部署模型。练习还包括注册初始化转换的菜单命令。</p>
</div>
<div class="paragraph">
<p>鉴于批处理和事件驱动的转换非常相似，本节主要关注差异;如果需要，请参阅<a href="#_batch_transformations">批量转换教程</a> 。</p>
</div>
<div class="sect3">
<h4 id="_create_transformation_2"><a class="link" href="#_create_transformation_2">4.2.1。创造转型</a></h4>
<div class="paragraph">
<p>必须为事件驱动规则定义特定模式;请注意，批处理定义存在细微差别，例如，还有一个名为<em>allocatedDeploymentApplication</em>的附加模式。</p>
</div>
<div id="emt-queries" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">import "http://org.eclipse.viatra/model/cps"
import "http://org.eclipse.viatra/model/deployment"
import "http://org.eclipse.viatra/model/cps-traceability"

pattern hostInstance(hostInstance) {
    HostInstance(hostInstance);
}

pattern applicationInstance(appType, appInstance){
    HostInstance.applications(_, appInstance);
    ApplicationType.instances(appType, appInstance);
}

pattern allocatedDeploymentApplication(depHost, depApp) {
    DeploymentHost.applications(depHost, depApp);
}

pattern cps2depTrace(cps2dep, trace, cpsElement, depElement) {
    CPSToDeployment.traces(cps2dep, trace);
    CPS2DeploymentTrace.cpsElements(trace, cpsElement);
    CPS2DeploymentTrace.deploymentElements(trace, depElement);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>创建转换类（最好是Xtend）</p>
<div class="ulist">
<ul>
<li>
<p>使用向导创建新的<em>模型转换</em></p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/transformation_wizard.png" alt="转型向导">
</div>
<div class="title">图17。模型转换向导 - 创建新转换</div>
</div>
<div class="ulist">
<ul>
<li>
<p>设置转换的名称，然后单击“下一步”</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/eventdriven_transformation_wizard_name.png" alt="eventdriven转换向导名称">
</div>
<div class="title">图18。模型转换向导 - 新事件驱动转换的名称</div>
</div>
</li>
<li>
<p>将转换类型设置为<em>EventDrivenTransformation</em> ，然后单击Finish</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/eventdriven_transformation_wizard_type.png" alt="eventdriven转换向导类型">
</div>
<div class="title">图19。模型转换向导 - 新转换的类型</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>注册使用的特定于域的API作为扩展，已生成通用API</p>
<div id="emt-extensions" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/*
 * VIATRA Query group
 */
val extension CpsXformM2M cpsXformM2M = CpsXformM2M.instance

/*
 * EMF metamodels
 */
val extension DeploymentPackage depPackage = DeploymentPackage::eINSTANCE
val extension TraceabilityPackage trPackage = TraceabilityPackage::eINSTANCE</code></pre>
</div>
</div>
</li>
<li>
<p>构造函数也将初始化转换（替换生成的转换）</p>
<div class="ulist">
<ul>
<li>
<p>它假定已经创建了输出和跟踪模型</p>
</li>
<li>
<p>IModelManipulations实现用于使模型访问可替换，这种方式相同的转换可用于资源集是事务性的情况</p>
<div id="emt-init" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val CPSToDeployment cps2dep

new(CPSToDeployment cps2dep, ViatraQueryEngine engine) {
    this.cps2dep = cps2dep
    this.resource = cps2dep.deployment.eResource
    this.engine = engine
    prepare(engine)
    createTransformation
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>转换将保持活动状态，直到调用<code>dispose</code> （已生成<code>dispose</code>方法）</p>
</li>
<li>
<p>创建规则以为每个HostInstances创建DeploymentHosts</p>
<div class="ulist">
<ul>
<li>
<p>EventDrivenTransformationRuleFactory扩展为规则定义提供了构建器API</p>
</li>
<li>
<p>VIATRA查询模式用作规则的前提条件，这意味着每当给定模式更改时，将激活规则，从而允许相应地更新输出。</p>
<div id="emt-rule-structure" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val hostRule = createRule(HostInstanceMatcher.querySpecification)</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在2.1版之前， <code>createRule</code>方法是无参数的，并且必须在<code>precondition</code>方法中提供查询规范。这是因为旧的API在普通Java（而不是Xtend或Kotlin）中编写转换时需要一些意外的类型转换。这种方法在VIATRA 2.1中仍然可用，但它被标记为已弃用。
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>为模式中的每种更改添加操作以更新跟踪和输出模型：</p>
<div class="ulist">
<ul>
<li>
<p>在创建HostInstance时</p>
<div id="emt-hostrule" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.CREATED) [
    val hostinstance = hostInstance
    val nodeIp = hostInstance.nodeIp
    println('''Mapping host with IP: «nodeIp»''')
    /* Create new DeploymentHost element in output model */
    val host = cps2dep.deployment.createChild(deployment_Hosts, deploymentHost) =&gt; [
        set(deploymentHost_Ip, nodeIp)
    ]
    /* Create trace entry */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, hostinstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, host)
    ]
]</code></pre>
</div>
</div>
</li>
<li>
<p>在更改HostInstance时</p>
<div id="emt-hostupdated" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.UPDATED) [
    /* find associated DeploymentHost element */
    val depHost = engine.cps2depTrace
                        .getOneArbitraryMatch(cps2dep, null, hostInstance, null)
                        .depElement as DeploymentHost
    val hostIp = depHost.ip
    println('''Updating mapped host with IP: «hostIp»''')
    /* update IP attribute */
    val nodeIp = hostInstance.nodeIp
    depHost.set(deploymentHost_Ip, nodeIp)
    println('''Updated mapped host with IP: «nodeIp»''')
]</code></pre>
</div>
</div>
</li>
<li>
<p>删除HostInstance后</p>
<div id="emt-hostdeleted" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.DELETED) [
    /* Find trace element */
    val traceMatch = engine.cps2depTrace
                        .getOneArbitraryMatch(cps2dep, null, hostInstance, null)
    val hostIp = hostInstance.nodeIp
    println('''Removing host with IP: «hostIp»''')
    /* Remove DeploymentHost element */
    cps2dep.deployment.remove(deployment_Hosts, traceMatch.depElement)
    /* Remove trace */
    cps2dep.remove(CPSToDeployment_Traces, traceMatch.trace)
    println('''Removed host with IP: «hostIp»''')
]</code></pre>
</div>
</div>
</li>
<li>
<p>添加默认激活生命周期，然后构建规则：</p>
<div class="ulist">
<ul>
<li>
<p>生命周期定义用于确定转换操作可以定义的可能状态的状态机。</p>
<div id="emt-lifecycle" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.addLifeCycle(Lifecycles.getDefault(true, true)).build</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>为ApplicationInstances创建DeploymentApplication元素的规则看起来很相似</p>
<div id="emt-applicationrule" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">val applicationRule = createRule(ApplicationInstanceMatcher.querySpecification)
.action(CRUDActivationStateEnum.CREATED) [
    /* Find associated DeploymentHost for the HostInstance this application is allocated to */
    val depHost = engine.cps2depTrace.getAllValuesOfdepElement(null, null, appInstance.allocatedTo).filter(
        DeploymentHost).head
    val appinstance = appInstance
    val appId = appInstance.identifier
    println('''Mapping application with ID: «appId»''')
    /* Create DeploymentApplication application in host */
    val app = depHost.createChild(deploymentHost_Applications, deploymentApplication) =&gt; [
        set(deploymentApplication_Id, appId)
    ]
    /* create trace entry */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, appinstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, app)
    ]
    println('''Mapped application with ID: «appId»''')
].action(CRUDActivationStateEnum.UPDATED) [
    /* find associated DeploymentApplication */
    val depApp = engine.cps2depTrace.getOneArbitraryMatch(cps2dep, null, appInstance, null).
        depElement as DeploymentApplication
    /* Update ID */
    if (depApp.id != appInstance.identifier)
        depApp.set(deploymentApplication_Id, appInstance.identifier)
].action(CRUDActivationStateEnum.DELETED) [
    /* find associated DeploymentApplication */
    val trace = engine.cps2depTrace.getAllValuesOftrace(null, appInstance, null).head as CPS2DeploymentTrace
    val depApp = trace.deploymentElements.head as DeploymentApplication
    /* Remove application from host */
    engine.allocatedDeploymentApplication.getAllValuesOfdepHost(depApp).head.remove(deploymentHost_Applications, depApp)
    /* Remove traces */
    cps2dep.remove(CPSToDeployment_Traces, trace)
].addLifeCycle(Lifecycles.getDefault(true, true)).build</code></pre>
</div>
</div>
</li>
<li>
<p>使用上面定义的规则替换生成的<code>createTransformation</code></p>
<div class="ulist">
<ul>
<li>
<p>对于可能激活多个规则的情况（例如，将新的HostInstance添加到已设置已分配应用程序的模型中），冲突解决程序用于提供要执行的规则的固定顺序。</p>
</li>
<li>
<p>我们使用基于优先级的解析器（优先级较低的规则将首先执行），它考虑要删除的消失规则的优先级（消失的应用程序的优先级将为-2）</p>
<div id="emt-create" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private def createTransformation() {
    //Initialize model manipulation API
    this.manipulation = new SimpleModelManipulations(engine)

    //Initialize event-driven transformation
    val fixedPriorityResolver = new InvertedDisappearancePriorityConflictResolver
    fixedPriorityResolver.setPriority(hostRule.ruleSpecification, 1)
    fixedPriorityResolver.setPriority(applicationRule.ruleSpecification, 2)

    transformation = EventDrivenTransformation.forEngine(engine)
        .setConflictResolver(fixedPriorityResolver)
        .addRule(hostRule)
        .addRule(applicationRule)
        .build
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_menu_command_to_execute_the_transformation"><a class="link" href="#_creating_a_menu_command_to_execute_the_transformation">4.2.2。创建菜单命令以执行转换</a></h4>
<div class="ulist">
<ul>
<li>
<p>创建UI插件</p>
</li>
<li>
<p>添加依赖项：</p>
<div id="emt-dependencies" class="listingblock">
<div class="title">MANIFEST.MF</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">org.eclipse.ui,
com.incquerylabs.course.cps.viatra.incr;bundle-version="0.1.0",
org.eclipse.viatra.examples.cps.traceability;bundle-version="0.1.0",
org.eclipse.viatra.query.runtime;bundle-version="1.2.0"</code></pre>
</div>
</div>
</li>
<li>
<p>创建处理程序实现</p>
<div id="emt-handler" class="listingblock">
<div class="title">ToggleTransformationHandler.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ToggleTransformationHandler extends AbstractHandler implements IHandler {

    ViatraQueryEngine engine;
    CPS2DeploymentTransformationViatra transformation;


    /* (non-Javadoc)
     * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
     */
    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        IStructuredSelection selection =
            (IStructuredSelection) HandlerUtil.getCurrentSelection(event);

        CPSToDeployment tracemodel =
            (CPSToDeployment) selection.getFirstElement();

        if(transformation == null) {
            if(engine == null) {
                try {
                    engine = ViatraQueryEngine.on(
                                new EMFScope(
                                    tracemodel.eResource()
                                                .getResourceSet()));
                    transformation =
                        new CPS2DeploymentTransformationViatra(tracemodel,
                                                                engine);
                } catch (ViatraQueryException e) {
                    throw new ExecutionException(e.getMessage(), e);
                }
            }
        } else {
            transformation.dispose();
        }

        return null;
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>在“CPSToDeployment”元素的上下文菜单中注册处理程序</p>
<div id="emt-command" class="listingblock">
<div class="title">plugin.xml中</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;extension point="org.eclipse.ui.commands"&gt;
    &lt;command defaultHandler="com.incquerylabs.course.cps.viatra.incr.ui.ToggleTransformationHandler"
            id="com.incquerylabs.course.cps.viatra.incr.ui.command"
            name="Toggle Transformation"&gt;
    &lt;/command&gt;
&lt;/extension&gt;
&lt;extension point="org.eclipse.ui.menus"&gt;
    &lt;menuContribution allPopups="false"
            locationURI="popup:org.eclipse.ui.popup.any?after=additions"&gt;
        &lt;command commandId="com.incquerylabs.course.cps.viatra.incr.ui.command"
                label="Toggle Incremental Transformation"
                style="push"&gt;
            &lt;visibleWhen checkEnabled="false"&gt;
                &lt;with variable="selection"&gt;
                    &lt;count value="1"&gt;
                    &lt;/count&gt;
                    &lt;iterate&gt;
                        &lt;adapt type="org.eclipse.viatra.examples.cps.traceability.CPSToDeployment"&gt;
                        &lt;/adapt&gt;
                    &lt;/iterate&gt;
                &lt;/with&gt;
            &lt;/visibleWhen&gt;
        &lt;/command&gt;
    &lt;/menuContribution&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_executing_the_transformation"><a class="link" href="#_executing_the_transformation">4.2.3。执行转换</a></h4>
<div class="ulist">
<ul>
<li>
<p>启动运行时eclipse</p>
</li>
<li>
<p>创建一个通用资源项目</p>
</li>
<li>
<p>复制<code>.cyberphysicalsystem</code>资源</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example1.png" alt="viatraIncr example1">
</div>
<div class="title">图20。使用.cyberphysicalsystem资源的项目</div>
</div>
</li>
<li>
<p>创建一个空的部署模型</p>
<div class="ulist">
<ul>
<li>
<p>根元素应该是部署</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example2.png" alt="viatraIncr example2">
</div>
<div class="title">图21。新的部署模型</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>创建可跟踪性模型</p>
<div class="ulist">
<ul>
<li>
<p>根元素应为“CPS To Deployment”</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example3.png" alt="viatraIncr example3">
</div>
<div class="title">图22。新的可追溯性模型</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>在Traceability编辑器中，在上下文菜单中使用“Load Resources ..”加载CPS和Deployment模型</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example4.png" alt="viatraIncr example4">
</div>
<div class="title">图23。将必要的资源加载到可跟踪性模型中</div>
</div>
</li>
<li>
<p>在属性视图中设置可跟踪性模型的CPS和部署参考</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example5.png" alt="viatraIncr example5">
</div>
<div class="title">图24。设置可跟踪性模型的引用</div>
</div>
</li>
<li>
<p>使用创建的命令切换转换（在Traceability模型根的上下文菜单上）</p>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example6.png" alt="viatraIncr example6">
</div>
<div class="title">图25。在上下文菜单中切换转换</div>
</div>
</li>
<li>
<p>在第一次修改输入模型时完成初始激活，例如创建一个新的HostType</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_3"><a class="link" href="#_references_3">4.2.4。参考</a></h4>
<div class="ulist">
<ul>
<li>
<p>VIATRA Transformation API： <a href="transformations.html" class="bare">transformations.html</a></p>
</li>
<li>
<p>进一步的转换示例： <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">https</a> ： <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">//wiki.eclipse.org/VIATRA/Transformation/Examples</a></p>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_model_transformations"><a class="link" href="#_debugging_model_transformations">4.3。调试模型转换</a></h3>
<div class="paragraph">
<p>模型转换的开发和调试不是一件轻而易举的事，但软件调试的基本概念也可以映射到这个领域。调试器可用于检测错误，以及更好地理解程序的结构和行为。对程序的直接控制允许程序员遵循执行流程或在任何所需的点停止程序。然后可以检查其当前状态并验证软件的正确性。这些属性在模型转换领域也是非常理想的。VIATRA框架包含一个支持以下功能的调试器框架：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>显示远程VIATRA转换的状态。</p>
</li>
<li>
<p>允许用户通过标准调试器命令（“跳过”，“继续”）或选择要执行的下一个激活来控制VIATRA转换的执行。</p>
</li>
<li>
<p>显示与调试下的转换关联的模型实例。</p>
</li>
<li>
<p>允许用户定义各种转换断点。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_setting_up_the_transformation_under_debugging"><a class="link" href="#_setting_up_the_transformation_under_debugging">4.3.1。在调试下设置转换</a></h4>
<div class="paragraph">
<p>为了支持调试，模型转换定义需要稍作修改。这些可以通过两种不同的方式完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果正在新开发转换，强烈建议使用VIATRA模型转换创建向导。如下图所示，用户可以选中“VIATRA调试器支持”复选框，这样生成的代码将包含适当的设置。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用<em>VIATRA Debugger Session Name</em>可选参数定义转换的文本标识符。使用此标识符有助于转换开发人员在使用转换调试器时区分不同的模型转换会话。
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/wizard_selection.png" alt="向导选择">
</div>
<div class="title">图26。打开向导</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/wizard_debugging.png" alt="向导调试">
</div>
<div class="title">图27。选择调试器支持</div>
</div>
<div class="ulist">
<ul>
<li>
<p>如果已存在转换，则需要手动修改模型转换定义。这涉及将VIATRA调试配置添加到VIATRA转换构建器。以下示例代码段显示了如何在示例中实现此功能。</p>
</li>
</ul>
</div>
<div id="Transformation-setup" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">private def createTransformation() {
    import org.eclipse.viatra.transformation.debug.configuration.TransformationDebuggerConfiguration
    ...
    transformation = BatchTransformation.forEngine(engine).addAdapterConfiguration(new TransformationDebuggerConfiguration("TestTransformation")).build
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于VIATRA转换调试器是<em>远程调试</em>样式调试器，因此需要手动启动示例转换。在批量转换的情况下尤其如此，因为事件驱动的转换通常连续运行。该示例使用简单的命令和处理程序在预定义的测试模型上运行模型转换。</p>
</div>
<div id="Transformation-handler" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">public class BatchTestHandler extends AbstractHandler {
    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        final Job job = new Job(JOB_NAME) {
            protected IStatus run(IProgressMonitor monitor) {
                // Load the CPS model
                CPSModelInitializer init = new CPSModelInitializer();
                CPSToDeployment cps2dep = init.loadModel(SOURCE_MODEL_URI);
                // Initialize CPS to Deployment Transformation
                CPSTransformation transformation = new CPSBatchTransformation(cps2dep);
                // Execute the transformation and observe the effects of the selected adapter
                transformation.execute();
                transformation.dispose();
                return Status.OK_STATUS;
            }
        };
        job.schedule();
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了正确启动VIATRA调试器运行时代理程序，应使用以下命令行参数启动目标Eclipse实例：</p>
</div>
<div id="Transformation-vmargs" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">-Dcom.sun.management.jmxremote.port="port to be used, typically 1099"
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_debugger_ui"><a class="link" href="#_using_the_debugger_ui">4.3.2。使用调试器UI</a></h4>
<div class="paragraph">
<p>以下部分描述了在设置调试基础结构后如何使用VIATRA转换调试器UI元素。本指南的这一部分假定目标Eclipse实例正在运行。</p>
</div>
<div class="sect4">
<h5 id="_connecting_to_the_transformation_under_debugging"><a class="link" href="#_connecting_to_the_transformation_under_debugging">4.3.2.1。连接到调试下的转换</a></h5>
<div class="ulist">
<ul>
<li>
<p>如果安装了VIATRA调试器功能，则Eclipse Debug透视图将包含调试器UI元素，一旦选择了此透视图，就会显示相关的VIATRA调试视图。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/debug_persp_empty.png" alt="调试透视图">
</div>
<div class="title">图28。使用调试器视图调试透视图</div>
</div>
<div class="ulist">
<ul>
<li>
<p>可以通过启动<em>VIATRA Transformation Remote Debugging</em>调试配置来初始化调试器。可以与任何其他Eclipse启动配置类似地指定调试配置。如下图所示，首先需要指定目标端口。此值必须等于目标Eclipse启动配置中指定的端口值（通常为1099）。</p>
</li>
<li>
<p>接下来，需要使用端口文本字段旁边的按钮查询端口。</p>
</li>
<li>
<p>查询完成后，用户可以从该端口上存在的一组转换实例中进行选择。</p>
</li>
<li>
<p>最后，需要选择工作空间中存在的类文件，因为与转换关联的断点将绑定到此文件的资源。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/debug_newlaunch.png" alt="班级选择">
</div>
<div class="title">图29。编辑启动配置</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/newtransf_classsel.png" alt="班级选择">
</div>
<div class="title">图30。选择一个班级</div>
</div>
<div class="ulist">
<ul>
<li>
<p>保存这些启动配置，一旦用户定义了目标转换的配置，就可以重复使用它而无需任何必要的修改（假设用户没有修改转换会话的ID）。</p>
</li>
<li>
<p>启动调试配置后，初始化调试会话，允许用户观察和控制所选转换的执行。这里转换调试会话显示在Eclipse调试视图中。然而，还有其他当代视图显示所选调试会话的详细信息。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/debug_persp.png" alt="调试透视图">
</div>
<div class="title">图31。调试器处于初始化状态</div>
</div>
</div>
<div class="sect4">
<h5 id="_browsing_the_transformation_state"><a class="link" href="#_browsing_the_transformation_state">4.3.2.2。浏览转换状态</a></h5>
<div class="paragraph">
<p>VIATRA转换调试器的主要用例之一是使转换开发人员能够在其执行顺序的某一点观察VIATRA转换的状态。调试器允许转换开发人员观察以下转换元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>活动转换规则激活</p>
</li>
<li>
<p>输入和输出模型实例</p>
</li>
<li>
<p>下次激活的输入参数</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要使用调试器UI元素，请选择表示转换的调试堆栈跟踪：</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/selectthread.png" alt="选择转换堆栈帧">
</div>
<div class="title">图32。选择转换堆栈帧</div>
</div>
<div class="paragraph">
<p><em>Transformation Browser</em>视图负责观察转换的内部状态。它允许用户观察当前的转换规则激活，并支持各种转换断点的定义。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/transformation_rules.png" alt="结核病规则">
</div>
<div class="title">图33。转换浏览器按转换规则排序</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/conflict_set.png" alt="结核病冲突集">
</div>
<div class="title">图34。转换浏览器按EVM冲突设置状态排序</div>
</div>
<div class="paragraph">
<p><em>转换模型实例查看</em>器使转换开发人员能够观察与在<em>Adaptable Transformation Browser</em>视图中选择的模型转换相关的源和目标模型实例的状态。此视图在具有属性视图支持的多选项卡式树视图中显示模型实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/model_browser.png" alt="VTB视图">
</div>
<div class="title">图35。VIATRA模型实例浏览器视图</div>
</div>
<div class="paragraph">
<p>可以通过<em>Variables</em> Eclipse Debug View观察下一个要执行的激活的参数。在选择给定的调试堆栈帧（表示转换规则激活）之后，转换规则前提条件的参数显示为变量。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/variables_view.png" alt="变量视图">
</div>
<div class="title">图36。VIATRA转换前提条件为变量</div>
</div>
</div>
<div class="sect4">
<h5 id="_controlling_the_transformation_execution_sequence"><a class="link" href="#_controlling_the_transformation_execution_sequence">4.3.2.3。控制转换执行顺序</a></h5>
<div class="paragraph">
<p>VIATRA转换调试器使转换开发人员能够在调试时控制转换的执行顺序。这可以通过以下方式完成。</p>
</div>
<div class="sect5">
<h6 id="_using_breakpoints_and_standard_debug_commands"><a class="link" href="#_using_breakpoints_and_standard_debug_commands">使用断点和标准调试命令</a></h6>
<div class="paragraph">
<p>Transformation调试器支持以下断点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>激活断点</em> ：可以通过选择规则激活并使用<em>转换浏览器</em>视图上的相应命令来切换激活断点。</p>
</li>
<li>
<p><em>规则断点</em> ：可以通过选择模型转换实例并使用适当的UI元素来创建规则断点。完成此操作后，将打开以下对话框，转换开发人员可在其上指定转换规则的名称。一旦即将执行激活，调试器将检查激活是否源自与指定名称关联的规则。如果此条件为真，则暂停执行。</p>
</li>
<li>
<p><em>条件断点</em> ：这些断点允许用户定义基于VIATRA查询的条件以停止转换的执行。要创建条件断点，请在“ <em>转换浏览器”</em>视图中选择模型转换实例，然后在视图的命令栏上使用相应的命令。然后，将打开一个对话框窗口，允许用户定义VIATRA查询模式。一旦模式的匹配集改变，就停止执行转换。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/rule_breakpoint.png" alt="规则断点定义">
</div>
<div class="title">图37。规则断点定义对话框</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/conditional_breakpoint.png" alt="条件断点定义">
</div>
<div class="title">图38。条件断点定义对话框</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">此编辑器重用基于标准Xtext的VIATRA查询编辑器，但在这种情况下，应省略包定义（因为文件中没有封闭的Eclipse资源）。此外，此时定义只能包含一个公共模式，但此限制不适用于私有模式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">调试器运行时组件重用VIATRA查询语言解析器基础结构来解析<em>条件断点中</em>包含的模式。调试器运行时组件显式地不需要加载解析器基础结构的类（以便最小化所述运行时组件的依赖性）。但是，请确保使用<em>条件断点时</em> ，运行调试的转换的目标平台应包含VIATRA查询工具UI元素，并且还应初始化它们。如果省略这些必需步骤，调试器将生成以下错误消息：</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">规则和条件断点在各个转换调试会话之间保持不变。断点包含在Eclipse断点管理器管理的公共断点池中。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">添加的断点显示在<em>Breakpoints</em> Eclipse Debug视图中。可用于禁用和删除这些断点。
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/conditional_breakpoint_parseerror.png" alt="条件断点解析错误">
</div>
<div class="title">图39。条件断点错误对话框</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/breakpoints_view.png" alt="Eclipse Breakpoints视图">
</div>
<div class="title">图40。Eclipse Breakpoints视图中的转换断点</div>
</div>
<div class="paragraph">
<p>调试器支持以下Eclipse调试命令：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">跳过（F6）</dt>
<dd>
<p>如果转换执行暂停，请使用此命令执行下一次激活，然后再次停止执行。</p>
</dd>
<dt class="hdlist1">简历（F8）</dt>
<dd>
<p>如果转换执行暂停，请使用此命令继续执行转换，直到命中断点。</p>
</dd>
<dt class="hdlist1">终止（Ctrl + F2）</dt>
<dd>
<p>恢复转换并且调试器代理与目标转换断开连接。转换调试会话终止。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>目前不支持一些调试命令，包括<em>Step Return</em> ， <em>Step Into</em> ， <em>Suspend</em>和<em>Disconnect</em> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="_directly_selecting_the_next_transformation_activation_to_be_fired"><a class="link" href="#_directly_selecting_the_next_transformation_activation_to_be_fired">直接选择要触发的下一个转换激活</a></h6>
<div class="paragraph">
<p>转换调试器允许用户定义下一个应该执行的激活。为此，请选择激活并使用适当的命令将其设置为要执行的下一个激活。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">这种方式所做的更改可能会在模型转换中产生不可预测的行为（覆盖已定义的优先级可能会导致模型状态不一致）。谨慎使用此功能。
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/select_next.png" alt="选择下一个激活">
</div>
<div class="title">图41。选择下一次激活</div>
</div>
<div class="paragraph">
<p>一旦选择了下一个激活，请注意表示要触发的下一个激活的红色矩形将移动到所需的激活。此时，如果恢复转换，它将从所选激活继续执行。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_common_issues"><a class="link" href="#_common_issues">4.3.3。常见问题</a></h4>
<div class="sect4">
<h5 id="_trying_to_connect_to_an_unreachable_viatra_transformation_instance"><a class="link" href="#_trying_to_connect_to_an_unreachable_viatra_transformation_instance">4.3.3.1。尝试连接到无法访问的VIATRA转换实例</a></h5>
<div class="paragraph">
<p>如果调试器启动配置中指定的VIATRA转换实例不存在，则调试器工具将通知用户调试会话无法初始化并终止新创建的会话。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/connection_error.png" alt="调试器连接错误">
</div>
<div class="title">图42。调试器连接错误</div>
</div>
</div>
<div class="sect4">
<h5 id="_transformation_under_debugging_terminated_abruptly"><a class="link" href="#_transformation_under_debugging_terminated_abruptly">4.3.3.2。调试下的转换突然终止。</a></h5>
<div class="paragraph">
<p>如果终止运行目标转换的eclipse实例，或者主机和目标组件之间的连接断开，则调试器工具将自动终止相应的VIATRA调试器启动。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/automatic_termination.png" alt="自动终止">
</div>
<div class="title">图43。自动终止</div>
</div>
</div>
<div class="sect4">
<h5 id="_trying_to_add_a_conditional_breakpoint_but_the_xtext_parser_infrastructure_is_not_initialized"><a class="link" href="#_trying_to_add_a_conditional_breakpoint_but_the_xtext_parser_infrastructure_is_not_initialized">4.3.3.3。尝试添加条件断点，但未初始化Xtext解析器基础结构。</a></h5>
<div class="paragraph">
<p>为了确保在运行时Eclipse实例中正确解析条件断点模式，需要初始化Xtext解析器基础结构。如果调试器工具产生以下异常，请打开VIATRA查询视图（例如：VIATRA Query Explorer）以手动初始化解析器工具。需要这些手动步骤，因为基于Xtext的解析器工具组件是懒惰加载的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/screenshots/conditional_breakpoint_parseerror.png" alt="条件断点解析错误">
</div>
<div class="title">图44。条件断点错误对话框</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>