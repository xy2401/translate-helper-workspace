<html lang="zh-Hans" >
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>插件和集成</title>
<link rel="stylesheet" href="asset?aid=0">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="article" >
<div id="header">
<h1>插件和集成</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>除了这些组件之外，VIATRA还提供了一组基于VIATRA查询和转换功能构建的插件，以（1）演示框架的功能，（2）提供可重用的功能，（3）帮助与其他编辑器和工具集成。</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#viatra-validation">VIATRA验证框架</a>
<ul class="sectlevel2">
<li><a href="#_main_concepts">主要概念</a></li>
<li><a href="#_creating_constraints_from_graph_patterns">从图形模式创建约束</a></li>
<li><a href="#_validation_api">验证API</a></li>
</ul>
</li>
<li><a href="#_derived_feature_support">派生功能支持</a>
<ul class="sectlevel2">
<li><a href="#_well_behaving_structural_features">表现良好的结构特征</a></li>
<li><a href="#viatra-qbf">基于查询的功能</a></li>
<li><a href="#surrogate-queries">代理查询派生特征</a></li>
</ul>
</li>
<li><a href="#_displaying_query_results_in_the_user_interface">在用户界面中显示查询结果</a>
<ul class="sectlevel2">
<li><a href="#databinding">VIATRA数据绑定</a></li>
<li><a href="#viewers">VIATRA观众</a></li>
</ul>
</li>
<li><a href="#uml-integration">UML支持VIATRA</a>
<ul class="sectlevel2">
<li><a href="#_surrogate_queries_for_uml_derived_features">代理UML派生特征的查询</a></li>
<li><a href="#_static_profile_support">静态配置支持</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-validation"><a class="link" href="#viatra-validation">VIATRA验证框架</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA提供了基于框架模式语言创建验证规则的工具。可以在各种EMF实例模型上以及在违反约束时评估这些规则，并且可以在Eclipse Problems View中自动创建已处理的标记，例如标记。</p>
</div>
<div class="sect2">
<h3 id="_main_concepts"><a class="link" href="#_main_concepts">主要概念</a></h3>
<div class="sect3">
<h4 id="_constraint_specification"><a class="link" href="#_constraint_specification">约束规范</a></h4>
<div class="paragraph">
<p>约束规范表示使用元模型中的概念指定的格式良好或结构验证规则，并且可以通过实例模型进行评估。</p>
</div>
<div class="paragraph">
<p>例如，约束规范是<em>“终止数据端口不能是端口连接的结束”</em> ，其中<em>“终止”</em> ， <em>“数据端口”</em> ， <em>“端口连接”</em>和<em>“连接端”</em>是元模型中的概念。</p>
</div>
<div class="paragraph">
<p>约束规范包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于创建违规的位置信息的转换机制</p>
</li>
<li>
<p>用于创建违规消息的格式消息</p>
</li>
<li>
<p>严重程度（例如错误，警告）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当约束规范由VIATRA模式表示时，存储相应的查询规范。</p>
</div>
</div>
<div class="sect3">
<h4 id="_constraint"><a class="link" href="#_constraint">约束</a></h4>
<div class="paragraph">
<p>我们区分表示基于验证引擎的约束规范的一个实例<strong>约束规范</strong> ，代表验证规则和<strong>约束</strong>之间。</p>
</div>
<div class="paragraph">
<p>每个约束存储其规范并引用验证引擎。它提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>列出违规行为</p>
</li>
<li>
<p>为有关违规集的更改以及与约束生命周期相关的其他事件的通知注册侦听器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于VIATRA模式指定的约束，存储相应的匹配器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_violation"><a class="link" href="#_violation">违反</a></h4>
<div class="paragraph">
<p>违规是在实例模型中设置的模型元素，满足约束的规范。</p>
</div>
<div class="paragraph">
<p>例如，对于上述约束，违规是终止的端口P和具有“PC.end = P”的端口连接PC。</p>
</div>
<div class="paragraph">
<p>每次违规都有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>相应的约束</p>
</li>
<li>
<p>一个位置（与违规相关的一个或多个模型元素（例如示例中的端口和端口连接）</p>
</li>
<li>
<p>格式化的消息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>违规应提供为生命周期事件的通知注册侦听器的功能，例如消息的更改。</p>
</div>
<div class="paragraph">
<p>对于违反基于VIATRA模式的约束，也存储匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_validation_engine"><a class="link" href="#_validation_engine">验证引擎</a></h4>
<div class="paragraph">
<p>验证引擎负责管理添加到验证引擎的一组约束规范的VIATRA查询引擎（例如资源集）范围内存在的约束。</p>
</div>
<div class="paragraph">
<p>验证引擎提供了功能</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加约束规范</p>
</li>
<li>
<p>列出约束集</p>
</li>
<li>
<p>为有关约束集中的更改以及与验证引擎生命周期相关的其他事件的通知注册侦听器。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_validation_manager"><a class="link" href="#_validation_manager">验证经理</a></h4>
<div class="paragraph">
<p>验证管理器是单例，用作使用提供功能的验证的单一入口点</p>
</div>
<div class="ulist">
<ul>
<li>
<p>访问通过扩展注册的约束规范（请参阅VIATRA <code>@Constraint</code>注释）</p>
</li>
<li>
<p>初始化新的验证引擎</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_constraints_from_graph_patterns"><a class="link" href="#_creating_constraints_from_graph_patterns">从图形模式创建约束</a></h3>
<div class="paragraph">
<p>验证框架提供<code>@Constraint</code>注释，用于提供从模式定义创建约束所需的额外信息。</p>
</div>
<div class="dlist">
<div class="title">约束注释的参数</div>
<dl>
<dt class="hdlist1">键</dt>
<dd>
<p>（参数名称列表作为字符串）约束的键表示一起标识给定违规的参数。具有相同键的参数值的相同约束模式的多个匹配将被视为单个违规。非关键参数可以通过API作为元组进行访问。</p>
</dd>
<dt class="hdlist1">信息</dt>
<dd>
<p>（格式字符串）：找到约束违规时要显示的消息。该消息可能引用$符号或其EMF功能之间的关键变量，例如$ keyParam1.name $。</p>
</dd>
<dt class="hdlist1">严重</dt>
<dd>
<p>（字符串）“info”，“warning”或“error”</p>
</dd>
<dt class="hdlist1">targetEditorId</dt>
<dd>
<p>（字符串）Eclipse编辑器ID，其中验证框架应将自身注册到上下文菜单。如果在启动验证时始终使用约束，请使用*作为通配符。</p>
</dd>
<dt class="hdlist1">对称</dt>
<dd>
<p>（可能多个参数名称列表作为字符串）列为对称的参数被认为对应于值在不同排列中的匹配的相同违规。对称参数可以是键或非键，不允许混音。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">示例注释</div>
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Constraint(
  key = {key1, sk1, sk2},
  severity = "error",
  symmetric = {sk1, sk2},
  symmetric = {sp1, sp2},
  message = "Some message $key1$ and $param$ and $sp2$"
)
pattern myPattern(key1, sk1, sk2, sp1, sp2, param) {...}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validation_api"><a class="link" href="#_validation_api">验证API</a></h3>
<div class="paragraph">
<p>使用模式和<code>@Constraint</code>批注指定约束后，您可以像以前一样使用基于标记的验证，也可以使用API自行处理违规：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ResourceSet myModel; // already initialized
Logger myLogger; // Log4J logger, use Logger.getLogger(this.class) if you need one
IConstraintSpecification constraintSpec = new MyPatternNameConstraint0(); // generated for pattern called MyPatternName

ValidationEngine validationEngine = new ValidationEngine(notifier, logger);
IConstraint constraint = validationEngine.addConstraintSpecification(constraintSpecification);
validationEngine.initialize();

Collection&lt;IViolation&gt; violations = constraint.listViolations();
for(IViolation violation : violations) {
  System.out.println(violation.getMessage());
  Map&lt;String, Object&gt; keyMap = violation.getKeyObjects()
  for(String key : keyMap.keySet()){
    System.out.println("Key " + key + " is " + keyMap.get(key));
  }
}

// you can filter violations
Collection&lt;IViolation&gt; filteredViolations = constraint.listViolations(new IViolationFilter(){
  public boolean apply(IViolation violation){
    return violation.getMessage().contains("MyFilterWord");
  }
});

// you can add listeners on IConstraint to get notified on violation list changes
constraint.addListener(new ConstraintListener(){
  public void violationAppeared(IViolation violation){
    System.out.println("Appeared: " + violation.getMessage());
  }
  public void violationDisappeared(IViolation violation){
    System.out.println("Disappeared: " + violation.getMessage());
  }
});

// or on IViolations to get notified of message and parameter changes
violations.iterator().next().addListener(new ViolationListener(){
  public void violationEntryAppeared(IViolation violation, IEntry entry){
    System.out.println("Entry appeared: " + entry);
  }

  public void violationMessageUpdated(IViolation violation){
    System.out.println("Message updated: " + violation.getMessage());
  }

  public void violationEntryDisappeared(IViolation violation, IEntry entry){
    System.out.println("Entry disappeared: " + entry);
  }
});

// you can also remove constraint specifications from an engine
validationEngine.removeConstraintSpecification(constraintSpecification);

// and dispose it when no longer needed
validationEngine.dispose();</code></pre>
</div>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_derived_feature_support"><a class="link" href="#_derived_feature_support">派生功能支持</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>EMF模型中的派生特征表示从模型的其余部分计算的信息（属性值，参考），例如给定集合中的元素数量或满足某些附加条件的元素集合。这些派生特征可以显着简化模型的处理，因为它们以与常规特征相同的方式出现。但是，为了实现派生功能的完全透明性，开发人员必须确保在模型修改导致派生功能的值发生更改时发送正确的更改通知。最后，由于可能经常检索派生特征的值，因此完全重新计算该值可能会影响应用程序性能。因此，最好保留值的缓存版本，并根据模型中的更改以增量方式更新它。</p>
</div>
<div class="paragraph">
<p>通常，在EMF中使用派生特征的开发人员必须为他们在模型中引入的每个派生特征手动解决这些挑战中的每一个。此外，尽管派生特征几乎总是表示模型查询的结果（包括类型约束，导航，聚合），但它们是作为命令式Java代码实现的。</p>
</div>
<div class="paragraph">
<p>为了帮助开发人员使用派生特征，VIATRA支持模型查询的定义，该查询为派生特征值计算提供结果，并包括开箱即用的更改通知和结果的增量维护。此外，EMF模型代码和VIATRA之间自动生成Ecore注释或粘合代码可轻松集成到任何现有的EMF应用程序中。</p>
</div>
<div class="paragraph">
<p>VIATRA通过使用高级模型查询和增量评估来计算派生特征的值并提供自动代码生成以集成到现有应用程序中，支持在EMF中定义高效，增量维护，良好行为的派生特征。</p>
</div>
<div class="ulist">
<div class="title">基于查询的功能的主要范围</div>
<ul>
<li>
<p>将模型查询结果集成到EMF应用程序中作为结构特征</p>
</li>
<li>
<p>使用增量评估的模型查询替换低性能派生特征实现</p>
</li>
<li>
<p>为碎片模型提供灵活的链接方法</p>
</li>
<li>
<p>通过自动代码生成和验证支持高性能计算功能的声明性定义</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_well_behaving_structural_features"><a class="link" href="#_well_behaving_structural_features">表现良好的结构特征</a></h3>
<div class="paragraph">
<p>VIATRA查询的增量方法依赖于来自查询定义中使用的模型中的每个对象和每个功能的更改通知。因此，常规易失性功能没有字段，因此它不存储功能的当前值，并且通常不会发送正确的更改通知（例如SET oldValue to newValue）。除非有明确声明，否则VIATRA会忽略此类功能，即功能实现始终发送正确的更改通知。这些被称为良好的结构特征。</p>
</div>
<div class="paragraph">
<p>如果您的应用程序使用易失性（通常是派生的）功能，您可以为它们提供适当的通知，并希望将它们包含在查询定义中，您可以明确告诉VIATRA该功能是否良好。有两种方法可以做到这一点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>延长<code>org.eclipse.viatra.query.runtime.base.wellbehaving.derived.features</code>如所描述的扩展点<a href="https://github.com/FTSRG/publication-pages/wiki/Using-queries-for-derived-features-(ECMFA12)">这里</a></p>
</li>
<li>
<p>提供代理查询，请参阅后面的内容</p>
</li>
<li>
<p>将您的功能直接注册到<code>org.eclipse.viatra.query.runtime.base.comprehension.使用各种<code>registerX</code>方法的WellbehavingDerivedFeatureRegistry</code> 。<strong>警告</strong> ：您必须在执行任何查询之前（即在第一个<code>getMatcher()</code>或<code>getEngine()</code>调用之前）调用此方法，因为VIATRA在遍历模型时检查注册表。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="viatra-qbf"><a class="link" href="#viatra-qbf">基于查询的功能</a></h3>
<div class="paragraph">
<p>为了演示，我们将使用<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/query/bpm">示例存储库中</a>的BPM元模型。</p>
</div>
<div class="paragraph">
<p>其他示例包括<a href="https://github.com/viatra/massif/">Massif中</a>的Simulink模型使用基于查询的功能来支持库块，模型引用，端口过滤等等。</p>
</div>
<div class="sect3">
<h4 id="_user_documentation"><a class="link" href="#_user_documentation">用户文档</a></h4>
<div class="paragraph">
<p>VIATRA仅为派生特征提供后端，开发人员必须首先在元模型中定义特征本身。完成后，开发人员在查询定义文件中的常规VIATRA查询项目中创建查询，并添加具有正确参数的特定注释，以生成派生特征实现。这些步骤详述如下：</p>
</div>
<div class="sect4">
<h5 id="_definition_of_the_derived_feature"><a class="link" href="#_definition_of_the_derived_feature">派生特征的定义</a></h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在Ecore模型（.ecore文件）中，在所选EClass中创建所需的EAttribute或EReference，并正确设置名称，类型和多重性信息。</p>
</li>
<li>
<p>对创建的EStructuralFeature的其他属性使用以下配置：</p>
<div class="ulist">
<ul>
<li>
<p>derived = true（表示从模型计算特征的值）</p>
</li>
<li>
<p>changeable = false（删除setter方法）</p>
</li>
<li>
<p>transient = true（避免将值保存到文件中）</p>
</li>
<li>
<p>volatile = true（删除对象中的字段声明）</p>
</li>
</ul>
</div>
</li>
<li>
<p>在Generator模型（.genmodel）中，右键单击顶级元素并选择Reload，单击Next，Load和Finish以使用Ecore模型中的更改更新Generator模型。</p>
</li>
<li>
<p>右键单击顶级元素，然后选择Generate Model Code以确保将getter正确生成到EMF模型代码中。您也可以重新生成编辑和编辑器代码，尽管这里不需要这些代码。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_definition_of_the_model_query"><a class="link" href="#_definition_of_the_model_query">模型查询的定义</a></h5>
<div class="ulist">
<ul>
<li>
<p>创建VIATRA查询项目和查询定义（.vql）文件，如备忘单或本教程中所述。</p>
</li>
<li>
<p>确保已将元模型导入到查询定义中。如有必要，创建VIATRA生成器模型（.vqlgen文件）。</p>
</li>
<li>
<p>确保包含Ecore模型或生成的代码的项目与VIATRA查询项目位于同一工作区中。</p>
</li>
<li>
<p>创建与派生要素对应的查询。例如，标识符与给定作业要素对应的任务如下所示：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.eclipse.viatra.examples.bpm.queries.system

import "http://process/1.0"
import "http://system/1.0"

@QueryBasedFeature(feature = "tasks")
pattern JobTaskCorrespondence(Job : Job, Task : Task) = {
 Job.taskIds(Job,TaskId);
 Task.id(Task,TaskId);
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>保存时，VIATRA查询构建器会自动运行，并将设置委托注释放在Ecore模型中。</p>
</li>
<li>
<p>如果引入了基于查询的新特征查询或者给定特征的模式的完全限定名称已更改，则必须调用EMF生成器。这是必需的，因为生成器使用设置委托注释来创建模型代码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，模式的第一个参数是派生特征的源，第二个参数是目标。虽然不是强制性的，但使用<code>(This : EClass, Target)</code>格式来缓解理解是一种好习惯。@QueryBasedFeature注释向代码生成器指示它应该在Ecore模型中创建设置委托注释。</p>
</div>
<div class="paragraph">
<p>保存查询定义会启动代码生成。完成后，您可以打开Ecore模型以确保正确创建新注释。请注意，还会在VIATRA Query项目的plugin.xml中生成行为良好的派生特征扩展，以指示在加载项目时给定的派生特征正确发送更改通知。</p>
</div>
<div class="paragraph">
<p>生成注释并调用EMF生成器后，您可以通过将VIATRA Query项目与模型项目一起包含在运行时来使用派生功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_annotation_parameters"><a class="link" href="#_annotation_parameters">注释参数</a></h5>
<div class="paragraph">
<p>@QueryBasedFeature批注对每个可能的参数使用默认值，这允许开发人员在正确编写查询时避免使用任何参数。</p>
</div>
<div class="paragraph">
<p>简而言之，如果满足以下条件，则不需要参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式的名称与派生特征的名称相同（比较使用String.equals（））</p>
</li>
<li>
<p>第一个参数是定义的EClass，它的类型是正确给出的（例如This：Course）</p>
</li>
<li>
<p>第二个参数是派生特征的目标</p>
</li>
<li>
<p>派生特征值是单个EObject或EObject集合</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果派生特征及其查询不满足上述条件，则可以在注释中使用以下参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>feature ="featureName"</code> （默认值：模式名称） - 指示模式定义的派生特征</p>
</li>
<li>
<p><code>source ="Src"</code> （默认值：第一个参数） - 指示哪个查询参数（使用其名称）是源EObject，此参数的推断类型指示必须修改哪个EClass生成的代码</p>
</li>
<li>
<p><code>target ="Trg"</code> （默认值：第二个参数） - 指示哪个查询参数（使用其名称）是派生要素的目标</p>
</li>
<li>
<p><code>kind ="single/many/counter/sum/iteration"</code> （默认值：feature.isMany？many：single） - 指示应对查询结果进行何种计算，以将它们映射到派生特征值</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_common_issues"><a class="link" href="#_common_issues">常见问题</a></h5>
<div class="sect5">
<h6 id="_code_generation_fails_for_derived_feature_query"><a class="link" href="#_code_generation_fails_for_derived_feature_query">导出的要素查询的代码生成失败</a></h6>
<div class="paragraph">
<p>确保.ecore文件在与VIATRA查询项目相同的工作空间中可用且可写，并带有查询定义。</p>
</div>
</div>
<div class="sect5">
<h6 id="_multiple_results_for_a_query_used_in_a_single_upper_bound_1_feature"><a class="link" href="#_multiple_results_for_a_query_used_in_a_single_upper_bound_1_feature">在单个（上限= 1）要素中使用的查询的多个结果</a></h6>
<div class="paragraph">
<p>如果为返回给定源模型元素的多个结果的单个要素定义查询，则派生要素的值在大多数情况下将是出现的最后一个匹配的值。但是，可以以功能没有值的方式更改值，即使它可能只有一个值。因此，以只有一种结果可能的方式定义要素的查询非常重要。您可以对模型进行假设，并使用其他方法确保只有一个匹配，或者您可以在模式中明确声明它应该只对给定的源元素匹配一次。此外，当查询具有多个指示模型无效的结果时，您可以使用VIATRA的验证框架为用户创建反馈。</p>
</div>
<div class="paragraph">
<p>以下是经过验证的确保单一功能的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@QueryBasedFeature
pattern singleFeature(This : SourceType, Target : TargetType){
 find internalQuery(This, Target);
 1 == count find internalQuery(This, Target);
}

private pattern internalQuery(This : SourceType, Target : TargetType){
 // actual query definition
}

@Constraint(location = "This", severity = "error",
   message="Multiple values for $This.name$.singleFeature!")
pattern singleFeatureInvalid(This : SourceType){
 1 &lt; count find internalQuery(This, _Target);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_overview_of_the_implementation"><a class="link" href="#_overview_of_the_implementation">实施概述</a></h5>
<div class="paragraph">
<p>为了支持作为派生特征捕获的查询支持的特征，VIATRA查询引擎的输出需要在两点集成到EMF模型访问层：（1）在派生特征的getter函数中提供查询结果，（2）处理查询结果增量以生成通过标准EMF API传递的EMF通知对象，以便应用程序代码可以透明地处理它们。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/addons/qbf-overview.png" alt="qbf概述" width="600">
</div>
</div>
<div class="paragraph">
<p>应用程序通过标准EMF模型访问层访问模型和查询结果 - 因此，不需要修改应用程序源代码。在后台，我们的新颖派生特征处理程序附加到EMF模型插件，该插件集成了生成的查询组件（模式匹配器）。当EMF应用程序打算读取软链接（B1）时，通过简单地从相关查询的高速缓存中检索值，由相应的处理程序（B2）提供当前值。当应用程序修改EMF模型（A1）时，此更改将沿着通知（A2）传播到VIATRA生成的查询组件，这可能会更新处理程序的增量监视器（A3）。衍生特征的变化可以反过来触发其他衍生特征的结果集的进一步变化（A4）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_setting_delegates"><a class="link" href="#_using_setting_delegates">使用设置代理</a></h5>
<div class="paragraph">
<p>基于查询的功能依赖于设置委托而不是覆盖生成的代码。设置委托是将派生特征计算集成到EMF模型中的推荐方法。这意味着在更改模式定义时仅修改Ecore文件，但是也必须调用genmodel中的代码生成。</p>
</div>
<div class="paragraph">
<p>要设置设置委托，生成器会自动在EPackage和EStructuralFeatures上添加注释</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在EPackage上，声明委托使用哪个设置：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;eAnnotations source="http://www.eclipse.org/emf/2002/Ecore"&gt;
  &lt;details key="settingDelegates" value="org.eclipse.viatra.query.querybasedfeature"/&gt;
&lt;/eAnnotations&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在EStructuralFeature上，这是一个基于查询的功能：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;eAnnotations source="org.eclipse.viatra.query.querybasedfeature"&gt;
  &lt;details key="patternFQN" value="querypackage.patternName"/&gt;
&lt;/eAnnotations&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>设置委托工厂由基于查询的功能运行时插件注册，EMF将使用工厂为基于查询的派生功能创建设置委托。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="surrogate-queries"><a class="link" href="#surrogate-queries">代理查询派生特征</a></h3>
<div class="paragraph">
<p>基于查询的功能通过查询捕获Ecore模型的良好行为派生特征的定义，并允许在其他查询的主体中使用此类派生特征。但是，如果不允许修改Ecore模型，则过去无法在查询体中使用派生特征。EMF-IncQuery 1.0.0引入了派生特征的<strong>代理查询</strong> ，其中查询中使用的派生特征在查询执行时（运行时）期间被子模式调用替换。</p>
</div>
<div class="sect3">
<h4 id="_usage"><a class="link" href="#_usage">用法</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Surrogate
pattern superClass(self : Classifier, super : Classifer) {
  Classifier.generalization(self, generalization);
  Generalization.general(generalization, classifier);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了创建代理查询，只需为模式添加@Surrogate注释，生成器将负责定义正确的扩展点。当查询插件包含在主机中时，VIATRA查询运行时将自动将包含该功能的路径表达式替换为子模式调用。此外，如果插件在主机或目标平台中可用，则派生功能使用的警告将不同（而不是警告无法表示的功能，它将包括代理查询的完全限定名称）。因此，以下内容将在运行时正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern superClassWithName(self : Classifier) {
  Classifier.superClass(self, superClass);
  Classifier.name(superClass, "mySuperClass");
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_important_information_on_developing_surrogate_queries"><a class="link" href="#_important_information_on_developing_surrogate_queries">有关开发代理查询的重要信息</a></h5>
<div class="paragraph">
<p>查询资源管理器中尚未显示工作空间项目中定义的代理查询，因此加载使用这些派生功能的查询将导致不正确的匹配结果。如果要在查询资源管理器中尝试此类查询，请执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果代理查询定义和使用它的模式在不同的项目中，只需启动运行时Eclipse，其中至少包含定义查询。</p>
</li>
<li>
<p>如果代理查询定义和使用它的模式在同一个项目中，只需使用子模式调用（find）。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example"><a class="link" href="#_example">例</a></h4>
<div class="paragraph">
<p>EMF-UML中使用的UML元模型包含大量派生特征（有关详细信息，请参阅<a href="#uml-integration">UML对VIATRA的支持</a> ），其中大部分都不是很好的行为，这使得过去UML模型的模式定义显着复杂化。</p>
</div>
<div class="paragraph">
<p>考虑以下模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern superClassWithQualifiedName(self : Classifier) {
  Classifier.superClass(self, superClass);
  Classifier.qualifiedName(superClass, "my::favorite::package::SuperSuperClass");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，Classifer.superClass和NamedElement.qualifiedName都是派生特征</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式编辑器将显示有关这些功能的警告，不适合增量评估;</p>
</li>
<li>
<p>运行时将索引这些功能的值，并且不会返回任何匹配项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于可以从模型的其余部分计算这些特征的值，因此用户通常手动定义辅助模式，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">pattern superClass(self : Classifier, super : Classifer) {
  Classifier.generalization(self, generalization);
  Generalization.general(generalization, classifier);
}

pattern superClassWithQualifiedName(self : Classifier) {
  find superClass(self, superClass);
  Classifier.qualifiedName(superClass, "my::favorite::package::SuperSuperClass");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这种方法有几个缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重新发明轮子：衍生的功能被一遍又一遍地重新定义。</p>
</li>
<li>
<p>容易出错的定义：您可以轻松忽略计算中的一些细节并获得意外结果。</p>
</li>
<li>
<p>不允许在模式中使用：派生特征不能直接在其他模式体中使用，需要显式调用辅助模式（通过''find''构造）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>引入代理查询以帮助克服这些问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_technical_details"><a class="link" href="#_technical_details">技术细节</a></h4>
<div class="paragraph">
<p>代理查询支持包括模式编辑器中的<code>@Surrogate</code>注释，相应的代码生成器片段，代理查询注册表的运行时加载和使用，查询中派生特征使用的运行时替换。但是，在Eclipse外部运行时，需要进行一些额外的设置。</p>
</div>
<div class="sect4">
<h5 id="_definition_of_surrogate_queries"><a class="link" href="#_definition_of_surrogate_queries">代理查询的定义</a></h5>
<div class="paragraph">
<p><code>@Surrogate</code>注释具有单个可选参数<code>feature</code> ，该<code>feature</code>指定代理查询替换的EStructuralFeature的名称。如果省略，则模式的名称必须与要素的名称匹配。模式的第一个参数始终是源，第二个参数是目标。</p>
</div>
<div class="paragraph">
<p>我们假设您想要在EClass <code>ExternalClass</code>使用类型<code>OtherExternalClass</code>来代理派生特征<code>someExternalModelFeature</code> 。</p>
</div>
<div class="paragraph">
<p>你可以选择：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Surrogate(feature = "someExternalModelFeature")
pattern mySurrogatePattern(this : ExternalClass, target : OtherExternalClass) {
  [...] // pattern body
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Surrogate
pattern someExternalModelFeature(this : ExternalClass, target : OtherExternalClass) {
  [...] // pattern body
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释由<em>querybasedfeatures.runtime</em>插件和验证器（也由同一插件提供）定义，验证器检查以下几项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该模式恰好有两个参数</p>
</li>
<li>
<p>模式名称指定的功能或注释的参数存在于源EClass中</p>
</li>
<li>
<p>特征的目标类型与模式的第二个参数兼容</p>
</li>
<li>
<p>一个模式只有一个Surrogate注释，或者每个模式定义不同的特征</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>代码生成器片段由<em>querybasedfeatures.tooling</em>插件定义，它只是为plugin.xml中的代理查询扩展点创建扩展：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;extension id="extension.surrogate.mySurrogates.mySurrogatePattern" point="org.eclipse.viatra.query.patternlanguage.emf.surrogatequeryemf"&gt;
  &lt;surrogate-query-emf class-name="ExternalClass" feature-name="someExternalModelFeature" package-nsUri="external.ecore.uri"
    surrogate-query="org.eclipse.viatra.query.runtime.extensibility.PQueryExtensionFactory:mySurrogates.MySurrogatePatternQuerySpecification"/&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_behavior"><a class="link" href="#_runtime_behavior">运行时行为</a></h5>
<div class="paragraph">
<p>在运行时，通过读取Eclipse的扩展注册表，将代理查询加载到代理查询注册表（在''runtime.matchers''插件中定义）中。当给定模式加载到引擎中时，包括具有定义的代理查询的派生特征的路径表达式在PSystem表示中被替换。</p>
</div>
<div class="paragraph">
<p>这意味着代理查询仅在可用且已注册时使用。此外，对于可以处理非良好行为的派生特征（例如本地搜索后端）的查询后端，将跳过此重写。</p>
</div>
</div>
<div class="sect4">
<h5 id="_usage_outside_of_eclipse"><a class="link" href="#_usage_outside_of_eclipse">在Eclipse之外的用法</a></h5>
<div class="paragraph">
<p>由于扩展注册表在Eclipse外部运行时不可用，因此用户必须手动注册代理查询才能用于查询评估。</p>
</div>
<div class="paragraph">
<p>除基本基础结构外，每个代理查询还需要以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SurrogateQueryRegistry.instance().registerSurrogateQueryForFeature(
  new EStructuralFeatureInstancesKey(ExternalPackage.Literals.EXTERNAL_CLASS_SOME_EXTERNAL_MODEL_FEATURE),
  MySurrogatePatternQuerySpecification.instance.getInternalQueryRepresentation());</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关示例，请参阅<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/plugins/org.eclipse.viatra.integration.uml/src/org/eclipse/viatra/integration/uml/ViatraQueryUMLStandaloneSetup.java">VIATRA UML独立设置</a> 。</p>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_displaying_query_results_in_the_user_interface"><a class="link" href="#_displaying_query_results_in_the_user_interface">在用户界面中显示查询结果</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>就VIATRA模式匹配结果的可视化而言，VIATRA框架提供了两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>VIATRA数据绑定插件</em> ：使用此插件，VIATRA模式匹配可以直接合并到使用JFace数据绑定的新开发的应用程序中。</p>
</li>
<li>
<p><em>VIATRA Viewers Addon</em> ：VIATRA Viewers组件通过使用模型查询的结果填充和更新模型查看器结果，帮助开发模型驱动的用户界面。该实现依赖于事件驱动的虚拟机和JFace Viewers库（并以其为模型）。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="databinding"><a class="link" href="#databinding">VIATRA数据绑定</a></h3>
<div class="paragraph">
<p>VIATRA提供了一个简单的数据绑定工具，可用于将模式匹配绑定到UI元素。该功能主要用于将VIATRA查询集成到新开发的用户界面。为了利用此功能，需要对源模式进行注释，并且需要将使用过的UI组件绑定到数据绑定API提供的Observable。在以下部分中，显示了使用VIATRA数据绑定的示例。</p>
</div>
<div class="sect3">
<h4 id="_required_annotations"><a class="link" href="#_required_annotations">必需的注释</a></h4>
<div class="ulist">
<ul>
<li>
<p><em>@ObservableValue</em> ：允许开发人员自定义匹配的外观。它定义了一个可观察的值（在JFace数据绑定中定义），它可以绑定到Eclipse / JFace UI。</p>
<div class="ulist">
<ul>
<li>
<p><em>name</em> （String）：参数的名称</p>
</li>
<li>
<p><em>expression</em> （String）：没有'$'标记的待观察属性定义。例如<code>@ObservableValue(name = "id", expression = "host.identifier")</code></p>
</li>
<li>
<p><em>labelExpression</em> ：此注释可以创建可观察的字符串属性，这在呈现JFace查看器组件内的对象之间的关系时很有用。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="databinding-annotations" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@ObservableValue(name = "id", expression = "host.identifier")
@ObservableValue(name = "node_ip", expression = "host.nodeIp")
@ObservableValue(name = "current_cpu", expression = "host.availableCpu")
@ObservableValue(name = "current_hdd", expression = "host.availableHdd")
@ObservableValue(name = "current_ram", expression = "host.availableRam")
@ObservableValue(name = "total_cpu", expression = "host.totalCpu")
@ObservableValue(name = "total_hdd", expression = "host.totalHdd")
@ObservableValue(name = "total_ram", expression = "host.totalRam")
pattern hostInstances(host: HostInstance) {
    HostInstance(host);
}

@ObservableValue(name = "id", expression = "app.identifier")
@ObservableValue(name = "state", expression = "app.state")
@ObservableValue(name = "db_user", expression = "app.dbUser")
@ObservableValue(name = "db_pass", expression = "app.dbPassword")
@ObservableValue(name = "allocatedTo", expression = "app.allocatedTo")
pattern applicationInstances(app: ApplicationInstance) {
    ApplicationInstance(app);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listening_to_change_via_an_observable"><a class="link" href="#_listening_to_change_via_an_observable">通过Observable收听变化</a></h4>
<div class="paragraph">
<p>有一些用例，你不想跟随模式匹配的每一个变化，只需将它们聚集在一起并在你准备好时处理它们。VIATRA Query提供了几种方法，但我们建议将JFace数据绑定用于基本目的。为此， <strong>ViatraObservables</strong>实用程序类可以将匹配器的结果集转换为可以跟踪的可观察列表或集合，甚至可以轻松绑定数据。</p>
</div>
<div class="paragraph">
<p>对于无头（或非UI线程）执行，请使用示例中提供的简单DefaultRealm实现（并在适当的线程上调用它）。</p>
</div>
<div id="query-api-databinding" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// (+) changes can also be tracked using JFace Databinding
// this approach provides good performance, as the observable callbacks are guaranteed to be called
//   in a consistent state, and only when there is a relevant change; anything
//   can be written into the callback method
// (-) * the databinding API introduces additional dependencies
//     * is does not support generics, hence typesafe programming is not possible
//     * a "Realm" needs to be set up for headless execution
DefaultRealm realm = new DefaultRealm(); // this is necessary for headless execution (or when you
// wish to execute outside of the UI thread. make sure to invoke it on the appropriate thread!
IObservableSet set = ViatraObservables.observeMatchesAsSet(matcher);
set.addSetChangeListener(new ISetChangeListener() {
 @Override
 public void handleSetChange(SetChangeEvent event) {
  for (Object _o : event.diff.getAdditions()) {
   if (_o instanceof EPackageMatch) {
    results.append("\tNew EPackage found by changeset databinding: " + ((EPackageMatch)_o).getP().getName()+"\n");
   }
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_data_binding_to_populate_a_table"><a class="link" href="#_using_data_binding_to_populate_a_table">使用数据绑定来填充表</a></h4>
<div id="databinding-table" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//Initialize VIATRA query engine
ViatraQueryEngine engine = ViatraQueryEngine.on(new EMFScope(resourceSet));
//Get the matcher for the query to be observed (HostInstances pattern)
HostInstancesMatcher matcher = HostInstancesMatcher.on(engine);
//Create a generic data binding adapter for the query specification
//It is responsible for creating observable value properties based on the annotations of the pattern
GenericDatabindingAdapter adapter = new GenericDatabindingAdapter(HostInstancesMatcher.querySpecification());
//Bind the matches to the given TableViewer
ViewerSupport.bind(
    tableViewer,
    //Get the matching results as an observable list
        ViatraObservables.observeMatchesAsList(matcher),
        //Specify observed proeprties
        new IValueProperty[] {
        adapter.getProperty("id"),
        adapter.getProperty("node_ip"),
        adapter.getProperty("current_cpu"),
        adapter.getProperty("current_hdd"),
        adapter.getProperty("current_ram"),
        adapter.getProperty("total_cpu"),
        adapter.getProperty("total_hdd"),
        adapter.getProperty("total_ram") });</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_master_detail_data_binding_with_a_list"><a class="link" href="#_master_detail_data_binding_with_a_list">主 - 与列表绑定的详细数据</a></h4>
<div class="paragraph">
<p>以下代码片段负责将列表绑定到VIATRA查询的结果，并在文本框中显示匹配详细信息。（使用Master-detail绑定）</p>
</div>
<div id="databinding-masterdetail" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//Create new data binding context
//It will be used for binding the pattern match details
DataBindingContext dataBindingContext = new DataBindingContext();
//Initialize VIATRA query engine
ViatraQueryEngine engine = ViatraQueryEngine.on(new EMFScope(resourceSet));
//Get the matcher for the query to be observed (ApplicationInstances pattern)
ApplicationInstancesMatcher matcher = ApplicationInstancesMatcher.on(engine);
//Create a generic data binding adapter for the query specification
//It is responsible for creating observable value properties based on the annotations of the pattern
GenericDatabindingAdapter adapter = new GenericDatabindingAdapter(ApplicationInstancesMatcher.querySpecification());
//Bind the matches to the given ListViewer
ViewerSupport.bind(listViewer, ViatraObservables.observeMatchesAsSet(matcher), adapter.getProperty("id"));

//At this point, the results of the given pattern will appear in the list Viewer, the details however still need to be implemented
//Define target observable values for both textboxes
IObservableValue dbUserTarget = WidgetProperties.text().observe(dbUser);
IObservableValue dbPassTarget = WidgetProperties.text().observe(dbPass);

//Observe the changes in the list selection
IViewerObservableValue listSelection = ViewerProperties
    .singleSelection().observe(listViewer);

//Use the data binding context to bind the text property of the target textbox and the given property of the matcher.
dataBindingContext.bindValue(
    //Target textbox observable value
    dbPassTarget,
    //Get the source observable value from the adapter
    adapter.getProperty("db_pass").observeDetail(listSelection),
    //Define EMF update value strategy
    //In this case its one directional
    new EMFUpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),
    new EMFUpdateValueStrategy());

dataBindingContext.bindValue(dbUserTarget, adapter.getProperty("db_user").observeDetail(listSelection),
    new EMFUpdateValueStrategy(UpdateValueStrategy.POLICY_NEVER),
    new EMFUpdateValueStrategy());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="viewers"><a class="link" href="#viewers">VIATRA观众</a></h3>
<div class="paragraph">
<p>VIATRA Viewers组件可以将查询结果绑定到各种JFace查看器：当前支持JFace ListViewer和TreeViewers。此外，通过从额外更新站点安装额外功能，还支持GraphViewers（基于GEF4 Zest）。在下面的示例中，以及在实验室中除外，还将介绍GraphViewers的使用方法。这些GraphViewers能够以图形形式显示查询结果。</p>
</div>
<div class="sect3">
<h4 id="_usage_2"><a class="link" href="#_usage_2">用法</a></h4>
<div class="paragraph">
<p>要使用VIATRA Viewers插件，需要执行以下步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用@ Item，@ ConfinsItem和@Edge注释注释VIATRA查询模式</p>
<div class="ulist">
<ul>
<li>
<p><em>@Item</em>将表示为图形节点</p>
</li>
<li>
<p><em>@ContainsItem</em>将表示为节点和边（边缘位于父节点和子节点之间）</p>
</li>
<li>
<p><em>@Edge</em>将显示为边缘（目标）</p>
</li>
</ul>
</div>
</li>
<li>
<p>初始化基于查看器的UI组件</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_pattern_annotations"><a class="link" href="#_pattern_annotations">模式注释</a></h4>
<div id="viewers-annotations" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">//Host Type objects will be nodes of the displayed graph
@Item(item = host, label = "$host.identifier$")
//Format options can be set using the @Format annotation
@Format(color = "#0033CC", textColor = "#FFFFFF")
pattern hostTypes(host) {
    HostType(host);
}
//Host types contain host instances
//Displayed as nodes which have common edges with their parents
@ContainsItem(container = type, item = instance)
pattern connectTypesAndInstancesHost(type, instance) {
    HostType.instances(type,instance);
}
//Host instances can communicate with each other
//Displayed as an edge between the two nodes
@Edge(source = i1, target = i2, label = "comm")
pattern communications(i1, i2) {
    HostInstance.communicateWith(i1,i2);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_initializing_a_viewer_programmatically"><a class="link" href="#_initializing_a_viewer_programmatically">以编程方式初始化查看器</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将依赖项添加到<code>org.eclipse.viatra.addon.viewers.runtime</code> （如果需要，还可以添加<code>org.eclipse.viatra.addon.viewers.runtime.zest</code> ）到插件中。</p>
</li>
<li>
<p>从一组查询规范中创建一个<code>ViewerState</code>实例。<code>ViatraViewerDataModel</code>类中提供了有用的（静态）辅助方法，它们需要一组查询规范;数据过滤器和所需的功能。</p>
<div class="ulist">
<ul>
<li>
<p>查询规范的集合：仅使用具有相应的Viewers注释的查询规范;其他规格将被忽略。</p>
</li>
<li>
<p>ViewerDataFilter：用于通过参数过滤查询结果。对于每个模式，可以初始化单独的过滤器，该过滤器绑定其某些参数。</p>
</li>
<li>
<p>必需功能：ViewerStateFeature枚举可用于列出可视化所需的功能。列表查看器不需要特定功能;树观众需要遏制关系; Zest查看器需要边缘关系（以及可能的包含关系）。不需要的功能不会创建</p>
</li>
</ul>
</div>
</li>
<li>
<p>在手动创建的<code>Viewer</code>上使用<code>ViatraViewers</code>或<code>ViatraGraphViewers</code>类中的相应绑定方法以及<code>ViewerState</code>和实例模型。</p>
<div class="ulist">
<ul>
<li>
<p><code>ViewerState</code>实例可以在不同的查看器之间重用。</p>
</li>
<li>
<p>如果更改了添加到<code>ViewerState</code>的过滤器，则所有查看器都将过时，并且必须重新创建。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="viewers-code" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//Create the graph viewer component and add it to the containing SWT control
GraphViewer viewer = new GraphViewer(parent, SWT.None);
//Create a new Viewer state based on the created VIATRA query engine and a set of annotated VIATRA query specifications
ViewerState state = ViatraViewerDataModel.newViewerState(getEngine(), getSpecifications(), ViewerDataFilter.UNFILTERED,
        ImmutableSet.of(ViewerStateFeature.EDGE, ViewerStateFeature.CONTAINMENT));
//This method of binding supports isolated nodes
ViatraGraphViewers.bindWithIsolatedNodes(viewer, state, true);
//Define layout algorithm
viewer.setLayoutAlgorithm(new SpaceTreeLayoutAlgorithm());
//Apply layout
viewer.applyLayout();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_examples"><a class="link" href="#_examples">例子</a></h4>
<div class="sect4">
<h5 id="_uml_visualization"><a class="link" href="#_uml_visualization">UML可视化</a></h5>
<div class="paragraph">
<p>为了说明该方法， <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/papyrus-uml">在VIATRA项目</a>的<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/papyrus-uml">示例存储库中</a>基于UML类图准备了一个简单的示例。这些示例依赖于示例类的概念： <em>没有操作或属性的UML类（在其父类中都没有）</em> 。</p>
</div>
<div class="paragraph">
<p>为了呈现框架的大多数功能，使用了四种特定模式（对于整个实现，请访问git存储库）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>pattern emptyClass (cl : Class)</code> - 用于列出模型中的所有空类</p>
</li>
<li>
<p><code>pattern nonEmptyClass(cl : Class)</code> - 用于列出<code>pattern nonEmptyClass(cl : Class)</code>空的所有类</p>
</li>
<li>
<p><code>pattern superClass(sub : Class, sup : Class)</code> - 用于列出类之间的所有直接超类关系</p>
</li>
<li>
<p><code>pattern transitiveSuperClass(sub : Class, sup : Class)</code> - 用于列出类之间的所有间接超类关系（但不包括直接的超类）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面的可视化器插图对应于存储库中的<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/papyrus-uml/org.eclipse.viatra.examples.uml.queries/testmodels/Testmodel.uml">测试模型</a> 。</p>
</div>
<div class="sect5">
<h6 id="_jface_list_viewer_example"><a class="link" href="#_jface_list_viewer_example">JFace List Viewer示例</a></h6>
<div class="paragraph">
<p>列表查看器可用于将元素集合显示为列表。要定义列表，仅使用<code>Item</code>注释。其<code>item</code>参数选择一个模式参数，表示要显示的数据，而其<code>label</code>参数用于定义标签字符串（与Data Binding的标签功能或Validation Framework的标签具有相同的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Item(item = cl, label="Empty class $cl$")
pattern emptyClass(cl : Class) {
...
}

@Item(item = cl, label = "Class $cl$")
pattern nonEmptyClass(cl : Class) {
...
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/addons/viewers_uml_list.png" alt="观众uml列表">
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_binding_contents_to_a_jface_tree_viewer"><a class="link" href="#_binding_contents_to_a_jface_tree_viewer">将内容绑定到JFace Tree Viewer</a></h5>
<div class="paragraph">
<p>为了支持绑定元素到JFace树查看器，除了项目列表之外，还需要使用&lt;code&gt; ContainsItem &lt;/ code&gt;注释指定一组包含关系，该注释将容器和包含的项目描述为模式参数。仅当匹配结果的两端在查看器中作为项目出现时，才会显示包含引用 - 否则只会忽略它。</p>
</div>
<div class="paragraph">
<p>Tree Viewer支持的一个独特属性是Viewers框架的单个Item可能会在树中多次出现。如果元素有多个父项，则会发生这种情况</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@ContainsItem(container = sup, item = sub)
pattern superClass(sub : Class, sup : Class) {
...
}
@Item(item = cl, label="Empty class $cl$")
pattern emptyClass(cl : Class) {
...
}
@Item(item = cl, label = "Class $cl$")
pattern nonEmptyClass(cl : Class) {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="./images/addons/viewers_uml_tree.png" alt="观众uml树"></span></p>
</div>
<div class="ulist">
<div class="title">补充说明</div>
<ul>
<li>
<p>除了基本绑定支持，其中所有项目都根据需要显示为根项目和子项目，可以使用层次结构参数将项目限制为仅显示为root或仅显示为子位置。</p>
</li>
<li>
<p>如果以编程方式创建TreeViewer绑定，并且项目出现在多个位置，请确保设置TreeViewer的<code>useHashLookup</code>属性，否则TreeViewer的更新将失败。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_zest_graph_viewer_example"><a class="link" href="#_zest_graph_viewer_example">Zest Graph Viewer示例</a></h5>
<div class="paragraph">
<p>图形查看器的定义需要一组项目和一组边缘。边缘连接两个不同的项目;端点不在的边缘不显示项目。与Tree Viewer支持相反，单个项目仅出现一次。</p>
</div>
<div class="paragraph">
<p>此外，根据Zest的格式化功能，一些基本的显示选项以<code>Format</code>注释的形式提供。各种参数可用于描绘颜色，线宽等。如果所选格式不适用于当前元素，则会忽略它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Edge(source = sup, target = sub, label = "direct")
@Format(color = "#7f004b", lineWidth = 2)
pattern superClass(sub : Class, sup : Class) {
...
}
@Edge(source = sup, target = sub)
pattern transitiveSuperClass(sub : Class, sup : Class) {
...
}
@Item(item = cl, label="Empty class $cl$")
@Format(color="#3770d7", textColor = "#ffffff")
pattern emptyClass(cl : Class) {
...
}
@Item(item = cl, label = "Class $cl$")
pattern nonEmptyClass(cl : Class) {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="./images/addons/viewers_uml_zest.png" alt="观众uml热情"></span></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ecore_visualization"><a class="link" href="#_ecore_visualization">Ecore可视化</a></h4>
<div class="paragraph">
<p>我们在无头示例的背景下开发了另一个示范示例。由于无头示例的查询与.ecore模型（即EMF元模型）匹配，下面的可视化示例可用于以简单的方式可视化元模型和包含关系。此示例主要关注GEF5 Zest框架支持的2D图形可视化。</p>
</div>
<div class="sect4">
<h5 id="_specification"><a class="link" href="#_specification">规格</a></h5>
<div class="paragraph">
<p>该示例定义了两个图节点类型和三个图边类型（ <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/headless/org.eclipse.viatra.query.application.queries/src/org/eclipse/viatra/query/application/queries/headlessQueries.vql">代码</a> ）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>节点是EPackage和EClass实例</p>
</li>
<li>
<p>边是<strong>包中包含</strong>的<strong>类</strong> ， <strong>子包</strong>关系，以及<strong>包层次结构中的包</strong>和类<strong>类</strong>之间的特殊传递包含关系，它枚举根包或包含在此根下的某个子包（传递）所包含的所有类。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">@Item(item = p, label = "P: $p.name$")
@Format(color = "#791662", textColor = "#ffffff")
pattern ePackage(p : EPackage) { EPackage(p); }

@Item(item = ec, label = "EC: $ec.name$")
@Format(color = "#e8da2c")
pattern eClass(ec : EClass) { EClass(ec); }

@Edge(source = p, target = ec, label = "classIn")
pattern classesInPackage(p : EPackage, ec: EClass) { EPackage.eClassifiers(p,ec); }

@Edge(source = p, target = sp, label = "sub")
pattern subPackage(p: EPackage, sp: EPackage){ EPackage.eSubpackages(p,sp); }

@Edge(source = rootP, target = containedClass, label = "classIn+")
@Format(color = "#0033ff")
pattern classesInPackageHierarchy(rootP: EPackage, containedClass: EClass)
{
	find classesInPackage(rootP,containedClass);
} or {
	find subPackage+(rootP,somePackage);
	find classesInPackage(somePackage,containedClass);
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">简单测试模型（ <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/examples/headless/org.eclipse.viatra.query.application.queries/testmodels/Test.ecore">文件</a> ）的可视化</div>
<p><span class="image"><img src="./images/addons/viewers_ecore.png" alt="使用VIATRA查看器进行Ecore元模型可视化" width="700"></span></p>
</div>
<div class="paragraph">
<p>请注意以下细节：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EPackages和EClasses分别以紫色和黄色显示</p>
</li>
<li>
<p>直接关系（子包和包含的包）以灰色显示</p>
</li>
<li>
<p>推断的传递包含关系以蓝色显示</p>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="uml-integration"><a class="link" href="#uml-integration">UML支持VIATRA</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了与UML编辑器无缝协作，VIATRA提供了两个相关的集成功能：（1）查询结果视图需要GMF集成功能才能与基于GMF的编辑器（如Papyrus）协同工作; （2）UML元模型的一组代理查询。这两个功能都可以从<a href="https://eclipse.org/viatra/downloads.html">VIATRA更新站点获得</a> 。</p>
</div>
<div class="sect2">
<h3 id="_surrogate_queries_for_uml_derived_features"><a class="link" href="#_surrogate_queries_for_uml_derived_features">代理UML派生特征的查询</a></h3>
<div class="paragraph">
<p>UML 2的EMF元模型包含几个默认情况下VIATRA模式不支持的派生特征。此可选集成组件通过定义适当的代理查询为它们提供支持。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将''org.eclipse.viatra.integration.uml''插件添加到依赖项中。
<span class="image"><img src="./images/addons/uml-integration-deps.png" alt="uml集成代表"></span></p>
</li>
<li>
<p>现在，您可以像使用其他所有功能一样使用大多数派生功能。
<span class="image"><img src="./images/addons/uml-integration-surrogates.png" alt="uml集成代理" width="815px"></span></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>从1.7.0版开始，VIATRA不支持UML模型中定义的所有派生特性。在下文中，详细说明了当前状态。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表格1。派生特征的状态</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">衍生功能</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action.context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自1.1.0起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action.input</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action.output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Activity.group</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Activity.node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityEdge.inGroup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityGroup.containedEdge</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityGroup.containedNode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityGroup.inActivity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自1.1.0起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityGroup.subgroup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityGroup.superGroup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityNode.activity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自1.1.0起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActivityNode.inGroup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Association.endType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Behavior.context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自1.1.0起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class.extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0.0中的Buggy，在1.1.0中禁用（实现检查Metaclass构造型应用程序，因此如果在<em>非</em>元类的类上使用它将是不正确的）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class.superClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Classifier.attribute</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Classifier.feature</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Classifier.general</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Classifier.inheritedMember</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Component.provided</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Component.required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ConnectableElement.end</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connector.kind</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ConnectorEnd.definingEnd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DeploymentTarget.deployedElement</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DirectedRelationship.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DirectedRelationship.target</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Element.ownedElement</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Element.owner</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EncapsulatedClassifier.ownedPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extension.isRequired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extension.metaclass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Feature.featuringClassifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不正确</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始，已知问题（与Classifier.feature相反，根据规范，但实现在涉及信号的一些极端情况下给出不同的结果）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message.messageKind</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MultiplicityElement.lower</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MultiplicityElement.upper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NamedElement.clientDependency</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NamedElement.namespace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NamedElement.qualifiedName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0.0中不正确，在1.1.0中已修复</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespace.importedMember</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不正确</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始，已知问题（Profiles的导入成员不完全正确）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespace.member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不正确</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始，已知问题（不包括继承的类成员）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespace.ownedMember</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpaqueExpression.result</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation.isOrdered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation.isUnique</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation.lower</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation.type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation.upper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package.nestedPackage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package.nestingPackage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自1.1.0起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package.ownedStereotype</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package.ownedType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameter.default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Port.provided</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Port.required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property.default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property.isComposite</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property.opposite</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ProtocolTransition.referred</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RedefinableElement.redefinedElement</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RedefinableElement.redefinitionContext</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RedefinableTemplateSignature.inheritedParameter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relationship.relatedElement</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">State.isComposite</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">State.isOrthogonal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">State.isSimple</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">State.isSubmachineState</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stereotype.profile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去做</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StructuredClassifier.part</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StructuredClassifier.role</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type.package</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vertex.incoming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vertex.outgoing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从1.0.0开始</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在无头环境中使用UML时，请务必调用<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/plugins/org.eclipse.viatra.integration.uml/src/org/eclipse/viatra/integration/uml/ViatraQueryUMLStandaloneSetup.java">ViatraQueryUMLStandaloneSetup.doSetup（）</a>以确保所有内容<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/plugins/org.eclipse.viatra.integration.uml/src/org/eclipse/viatra/integration/uml/ViatraQueryUMLStandaloneSetup.java">都已</a>注册。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_static_profile_support"><a class="link" href="#_static_profile_support">静态配置支持</a></h3>
<div class="paragraph">
<p>如果您有EMF-UML配置文件，则可以查询其构造型及其标记值的应用程序，就好像它们是普通的EClasses和EAttributes一样。从1.1.0开始，VIATRA仅支持静态配置文件，因此您必须按照<a href="http://nyssen.blogspot.hu/2009/09/defining-static-profiles-with-eclipse.html">此博客文章中的</a>描述定义一个静态配置文件。</p>
</div>
<div class="paragraph">
<p>在下面的示例中继续博客文章，在启动的运行时Eclipse中，我们创建了一个匹配&lt;tt&gt; ExampleStereotype &lt;/ tt&gt;应用程序的模式，正如我们在查询资源管理器中看到的，它在简单的UML实例模型上有匹配：</p>
</div>
<div id="File:Static-profile.png" class="paragraph">
<p>Papyrus用户请注意：建议您也使用Papyrus注册您的个人资料。要完成此操作，请为<code>org.eclipse.papyrus.uml.extensionpoints.添加扩展名<code>org.eclipse.papyrus.uml.extensionpoints.UMLProfile</code>扩展点，指向包含您的配置文件的UML模型文件。有关更多信息，请参阅<a href="https://www.eclipse.org/forums/index.php/t/604098/">此主题</a> 。</p>
</div>
<div class="paragraph">
<p>可以在<a href="https://github.com/thSoft/viatra-uml-support">此存储库中</a>找到此示例的代码。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>