<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 包装软件</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 包装软件</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="rpm-packages_packaging-software"></a> RPM包</h1></div></div></div><p>本节介绍RPM打包格式的基础知识。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="what-is-an-rpm_rpm-packages"></a>什么是RPM</h2></div></div></div><p>RPM包是包含其他文件及其元数据的文件（有关系统所需文件的信息）。
				</p><p>具体来说，RPM包由<code class="literal">cpio</code>存档组成。
				</p><p><code class="literal">cpio</code>存档包含：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">档</li><li class="listitem"><p class="simpara">RPM标头（包元数据）</p><p class="simpara"><code class="literal">rpm</code>包管理器使用此元数据来确定依赖关系，安装文件的位置以及其他信息。
						</p></li></ul></div><h4><a id="types_of_rpm_packages"></a> RPM包的类型</h4><p>有两种类型的RPM包。两种类型共享文件格式和工具，但具有不同的内容并用于不同的目的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">源RPM（SRPM）</p><p class="simpara">SRPM包含源代码和SPEC文件，它描述了如何将源代码构建为二进制RPM。可选地，还包括源代码的补丁。
						</p></li><li class="listitem"><p class="simpara">二进制RPM</p><p class="simpara">二进制RPM包含从源和补丁构建的二进制文件。
						</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rpm-packaging-tools_rpm-packages"></a>列出RPM打包工具的实用程序</h2></div></div></div><p>以下过程说明如何列出<code class="literal">rpmdevtools</code>包提供的实用程序。
				</p><h4><a id="prerequisite"></a>条件</h4><p>为了能够使用RPM打包工具，您需要安装<code class="literal">rpmdevtools</code>软件包，该软件包提供了几个用于打包RPM的实用程序。</p><pre class="literallayout"># yum install rpmdevtools</pre><h4><a id="procedure_12"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">列出RPM打包工具的实用程序：</li></ul></div><pre class="literallayout">$ rpm -ql rpmdevtools | grep bin</pre><p>有关上述实用程序的详细信息，请参阅其手册页或帮助对话框。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="setting-up-rpm-packaging-workspace_rpm-packages"></a>设置RPM打包工作区</h2></div></div></div><p>本节介绍如何使用<code class="literal">rpmdev-setuptree</code>实用程序设置作为RPM打包工作空间的目录布局。
				</p><h4><a id="prerequisites_4"></a>先决条件</h4><p>必须在您的系统上安装<code class="literal">rpmdevtools</code>包：</p><pre class="literallayout"># yum install rpmdevtools</pre><h4><a id="procedure_13"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">运行<code class="literal">rpmdev-setuptree</code>实用程序：</li></ul></div><pre class="literallayout">$ rpmdev-setuptree

$ tree ~/rpmbuild/
/home/user/rpmbuild/
|-- BUILD
|-- RPMS
|-- SOURCES
|-- SPECS
`-- SRPMS

5 directories, 0 files</pre><p>创建的目录用于以下目的：</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><tbody><tr><td valign="top" style="text-align:left"> <p>目录</p>
								 </td><td valign="top" style="text-align:left"> <p>目的</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>建立</p>
								 </td><td valign="top" style="text-align:left"> <p>构建包时，会在此处创建各种<code class="literal">%buildroot</code>目录。如果日志输出未提供足够的信息，这对于调查失败的构建非常有用。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>RPMS</p>
								 </td><td valign="top" style="text-align:left"> <p>二进制RPM在此处创建，用于不同体系结构的子目录，例如子目录<code class="literal">x86_64</code>和<code class="literal">noarch</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>来源</p>
								 </td><td valign="top" style="text-align:left"> <p>这里，打包器放置压缩的源代码存档和补丁。<code class="literal">rpmbuild</code>命令在这里查找它们。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>眼镜</p>
								 </td><td valign="top" style="text-align:left"> <p>打包器将SPEC文件放在这里。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>SRPMS</p>
								 </td><td valign="top" style="text-align:left"> <p>当<code class="literal">rpmbuild</code>用于构建SRPM而不是二进制RPM时，将在此处创建生成的SRPM。
								</p>
								 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="what-is-a-spec-file_rpm-packages"></a>什么是SPEC文件</h2></div></div></div><p>您可以将SPEC文件理解为<code class="literal">rpmbuild</code>实用程序用于构建RPM的配方。 SPEC文件通过定义一系列部分中的指令，为构建系统提供必要的信息。该段在<span class="emphasis"><em>序言</em></span>和<span class="emphasis"><em>正文</em></span>部分定义。<span class="emphasis"><em>Preamble</em></span>部分包含<span class="emphasis"><em>Body</em></span>部分中使用的一系列元数据项。<span class="emphasis"><em>身体</em></span>部分代表的说明的主要部分。
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="preamble-items"></a>序言项目</h3></div></div></div><p>下表列出了RPM SPEC文件的<span class="emphasis"><em>Preamble</em></span>部分中经常使用的一些指令。
					</p><div class="table"><a id="idm140116090264384"></a><p class="title"><strong>表3.1。RPM SPEC文件的<code class="literal"><span class="emphasis"><em>Preamble</em></span></code>部分中使用的项目</strong></p><div class="table-contents"><table border="1" summary="Items used in the Preamble section of the RPM SPEC file"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">SPEC指令</th><th valign="top" style="text-align:left">定义</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">名称</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>包的基本名称，应与SPEC文件名匹配。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">版</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>软件的上游版本号。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">发布</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>此版本软件发布的次数。通常，将初始值设置为1％{？dist}，并随着包的每个新版本递增它。在构建新<code class="literal">Version</code>的软件时重置为1。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">摘要</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>包的简短一行摘要。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">执照</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>正在打包的软件的许可证。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">网址</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>有关该程序的更多信息的完整URL。通常，这是打包软件的上游项目网站。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">Source0</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>上游源代码的压缩归档的路径或URL（未修补，补丁在其他地方处理）。这应该指向存档的可访问且可靠的存储，例如，上游页面而不是打包器的本地存储。如果需要，可以添加更多SourceX指令，每次递增数字，例如：Source1，Source2，Source3等。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">补丁</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>必要时应用于源代码的第一个补丁的名称。
									</p>
									 <p>该指令可以以两种方式应用：在Patch结尾处有或没有数字。
									</p>
									 <p>如果没有给出数字，则在内部为该条目分配一个。也可以使用Patch0，Patch1，Patch2，Patch3等明确给出数字。
									</p>
									 <p>可以使用％patch0，％patch1，％patch2宏等逐个应用这些修补程序。这些宏应用于RPM SPEC文件的<span class="emphasis"><em>Body</em></span>部分中的％prep指令中。或者，您可以使用％autopatch宏，它会按照SPEC文件中给出的顺序自动应用所有修补程序。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">BuildArch</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>如果包不依赖于体系结构，例如，如果完全用解释的编程语言编写，则将其设置为<code class="literal">BuildArch: noarch</code> 。如果未设置，则程序包将自动继承构建它的计算机的体系结构，例如<code class="literal">x86_64</code> 。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">BuildRequires</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>用于构建以编译语言编写的程序所需的逗号或以空格分隔的包列表。<code class="literal">BuildRequires</code>可以有多个条目，每个条目在SPEC文件中都有自己的行。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">需要</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>安装后运行软件所需的以逗号或空格分隔的软件包列表。可以有多个<code class="literal">Requires</code>条目，每个条目在SPEC文件中都有自己的行。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">ExcludeArch</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>如果某个软件无法在特定的处理器体系结构上运行，则可以在此处排除该体系结构。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">冲突</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">Conflicts</code>与<code class="literal">Requires</code>相反。如果存在与<code class="literal">Conflicts</code>匹配的程序包，则无法单独安装程序包是否已在已安装的程序包上或将要安装的程序包上使用<code class="literal">Conflict</code>标记。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">淘汰了</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>此指令根据是否在命令行上直接使用<code class="literal">rpm</code>命令或更新是由更新还是依赖项解算器来更改更新的工作方式。在命令行上使用时，RPM将删除与所安装的软件包的过时匹配的所有软件包。使用更新或依赖项解析程序时，包含匹配的<code class="literal">Obsoletes:</code>包将作为更新添加并替换匹配的包。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">提供</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>如果将<code class="literal">Provides</code>添加到包中，则可以通过除其名称之外的依赖项来引用该包。
									</p>
									 </td></tr></tbody></table></div></div><p><code class="literal">Name</code> ， <code class="literal">Version</code>和<code class="literal">Release</code>指令包含RPM包的文件名。RPM软件包维护者和系统管理员经常将这三个指令称为<span class="strong"><strong>NVR</strong></span>或<span class="strong"><strong>NVR</strong></span> ，因为RPM软件包文件名具有<code class="literal">NAME-VERSION-RELEASE</code>格式。
					</p><p>以下示例显示如何通过查询<code class="literal">rpm</code>命令获取特定软件包的<span class="strong"><strong>NVR</strong></span>信息。
					</p><div class="example"><a id="idm140115980533200"></a><p class="title"><strong>例3.1。查询rpm以提供python包的NVR信息</strong></p><div class="example-contents"><pre class="literallayout"># rpm -q bash
bash-4.4.19-7.el8.x86_64</pre></div></div><p>这里， <code class="literal">bash</code>是包名， <code class="literal">4.4.19</code>是版本， <code class="literal">7.el8</code>是版本。最终的标记是<code class="literal">x86_64</code> ，它标志着架构。与<span class="strong"><strong>NVR</strong></span>不同，体系结构标记不受RPM包装程序的直接控制，而是由<code class="literal">rpmbuild</code>构建环境定义。例外是与架构无关的<code class="literal">noarch</code>包。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="body-items"></a>身体物品</h3></div></div></div><p>RPM SPEC文件的<code class="literal">Body section</code>中使用的项目列在下表中。
					</p><div class="table"><a id="idm140116095038896"></a><p class="title"><strong>表3.2。RPM SPEC文件的Body部分中使用的项目</strong></p><div class="table-contents"><table border="1" summary="Items used in the Body section of the RPM SPEC file"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">SPEC指令</th><th valign="top" style="text-align:left">定义</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％描述</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>RPM中打包的软件的完整描述。该描述可以跨越多行并且可以分成段落。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％准备</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>用于准备要构建的软件的命令或一系列命令，例如，在<code class="literal">Source0</code>解压缩归档文件。该指令可以包含shell脚本。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％建立</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>用于将软件构建为机器代码（用于编译语言）或字节代码（用于某些解释语言）的命令或一系列命令。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％安装</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>用于将所需构建工件从<code class="literal">%builddir</code> （构建发生的位置）复制到<code class="literal">%buildroot</code>目录（包含要打包的文件的目录结构）的命令或一系列命令。这通常意味着将文件从<code class="literal">~/rpmbuild/BUILD</code>复制到<code class="literal">~/rpmbuild/BUILDROOT</code>并在<code class="literal">~/rpmbuild/BUILDROOT</code>创建必要的目录。这仅在创建包时运行，而不是在最终用户安装包时运行。有关详细信息，请参阅<a class="xref" href="packaging-software_packaging-and-distributing-software.html#working-with-spec-files" title="使用SPEC文件">“使用SPEC文件”一节</a> 。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％校验</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>用于测试软件的命令或一系列命令。这通常包括单元测试等。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％文件</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>将在最终用户的系统中安装的文件列表。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">％的changelog</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>不同<code class="literal">Version</code>或<code class="literal">Release</code>版本之间的包发生的更改记录。
									</p>
									 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="advanced-items"></a>高级项目</h3></div></div></div><p>SPEC文件还可以包含高级项，例如<a class="link" href="advanced-topics.html#scriptlets_epoch-scriplets-and-triggers" title="Scriptlets指令">Scriptlet</a>或<a class="link" href="advanced-topics.html#triggers_epoch-scriplets-and-triggers" title="触发器指令">Triggers</a> 。它们在最终用户系统的安装过程中的不同点生效，而不是在构建过程中生效。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="buildroots_rpm-packages"></a> BuildRoots</h2></div></div></div><p>在RPM打包的环境中， <code class="literal">buildroot</code>是一个chroot环境。这意味着构建工件放置在此处使用与最终用户系统中的未来层次结构相同的文件系统层次结构，其中<code class="literal">buildroot</code>充当根目录。构建工件的放置应符合最终用户系统的文件系统层次结构标准。
				</p><p><code class="literal">buildroot</code>中的文件稍后会被放入<code class="literal">cpio</code>存档中，这将成为RPM的主要部分。在最终用户的系统上安装RPM时，会在<code class="literal">root</code>目录中提取这些文件，从而保留正确的层次结构。
				</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>从Red Hat Enterprise Linux 6开始， <code class="literal">rpmbuild</code>程序有自己的默认值。覆盖这些默认值会导致一些问题;因此，Red Hat不建议您定义自己的宏值。您可以将<code class="literal">%{buildroot}</code>宏与<code class="literal">rpmbuild</code>目录中的默认值一起使用。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rpm-macros_rpm-packages"></a> RPM宏</h2></div></div></div><p><a class="link" href="http://rpm.org/user_doc/macros.html">rpm宏</a>是直接文本替换，可以在使用某些内置功能时根据语句的可选评估有条件地分配。因此，RPM可以为您执行文本替换。
				</p><p>示例用法是在SPEC文件中多次引用打包的软件<span class="emphasis"><em>版本</em></span> 。您在定义<span class="emphasis"><em>版本</em></span>只有一次<code class="literal">%{version}</code>的宏，并使用整个SPEC文件这个宏。每次出现都会自动替换您之前定义的<span class="emphasis"><em>版本</em></span> 。
				</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>如果您看到一个不熟悉的宏，可以使用以下命令对其进行评估：</p><pre class="literallayout">$ rpm --eval %{_MACRO}</pre><pre class="literallayout">$ rpm --eval %{_bindir}
/usr/bin

$ rpm --eval %{_libexecdir}
/usr/libexec</pre></div><p>常用的宏是<code class="literal">%{?dist}</code> macro，表示哪个分布用于构建（分发标记）。
				</p><pre class="literallayout"># On a RHEL 8.x machine
$ rpm --eval %{?dist}
.el8</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="working-with-spec-files"></a>使用SPEC文件</h1></div></div></div><p>本节介绍如何创建和修改SPEC文件。
			</p><h3><a id="prerequisites_5"></a>先决条件</h3><p>本节使用<code class="literal">Hello World!</code>的三个示例实现<code class="literal">Hello World!</code> <a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#source-code-examples" title="源代码示例">“源代码示例”一节</a>中描述的程序。
			</p><p>下表中还详细描述了每个程序。
			</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><tbody><tr><td valign="top" style="text-align:left"> <p>软件名称</p>
							 </td><td valign="top" style="text-align:left"> <p>示例说明</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>贝洛</p>
							 </td><td valign="top" style="text-align:left"> <p>用原始解释编程语言编写的程序。它演示了何时不需要构建源代码，只需要安装源代码。如果需要打包预编译的二进制文件，您也可以使用此方法，因为二进制文件也只是一个文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>佩洛</p>
							 </td><td valign="top" style="text-align:left"> <p>用字节编译的解释编程语言编写的程序。它演示了字节编译源代码和安装字节码 - 生成的预优化文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>大提琴</p>
							 </td><td valign="top" style="text-align:left"> <p>用本机编译的编程语言编写的程序。它演示了将源代码编译为机器代码并安装生成的可执行文件的常见过程。
							</p>
							 </td></tr></tbody></table></div><p><code class="literal">Hello World!</code>的实现<code class="literal">Hello World!</code> 是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/bello-0.1.tar.gz">贝洛-0.1.tar.gz</a>
					</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/pello-0.1.2.tar.gz">佩洛-0.1.2.tar.gz</a>
					</li><li class="listitem"><p class="simpara">
						<a class="link" href="https://github.com/redhat-developer/rpm-packaging-guide/raw/master/example-code/cello-1.0.tar.gz">大提琴-1.0.tar.gz中</a>
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<a class="link" href="https://raw.githubusercontent.com/redhat-developer/rpm-packaging-guide/master/example-code/cello-output-first-patch.patch">大提琴输出先patch.patch</a>
							</li></ul></div></li></ul></div><p>作为先决条件，这些实现需要放在<code class="literal">~/rpmbuild/SOURCES</code>目录中。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ways_to_create_a_new_spec_file"></a>如何创建新的SPEC文件</h2></div></div></div><p>要打包新软件，您需要创建一个新的SPEC文件。
				</p><p>实现这一目标有两个：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">从头开始手动编写新的SPEC文件</li><li class="listitem"><p class="simpara">使用<code class="literal">rpmdev-newspec</code>实用程序</p><p class="simpara">该实用程序创建一个未填充的SPEC文件，并填写必要的指令和字段。
						</p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>一些以程序员为中心的文本编辑器使用自己的SPEC模板预先填充新的<code class="literal">.spec</code>文件。<code class="literal">rpmdev-newspec</code>实用程序提供了一种与编辑器无关的方法。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-spec-files-with-rpmdev-newspec_working-with-spec-files"></a>使用rpmdev-newspec创建新的SPEC文件</h2></div></div></div><p>以下过程说明如何为上述三个<code class="literal">Hello World!</code>每一个创建SPEC文件<code class="literal">Hello World!</code> 程序使用<code class="literal">rpmdev-newspec</code>实用程序。
				</p><h4><a id="procedure_14"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">切换到<code class="literal">~/rpmbuild/SPECS</code>目录并使用<code class="literal">rpmdev-newspec</code>实用程序：</p><pre class="literallayout">$ cd ~/rpmbuild/SPECS

$ rpmdev-newspec bello
bello.spec created; type minimal, rpm version &gt;= 4.11.

$ rpmdev-newspec cello
cello.spec created; type minimal, rpm version &gt;= 4.11.

$ rpmdev-newspec pello
pello.spec created; type minimal, rpm version &gt;= 4.11.</pre><p class="simpara"><code class="literal">~/rpmbuild/SPECS/</code>目录现在包含三个名为<code class="literal">bello.spec</code> ， <code class="literal">cello.spec</code>和<code class="literal">pello.spec</code> SPEC文件。
						</p></li></ol></div><p>FD。检查文件：</p><p>+文件中的指令代表<a class="xref" href="packaging-software_packaging-and-distributing-software.html#what-is-a-spec-file_rpm-packages" title="什么是SPEC文件">“在什么是SPEC文件”</a>部分中描述的指令。在以下部分中，您将在<code class="literal">rpmdev-newspec</code>的输出文件中填充特定部分。
				</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">rpmdev-newspec</code>实用程序不使用特定于任何特定Linux发行版的指南或约定。但是，本文档针对Red Hat Enterprise Linux，因此在引用RPM的<code class="literal">$RPM_BUILD_ROOT</code>时， <code class="literal">%{buildroot}</code>符号优先于<code class="literal">$RPM_BUILD_ROOT</code>表示法，以便与整个SPEC文件中的所有其他已定义或提供的宏保持一致。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="modifying-a-spec-file_working-with-spec-files"></a>修改原始SPEC文件以创建RPM</h2></div></div></div><p>以下过程说明如何修改<code class="literal">rpmdev-newspec</code>提供的输出SPEC文件以创建RPM。</p><h4><a id="prerequisites_6"></a>先决条件</h4><p>确保：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">特定程序的源代码已放入<code class="literal">~/rpmbuild/SOURCES/</code>目录中。
						</li><li class="listitem">未填充的SPEC文件<code class="literal">~/rpmbuild/SPECS/&lt;name&gt;.spec</code>文件已由<code class="literal">rpmdev-newspec</code>实用程序创建。
						</li></ul></div><h4><a id="procedure_15"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem">打开<code class="literal">rpmdev-newspec</code>实用程序提供的<code class="literal">~/rpmbuild/SPECS/&lt;name&gt;.spec</code>文件的输出模板：</li><li class="listitem"><p class="simpara">填充SPEC文件的第一部分：</p><p class="simpara">第一部分包括<code class="literal">rpmdev-newspec</code>组合在一起的这些指令：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<code class="literal">名称</code>
								</li><li class="listitem">
									<code class="literal">版</code>
								</li><li class="listitem">
									<code class="literal">发布</code>
								</li><li class="listitem"><p class="simpara">
									<code class="literal">摘要</code>
								</p><p class="simpara"><code class="literal">Name</code>已被指定为<code class="literal">rpmdev-newspec</code>的参数。
								</p><p class="simpara">设置<code class="literal">Version</code>以匹配源代码的上游发行版本。
								</p><p class="simpara"><code class="literal">Release</code>自动设置为<code class="literal">1%{?dist}</code> ，最初为<code class="literal">1</code> 。在更新程序包时增加初始值，而不更改上游发行<code class="literal">Version</code> - 例如包含修补程序时。当新的上游版本发生时，重置<code class="literal">Release</code>为<code class="literal">1</code> 。
								</p><p class="simpara"><code class="literal">Summary</code>是对该软件的<code class="literal">Summary</code>说明。
								</p></li></ul></div></li><li class="listitem"><p class="simpara">填充<code class="literal">License</code> ， <code class="literal">URL</code>和<code class="literal">Source0</code>指令：</p><p class="simpara"><code class="literal">License</code>字段是与上游版本的源代码关联的软件许可证。如何在SPEC文件中标记<code class="literal">License</code>的确切格式将根据您遵循的基于RPM的Linux分发指南而有所不同。
						</p><p class="simpara">例如，您可以使用<a class="link" href="https://www.gnu.org/licenses/quick-guide-gplv3.html">GPLv3 +</a> 。
						</p><p class="simpara"><code class="literal">URL</code>字段提供上游软件网站的URL。为保持一致性，请使用<code class="literal">%{name}</code>的RPM宏变量，并使用<code class="literal"><a class="link" href="javascript:void(0);">https://example.com/%{name}</a></code> 。
						</p><p class="simpara"><code class="literal">Source0</code>字段提供上游软件源代码的URL。它应该直接链接到正在打包的特定软件版本。请注意，本文档中给出的示例URL包含可能在将来更改的硬编码值。同样，发布版本也可以更改。要简化这些可能的未来更改，请使用<code class="literal">%{name}</code>和<code class="literal">%{version}</code>宏。通过使用这些，您只需要更新SPEC文件中的一个字段。
						</p></li><li class="listitem"><p class="simpara">填充<code class="literal">BuildRequires</code> ， <code class="literal">Requires</code>和<code class="literal">BuildArch</code>指令：</p><p class="simpara">
							<code class="literal">BuildRequires</code>指定包的构建时依赖性。
						</p><p class="simpara">
							<code class="literal">Requires</code>指定包的运行时依赖性。
						</p><p class="simpara">这是一个用解释型编程语言编写的软件，没有本机编译的扩展。因此，添加带有<code class="literal">noarch</code>值的<code class="literal">BuildArch</code>指令。这告诉RPM这个包不需要绑定到构建它的处理器体系结构。
						</p></li><li class="listitem"><p class="simpara">填充<code class="literal">%description</code> ， <code class="literal">%prep</code> ， <code class="literal">%build</code> ， <code class="literal">%install</code> ， <code class="literal">%files</code>和<code class="literal">%license</code>指令：</p><p class="simpara">这些指令可以被视为部分标题，因为它们是可以定义要发生的多行，多指令或脚本任务的指令。
						</p><p class="simpara"><code class="literal">%description</code>是一个比<code class="literal">Summary</code>更长，更全面的软件描述，包含一个或多个段落。
						</p><p class="simpara"><code class="literal">%prep</code>部分指定了如何准备构建环境。这通常涉及扩展源代码的压缩存档，补丁的应用，以及可能解析源代码中提供的信息，以便在SPEC文件的后续部分中使用。在本节中，您可以使用内置的<code class="literal">%setup -q</code>宏。
						</p><p class="simpara"><code class="literal">%build</code>部分指定了如何构建软件。
						</p><p class="simpara"><code class="literal">%install</code>部分包含<code class="literal">rpmbuild</code>关于如何在构建软件后将其安装到<code class="literal">BUILDROOT</code>目录中的说明。
						</p><p class="simpara">此目录是一个空的chroot基目录，类似于最终用户的根目录。在这里，您可以创建包含已安装文件的任何目录。要创建此类目录，您可以使用RPM宏而无需对路径进行硬编码。
						</p><p class="simpara"><code class="literal">%files</code>部分指定此RPM提供的文件列表及其在最终用户系统上的完整路径位置。
						</p><p class="simpara">在此部分中，您可以使用内置宏指示各种文件的角色。这对于使用命令[] <code class="literal">rpm</code>命令查询包文件清单元数据很有用。例如，要指示LICENSE文件是软件许可证文件，请使用<code class="literal">%license</code>宏。
						</p></li><li class="listitem"><p class="simpara">最后一部分<code class="literal">%changelog</code>是包的每个Version-Release的日期戳记条目列表。他们记录包装更改，而不是软件更改。打包更改的示例：添加修补程序，更改<code class="literal">%build</code>部分中的构建过程。
						</p><p class="simpara">请遵循第一行的格式：</p><p class="simpara">以<code class="literal">*</code>字符开头，然后是<code class="literal">Day-of-Week Month Day Year Name Surname &lt;email&gt; - Version-Release</code>
						</p><p class="simpara">请按照以下格式输入实际更改条目：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">每个更改条目可以包含多个项目，每个项目对应一次更改。
								</li><li class="listitem">每个项目都以新行开头。
								</li><li class="listitem">每个项目都以<code class="literal">-</code>字符开头。
								</li></ul></div></li></ol></div><p>您现在已经为所需程序编写了一个完整的SPEC文件。
				</p><p>有关使用不同编程语言编写的SPEC文件的示例，请参阅：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="packaging-software_packaging-and-distributing-software.html#an-example-spec-file-for-bello_working-with-spec-files" title="用bash编写的程序的示例SPEC文件">用bash编写的程序的示例SPEC文件</a>
						</li><li class="listitem">
							<a class="link" href="packaging-software_packaging-and-distributing-software.html#an-example-spec-file-for-pello_working-with-spec-files" title="用Python编写的程序的示例SPEC文件">用Python编写的程序的示例SPEC文件</a>
						</li><li class="listitem">
							<a class="link" href="packaging-software_packaging-and-distributing-software.html#an-example-spec-file-for-cello_working-with-spec-files" title="用C编写的程序的示例SPEC文件">用C编写的程序的示例SPEC文件</a>
						</li></ul></div><p>从SPEC文件<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="Building RPMs">构建RPM</a>在<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="构建RPM">“构建RPM”一节中</a>描述。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="an-example-spec-file-for-bello_working-with-spec-files"></a>用bash编写的程序的示例SPEC文件</h2></div></div></div><p>本节显示了用bash编写的<span class="strong"><strong>bello</strong></span>程序的示例SPEC文件。有关<span class="strong"><strong>bello的</strong></span>更多信息，请参阅<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#source-code-examples" title="源代码示例">“源代码示例”一节</a> 。
				</p><div class="title"><strong>用bash编写的<span class="strong"><strong>bello</strong></span>程序的示例SPEC文件</strong></div><p>
						
</p><pre class="literallayout">Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            <a class="link" href="https://www.example.com/%{name}">https://www.example.com/%{name}</a>
Source0:        <a class="link" href="https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz">https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz</a>

Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in
bash script.

%prep
%setup -q

%build

%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller &lt;<a class="link" href="mailto:maxamillion@fedoraproject.org">maxamillion@fedoraproject.org</a>&gt; - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1</pre><p>

					</p><p>由于没有<code class="literal">bello</code>构建步骤，因此删除了指定包的构建时依赖关系的<code class="literal">BuildRequires</code>指令。Bash是一种原始的解释型编程语言，文件只是安装在系统上的位置。
				</p><p><code class="literal">Requires</code>指令指定包的运行时依赖性，仅包含<code class="literal">bash</code> ，因为<code class="literal">bello</code>脚本只需要执行<code class="literal">bash</code> shell环境。
				</p><p>指定如何构建软件的<code class="literal">%build</code>部分是空白的，因为不需要构建<code class="literal">bash</code> 。
				</p><p>要安装<code class="literal">bello</code>您只需要创建目标目录并在那里安装可执行的<code class="literal">bash</code>脚本文件。因此，您可以在<code class="literal">%install</code>部分中使用<code class="literal">install</code>命令。RPM宏允许在没有硬编码路径的情况下执行此操作。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="an-example-spec-file-for-pello_working-with-spec-files"></a>用Python编写的程序的示例SPEC文件</h2></div></div></div><p>本节显示了用Python编程语言编写的<span class="strong"><strong>pello</strong></span>程序的示例SPEC文件。有关<span class="strong"><strong>pello的</strong></span>更多信息，请参阅<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#source-code-examples" title="源代码示例">“源代码示例”一节</a> 。
				</p><div class="title"><strong>用Python编写的<span class="strong"><strong>pello</strong></span>程序的示例SPEC文件</strong></div><p>
						
</p><pre class="literallayout">Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

License:        GPLv3+
URL:            <a class="link" href="https://www.example.com/%{name}">https://www.example.com/%{name}</a>
Source0:        <a class="link" href="https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz">https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz</a>

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in Python.

%prep
%setup -q

%build

python -m compileall %{name}.py

%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat &gt; %{buildroot}/%{_bindir}/%{name} &lt;←EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

%changelog
* Tue May 31 2016 Adam Miller &lt;<a class="link" href="mailto:maxamillion@fedoraproject.org">maxamillion@fedoraproject.org</a>&gt; - 0.1.1-1
  - First pello package</pre><p>

					</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">重要</h3><p><span class="strong"><strong>pello</strong></span>程序是用字节编译的解释语言编写的。因此，shebang不适用，因为生成的文件不包含该条目。
					</p><p>由于shebang不适用，您可能需要应用以下方法之一：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">创建一个非字节编译的shell脚本，用于调用可执行文件。
							</li><li class="listitem">提供一小部分非字节编译的Python代码作为程序执行的入口点。
							</li></ul></div><p>这些方法特别适用于具有数千行代码的大型软件项目，其中前字节编译代码的性能增加是相当大的。
					</p></div><p><code class="literal">BuildRequires</code>指令指定包的构建时依赖性，包括两个包：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">需要<code class="literal">python</code>包来执行字节编译构建过程</li><li class="listitem">执行小入口点脚本需要<code class="literal">bash</code>包</li></ul></div><p><code class="literal">Requires</code>指令指定包的运行时依赖性，仅包含<code class="literal">python</code>包。<code class="literal">pello</code>程序需要<code class="literal">python</code>包在运行时执行字节编译的代码。
				</p><p><code class="literal">%build</code>部分指定了如何构建软件，这对应于软件是字节编译的事实。
				</p><p>要安装<code class="literal">pello</code> ，您需要创建一个包装器脚本，因为shebang不适用于字节编译语言。有多种方法可以实现此目的，例如：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">制作单独的脚本并将其用作单独的<code class="literal">SourceX</code>指令。
						</li><li class="listitem">在SPEC文件中在线创建文件。
						</li></ul></div><p>此示例显示在SPEC文件中在线创建包装器脚本，以演示SPEC文件本身是可编写脚本的。这个包装器脚本将使用<code class="literal">here</code>文件执行Python字节编译的代码。
				</p><p>此示例中的<code class="literal">%install</code>部分也对应于以下事实：您需要将字节编译的文件安装到系统上的库目录中，以便可以访问它。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="an-example-spec-file-for-cello_working-with-spec-files"></a>用C编写的程序的示例SPEC文件</h2></div></div></div><p>本节显示了用C编程语言编写的<span class="strong"><strong>大提琴</strong></span>程序的示例SPEC文件。有关<span class="strong"><strong>大提琴的</strong></span>更多信息，请参阅<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#source-code-examples" title="源代码示例">“源代码示例”一节</a> 。
				</p><div class="title"><strong>用C编写的<span class="strong"><strong>大提琴</strong></span>程序的示例SPEC文件</strong></div><p>
						
</p><pre class="literallayout">Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            <a class="link" href="https://www.example.com/%{name}">https://www.example.com/%{name}</a>
Source0:        <a class="link" href="https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz">https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz</a>

Patch0:         cello-output-first-patch.patch

BuildRequires:  gcc
BuildRequires:  make

%description
The long-tail description for our Hello World Example implemented in
C.

%prep
%setup -q

%patch0

%build
make %{?_smp_mflags}

%install
%make_install

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller &lt;<a class="link" href="mailto:maxamillion@fedoraproject.org">maxamillion@fedoraproject.org</a>&gt; - 1.0-1
- First cello package</pre><p>

					</p><p><code class="literal">BuildRequires</code>指令指定包的构建时依赖性，包括执行编译构建过程所需的两个包：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">gcc</code>包</li><li class="listitem"><code class="literal">make</code>包</li></ul></div><p>在此示例中省略了<code class="literal">Requires</code>指令，该指令指定包的运行时依赖性。所有运行时需求都由<code class="literal">rpmbuild</code>处理，而<code class="literal">cello</code>程序不需要核心C标准库之外的任何内容。
				</p><p><code class="literal">%build</code>部分反映了这样一个事实：在这个例子中，编写了<span class="strong"><strong>大提琴</strong></span>程序的<code class="literal">Makefile</code> ，因此可以使用<code class="literal">rpmdev-newspec</code>实用程序提供的<a class="link" href="http://www.gnu.org/software/make/">GNU make</a>命令。但是，您需要删除对<code class="literal">%configure</code>的调用，因为您没有提供配置脚本。
				</p><p>可以使用<code class="literal">rpmdev-newspec</code>命令提供的<code class="literal">%make_install</code>宏来完成<span class="strong"><strong>大提琴</strong></span>程序的安装。这是可能的，因为<span class="strong"><strong>大提琴</strong></span>程序的<code class="literal">Makefile</code>可用。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="building-rpms_packaging-software"></a>构建RPM</h1></div></div></div><p>本节介绍如何在创建程序的SPEC文件后构建RPM。
			</p><p>RPM是使用<code class="literal">rpmbuild</code>命令构建的。此命令需要某个目录和文件结构，该结构与<code class="literal">rpmdev-setuptree</code>实用程序设置的结构相同。
			</p><p>不同的用例和期望的结果需要<code class="literal">rpmbuild</code>命令的不同参数组合。本节介绍两个主要用例：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-source-rpms" title="构建源RPM">名为“构建源RPM”的部分</a>
					</li><li class="listitem">
						<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-binary-rpms" title="构建二进制RPMS">名为“构建二进制RPMS”的部分</a>
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="building-source-rpms"></a>构建源RPM</h2></div></div></div><p>构建源RPM（SRPM）有两个主要原因：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">保留部署到环境的RPM的某个名称版本发布的确切来源。
						</p><p class="simpara">这包括确切的SPEC文件，源代码和所有相关补丁。源RPM可用于回顾历史记录和调试。
						</p></li><li class="listitem">能够在不同的硬件平台或体系结构上构建二进制RPM。
						</li></ul></div><h4><a id="prerequisites_7"></a>先决条件</h4><p>我们要打包的程序的SPEC文件必须已存在。有关创建SPEC文件的更多信息，请参阅<a class="link" href="packaging-software_packaging-and-distributing-software.html#working-with-spec-files" title="使用SPEC文件">使用SPEC文件</a> 。
				</p><h4><a id="procedure_16"></a>程序</h4><p>以下过程描述了如何构建源RPM。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">使用指定的SPEC文件运行<code class="literal">rpmbuild</code>命令：</p><pre class="literallayout">$ rpmbuild -bs <span class="emphasis"><em>SPECFILE</em></span></pre><p class="simpara">用SPEC文件替换<span class="emphasis"><em>SPECFILE</em></span> 。<code class="literal">-bs</code>选项代表构建源。
						</p></li></ul></div><p>以下示例显示了<code class="literal">bello</code> ， <code class="literal">pello</code>和<code class="literal">cello</code>项目的构建源RPM。
				</p><div class="title"><strong>为bello，pello和cello构建源RPM。</strong></div><p>
						
</p><pre class="literallayout">$ cd ~/rpmbuild/SPECS/

8$ rpmbuild -bs bello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/bello-0.1-1.el8.src.rpm

$ rpmbuild -bs pello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/pello-0.1.2-1.el8.src.rpm

$ rpmbuild -bs cello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/cello-1.0-1.el8.src.rpm</pre><p>

					</p><p>生成的源RPM将放置到<code class="literal">rpmbuild/SRPMS</code>目录，该目录是<code class="literal">rpmbuild</code>期望的结构的一部分。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="building-binary-rpms"></a>构建二进制RPMS</h2></div></div></div><p>构建二进制RPM有两种方法：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="xref" href="packaging-software_packaging-and-distributing-software.html#rebuilding-binary" title="从源RPM重建二进制RPM">“从源RPM重建二进制RPM”一节</a>
						</li><li class="listitem">
							<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-binary" title="从SPEC文件构建二进制RPM">“从SPEC文件构建二进制RPM”一节</a>
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="rebuilding-binary"></a>从源RPM重建二进制RPM</h3></div></div></div><p>以下过程说明如何从源RPM（SRPM）重建二进制RPM。
					</p><h5><a id="procedure_17"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要从他们的SRPM重建<code class="literal">bello</code> ， <code class="literal">pello</code>和<code class="literal">cello</code> ，请运行：</p><pre class="literallayout">$ rpmbuild --rebuild ~/rpmbuild/SRPMS/bello-0.1-1.el8.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/pello-0.1.2-1.el8.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el8.src.rpm
[output truncated]</pre></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>调用<code class="literal">rpmbuild --rebuild</code>涉及：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">将SRPM的内容（SPEC文件和源代码）安装到<code class="literal">~/rpmbuild/</code>目录中。
								</li><li class="listitem">使用已安装的内容构建。
								</li><li class="listitem">删除SPEC文件和源代码。
								</li></ul></div><p>要在构建之后保留SPEC文件和源代码，您可以：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">建设时使用<code class="literal">rpmbuild</code>命令与<code class="literal">--recompile</code>选项而不是<code class="literal">--rebuild</code>选项。
								</li><li class="listitem"><p class="simpara">使用以下命令安装SRPM：</p><pre class="literallayout">$ rpm -Uvh ~/rpmbuild/SRPMS/bello-0.1-1.el8.src.rpm
Updating / installing…​
   1:bello-0.1-1.el8               [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/pello-0.1.2-1.el8.src.rpm
Updating / installing…​
…​1:pello-0.1.2-1.el8              [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/cello-1.0-1.el8.src.rpm
Updating / installing…​
…​1:cello-1.0-1.el8            [100%]</pre></li></ul></div></div><p>创建二进制RPM时生成的输出是详细的，这有助于调试。输出因不同的示例而异，并且与其SPEC文件相对应。
					</p><p>生成的二进制RPM位于<code class="literal">~/rpmbuild/RPMS/YOURARCH</code>目录中，其中<code class="literal">YOURARCH</code>是您的体系结构，或者位于<code class="literal">~/rpmbuild/RPMS/noarch/</code>目录中，如果包不是特定于体系结构的。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="building-binary"></a>从SPEC文件构建二进制RPM</h3></div></div></div><p>以下过程说明如何从SPEC文件构建<code class="literal">bello</code> ， <code class="literal">pello</code>和<code class="literal">cello</code>二进制RPM。
					</p><h5><a id="procedure_18"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">使用<code class="literal">bb</code>选项运行<code class="literal">rpmbuild</code>命令：</p><pre class="literallayout">$ rpmbuild -bb ~/rpmbuild/SPECS/bello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/pello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/cello.spec</pre></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="checking-rpms-for-sanity_packaging-software"></a>检查RPM是否合理</h1></div></div></div><p>创建包后，检查包的质量。
			</p><p>检查包质量的主要工具是<a class="link" href="https://github.com/rpm-software-management/rpmlint">rpmlint</a> 。
			</p><p><code class="literal">rpmlint</code>工具执行以下操作：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">提高RPM可维护性。
					</li><li class="listitem">通过执行RPM的静态分析来启用健全性检查。</li><li class="listitem">通过执行RPM的静态分析来启用错误检查。</li></ul></div><p><code class="literal">rpmlint</code>工具可以检查二进制RPM，源RPM（SRPM）和SPEC文件，因此它适用于所有打包阶段，如以下示例所示。
			</p><p>请注意， <code class="literal">rpmlint</code>具有非常严格的准则;因此，有时可以跳过它的一些错误和警告，如以下示例所示。
			</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>在以下示例中， <code class="literal">rpmlint</code>在没有任何选项的情况下运行，这会产生非详细输出。有关每个错误或警告的详细说明，您可以改为运行<code class="literal">rpmlint -i</code> 。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="checking-bello-for-sanity_checking-rpms-for-sanity"></a>检查bello是否理智</h2></div></div></div><p>本节显示了在bello SPEC文件和bello二进制RPM示例中检查RPM完整性时可能出现的警告和错误。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-bello-spec-file"></a>检查bello SPEC文件</h3></div></div></div><div class="example"><a id="idm140116092523968"></a><p class="title"><strong>例3.2。在SPEC文件上运行<code class="literal">rpmlint</code>命令的输出</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint bello.spec
bello.spec: W: invalid-url Source0: <a class="link" href="https://www.example.com/bello/releases/bello-0.1.tar.gz">https://www.example.com/bello/releases/bello-0.1.tar.gz</a> HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.</pre></div></div><p>对于<code class="literal">bello.spec</code> ，只有一个警告，表示<code class="literal">Source0</code>指令中列出的URL无法访问。这是预期的，因为指定的<code class="literal">example.com</code> URL不存在。假设我们希望此URL在将来有效，我们可以忽略此警告。
					</p><div class="example"><a id="idm140115981604176"></a><p class="title"><strong>例3.3。在SRPM上为bello运行<code class="literal">rpmlint</code>命令的输出</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/SRPMS/bello-0.1-1.el8.src.rpm
bello.src: W: invalid-url URL: <a class="link" href="https://www.example.com/bello">https://www.example.com/bello</a> HTTP Error 404: Not Found
bello.src: W: invalid-url Source0: <a class="link" href="https://www.example.com/bello/releases/bello-0.1.tar.gz">https://www.example.com/bello/releases/bello-0.1.tar.gz</a> HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.</pre></div></div><p>对于<code class="literal">bello</code> SRPM，有一个新警告，表示<code class="literal">URL</code>指令中指定的<code class="literal">URL</code>无法访问。假设链接将来正在运行，我们可以忽略此警告。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-bello-binary-rpm"></a>检查bello二进制RPM</h3></div></div></div><p>检查二进制RPM时， <code class="literal">rpmlint</code>检查以下项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">文档</li><li class="listitem">手册页</li><li class="listitem">一致使用文件系统层次结构标准</li></ul></div><div class="example"><a id="idm140116089143344"></a><p class="title"><strong>例3.4。对于bello，在二进制RPM上运行<code class="literal">rpmlint</code>命令的输出</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/RPMS/noarch/bello-0.1-1.el8.noarch.rpm
bello.noarch: W: invalid-url URL: <a class="link" href="https://www.example.com/bello">https://www.example.com/bello</a> HTTP Error 404: Not Found
bello.noarch: W: no-documentation
bello.noarch: W: no-manual-page-for-binary bello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.</pre></div></div><p><code class="literal">no-documentation</code>和<code class="literal">no-manual-page-for-binary</code>警告说他没有文档或手册页，因为我们没有提供任何文档或手册页。除了上述警告之外，RPM还是通过了<code class="literal">rpmlint</code>检查。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="checking-pello-for-sanity_checking-rpms-for-sanity"></a>检查pello是否理智</h2></div></div></div><p>本节显示了在pello SPEC文件和pello二进制RPM示例中检查RPM完整性时可能出现的警告和错误。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-pello-spec-file"></a>检查pello SPEC文件</h3></div></div></div><div class="example"><a id="idm140116088499840"></a><p class="title"><strong>例3.5。输出在SPEC文件上运行<code class="literal">rpmlint</code>命令以获取pello</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint pello.spec
pello.spec:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.spec:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.spec:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.spec:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.spec:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.spec: W: invalid-url Source0: <a class="link" href="https://www.example.com/pello/releases/pello-0.1.2.tar.gz">https://www.example.com/pello/releases/pello-0.1.2.tar.gz</a> HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 5 errors, 1 warnings.</pre></div></div><p><code class="literal">invalid-url Source0</code>警告表示<code class="literal">Source0</code>指令中列出的URL无法访问。这是预期的，因为指定的<code class="literal">example.com</code> URL不存在。假设此URL将来可用，您可以忽略此警告。
					</p><p><code class="literal">hardcoded-library-path</code>错误建议使用<code class="literal">%{_libdir}</code>宏而不是硬编码库路径。为了这个例子，您可以安全地忽略这些错误。但是，对于进入生产的包装，请务必仔细检查所有错误。
					</p><div class="example"><a id="idm140116107510336"></a><p class="title"><strong>例3.6。在SRPM上为pello运行<code class="literal">rpmlint</code>命令的输出</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/SRPMS/pello-0.1.2-1.el8.src.rpm
pello.src: W: invalid-url URL: <a class="link" href="https://www.example.com/pello">https://www.example.com/pello</a> HTTP Error 404: Not Found
pello.src:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.src:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.src:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.src:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.src:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.src: W: invalid-url Source0: <a class="link" href="https://www.example.com/pello/releases/pello-0.1.2.tar.gz">https://www.example.com/pello/releases/pello-0.1.2.tar.gz</a> HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 5 errors, 2 warnings.</pre></div></div><p>这里新的<code class="literal">invalid-url URL</code>错误是关于<code class="literal">URL</code>指令，它是无法访问的。假设URL将来有效，您可以放心地忽略此错误。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-pello-binary-rpm"></a>检查pello二进制RPM</h3></div></div></div><p>检查二进制RPM时， <code class="literal">rpmlint</code>检查以下项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">文档</li><li class="listitem">手册页</li><li class="listitem">一致使用文件系统层次结构标准</li></ul></div><div class="example"><a id="idm140116086398208"></a><p class="title"><strong>例3.7。输出在二进制RPM上运行<code class="literal">rpmlint</code>命令以获取pello</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/RPMS/noarch/pello-0.1.2-1.el8.noarch.rpm
pello.noarch: W: invalid-url URL: <a class="link" href="https://www.example.com/pello">https://www.example.com/pello</a> HTTP Error 404: Not Found
pello.noarch: W: only-non-binary-in-usr-lib
pello.noarch: W: no-documentation
pello.noarch: E: non-executable-script /usr/lib/pello/pello.py 0644L /usr/bin/env
pello.noarch: W: no-manual-page-for-binary pello
1 packages and 0 specfiles checked; 1 errors, 4 warnings.</pre></div></div><p><code class="literal">no-documentation</code>和<code class="literal">no-manual-page-for-binary</code>警告表示RPM没有文档或手册页，因为您没有提供任何文档或手册页。
					</p><p><code class="literal">only-non-binary-in-usr-lib</code>警告说你在<code class="literal">/usr/lib/</code>只提供了非二进制工件。此目录通常保留用于共享对象文件，这些文件是二进制文件。因此， <code class="literal">rpmlint</code> <code class="literal">/usr/lib/</code>目录中至少有一个或多个文件是二进制文件。
					</p><p>这是<code class="literal">rpmlint</code>检查是否符合Filesystem Hierarchy Standard的示例。通常，使用RPM宏来确保正确放置文件。为了这个例子，您可以安全地忽略此警告。
					</p><p><code class="literal">non-executable-script</code>错误警告<code class="literal">/usr/lib/pello/pello.py</code>文件没有执行权限。<code class="literal">rpmlint</code>工具希望该文件是可执行的，因为该文件包含shebang。出于此示例的目的，您可以保留此文件而不具有执行权限，并忽略此错误。
					</p><p>除了上述警告和错误之外，RPM还是通过了<code class="literal">rpmlint</code>检查。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="checking-cello-for-sanity_checking-rpms-for-sanity"></a>检查大提琴是否理智</h2></div></div></div><p>本节显示了在大提琴SPEC文件和pello二进制RPM示例中检查RPM完整性时可能出现的警告和错误。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-cello-spec-file"></a>检查大提琴SPEC文件</h3></div></div></div><div class="example"><a id="idm140116098152592"></a><p class="title"><strong>例3.8。输出在大提琴的SPEC文件上运行<code class="literal">rpmlint</code>命令</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/SPECS/cello.spec
/home/admiller/rpmbuild/SPECS/cello.spec: W: invalid-url Source0: <a class="link" href="https://www.example.com/cello/releases/cello-1.0.tar.gz">https://www.example.com/cello/releases/cello-1.0.tar.gz</a> HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.</pre></div></div><p>对于<code class="literal">cello.spec</code> ，只有一个警告，表示<code class="literal">Source0</code>指令中列出的URL无法访问。这是预期的，因为指定的<code class="literal">example.com</code> URL不存在。假设此URL将来可用，您可以忽略此警告。
					</p><div class="example"><a id="idm140116018190208"></a><p class="title"><strong>例3.9。输出在SRPM上为大提琴运行<code class="literal">rpmlint</code>命令</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/SRPMS/cello-1.0-1.el8.src.rpm
cello.src: W: invalid-url URL: <a class="link" href="https://www.example.com/cello">https://www.example.com/cello</a> HTTP Error 404: Not Found
cello.src: W: invalid-url Source0: <a class="link" href="https://www.example.com/cello/releases/cello-1.0.tar.gz">https://www.example.com/cello/releases/cello-1.0.tar.gz</a> HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.</pre></div></div><p>对于<code class="literal">cello</code> SRPM，有一个新警告，表示<code class="literal">URL</code>指令中指定的<code class="literal">URL</code>无法访问。假设链接将来正在运行，您可以忽略此警告。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="checking-cello-binary-rpm"></a>检查大提琴二进制RPM</h3></div></div></div><p>检查二进制RPM时， <code class="literal">rpmlint</code>检查以下项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">文档</li><li class="listitem">手册页</li><li class="listitem">一致使用文件系统层次结构标准</li></ul></div><div class="example"><a id="idm140116099915776"></a><p class="title"><strong>例3.10。在大提琴的二进制RPM上运行<code class="literal">rpmlint</code>命令的输出</strong></p><div class="example-contents"><pre class="literallayout">$ rpmlint ~/rpmbuild/RPMS/x86_64/cello-1.0-1.el8.x86_64.rpm
cello.x86_64: W: invalid-url URL: <a class="link" href="https://www.example.com/cello">https://www.example.com/cello</a> HTTP Error 404: Not Found
cello.x86_64: W: no-documentation
cello.x86_64: W: no-manual-page-for-binary cello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.</pre></div></div><p><code class="literal">no-documentation</code>和<code class="literal">no-manual-page-for-binary</code>警告说他没有文档或手册页，因为你没有提供任何文档或手册页。除了上述警告之外，RPM还是通过了<code class="literal">rpmlint</code>检查。
					</p></div></div></div></div></body></html>