<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>附录A. RHEL 8中开发工具的差异</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a id="differences-in-development-tools-in-rhel-8_developing-applications"></a>附录A. RHEL 8中开发工具的差异</h1></div></div></div><p>以下部分列出了Red Hat Enterprise Linux 8和7之间的重要差异。
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="changes-in-toolchain-since-rhel-7_differences-in-development-tools-in-rhel-8"></a>自RHEL 7以来工具链的变化</h1></div></div></div><p>以下部分列出了自Red Hat Enterprise Linux 7中所述组件发布以来工具链中的更改。另请参阅<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/8.0_release_notes/">Red Hat Enterprise Linux 8.0的发行说明</a> 。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="changes-in-gcc-in-rhel-8_changes-in-toolchain-since-rhel-7"></a> RHEL 8中GCC的变化</h2></div></div></div><p>在Red Hat Enterprise Linux 8中，GCC工具链基于GCC 8.2发布系列。自Red Hat Enterprise Linux 7以来的显着变化包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">已经添加了许多一般优化，例如别名分析，矢量化器改进，相同的代码折叠，过程间分析，商店合并优化传递等。
						</li><li class="listitem">Address Sanitizer已得到改进。
						</li><li class="listitem">添加了用于检测内存泄漏的泄漏消毒剂。
						</li><li class="listitem">添加了用于检测未定义行为的Undefined Behavior Sanitizer。
						</li><li class="listitem">现在可以以DWARF5格式生成调试信息。这种能力是实验性的。
						</li><li class="listitem">源代码覆盖率分析工具GCOV已经扩展了各种改进。
						</li><li class="listitem">增加了对OpenMP 4.5规范的支持。此外，C ++，C ++和Fortran编译器现在支持OpenMP 4.0规范的卸载功能。
						</li><li class="listitem">添加了新警告和改进的诊断，用于静态检测某些可能的编程错误。
						</li><li class="listitem">源位置现在被跟踪为范围而不是点，这允许更丰富的诊断。编译器现在提供“修复它”提示，建议可能的代码修改。添加了拼写检查器以提供替代名称并轻松检测拼写错误。
						</li></ul></div><div class="title"><strong>安全</strong></div><p>GCC已扩展为提供工具以确保生成的代码的额外加固。与安全相关的改进包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">添加了具有溢出检查的算术的<code class="literal">__builtin_add_overflow</code> ， <code class="literal">__builtin_sub_overflow</code>和<code class="literal">__builtin_mul_overflow</code>内置函数。
						</li><li class="listitem">添加了<code class="literal">-fstack-clash-protection</code>选项以生成防止堆栈冲突的其他代码。
						</li><li class="listitem">引入了<code class="literal">-fcf-protection</code>选项来检查控制流指令的目标地址，以提高程序的安全性。
						</li><li class="listitem">新的<code class="literal">-Wstringop-truncation</code>警告选项列出了对有界字符串操作函数（如<code class="literal">strncat</code> ， <code class="literal">strncpy</code>或<code class="literal">stpncpy</code>调用，这些函数可能会截断复制的字符串或保持目标不变。
						</li><li class="listitem"><code class="literal">-Warray-bounds</code>警告选项已得到改进，可以更好地检测越界数组索引和指针偏移。
						</li><li class="listitem">添加了<code class="literal">-Wclass-memaccess</code>警告选项，以警告可能通过原始内存访问函数（如<code class="literal">memcpy</code>或<code class="literal">realloc</code>对非平凡类类型的对象进行不安全操作。
						</li></ul></div><div class="title"><strong>架构和处理器支持</strong></div><p>架构和处理器支持的改进包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">英特尔AVX-512架构的多个新架构特定选项，其许多微架构以及英特尔软件防护扩展（SGX）已被添加。
						</li><li class="listitem">代码生成现在可以针对64位ARM体系结构LSE扩展，ARMv8.2-A 16位浮点扩展（FPE）和ARMv8.2-A，ARMv8.3-A和ARMv8.4-A体系结构版本。
						</li><li class="listitem">已修复了ARM和64位ARM体系结构上<code class="literal">-march=native</code>选项的处理问题。
						</li><li class="listitem">添加了对IBM Z体系结构的z13和z14处理器的支持。
						</li></ul></div><div class="title"><strong>语言和标准</strong></div><p>与语言和标准相关的显着变化包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">在C语言中编译代码时使用的默认标准已更改为带有GNU扩展的C17。
						</li><li class="listitem">在C ++语言中编译代码时使用的默认标准已更改为使用GNU扩展的C ++ 14。
						</li><li class="listitem">C ++运行时库现在支持C ++ 11和C ++ 14标准。
						</li><li class="listitem">C ++编译器现在实现了C ++ 14标准，其中包含许多新功能，例如变量模板，带有非静态数据成员初始化器的聚合，扩展的<code class="literal">constexpr</code>说明符，大小的释放函数，通用lambda，可变长度数组，数字分隔符和其他。
						</li><li class="listitem">对C语言标准C11的支持已得到改进：现在可以使用ISO C11原子，通用选择和线程局部存储。
						</li><li class="listitem">新的<code class="literal">__auto_type</code> GNU C扩展提供了C语言中C ++ 11 <code class="literal">auto</code>关键字功能的子集。
						</li><li class="listitem">ISO / IEC TS 18661-3：2015标准指定的<code class="literal">_FloatN</code>和<code class="literal">_FloatNx</code>类型名称现在由C前端识别。
						</li><li class="listitem">在C语言中编译代码时使用的默认标准已更改为带有GNU扩展的C17。这与使用<code class="literal">--std=gnu17</code>选项具有相同的效果。以前，默认情况下是带有GNU扩展的C89。
						</li><li class="listitem">GCC现在可以使用C ++ 17语言标准以及C ++ 20标准的某些功能来实验性地编译代码。
						</li><li class="listitem">根据平台ABI的要求，将空类作为参数传递现在不占用Intel 64和AMD64架构上的空间。传递或返回仅具有已删除的副本和移动构造函数的类现在使用与具有非平凡副本或移动构造函数的类相同的调用约定。
						</li><li class="listitem">已更正C ++ 11 <code class="literal">alignof</code>运算符返回的值以匹配C <code class="literal">_Alignof</code>运算符并返回最小对齐。要查找首选对齐方式，请使用GNU扩展名<code class="literal">__alignof__</code> 。
						</li><li class="listitem">Fortran语言代码的<code class="literal">libgfortran</code>库的主要版本已更改为5。
						</li><li class="listitem">已删除对Ada（GNAT），GCC Go和Objective C / C ++语言的支持。使用Go Toolset进行Go代码开发。
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>其他资源</strong></p><ul class="itemizedlist"><li class="listitem">另请参阅“ <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/">Red Hat Enterprise Linux 8发行说明”</a> 。
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_developer_tools/2018.4/html/using_go_toolset/index">使用Go Toolset</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="security-enhancements-in-gcc-in-rhel-8_changes-in-toolchain-since-rhel-7"></a> RHEL 8中GCC的安全性增强</h2></div></div></div><p>本节详细介绍了自红帽企业Linux 7.0发布以来GCC相关安全性的变化。
				</p><div class="title"><strong>新警告</strong></div><p>添加了以下警告选项：</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项</th><th valign="top" style="text-align:left">显示警告</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wstringop截断</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>调用有界字符串操作函数，例如<code class="literal">strncat</code> ， <code class="literal">strncpy</code>和<code class="literal">stpncpy</code> ，它们可能会截断复制的字符串或保持目标不变。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wclass-memaccess</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>非平凡类类型的对象通过原始内存函数（如<code class="literal">memcpy</code>或<code class="literal">realloc</code>以可能不安全的方式进行操作。
								</p>
								 <p>该警告有助于检测绕过用户定义的构造函数或复制赋值运算符，损坏虚拟表指针，const限定类型或引用的数据成员或成员指针的调用。该警告还会检测绕过对数据成员的访问控制的调用。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wmisleading压痕</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>代码缩进的地方给人类读者带来了代码块结构的误导性概念。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Walloc-size-than-than = <span class="emphasis"><em>size</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>调用内存分配函数，其中要分配的内存量超出<span class="emphasis"><em>大小</em></span> 。也适用于通过将两个参数相乘以及使用属性<code class="literal">alloc_size</code>装饰的任何函数来指定分配的函数。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Walloc零</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>调用尝试分配零内存量的内存分配函数。也适用于通过将两个参数相乘以及使用属性<code class="literal">alloc_size</code>装饰的任何函数来指定分配的函数。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Walloca</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>所有对<code class="literal">alloca</code>函数的调用。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Walloca-than-than = <span class="emphasis"><em>size</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>调用<code class="literal">alloca</code>函数，其中请求的内存大于<span class="emphasis"><em>大小</em></span> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wvla-大于= <span class="emphasis"><em>尺寸</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>可变长度阵列（VLA）的定义可以超过指定的大小，或者其边界未被充分约束。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wformat-overflow = <span class="emphasis"><em>level</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在调用<code class="literal">sprintf</code>系列格式化输出函数时，某些和可能的缓冲区都会溢出。有关<span class="emphasis"><em>级别</em></span>值的更多详细信息和说明，请参见<span class="emphasis"><em>gcc（1）</em></span>手册页。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wformat-truncation = <span class="emphasis"><em>level</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在调用<code class="literal">snprintf</code>系列格式化输出函数时，某些和可能的输出都会截断。有关<span class="emphasis"><em>级别</em></span>值的更多详细信息和说明，请参见<span class="emphasis"><em>gcc（1）</em></span>手册页。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-Wstringop-overflow = <span class="emphasis"><em>type</em></span></code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>调用字符串处理函数（如<code class="literal">memcpy</code>和<code class="literal">strcpy</code>缓冲区溢出。有关<span class="emphasis"><em>级别</em></span>值的更多详细信息和说明，请参见<span class="emphasis"><em>gcc（1）</em></span>手册页。
								</p>
								 </td></tr></tbody></table></div><div class="title"><strong>警告改进</strong></div><p>这些GCC警告已得到改进：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">-Warray-bounds</code>选项已得到改进，可以检测越界数组索引和指针偏移的更多实例。例如，检测到灵活数组成员和字符串文字的负或过多索引。
						</li><li class="listitem">GCC 7中引入的<code class="literal">-Wrestrict</code>选项已得到增强，可通过对标准内存和字符串操作函数（如<code class="literal">memcpy</code>和<code class="literal">strcpy</code>限制限定参数来检测更多对对象重叠访问的实例。
						</li><li class="listitem"><code class="literal">-Wnonnull</code>选项已得到增强，可以检测更广泛的一组将空指针传递给期望非空参数（使用属性<code class="literal">nonnull</code>修饰）的函数的情况。
						</li></ul></div><div class="title"><strong>新的UndefinedBehaviorSanitizer</strong></div><p>添加了一个新的运行时清理程序，用于检测名为UndefinedBehaviorSanitizer的未定义行为。以下选项值得注意：</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项</th><th valign="top" style="text-align:left">校验</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =浮子除以零</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>检测浮点除以零。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =浮法铸溢出</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>检查浮点类型到整数转换的结果是否溢出。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =界限</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用数组边界检测并检测越界访问。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =对准</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用对齐检查并检测各种未对齐的对象。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =对象尺寸</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用对象大小检查并检测各种越界访问。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize = vptr的</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用检查C ++成员函数调用，成员访问以及指向基类和派生类的指针之间的一些转换。另外，检测引用的对象何时没有正确的动态类型。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =边界严格</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用严格检查数组边界。这使得<code class="literal">-fsanitize=bounds</code>以及灵活的数组成员类数组的检测成为可能。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =签名整数溢出</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>即使在使用通用向量的算术运算上，诊断算法也会溢出。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =内置</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在运行时诊断<code class="literal">__builtin_clz</code>或<code class="literal">__builtin_ctz</code> prefixed builtins的无效参数。包括来自<code class="literal">-fsanitize=undefined</code>检查。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =指针溢出</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>对指针包装执行廉价的运行时测试。包括来自<code class="literal">-fsanitize=undefined</code>检查。
								</p>
								 </td></tr></tbody></table></div><div class="title"><strong>AddressSanitizer的新选项</strong></div><p>这些选项已添加到AddressSanitizer中：</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项</th><th valign="top" style="text-align:left">校验</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =指针比较</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>警告有关指向不同内存对象的指针的比较。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize =指针减</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>关于指向不同内存对象的指针减法的警告。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">-fsanitize-地址释放后使用范围</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>清理变量的地址，并在定义变量的范围之后使用。
								</p>
								 </td></tr></tbody></table></div><div class="itemizedlist"><p class="title"><strong>其他消毒杀菌剂和仪器</strong></p><ul class="itemizedlist"><li class="listitem">当静态或动态分配堆栈空间以可靠地检测堆栈溢出时，添加了选项<code class="literal">-fstack-clash-protection</code>以插入探测，从而减轻依赖于跳过操作系统提供的堆栈保护页面的攻击向量。
						</li><li class="listitem">添加了一个新选项<code class="literal">-fcf-protection=[full|branch|return|none]</code>来执行代码检测并通过检查控制流转移指令的目标地址（例如间接函数调用，函数返回，间接）来提高程序安全性跳）是有效的。
						</li><li class="listitem">可以使用<code class="literal">-fcheck-pointer-bounds</code>选项启用名为Pointer Bounds Checker的新边界违规检测器。内存访问使用针对其边界的使用指针的运行时检查来检测指针边界违规（溢出）。此功能适用于64位Intel和AMD架构的目标，并具有新的ISA扩展Intel MPX支持。
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>其他资源</strong></p><ul class="itemizedlist"><li class="listitem"><p class="simpara">有关上面某些选项提供的值的更多详细信息和说明，请参阅<span class="emphasis"><em>gcc（1）</em></span>手册页：</p><pre class="screen">$ man gcc</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="compiler-toolsets_differences-in-development-tools-in-rhel-8"></a>编译器工具集</h1></div></div></div><p>RHEL 8.0提供以下编译器工具集作为Application Streams：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Clang和LLVM Toolset 7.0.1，提供LLVM编译器基础结构框架，用于C和C ++语言的Clang编译器，LLDB调试器以及用于代码分析的相关工具。请参阅<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_developer_tools/2019.1/html/using_clang_and_llvm_toolset/index">Using Clang和LLVM Toolset</a>文档。
					</li><li class="listitem">Rust Toolset 1.31，它提供Rust编程语言编译器<code class="literal">rustc</code> ， <code class="literal">cargo</code>构建工具和依赖管理器， <code class="literal">cargo-vendor</code>插件和所需的库。请参阅<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_developer_tools/2019.1/html/using_rust_toolset/index">使用Rust工具集</a>文档。
					</li><li class="listitem">Go Toolset 1.11.5，提供Go编程语言工具和库。Go也称为<code class="literal">golang</code> 。请参阅<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_developer_tools/2019.1/html/using_go_toolset/index">使用Go Toolset</a>文档。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="compatibility-breaking-changes-in-gdb_differences-in-development-tools-in-rhel-8"></a> GDB中兼容性突破的变化</h1></div></div></div><p>Red Hat Enterprise Linux 8中提供的GDB版本包含许多破坏兼容性的更改，尤其是对于直接从终端读取GDB输出的情况。以下部分提供有关这些更改的更多详细信息。
			</p><p>不建议解析GDB的输出。首选使用Python GDB API或GDB机器接口（MI）的脚本。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="gdbserver_now_starts_inferiors_with_shell"></a> GDBserver现在用shell启动下级</h2></div></div></div><p>为了在劣质命令行参数中启用扩展和变量替换，GDBserver现在在shell中启动劣质，与GDB相同。</p><p>要禁用shell：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">使用<code class="literal">target extended-remote</code> GDB命令时，请使用<code class="literal">set startup-with-shell off</code>命令禁用shell。
						</li><li class="listitem">使用<code class="literal">target remote</code> GDB命令时，请使用GDBserver的<code class="literal">--no-startup-with-shell</code>选项禁用shell。
						</li></ul></div><div class="example"><a id="idm140318682259216"></a><p class="title"><strong>例A.1。远程GDB下级中的shell扩展示例</strong></p><div class="example-contents"><p>此示例显示了如何通过GDBserver在Red Hat Enterprise Linux版本7和8上运行<code class="literal">/bin/echo /*</code>命令：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">在RHEL 7上：</p><pre class="screen">$ gdbserver --multi :1234
$ gdb -batch -ex 'target extended-remote :1234' -ex 'set remote exec-file /bin/echo' -ex 'file /bin/echo' -ex 'run /*'
/*</pre></li><li class="listitem"><p class="simpara">在RHEL 8上：</p><pre class="screen">$ gdbserver --multi :1234
$ gdb -batch -ex 'target extended-remote :1234' -ex 'set remote exec-file /bin/echo' -ex 'file /bin/echo' -ex 'run /*'
/bin /boot (...) /tmp /usr /var</pre></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="gcj_support_removed"></a>已删除gcj支持</h2></div></div></div><p>已删除对使用<code class="literal">gcj</code>编译的调试Java程序的支持。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="new_syntax_for_symbol_dumping_maintenance_commands"></a>符号转储维护命令的新语法</h2></div></div></div><p>符号转储维护命令语法现在包括文件名之前的选项。因此，在RHEL 7中使用GDB的命令在RHEL 8中不起作用。
				</p><p>例如，以下命令不再将符号存储在文件中，但会生成错误消息：</p><pre class="screen">(gdb) maintenance print symbols /tmp/out main.c</pre><p>符号转储维护命令的新语法是：</p><pre class="screen">maint print symbols [-pc <span class="emphasis"><em>address</em></span>] [--] [<span class="emphasis"><em>filename</em></span>]
maint print symbols [-objfile <span class="emphasis"><em>objfile</em></span>] [-source <span class="emphasis"><em>source</em></span>] [--] [<span class="emphasis"><em>filename</em></span>]
maint print psymbols [-objfile <span class="emphasis"><em>objfile</em></span>] [-pc <span class="emphasis"><em>address</em></span>] [--] [<span class="emphasis"><em>filename</em></span>]
maint print psymbols [-objfile <span class="emphasis"><em>objfile</em></span>] [-source <span class="emphasis"><em>source</em></span>] [--] [<span class="emphasis"><em>filename</em></span>]
maint print msymbols [-objfile <span class="emphasis"><em>objfile</em></span>] [--] [<span class="emphasis"><em>filename</em></span>]</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="thread_numbers_are_no_loger_global"></a>线程数不是全局的</h2></div></div></div><p>以前，GDB仅使用全局线程编号。编号一直延伸到被在每形式显示低劣<code class="literal">inferior_num.thread_num</code> ，如<code class="literal">2.1</code> 。因此， <code class="literal">$_thread</code>便捷变量和<code class="literal">InferiorThread.num</code> Python属性中的线程编号在<code class="literal">InferiorThread.num</code>之间不再是唯一的。
				</p><p>GDB现在为每个线程存储第二个线程ID，称为全局线程ID，这是先前版本中新的线程数等价物。要访问全局线程编号，请使用<code class="literal">$_gthread</code>便捷变量和<code class="literal">InferiorThread.global_num</code> Python属性。
				</p><p>为了向后兼容，机器接口（MI）线程ID始终包含全局ID。
				</p><div class="example"><a id="idm140318688095312"></a><p class="title"><strong>例A.2。GDB线程号更改的示例</strong></p><div class="example-contents"><p>在Red Hat Enterprise Linux 7上：</p><pre class="screen"># debuginfo-install coreutils
$ gdb -batch -ex 'file echo' -ex start -ex 'add-inferior' -ex 'inferior 2' -ex 'file echo' -ex start -ex 'info threads' -ex 'pring $_thread' -ex 'inferior 1' -ex 'pring $_thread'
(...)
  Id   Target Id         Frame
* 2    process 203923 "echo" main (argc=1, argv=0x7fffffffdb88) at src/echo.c:109
  1    process 203914 "echo" main (argc=1, argv=0x7fffffffdb88) at src/echo.c:109
$1 = 2
(...)
$2 = 1</pre><p>在Red Hat Enterprise Linux 8上：</p><pre class="screen"># dnf debuginfo-install coreutils
$ gdb -batch -ex 'file echo' -ex start -ex 'add-inferior' -ex 'inferior 2' -ex 'file echo' -ex start -ex 'info threads' -ex 'pring $_thread' -ex 'inferior 1' -ex 'pring $_thread'
(...)
  Id   Target Id         Frame
  1.1  process 4106488 "echo" main (argc=1, argv=0x7fffffffce58) at ../src/echo.c:109
* 2.1  process 4106494 "echo" main (argc=1, argv=0x7fffffffce58) at ../src/echo.c:109
$1 = 1
(...)
$2 = 1</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="memory_for_value_contents_can_be_limited"></a>可以限制值内容的存储器</h2></div></div></div><p>以前，GDB没有限制为值内容分配的内存量。因此，调试错误的程序可能会导致GDB分配太多内存。添加了<code class="literal">max-value-size</code>设置以启用限制已分配内存的数量。此限制的默认值为64 KiB。因此，Red Hat Enterprise Linux 8中的GDB不会显示太大的值，而是报告该值太大。
				</p><p>例如，打印定义为<code class="literal">char s[128*1024];</code>产生不同的结果：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">在Red Hat Enterprise Linux 7上， <code class="literal">$1 = 'A' &lt;repeats 131072 times&gt;</code>
						</li><li class="listitem">在Red Hat Enterprise Linux 8上， <code class="literal">value requires 131072 bytes, which is more than max-value-size</code>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sun_version_of_stabs_format_no_longer_supported"></a>不再支持Sun版本的stabs格式</h2></div></div></div><p>已删除对Sun版本的<code class="literal">stabs</code>调试文件格式的支持。GDB仍然支持GCC在RHEL中使用<code class="literal">gcc -gstabs</code>选项生成的<code class="literal">stabs</code>格式。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sysroot_handling_changes"></a> Sysroot处理变化</h2></div></div></div><p><code class="literal">set sysroot <span class="emphasis"><em>path</em></span></code>命令在搜索调试所需的文件时指定系统root。提供给此命令的目录名称现在可以使用字符串<code class="literal">target:</code>作为前缀<code class="literal">target:</code>使GDB从目标系统（本地和远程）读取共享库。以前可用的<code class="literal">remote:</code>前缀现在被视为<code class="literal">target:</code> 。此外，默认系统根值已从空字符串更改为<code class="literal">target:</code>以实现向后兼容性。
				</p><p>当GDB远程启动进程时，或者当它连接到已经运行的进程（本地和远程进程）时，指定的系统根被添加到主可执行文件的文件名前面。这意味着对于远程进程，默认值<code class="literal">target:</code>使GDB始终尝试从远程系统加载调试信息。要防止这种情况，请在<code class="literal">target remote</code>命令之前运行<code class="literal">set sysroot</code>命令，以便在<code class="literal">target remote</code>命令之前找到本地符号文件。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="histsize_no_longer_controls_gdb_command_history_size"></a> HISTSIZE不再控制GDB命令历史记录大小</h2></div></div></div><p>以前，GDB使用<code class="literal">HISTSIZE</code>环境变量来确定应保留命令历史记录的时间。GDB已更改为使用<code class="literal">GDBHISTSIZE</code>环境变量。此变量仅特定于GDB。可能的值及其影响是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">正数 - 使用此大小的命令历史记录，</li><li class="listitem">
							<code class="literal">-1</code>或空字符串 - 保留所有命令的历史记录，</li><li class="listitem">非数字值 - 忽略。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="completion_limiting_added"></a>完成限制添加</h2></div></div></div><p>现在可以使用<code class="literal">set max-completions</code>命令限制在完成期间考虑的最大候选者数量。要显示当前限制，请运行<code class="literal">show max-completions</code>命令。默认值为200。此限制可防止GDB生成过大的完成列表并变得无响应。
				</p><p>例如，输入<code class="literal">p &lt;tab&gt;&lt;tab&gt;</code>后的输出为：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">在RHEL 7上： <code class="literal">Display all 29863 possibilities?（是或否）</code>
						</li><li class="listitem">在RHEL 8上： <code class="literal">Display all 200 possibilities?（是或否）</code>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="hp_ux_xdb_compatibility_mode_removed"></a>已删除HP-UX XDB兼容模式</h2></div></div></div><p>已从GDB中删除HP-UX XDB兼容模式的<code class="literal">-xdb</code>选项。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="handling_signals_for_threads"></a>处理线程的信号</h2></div></div></div><p>以前，GDB可以向当前线程发送信号，而不是实际发送信号的线程。此错误已得到修复，GDB现在始终在恢复执行时将信号传递给正确的线程。
				</p><p>此外， <code class="literal">signal</code>命令现在始终正确地将请求的信号传递给当前线程。如果程序因信号而停止并且用户切换了线程，GDB会要求确认。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="breakpoint_modes_always_inserted_off_and_auto_merged"></a>断点模式始终插入并自动合并</h2></div></div></div><p><code class="literal">breakpoint always-inserted</code>设置已更改。<code class="literal">auto</code>值和相应的行为已被删除。现在，默认值已<code class="literal">off</code> 。此外， <code class="literal">off</code>值现在导致GDB在所有线程停止之前不从目标中删除断点。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="remotebaud_commands_no_longer_supported"></a>不再支持remotebaud命令</h2></div></div></div><p>不再支持<code class="literal">set remotebaud</code>和<code class="literal">show remotebaud</code>命令。请改用<code class="literal">set serial baud</code>和<code class="literal">show serial baud</code>命令。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="compatibility-breaking-changes-in-compilers-and-development-tools_differences-in-development-tools-in-rhel-8"></a>编译器和开发工具中兼容性的变化</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="cpp-abi_compatibility-breaking-changes-in-compilers-and-development-tools"></a> C ++ ABI在<code class="literal">std::string</code>和<code class="literal">std::list</code>更改</h2></div></div></div><p>来自<code class="literal">libstdc++</code>库的<code class="literal">std::string</code>和<code class="literal">std::list</code>类的应用程序二进制接口（ABI）在RHEL 7（GCC 4.8）和RHEL 8（GCC 8）之间进行了更改，以符合C ++ 11标准。<code class="literal">libstdc++</code>库既支持新旧ABI，也支持其他一些C ++系统库。因此，需要重建动态链接这些库的应用程序。这会影响所有C ++标准模式，包括C ++ 98。它还会影响使用RHEL 7的Red Hat Developer Toolset编译器构建的应用程序，这使得旧的ABI保持与系统库的兼容性。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="librtkaio-removed_compatibility-breaking-changes-in-compilers-and-development-tools"></a> <span class="strong"><strong>librtkaio</strong></span>已删除</h2></div></div></div><p>通过此更新， <span class="strong"><strong>librtkaio</strong></span>库已被删除。该库为某些文件提供了高性能的实时异步I / O访问，这些文件基于Linux内核异步I / O支持（KAIO）。
				</p><p>由于删除：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">使用<code class="literal">LD_PRELOAD</code>方法加载<span class="strong"><strong>librtkaio的</strong></span>应用程序显示有关缺少库的警告，而是加载<span class="strong"><strong>librt</strong></span>库并正确运行。
						</li><li class="listitem">使用<code class="literal">LD_LIBRARY_PATH</code>方法加载<span class="strong"><strong>librtkaio的</strong></span>应用程序<span class="strong"><strong>改为</strong></span>加载<span class="strong"><strong>librt</strong></span>库并正确运行，没有任何警告。
						</li><li class="listitem">使用<code class="literal">dlopen()</code>系统调用访问<span class="strong"><strong>librtkaio的</strong></span>应用程序直接加载<span class="strong"><strong>librt</strong></span>库。
						</li></ul></div><p><span class="strong"><strong>librtkaio的</strong></span>用户有以下选项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">使用上述回退机制，而不对其应用程序进行任何更改。
						</li><li class="listitem">更改其应用程序的代码以使用<span class="strong"><strong>librt</strong></span>库，该库提供兼容的POSIX兼容API。</li><li class="listitem">更改其应用程序的代码以使用<span class="strong"><strong>libaio</strong></span>库，该库提供兼容的API。</li></ul></div><p><span class="strong"><strong>librt</strong></span>和<span class="strong"><strong>libaio</strong></span>都可以在特定条件下提供可比较的功能和性能。
				</p><p>请注意， <span class="strong"><strong>libaio</strong></span>包的Red Hat兼容级别为2，而<span class="strong"><strong>librtk</strong></span>和删除的<span class="strong"><strong>librtkaio</strong></span>级别为1。
				</p><p>有关更多详细信息，请参阅<a class="link" href="https://fedoraproject.org/wiki/Changes/GLIBC223_librtkaio_removal">https://fedoraproject.org/wiki/Changes/GLIBC223_librtkaio_removal</a>
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="glibc-sun-rpc-nis_compatibility-breaking-changes-in-compilers-and-development-tools"></a>从<code class="literal">glibc</code>删除了Sun RPC和NIS接口</h2></div></div></div><p><code class="literal">glibc</code>库不再为新应用程序提供Sun RPC和NIS接口。这些接口现在仅可用于运行旧版应用程序。开发人员必须更改其应用程序以使用<code class="literal">libtirpc</code>库而不是Sun RPC和<code class="literal">libnsl2</code>而不是NIS。应用程序可以从替换库中的IPv6支持中受益。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="valgrind-library-for-MPI-debugging-support-removed_compatibility-breaking-changes-in-compilers-and-development-tools"></a>删除了Valgrind库以获取MPI调试支持</h2></div></div></div><p>已删除<code class="literal">valgrind-openmpi</code>包提供的<span class="strong"><strong>Valgrind</strong></span>的<code class="literal">libmpiwrap.so</code>包装器库。该库使<span class="strong"><strong>Valgrind</strong></span>能够使用消息传递接口（MPI）调试程序。该库特定于以前版本的Red Hat Enterprise Linux中的Open MPI实现版本。
				</p><p>我们鼓励<code class="literal">libmpiwrap.so</code>用户从特定于其MPI实现和版本的上游源构建自己的版本。使用<code class="literal">LD_PRELOAD</code>技术将这些定制库提供给<span class="strong"><strong>Valgrind</strong></span> 。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="valgrind-devel_compatibility-breaking-changes-in-compilers-and-development-tools"></a>从<code class="literal">valgrind-devel</code>删除了开发头和静态库</h2></div></div></div><p>以前， <code class="literal">valgrind-devel</code>子包用于包含用于开发自定义valgrind工具的开发文件。此更新删除了这些文件，因为它们没有保证的API，必须静态链接，并且不受支持。<code class="literal">valgrind-devel</code>包仍然包含valgrind感知程序和头文件的开发文件，例如<code class="literal">valgrind.h</code> ， <code class="literal">callgrind.h</code> ， <code class="literal">drd.h</code> ， <code class="literal">helgrind.h</code>和<code class="literal">memcheck.h</code> ，它们是稳定且受到良好支持的。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="xen-lib_compatibility-breaking-changes-in-compilers-and-development-tools"></a>已删除32位Xen的<code class="literal">nosegneg</code>库</h2></div></div></div><p>以前， <code class="literal">glibc</code> i686软件包包含一个替代的<code class="literal">glibc</code>构建，它避免使用具有负偏移（ <code class="literal">nosegneg</code> ）的线程描述符段寄存器。此备用版本仅用于32位版本的Xen Project虚拟机管理程序，无需硬件虚拟化支持，作为优化以降低完全半虚拟化的成本。不再使用这些替代版本，它们已被删除。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="gcc-ada-go-objc_compatibility-breaking-changes-in-compilers-and-development-tools"></a> GCC不再构建Ada，Go和Objective C / C ++代码</h2></div></div></div><p>已从GCC编译器中删除了在Ada（GNAT），GCC Go和Objective C / C ++语言中构建代码的功能。
				</p><p>要构建Go代码，请改用Go Toolset。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="make-operator_compatibility-breaking-changes-in-compilers-and-development-tools"></a> <code class="literal">make</code>新的运营商<code class="literal">!=</code>导致对某些现有makefile语法的不同解释</h2></div></div></div><p>的<code class="literal">!=</code> shell赋值运算符已被添加到GNU <code class="literal">make</code>作为<code class="literal">$(shell …​)</code>函数的替代，以增加与BSD makefile的兼容性。因此，名称以感叹号结尾的变量会立即跟随<code class="literal">variable!等<code class="literal">variable!=value</code>现在被解释为shell赋值。要恢复以前的行为，请在感叹号后面添加一个空格，例如<code class="literal">variable!=value</code> 。
				</p><p>有关运算符和函数之间的更多详细信息和差异，请参阅GNU <code class="literal">make</code>手册。
				</p></div></div></div></body></html>