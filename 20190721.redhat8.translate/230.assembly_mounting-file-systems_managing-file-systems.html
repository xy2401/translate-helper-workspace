<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 挂载文件系统</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 挂载文件系统</h1></div></div></div><p>作为系统管理员，您可以在系统上安装文件系统以访问它们上的数据。
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="the-linux-mount-mechanism_assembly_mounting-file-systems"></a> Linux挂载机制</h1></div></div></div><p>本节介绍在Linux上安装文件系统的基本概念。
			</p><p>在Linux，UNIX和类似操作系统上，不同分区和可移动设备（例如CD，DVD或USB闪存驱动器）上的文件系统可以附加到目录树中的某个点（安装点），然后分离再次。在目录上安装文件系统时，无法访问目录的原始内容。
			</p><p>请注意，Linux不会阻止您将文件系统挂载到已附加文件系统的目录。
			</p><p>安装时，您可以通过以下方式识别设备：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">通用唯一标识符（UUID）：例如， <code class="literal">UUID=34795a28-ca6d-4fd8-a347-73671d0c19cb</code>
					</li><li class="listitem">卷标：例如， <code class="literal">LABEL=home</code>
					</li><li class="listitem">非持久性块设备的完整路径：例如， <code class="literal">/dev/sda3</code>
					</li></ul></div><p>使用<code class="literal">mount</code>命令挂载文件系统而没有所有必需信息（没有设备名称，目标目录或文件系统类型）时， <code class="literal">mount</code>实用程序会读取<code class="literal">/etc/fstab</code>文件的内容以检查是否给定文件系统列在那里。<code class="literal">/etc/fstab</code>文件包含设备名称列表以及设置要安装所选文件系统的目录以及文件系统类型和安装选项。因此，在挂载<code class="literal">/etc/fstab</code>指定的文件系统时，以下命令语法就足够了：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">由挂载点安装：</p><pre class="screen"># mount <span class="emphasis"><em><span class="replaceable">directory</span></em></span></pre></li><li class="listitem"><p class="simpara">通过块装置安装：</p><pre class="screen"># mount <span class="emphasis"><em><span class="replaceable">device</span></em></span></pre></li></ul></div><h3><a id="additional_resources_28"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
					</li><li class="listitem">有关如何列出持久命名属性（如UUID）的信息，请参阅<a class="xref" href="assembly_overview-of-persistent-naming-attributes_managing-file-systems.html#proc_listing-persistent-naming-attributes_assembly_overview-of-persistent-naming-attributes" title="列出持久性命名属性">“列出持久命名属性”一节</a> 。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="listing-currently-mounted-file-systems_assembly_mounting-file-systems"></a>列出当前安装的文件系统</h1></div></div></div><p>此过程描述如何在命令行上列出所有当前安装的文件系统。
			</p><h3><a id="procedure_30"></a>程序</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要列出所有已安装的文件系统，请使用<code class="literal">findmnt</code>实用程序：</p><pre class="screen">$ findmnt</pre></li><li class="listitem"><p class="simpara">要将列出的文件系统仅限制为某种文件系统类型，请添加<code class="literal">--types</code>选项：</p><pre class="screen">$ findmnt --types <span class="emphasis"><em><span class="replaceable">fs-type</span></em></span></pre><p class="simpara">例如：</p><div class="example"><a id="idm139870536962640"></a><p class="title"><strong>例9.1。仅列出XFS文件系统</strong></p><div class="example-contents"><pre class="screen">$ findmnt --types xfs

TARGET  SOURCE                                                FSTYPE OPTIONS
/       /dev/mapper/luks-5564ed00-6aac-4406-bfb4-c59bf5de48b5 xfs    rw,relatime
├─/boot /dev/sda1                                             xfs    rw,relatime
└─/home /dev/mapper/luks-9d185660-7537-414d-b727-d92ea036051e xfs    rw,relatime</pre></div></div></li></ul></div><h3><a id="additional_resources_29"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">findmnt(8)</code>手册页。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="mounting-a-file-system-with-mount_assembly_mounting-file-systems"></a>使用mount挂载文件系统</h1></div></div></div><p>此过程描述如何使用<code class="literal">mount</code>实用程序装入文件系统。
			</p><h3><a id="prerequisites_13"></a>先决条件</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">确保所选挂载点上尚未安装任何文件系统：</p><pre class="screen">$ findmnt <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre></li></ul></div><h3><a id="procedure_31"></a>程序</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">要附加某个文件系统，请使用<code class="literal">mount</code>实用程序：</p><pre class="screen"># mount <span class="emphasis"><em><span class="replaceable">device</span></em></span> <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre><div class="example"><a id="idm139870476633088"></a><p class="title"><strong>例9.2。挂载XFS文件系统</strong></p><div class="example-contents"><p>例如，要挂载由UUID标识的本地XFS文件系统：</p><pre class="screen"># mount UUID=ea74bbec-536d-490c-b8d9-5b40bbd7545b /mnt/data</pre></div></div></li><li class="listitem"><p class="simpara">如果<code class="literal">mount</code>无法自动识别文件系统类型，请使用<code class="literal">--types</code>选项指定它：</p><pre class="screen"># mount --types <span class="emphasis"><em><span class="replaceable">type</span></em></span> <span class="emphasis"><em><span class="replaceable">device</span></em></span> <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre><div class="example"><a id="idm139870476625600"></a><p class="title"><strong>例9.3。挂载NFS文件系统</strong></p><div class="example-contents"><p>例如，要挂载远程NFS文件系统：</p><pre class="screen"># mount --types nfs4 host:/remote-export /mnt/nfs</pre></div></div></li></ol></div><h3><a id="additional_resources_30"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="moving-a-mount-point_assembly_mounting-file-systems"></a>移动安装点</h1></div></div></div><p>此过程描述如何将已安装的文件系统的安装点更改为其他目录。
			</p><h3><a id="procedure_32"></a>程序</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">要更改装入文件系统的目录：</p><pre class="screen"># mount --move <span class="emphasis"><em><span class="replaceable">old-directory</span></em></span> <span class="emphasis"><em><span class="replaceable">new-directory</span></em></span></pre><div class="example"><a id="idm139870476612416"></a><p class="title"><strong>例9.4。移动主文件系统</strong></p><div class="example-contents"><p>例如，要将安装在<code class="literal">/mnt/userdirs/</code>目录中的文件系统移动到<code class="literal">/home/</code> mount点：</p><pre class="screen"># mount --move /mnt/userdirs /home</pre></div></div></li><li class="listitem"><p class="simpara">验证文件系统是否已按预期移动：</p><pre class="screen">$ findmnt
$ ls <span class="emphasis"><em><span class="replaceable">old-directory</span></em></span>
$ ls <span class="emphasis"><em><span class="replaceable">new-directory</span></em></span></pre></li></ol></div><h3><a id="additional_resources_31"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="unmounting-a-file-system-with-umount_assembly_mounting-file-systems"></a>使用umount卸载文件系统</h1></div></div></div><p>此过程描述如何使用<code class="literal">umount</code>实用程序卸载文件系统。
			</p><h3><a id="procedure_33"></a>程序</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">尝试使用以下任一命令卸载文件系统：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">按挂载点：</p><pre class="screen"># umount <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre></li><li class="listitem"><p class="simpara">按设备：</p><pre class="screen"># umount <span class="emphasis"><em><span class="replaceable">device</span></em></span></pre></li></ul></div><p class="simpara">如果命令失败并出现类似于以下内容的错误，则表示文件系统正在使用中，因为进程正在使用其上的资源：</p><pre class="screen">umount: <span class="emphasis"><em><span class="replaceable">/run/media/user/FlashDrive</span></em></span>: target is busy.</pre></li><li class="listitem"><p class="simpara">如果正在使用文件系统，请使用<code class="literal">fuser</code>实用程序确定正在访问它的进程。例如：</p><pre class="screen">$ fuser --mount <span class="emphasis"><em><span class="replaceable">/run/media/user/FlashDrive</span></em></span>

<span class="emphasis"><em><span class="replaceable">/run/media/user/FlashDrive</span></em></span>: <span class="emphasis"><em><span class="replaceable">18351</span></em></span></pre><p class="simpara">然后，使用文件系统终止进程并尝试再次卸载它。
					</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="common-mount-options_assembly_mounting-file-systems"></a>常见的挂载选项</h1></div></div></div><p>本节列出了<code class="literal">mount</code>实用程序的一些常用选项。
			</p><p>您可以使用以下语法中的这些选项：</p><pre class="screen"># mount --options <span class="emphasis"><em><span class="replaceable">option1,option2,option3</span></em></span> <span class="emphasis"><em><span class="replaceable">device</span></em></span> <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre><div class="table"><a id="idm139870465767344"></a><p class="title"><strong>表9.1。常见的挂载选项</strong></p><div class="table-contents"><table border="1" summary="Common mount options"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">异步</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>在文件系统上启用异步输入和输出操作。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">汽车</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>允许使用<code class="literal">mount -a</code>命令自动<code class="literal">mount -a</code>文件系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">默认</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>为<code class="literal">async,auto,dev,exec,nouser,rw,suid</code>选项提供别名。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">EXEC</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>允许在特定文件系统上执行二进制文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">环</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>将图像安装为循环设备。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">NOAUTO</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>默认行为使用<code class="literal">mount -a</code>命令禁用文件系统的自动装入。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">NOEXEC</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>不允许在特定文件系统上执行二进制文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">nouser</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>禁止普通用户（即root用户除外）挂载和卸载文件系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">再登</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>重新安装文件系统，以防它已安装。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">RO</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>安装文件系统以进行只读。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">RW</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>安装文件系统以进行读写。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">用户</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>允许普通用户（即root用户除外）挂载和卸载文件系统。
							</p>
							 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="sharing-a-mount-on-multiple-mount-points_assembly_mounting-file-systems"></a>在多个挂载点上共享挂载</h1></div></div></div><p>作为系统管理员，您可以复制装入点以使文件系统可从多个目录访问。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="types-of-shared-mounts_sharing-a-mount-on-multiple-mount-points"></a>共享安装的类型</h2></div></div></div><p>您可以使用多种类型的共享安装。它们之间的区别是当您在其中一个共享挂载点下挂载另一个文件系统时会发生的情况。共享安装是使用<span class="emphasis"><em>共享子树</em></span>功能实现的。
				</p><p>类型是：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">私人山</span></dt><dd><p class="simpara">此类型不接收或转发任何传播事件。
							</p><p class="simpara">在副本或原始安装点下安装另一个文件系统时，它不会反映在另一个文件系统中。
							</p></dd><dt><span class="term">共享安装</span></dt><dd><p class="simpara">此类型创建给定安装点的精确副本。
							</p><p class="simpara">当挂载点标记为共享挂载时，原始挂载点中的任何挂载都会反映在其中，反之亦然。
							</p><p class="simpara">这是根文件系统的默认安装类型。
							</p></dd><dt><span class="term">奴隶坐骑</span></dt><dd><p class="simpara">此类型创建给定安装点的有限副本。
							</p><p class="simpara">当安装点标记为从属安装时，原始安装点内的任何安装都会反映在其中，但从属安装中的安装不会反映在其原始安装中。
							</p></dd><dt><span class="term">不可绑定的安装</span></dt><dd>此类型可防止给定的挂载点被复制。
							</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-a-private-mount-point-duplicate_sharing-a-mount-on-multiple-mount-points"></a>创建专用安装点副本</h2></div></div></div><p>此过程将挂载点复制为专用挂载。稍后在副本或原始安装点下安装的文件系统不会反映在另一个文件系统中。
				</p><h4><a id="procedure_34"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从原始安装点创建虚拟文件系统（VFS）节点：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre></li><li class="listitem"><p class="simpara">将原始挂载点标记为私有：</p><pre class="screen"># mount --make-private <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre><p class="simpara">或者，要更改所选安装点的安装类型以及其下的所有安装点，请使用<code class="literal">--make-rprivate</code>选项而不是<code class="literal">--make-private</code> 。
						</p></li><li class="listitem"><p class="simpara">创建副本：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">duplicate-dir</span></em></span></pre></li></ol></div><div class="example"><a id="idm139870589314704"></a><p class="title"><strong>例9.5。将/ mnt复制/媒体作为私有安装点</strong></p><div class="example-contents"><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从<code class="literal">/media</code>目录创建VFS节点：</p><pre class="screen"># mount --bind /media /media</pre></li><li class="listitem"><p class="simpara">将<code class="literal">/media</code>目录标记为私有：</p><pre class="screen"># mount --make-private /media</pre></li><li class="listitem"><p class="simpara">在<code class="literal">/mnt</code>创建副本：</p><pre class="screen"># mount --bind /media /mnt</pre></li><li class="listitem"><p class="simpara">现在可以验证<code class="literal">/media</code>和<code class="literal">/mnt</code>共享内容，但<code class="literal">/media</code>没有任何挂载出现在<code class="literal">/mnt</code> 。例如，如果CD-ROM驱动器包含非空介质并且<code class="literal">/media/cdrom/</code>目录存在，请使用：</p><pre class="screen"># mount /dev/cdrom /media/cdrom
# ls /media/cdrom
EFI  GPL  isolinux  LiveOS
# ls /mnt/cdrom
#</pre></li><li class="listitem"><p class="simpara">还可以验证安装在<code class="literal">/mnt</code>目录中的文件系统是否未反映在<code class="literal">/media</code> 。例如，如果插入了使用<code class="literal">/dev/sdc1</code>设备的非空USB闪存驱动器并且存在<code class="literal">/mnt/flashdisk/</code>目录，请使用：</p><pre class="screen"># mount /dev/sdc1 /mnt/flashdisk
# ls /media/flashdisk
# ls /mnt/flashdisk
en-US  publican.cfg</pre></li></ol></div></div></div><h4><a id="additional_resources_32"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-a-shared-mount-point-duplicate_sharing-a-mount-on-multiple-mount-points"></a>创建共享安装点重复</h2></div></div></div><p>此过程将挂载点复制为共享挂载。稍后在原始目录下安装的文件系统或副本始终反映在另一个文件系统中。
				</p><h4><a id="procedure_35"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从原始安装点创建虚拟文件系统（VFS）节点：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre></li><li class="listitem"><p class="simpara">将原始挂载点标记为共享：</p><pre class="screen"># mount --make-shared <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre><p class="simpara">或者，要更改所选安装点的安装类型以及其下的所有安装点，请使用<code class="literal">--make-rshared</code>选项而不是<code class="literal">--make-shared</code> 。
						</p></li><li class="listitem"><p class="simpara">创建副本：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">duplicate-dir</span></em></span></pre></li></ol></div><div class="example"><a id="idm139870478130240"></a><p class="title"><strong>例9.6。将/ mnt复制/媒体作为共享挂载点</strong></p><div class="example-contents"><p>要使<code class="literal">/media</code>和<code class="literal">/mnt</code>目录共享相同的内容：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从<code class="literal">/media</code>目录创建VFS节点：</p><pre class="screen"># mount --bind /media /media</pre></li><li class="listitem"><p class="simpara">将<code class="literal">/media</code>目录标记为共享：</p><pre class="screen"># mount --make-shared /media</pre></li><li class="listitem"><p class="simpara">在<code class="literal">/mnt</code>创建副本：</p><pre class="screen"># mount --bind /media /mnt</pre></li><li class="listitem"><p class="simpara">现在可以验证<code class="literal">/media</code>中的安装是否也出现在<code class="literal">/mnt</code> 。例如，如果CD-ROM驱动器包含非空介质并且<code class="literal">/media/cdrom/</code>目录存在，请使用：</p><pre class="screen"># mount /dev/cdrom /media/cdrom
# ls /media/cdrom
EFI  GPL  isolinux  LiveOS
# ls /mnt/cdrom
EFI  GPL  isolinux  LiveOS</pre></li><li class="listitem"><p class="simpara">同样，可以验证安装在<code class="literal">/mnt</code>目录中的任何文件系统是否都反映在<code class="literal">/media</code> 。例如，如果插入了使用<code class="literal">/dev/sdc1</code>设备的非空USB闪存驱动器并且存在<code class="literal">/mnt/flashdisk/</code>目录，请使用：</p><pre class="screen"># mount /dev/sdc1 /mnt/flashdisk
# ls /media/flashdisk
en-US  publican.cfg
# ls /mnt/flashdisk
en-US  publican.cfg</pre></li></ol></div></div></div><h4><a id="additional_resources_33"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-a-slave-mount-point-duplicate_sharing-a-mount-on-multiple-mount-points"></a>创建从属安装点重复</h2></div></div></div><p>此过程将安装点复制为从属安装。稍后在原始安装点下安装的文件系统将反映在副本中，而不是反过来。
				</p><h4><a id="procedure_36"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从原始安装点创建虚拟文件系统（VFS）节点：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre></li><li class="listitem"><p class="simpara">将原始挂载点标记为共享：</p><pre class="screen"># mount --make-shared <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span></pre><p class="simpara">或者，要更改所选安装点的安装类型以及其下的所有安装点，请使用<code class="literal">--make-rshared</code>选项而不是<code class="literal">--make-shared</code> 。
						</p></li><li class="listitem"><p class="simpara">创建副本并将其标记为slave：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">original-dir</span></em></span> <span class="emphasis"><em><span class="replaceable">duplicate-dir</span></em></span>
# mount --make-slave <span class="emphasis"><em><span class="replaceable">duplicate-dir</span></em></span></pre></li></ol></div><div class="example"><a id="idm139870590377104"></a><p class="title"><strong>例9.7。将/ mnt复制/介入作为从属安装点</strong></p><div class="example-contents"><p>此示例显示如何使<code class="literal">/media</code>目录的内容也出现在<code class="literal">/mnt</code>中，但<code class="literal">/mnt</code>目录中没有任何挂载要反映在<code class="literal">/media</code> 。
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">从<code class="literal">/media</code>目录创建VFS节点：</p><pre class="screen"># mount --bind /media /media</pre></li><li class="listitem"><p class="simpara">将<code class="literal">/media</code>目录标记为共享：</p><pre class="screen"># mount --make-shared /media</pre></li><li class="listitem"><p class="simpara">在<code class="literal">/mnt</code>创建副本并将其标记为slave：</p><pre class="screen"># mount --bind /media /mnt
# mount --make-slave /mnt</pre></li><li class="listitem"><p class="simpara">验证<code class="literal">/media</code>中的安装是否也出现在<code class="literal">/mnt</code> 。例如，如果CD-ROM驱动器包含非空介质并且<code class="literal">/media/cdrom/</code>目录存在，请使用：</p><pre class="screen"># mount /dev/cdrom /media/cdrom
# ls /media/cdrom
EFI  GPL  isolinux  LiveOS
# ls /mnt/cdrom
EFI  GPL  isolinux  LiveOS</pre></li><li class="listitem"><p class="simpara">还要验证安装在<code class="literal">/mnt</code>目录中的文件系统是否未反映在<code class="literal">/media</code> 。例如，如果插入了使用<code class="literal">/dev/sdc1</code>设备的非空USB闪存驱动器并且存在<code class="literal">/mnt/flashdisk/</code>目录，请使用：</p><pre class="screen"># mount /dev/sdc1 /mnt/flashdisk
# ls /media/flashdisk
# ls /mnt/flashdisk
en-US  publican.cfg</pre></li></ol></div></div></div><h4><a id="additional_resources_34"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="preventing-a-mount-point-from-being-duplicated_sharing-a-mount-on-multiple-mount-points"></a>防止挂载点被复制</h2></div></div></div><p>此过程将安装点标记为不可绑定，因此无法在另一个安装点复制它。
				</p><h4><a id="procedure_37"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要将安装点的类型更改为不可绑定的安装，请使用：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span> <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span>
# mount --make-unbindable <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre><p class="simpara">或者，要更改所选安装点的安装类型以及其下的所有安装点，请使用<code class="literal">--make-runbindable</code>选项而不是<code class="literal">--make-unbindable</code> 。
						</p><p class="simpara">任何后续尝试复制此挂载都会失败，并显示以下错误：</p><pre class="screen"># mount --bind <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span> <span class="emphasis"><em><span class="replaceable">duplicate-dir</span></em></span>

mount: wrong fs type, bad option, bad superblock on <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span>,
missing codepage or helper program, or other error
In some cases useful info is found in syslog - try
dmesg | tail  or so</pre></li></ul></div><div class="example"><a id="idm139870473512256"></a><p class="title"><strong>例9.8。防止/媒体被复制</strong></p><div class="example-contents"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要阻止共享<code class="literal">/media</code>目录，请使用：</p><pre class="screen"># mount --bind /media /media
# mount --make-unbindable /media</pre></li></ul></div></div></div><h4><a id="additional_resources_35"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mount(8)</code>手册页。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="related-information-sharing-a-mount-on-multiple-mount-points"></a>相关信息</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Linux Weekly News上的<span class="emphasis"><em>共享子树</em></span>文章： <a class="link" href="https://lwn.net/Articles/159077/">https</a> ： <a class="link" href="https://lwn.net/Articles/159077/">//lwn.net/Articles/159077/</a> 。</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="assembly_persistently-mounting-file-systems_assembly_mounting-file-systems"></a>持久安装文件系统</h1></div></div></div><p>作为系统管理员，您可以持久安装文件系统以配置不可移动存储。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="con_the-etc-fstab-file_assembly_persistently-mounting-file-systems"></a> / etc / fstab文件</h2></div></div></div><p>本节介绍<code class="literal">/etc/fstab</code>配置文件，该文件控制文件系统的持久性挂载点。使用<code class="literal">/etc/fstab</code>是持久安装文件系统的推荐方法。
				</p><p><code class="literal">/etc/fstab</code>文件中的每一行都定义了文件系统的安装点。它包括由空格分隔的六个字段：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">块设备由持久属性标识或路径为<code class="literal">/dev</code>目录。
						</li><li class="listitem">设备将挂载的目录。
						</li><li class="listitem">设备上的文件系统。
						</li><li class="listitem">挂载文件系统的选项。选项<code class="literal">defaults</code>表示分区是在引导时使用默认选项安装的。本节还识别<code class="literal">x-systemd. <span class="emphasis"><em><span class="replaceable">option</span></em></span></code>中的<code class="literal">systemd</code>安装单元选项<code class="literal">x-systemd. <span class="emphasis"><em><span class="replaceable">option</span></em></span></code>格式。
						</li><li class="listitem"><code class="literal">dump</code>实用程序的备份选项。
						</li><li class="listitem">检查<code class="literal">fsck</code>实用程序的顺序。
						</li></ol></div><div class="example"><a id="idm139870477352560"></a><p class="title"><strong>例9.9。<code class="literal">/etc/fstab</code>的<code class="literal">/boot</code>文件系统</strong></p><div class="example-contents"><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"><col class="col_6"></colgroup><thead><tr><th valign="top" style="text-align:left">块设备</th><th valign="top" style="text-align:left">装点</th><th valign="top" style="text-align:left">文件系统</th><th valign="top" style="text-align:left">选项</th><th valign="top" style="text-align:left">备用</th><th valign="top" style="text-align:left">校验</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
										<code class="literal">UUID = ea74bbec-536d-490C-b8d9-5b40bbd7545b</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">/启动</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">XFS</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">默认</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">0</code>
									</p>
									 </td><td valign="top" style="text-align:left"> <p>
										<code class="literal">0</code>
									</p>
									 </td></tr></tbody></table></div></div></div><p><code class="literal">systemd</code>服务自动从<code class="literal">/etc/fstab</code>条目生成装载单元。
				</p><h4><a id="additional_resources_36"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">fstab(5)</code>手册页。
						</li><li class="listitem"><code class="literal">systemd.mount(5)</code>手册页的<span class="emphasis"><em>fstab</em></span>部分。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="adding-a-file-system-to-etc-fstab_assembly_persistently-mounting-file-systems"></a>将文件系统添加到/ etc / fstab</h2></div></div></div><p>此过程描述如何在<code class="literal">/etc/fstab</code>配置文件中为文件系统配置持久性挂载点。
				</p><h4><a id="procedure_38"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">找出文件系统的UUID属性：</p><pre class="screen">$ lsblk --fs <span class="emphasis"><em><span class="replaceable">storage-device</span></em></span></pre><p class="simpara">例如：</p><div class="example"><a id="idm139870576246400"></a><p class="title"><strong>例9.10。查看分区的UUID</strong></p><div class="example-contents"><pre class="screen">$ lsblk --fs <span class="emphasis"><em><span class="replaceable">/dev/sda1</span></em></span>

NAME FSTYPE LABEL <span class="strong"><strong>UUID</strong></span>                                 MOUNTPOINT
sda1 xfs    Boot  <span class="strong"><strong>ea74bbec-536d-490c-b8d9-5b40bbd7545b</strong></span> /boot</pre></div></div></li><li class="listitem"><p class="simpara">如果挂载点目录不存在，请创建它：</p><pre class="screen"># mkdir --parents <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre></li><li class="listitem"><p class="simpara">以root用户身份编辑<code class="literal">/etc/fstab</code>文件，并为UUID标识的文件系统添加一行。</p><p class="simpara">例如：</p><div class="example"><a id="idm139870576237872"></a><p class="title"><strong>例9.11。/ etc / fstab中的/ boot挂载点</strong></p><div class="example-contents"><pre class="screen">UUID=ea74bbec-536d-490c-b8d9-5b40bbd7545b /boot xfs defaults 0 0</pre></div></div></li><li class="listitem"><p class="simpara">重新生成装载单元，以便系统注册新配置：</p><pre class="screen"># systemctl daemon-reload</pre></li><li class="listitem"><p class="simpara">尝试安装文件系统以验证配置是否有效：</p><pre class="screen"># mount <span class="emphasis"><em><span class="replaceable">mount-point</span></em></span></pre></li></ol></div><h4><a id="additional_resources_37"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">可用于标识文件系统的其他持久属性： <a class="xref" href="assembly_overview-of-persistent-naming-attributes_managing-file-systems.html#con_device-names-managed-by-the-udev-mechanism-in-dev-disk-_assembly_overview-of-persistent-naming-attributes" title="由/ dev / disk /中的udev机制管理的设备名称">“/ dev / disk /中由udev机制管理的设备名称”一节</a>
						</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="assembly_mounting-file-systems-on-demand_assembly_mounting-file-systems"></a>按需安装文件系统</h1></div></div></div><p>作为系统管理员，您可以配置文件系统（如NFS）以按需自动装入。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="the-autofs-service_assembly_mounting-file-systems-on-demand"></a> autofs服务</h2></div></div></div><p>本节介绍<code class="literal">autofs</code>服务的优点和基本概念，用于按需安装文件系统。
				</p><p>使用<code class="literal">/etc/fstab</code>配置进行永久安装的一个缺点是，无论用户如何不经常访问已安装的文件系统，系统都必须专用资源来保持已安装的文件系统。例如，当系统一次维护NFS挂载到许多系统时，这可能会影响系统性能。
				</p><p><code class="literal">/etc/fstab</code>的替代方法是使用基于内核的<code class="literal">autofs</code>服务。它由以下组件组成：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">实现文件系统的内核模块，和</li><li class="listitem">用户空间服务，执行所有其他功能。
						</li></ul></div><p><code class="literal">autofs</code>服务可以自动（按需）安装和卸载文件系统，从而节省系统资源。它可用于安装文件系统，如NFS，AFS，SMBFS，CIFS和本地文件系统。
				</p><h4><a id="additional_resources_38"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">autofs(8)</code>手册页。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="the-autofs-configuration-files_assembly_mounting-file-systems-on-demand"></a> autofs配置文件</h2></div></div></div><p>本节介绍<code class="literal">autofs</code>服务使用的配置文件的用法和语法。
				</p><h4><a id="the_master_map_file"></a>主映射文件</h4><p><code class="literal">autofs</code>服务使用<code class="literal">/etc/auto.master</code> （主映射）作为其默认主配置文件。可以使用<code class="literal">/etc/autofs.conf</code>配置文件中的<code class="literal">autofs</code>配置以及名称服务交换机（NSS）机制将其更改为使用其他受支持的网络源和名称。
				</p><p>必须在主映射中配置所有按需安装点。挂载点，主机名，导出的目录和选项都可以在一组文件（或其他受支持的网络源）中指定，而不是为每个主机手动配置它们。
				</p><p>主映射文件列出由<code class="literal">autofs</code>控制的挂载点及其相应的配置文件或称为automount映射的网络源。主地图的格式如下：</p><pre class="screen"><span class="emphasis"><em><span class="replaceable">mount-point</span></em></span>  <span class="emphasis"><em><span class="replaceable">map-name</span></em></span>  <span class="emphasis"><em><span class="replaceable">options</span></em></span></pre><p>这种格式使用的变量是：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="emphasis"><em><span class="replaceable">挂载点</span></em></span></span></dt><dd><code class="literal">autofs</code>挂载点;例如， <code class="literal">/mnt/data/</code> 。
							</dd><dt><span class="term"><span class="emphasis"><em><span class="replaceable">映射文件</span></em></span></span></dt><dd>映射源文件，其中包含挂载点列表以及应从中挂载这些挂载点的文件系统位置。
							</dd><dt><span class="term"><span class="emphasis"><em><span class="replaceable">选项</span></em></span></span></dt><dd>如果提供，这些适用于给定地图中的所有条目，如果它们本身没有指定选项。
							</dd></dl></div><div class="example"><a id="idm139870578880928"></a><p class="title"><strong>例9.12。/etc/auto.master文件</strong></p><div class="example-contents"><p>以下是<code class="literal">/etc/auto.master</code>文件中的示例行：</p><pre class="screen">/mnt/data  /etc/auto.data</pre></div></div><h4><a id="map_files"></a>映射文件</h4><p>映射文件配置各个按需装入点的属性。
				</p><p>如果目录不存在，自动挂载程序将创建目录。如果在自动挂载程序启动之前存在目录，则自动挂载程序在退出时不会删除它们。如果指定了超时，则在超时期限内未访问目录时，将自动卸载该目录。
				</p><p>地图的一般格式类似于主地图。但是，选项字段显示在装入点和位置之间，而不是在主映射中的条目末尾：</p><pre class="screen"><span class="emphasis"><em><span class="replaceable">mount-point</span></em></span>  <span class="emphasis"><em><span class="replaceable">options</span></em></span>  <span class="emphasis"><em><span class="replaceable">location</span></em></span></pre><p>这种格式使用的变量是：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="emphasis"><em><span class="replaceable">挂载点</span></em></span></span></dt><dd>这是指<code class="literal">autofs</code>挂载点。这可以是间接装载的单个目录名称，也可以是直接装载的装入点的完整路径。每个直接和间接映射条目键（ <span class="emphasis"><em><span class="replaceable">挂载点</span></em></span> ）后面都可以跟一个空格分隔的偏移目录列表（每个以<code class="literal">/</code>开头的子目录名称），使它们成为所谓的多挂载条目。
							</dd><dt><span class="term"><span class="emphasis"><em><span class="replaceable">选项</span></em></span></span></dt><dd>提供时，这些是未指定自己选项的映射条目的装入选项。该字段是可选的。
							</dd><dt><span class="term"><span class="emphasis"><em><span class="replaceable">地点</span></em></span></span></dt><dd>这指的是文件系统位置，例如本地文件系统路径（以Sun映射格式转义字符开头<code class="literal">:</code>对于以<code class="literal">/</code>开头的映射名称），NFS文件系统或其他有效文件系统位置。
							</dd></dl></div><div class="example"><a id="idm139870468458096"></a><p class="title"><strong>例9.13。地图文件</strong></p><div class="example-contents"><p>以下是地图文件中的示例;例如，/ <code class="literal">/etc/auto.misc</code> ：</p><pre class="screen">payroll  -fstype=nfs4  personnel:/dev/disk/by-uuid/52b94495-e106-4f29-b868-fe6f6c2789b1
sales    -fstype=xfs   :/dev/disk/by-uuid/5564ed00-6aac-4406-bfb4-c59bf5de48b5</pre><p>映射文件中的第一列表示<code class="literal">autofs</code>挂载点：来自名为<code class="literal">personnel</code>的服务器的<code class="literal">sales</code>和<code class="literal">payroll</code> 。第二列指示<code class="literal">autofs</code>安装的选项。第三列表示安装的来源。
					</p><p>按照给定的配置， <code class="literal">autofs</code>挂载点将是<code class="literal">/home/payroll</code>和<code class="literal">/home/sales</code> 。<code class="literal">-fstype=</code>选项通常被省略，通常不需要正确的操作。
					</p><p>使用给定的配置，如果进程需要访问<code class="literal">autofs</code>未安装的目录，例如<code class="literal">/home/payroll/2006/July.sxc</code> ，则<code class="literal">autofs</code>服务会自动安装目录。
					</p></div></div><h4><a id="the_amd_map_format"></a> amd地图格式</h4><p><code class="literal">autofs</code>服务也以<code class="literal">amd</code>格式识别地图配置。如果要重用为<code class="literal">am-utils</code>服务编写的现有自动挂载程序配置（已从Red Hat Enterprise Linux中删除），这将非常有用。
				</p><p>但是，Red Hat建议使用前面部分中描述的更简单的<code class="literal">autofs</code>格式。
				</p><h4><a id="additional_resources_39"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">autofs(5)</code> ， <code class="literal">autofs.conf(5)</code>和<code class="literal">auto.master(5)</code>手册页。
						</li><li class="listitem">有关<code class="literal">amd</code>映射格式的详细信息，请参阅<code class="literal">autofs</code>软件包提供的<code class="literal">/usr/share/doc/autofs/README.amd-maps</code>文件。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-autofs-mount-points_assembly_mounting-file-systems-on-demand"></a>配置autofs挂载点</h2></div></div></div><p>此过程描述如何使用<code class="literal">autofs</code>服务配置按需装入点。
				</p><h4><a id="prerequisites_14"></a>先决条件</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">安装<code class="literal">autofs</code>包：</p><pre class="screen"># yum install autofs</pre></li><li class="listitem"><p class="simpara">启动并启用<code class="literal">autofs</code>服务：</p><pre class="screen"># systemctl enable --now autofs</pre></li></ul></div><h4><a id="procedure_39"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem">为按需安装点创建一个映射文件，位于<code class="literal">/etc/auto. <span class="emphasis"><em><span class="replaceable">identifier</span></em></span></code> 。使用<span class="emphasis"><em><span class="replaceable">标识</span></em></span>安装点的名称替换<span class="emphasis"><em><span class="replaceable">标识符</span></em></span> 。
						</li><li class="listitem">在映射文件中，按照<a class="xref" href="assembly_mounting-file-systems_managing-file-systems.html#the-autofs-configuration-files_assembly_mounting-file-systems-on-demand" title="autofs配置文件">“autofs配置文件”一节</a>中的说明填写安装点，选项和位置字段。
						</li><li class="listitem">在主映射文件中注册映射文件，如<a class="xref" href="assembly_mounting-file-systems_managing-file-systems.html#the-autofs-configuration-files_assembly_mounting-file-systems-on-demand" title="The autofs configuration files">“autofs配置文件”一节</a>中<a class="xref" href="assembly_mounting-file-systems_managing-file-systems.html#the-autofs-configuration-files_assembly_mounting-file-systems-on-demand" title="autofs配置文件">所述</a> 。
						</li><li class="listitem"><p class="simpara">尝试访问按需目录中的内容：</p><pre class="screen">$ ls <span class="emphasis"><em><span class="replaceable">automounted-directory</span></em></span></pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="overriding-or-augmenting-autofs-site-configuration-files_assembly_mounting-file-systems-on-demand"></a>覆盖或扩充autofs站点配置文件</h2></div></div></div><p>在客户端系统上覆盖特定安装点的站点默认值有时很有用。
				</p><div class="example"><a id="idm139870567139200"></a><p class="title"><strong>例9.14。初始状态</strong></p><div class="example-contents"><p>例如，请考虑以下条件：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">自动挂载程序映射存储在NIS中，而<code class="literal">/etc/nsswitch.conf</code>文件具有以下指令：</p><pre class="screen">automount:    files nis</pre></li><li class="listitem"><p class="simpara"><code class="literal">auto.master</code>文件包含：</p><pre class="screen">+auto.master</pre></li><li class="listitem"><p class="simpara">NIS <code class="literal">auto.master</code>映射文件包含：</p><pre class="screen">/home auto.home</pre></li><li class="listitem"><p class="simpara">NIS <code class="literal">auto.home</code>映射包含：</p><pre class="screen">beth    fileserver.example.com:/export/home/beth
joe     fileserver.example.com:/export/home/joe
*       fileserver.example.com:/export/home/&amp;</pre></li><li class="listitem">文件映射<code class="literal">/etc/auto.home</code>不存在。
							</li></ul></div></div></div><h4><a id="procedure_40"></a>程序</h4><div class="example"><a id="idm139870567125728"></a><p class="title"><strong>例9.15。从其他服务器安装主目录</strong></p><div class="example-contents"><p>鉴于上述条件，我们假设客户端系统需要覆盖NIS映射<code class="literal">auto.home</code>并从其他服务器挂载主目录。
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">在这种情况下，客户端需要使用以下<code class="literal">/etc/auto.master</code>映射：</p><pre class="screen">/home ­/etc/auto.home
+auto.master</pre></li><li class="listitem"><p class="simpara"><code class="literal">/etc/auto.home</code>映射包含以下条目：</p><pre class="screen">*    labserver.example.com:/export/home/&amp;</pre></li></ul></div><p>由于自动挂载程序仅处理第一次出现的挂载点，因此<code class="literal">/home</code>目录包含<code class="literal">/etc/auto.home</code>的内容，而不是NIS <code class="literal">auto.home</code>映射。
					</p></div></div><div class="example"><a id="idm139870590083984"></a><p class="title"><strong>例9.16。仅使用选定的条目扩充auto.home</strong></p><div class="example-contents"><p>或者，仅使用几个条目来扩充站点范围的<code class="literal">auto.home</code>映射：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">创建一个<code class="literal">/etc/auto.home</code>文件映射，并在其中放入新条目。最后，包括NIS <code class="literal">auto.home</code>地图。然后<code class="literal">/etc/auto.home</code>文件映射看起来类似于：</p><pre class="screen">mydir someserver:/export/mydir
+auto.home</pre></li><li class="listitem"><p class="simpara">使用这些NIS <code class="literal">auto.home</code>映射条件，列出<code class="literal">/home</code>目录输出的内容：</p><pre class="screen">$ ls /home

beth joe mydir</pre></li></ol></div><p>最后一个示例按预期工作，因为<code class="literal">autofs</code>不包含与正在读取的文件映射名称相同的文件映射的内容。因此， <code class="literal">autofs</code>移动到<code class="literal">nsswitch</code>配置中的下一个映射源。
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using-ldap-to-store-automounter-maps_assembly_mounting-file-systems-on-demand"></a>使用LDAP存储自动挂载程序映射</h2></div></div></div><p>此过程将<code class="literal">autofs</code>配置为在LDAP配置中而不是在<code class="literal">autofs</code>映射文件中存储自动挂载程序映射。
				</p><h4><a id="prerequisites_15"></a>先决条件</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">必须在配置为从LDAP检索自动挂载程序映射的所有系统上安装LDAP客户端库。在Red Hat Enterprise Linux上，应该自动安装<code class="literal">openldap</code>软件包作为<code class="literal">autofs</code>软件包的依赖项。
						</li></ul></div><h4><a id="procedure_41"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem">要配置LDAP访问，请修改<code class="literal">/etc/openldap/ldap.conf</code>文件。确保为您的站点正确设置了<code class="literal">BASE</code> ， <code class="literal">URI</code>和<code class="literal">schema</code>选项。
						</li><li class="listitem"><p class="simpara"><code class="literal">rfc2307bis</code>草案描述了最近建立的用于在LDAP中存储自动挂载映射的模式。要使用此模式，请通过从架构定义中删除注释字符在<code class="literal">/etc/autofs.conf</code>配置文件中进行设置。例如：</p><div class="example"><a id="idm139870590056864"></a><p class="title"><strong>例9.17。设置autofs配置</strong></p><div class="example-contents"><pre class="screen">DEFAULT_MAP_OBJECT_CLASS="automountMap"
DEFAULT_ENTRY_OBJECT_CLASS="automount"
DEFAULT_MAP_ATTRIBUTE="automountMapName"
DEFAULT_ENTRY_ATTRIBUTE="automountKey"
DEFAULT_VALUE_ATTRIBUTE="automountInformation"</pre></div></div></li><li class="listitem"><p class="simpara">确保在配置中注释所有其他模式条目。<code class="literal">automountKey</code>属性替换<code class="literal">rfc2307bis</code>架构中的<code class="literal">cn</code>属性。以下是LDAP数据交换格式（LDIF）配置的示例：</p><div class="example"><a id="idm139870590052752"></a><p class="title"><strong>例9.18。LDF配置</strong></p><div class="example-contents"><pre class="screen"># extended LDIF
#
# LDAPv3
# base &lt;&gt; with scope subtree
# filter: (&amp;(objectclass=automountMap)(automountMapName=auto.master))
# requesting: ALL
#

# auto.master, example.com
dn: automountMapName=auto.master,dc=example,dc=com
objectClass: top
objectClass: automountMap
automountMapName: auto.master

# extended LDIF
#
# LDAPv3
# base &lt;automountMapName=auto.master,dc=example,dc=com&gt; with scope subtree
# filter: (objectclass=automount)
# requesting: ALL
#

# /home, auto.master, example.com
dn: automountMapName=auto.master,dc=example,dc=com
objectClass: automount
cn: /home

automountKey: /home
automountInformation: auto.home

# extended LDIF
#
# LDAPv3
# base &lt;&gt; with scope subtree
# filter: (&amp;(objectclass=automountMap)(automountMapName=auto.home))
# requesting: ALL
#

# auto.home, example.com
dn: automountMapName=auto.home,dc=example,dc=com
objectClass: automountMap
automountMapName: auto.home

# extended LDIF
#
# LDAPv3
# base &lt;automountMapName=auto.home,dc=example,dc=com&gt; with scope subtree
# filter: (objectclass=automount)
# requesting: ALL
#

# foo, auto.home, example.com
dn: automountKey=foo,automountMapName=auto.home,dc=example,dc=com
objectClass: automount
automountKey: foo
automountInformation: filer.example.com:/export/foo

# /, auto.home, example.com
dn: automountKey=/,automountMapName=auto.home,dc=example,dc=com
objectClass: automount
automountKey: /
automountInformation: filer.example.com:/export/&amp;</pre></div></div></li></ol></div><h4><a id="additional_resources_40"></a>其他资源</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">rfc2307bis</code>草案： <a class="link" href="https://tools.ietf.org/html/draft-howard-rfc2307bis">https</a> ： <code class="literal">rfc2307bis</code> 。</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="setting-read-only-permissions-for-the-root-file-system_assembly_mounting-file-systems"></a>设置根文件系统的只读权限</h1></div></div></div><p>有时，您需要使用只读权限挂载根文件系统（ <code class="literal">/</code> ）。示例用例包括在意外的系统断电后增强安全性或确保数据完整性。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="files-and-directories-that-always-retain-write-permissions_setting-read-only-permissions-for-the-root-file-system"></a>始终保留写入权限的文件和目录</h2></div></div></div><p>为使系统正常运行，某些文件和目录需要保留写入权限。当根文件系统以只读模式挂载时，这些文件使用<code class="literal">tmpfs</code>临时文件系统挂载到RAM中。
				</p><p>从<code class="literal">/etc/rwtab</code>文件中读取默认的此类文件和目录集，其中包含：</p><pre class="screen">dirs	/var/cache/man
dirs	/var/gdm
<span class="emphasis"><em>&lt;content truncated&gt;</em></span>

empty	/tmp
empty	/var/cache/foomatic
<span class="emphasis"><em>&lt;content truncated&gt;</em></span>

files	/etc/adjtime
files	/etc/ntp.conf
<span class="emphasis"><em>&lt;content truncated&gt;</em></span></pre><p><code class="literal">/etc/rwtab</code>文件中的条目遵循以下格式：</p><pre class="screen"><span class="emphasis"><em><span class="replaceable">copy-method</span></em></span>    <span class="emphasis"><em><span class="replaceable">path</span></em></span></pre><p>在这个语法中：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">将<span class="emphasis"><em><span class="replaceable">copy-method</span></em></span>替换为指定文件或目录如何复制到tmpfs的关键字之一。
						</li><li class="listitem">将<span class="emphasis"><em><span class="replaceable">路径</span></em></span>替换为文件或目录的路径。
						</li></ul></div><p><code class="literal">/etc/rwtab</code>文件识别以下可以将文件或目录复制到<code class="literal">tmpfs</code> ：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">空</code></span></dt><dd><p class="simpara">空路径将复制到<code class="literal">tmpfs</code> 。例如：</p><pre class="screen">empty /tmp</pre></dd><dt><span class="term"><code class="literal">迪尔斯</code></span></dt><dd><p class="simpara">目录树将复制到<code class="literal">tmpfs</code> ，为空。例如：</p><pre class="screen">dirs /var/run</pre></dd><dt><span class="term"><code class="literal">档</code></span></dt><dd><p class="simpara">文件或目录树完整地复制到<code class="literal">tmpfs</code> 。例如：</p><pre class="screen">files /etc/resolv.conf</pre></dd></dl></div><p>向<code class="literal">/etc/rwtab.d/</code>添加自定义路径时，采用相同的格式。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-the-root-file-system-to-mount-with-read-only-permissions-on-boot_setting-read-only-permissions-for-the-root-file-system"></a>配置根文件系统以在引导时使用只读权限进行装载</h2></div></div></div><p>使用此过程，根文件系统将以只读方式挂载在所有后续引导上。
				</p><h4><a id="procedure_42"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">在<code class="literal">/etc/sysconfig/readonly-root</code>文件中，将<code class="literal">READONLY</code>选项设置为<code class="literal">yes</code> ：</p><pre class="screen"># Set to 'yes' to mount the file systems as read-only.
READONLY=yes</pre></li><li class="listitem"><p class="simpara">在<code class="literal">/etc/fstab</code>文件的根条目（ <code class="literal">/</code> ）中添加<code class="literal">ro</code>选项：</p><pre class="screen">/dev/mapper/luks-c376919e...  /  xfs  x-systemd.device-timeout=0,<span class="strong"><strong>ro</strong></span>  1  1</pre></li><li class="listitem"><p class="simpara">将<code class="literal">ro</code>选项添加到<code class="literal">/etc/default/grub</code>文件中的<code class="literal">GRUB_CMDLINE_LINUX</code>指令，并确保该指令不包含<code class="literal">rw</code> ：</p><pre class="screen">GRUB_CMDLINE_LINUX="rhgb quiet... <span class="strong"><strong>ro</strong></span>"</pre></li><li class="listitem"><p class="simpara">重新创建GRUB2配置文件：</p><pre class="screen"># grub2-mkconfig -o /boot/grub2/grub.cfg</pre></li><li class="listitem"><p class="simpara">如果需要在<code class="literal">tmpfs</code>文件系统中添加要使用写权限挂载的文件和目录，请在<code class="literal">/etc/rwtab.d/</code>目录中创建一个文本文件并将配置放在那里。
						</p><p class="simpara">例如，要使用写权限挂载<code class="literal">/etc/example/file</code>文件，请将此行添加到<code class="literal">/etc/rwtab.d/example</code>文件中：</p><pre class="screen">files /etc/example/file</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">重要</h3><p>对<code class="literal">tmpfs</code>文件和目录所做的更改不会在引导期间保留。
							</p></div></li><li class="listitem">重新引导系统以应用更改。
						</li></ol></div><h4><a id="troubleshooting"></a>故障排除</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">如果错误地挂载具有只读权限的根文件系统，则可以使用以下命令再次使用读写权限重新装入它：</p><pre class="screen"># mount -o remount,rw /</pre></li></ul></div></div></div></div></body></html>