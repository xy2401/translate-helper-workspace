<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 管理虚拟机的存储</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 管理虚拟机的存储</h1></div></div></div><p>您可以使用<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#managing-storage-for-virtual-machines-using-the-cli_managing-storage-for-virtual-machines" title="使用CLI管理虚拟机的存储">CLI</a>或<a class="link" href="using-the-rhel-8-web-console-for-managing-vms_configuring-and-managing-virtualization.html#managing-virtual-machine-disks-using-the-rhel-8-web-console_using-the-rhel-8-web-console-for-managing-vms" title="使用RHEL 8 Web控制台管理虚拟机磁盘">Web控制台</a>管理虚拟机存储。
		</p><p>本文档提供有关如何使用<code class="literal">virsh</code>命令管理虚拟机存储的信息。
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="understanding-virtual-machine-storage_managing-storage-for-virtual-machines"></a>了解虚拟机存储</h1></div></div></div><p>以下各节提供有关虚拟机（VM）存储的信息，包括有关存储池，存储卷以及如何使用它们为VM提供存储的信息。</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="virtual-machine-storage_understanding-virtual-machine-storage"></a>虚拟机存储</h2></div></div></div><p>以下提供有关如何使用存储池和存储卷为VM创建存储的信息。</p><p><span class="emphasis"><em>存储池</em></span>是由主机托管以供VM使用的一定数量的存储。可以从存储池中的空间创建<span class="emphasis"><em>存储卷</em></span> 。可以将每个存储卷分配给VM作为客户总线上的块设备。
				</p><p>使用<code class="literal">libvirt</code>管理存储池和卷。使用<code class="literal">libvirt</code>远程协议，您可以管理虚拟机存储的所有方面。可以在远程主机上执行这些操作。因此，使用<code class="literal">libvirt</code>的管理应用程序（如RHEL Web控制台）可以使用户执行配置虚拟机存储所需的所有任务。
				</p><p><code class="literal">libvirt</code> API可用于查询存储池中的卷列表，或获取有关存储池中的容量，分配和可用存储的信息。可以查询存储池中的存储卷以获得诸如分配和容量之类的信息，这些信息对于稀疏卷可能不同。
				</p><p>对于支持它的存储池， <code class="literal">libvirt</code> API可用于创建，克隆，调整大小和删除存储卷。API还可用于将数据上载到存储卷，从存储卷下载数据或从存储卷擦除数据。
				</p><p>启动存储池后，可以使用存储池名称和存储卷名称（而不是虚拟机的XML配置文件中卷的主机路径）将存储卷分配给guest虚拟机。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="understanding-storage-pools_understanding-virtual-machine-storage"></a>存储池</h2></div></div></div><p>存储池是由<code class="literal">libvirt</code>管理的文件，目录或存储设备，用于为虚拟机提供存储。存储池分为存储卷，用于存储虚拟机映像或作为附加存储附加到VM。多个guest虚拟机可以共享同一存储池，从而可以更好地分配存储资源。
				</p><p>存储池可以是持久的或瞬态的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">持久存储池在主机重启系统后仍然存在。
						</li><li class="listitem">临时存储池仅在主机重新启动之前存在。
						</li></ul></div><p><code class="literal">virsh pool-define</code>命令用于创建永久存储池， <code class="literal">virsh pool-create</code>命令用于创建临时存储池。
				</p><h4><a id="storage_pool_storage_types"></a>存储池存储类型</h4><p>存储池可以是本地存储池，也可以是基于网络的（共享）：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							<span class="strong"><strong>本地存储池</strong></span>
						</p><p class="simpara">本地存储池直接连接到主机服务器。它们包括本地目录，直接连接的磁盘，物理分区和本地设备上的逻辑卷管理（LVM）卷组。
						</p><p class="simpara">本地存储池对于不需要迁移或大量VM的开发，测试和小型部署非常有用。</p></li><li class="listitem"><p class="simpara">
							<span class="strong"><strong>联网（共享）存储池</strong></span>
						</p><p class="simpara">网络存储池包括使用标准协议通过网络共享的存储设备。
						</p></li></ul></div><h4><a id="storage_pool_actions"></a>存储池操作</h4><p>可以停止（销毁）存储池。这将删除数据的抽象，但保持数据完整。
				</p><p>例如，使用<code class="literal">mount -t nfs nfs.example.com:/path/to/share /path/to/data</code>的NFS服务器。负责的存储管理员可以在虚拟化主机上定义NFS存储池，以描述导出的服务器路径和客户端目标路径。这将允许<code class="literal">libvirt</code>时候可以自动执行安装<code class="literal">libvirt</code>启动或当需要时再<code class="literal">libvirt</code>运行。具有NFS服务器导出目录的文件在NFS存储池中列为存储卷。
				</p><p>将存储卷添加到VM后，管理员无需将目标路径添加到卷。他只需要按名称添加存储池和存储卷。因此，如果目标客户端路径更改，则不会影响虚拟机。
				</p><p>启动存储池时， <code class="literal">libvirt</code>在指定目录上安装共享，就像系统管理员登录并执行<code class="literal">mount nfs.example.com:/path/to/share /vmdata</code> 。如果存储池被配置成自动启动， <code class="literal">libvirt</code>确保NFS共享磁盘被安装在当指定的目录<code class="literal">libvirt</code>开始。
				</p><p>启动存储池后，NFS共享磁盘中的文件将报告为存储卷，并且可以使用<code class="literal">libvirt</code> API查询存储卷的路径。然后，可以将存储卷的路径复制到虚拟机的XML定义部分，该部分描述虚拟机块设备的源存储。对于NFS，使用<code class="literal">libvirt</code> API的应用程序可以创建和删除存储池（NFS共享中的文件）中的存储卷，最大可达池大小（共享的存储容量）。
				</p><p>并非所有存储池类型都支持创建和删除卷。停止存储池（ <code class="literal">pool-destroy</code> ）撤消启动操作，在这种情况下，卸载NFS共享。尽管命令的名称表明，但是破坏操作不会修改共享上的数据。有关更多详细信息，请参阅<code class="literal">man virsh</code> 。
				</p><h4><a id="supported_and_unsupported_storage_pool_types"></a>支持和不支持的存储池类型</h4><p>以下是RHEL支持的存储池类型列表：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">基于目录的存储池</li><li class="listitem">基于磁盘的存储池</li><li class="listitem">基于分区的存储池</li><li class="listitem">GlusterFS存储池</li><li class="listitem">基于iSCSI的存储池</li><li class="listitem">基于LVM的存储池</li><li class="listitem">基于NFS的存储池</li><li class="listitem">带有SCSI设备的基于vHBA的存储池</li><li class="listitem">基于多路径的存储池</li><li class="listitem">基于RBD的存储池</li></ul></div><p>以下是RHEL不支持的<code class="literal">libvirt</code>存储池类型列表：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">基于牧羊犬的存储池</li><li class="listitem">基于Vstorage的存储池</li><li class="listitem">基于ZFS的存储池</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="storage-volumes_understanding-virtual-machine-storage"></a>存储量</h2></div></div></div><p>存储池分为<code class="literal">storage volumes</code> 。存储卷是物理分区，LVM逻辑卷，基于文件的磁盘映像以及<code class="literal">libvirt</code>处理的其他存储类型的抽象。无论底层硬件如何，存储卷都作为本地存储设备呈现给VM。
				</p><p>在主机上，存储卷由其名称和从中派生的存储池的标识符引用。在<code class="literal">virsh</code>命令行中，它采用<code class="literal">--pool <span class="emphasis"><em>storage_pool</em></span> <span class="emphasis"><em>volume_name</em></span></code>形式。
				</p><p>例如， <span class="emphasis"><em>guest_images</em></span>池中名为<span class="emphasis"><em>firstimage</em></span>的卷。
				</p><pre class="literallayout"># <span class="strong"><strong>virsh vol-info --pool guest_images firstimage</strong></span>
  Name:             firstimage
  Type:             block
  Capacity:         20.00 GB
  Allocation:       20.00 GB</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="managing-storage-for-virtual-machines-using-the-cli_managing-storage-for-virtual-machines"></a>使用CLI管理虚拟机的存储</h1></div></div></div><p>本文档提供有关如何使用<code class="literal">virsh</code>命令管理虚拟机存储的信息。
			</p><p>您可以使用CLI添加，删除和修改虚拟机存储。您还可以查看有关虚拟机存储的信息。
			</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>在许多情况下，VM的存储是在创建<a class="link" href="getting-started-with-virtualization-in-rhel-8_configuring-and-managing-virtualization.html#assembly_creating-virtual-machines_virt-getting-started" title="创建虚拟机">VM的同时创建的</a> 。因此，以下信息主要涉及VM存储的高级管理。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="viewing-virtual-machine-storage-information-using-the-cli_managing-storage-for-virtual-machines-using-the-cli"></a>使用CLI查看虚拟机存储信息</h2></div></div></div><p>以下提供有关使用CLI查看有关存储池和存储卷的信息的信息。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="viewing-storage-pool-information-using-the-cli_viewing-virtual-machine-storage-information-using-the-cli"></a>使用CLI查看存储池信息</h3></div></div></div><p>以下提供有关查看有关存储池的信息的信息。您可以查看具有有关存储池的有限或完整详细信息的所有存储池的列表。您还可以过滤列出的存储池。
					</p><h5><a id="procedure_43"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara"><code class="literal">virsh pool-list</code>命令用来查看存储池信息。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all --details</strong></span>
 Name                State    Autostart  Persistent    Capacity  Allocation   Available
----------------------------------------------------------------------------------------
 default             running  yes        yes          48.97 GiB   23.93 GiB   25.03 GiB
 Downloads           running  yes        yes         175.62 GiB   62.02 GiB  113.60 GiB
 RHEL8-Storage-Pool  running  yes        yes         214.62 GiB   93.02 GiB  168.60 GiB</pre></li></ul></div><h5><a id="additional_resources_32"></a>其他资源</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">有关可用的<code class="literal">virsh pool-list</code>选项的信息，请参阅相关的<code class="literal">man</code>页。
							</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="viewing-storage-volume-information-using-the-cli_viewing-virtual-machine-storage-information-using-the-cli"></a>使用CLI查看存储卷信息</h3></div></div></div><p>以下提供有关查看有关存储池的信息的信息。您可以查看指定存储池中所有存储池的列表以及有关指定存储池的详细信息。
					</p><h5><a id="procedure_44"></a>程序</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">virsh vol-list</code>命令列出指定存储池中的存储卷。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh vol-list --pool RHEL8-Storage-Pool --details</strong></span>
 Name                Path                                               Type   Capacity  Allocation
---------------------------------------------------------------------------------------------
 .bash_history       /home/VirtualMachines/.bash_history       file  18.70 KiB   20.00 KiB
 .bash_logout        /home/VirtualMachines/.bash_logout        file    18.00 B    4.00 KiB
 .bash_profile       /home/VirtualMachines/.bash_profile       file   193.00 B    4.00 KiB
 .bashrc             /home/VirtualMachines/.bashrc             file   1.29 KiB    4.00 KiB
 .git-prompt.sh      /home/VirtualMachines/.git-prompt.sh      file  15.84 KiB   16.00 KiB
 .gitconfig          /home/VirtualMachines/.gitconfig          file   167.00 B    4.00 KiB
 RHEL8_Volume.qcow2  /home/VirtualMachines/RHEL8_Volume.qcow2  file  60.00 GiB   13.93 GiB</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关可用<code class="literal">virsh vol-list</code>选项的信息，请参见相关<code class="literal">man</code>页。
								</p></div></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh vol-info</code>命令列出指定存储池中的存储卷。
							</p><pre class="literallayout"># <span class="strong"><strong>vol-info --pool RHEL8-Storage-Pool --vol RHEL8_Volume.qcow2</strong></span>
Name:           RHEL8_Volume.qcow2
Type:           file
Capacity:       60.00 GiB
Allocation:     13.93 GiB</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关可用的<code class="literal">virsh vol-info</code>选项<code class="literal">virsh vol-info</code> ，请参阅相关<code class="literal">man</code>页。
								</p></div></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-storage-for-virtual-machines-using-the-cli_managing-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配存储</h2></div></div></div><p>以下是为虚拟机创建和分配存储的高级过程：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							<span class="strong"><strong>创建存储池</strong></span>
						</p><p class="simpara">从可用存储介质创建一个或多个存储池。有关支持的存储池类型的列表，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#understanding-storage-pools_understanding-virtual-machine-storage" title="存储池">存储池类型</a> 。
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要创建永久存储池，请使用<code class="literal">virsh pool-define</code>和<code class="literal">virsh pool-define-as</code>命令。
								</p><p class="simpara"><code class="literal">virsh pool-define</code>命令使用XML文件作为池选项。<code class="literal">virsh pool-define-as</code>命令将选项放在命令行中。
								</p></li><li class="listitem"><p class="simpara">要创建临时存储池，请使用<code class="literal">virsh pool-create</code>和<code class="literal">virsh pool-create-as</code>命令。
								</p><p class="simpara"><code class="literal">virsh pool-create</code>命令使用XML文件作为池选项。<code class="literal">virsh pool-create-as</code>命令将选项放在命令行中。
								</p></li></ul></div></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>本文档中的所有示例和过程均使用<code class="literal">virsh pool-define</code>命令创建持久存储池。有关<code class="literal">virsh pool-create</code> ， <code class="literal">virsh pool-define-as</code>和<code class="literal">virsh pool-create-as</code>命令的更多信息，请参见相关手册页。
					</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							<span class="strong"><strong>创建存储卷</strong></span>
						</p><p class="simpara">从可用存储池创建一个或多个<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-storage-volumes-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI创建和分配存储卷">存储卷</a> 。
						</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>本文档中的所有示例和过程均使用<code class="literal">virsh vol‑create</code>命令创建存储。有关<code class="literal">virsh vol-create-as</code>命令的更多信息，请参见相关手册页。
							</p></div></li><li class="listitem"><p class="simpara">
							<span class="strong"><strong>将存储设备分配给虚拟机</strong></span>
						</p><p class="simpara">将从存储卷抽象的一个或多个存储设备分配给来宾虚拟机。
						</p></li></ol></div><p>以下部分提供有关使用CLI创建和分配存储的信息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-directory-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于目录的存储">基于目录的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-partition-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于文件系统的存储">基于文件系统的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-glusterfs-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配GlusterFS存储">基于GlusterFS的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于iSCSI的存储">基于iSCSI的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-lvm-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于LVM的存储">基于LVM的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于网络的存储">基于NFS的存储</a>
						</li><li class="listitem">
							<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli" title="使用CLI为虚拟机创建和分配基于vHBA的存储">基于vHBA的存储</a>
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-directory-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于目录的存储</h3></div></div></div><p>以下提供有关创建基于目录的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-directory-based-storage-pools-using-the-cli_creating-and-assigning-directory-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于目录的存储池</h4></div></div></div><p>以下提供了有关创建基于目录的存储池的说明。
						</p><h6><a id="procedure_45"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#directory-based-storage-pool-parameters_creating-and-assigning-directory-based-storage-for-virtual-machines-using-the-cli" title="基于目录的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>定义存储池目标路径</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-build</code>命令为预格式化的文件系统存储池创建存储池目标路径，初始化存储源设备，并定义数据的格式。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-build guest_images_fs</strong></span>
  Pool guest_images_fs built

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 8
  drwx------.  2 root root 4096 May 31 19:38 .
  dr-xr-xr-x. 25 root root 4096 May 31 19:38 ..</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="directory-based-storage-pool-parameters_creating-and-assigning-directory-based-storage-for-virtual-machines-using-the-cli"></a>基于目录的存储池参数</h4></div></div></div><p>以下提供有关基于目录的存储池所需参数的信息和示例。
						</p><h6><a id="parameters"></a>参数</h6><p>下表提供了基于目录的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710550145888"></a><p class="title"><strong>表7.1。基于目录的存储池参数</strong></p><div class="table-contents"><table border="1" summary="Directory-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='dir'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定目标的路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>target_path</em></span></code> &lt;/ path&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><h6><a id="example"></a>例</h6><p>以下是基于<code class="literal">/guest_images</code>目录的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='dir'&gt;
  &lt;name&gt;dirpool&lt;/name&gt;
  &lt;target&gt;
    &lt;path&gt;/guest_images&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-disk-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于磁盘的存储</h3></div></div></div><p>以下提供有关创建基于磁盘的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-disk-based-storage-pools-using-the-cli_creating-and-assigning-disk-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于磁盘的存储池</h4></div></div></div><p>以下提供了有关创建基于磁盘的存储池的说明。
						</p><h6><a id="recommendations"></a>建议</h6><p>在创建基于磁盘的存储池之前，请注意以下事项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">根据所使用的<code class="literal">libvirt</code>的版本，将磁盘专用于存储池可能会重新格式化并擦除当前存储在磁盘设备上的所有数据。强烈建议您在创建存储池之前备份存储设备上的数据。
								</li><li class="listitem"><p class="simpara">不应授予guest虚拟机对整个磁盘或块设备的写访问权限（例如， <code class="literal">/dev/sdb</code> ）。使用分区（例如， <code class="literal">/dev/sdb1</code> ）或LVM卷。
								</p><p class="simpara">如果将整个块设备传递给guest虚拟机，则guest虚拟机可能会对其进行分区或在其上创建自己的LVM组。这可能导致主机检测到这些分区或LVM组并导致错误。
								</p></li></ul></div><h6><a id="procedure_46"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用GUID分区表（GPT）磁盘标签重新标记磁盘。GPT磁盘标签允许在每个设备上创建多达128个分区。
								</p><pre class="literallayout"># <span class="strong"><strong>parted /dev/sdb</strong></span>
GNU Parted 2.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) mklabel
New disk label type? gpt
(parted) quit
Information: You may need to update /etc/fstab.
#</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#disk-based-storage-pool-parameters_creating-and-assigning-disk-based-storage-for-virtual-machines-using-the-cli" title="基于磁盘的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>定义存储池目标路径</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-build</code>命令为预格式化的文件系统存储池创建存储池目标路径，初始化存储源设备，并定义数据的格式。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-build guest_images_fs</strong></span>
  Pool guest_images_fs built

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 8
  drwx------.  2 root root 4096 May 31 19:38 .
  dr-xr-xr-x. 25 root root 4096 May 31 19:38 ..</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>只有基于磁盘，基于文件系统和逻辑存储池才需要构建目标路径。如果<code class="literal">libvirt</code>检测到源存储设备的数据格式与所选存储池类型不同，则构建将失败，除非指定了<code class="literal"><span class="emphasis"><em>overwrite</em></span></code>选项。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="disk-based-storage-pool-parameters_creating-and-assigning-disk-based-storage-for-virtual-machines-using-the-cli"></a>基于磁盘的存储池参数</h4></div></div></div><p>以下提供有关基于目录的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_2"></a>参数</h6><p>下表提供了基于磁盘的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710460136832"></a><p class="title"><strong>表7.2。基于磁盘的存储池参数</strong></p><div class="table-contents"><table border="1" summary="Disk-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='disk'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定存储设备的路径。例如， <code class="literal">/dev/sdb</code> 。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>source_path</em></span></code> &lt;/ path&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定目标设备的路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>target_path</em></span></code> &lt;/ path&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><h6><a id="example_2"></a>例</h6><p>以下是基于磁盘的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='disk'&gt;
  &lt;name&gt;phy_disk&lt;/name&gt;
  &lt;source&gt;
    &lt;device path='/dev/sdb'/&gt;
    &lt;format type='gpt'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-partition-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于文件系统的存储</h3></div></div></div><p>以下提供有关创建基于目录的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-filesystem-based-storage-pools-using-the-cli_creating-and-assigning-partition-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于文件系统的存储池</h4></div></div></div><p>以下提供了有关创建基于文件系统的存储池的说明。
						</p><h6><a id="recommendations_2"></a>建议</h6><p>请勿使用此过程将整个磁盘分配为存储池（例如， <code class="literal">/dev/sdb</code> ）。不应为访客提供对整个磁盘或块设备的写访问权限。此方法仅应用于将分区（例如， <code class="literal">/dev/sdb1</code> ）分配给存储池。
						</p><h6><a id="procedure_47"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#filesystem-based-storage-pool-parameters_creating-and-assigning-partition-based-storage-for-virtual-machines-using-the-cli" title="基于文件系统的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>定义存储池目标路径</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-build</code>命令为预格式化的文件系统存储池创建存储池目标路径，初始化存储源设备，并定义数据的格式。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-build guest_images_fs</strong></span>
  Pool guest_images_fs built

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 8
  drwx------.  2 root root 4096 May 31 19:38 .
  dr-xr-xr-x. 25 root root 4096 May 31 19:38 ..</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="filesystem-based-storage-pool-parameters_creating-and-assigning-partition-based-storage-for-virtual-machines-using-the-cli"></a>基于文件系统的存储池参数</h4></div></div></div><p>以下提供有关基于目录的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_3"></a>参数</h6><p>下表提供了基于文件系统的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710490867040"></a><p class="title"><strong>表7.3。基于文件系统的存储池参数</strong></p><div class="table-contents"><table border="1" summary="Filesystem-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='fs'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定分区的路径。例如， <code class="literal">/dev/sdc1</code>
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;device path = <span class="emphasis"><em>device_path</em></span> /&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>文件系统类型，例如<span class="strong"><strong>ext4</strong></span> 。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;format type = <span class="emphasis"><em>fs_type</em></span> /&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定目标的路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>path-to-pool</em></span></code> &lt;/ path&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><h6><a id="example_3"></a>例</h6><p>以下是基于<code class="literal">/dev/sdc1</code>分区的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='fs'&gt;
  &lt;name&gt;guest_images_fs&lt;/name&gt;
  &lt;source&gt;
    &lt;device path='/dev/sdc1'/&gt;
    &lt;format type='auto'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/guest_images&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-glusterfs-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配GlusterFS存储</h3></div></div></div><p>以下提供有关创建基于目录的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-glusterfs-based-storage-pools-using-the-cli_creating-and-assigning-glusterfs-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于GlusterFS的存储池</h4></div></div></div><p>GlusterFS是一个在用户空间（FUSE）中使用文件系统的用户空间文件系统。
						</p><p>以下提供了有关创建基于GlusterFS的存储池的说明。
						</p><h6><a id="prerequisites_42"></a>先决条件</h6><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">在可以在主机上创建基于GlusterFS的存储池之前，必须准备Gluster服务器。
								</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">通过使用以下命令列出其状态来获取Gluster服务器的IP地址：</p><pre class="literallayout"># <span class="strong"><strong>gluster volume status</strong></span>
Status of volume: gluster-vol1
Gluster process                           Port	Online	Pid
------------------------------------------------------------
Brick 222.111.222.111:/gluster-vol1       49155	  Y    18634

Task Status of Volume gluster-vol1
------------------------------------------------------------
There are no active volume tasks</pre></li><li class="listitem">如果未安装，请安装<code class="literal">glusterfs-fuse</code>包。
										</li><li class="listitem"><p class="simpara">如果未启用，请启用<code class="literal">virt_use_fusefs</code>布尔值。检查它是否已启用。
										</p><pre class="literallayout"># <span class="strong"><strong>setsebool virt_use_fusefs on</strong></span>
# <span class="strong"><strong>getsebool virt_use_fusefs</strong></span>
virt_use_fusefs --&gt; on</pre></li></ol></div></li></ul></div><p>确保安装并启用了所需的软件包后，继续创建存储池。
						</p><h6><a id="procedure_48"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#glusterfs-based-storage-pool-parameters_creating-and-assigning-glusterfs-storage-for-virtual-machines-using-the-cli" title="基于GlusterFS的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="informalexample"><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
						</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>定义存储池目标路径</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-build</code>命令为预格式化的文件系统存储池创建存储池目标路径，初始化存储源设备，并定义数据的格式。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-build guest_images_fs</strong></span>
  Pool guest_images_fs built

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 8
  drwx------.  2 root root 4096 May 31 19:38 .
  dr-xr-xr-x. 25 root root 4096 May 31 19:38 ..</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>只有基于磁盘，基于文件系统和逻辑存储池才需要构建目标路径。如果<code class="literal">libvirt</code>检测到源存储设备的数据格式与所选存储池类型不同，则构建将失败，除非指定了<code class="literal"><span class="emphasis"><em>overwrite</em></span></code>选项。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="glusterfs-based-storage-pool-parameters_creating-and-assigning-glusterfs-storage-for-virtual-machines-using-the-cli"></a>基于GlusterFS的存储池参数</h4></div></div></div><p>以下提供有关基于GlusterFS的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_4"></a>参数</h6><p>下表提供了基于GlusterFS的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710572811296"></a><p class="title"><strong>表7.4。基于GlusterFS的存储池参数</strong></p><div class="table-contents"><table border="1" summary="GlusterFS-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='gluster'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>Gluster服务器的主机名或IP地址</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;name = <span class="emphasis"><em>gluster-name</em></span> /&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>Gluster服务器的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>用于存储池的Gluster服务器上的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;dir path = <span class="emphasis"><em>gluster-path</em></span> /&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><h6><a id="example_4"></a>例</h6><p>以下是基于Gluster文件系统111.222.111.222的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='gluster'&gt;
  &lt;name&gt;Gluster_pool&lt;/name&gt;
  &lt;source&gt;
    &lt;host name='111.222.111.222'/&gt;
    &lt;dir path='/'/&gt;
    &lt;name&gt;gluster-vol1&lt;/name&gt;
  &lt;/source&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于iSCSI的存储</h3></div></div></div><p>以下提供有关创建基于iSCSI的存储池和存储卷，使用<code class="literal">libvirt</code>机密保护基于iSCSI的存储池以及将卷分配给虚拟机的信息。
					</p><h5><a id="recommendations_3"></a>建议</h5><p>Internet小型计算机系统接口（iSCSI）是用于共享存储设备的网络协议。 iSCSI使用IP层上的SCSI指令将启动器（存储客户端）连接到目标（存储服务器）。
					</p><p>使用基于iSCSI的设备存储虚拟机可以实现更灵活的存储选项，例如将iSCSI用作块存储设备。iSCSI设备使用Linux-IO（LIO）目标。这是Linux的多协议SCSI目标。除iSCSI外，LIO还支持光纤通道和以太网光纤通道（FCoE）。
					</p><p>如果您需要阻止访问iSCSI存储池，可以使用<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#securing-iscsi-storage-pools-with-libvirt-secrets_creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli" title="使用libvirt机密保护iSCSI存储池">libvirt机密</a>保护它。
					</p><h5><a id="prerequisites-creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli"></a>先决条件</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">在创建基于iSCSI的存储池之前，必须先创建iSCSI目标。 iSCSI目标是使用<code class="literal">targetcli</code>程序包创建的，该程序包提供用于创建软件支持的iSCSI目标的命令集。
							</p><p class="simpara">有关创建iSCSI目标的更多信息和说明，请参阅“ <span class="emphasis"><em>Red Hat Enterprise Linux存储管理指南”</em></span> 。
							</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-iscsi-based-storage-pools-using-the-cli_creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于iSCSI的存储池</h4></div></div></div><p>以下提供了有关创建基于iSCSI的存储池的说明。
						</p><h6><a id="procedure_49"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#iscsi-based-storage-pool-parameters_creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli" title="基于iSCSI的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="informalexample"><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
						</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iscsi-based-storage-pool-parameters_creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli"></a>基于iSCSI的存储池参数</h4></div></div></div><p>以下提供有关基于iSCSI的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_5"></a>参数</h6><p>下表提供了基于iSCSI的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710562124800"></a><p class="title"><strong>表7.5。基于iSCSI的存储池参数</strong></p><div class="table-contents"><table border="1" summary="iSCSI-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='iscsi'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>主机的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;主机名= <span class="emphasis"><em>主机名</em></span> /&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>iSCSI IQN</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;device path = <span class="emphasis"><em>iSCSI_IQN</em></span> /&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定目标的路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>/dev/disk/by-path</em></span></code> &lt;/ path&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>[可选] iSCSI启动器的IQN。仅当ACL将LUN限制为特定启动器时才需要此操作。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;引发剂&gt;<br>&lt;iqn name =' <span class="emphasis"><em>initiator0</em></span> '/&gt;<br>&lt;/引发剂&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>可以使用<code class="literal">virsh find-storage-pool-sources-as</code> iscsi命令确定iSCSI启动器的IQN。
							</p></div><h6><a id="example_5"></a>例</h6><p>以下是基于指定的iSCSI设备的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='iscsi'&gt;
  &lt;name&gt;iSCSI_pool&lt;/name&gt;
  &lt;source&gt;
    &lt;host name='server1.example.com'/&gt;
    &lt;device path='iqn.2010-05.com.example.server1:iscsirhel7guest'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev/disk/by-path&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="securing-iscsi-storage-pools-with-libvirt-secrets_creating-and-assigning-iscsi-based-storage-for-virtual-machines-using-the-cli"></a>使用libvirt机密保护iSCSI存储池</h4></div></div></div><p>可以使用<code class="literal">virsh</code>配置用户名和密码参数以保护iSCSI存储池。可以在定义池之前或之后配置，但必须启动池才能使身份验证设置生效。
						</p><p>以下提供了使用<code class="literal">libvirt</code>机密保护基于iSCSI的存储池的说明。
						</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>如果在创建iSCSI目标时定义了<code class="literal"><span class="emphasis"><em>user_ID</em></span></code>和<code class="literal"><span class="emphasis"><em>password</em></span></code> ，则需要此过程。
							</p></div><h6><a id="procedure_50"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用质询握手身份验证协议（CHAP）用户名创建libvirt机密文件。例如：</p><pre class="programlisting">&lt;secret ephemeral='no' private='yes'&gt;
    &lt;description&gt;Passphrase for the iSCSI example.com server&lt;/description&gt;
    &lt;usage type='iscsi'&gt;
        &lt;target&gt;iscsirhel7secret&lt;/target&gt;
    &lt;/usage&gt;
&lt;/secret&gt;</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh secret-define</code>命令定义libvirt机密。
								</p><p class="simpara">
									<code class="literal"><span class="emphasis"><em>#virsh</em></span> <span class="strong"><strong>secret-define</strong></span> <span class="emphasis"><em>secret.xml</em></span></code>
								</p></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh secret-list</code>命令验证UUID。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh secret-list</strong></span>
UUID                                  Usage
-------------------------------------------------------------------
2d7891af-20be-4e5e-af83-190e8a922360  iscsi iscsirhel7secret</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh secret-set-value</code>命令在上一步的输出中为UUID分配一个秘密。这可确保CHAP用户名和密码位于libvirt控制的密钥列表中。例如：</p><pre class="literallayout"># <span class="strong"><strong>MYSECRET=`printf *%s "<span class="emphasis"><em>password123</em></span>" | base64`</strong></span>
# <span class="strong"><strong>virsh secret-set-value 2d7891af-20be-4e5e-af83-190e8a922360 $MYSECRET</strong></span></pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh edit</code>命令在存储池的XML文件中添加身份验证条目，并添加<code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code>元素，指定<code class="literal"><span class="strong"><strong>authentication type</strong></span></code> ， <code class="literal"><span class="strong"><strong>username</strong></span></code>和<code class="literal"><span class="strong"><strong>secret usage</strong></span></code> 。
								</p><p class="simpara">例如：</p><pre class="programlisting">&lt;pool type='iscsi'&gt;
  &lt;name&gt;iscsirhel7pool&lt;/name&gt;
    &lt;source&gt;
       &lt;host name='192.168.122.1'/&gt;
       &lt;device path='iqn.2010-05.com.example.server1:iscsirhel7guest'/&gt;
       &lt;auth type='chap' username='redhat'&gt;
          &lt;secret usage='iscsirhel7secret'/&gt;
       &lt;/auth&gt;
    &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev/disk/by-path&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code>子元素存在于guest XML的<code class="literal"><span class="strong"><strong>&lt;pool&gt;</strong></span></code>和<code class="literal"><span class="strong"><strong>&lt;disk&gt;</strong></span></code>元素中的不同位置。对于<code class="literal"><span class="strong"><strong>&lt;pool&gt;</strong></span></code> ， <code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code> <code class="literal"><span class="strong"><strong>&lt;source&gt;</strong></span></code>元素中指定了<code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code> ，因为它描述了查找池源的位置，因为身份验证是某些池源（iSCSI和RBD）的属性。对于<code class="literal"><span class="strong"><strong>&lt;disk&gt;</strong></span></code> ，它是域的子元素，对iSCSI或RBD磁盘的身份验证是磁盘的属性。此外，磁盘的<code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code>子元素与存储池的<code class="literal"><span class="strong"><strong>&lt;auth&gt;</strong></span></code>子元素不同。
									</p><pre class="programlisting">&lt;auth username='redhat'&gt;
  &lt;secret type='iscsi' usage='iscsirhel7secret'/&gt;
&lt;/auth&gt;</pre></div></li><li class="listitem"><p class="simpara">要激活更改，必须激活存储池。如果池已经启动，请停止并重新启动存储池：</p><p class="simpara">
									<code class="literal"><span class="emphasis"><em>#virsh</em></span> <span class="strong"><strong>pool-destroy</strong></span> <span class="emphasis"><em>iscsirhel7pool</em></span></code>
								</p><p class="simpara">
									<code class="literal"><span class="emphasis"><em>#virsh</em></span> <span class="strong"><strong>pool-start</strong></span> <span class="emphasis"><em>iscsirhel7pool</em></span></code>
								</p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-lvm-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于LVM的存储</h3></div></div></div><p>以下提供有关创建基于LVM的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-lvm-based-storage-pools-using-the-cli_creating-and-assigning-lvm-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于LVM的存储池</h4></div></div></div><p>以下提供了有关创建基于LVM的存储池的说明。
						</p><h6><a id="recommendations_4"></a>建议</h6><p>在创建基于LVM的存储池之前，请注意以下事项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">基于LVM的存储池不能提供LVM的完全灵活性。</li><li class="listitem">
									<code class="literal">libvirt</code>支持精简逻辑卷，但不提供精简存储池的功能。
								</li><li class="listitem"><p class="simpara">基于LVM的存储池是卷组。您可以使用Logical Volume Manager命令或<code class="literal">virsh</code>命令创建卷组。要使用<code class="literal">virsh</code>界面管理卷组，请使用<code class="literal">virsh</code>命令创建卷组。
								</p><p class="simpara">有关卷组的更多信息，请参阅“ <span class="emphasis"><em>Red Hat Enterprise Linux逻辑卷管理器管理指南”</em></span> 。
								</p></li><li class="listitem">基于LVM的存储池需要完整的磁盘分区。如果使用这些过程激活新分区或设备，则将格式化分区并删除所有数据。如果使用主机的现有卷组（VG），则不会删除任何内容。建议在启动前备份存储设备。
								</li></ul></div><h6><a id="procedure_51"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#lvm-based-storage-pool-parameters_creating-and-assigning-lvm-based-storage-for-virtual-machines-using-the-cli" title="基于LVM的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="lvm-based-storage-pool-parameters_creating-and-assigning-lvm-based-storage-for-virtual-machines-using-the-cli"></a>基于LVM的存储池参数</h4></div></div></div><p>以下提供有关基于LVM的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_6"></a>参数</h6><p>下表提供了基于LVM的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710573849408"></a><p class="title"><strong>表7.6。基于LVM的存储池参数</strong></p><div class="table-contents"><table border="1" summary="LVM-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='logical'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池设备的路径</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;device path =' <span class="emphasis"><em>device_path</em></span> '/&gt;`</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>卷组的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>VG-name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>虚拟组格式</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;format type ='lvm2'/&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>目标路径</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path = <span class="emphasis"><em>target_path</em></span> /&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>如果逻辑卷组由多个磁盘分区组成，则可能会列出多个源设备。例如：</p><pre class="screen">&lt;source&gt;
  &lt;device path='/dev/sda1'/&gt;
  &lt;device path='/dev/sdb3'/&gt;
  &lt;device path='/dev/sdc2'/&gt;
  ...
&lt;/source&gt;</pre></div><h6><a id="example_6"></a>例</h6><p>以下是基于指定LVM的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='logical'&gt;
  &lt;name&gt;guest_images_lvm&lt;/name&gt;
  &lt;source&gt;
    &lt;device path='/dev/sdc'/&gt;
    &lt;name&gt;libvirt_lvm&lt;/name&gt;
    &lt;format type='lvm2'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev/libvirt_lvm&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于网络的存储</h3></div></div></div><p>以下提供有关创建基于网络的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="prerequisites-creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli"></a>先决条件</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">要创建基于网络文件系统（NFS）的存储池，应已将NFS服务器配置为由主机使用。有关NFS的更多信息，请参阅“ <span class="emphasis"><em>Red Hat Enterprise Linux存储管理指南”</em></span> 。
								</li><li class="listitem">确保在主机上安装了所用文件系统所需的实用程序。例如， <code class="literal">cifs-utils</code>的通用互联网文件系统（CIFS）和<code class="literal">glusterfs.fuse</code>的GlusterFS。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-nfs-based-storage-pools-using-the-cli_creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于网络的存储池</h4></div></div></div><p>以下提供了有关创建基于网络的存储池的说明。
						</p><h6><a id="procedure_52"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#nfs-based-storage-pool-parameters_creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli" title="基于NFS的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>定义存储池目标路径</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-build</code>命令为预格式化的文件系统存储池创建存储池目标路径，初始化存储源设备，并定义数据的格式。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-build guest_images_fs</strong></span>
  Pool guest_images_fs built

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 8
  drwx------.  2 root root 4096 May 31 19:38 .
  dr-xr-xr-x. 25 root root 4096 May 31 19:38 ..</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="nfs-based-storage-pool-parameters_creating-and-assigning-nfs-storage-for-virtual-machines-using-the-cli"></a>基于NFS的存储池参数</h4></div></div></div><p>以下提供有关基于NFS的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_7"></a>参数</h6><p>下表提供了基于NFS的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710566810800"></a><p class="title"><strong>表7.7。基于NFS的存储池参数</strong></p><div class="table-contents"><table border="1" summary="NFS-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='netfs'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>挂载点所在的网络服务器的主机名。这可以是主机名或IP地址。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;host name= <span class="emphasis"><em>hostname</em></span></code> <code class="literal">/&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的格式</p>
										 </td><td valign="top" style="text-align:left"> <p>以下之一：</p>
										 <p>
											    <code class="literal">&lt;format type ='nfs'/&gt;</code>
										</p>
										 <p>
											    <code class="literal">&lt;format type ='glusterfs'/&gt;</code>
										</p>
										 <p>
											    <code class="literal">&lt;format type ='cifs'/&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>网络服务器上使用的目录</p>
										 </td><td valign="top" style="text-align:left"> <p>
											    <code class="literal">&lt;dir path= <span class="emphasis"><em>source_path</em></span></code> <code class="literal">/&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>指定目标的路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path&gt; <code class="literal"><span class="emphasis"><em>target_path</em></span></code> &lt;/ path&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><h6><a id="example_7"></a>例</h6><p>以下是基于<code class="literal">file_server</code> NFS服务器的<code class="literal">/home/net_mount</code>目录的存储池的XML文件示例：</p><pre class="programlisting">&lt;pool type='netfs'&gt;
  &lt;name&gt;nfspool&lt;/name&gt;
  &lt;source&gt;
    &lt;host name='file_server'/&gt;
    &lt;format type='nfs'/&gt;
    &lt;dir path='/home/net_mount'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/var/lib/libvirt/images/nfspool&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI为虚拟机创建和分配基于vHBA的存储</h3></div></div></div><p>以下提供有关创建基于vHBA的存储池和存储卷以及将卷分配给虚拟机的信息。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="recommendations-creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>建议</h4></div></div></div><p>
							<span class="emphasis"><em>N_Port ID虚拟化</em></span> （NPIV）是一种允许共享单个物理光纤通道主机总线适配器（HBA）的软件技术。这允许多个guest虚拟机从多个物理主机中查看相同的存储，从而允许更容易的存储迁移路径。因此，只要指定了正确的存储路径，就无需迁移来创建或复制存储。
						</p><p>在虚拟化中， <span class="emphasis"><em>虚拟主机总线适配器</em></span>或<span class="emphasis"><em>vHBA</em></span>控制虚拟机的逻辑单元号（LUN）。要使主机在多个KVM来宾之间共享一个光纤通道设备路径，必须为每个虚拟机创建一个vHBA。多个KVM来宾不得使用单个vHBA。
						</p><p>NPIV的每个vHBA由其父HBA及其自己的全球节点名称（WWNN）和全球端口名称（WWPN）标识。存储路径由WWNN和WWPN值确定。父HBA可以定义为<code class="literal"><span class="emphasis"><em>scsi_host#</em></span></code>或WWNN / WWPN对。
						</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>如果将父HBA定义为<code class="literal"><span class="emphasis"><em>scsi_host#</em></span></code>并将硬件添加到主机，则<code class="literal"><span class="emphasis"><em>scsi_host#</em></span></code>赋值可能会更改。因此，建议您使用WWNN / WWPN对定义父HBA。
							</p></div><p>建议您基于vHBA定义<code class="literal">libvirt</code>存储池，因为这会保留vHBA配置。
						</p><p>使用libvirt存储池有两个主要优点：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">libvirt代码可以通过virsh命令输出轻松找到LUN的路径。
								</li><li class="listitem">虚拟机迁移仅需要在目标计算机上定义和启动具有相同vHBA名称的存储池。为此，必须在虚拟机的XML配置中指定vHBA LUN，libvirt存储池和卷名。
								</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>在创建vHBA之前，建议您在主机LUN中配置存储阵列（SAN）侧分区，以在guest虚拟机之间提供隔离，并防止数据损坏的可能性。
							</p></div><p>要创建持久性vHBA配置，首先要创建一个libvirt <span class="strong"><strong>“scsi”</strong></span>存储池XML文件。有关XML文件的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-vhbas_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli" title="创建vHBA">创建vHBA</a> 。在同一物理HBA上创建使用存储池的单个vHBA时，建议对<code class="literal">&lt;path&gt;</code>值使用稳定的位置，例如<code class="literal">/dev/disk/by-{ <span class="emphasis"><em>path|id|uuid|label</em></span> }</code>系统上的位置。
						</p><p>创建在同一物理HBA上使用存储池的多个vHBA时， <code class="literal">&lt;path&gt;</code>字段的值必须仅为<code class="literal">/dev/</code> ，否则存储池卷仅对其中一个vHBA可见，并且无法公开来自主机的设备使用NPIV配置的多个来宾。
						</p><p>有关<code class="literal">&lt;path&gt;</code>和<code class="literal">&lt;target&gt;</code>元素的更多信息，请参阅<a class="link" href="https://libvirt.org/formatstorage.html#StoragePoolTarget">上游libvirt文档</a> 。
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="prerequisites-creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>先决条件</h4></div></div></div><p>在使用SCSI设备创建基于vHBA的存储池之前，请创建vHBA。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-vhbas_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>创建vHBA</h4></div></div></div><p>以下提供有关创建虚拟主机总线适配器（vHBA）的说明。
						</p><h6><a id="procedure_53"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">virsh nodedev-list --cap vports</code>命令在主机系统上找到HBA。
								</p><p class="simpara">以下示例显示了具有两个支持vHBA的HBA的主机：</p><pre class="literallayout"># <span class="strong"><strong>virsh nodedev-list --cap vports</strong></span>
scsi_host3
scsi_host4</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh nodedev-dumpxml <span class="emphasis"><em>HBA_device</em></span></code>命令查看HBA的详细信息。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh nodedev-dumpxml scsi_host3</strong></span></pre><p class="simpara">该命令的输出列出了<code class="literal">&lt;name&gt;</code> ， <code class="literal">&lt;wwnn&gt;</code>和<code class="literal">&lt;wwpn&gt;</code>字段，这些字段用于创建vHBA。 <code class="literal">&lt;max_vports&gt;</code>显示支持的vHBA的最大数量。例如：</p><pre class="programlisting">&lt;device&gt;
  &lt;name&gt;scsi_host3&lt;/name&gt;
  &lt;path&gt;/sys/devices/pci0000:00/0000:00:04.0/0000:10:00.0/host3&lt;/path&gt;
  &lt;parent&gt;pci_0000_10_00_0&lt;/parent&gt;
  &lt;capability type='scsi_host'&gt;
    &lt;host&gt;3&lt;/host&gt;
    &lt;unique_id&gt;0&lt;/unique_id&gt;
    &lt;capability type='fc_host'&gt;
      &lt;wwnn&gt;20000000c9848140&lt;/wwnn&gt;
      &lt;wwpn&gt;10000000c9848140&lt;/wwpn&gt;
      &lt;fabric_wwn&gt;2002000573de9a81&lt;/fabric_wwn&gt;
    &lt;/capability&gt;
    &lt;capability type='vport_ops'&gt;
      &lt;max_vports&gt;127&lt;/max_vports&gt;
      &lt;vports&gt;0&lt;/vports&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre><p class="simpara">在此示例中， <code class="literal">&lt;max_vports&gt;</code>值显示共有127个虚拟端口可供HBA配置使用。<code class="literal">&lt;vports&gt;</code>值显示当前正在使用的虚拟端口数。创建vHBA后，这些值会更新。</p></li><li class="listitem"><p class="simpara">为vHBA主机创建类似于以下内容之一的XML文件。在这些示例中，该文件名为<code class="literal">vhba_host3.xml</code> 。
								</p><p class="simpara">此示例使用<code class="literal"><span class="strong"><strong>scsi_host3</strong></span></code>来描述父vHBA。</p><pre class="programlisting">&lt;device&gt;
  &lt;parent&gt;scsi_host3&lt;/parent&gt;
  &lt;capability type='scsi_host'&gt;
    &lt;capability type='fc_host'&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre><p class="simpara">此示例使用WWNN / WWPN对来描述父vHBA。</p><pre class="programlisting">&lt;device&gt;
  &lt;name&gt;vhba&lt;/name&gt;
  &lt;parent wwnn='20000000c9848140' wwpn='10000000c9848140'/&gt;
  &lt;capability type='scsi_host'&gt;
    &lt;capability type='fc_host'&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>WWNN和WWPN值必须与上一步中看到的HBA详细信息中的值相匹配。
									</p></div><p class="simpara"><code class="literal">&lt;parent&gt;</code>字段指定要与此vHBA设备关联的HBA设备。<code class="literal">&lt;device&gt;</code>标记中的详细信息将在下一步中用于为主机创建新的vHBA设备。有关<code class="literal">nodedev</code> XML格式的更多信息，请参阅<a class="link" href="https://libvirt.org/formatnode.html">libvirt上游页面</a> 。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh</code>命令不提供定义<code class="literal">parent_wwnn</code> ， <code class="literal">parent_wwpn</code>或<code class="literal">parent_fabric_wwn</code>属性的方法。
									</p></div></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh nodev-create</code>命令基于上一步中创建的XML文件创建VHBA。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh nodedev-create vhba_host3</strong></span>
Node device scsi_host5 created from vhba_host3.xml</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh nodedev-dumpxml</code>命令验证新的vHBA的详细信息（scsi_host5）：</p><pre class="literallayout"># <span class="strong"><strong>virsh nodedev-dumpxml scsi_host5</strong></span>
&lt;device&gt;
  &lt;name&gt;scsi_host5&lt;/name&gt;
  &lt;path&gt;/sys/devices/pci0000:00/0000:00:04.0/0000:10:00.0/host3/vport-3:0-0/host5&lt;/path&gt;
  &lt;parent&gt;scsi_host3&lt;/parent&gt;
  &lt;capability type='scsi_host'&gt;
    &lt;host&gt;5&lt;/host&gt;
    &lt;unique_id&gt;2&lt;/unique_id&gt;
    &lt;capability type='fc_host'&gt;
      &lt;wwnn&gt;5001a4a93526d0a1&lt;/wwnn&gt;
      &lt;wwpn&gt;5001a4ace3ee047d&lt;/wwpn&gt;
      &lt;fabric_wwn&gt;2002000573de9a81&lt;/fabric_wwn&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="creating-vhba-based-storage-pools-using-the-cli_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建基于vHBA的存储池</h4></div></div></div><p>以下提供了有关创建基于vHBA的存储池的说明。
						</p><h6><a id="prerequisites_43"></a>先决条件</h6><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">确保有vHBA。有关更多信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-vhbas_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli" title="创建vHBA">创建vHBA</a> 。
								</li></ul></div><h6><a id="procedure_54"></a>程序</h6><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储池</strong></span>
								</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
								</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#vhba-based-storage-pool-parameters_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli" title="基于vHBA的存储池参数">参数</a> 。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="informalexample"><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
						</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证池是否已创建</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>启动存储池</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
									</p></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>[可选]打开自动启动</strong></span>
								</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
								</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>验证存储池</strong></span>
								</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="vhba-based-storage-pool-parameters_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>基于vHBA的存储池参数</h4></div></div></div><p>以下提供有关基于vHBA的存储池所需参数的信息和示例。
						</p><h6><a id="parameters_8"></a>参数</h6><p>下表提供了基于vHBA的存储池的XML文件所需参数的列表。
						</p><div class="table"><a id="idm139710573980768"></a><p class="title"><strong>表7.8。基于vHBA的存储池参数</strong></p><div class="table-contents"><table border="1" summary="vHBA-based storage pool parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">XML</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>存储池的类型</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;pool type ='scsi'&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>存储池的名称</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;name&gt; <code class="literal"><span class="emphasis"><em>name</em></span></code> &lt;/ name&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>vHBA的标识符。 <code class="literal">parent</code>属性是可选的。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;源&gt;<br>&lt;adapter type ='fc_host'<br>[parent = <span class="emphasis"><em>parent_scsi_device</em></span> ]<br>wwnn =' <span class="emphasis"><em>WWNN</em></span> '<br>wwpn =' <span class="emphasis"><em>WWPN</em></span> '/&gt;<br>&lt;/源&gt;</code>
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>目标路径。这将是用于存储池的路径。
										</p>
										 </td><td valign="top" style="text-align:left"> <p>
											<code class="literal">&lt;目标&gt;<br>&lt;path = <span class="emphasis"><em>target_path</em></span> /&gt;<br>&lt;/目标&gt;</code>
										</p>
										 </td></tr></tbody></table></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">重要</h3><p>当<code class="literal">&lt;path&gt;</code>字段为<code class="literal"><span class="strong"><strong>/dev/</strong></span></code> ， <code class="literal">libvirt</code>为卷设备路径生成唯一的短设备路径。例如， <code class="literal"><span class="strong"><strong>/dev/sdc</strong></span></code> 。否则，使用物理主机路径。例如，/ <code class="literal"><span class="strong"><strong>/dev/disk/by-path/pci-0000:10:00.0-fc-0x5006016044602198-lun-0</strong></span></code> 。唯一的短设备路径允许多个存储池在多个guest虚拟机中列出相同的卷。如果多个guest虚拟机使用物理主机路径，则可能会出现重复的设备类型警告。
							</p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>可以在<code class="literal">&lt;adapter&gt;</code>字段中使用<code class="literal">parent</code>属性来标识可以使用通过变化路径的NPIV LUN的物理HBA父级。此字段<code class="literal">scsi_hostN</code>与<code class="literal">vports</code>和<code class="literal">max_vports</code>属性组合以完成父标识。<code class="literal">parent</code> ， <code class="literal">parent_wwnn</code> ， <code class="literal">parent_wwpn</code>或<code class="literal">parent_fabric_wwn</code>属性提供了不同程度的保证，即在主机重新启动后使用相同的HBA。
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">如果未指定<code class="literal">parent</code> ，则<code class="literal">libvirt</code>使用支持NPIV的第一个<code class="literal">scsi_hostN</code>适配器。</li><li class="listitem">如果仅指定了<code class="literal">parent</code> ，则在将其他SCSI主机适配器添加到配置时可能会出现问题。
									</li><li class="listitem">如果指定了<code class="literal">parent_wwnn</code>或<code class="literal">parent_wwpn</code> ，则在主机重新启动后，将使用相同的HBA。
									</li><li class="listitem">如果使用<code class="literal">parent_fabric_wwn</code> ，则在主机重新启动后，选择同一结构上的HBA，而不管使用的<code class="literal">scsi_hostN</code>如何。
									</li></ul></div></div><h6><a id="examples"></a>例子</h6><p>以下是基于vHBA的存储池的XML文件示例。
						</p><p>以下是存储池的示例，它是HBA上唯一的存储池：</p><pre class="programlisting">&lt;pool type='scsi'&gt;
  &lt;name&gt;vhbapool_host3&lt;/name&gt;
  &lt;source&gt;
    &lt;adapter type='fc_host' wwnn='5001a4a93526d0a1' wwpn='5001a4ace3ee047d'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev/disk/by-path&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre><p>以下是存储池的示例，该存储池是使用单个vHBA并使用<code class="literal">parent</code>属性标识SCSI主机设备的多个存储池之一：</p><pre class="programlisting">&lt;pool type='scsi'&gt;
  &lt;name&gt;vhbapool_host3&lt;/name&gt;
  &lt;source&gt;
    &lt;adapter type='fc_host' parent='scsi_host3' wwnn='5001a4a93526d0a1' wwpn='5001a4ace3ee047d'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/dev/disk/by-path&lt;/path&gt;
  &lt;/target&gt;
&lt;/pool&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="assigning-scsi-lun-based-storage-volumes-to-virtual-machines-using-the-cli_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli"></a>使用CLI为基于SCSI LUN的存储卷分配和连接到虚拟机</h4></div></div></div><p>以下提供有关如何配置虚拟机以使用vHBA LUN以及如何在硬件故障后重新连接到公开的LUN的信息。
						</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="prerequisites-assigning-scsi-lun-based-storage-volumes-to-virtual-machines-using-the-cli"></a>先决条件</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">确保有一个或多个vHBA存储池。
									</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="creating-vhba-based-storage-pools-using-the-cli_assigning-scsi-lun-based-storage-volumes-to-virtual-machines-using-the-cli"></a>使用CLI创建基于vHBA的存储池</h5></div></div></div><p>以下提供了有关创建基于vHBA的存储池的说明。
							</p><h7><a id="prerequisites_44"></a>先决条件</h7><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">确保有vHBA。有关更多信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#creating-vhbas_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli" title="创建vHBA">创建vHBA</a> 。
									</li></ul></div><h7><a id="procedure_55"></a>程序</h7><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
										<span class="strong"><strong>在XML文件中定义存储池</strong></span>
									</p><p class="simpara">创建一个临时XML文件，其中包含新设备所需的存储池参数。
									</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>有关所需参数的信息，请参阅<a class="link" href="managing-storage-for-virtual-machines_configuring-and-managing-virtualization.html#vhba-based-storage-pool-parameters_creating-and-assigning-vhba-based-storage-for-virtual-machines-using-the-cli" title="基于vHBA的存储池参数">参数</a> 。
										</p></div></li><li class="listitem"><p class="simpara">
										<span class="strong"><strong>创建存储池</strong></span>
									</p><p class="simpara">使用<code class="literal">virsh pool-define</code>命令根据上一步中创建的XML文件创建持久存储池。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-define ~/guest_images.xml</strong></span>
  Pool defined from guest_images_fs</pre></li></ol></div><div class="informalexample"><p>运行<code class="literal">virsh pool-define</code>命令后，可以删除在步骤1中创建的XML文件。
							</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
										<span class="strong"><strong>验证池是否已创建</strong></span>
									</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证池是否已创建。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   no</pre></li><li class="listitem"><p class="simpara">
										<span class="strong"><strong>启动存储池</strong></span>
									</p><p class="simpara">使用<code class="literal">virsh pool-start</code>命令安装存储池。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-start guest_images_fs</strong></span>
  Pool guest_images_fs started</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">virsh pool-start</code>命令仅对持久存储池是必需的。临时存储池在创建时会自动启动。
										</p></div></li><li class="listitem"><p class="simpara">
										<span class="strong"><strong>[可选]打开自动启动</strong></span>
									</p><p class="simpara">默认情况下，使用<code class="literal">virsh</code>命令定义的存储池未设置为每次启动libvirtd时自动启动。使用<code class="literal">virsh pool-autostart</code>命令将存储池配置为自动启动。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-autostart guest_images_fs</strong></span>
  Pool guest_images_fs marked as autostarted</pre></li><li class="listitem"><p class="simpara">
										<span class="strong"><strong>验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态</strong></span>
									</p><p class="simpara">使用<code class="literal">virsh pool-list</code>命令验证<code class="literal"><span class="emphasis"><em>Autostart</em></span></code>状态。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>

  Name                 State      Autostart
  -----------------------------------------
  default              active     yes
  guest_images_fs      inactive   yes</pre></li><li class="listitem"><p class="simpara">
										<span class="strong"><strong>验证存储池</strong></span>
									</p><p class="simpara">验证是否已正确创建存储池，报告的大小是否符合预期，并且状态报告为<code class="literal"><span class="emphasis"><em>running</em></span></code> 。验证文件系统上目标路径中是否存在<code class="literal">lost+found</code>目录，表明设备已挂载。
									</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-info guest_images_fs</strong></span>
  Name:           guest_images_fs
  UUID:           c7466869-e82a-a66c-2187-dc9d6f0877d0
  State:          running
  Persistent:     yes
  Autostart:      yes
  Capacity:       458.39 GB
  Allocation:     197.91 MB
  Available:      458.20 GB

# <span class="strong"><strong>mount | grep /guest_images</strong></span>
  /dev/sdc1 on /guest_images type ext4 (rw)

# <span class="strong"><strong>ls -la /guest_images</strong></span>
  total 24
  drwxr-xr-x.  3 root root  4096 May 31 19:47 .
  dr-xr-xr-x. 25 root root  4096 May 31 19:38 ..
  drwx------.  2 root root 16384 May 31 14:18 lost+found</pre></li></ol></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating-and-assigning-storage-volumes-using-the-cli_creating-storage-for-virtual-machines-using-the-cli"></a>使用CLI创建和分配存储卷</h3></div></div></div><p>以下提供有关从存储池创建存储卷以及使用CLI将存储卷分配给虚拟机的信息。对于所有类型的存储池，该过程都是相同的。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="prerequisites-creating-and-assigning-storage-volumes-using-the-cli"></a>先决条件</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">主机上具有未分配空间的存储池</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="procedure-creating-and-assigning-storage-volumes-using-the-cli"></a>程序</h4></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
									<span class="strong"><strong>在XML文件中定义存储卷</strong></span>
								</p><p class="simpara">创建包含存储卷参数的临时XML文件。
								</p><p class="simpara">以下是所需存储卷参数的列表：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
											<span class="strong"><strong>name</strong></span> - 存储卷的名称。
										</li><li class="listitem">
											<span class="strong"><strong>allocation</strong></span> - 存储卷的总存储分配。
										</li><li class="listitem">
											<span class="strong"><strong>capacity</strong></span> - 存储卷的逻辑容量。如果卷稀疏，则此值可能与<code class="literal"><span class="emphasis"><em>allocation</em></span></code>值不同。
										</li><li class="listitem"><p class="simpara">
											<span class="strong"><strong>target</strong></span> - 主机系统上存储卷的路径，以及可选的权限和标签。
										</p><p class="simpara">以下显示了存储卷定义XML文件的示例。在此示例中，文件保存到<code class="literal">~/guest_volume.xml</code> 。
										</p><pre class="screen">  &lt;volume&gt;
    &lt;name&gt;volume1&lt;/name&gt;
    &lt;allocation&gt;0&lt;/allocation&gt;
    &lt;capacity&gt;20G&lt;/capacity&gt;
    &lt;target&gt;
      &lt;path&gt;/var/lib/virt/images/sparse.img&lt;/path&gt;
    &lt;/target&gt;
  &lt;/volume&gt;</pre></li></ul></div></li><li class="listitem"><p class="simpara">
									<span class="strong"><strong>创建并分配存储卷</strong></span>
								</p><p class="simpara"><code class="literal">virsh vol-create</code>和<code class="literal">virsh vol-create-as</code>命令用于从大多数存储池类型创建存储卷。
								</p><p class="simpara">以下是不支持<code class="literal">virsh vol-create</code>和<code class="literal">virsh vol-create-as</code>命令的存储池类型列表，以及用于创建存储卷的方法：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
											<span class="strong"><strong>基于GlusterFS</strong></span> - 使用<code class="literal">qemu-img</code>命令创建存储卷。
										</li><li class="listitem">
											<span class="strong"><strong>基于iSCSI</strong></span> - 在iSCSI服务器上预先准备iSCSI LUN。
										</li><li class="listitem">
											<span class="strong"><strong>基于多路径</strong></span> - 使用<code class="literal">multipathd</code>命令准备或管理多路径。
										</li><li class="listitem">
											<span class="strong"><strong>基于vHBA</strong></span> - 提前准备光纤通道卡。
										</li></ul></div><p class="simpara">使用<code class="literal">virsh vol-create</code>命令基于XML文件创建和分配存储卷。在<code class="literal">virsh vol-create</code>命令中指定要将存储卷分配到的虚拟机。
								</p><pre class="literallayout"># <span class="strong"><strong>virsh vol-create guest_images_dir ~/guest_volume.xml</strong></span>
  Vol volume1 created</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>运行<code class="literal">virsh vol-create</code>命令后，可以删除在步骤1中创建的XML文件。
									</p></div><p class="simpara">对于基于GlusterFS，基于多路径和基于RBD的存储池，使用以下XML格式描述存储卷并将其添加到域XML：</p><pre class="screen">  &lt;disk type='network' device='disk'&gt;
    &lt;driver name='qemu' type='raw'/&gt;
    &lt;source protocol='gluster' name='Volume1/Image'&gt;
      &lt;host name='example.org' port='6000'/&gt;
    &lt;/source&gt;
    &lt;target dev='vda' bus='virtio'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
  &lt;/disk&gt;</pre><p class="simpara">对于基于多路径的存储池，请使用以下XML格式描述存储卷，并将其添加到域XML：</p><pre class="screen">&lt;disk type='block' device='disk'&gt;
&lt;driver name='qemu' type='raw'/&gt;
&lt;source dev='/dev/mapper/mpatha' /&gt;
&lt;target dev='sdc' bus='scsi'/&gt;
&lt;/disk&gt;</pre><p class="simpara">对于基于RBD的存储池，请使用以下XML格式描述存储卷，并将其添加到域XML：</p><pre class="screen">  &lt;disk type='network' device='disk'&gt;
    &lt;driver name='qemu' type='raw'/&gt;
    &lt;source protocol='rbd' name='pool/image'&gt;
      &lt;host name='mon1.example.org' port='6321'/&gt;
    &lt;/source&gt;
    &lt;target dev='vdc' bus='virtio'/&gt;
  &lt;/disk&gt;</pre></li></ol></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="deleting-storage-for-virtual-machines-using-the-cli_managing-storage-for-virtual-machines-using-the-cli"></a>使用CLI删除虚拟机的存储</h2></div></div></div><p>以下提供有关使用CLI删除存储池和存储卷的信息。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="deleting-storage-pools-using-the-cli_deleting-storage-for-virtual-machines-using-the-cli"></a>使用CLI删除存储池</h3></div></div></div><p>以下提供有关删除存储池的信息。
					</p><h5><a id="prerequisites_45"></a>先决条件</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">为避免对使用要删除的存储池的其他虚拟机产生负面影响，建议您停止存储池并释放其使用的所有资源。
							</li></ul></div><h5><a id="procedure_56"></a>程序</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">virsh pool-list</code>命令列出已定义的存储池。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>
Name                 State      Autostart
-------------------------------------------
default              active     yes
Downloads            active     yes
RHEL8-Storage-Pool   active     yes</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh pool-destroy</code>命令停止要删除的存储池。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-destroy Downloads</strong></span>
Pool Downloads destroyed</pre></li><li class="listitem"><p class="simpara">（ <span class="emphasis"><em>可选</em></span> ）对于某些类型的存储池，您可以选择使用<code class="literal">virsh pool-delete</code>命令<code class="literal">virsh pool-delete</code>存储池所在的目录。请注意，要删除存储池所在的目录，它必须为空。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-delete Downloads</strong></span>
Pool Downloads deleted</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh pool-undefine</code>命令删除存储<code class="literal">virsh pool-undefine</code> 。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-undefine Downloads</strong></span>
Pool Downloads has been undefined</pre></li><li class="listitem"><p class="simpara">确认已删除存储池。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-list --all</strong></span>
Name                 State      Autostart
-------------------------------------------
default              active     yes
RHEL8-Storage-Pool   active     yes</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="deleting-storage-volumes-using-the-cli_deleting-storage-for-virtual-machines-using-the-cli"></a>使用CLI删除存储卷</h3></div></div></div><p>以下提供有关使用CLI删除存储卷的信息。</p><h5><a id="prerequisites_46"></a>先决条件</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">为避免对使用您要删除的存储卷的虚拟机产生负面影响，建议您使用它释放所有资源。
							</li></ul></div><h5><a id="procedure_57"></a>程序</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">virsh vol-list</code>命令<code class="literal">virsh vol-list</code>存储池中定义的存储卷。该命令必须指定存储卷的名称或路径。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh vol-list --pool RHEL8-Storage-Pool</strong></span>
 Name                 Path
---------------------------------------------------------------
 .bash_history        /home/VirtualMachines/.bash_history
 .bash_logout         /home/VirtualMachines/.bash_logout
 .bash_profile        /home/VirtualMachines/.bash_profile
 .bashrc              /home/VirtualMachines/.bashrc
 .git-prompt.sh       /home/VirtualMachines/.git-prompt.sh
 .gitconfig           /home/VirtualMachines/.gitconfig
 RHEL8_Volume.qcow2   /home/VirtualMachines/RHEL8_Volume.qcow2</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">virsh vol-delete</code>命令删除存储卷。该命令必须指定存储卷的名称或路径以及从中抽象存储卷的存储池。
							</p><pre class="literallayout"># <span class="strong"><strong>virsh pool-delete RHEL8_Volume.qcow2</strong></span>
Pool RHEL8_Volume.qcow2 deleted</pre></li></ol></div></div></div></div></div></body></html>