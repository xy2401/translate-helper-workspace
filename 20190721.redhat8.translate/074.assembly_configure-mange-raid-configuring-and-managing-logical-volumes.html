<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 配置RAID逻辑卷</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 配置RAID逻辑卷</h1></div></div></div><p>LVM支持RAID0 / 1/4/5/6/10。
		</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>RAID逻辑卷不支持群集。虽然可以在一台计算机上专门创建和激活RAID逻辑卷，但不能在多台计算机上同时激活它们。
			</p></div><p>要创建RAID逻辑卷，请将raid类型指定为<code class="literal">lvcreate</code>命令的<code class="literal">--type</code>参数。<a class="xref" href="assembly_configure-mange-raid-configuring-and-managing-logical-volumes.html#tb-raid-types" title="表7.1。RAID段类型">表7.1“RAID段类型”</a>描述了可能的RAID段类型。使用LVM创建RAID逻辑卷后，您可以像激活任何其他LVM逻辑卷一样激活，更改，删除，显示和使用该卷。
		</p><div class="table"><a id="tb-raid-types"></a><p class="title"><strong>表7.1。RAID段类型</strong></p><div class="table-contents"><table border="1" summary="RAID Segment Types"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">细分类型</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID1</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>RAID1镜像。当您指定<code class="literal">-m</code>但未指定条带时，这是<code class="literal">lvcreate</code>命令的<code class="literal">--type</code>参数的默认值。
						</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID4</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>RAID4专用奇偶校验磁盘</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID5</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>与<code class="literal">raid5_ls</code>相同
						</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid5_la</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID5左不对称。
						</p>
						 <p>*通过数据继续旋转奇偶校验0</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid5_ra</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID5右对称。
						</p>
						 <p>*通过数据继续旋转奇偶校验N.</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid5_ls</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID5左对称。
						</p>
						 <p>*数据重启时旋转奇偶校验0</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid5_rs</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID5右对称。
						</p>
						 <p>*数据重启时旋转奇偶校验N.</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID6</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>与<code class="literal">raid6_zr</code>相同
						</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid6_zr</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID6零重启</p>
						 <p>*数据重启时旋转奇偶校验零（从左到右）</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid6_nr</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID6 N重启</p>
						 <p>*数据重启时旋转奇偶校验N（从左到右）</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">raid6_nc</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>* RAID6 N继续</p>
						 <p>*通过数据继续旋转奇偶校验N（从左到右）</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID10</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>*条纹镜子。如果指定<code class="literal">-m</code>并指定大于1的条带数，则这是<code class="literal">lvcreate</code>命令的<code class="literal">--type</code>参数的缺省值。
						</p>
						 <p>*镜组镶边</p>
						 </td></tr><tr><td valign="top" style="text-align:left"> <p>
							<code class="literal">RAID0 / raid0_meta</code>
						</p>
						 </td><td valign="top" style="text-align:left"> <p>条带化。RAID0以条带大小为单位跨多个数据子卷传播逻辑卷数据。这用于提高性能。如果任何数据子卷失败，逻辑卷数据将丢失。
						</p>
						 </td></tr></tbody></table></div></div><p>对于大多数用户，指定五种可用的主要类型之一（ <code class="literal">raid1</code> ， <code class="literal">raid4</code> ， <code class="literal">raid5</code> ， <code class="literal">raid6</code> ， <code class="literal">raid10</code> ）就足够了。有关RAID 5/6使用的不同算法的更多信息，请参阅<a class="link" href="http://www.snia.org/sites/default/files/SNIA_DDF_Technical_Position_v2.0.pdf">http://www.snia.org/sites/default/files/SNIA_DDF_Technical_Position_v2.0.pdf</a>上的<span class="emphasis"><em><span class="citetitle">通用RAID磁盘数据格式规范的</span></em></span>第四章。</p><p>创建RAID逻辑卷时，LVM会为阵列中的每个数据或奇偶校验子卷创建一个大小为一个范围的元数据子卷。例如，创建双向RAID1阵列会生成两个元数据子卷（ <code class="literal">lv_rmeta_0</code>和<code class="literal">lv_rmeta_1</code> ）和两个数据子卷（ <code class="literal">lv_rimage_0</code>和<code class="literal">lv_rimage_1</code> ）。类似地，创建3 <code class="literal">lv_rmeta_0</code>带（加上1个隐式奇偶校验设备）RAID4导致4个元数据子卷（ <code class="literal">lv_rmeta_0</code> ， <code class="literal">lv_rmeta_1</code> ， <code class="literal">lv_rmeta_2</code>和<code class="literal">lv_rmeta_3</code> ）和4个数据子卷（ <code class="literal">lv_rimage_0</code> ， <code class="literal">lv_rimage_1</code> ， <code class="literal">lv_rimage_2</code>和<code class="literal">lv_rimage_3</code> ）。
		</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>您可以使用LVM RAID Calculator应用程序生成用于在RAID存储上创建逻辑卷的命令。此应用程序使用您输入的有关当前或计划存储的信息来生成这些命令。可以在<a class="link" href="https://access.redhat.com/labs/lvmraidcalculator/">https://access.redhat.com/labs/lvmraidcalculator/</a>上找到LVM RAID Calculator应用程序。</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ref_creating-raid-volume-configure-manage-raid"></a>创建RAID逻辑卷</h1></div></div></div><p>本节提供了创建不同类型的RAID逻辑卷的示例命令。
			</p><p>您可以根据为<code class="literal">-m</code>参数指定的值创建具有不同份数的RAID1阵列。同样，您使用<code class="literal">-i argument</code>指定RAID 4/5/6逻辑卷的条带数。您还可以使用<code class="literal">-I</code>参数指定条带大小。
			</p><p>以下命令在卷组<code class="literal">my_vg</code>中创建名为<code class="literal">my_lv</code>的双向RAID1阵列，其大小为1 GB。
			</p><pre class="literallayout"># <code class="literal">lvcreate --type raid1 -m 1 -L 1G -n my_lv my_vg</code></pre><p>以下命令在卷组<code class="literal">my_vg</code>中创建名为<code class="literal">my_lv</code>的RAID5阵列（3个条带+ 1个隐式奇偶校验驱动器），其大小为1千兆字节。请注意，您可以像对LVM条带卷一样指定条带数量;自动添加正确数量的奇偶校验驱动器。
			</p><pre class="literallayout"># <code class="literal">lvcreate --type raid5 -i 3 -L 1G -n my_lv my_vg</code></pre><p>以下命令在卷组<code class="literal">my_vg</code>中创建名为<code class="literal">my_lv</code>的RAID6阵列（3个条带+ 2个隐式奇偶校验驱动器），其大小为1千兆字节。
			</p><pre class="literallayout"># <code class="literal">lvcreate --type raid6 -i 3 -L 1G -n my_lv my_vg</code></pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc_creating-a-striped-logical-volume_configure-manage-raid"></a>创建RAID0（条带化）逻辑卷</h1></div></div></div><p>RAID0逻辑卷以条带大小为单位跨多个数据子卷传播逻辑卷数据。
			</p><p>创建RAID0卷的命令格式如下。
			</p><pre class="literallayout">lvcreate --type raid0[_meta] --stripes <span class="emphasis"><em>Stripes</em></span> --stripesize <span class="emphasis"><em>StripeSize</em></span> <span class="emphasis"><em>VolumeGroup</em></span> [<span class="emphasis"><em>PhysicalVolumePath</em></span> ...]</pre><div class="table"><a id="idm140241349086656"></a><p class="title"><strong>表7.2。RAID0命令创建参数</strong></p><div class="table-contents"><table border="1" summary="RAID0 Command Creation parameters"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">参数</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">--type raid0 [_meta]</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>指定<code class="literal">raid0</code>会创建没有元数据卷的RAID0卷。指定<code class="literal">raid0_meta</code>会创建包含元数据卷的RAID0卷。由于RAID0是非弹性的，因此不必将任何镜像数据块存储为RAID1 / 10，也不必像RAID4 / 5/6那样计算和存储任何奇偶校验块。因此，它不需要元数据卷来保持镜像或奇偶校验块的重新同步进度的状态。但是，从RAID0到RAID4 / <code class="literal">raid0_meta</code>的转换时，元数据卷成为必需的，并且指定<code class="literal">raid0_meta</code>预先分配这些元数据卷以防止相应的分配失败。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">- <span class="emphasis"><em>条纹条纹</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>指定跨越逻辑卷的设备数。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">--stripesize <span class="emphasis"><em>StripeSize</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>指定每个条带的大小（以KB为单位）。这是在移动到下一个设备之前写入一个设备的数据量。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal"><span class="emphasis"><em>VolumeGroup</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>指定要使用的卷组。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal"><span class="emphasis"><em>PhysicalVolumePath</em></span></code> ......</p>
							 </td><td valign="top" style="text-align:left"> <p>指定要使用的设备。如果没有指定，LVM会选择由<span class="emphasis"><em>条纹</em></span>选项，每个条纹中指定的设备数量。
							</p>
							 </td></tr></tbody></table></div></div><p>此示例过程创建一个名为<code class="literal">mylv</code>的LVM RAID0逻辑卷， <code class="literal">mylv</code>在<code class="literal">/dev/sda1</code> ， <code class="literal">/dev/sdb1</code>和<code class="literal">/dev/sdc1</code>的磁盘上对数据进行条<code class="literal">/dev/sdc1</code> 。
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">pvcreate</code>命令将要在卷组中使用的磁盘标记为LVM物理卷。
					</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">警告</h3><p>此命令会破坏<code class="literal">/dev/sda1</code> ， <code class="literal">/dev/sdb1</code>和<code class="literal">/dev/sdc1</code> 。
						</p></div><pre class="literallayout"># <code class="literal">pvcreate /dev/sda1 /dev/sdb1 /dev/sdc1</code>
  Physical volume "/dev/sda1" successfully created
  Physical volume "/dev/sdb1" successfully created
  Physical volume "/dev/sdc1" successfully created</pre></li><li class="listitem"><p class="simpara">创建卷组<code class="literal">myvg</code> 。以下命令将创建卷组<code class="literal">myvg</code> 。
					</p><pre class="literallayout"># <code class="literal">vgcreate myvg /dev/sda1 /dev/sdb1 /dev/sdc1</code>
  Volume group "myvg" successfully created</pre><p class="simpara">您可以使用<code class="literal">vgs</code>命令显示新卷组的属性。
					</p><pre class="literallayout"># <code class="literal">vgs</code>
  VG   #PV #LV #SN Attr   VSize  VFree
  myvg   3   0   0 wz--n- 51.45G 51.45G</pre></li><li class="listitem"><p class="simpara">从您创建的卷组创建RAID0逻辑卷。以下命令从卷组<code class="literal">myvg</code>创建RAID0卷<code class="literal">mylv</code> 。此示例创建一个大小为2千兆字节的逻辑卷，其中包含三个条带，条带大小为4千字节。
					</p><pre class="literallayout"># <code class="literal">lvcreate --type raid0 -L 2G --stripes 3 --stripesize 4 -n mylv myvg</code>
  Rounding size 2.00 GiB (512 extents) up to stripe boundary size 2.00 GiB(513 extents).
  Logical volume "mylv" created.</pre></li><li class="listitem"><p class="simpara">在RAID0逻辑卷上创建文件系统。以下命令在逻辑卷上创建<code class="literal">ext4</code>文件系统。
					</p><pre class="literallayout"># <code class="literal">mkfs.ext4 /dev/myvg/mylv</code>
mke2fs 1.44.3 (10-July-2018)
Creating filesystem with 525312 4k blocks and 131376 inodes
Filesystem UUID: 9d4c0704-6028-450a-8b0a-8875358c0511
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912

Allocating group tables: done
Writing inode tables: done
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done</pre><p class="simpara">以下命令装入逻辑卷并报告文件系统磁盘空间使用情况。
					</p><pre class="literallayout"># <code class="literal">mount /dev/myvg/mylv /mnt</code>
# <code class="literal">df</code>
Filesystem             1K-blocks     Used  Available Use% Mounted on
/dev/mapper/myvg-mylv    2002684     6168    1875072   1% /mnt</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc_controlling-raid-initialization-configure-manage-raid"></a>控制初始化RAID卷的速率</h1></div></div></div><p>创建RAID10逻辑卷时，使用<code class="literal">sync</code>操作初始化逻辑卷所需的后台I / O可以挤出对LVM设备的其他I / O操作，例如卷组元数据的更新，尤其是在创建多个RAID逻辑时卷。这可能导致其他LVM操作变慢。
			</p><p>您可以通过实施恢复限制来控制RAID逻辑卷的初始化速率。您可以通过使用<code class="literal">lvcreate</code>命令的<code class="literal">--minrecoveryrate</code>和<code class="literal">--maxrecoveryrate</code>选项设置这些操作的最小和最大I / O速率来控制执行<code class="literal">sync</code>操作的速率。您可以如下指定这些选项。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
						<code class="literal">-  maxrecoveryrate <span class="emphasis"><em>Rate</em></span> [bBsSkKmMgG]</code>
					</p><p class="simpara">设置RAID逻辑卷的最大恢复速率，以便它不会挤出标称I / O操作。<span class="emphasis"><em>速率</em></span>指定为阵列中每个设备的每秒数量。如果没有给出后缀，则假定为kiB / sec / device。将恢复率设置为0意味着它将是无限制的。
					</p></li><li class="listitem"><p class="simpara">
						<code class="literal">--minrecoveryrate <span class="emphasis"><em>Rate</em></span> [bBsSkKmMgG]</code>
					</p><p class="simpara">设置RAID逻辑卷的最低恢复速率，以确保<code class="literal">sync</code>操作的I / O实现最小吞吐量，即使存在大量标称I / O.<span class="emphasis"><em>速率</em></span>指定为阵列中每个设备的每秒数量。如果没有给出后缀，则假定为kiB / sec / device。
					</p></li></ul></div><p>以下命令创建一个双向RAID10阵列，其中包含3个条带，大小为10千兆字节，最大恢复速率为128 kiB /秒/设备。该数组名为<code class="literal">my_lv</code> ，位于卷组<code class="literal">my_vg</code> 。
			</p><pre class="literallayout"># <code class="literal">lvcreate --type raid10 -i 2 -m 1 -L 10G --maxrecoveryrate 128 -n my_lv my_vg</code></pre><p>您还可以为RAID清理操作指定最小和最大恢复速率。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc_converting-linear-to-raid-configure-manage-raid"></a>将Linear设备转换为RAID设备</h1></div></div></div><p>您可以使用<code class="literal">lvconvert</code>命令的<code class="literal">--type</code>参数将现有线性逻辑卷转换为RAID设备。
			</p><p>以下命令将卷组<code class="literal">my_vg</code>的线性逻辑卷<code class="literal">my_lv</code>转换为双向RAID1阵列。
			</p><pre class="literallayout"># <code class="literal">lvconvert --type raid1 -m 1 my_vg/my_lv</code></pre><p>由于RAID逻辑卷由元数据和数据子卷对组成，因此在将线性设备转换为RAID1阵列时，会创建新的元数据子卷，并将其与原始逻辑卷相关联（其中一个）与线性卷相同的物理卷是的。附加图像被添加到元数据/数据子卷对中。例如，如果原始设备如下：</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV     Copy%  Devices
  my_lv         /dev/sde1(0)</pre><p>转换为双向RAID1阵列后，设备包含以下数据和元数据子卷对：</p><pre class="literallayout"># <code class="literal">lvconvert --type raid1 -m 1 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            6.25   my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(0)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rmeta_0]         /dev/sde1(256)
  [my_lv_rmeta_1]         /dev/sdf1(0)</pre><p>如果与原始逻辑卷配对的元数据映像无法放在同一物理卷上，则<code class="literal">lvconvert</code>将失败。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-converting-raid1-to-linear-configure-manage-raid"></a>将LVM RAID1逻辑卷转换为LVM线性逻辑卷</h1></div></div></div><p>您可以使用<code class="literal">lvconvert</code>命令将现有RAID1 LVM逻辑卷转换为LVM线性逻辑卷， <code class="literal">lvconvert</code>是指定<code class="literal">-m0</code>参数。这将删除构成RAID阵列的所有RAID数据子卷和所有RAID元数据子卷，将顶级RAID1映像保留为线性逻辑卷。
			</p><p>以下示例显示现有LVM RAID1逻辑卷。
			</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)</pre><p>以下命令将LVM RAID1逻辑卷<code class="literal">my_vg/my_lv</code>转换为LVM线性设备。
			</p><pre class="literallayout"># <code class="literal">lvconvert -m0 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV      Copy%  Devices
  my_lv          /dev/sde1(1)</pre><p>将LVM RAID1逻辑卷转换为LVM线性卷时，可以指定要删除的物理卷。以下示例显示了由两个映像组成的LVM RAID1逻辑卷的布局： <code class="literal">/dev/sda1</code>和<code class="literal">/dev/sdb1</code> 。在此示例中， <code class="literal">lvconvert</code>命令指定要删除<code class="literal">/dev/sda1</code> ，将<code class="literal">/dev/sdb1</code>保留为组成线性设备的物理卷。
			</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdb1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdb1(0)
# <code class="literal">lvconvert -m0 my_vg/my_lv /dev/sda1</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV    Copy%  Devices
  my_lv        /dev/sdb1(1)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-converting-mirror-to-raid-configure-manage-raid"></a>将镜像LVM设备转换为RAID1设备</h1></div></div></div><p>可以将现有镜像LVM设备转换与段类型的<code class="literal">mirror</code>与一个RAID1 LVM设备<code class="literal">lvconvert</code>通过指定命令<code class="literal">--type raid1</code>参数。这会将镜像子卷（ <code class="literal"><span class="strong"><strong><span class="emphasis"><em>mimage</em></span></strong></span></code> ）重命名为RAID子卷（ <code class="literal"><span class="strong"><strong><span class="emphasis"><em>rimage</em></span></strong></span></code> ）。此外，移除镜像日志，并为与相应数据子卷相同的物理卷上的数据子卷创建元数据子卷（ <code class="literal"><span class="strong"><strong><span class="emphasis"><em>rmeta</em></span></strong></span></code> ）。
			</p><p>以下示例显示了镜像逻辑卷<code class="literal">my_vg/my_lv</code>的布局。</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             15.20 my_lv_mimage_0(0),my_lv_mimage_1(0)
  [my_lv_mimage_0]        /dev/sde1(0)
  [my_lv_mimage_1]        /dev/sdf1(0)
  [my_lv_mlog]            /dev/sdd1(0)</pre><p>以下命令将镜像逻辑卷<code class="literal">my_vg/my_lv</code>转换为RAID1逻辑卷。
			</p><pre class="literallayout"># <code class="literal">lvconvert --type raid1 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(0)
  [my_lv_rimage_1]        /dev/sdf1(0)
  [my_lv_rmeta_0]         /dev/sde1(125)
  [my_lv_rmeta_1]         /dev/sdf1(125)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-resizing-raid-configure-manage-raid"></a>调整RAID逻辑卷的大小</h1></div></div></div><p>您可以通过以下方式调整RAID逻辑卷的大小;</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">您可以使用<code class="literal">lvresize</code>或<code class="literal">lvextend</code>命令增加任何类型的RAID逻辑卷的大小。这不会改变RAID映像的数量。对于条带RAID逻辑卷，应用与创建条带化RAID逻辑卷时相同的条带舍入约束。
					</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">您可以使用<code class="literal">lvresize</code>或<code class="literal">lvreduce</code>命令<code class="literal">lvresize</code>任何类型的RAID逻辑卷的大小。这不会改变RAID映像的数量。与<code class="literal">lvextend</code>命令一样，应用与创建条带化RAID逻辑卷时相同的条带舍入约束。
					</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">您可以使用<code class="literal">lvconvert</code>命令的<code class="literal">--stripes N</code>参数更改条带RAID逻辑卷（ <code class="literal">raid4/5/6/10</code>上的条带数。这会增加或减少RAID逻辑卷的大小，增加或删除条带的容量。请注意， <code class="literal">raid10</code>卷只能添加条纹。此功能是RAID <span class="emphasis"><em>重塑</em></span>功能的一部分，允许您在保持相同RAID级别的同时更改RAID逻辑卷的属性。有关RAID重新整形的信息以及使用<code class="literal">lvconvert</code>命令重塑RAID逻辑卷的<code class="literal">lvmraid</code> ，请参见<code class="literal">lvmraid</code> （7）手册页。
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-changing-raid-imagenum-configure-manage-raid"></a>更改现有RAID1设备中的映像数</h1></div></div></div><p>您可以更改现有RAID1阵列中的图像数量，就像在早期LVM镜像实现中更改图像数量一样。使用<code class="literal">lvconvert</code>命令指定要添加或删除的其他元数据/数据子卷对的数量。
			</p><p>使用<code class="literal">lvconvert</code>命令将图像添加到RAID1设备时，可以指定生成的设备的图像总数，也可以指定要添加到设备的图像数。您还可以选择指定新元数据/数据映像对将驻留在哪些物理卷上。
			</p><p>元数据子卷（名为<code class="literal"><span class="strong"><strong><span class="emphasis"><em>rmeta</em></span></strong></span></code> ）始终存在于与其数据子卷对应物<code class="literal"><span class="strong"><strong><span class="emphasis"><em>rimage</em></span></strong></span></code>相同的物理设备上。元数据/数据子卷对不会在与RAID阵列中另一个元数据/数据子卷对相同的物理卷上创建（除非您<code class="literal">--alloc anywhere</code>指定<code class="literal">--alloc anywhere</code> ）。
			</p><p>将映像添加到RAID1卷的命令格式如下：</p><pre class="literallayout">lvconvert -m <span class="emphasis"><em>new_absolute_count</em></span> vg/lv [<span class="emphasis"><em>removable_PVs</em></span>]
lvconvert -m +<span class="emphasis"><em>num_additional_images</em></span> vg/lv [<span class="emphasis"><em>removable_PVs</em></span>]</pre><p>例如，以下命令显示LVM设备<code class="literal">my_vg/my_lv</code> ，它是一个双向RAID1阵列：</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV                Copy%  Devices
  my_lv             6.25    my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]         /dev/sde1(0)
  [my_lv_rimage_1]         /dev/sdf1(1)
  [my_lv_rmeta_0]          /dev/sde1(256)
  [my_lv_rmeta_1]          /dev/sdf1(0)</pre><p>以下命令将双向RAID1设备<code class="literal">my_vg/my_lv</code>转换为3路RAID1设备：</p><pre class="literallayout"># <code class="literal">lvconvert -m 2 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv              6.25 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sde1(0)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rimage_2]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sde1(256)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  [my_lv_rmeta_2]         /dev/sdg1(0)</pre><p>将映像添加到RAID1阵列时，可以指定要用于映像的物理卷。以下命令将双向RAID1设备<code class="literal">my_vg/my_lv</code>转换为3路RAID1设备，指定物理卷<code class="literal">/dev/sdd1</code>用于阵列：</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             56.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdb1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdb1(0)
# <code class="literal">lvconvert -m 2 my_vg/my_lv /dev/sdd1</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             28.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdb1(1)
  [my_lv_rimage_2]        /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdb1(0)
  [my_lv_rmeta_2]         /dev/sdd1(0)</pre><p>要从RAID1阵列中删除图像，请使用以下命令。使用<code class="literal">lvconvert</code>命令从RAID1设备删除图像时，可以指定生成的设备的图像总数，也可以指定要从设备中删除的图像数。您还可以选择指定从中删除设备的物理卷。
			</p><pre class="literallayout">lvconvert -m <span class="emphasis"><em>new_absolute_count</em></span> <span class="emphasis"><em>vg/lv</em></span> [<span class="emphasis"><em>removable_PVs</em></span>]
lvconvert -m -<span class="emphasis"><em>num_fewer_images</em></span> <span class="emphasis"><em>vg/lv</em></span> [<span class="emphasis"><em>removable_PVs</em></span>]</pre><p>另外，当移除图像及其相关联的元数据子体积时，任何更高编号的图像将向下移动以填充该槽。如果删除<code class="literal">lv_rimage_1</code>从3路RAID1阵列由<code class="literal">lv_rimage_0</code> ， <code class="literal">lv_rimage_1</code>和<code class="literal">lv_rimage_2</code> ，这导致一个RAID1阵列由<code class="literal">lv_rimage_0</code>和<code class="literal">lv_rimage_1</code> 。子卷<code class="literal">lv_rimage_2</code>将被重命名并接管空槽，变为<code class="literal">lv_rimage_1</code> 。
			</p><p>以下示例显示了3路RAID1逻辑卷<code class="literal">my_vg/my_lv</code>的布局。</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rimage_2]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  [my_lv_rmeta_2]         /dev/sdg1(0)</pre><p>以下命令将3路RAID1逻辑卷转换为双向RAID1逻辑卷。
			</p><pre class="literallayout"># <code class="literal">lvconvert -m1 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)</pre><p>以下命令将3路RAID1逻辑卷转换为双向RAID1逻辑卷，指定包含要删除的映像的物理卷为<code class="literal">/dev/sde1</code> 。
			</p><pre class="literallayout"># <code class="literal">lvconvert -m1 my_vg/my_lv /dev/sde1</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sdf1(1)
  [my_lv_rimage_1]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sdf1(0)
  [my_lv_rmeta_1]         /dev/sdg1(0)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-splitting-raid-image-configure-manage-raid"></a>将RAID映像拆分为单独的逻辑卷</h1></div></div></div><p>您可以拆分RAID逻辑卷的映像以形成新的逻辑卷。
			</p><p>拆分RAID映像的命令格式如下：</p><pre class="literallayout">lvconvert --splitmirrors <span class="emphasis"><em>count</em></span> -n <span class="emphasis"><em>splitname</em></span> <span class="emphasis"><em>vg/lv</em></span> [<span class="emphasis"><em>removable_PVs</em></span>]</pre><p>就像从现有RAID1逻辑卷中删除RAID映像一样，当您从设备中间删除RAID数据子卷（及其关联的元数据子卷）时，任何更高编号的图像将向下移动以填充插槽。因此，构成RAID阵列的逻辑卷上的索引号将是一个完整的整数序列。
			</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>如果RAID1阵列尚未同步，则无法拆分RAID映像。
				</p></div><p>以下示例将双向RAID1逻辑卷<code class="literal">my_lv</code>拆分为两个线性逻辑卷<code class="literal">my_lv</code>和<code class="literal">new</code> 。
			</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             12.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
# <code class="literal">lvconvert --splitmirror 1 -n new my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV      Copy%  Devices
  my_lv          /dev/sde1(1)
  new            /dev/sdf1(1)</pre><p>以下示例将3路RAID1逻辑卷<code class="literal">my_lv</code>拆分为双向RAID1逻辑卷<code class="literal">my_lv</code>和线性逻辑卷<code class="literal">new</code>
			</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rimage_2]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  [my_lv_rmeta_2]         /dev/sdg1(0)
# <code class="literal">lvconvert --splitmirror 1 -n new my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV            Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  new                     /dev/sdg1(1)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-split-merge-raid-image-configure-manage-raid"></a>拆分和合并RAID映像</h1></div></div></div><p>可以暂时分裂出一个RAID1阵列的图像为只读，同时保持轨道的任何变化通过使用使用<code class="literal">--trackchanges</code>与结合参数<code class="literal">--splitmirrors</code>所述的论点<code class="literal">lvconvert</code>命令。这允许您稍后将图像合并回数组，同时仅重新同步自分割图像以来已更改的阵列部分。
			</p><p>用于拆分RAID映像的<code class="literal">lvconvert</code>命令的格式如下。
			</p><pre class="literallayout">lvconvert --splitmirrors <span class="emphasis"><em>count</em></span> --trackchanges <span class="emphasis"><em>vg/lv</em></span> [<span class="emphasis"><em>removable_PVs</em></span>]</pre><p>使用<code class="literal">--trackchanges</code>参数拆分RAID映像时，可以指定要拆分的映像，但不能更改要拆分的卷的名称。此外，生成的卷具有以下约束。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">您创建的新卷是只读的。
					</li><li class="listitem">您无法调整新卷的大小。
					</li><li class="listitem">您无法重命名剩余的阵列。
					</li><li class="listitem">您无法调整剩余阵列的大小。
					</li><li class="listitem">您可以单独激活新卷和剩余阵列。
					</li></ul></div><p>可以合并这是分裂与图像<code class="literal">--trackchanges</code>通过执行随后的指定的参数<code class="literal">lvconvert</code>与命令<code class="literal">--merge</code>参数。合并图像时，仅重新分割自分割图像以来已更改的阵列部分。
			</p><p>用于合并RAID映像的<code class="literal">lvconvert</code>命令的格式如下。
			</p><pre class="literallayout">lvconvert --merge <span class="emphasis"><em>raid_image</em></span></pre><p>以下示例创建RAID1逻辑卷，然后在跟踪对剩余阵列的更改时从该卷中分离出图像。
			</p><pre class="literallayout"># <code class="literal">lvcreate --type raid1 -m 2 -L 1G -n my_lv my_vg</code>
  Logical volume "my_lv" created
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sdb1(1)
  [my_lv_rimage_1]        /dev/sdc1(1)
  [my_lv_rimage_2]        /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sdb1(0)
  [my_lv_rmeta_1]         /dev/sdc1(0)
  [my_lv_rmeta_2]         /dev/sdd1(0)
# <code class="literal">lvconvert --splitmirrors 1 --trackchanges my_vg/my_lv</code>
  my_lv_rimage_2 split from my_lv for read-only purposes.
  Use 'lvconvert --merge my_vg/my_lv_rimage_2' to merge back into my_lv
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sdb1(1)
  [my_lv_rimage_1]        /dev/sdc1(1)
  my_lv_rimage_2          /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sdb1(0)
  [my_lv_rmeta_1]         /dev/sdc1(0)
  [my_lv_rmeta_2]         /dev/sdd1(0)</pre><p>以下示例在跟踪对剩余阵列的更改时从RAID1卷中分离图像，然后将卷合并回到阵列中。
			</p><pre class="literallayout"># <code class="literal">lvconvert --splitmirrors 1 --trackchanges my_vg/my_lv</code>
  lv_rimage_1 split from my_lv for read-only purposes.
  Use 'lvconvert --merge my_vg/my_lv_rimage_1' to merge back into my_lv
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sdc1(1)
  my_lv_rimage_1          /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sdc1(0)
  [my_lv_rmeta_1]         /dev/sdd1(0)
# <code class="literal">lvconvert --merge my_vg/my_lv_rimage_1</code>
  my_vg/my_lv_rimage_1 successfully merged back into my_vg/my_lv
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sdc1(1)
  [my_lv_rimage_1]        /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sdc1(0)
  [my_lv_rmeta_1]         /dev/sdd1(0)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-setting-raid-fault-policy-configure-manage-raid"></a>设置RAID故障策略</h1></div></div></div><p>LVM RAID基于<code class="literal">lvm.conf</code>文件中<code class="literal">raid_fault_policy</code>字段定义的首选项以自动方式处理设备故障。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">如果<code class="literal">raid_fault_policy</code>字段设置为<code class="literal">allocate</code> ，系统将尝试使用卷组中的备用设备替换故障设备。如果没有可用的备用设备，则会将其报告给系统日志。
					</li><li class="listitem">如果<code class="literal">raid_fault_policy</code>字段设置为<code class="literal">warn</code> ，系统将发出警告，日志将指示设备已发生故障。这允许用户确定要采取的行动方案。
					</li></ul></div><p>只要剩余足够的设备来支持可用性，RAID逻辑卷将继续运行。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="raid-allocate-faultpolicy"></a>分配RAID故障策略</h2></div></div></div><p>在以下示例中， <code class="literal">raid_fault_policy</code>字段设置为在<code class="literal">lvm.conf</code>文件中进行<code class="literal">allocate</code> 。RAID逻辑卷的布局如下。
				</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sde1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rimage_2]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sde1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  [my_lv_rmeta_2]         /dev/sdg1(0)</pre><p>如果<code class="literal">/dev/sde</code>设备出现故障，系统日志将显示错误消息。
				</p><pre class="literallayout"># <code class="literal">grep lvm /var/log/messages</code>
Jan 17 15:57:18 bp-01 lvm[8599]: Device #0 of raid1 array, my_vg-my_lv, has failed.
Jan 17 15:57:18 bp-01 lvm[8599]: /dev/sde1: read failed after 0 of 2048 at
250994294784: Input/output error
Jan 17 15:57:18 bp-01 lvm[8599]: /dev/sde1: read failed after 0 of 2048 at
250994376704: Input/output error
Jan 17 15:57:18 bp-01 lvm[8599]: /dev/sde1: read failed after 0 of 2048 at 0:
Input/output error
Jan 17 15:57:18 bp-01 lvm[8599]: /dev/sde1: read failed after 0 of 2048 at
4096: Input/output error
Jan 17 15:57:19 bp-01 lvm[8599]: Couldn't find device with uuid
3lugiV-3eSP-AFAR-sdrP-H20O-wM2M-qdMANy.
Jan 17 15:57:27 bp-01 lvm[8599]: raid1 array, my_vg-my_lv, is not in-sync.
Jan 17 15:57:36 bp-01 lvm[8599]: raid1 array, my_vg-my_lv, is now in-sync.</pre><p>由于<code class="literal">raid_fault_policy</code>字段已设置为<code class="literal">allocate</code> ，因此故障设备将替换为卷组中的新设备。
				</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices vg</code>
  Couldn't find device with uuid 3lugiV-3eSP-AFAR-sdrP-H20O-wM2M-qdMANy.
  LV            Copy%  Devices
  lv            100.00 lv_rimage_0(0),lv_rimage_1(0),lv_rimage_2(0)
  [lv_rimage_0]        /dev/sdh1(1)
  [lv_rimage_1]        /dev/sdf1(1)
  [lv_rimage_2]        /dev/sdg1(1)
  [lv_rmeta_0]         /dev/sdh1(0)
  [lv_rmeta_1]         /dev/sdf1(0)
  [lv_rmeta_2]         /dev/sdg1(0)</pre><p>请注意，即使更换了故障设备，显示仍会指示LVM无法找到故障设备。这是因为，虽然故障设备已从RAID逻辑卷中删除，但故障设备尚未从卷组中删除。要从卷组中删除故障设备，可以执行<code class="literal">vgreduce --removemissing <span class="emphasis"><em>VG</em></span></code> 。</p><p>如果<code class="literal">raid_fault_policy</code>已设置为<code class="literal">allocate</code>但没有备用设备，则分配将失败，保持逻辑卷<code class="literal">raid_fault_policy</code> 。如果分配失败，您可以选择修复驱动器，然后使用<code class="literal">lvchange</code>命令的<code class="literal">--refresh</code>选项启动故障设备的恢复。或者，您可以替换发生故障的设备。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="raid-warn-faultpolicy"></a>警告RAID故障策略</h2></div></div></div><p>在以下示例中， <code class="literal">raid_fault_policy</code>字段已设置为在<code class="literal">lvm.conf</code>文件中<code class="literal">warn</code> 。RAID逻辑卷的布局如下。
				</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sdh1(1)
  [my_lv_rimage_1]        /dev/sdf1(1)
  [my_lv_rimage_2]        /dev/sdg1(1)
  [my_lv_rmeta_0]         /dev/sdh1(0)
  [my_lv_rmeta_1]         /dev/sdf1(0)
  [my_lv_rmeta_2]         /dev/sdg1(0)</pre><p>如果<code class="literal">/dev/sdh</code>设备出现故障，系统日志将显示错误消息。但是，在这种情况下，LVM不会通过替换其中一个映像自动尝试修复RAID设备。相反，如果设备发生故障，您可以使用<code class="literal">lvconvert</code>命令的<code class="literal">--repair</code>参数替换设备。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="assembly_replacing-a-raid-device-configure-manage-raid"></a>更换逻辑卷中的RAID设备</h1></div></div></div><p>您可以使用<code class="literal">lvconvert</code>命令替换逻辑卷中的RAID设备。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">如果出现了RAID设备上没有失败，使用<code class="literal">--replace</code>中的参数<code class="literal">lvconvert</code>命令替换设备。
					</li><li class="listitem">如果RAID设备出现故障，请使用<code class="literal">lvconvert</code>命令的<code class="literal">--repair</code>参数替换故障设备。
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="proc-replacing-raid-device-with-no-failure-replacing-a-raid-device"></a>更换未发生故障的RAID设备</h2></div></div></div><p>在一个逻辑卷替换RAID设备，则使用<code class="literal">--replace</code>所述的论点<code class="literal">lvconvert</code>命令。请注意，如果RAID设备出现故障，此命令将不起作用。
				</p><p><code class="literal">lvconvert --replace</code>命令的格式如下。
				</p><pre class="literallayout">lvconvert --replace <span class="emphasis"><em>dev_to_remove</em></span> <span class="emphasis"><em>vg/lv</em></span> [<span class="emphasis"><em>possible_replacements</em></span>]</pre><p>以下示例创建RAID1逻辑卷，然后替换该卷中的设备。
				</p><pre class="literallayout"># <code class="literal">lvcreate --type raid1 -m 2 -L 1G -n my_lv my_vg</code>
  Logical volume "my_lv" created
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sdb1(1)
  [my_lv_rimage_1]        /dev/sdb2(1)
  [my_lv_rimage_2]        /dev/sdc1(1)
  [my_lv_rmeta_0]         /dev/sdb1(0)
  [my_lv_rmeta_1]         /dev/sdb2(0)
  [my_lv_rmeta_2]         /dev/sdc1(0)
# <code class="literal">lvconvert --replace /dev/sdb2 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             37.50 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sdb1(1)
  [my_lv_rimage_1]        /dev/sdc2(1)
  [my_lv_rimage_2]        /dev/sdc1(1)
  [my_lv_rmeta_0]         /dev/sdb1(0)
  [my_lv_rmeta_1]         /dev/sdc2(0)
  [my_lv_rmeta_2]         /dev/sdc1(0)</pre><p>以下示例创建RAID1逻辑卷，然后替换该卷中的设备，指定要用于替换的物理卷。
				</p><pre class="literallayout"># <code class="literal">lvcreate --type raid1 -m 1 -L 100 -n my_lv my_vg</code>
  Logical volume "my_lv" created
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdb1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdb1(0)
# <code class="literal">pvs</code>
  PV          VG       Fmt  Attr PSize    PFree
  /dev/sda1   my_vg    lvm2 a--  1020.00m  916.00m
  /dev/sdb1   my_vg    lvm2 a--  1020.00m  916.00m
  /dev/sdc1   my_vg    lvm2 a--  1020.00m 1020.00m
  /dev/sdd1   my_vg    lvm2 a--  1020.00m 1020.00m
# <code class="literal">lvconvert --replace /dev/sdb1 my_vg/my_lv /dev/sdd1</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             28.00 my_lv_rimage_0(0),my_lv_rimage_1(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdd1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdd1(0)</pre><p>您可以通过指定多个<code class="literal">replace</code>参数一次替换多个RAID设备，如以下示例所示。
				</p><pre class="literallayout"># <code class="literal">lvcreate --type raid1 -m 2 -L 100 -n my_lv my_vg</code>
  Logical volume "my_lv" created
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv            100.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdb1(1)
  [my_lv_rimage_2]        /dev/sdc1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdb1(0)
  [my_lv_rmeta_2]         /dev/sdc1(0)
# <code class="literal">lvconvert --replace /dev/sdb1 --replace /dev/sdc1 my_vg/my_lv</code>
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Copy%  Devices
  my_lv             60.00 my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]        /dev/sda1(1)
  [my_lv_rimage_1]        /dev/sdd1(1)
  [my_lv_rimage_2]        /dev/sde1(1)
  [my_lv_rmeta_0]         /dev/sda1(0)
  [my_lv_rmeta_1]         /dev/sdd1(0)
  [my_lv_rmeta_2]         /dev/sde1(0)</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="proc-replacing-failed-raid-device-replacing-a-raid-device"></a>更换逻辑卷中的故障RAID设备</h2></div></div></div><p>RAID与传统的LVM镜像不同。LVM镜像需要删除故障设备或镜像逻辑卷将挂起。RAID阵列可以继续运行故障设备。事实上，对于RAID1以外的RAID类型，删除设备意味着转换为较低级别的RAID（例如，从RAID6转换为RAID5，或从RAID4或RAID5转换为RAID0）。因此，LVM允许您使用<code class="literal">lvconvert</code>命令的<code class="literal">--repair</code>参数在一步解决方案中替换RAID卷中的故障设备，而不是无条件地移除故障设备并可能分配替换设备。
				</p><p>在以下示例中，RAID逻辑卷的布局如下。
				</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  LV               Cpy%Sync Devices
  my_lv            100.00   my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]          /dev/sde1(1)
  [my_lv_rimage_1]          /dev/sdc1(1)
  [my_lv_rimage_2]          /dev/sdd1(1)
  [my_lv_rmeta_0]           /dev/sde1(0)
  [my_lv_rmeta_1]           /dev/sdc1(0)
  [my_lv_rmeta_2]           /dev/sdd1(0)</pre><p>如果<code class="literal">/dev/sdc</code>设备出现故障，则<code class="literal">lvs</code>命令的输出如下所示。
				</p><pre class="literallayout"># <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  /dev/sdc: open failed: No such device or address
  Couldn't find device with uuid A4kRl2-vIzA-uyCb-cci7-bOod-H5tX-IzH4Ee.
  WARNING: Couldn't find all devices for LV my_vg/my_lv_rimage_1 while checking used and assumed devices.
  WARNING: Couldn't find all devices for LV my_vg/my_lv_rmeta_1 while checking used and assumed devices.
  LV               Cpy%Sync Devices
  my_lv            100.00   my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]          /dev/sde1(1)
  [my_lv_rimage_1]          [unknown](1)
  [my_lv_rimage_2]          /dev/sdd1(1)
  [my_lv_rmeta_0]           /dev/sde1(0)
  [my_lv_rmeta_1]           [unknown](0)
  [my_lv_rmeta_2]           /dev/sdd1(0)</pre><p>使用以下命令替换发生故障的设备并显示逻辑卷。
				</p><pre class="literallayout"># <code class="literal">lvconvert --repair my_vg/my_lv</code>
  /dev/sdc: open failed: No such device or address
  Couldn't find device with uuid A4kRl2-vIzA-uyCb-cci7-bOod-H5tX-IzH4Ee.
  WARNING: Couldn't find all devices for LV my_vg/my_lv_rimage_1 while checking used and assumed devices.
  WARNING: Couldn't find all devices for LV my_vg/my_lv_rmeta_1 while checking used and assumed devices.
Attempt to replace failed RAID images (requires full device resync)? [y/n]: y
  Faulty devices in my_vg/my_lv successfully replaced.
# <code class="literal">lvs -a -o name,copy_percent,devices my_vg</code>
  /dev/sdc: open failed: No such device or address
  /dev/sdc1: open failed: No such device or address
  Couldn't find device with uuid A4kRl2-vIzA-uyCb-cci7-bOod-H5tX-IzH4Ee.
  LV               Cpy%Sync Devices
  my_lv            43.79    my_lv_rimage_0(0),my_lv_rimage_1(0),my_lv_rimage_2(0)
  [my_lv_rimage_0]          /dev/sde1(1)
  [my_lv_rimage_1]          /dev/sdb1(1)
  [my_lv_rimage_2]          /dev/sdd1(1)
  [my_lv_rmeta_0]           /dev/sde1(0)
  [my_lv_rmeta_1]           /dev/sdb1(0)
  [my_lv_rmeta_2]           /dev/sdd1(0)</pre><p>请注意，即使更换了故障设备，显示仍会指示LVM无法找到故障设备。这是因为，虽然故障设备已从RAID逻辑卷中删除，但故障设备尚未从卷组中删除。要从卷组中删除故障设备，可以执行<code class="literal">vgreduce --removemissing <span class="emphasis"><em>VG</em></span></code> 。</p><p>如果设备故障是暂时性故障或您能够修复发生故障的设备，则可以使用<code class="literal">lvchange</code>命令的<code class="literal">--refresh</code>选项启动故障设备的恢复。
				</p><p>以下命令刷新逻辑卷。
				</p><pre class="literallayout"># <code class="literal">lvchange --refresh my_vg/my_lv</code></pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-scrubbing-raid-volume-configure-manage-raid"></a>检查RAID逻辑卷中的数据一致性（RAID清理）</h1></div></div></div><p>LVM为RAID逻辑卷提供清理支持。RAID清理是读取阵列中所有数据和奇偶校验块并检查它们是否一致的过程。
			</p><p>使用<code class="literal">lvchange</code>命令的<code class="literal">--syncaction</code>选项启动RAID清理操作。您指定<code class="literal">check</code>或<code class="literal">repair</code>操作。<code class="literal">check</code>操作遍历数组并记录数组中的差异数，但不会修复它们。<code class="literal">repair</code>操作会在发现差异时更正差异。
			</p><p>擦除RAID逻辑卷的命令格式如下：</p><pre class="literallayout">lvchange --syncaction {check|repair} <span class="emphasis"><em>vg/raid_lv</em></span></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">lvchange --syncaction repair <span class="emphasis"><em>vg/raid_lv</em></span></code>操作不执行与<code class="literal">lvconvert --repair <span class="emphasis"><em>vg/raid_lv</em></span></code>操作相同的功能。<code class="literal">lvchange --syncaction repair</code>操作在阵列上启动后台同步操作，而<code class="literal">lvconvert --repair</code>操作用于修复/替换镜像或RAID逻辑卷中的故障设备。
				</p></div><p>为了支持RAID清理操作， <code class="literal">lvs</code>命令支持两个新的可打印字段： <code class="literal">raid_sync_action</code>和<code class="literal">raid_mismatch_count</code> 。默认情况下不打印这些字段。要显示这些字段，请使用<code class="literal">lvs</code>的<code class="literal">-o</code>参数指定它们，如下所示。
			</p><pre class="literallayout">lvs -o +raid_sync_action,raid_mismatch_count <span class="emphasis"><em>vg/lv</em></span></pre><p><code class="literal">raid_sync_action</code>字段显示raid卷正在执行的当前同步操作。它可以是以下值之一：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<code class="literal">idle</code> ：所有同步操作完成（什么都不做）</li><li class="listitem">
						<code class="literal">resync</code> ：在计算机出现故障后初始化阵列或恢复</li><li class="listitem">
						<code class="literal">recover</code> ：替换阵列中的设备</li><li class="listitem">
						<code class="literal">check</code> ：寻找阵列不一致</li><li class="listitem">
						<code class="literal">repair</code> ：寻找和修复不一致</li></ul></div><p><code class="literal">raid_mismatch_count</code>字段显示<code class="literal">check</code>操作期间发现的差异数。
			</p><p><code class="literal">lvs</code>命令的<code class="literal">Cpy%Sync</code>字段现在打印任何<code class="literal">raid_sync_action</code>操作的进度，包括<code class="literal">check</code>和<code class="literal">repair</code> 。
			</p><p><code class="literal">lvs</code>命令输出的<code class="literal">lv_attr</code>字段现在提供其他指示符以支持RAID清理操作。此字段的第9位显示逻辑卷的运行状况，现在它支持以下指示符。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">（ <span class="emphasis"><em>m</em></span> ）ismatches表示RAID逻辑卷存在差异。在清理操作检测到RAID的某些部分不连贯之后，将显示此字符。
					</li><li class="listitem">（ <span class="emphasis"><em>r</em></span> ）efresh表示RAID阵列中的设备出现故障，并且内核将其视为失败，即使LVM可以读取设备标签并认为设备可以运行。应该（r）刷新逻辑卷以通知内核设备现在可用，或者如果怀疑设备发生故障，则应该（r）替换设备。
					</li></ul></div><p>执行RAID清理操作时， <code class="literal">sync</code>操作所需的后台I / O可以挤出对LVM设备的其他I / O操作，例如对卷组元数据的更新。这可能导致其他LVM操作变慢。您可以通过实施恢复限制来控制擦除RAID逻辑卷的速率。
			</p><p>您可以通过使用<code class="literal">lvchange</code>命令的<code class="literal">--minrecoveryrate</code>和<code class="literal">--maxrecoveryrate</code>选项设置这些操作的最小和最大I / O速率来控制执行<code class="literal">sync</code>操作的速率。您可以如下指定这些选项。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
						<code class="literal">-  maxrecoveryrate <span class="emphasis"><em>Rate</em></span> [bBsSkKmMgG]</code>
					</p><p class="simpara">设置RAID逻辑卷的最大恢复速率，以便它不会挤出标称I / O操作。<span class="emphasis"><em>速率</em></span>指定为阵列中每个设备的每秒数量。如果没有给出后缀，则假定为kiB / sec / device。将恢复率设置为0意味着它将是无限制的。
					</p></li><li class="listitem"><p class="simpara">
						<code class="literal">--minrecoveryrate <span class="emphasis"><em>Rate</em></span> [bBsSkKmMgG]</code>
					</p><p class="simpara">设置RAID逻辑卷的最低恢复速率，以确保<code class="literal">sync</code>操作的I / O实现最小吞吐量，即使存在大量标称I / O.<span class="emphasis"><em>速率</em></span>指定为阵列中每个设备的每秒数量。如果没有给出后缀，则假定为kiB / sec / device。
					</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-raid-takeover-configure-manage-raid"></a>转换RAID级别（RAID接管）</h1></div></div></div><p>LVM支持Raid <span class="emphasis"><em>接管</em></span> ，这意味着将RAID逻辑卷从一个RAID级别转换为另一个RAID级别（例如从RAID 5转换为RAID 6）。通常，更改RAID级别是为了增加或减少设备故障的恢复能力或重新划分逻辑卷。您使用<code class="literal">lvconvert</code>进行RAID接管。有关RAID接管的信息以及使用<code class="literal">lvconvert</code>转换RAID逻辑卷的<code class="literal">lvmraid</code> ，请参见<code class="literal">lvmraid</code> （7）手册页。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-raid-reshape-configure-manage-raid"></a>更改RAID卷的属性（RAID重塑）</h1></div></div></div><p>RAID <span class="emphasis"><em>重塑</em></span>意味着在保持相同RAID级别的同时更改RAID逻辑卷的属性。您可以更改的某些属性包括RAID布局，条带大小和条带数。有关RAID重新整形的信息以及使用<code class="literal">lvconvert</code>命令重塑RAID逻辑卷的<code class="literal">lvmraid</code> ，请参见<code class="literal">lvmraid</code> （7）手册页。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-controlling-raid-io-configure-manage-raid"></a>控制RAID1逻辑卷上的I / O操作</h1></div></div></div><p>您可以使用<code class="literal">lvchange</code>命令的<code class="literal">--writemostly</code>和<code class="literal">--writebehind</code>参数来控制RAID1逻辑卷中设备的I / O操作。使用这些参数的格式如下。
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
						<code class="literal">-  [raid]写入<span class="emphasis"><em>PhysicalVolume</em></span> [：{t | y | n}]</code>
					</p><p class="simpara">将RAID1逻辑卷中的设备标记为<code class="literal">write-mostly</code> 。除非必要，否则将避免对这些驱动器的所有读取。设置此参数可使驱动器的I / O操作数保持最小。默认情况下，对于逻辑卷中的指定物理卷， <code class="literal">write-mostly</code>属性设置为yes。可以通过将<code class="literal">:n</code>附加到物理卷或通过指定<code class="literal">:t</code>来切换值来删除<code class="literal">write-mostly</code>标志。可以在单个命令中多次指定<code class="literal">--writemostly</code>参数，从而可以同时切换逻辑卷中所有物理卷的写入主要属性。
					</p></li><li class="listitem"><p class="simpara">
						<code class="literal">-  [raid]写入<span class="emphasis"><em>IOCount</em></span></code>
					</p><p class="simpara">指定允许RAID1逻辑卷中标记为<code class="literal">write-mostly</code>设备的最大未完成写入数。一旦超过此值，写入将变为同步，导致对组成设备的所有写入在阵列发出写入信号完成之前完成。将值设置为零会清除首选项，并允许系统任意选择值。
					</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="proc-changing-raid-regionsize-configure-manage-raid"></a>更改RAID逻辑卷上的区域大小</h1></div></div></div><p>创建RAID逻辑卷时，逻辑卷的区域大小将是<code class="literal">/etc/lvm/lvm.conf</code>文件中<code class="literal">raid_region_size</code>参数的值。您可以使用<code class="literal">lvcreate</code>命令的<code class="literal">-R</code>选项覆盖此默认值。
			</p><p>创建RAID逻辑卷后，可以使用<code class="literal">lvconvert</code>命令的<code class="literal">-R</code>选项更改卷的区域大小。以下示例将逻辑卷<code class="literal">vg/raidlv</code>的区域大小更改为4096K。必须同步RAID卷才能更改区域大小。
			</p><pre class="literallayout"># <code class="literal">lvconvert -R 4096K vg/raid1</code>
Do you really want to change the region_size 512.00 KiB of LV vg/raid1 to 4.00 MiB? [y/n]: <code class="literal">y</code>
  Changed region size on RAID LV vg/raid1 to 4.00 MiB.</pre></div></div></body></html>