<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 使用systemd管理服务</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 使用systemd管理服务</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="introduction-to-systemd_managing-services-with-systemd"></a> systemd简介</h1></div></div></div><p>
				<span class="strong"><strong><span class="application">Systemd</span></strong></span>是Linux操作系统的系统和服务管理器。它旨在向后兼容SysV init脚本，并提供许多功能，例如在引导时并行启动系统服务，按需激活守护程序或基于依赖性的服务控制逻辑。从Red Hat Enterprise Linux 7开始， <span class="strong"><strong><span class="application">systemd</span></strong></span>将Upstart替换为默认的init系统。
			</p><p>
				<span class="strong"><strong><span class="application">Systemd</span></strong></span>引入了<span class="emphasis"><em>systemd单元</em></span>的概念。这些单元由位于下表中列出的某个目录中的单元配置文件表示。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Introduction-Units-Locations"></a><p class="title"><strong>表3.1。系统单元文件位置</strong></p><div class="table-contents"><table border="1" summary="Systemd unit files locations"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">目录</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">/ usr / lib中/ systemd /系统/</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>使用已安装的RPM软件包分发的系统单元文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">/运行/ systemd /系统/</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>在运行时创建的系统单元文件。此目录优先于已安装服务单元文件的目录。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">的/ etc / systemd /系统/</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p><code class="literal">systemctl enable</code>单元文件以及为扩展服务而添加的单元文件。此目录优先于具有运行时单元文件的目录。
							</p>
							 </td></tr></tbody></table></div></div><p>这些单元封装了以下信息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">系统服务</li><li class="listitem">听力插座</li><li class="listitem">与init系统相关的其他对象</li></ul></div><p>有关可用systemd单元类型的完整列表，请参阅下表。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Introduction-Units-Types"></a><p class="title"><strong>表3.2。可用的systemd单元类型</strong></p><div class="table-contents"><table border="1" summary="Available systemd unit types"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">单位类型</th><th valign="top" style="text-align:left">文件扩展名</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>服务单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。服务</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>系统服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>目标单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。目标</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>一组系统单位。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>自动挂载单元</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">.automount</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>文件系统自动挂载点。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>设备单元</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。设备</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>内核识别的设备文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>安装单元</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。安装</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>文件系统挂载点。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>路径单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。路径</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>文件系统中的文件或目录。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>范围单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。范围</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>外部创建的流程。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>切片单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。切片</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>一组管理系统进程的分层组织单元。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>插座单元</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。插座</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>进程间通信套接字。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>交换单位</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">。交换</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>交换设备或交换文件。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>定时器单元</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">.timer</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>系统计时器。
							</p>
							 </td></tr></tbody></table></div></div><h5><a id="overriding_the_default_systemd_configuration_using_system_conf"></a>使用system.conf覆盖默认的systemd配置</h5><p><span class="strong"><strong><span class="application">systemd</span></strong></span>的默认配置是在编译期间定义的，可以在<code class="literal">/etc/systemd/system.conf</code>中的systemd配置文件中找到。如果要偏离这些默认值并全局覆盖systemd单位的选定默认值，请使用此文件。
			</p><p>例如，要覆盖超时限制的默认值（设置为90秒），请使用<code class="literal">DefaultTimeoutStartSec</code>参数以秒为单位输入所需的值。
			</p><pre class="literallayout">DefaultTimeoutStartSec=<span class="emphasis"><em>required value</em></span></pre><p>有关详细信息，请参见<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Overriding_Unit_Mod-Change-timout-limit" title="例3.20。更改超时限制">例3.20，“更改超时限制”</a> 。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Introduction-Features"></a>主要特点</h2></div></div></div><p>systemd系统和服务管理器提供以下主要功能：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							<span class="strong"><strong>基于套接字的激活</strong></span> - 在引导时， <span class="strong"><strong><span class="application">systemd</span></strong></span>为支持此类激活的所有系统服务创建侦听套接字，并在它们启动后立即将套接字传递给这些服务。这不仅允许<span class="strong"><strong><span class="application">systemd</span></strong></span>并行启动服务，而且还可以重新启动服务，而不会丢失任何在不可用时发送给它的消息：相应的套接字仍然可访问，所有消息都排队。
						</p><p class="simpara">
							<span class="strong"><strong><span class="application">Systemd</span></strong></span>使用<span class="emphasis"><em>套接字单元</em></span>进行基于套接字的激活。
						</p></li><li class="listitem">
							<span class="strong"><strong>基于总线的激活</strong></span> - 在客户端应用程序第一次尝试与它们通信时，可以按需启动使用D-Bus进行进程间通信的系统服务。<span class="strong"><strong><span class="application">Systemd</span></strong></span>使用<span class="emphasis"><em>D-Bus服务文件</em></span>进行基于总线的激活。
						</li><li class="listitem">
							<span class="strong"><strong>基于设备的激活</strong></span> - 当插入特定类型的硬件或可用时，可以按需启动支持<span class="strong"><strong>基于设备的激活的</strong></span>系统服务。<span class="strong"><strong><span class="application">Systemd</span></strong></span>使用<span class="emphasis"><em>设备单元</em></span>进行基于设备的激活。
						</li><li class="listitem">
							<span class="strong"><strong>基于路径的激活</strong></span> - 当特定文件或目录更改其状态时，可以按需启动支持<span class="strong"><strong>基于路径的激活的</strong></span>系统服务。<span class="strong"><strong><span class="application">Systemd</span></strong></span>使用<span class="emphasis"><em>路径单元</em></span>进行基于路径的激活。
						</li><li class="listitem">
							<span class="strong"><strong>挂载和自动挂载点管理</strong></span> - <span class="strong"><strong><span class="application">Systemd</span></strong></span>监视并管理挂载和自动挂载点。<span class="strong"><strong><span class="application">Systemd</span></strong></span>使用<span class="emphasis"><em>装载单元</em></span>作为挂载点，使用<span class="emphasis"><em>自动挂载单元</em></span>作为自动挂载点。
						</li><li class="listitem">
							<span class="strong"><strong>积极的并行化</strong></span> - 由于使用基于套接字的激活， <span class="strong"><strong><span class="application">systemd</span></strong></span>可以在所有侦听套接字到位后立即并行启动系统服务。结合支持按需激活的系统服务，并行激活可显着减少引导系统所需的时间。
						</li><li class="listitem">
							<span class="strong"><strong>事务单元激活逻辑</strong></span> - 在激活或停用单元之前， <span class="strong"><strong><span class="application">systemd</span></strong></span>计算其依赖关系，创建临时事务，并验证此事务是否一致。如果事务不一致， <span class="strong"><strong><span class="application">systemd</span></strong></span>会在报告错误之前自动尝试更正它并从中删除非必要的作业。
						</li><li class="listitem">
							<span class="strong"><strong>向后兼容SysV init</strong></span> - <span class="strong"><strong><span class="application">Systemd</span></strong></span>支持SysV init脚本，如<span class="emphasis"><em><span class="citetitle">Linux标准基本核心规范中所述</span></em></span> ，这简化了系统服务单元的升级路径。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Compatibility_Changes"></a>兼容性变化</h2></div></div></div><p>systemd系统和服务管理器主要与SysV init和Upstart兼容。以下是使用SysV init的Red Hat Enterprise Linux 6系统最显着的兼容性更改：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<span class="strong"><strong><span class="application">Systemd</span></strong></span>对运行级别的支持有限。它提供了许多可以直接映射到这些运行级别的目标单元，出于兼容性原因，它还与早期的<code class="literal">runlevel</code>命令一起分发。但是，并非所有systemd目标都可以直接映射到运行级别，因此，此命令可能返回<code class="literal">N</code>以指示未知的运行级别。如果可能，建议您避免使用<code class="literal">runlevel</code>命令。<br>有关systemd目标及其与运行级别的比较的更多信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#working-with-systemd-targets_managing-services-with-systemd" title="使用systemd目标">“使用systemd目标”一节</a> 。
						</li><li class="listitem"><p class="simpara"><code class="literal">systemctl</code>实用程序不支持自定义命令。除了标准命令（如<code class="literal">start</code> ， <code class="literal">stop</code>和<code class="literal">status</code> ，SysV init脚本的作者还可以实现对任意数量的任意命令的支持，以提供其他功能。例如，可以使用<code class="literal">panic</code>命令执行<code class="literal">iptables</code>的init脚本，该命令立即启用紧急模式并重新配置系统以开始丢弃所有传入和传出的数据包。<span class="strong"><strong><span class="application">systemd</span></strong></span>不支持此功能， <code class="literal">systemctl</code>只接受记录的命令。
						</p><p class="simpara">有关<code class="literal">systemctl</code>实用程序及其与早期<code class="literal">service</code>实用程序的比较的更多信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Services-systemctl" title="表3.3。服务实用程序与systemctl的比较">表3.3“服务实用程序与systemctl的比较”</a> 。
						</p></li><li class="listitem"><code class="literal">systemctl</code>实用程序不与<span class="strong"><strong><span class="application">systemd</span></strong></span>尚未启动的服务通信。当<span class="strong"><strong><span class="application">systemd</span></strong></span>启动系统服务时，它会存储其主进程的ID以便跟踪它。然后， <code class="literal">systemctl</code>实用程序使用此PID来查询和管理服务。因此，如果用户直接在命令行上启动特定守护程序，则<code class="literal">systemctl</code>无法确定其当前状态或将其停止。
						</li><li class="listitem">
							<span class="strong"><strong><span class="application">Systemd</span></strong></span>仅停止运行服务。以前，当启动关闭序列时，Red Hat Enterprise Linux 6及更早版本的系统使用位于<code class="literal">/etc/rc0.d/</code>目录中的符号链接来停止所有可用的系统服务，无论其状态如何。使用<span class="strong"><strong><span class="application">systemd时</span></strong></span> ，只有正在运行的服务在关闭时停止。
						</li><li class="listitem">系统服务无法从标准输入流中读取。当<span class="strong"><strong><span class="application">systemd</span></strong></span>启动服务时，它会将其标准输入连接到<code class="literal">/dev/null</code>以防止与用户进行任何交互。
						</li><li class="listitem">系统服务不会从调用用户及其会话继承任何上下文（例如<code class="literal">HOME</code>和<code class="literal">PATH</code>环境变量）。每个服务都在干净的执行上下文中运行。
						</li><li class="listitem">加载SysV init脚本时， <span class="strong"><strong><span class="application">systemd</span></strong></span>读取在Linux标准库（LSB）标头中编码的依赖关系信息，并在运行时解释它。
						</li><li class="listitem">服务单元上的所有操作都需要默认超时5分钟，以防止服务故障冻结系统。对于从initscripts生成且无法更改的服务，此值是硬编码的。但是，可以使用单个配置文件为每个服务指定更长的超时值，请参见<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Overriding_Unit_Mod-Change-timout-limit" title="例3.20。更改超时限制">例3.20“更改超时限制”</a> 。
						</li></ul></div><p>有关<span class="strong"><strong><span class="application">systemd</span></strong></span>引入的兼容性更改的详细列表，请参阅Red Hat Enterprise Linux 7的<a class="link" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Migration_Planning_Guide/">迁移规划指南</a> 。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="managing-system-services_managing-services-with-systemd"></a>管理系统服务</h1></div></div></div><p>以前版本的Red Hat Enterprise Linux（与SysV init或Upstart一起分发）使用位于<code class="literal">/etc/rc.d/init.d/</code>目录中的<span class="emphasis"><em>init脚本</em></span> 。这些init脚本通常用Bash编写，并允许系统管理员控制其系统中的服务和守护进程的状态。从Red Hat Enterprise Linux 7开始，这些init脚本已被<span class="emphasis"><em>服务单元</em></span>取代。
			</p><p>服务单元以<code class="literal">.service</code>文件扩展名结尾，其用途与init脚本类似。要查看，启动，停止，重新启动，启用或禁用系统服务，请使用<code class="literal">systemctl</code>命令，如<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Services-systemctl" title="表3.3。服务实用程序与systemctl的比较">服务实用程序与systemctl的</a> <a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Services-chkconfig" title="表3.4。chkconfig实用程序与systemctl的比较">比较，chkconfig实用程序与systemctl的比较</a> ，以及本节中的进一步说明。<code class="literal">service</code>和<code class="literal">chkconfig</code>命令在系统中仍然可用，并按预期工作，但仅出于兼容性原因而包含，应避免使用。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Services-systemctl"></a><p class="title"><strong>表3.3。服务实用程序与systemctl的比较</strong></p><div class="table-contents"><table border="1" summary="Comparison of the service utility with systemctl"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">服务</th><th valign="top" style="text-align:left">systemctl</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span>开始</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl起始<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>启动服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span>停止</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl停止<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>停止服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span>重启</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl重新启动<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>重新启动服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span> condrestart</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl try-restart <span class="emphasis"><em>name</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>仅在服务正在运行时重新启动服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span>重新加载</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl reload <span class="emphasis"><em>name</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>重新加载配置。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务<span class="emphasis"><em>名称</em></span>状态</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl status <span class="emphasis"><em>name</em></span> .service</code>
							</p>
							 <p>

							</p>
							 <p>
								<code class="literal">systemctl是活动<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>检查服务是否正在运行。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">服务--status-all</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl list-units --type service --all</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>显示所有服务的状态。
							</p>
							 </td></tr></tbody></table></div></div><div class="table"><a id="tabl-Managing_Services_with_systemd-Services-chkconfig"></a><p class="title"><strong>表3.4。chkconfig实用程序与systemctl的比较</strong></p><div class="table-contents"><table border="1" summary="Comparison of the chkconfig utility with systemctl"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">chkconfig的</th><th valign="top" style="text-align:left">systemctl</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig <span class="emphasis"><em>名称</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl enable <span class="emphasis"><em>name</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>启用服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig <span class="emphasis"><em>名称</em></span>关闭</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl禁用<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>禁用服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig --list <span class="emphasis"><em>name</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl status <span class="emphasis"><em>name</em></span> .service</code>
							</p>
							 <p>

							</p>
							 <p>
								<code class="literal">systemctl已启用<span class="emphasis"><em>名称</em></span> .service</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>检查是否启用了服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig --list</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl list-unit-files --type服务</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>列出所有服务并检查它们是否已启用。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig --list</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl list-dependencies  -  after</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>列出在指定单元之前订购的服务。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">chkconfig --list</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl list-dependencies --before</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>列出在指定单元后开始排序的服务。
							</p>
							 </td></tr></tbody></table></div></div><h3><a id="specifying_service_units"></a>指定服务单位</h3><p>为清楚起见，本节其余部分中的所有命令示例都使用带有<code class="literal">.service</code>文件扩展名的完整单元名称，例如：</p><pre class="literallayout">~]# systemctl stop nfs-server.service</pre><p>但是，可以省略文件扩展名，在这种情况下， <code class="literal">systemctl</code>实用程序假定参数是服务单元。以下命令等同于上面的命令：</p><pre class="literallayout">~]# systemctl stop nfs-server</pre><p>此外，某些单位具有别名。这些名称的名称可以比单位短，可以用来代替实际的单位名称。要查找可用于特定单元的所有别名，请使用：</p><pre class="literallayout">~]# systemctl show nfs-server.service -p Names</pre><h3><a id="behavior_of_systemctl_in_a_chroot_environment"></a> systemctl在chroot环境中的行为</h3><p>如果使用<code class="literal">chroot</code>命令更改根目录，则大多数<code class="literal">systemctl</code>命令拒绝执行任何操作。原因是<code class="literal">systemd</code>进程和使用<code class="literal">chroot</code>命令的用户没有相同的文件系统视图。例如，当从<code class="literal">kickstart</code>文件调用<code class="literal">systemctl</code>时会发生这种情况。
			</p><p>例外情况是单元文件命令，例如<code class="literal">systemctl enable</code>和<code class="literal">systemctl disable</code>命令。这些命令不需要正在运行的系统，也不会影响正在运行的进程，但它们会影响单元文件。因此，即使在<code class="literal">chroot</code>环境中也可以运行这些命令。例如，要在<code class="literal">/srv/website1/</code>目录下的系统上启用<code class="literal">httpd</code>服务：</p><pre class="literallayout">~]# chroot /srv/website1
~]# systemctl enable httpd.service
Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service, pointing to /usr/lib/systemd/system/httpd.service.</pre><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-List"></a>上市服务</h2></div></div></div><p>要列出所有当前加载的服务单元，请在shell提示符下键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl list-units --type service</code></pre><p>对于每个服务单元文件，此命令显示其全名（ <code class="literal">UNIT</code> ），然后记下单元文件是否已加载（ <code class="literal">LOAD</code> ），其高级（ <code class="literal">ACTIVE</code> ）和低级（ <code class="literal">SUB</code> ）单元文件激活状态，以及简短描述（ <code class="literal">DESCRIPTION</code> ）。
				</p><p>默认情况下， <code class="literal">systemctl list-units</code>命令仅显示活动单元。如果要列出所有已加载的单元而不管其状态如何，请使用<code class="literal">--all</code>或<code class="literal">-a</code>命令行选项运行此命令：</p><pre class="literallayout"><code class="literal">systemctl list-units --type service --all</code></pre><p>您还可以列出所有可用的服务单元，以查看它们是否已启用。为此，请键入：</p><pre class="literallayout"><code class="literal">systemctl list-unit-files --type service</code></pre><p>对于每个服务单元，此命令显示其全名（ <code class="literal">UNIT FILE</code> ），后跟服务单元是否已启用（ <code class="literal">STATE</code> ）的信息。有关如何确定各个服务单元状态的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-List"></a><p class="title"><strong>例3.1。上市服务</strong></p><div class="example-contents"><p>要列出所有当前加载的服务单元，请运行以下命令：</p><pre class="literallayout">~]$ <code class="literal">systemctl list-units --type service</code>
UNIT                           LOAD   ACTIVE SUB     DESCRIPTION
abrt-ccpp.service              loaded active exited  Install ABRT coredump hook
abrt-oops.service              loaded active running ABRT kernel log watcher
abrt-vmcore.service            loaded active exited  Harvest vmcores for ABRT
abrt-xorg.service              loaded active running ABRT Xorg log watcher
abrtd.service                  loaded active running ABRT Automated Bug Reporting Tool
…​
systemd-vconsole-setup.service loaded active exited  Setup Virtual Console
tog-pegasus.service            loaded active running OpenPegasus CIM Server

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

<span class="strong"><strong>46 loaded units listed.</strong></span> Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'</pre><p>要列出所有已安装的服务单元文件以确定它们是否已启用，请键入：</p><pre class="literallayout">~]$ systemctl list-unit-files --type service
UNIT FILE                                   STATE
abrt-ccpp.service                           enabled
abrt-oops.service                           enabled
abrt-vmcore.service                         enabled
abrt-xorg.service                           enabled
abrtd.service                               enabled
…​
wpa_supplicant.service                      disabled
ypbind.service                              disabled

208 unit files listed.</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Status"></a>显示服务状态</h2></div></div></div><p>要显示与系统服务对应的服务单元的详细信息，请在shell提示符下键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl status <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要检查的服务单元的名称（例如， <code class="literal">gdm</code> ）。此命令显示所选服务单元的名称，后跟其简短描述， <a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Services-Status" title="表3.5。可用的服务单位信息">表3.5“可用服务单元信息”中</a>描述的一个或多个字段，以及是否由<code class="literal">root</code>用户执行，还包括最新的日志条目。
				</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Services-Status"></a><p class="title"><strong>表3.5。可用的服务单位信息</strong></p><div class="table-contents"><table border="1" summary="Available service unit information"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">领域</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">加载</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>是否已加载服务单元的信息，单元文件的绝对路径以及是否启用了该单元的注释。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">活性</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>信息服务单元是否正在运行，后跟时间戳。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">主PID</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>相应系统服务的PID后跟其名称。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">状态</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>有关相应系统服务的其他信息。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">处理</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>有关相关流程的其他信息。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">CGROUP</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>有关相关控制组（cgroup）的其他信息。
								</p>
								 </td></tr></tbody></table></div></div><p>要仅验证特定服务单元是否正在运行，请运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl is-active <span class="emphasis"><em>name</em></span>.service</code></pre><p>同样，要确定是否启用了特定服务单元，请键入：</p><pre class="literallayout"><code class="literal">systemctl is-enabled <span class="emphasis"><em>name</em></span>.service</code></pre><p>请注意，如果指定的服务单元正在运行或已启用，则<code class="literal">systemctl is-active</code>且<code class="literal">systemctl is-enabled</code>返回退出状态<code class="literal">0</code> 。有关如何列出所有当前加载的服务单元的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-List" title="上市服务">列出服务</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Status"></a><p class="title"><strong>例3.2。显示服务状态</strong></p><div class="example-contents"><p>GNOME Display Manager的服务单元名为<code class="literal">gdm.service</code> 。要确定此服务单元的当前状态，请在shell提示符下键入以下内容：</p><pre class="literallayout">~]# systemctl status gdm.service
gdm.service - GNOME Display Manager
   Loaded: loaded (/usr/lib/systemd/system/gdm.service; enabled)
   Active: active (running) since Thu 2013-10-17 17:31:23 CEST; 5min ago
 Main PID: 1029 (gdm)
   CGroup: /system.slice/gdm.service
           ├─1029 /usr/sbin/gdm
           ├─1037 /usr/libexec/gdm-simple-slave --display-id /org/gno…​
           └─1047 /usr/bin/Xorg :0 -background none -verbose -auth /r…​

Oct 17 17:31:23 localhost systemd[1]: Started GNOME Display Manager.</pre></div></div><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Status_Start_Before"></a><p class="title"><strong>例3.3。显示在服务之前订购的服务</strong></p><div class="example-contents"><p>要确定在指定服务之前命令启动哪些服务，请在shell提示符下键入以下内容：</p><pre class="literallayout">~]# systemctl list-dependencies --after gdm.service
gdm.service
├─dbus.socket
├─getty@tty1.service
├─livesys.service
├─plymouth-quit.service
├─system.slice
├─systemd-journald.socket
├─systemd-user-sessions.service
└─basic.target
[output truncated]</pre></div></div><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Status_Start_After"></a><p class="title"><strong>例3.4。显示订购服务后启动的服务</strong></p><div class="example-contents"><p>要确定在指定服务之后命令启动哪些服务，请在shell提示符下键入以下内容：</p><pre class="literallayout">~]# systemctl list-dependencies --before gdm.service
gdm.service
├─dracut-shutdown.service
├─graphical.target
│ ├─systemd-readahead-done.service
│ ├─systemd-readahead-done.timer
│ └─systemd-update-utmp-runlevel.service
└─shutdown.target
  ├─systemd-reboot.service
  └─final.target
    └─systemd-reboot.service</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Start"></a>开始服务</h2></div></div></div><p>要启动与系统服务对应的服务单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl start <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要启动的服务单元的名称（例如， <code class="literal">gdm</code> ）。此命令在当前会话中启动所选服务单元。有关如何在引导时启动服务单元的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Enable" title="启用服务">启用服务</a> 。有关如何确定某个服务单元状态的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Start"></a><p class="title"><strong>例3.5。开始服务</strong></p><div class="example-contents"><p>Apache HTTP Server的服务单元名为<code class="literal">httpd.service</code> 。要激活此服务单元并在当前会话中启动<code class="literal">httpd</code>守护程序，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl start httpd.service</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Stop"></a>停止服务</h2></div></div></div><p>要停止与系统服务对应的服务单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl stop <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要停止的服务单元的名称（例如， <code class="literal">bluetooth</code> ）。此命令将停止当前会话中的所选服务单元。有关如何禁用服务单元并阻止其在引导时启动的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Disable" title="禁用服务">禁用服务</a> 。有关如何确定某个服务单元状态的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Stop"></a><p class="title"><strong>例3.6。停止服务</strong></p><div class="example-contents"><p><code class="literal">bluetoothd</code>守护进程的服务单元名为<code class="literal">bluetooth.service</code> 。要停用此服务单元并在当前会话中停止<code class="literal">bluetoothd</code>守护程序，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl stop bluetooth.service</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Restart"></a>重新启动服务</h2></div></div></div><p>要重新启动与系统服务对应的服务单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl restart <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要重新启动的服务单元的名称（例如， <code class="literal">httpd</code> ）。此命令在当前会话中停止所选服务单元并立即再次启动它。重要的是，如果所选服务单元未运行，则此命令也会启动。要告诉<span class="strong"><strong><span class="application">systemd</span></strong></span>仅在相应服务已在运行时重新启动服务单元，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl try-restart <span class="emphasis"><em>name</em></span>.service</code></pre><p>某些系统服务还允许您在不中断其执行的情况下重新加载其配置。为此，请以<code class="literal">root</code>身份键入：</p><pre class="literallayout"><code class="literal">systemctl reload <span class="emphasis"><em>name</em></span>.service</code></pre><p>请注意，不支持此功能的系统服务完全忽略此命令。为方便起见， <code class="literal">systemctl</code>命令还支持<code class="literal">reload-or-restart</code>启动此类服务的<code class="literal">reload-or-restart</code>和<code class="literal">reload-or-try-restart</code>命令。有关如何确定某个服务单元状态的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Restart"></a><p class="title"><strong>例3.7。重新启动服务</strong></p><div class="example-contents"><p>为了防止用户遇到不必要的错误消息或部分呈现的网页，Apache HTTP Server允许您编辑和重新加载其配置，而无需重新启动它并中断活动处理的请求。为此，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout">~]# systemctl reload httpd.service</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Enable"></a>启用服务</h2></div></div></div><p>要配置与在引导时自动启动的系统服务对应的服务单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl enable <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要启用的服务单元的名称（例如， <code class="literal">httpd</code> ）。此命令读取所选服务单元的<code class="literal">[Install]</code>部分，并为<code class="literal">/etc/systemd/system/</code>目录及其子目录中的<code class="literal">/usr/lib/systemd/system/ <span class="emphasis"><em>name</em></span> .service</code>文件创建适当的符号链接。但是，此命令不会重写已存在的链接。如果要确保重新创建符号链接，请以<code class="literal">root</code>身份使用以下命令：</p><pre class="literallayout"><code class="literal">systemctl reenable <span class="emphasis"><em>name</em></span>.service</code></pre><p>此命令禁用所选服务单元并立即再次启用它。有关如何确定某个服务单元是否已在启动时启动的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。有关如何在当前会话中<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Start" title="Starting a service">启动服务的信息</a> ，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Start" title="开始服务">启动服务</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Enable"></a><p class="title"><strong>例3.8。启用服务</strong></p><div class="example-contents"><p>要将Apache HTTP Server配置为在引导时自动启动，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl enable httpd.service
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Disable"></a>禁用服务</h2></div></div></div><p>要防止在引导时自动启动与系统服务对应的服务单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl disable <span class="emphasis"><em>name</em></span>.service</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要禁用的服务单元的名称（例如， <code class="literal">bluetooth</code> ）。此命令读取所选服务单元的<code class="literal">[Install]</code>部分，并从<code class="literal">/etc/systemd/system/</code>目录及其子目录中删除<code class="literal">/usr/lib/systemd/system/ <span class="emphasis"><em>name</em></span> .service</code>文件的相应符号链接。此外，您可以屏蔽任何服务单元，以防止手动或其他服务启动它。为此，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl mask <span class="emphasis"><em>name</em></span>.service</code></pre><p>此命令将<code class="literal">/etc/systemd/system/ <span class="emphasis"><em>name</em></span> .service</code>文件替换为<code class="literal">/dev/null</code>的符号链接，从而使<span class="strong"><strong><span class="application">systemd</span></strong></span>无法访问实际的单元文件。要还原此操作并取消屏蔽服务单元，请以<code class="literal">root</code>身份键入：</p><pre class="literallayout"><code class="literal">systemctl unmask <span class="emphasis"><em>name</em></span>.service</code></pre><p>有关如何确定某个服务单元是否已在启动时启动的信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Status" title="显示服务状态">显示服务状态</a> 。有关如何在当前会话中<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Stop" title="Stopping a service">停止服务的信息</a> ，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Stop" title="停止服务">停止服务</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Services-Disable"></a><p class="title"><strong>例3.9。禁用服务</strong></p><div class="example-contents"><p>
						<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#exam-Managing_Services_with_systemd-Services-Stop" title="例3.6。停止服务">例3.6，“停止服务”</a>说明了如何在当前会话中停止<code class="literal">bluetooth.service</code>单元。要防止此服务单元在引导时启动，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout">~]# systemctl disable bluetooth.service
Removed symlink /etc/systemd/system/bluetooth.target.wants/bluetooth.service.
Removed symlink /etc/systemd/system/dbus-org.bluez.service.</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Services-Start_confl"></a>启动冲突的服务</h2></div></div></div><p>在<span class="strong"><strong><span class="application">systemd中</span></strong></span> ，存在服务之间的正面和负面依赖关系。启动特定服务可能需要启动一个或多个其他服务（正依赖性）或停止一个或多个服务（负依赖性）。
				</p><p>当您尝试启动新服务时， <span class="strong"><strong><span class="application">systemd会</span></strong></span>自动解析所有依赖项。请注意，这是在没有向用户明确通知的情况下完成的。如果您已在运行服务，并且尝试启动具有负依赖性的其他服务，则会自动停止第一个服务。
				</p><p>例如，如果您正在运行<code class="literal">postfix</code>服务，并且您尝试启动<code class="literal">sendmail</code>服务，则<span class="strong"><strong><span class="application">systemd</span></strong></span>首先会自动停止<code class="literal">postfix</code> ，因为这两个服务是冲突的，无法在同一端口上运行。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="working-with-systemd-targets_managing-services-with-systemd"></a>使用systemd目标</h1></div></div></div><p>以前版本的Red Hat Enterprise Linux与SysV init或Upstart一起分发，实现了一组预定义的<span class="emphasis"><em>运行级别</em></span> ，代表了特定的操作模式。这些运行级别从0到6编号，并由系统管理员启用特定运行级别时要运行的一系列系统服务定义。从Red Hat Enterprise Linux 7开始，运行级别的概念已被<span class="emphasis"><em>systemd目标</em></span>取代。
			</p><p>系统目标由<span class="emphasis"><em>目标单位</em></span>表示。目标单元以<code class="literal">.target</code>文件扩展名结尾，其唯一目的是通过一系列依赖项将其他系统单元组合在一起。例如，用于启动图形会话的<code class="literal">graphical.target</code>单元启动系统服务，例如GNOME Display Manager（ <code class="literal">gdm.service</code> ）或Accounts Service（ <code class="literal">accounts-daemon.service</code> ），并激活<code class="literal">multi-user.target</code>单位。同样， <code class="literal">multi-user.target</code>单元启动其他基本系统服务，如NetworkManager（ <code class="literal">NetworkManager.service</code> ）或D-Bus（ <code class="literal">dbus.service</code> ），并激活另一个名为<code class="literal">basic.target</code>目标单元。
			</p><p>Red Hat Enterprise Linux 7与许多预定义目标一起分发，这些目标或多或少类似于此系统以前版本的标准运行级别集。出于兼容性原因，它还为这些目标提供了别名，这些目标直接将它们映射到SysV运行级别。<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Targets-Runlevels" title="表3.6。SysV运行级别与系统目标的比较">表3.6“SysV运行级别与systemd目标的比较”</a>提供了SysV运行级别及其相应系统目标的完整列表。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Targets-Runlevels"></a><p class="title"><strong>表3.6。SysV运行级别与系统目标的比较</strong></p><div class="table-contents"><table border="1" summary="Comparison of SysV runlevels with systemd targets"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">运行级别</th><th valign="top" style="text-align:left">目标单位</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">0</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel0.target</code> ， <code class="literal">poweroff.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>关闭并关闭系统电源。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">1</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel1.target</code> ， <code class="literal">rescue.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>设置救援外壳。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">2</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel2.target</code> ， <code class="literal">multi-user.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>设置非图形多用户系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">3</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel3.target</code> ， <code class="literal">multi-user.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>设置非图形多用户系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">4</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel4.target</code> ， <code class="literal">multi-user.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>设置非图形多用户系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">五</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel5.target</code> ， <code class="literal">graphical.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>设置图形多用户系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">6</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">runlevel6.target</code> ， <code class="literal">reboot.target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>关闭并重新启动系统。
							</p>
							 </td></tr></tbody></table></div></div><p>要查看，更改或配置systemd目标，请使用<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Targets-telinit" title="表3.7。SysV init命令与systemctl的比较">表3.7“使用systemctl比较SysV init命令”</a>和以下部分中所述的<code class="literal">systemctl</code>实用程序。<code class="literal">runlevel</code>和<code class="literal">telinit</code>命令在系统中仍然可用并按预期工作，但仅出于兼容性原因而包含，应避免使用。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Targets-telinit"></a><p class="title"><strong>表3.7。SysV init命令与systemctl的比较</strong></p><div class="table-contents"><table border="1" summary="Comparison of SysV init commands with systemctl"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">老命令</th><th valign="top" style="text-align:left">新命令</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">运行级别</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl list-units --type target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>列出当前加载的目标单位。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">telinit <span class="emphasis"><em>运行级别</em></span></code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl隔离<span class="emphasis"><em>名称</em></span> .target</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>更改当前目标。
							</p>
							 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-View_Default"></a>查看默认目标</h2></div></div></div><p>要确定默认使用哪个目标单元，请运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl get-default</code></pre><p>此命令解析位于<code class="literal">/etc/systemd/system/default.target</code>的符号链接并显示结果。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-View_Default"></a><p class="title"><strong>例3.10。查看默认目标</strong></p><div class="example-contents"><p>要显示默认目标单位，请键入：</p><pre class="literallayout">~]$ <code class="literal">systemctl get-default</code>
graphical.target</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-View_Current"></a>查看当前目标</h2></div></div></div><p>要列出所有当前加载的目标单元，请在shell提示符下键入以下命令：</p><pre class="literallayout"><code class="literal">systemctl list-units --type target</code></pre><p>对于每个目标单元，此命令显示其全名（ <code class="literal">UNIT</code> ），然后记下单元是否已加载（ <code class="literal">LOAD</code> ），其高级（ <code class="literal">ACTIVE</code> ）和低级（ <code class="literal">SUB</code> ）单元激活状态，以及简短描述（ <code class="literal">DESCRIPTION</code> ）。
				</p><p>默认情况下， <code class="literal">systemctl list-units</code>命令仅显示活动单元。如果要列出所有已加载的单元而不管其状态如何，请使用<code class="literal">--all</code>或<code class="literal">-a</code>命令行选项运行此命令：</p><pre class="literallayout"><code class="literal">systemctl list-units --type target --all</code></pre><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-View_Current"></a><p class="title"><strong>例3.11。查看当前目标</strong></p><div class="example-contents"><p>要列出所有当前加载的目标单位，请运行：</p><pre class="literallayout">~]$ <code class="literal">systemctl list-units --type target</code>
UNIT                  LOAD   ACTIVE SUB    DESCRIPTION
basic.target          loaded active active Basic System
cryptsetup.target     loaded active active Encrypted Volumes
getty.target          loaded active active Login Prompts
graphical.target      loaded active active Graphical Interface
local-fs-pre.target   loaded active active Local File Systems (Pre)
local-fs.target       loaded active active Local File Systems
multi-user.target     loaded active active Multi-User System
network.target        loaded active active Network
paths.target          loaded active active Paths
remote-fs.target      loaded active active Remote File Systems
sockets.target        loaded active active Sockets
sound.target          loaded active active Sound Card
spice-vdagentd.target loaded active active Agent daemon for Spice guests
swap.target           loaded active active Swap
sysinit.target        loaded active active System Initialization
time-sync.target      loaded active active System Time Synchronized
timers.target         loaded active active Timers

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

<span class="strong"><strong>17 loaded units listed.</strong></span> Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-Change_Default"></a>更改默认目标</h2></div></div></div><p>要将系统配置为默认使用其他目标设备，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl set-default <span class="emphasis"><em>name</em></span>.target</code></pre><p>将<span class="emphasis"><em>名称</em></span>替换<span class="emphasis"><em>为</em></span>默认情况下要使用的目标单位的名称（例如， <code class="literal">multi-user</code> ）。此命令将<code class="literal">/etc/systemd/system/default.target</code>文件替换为<code class="literal">/usr/lib/systemd/system/ <span class="emphasis"><em>name</em></span> .target</code>的符号链接，其中<span class="emphasis"><em>name</em></span>是要使用的目标单元的名称。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-Change_Default"></a><p class="title"><strong>例3.12。更改默认目标</strong></p><div class="example-contents"><p>要将系统配置为默认使用<code class="literal">multi-user.target</code>单元，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl set-default multi-user.target
rm '/etc/systemd/system/default.target'
ln -s '/usr/lib/systemd/system/multi-user.target' '/etc/systemd/system/default.target'</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-Change_Current"></a>改变当前目标</h2></div></div></div><p>要在当前会话中更改为其他目标单元，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl isolate <span class="emphasis"><em>name</em></span>.target</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>您要使用的目标单元的名称（例如， <code class="literal">multi-user</code> ）。此命令启动名为<span class="emphasis"><em>name</em></span>的目标单元和所有相关单元，并立即停止所有其他单元。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-Change_Current"></a><p class="title"><strong>例3.13。改变当前目标</strong></p><div class="example-contents"><p>要关闭图形用户界面并切换到当前会话中的<code class="literal">multi-user.target</code>单元，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl isolate multi-user.target</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-Rescue"></a>更改为救援模式</h2></div></div></div><p>
					<span class="emphasis"><em>Rescue模式</em></span>提供了方便的单用户环境，允许您在无法完成常规引导过程的情况下修复系统。在救援模式下，系统会尝试挂载所有本地文件系统并启动一些重要的系统服务，但它不会激活网络接口或允许更多用户同时登录系统。救援模式需要root密码。
				</p><p>要更改当前目标并在当前会话中进入救援模式，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl rescue</code></pre><p>此命令类似于<code class="literal">systemctl isolate rescue.target</code> ，但它还向当前登录到系统的所有用户发送信息性消息。要阻止<span class="strong"><strong><span class="application">systemd</span></strong></span>发送此消息，请使用<code class="literal">--no-wall</code>命令行选项运行此命令：</p><pre class="literallayout"><code class="literal">systemctl --no-wall rescue</code></pre><p>有关如何进入紧急模式的信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#sect-Managing_Services_with_systemd-Targets-Emergency" title="切换到紧急模式">“更改为紧急模式”一节</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-Rescue"></a><p class="title"><strong>例3.14。更改为救援模式</strong></p><div class="example-contents"><p>要在当前会话中进入救援模式，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl rescue

Broadcast message from root@localhost on pts/0 (Fri 2013-10-25 18:23:15 CEST):

The system is going down to rescue mode NOW!</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Targets-Emergency"></a>切换到紧急模式</h2></div></div></div><p>
					<span class="emphasis"><em>紧急模式</em></span>提供尽可能最小的环境，即使在系统无法进入救援模式的情况下，您也可以修复系统。在紧急模式下，系统仅安装根文件系统进行读取，不尝试安装任何其他本地文件系统，不激活网络接口，只启动一些基本服务。紧急模式需要root密码。
				</p><p>要更改当前目标并进入紧急模式，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl emergency</code></pre><p>此命令类似于<code class="literal">systemctl isolate emergency.target</code> ，但它还向当前登录到系统的所有用户发送信息性消息。要阻止<span class="strong"><strong><span class="application">systemd</span></strong></span>发送此消息，请使用<code class="literal">--no-wall</code>命令行选项运行此命令：</p><pre class="literallayout"><code class="literal">systemctl --no-wall emergency</code></pre><p>有关如何进入救援模式的信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#sect-Managing_Services_with_systemd-Targets-Rescue" title="更改为救援模式">“更改为救援模式”一节</a> 。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-Targets-Emergency"></a><p class="title"><strong>例3.15。切换到紧急模式</strong></p><div class="example-contents"><p>要进入紧急模式而不向当前登录到系统的所有用户发送消息，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout">~]# systemctl --no-wall emergency</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="shutting-down-suspending-hibernating-system_managing-services-with-systemd"></a>关闭，暂停和休眠系统</h1></div></div></div><p>在Red Hat Enterprise Linux 7中， <code class="literal">systemctl</code>实用程序取代了以前版本的Red Hat Enterprise Linux中使用的许多电源管理命令。出于兼容性原因， <a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Power" title="Table 3.8. Comparison of power management commands with systemctl">表3.8“电源管理命令与systemctl的比较”中</a>列出的<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Power" title="表3.8。电源管理命令与systemctl的比较">命令</a>仍在系统中可用，但建议您尽可能使用<code class="literal">systemctl</code> 。
			</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Power"></a><p class="title"><strong>表3.8。电源管理命令与systemctl的比较</strong></p><div class="table-contents"><table border="1" summary="Comparison of power management commands with systemctl"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">老命令</th><th valign="top" style="text-align:left">新命令</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">停</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl停止</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>停止系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">关机</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl poweroff</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>关闭系统电源。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">重启</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl重启</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>重新启动系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">PM-暂停</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl暂停</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>暂停系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">PM-休眠</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">systemctl hibernate</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>休眠系统。
							</p>
							 </td></tr><tr><td valign="top" style="text-align:left"> <p>
								<code class="literal">PM-暂停杂交</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>
								<code class="literal">系统混合睡眠</code>
							</p>
							 </td><td valign="top" style="text-align:left"> <p>暂停和暂停系统。
							</p>
							 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Power-Halt"></a>关闭系统</h2></div></div></div><p><code class="literal">systemctl</code>实用程序提供用于关闭系统的命令，但是也支持传统的<code class="literal">shutdown</code>命令。虽然<code class="literal">shutdown</code>命令将调用<code class="literal">systemctl</code>实用程序来执行关闭，但它的优点在于它还支持time参数。这对于计划维护特别有用，并且允许用户有更多时间对已安排系统关闭的警告作出反应。取消关闭的选项也是一个优点。
				</p><h4><a id="using_systemctl_commands"></a>使用systemctl命令</h4><p>要关闭系统并关闭计算机电源，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl poweroff</code></pre><p>要在不关闭计算机电源的情况下关闭并暂停系统，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl halt</code></pre><p>默认情况下，运行这些命令之一会导致<span class="strong"><strong><span class="application">systemd</span></strong></span>向当前登录到系统的所有用户发送信息性消息。要阻止<span class="strong"><strong><span class="application">systemd</span></strong></span>发送此消息，请使用<code class="literal">--no-wall</code>命令行选项运行所选命令，例如：</p><pre class="literallayout"><code class="literal">systemctl --no-wall poweroff</code></pre><h4><a id="using_the_shutdown_command"></a>使用shutdown命令</h4><p>要在特定时间关闭系统并关闭计算机电源，请使用以下格式的命令作为<code class="literal">root</code> ：</p><pre class="literallayout"><code class="literal">shutdown --poweroff <span class="emphasis"><em>hh:mm</em></span></code></pre><p>其中<span class="emphasis"><em>hh：mm</em></span>是24小时时钟格式的时间。系统关闭前5分钟创建<code class="literal">/run/nologin</code>文件以防止新登录。使用time参数时，可以将可选消息<span class="emphasis"><em>wall消息</em></span>附加到命令中。
				</p><p>要在延迟后关闭并停止系统，而不关闭机器电源，请使用以下格式的命令作为<code class="literal">root</code> ：</p><pre class="literallayout">shutdown --halt +m</pre><p>其中<span class="emphasis"><em>+ m</em></span>是以分钟为单位的延迟时间。<code class="literal">now</code>关键字是<code class="literal">+0</code>的别名。
				</p><p><code class="literal">root</code>用户可以取消挂起的关闭，如下所示：</p><pre class="literallayout"><code class="literal">shutdown -c</code></pre><p>有关更多命令选项，请参见<code class="literal">shutdown(8)</code>手册页。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Power-Reboot"></a>重启系统</h2></div></div></div><p>要重新启动系统，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl reboot</code></pre><p>默认情况下，此命令会使<span class="strong"><strong><span class="application">systemd</span></strong></span>向当前登录到系统的所有用户发送信息性消息。要阻止<span class="strong"><strong><span class="application">systemd</span></strong></span>发送此消息，请使用<code class="literal">--no-wall</code>命令行选项运行此命令：</p><pre class="literallayout"><code class="literal">systemctl --no-wall reboot</code></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Power-Suspend"></a>暂停系统</h2></div></div></div><p>要挂起系统，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl suspend</code></pre><p>此命令将系统状态保存在RAM中，RAM模块除外，关闭机器中的大多数设备。当您重新打开机器时，系统会从RAM恢复其状态，而无需再次启动。由于系统状态保存在RAM中而不是保存在硬盘上，因此从挂起模式恢复系统要比从休眠状态恢复系统快得多，但因此，挂起的系统状态也容易受到断电的影响。
				</p><p>有关如何休眠系统的信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#sect-Managing_Services_with_systemd-Power-Hibernate" title="冬眠系统">“休眠系统”一节</a> 。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Managing_Services_with_systemd-Power-Hibernate"></a>冬眠系统</h2></div></div></div><p>要休眠系统，请在shell提示符下以<code class="literal">root</code>身份键入以下内容：</p><pre class="literallayout"><code class="literal">systemctl hibernate</code></pre><p>此命令将系统状态保存在硬盘驱动器上并关闭计算机。当您重新打开机器时，系统会从保存的数据中恢复其状态，而无需再次启动。由于系统状态保存在硬盘而不是RAM中，因此机器不必维持RAM模块的电源，但因此，从休眠状态恢复系统要比从暂停模式恢复系统要慢得多。
				</p><p>要休眠和挂起系统，请以<code class="literal">root</code>身份运行以下命令：</p><pre class="literallayout"><code class="literal">systemctl hybrid-sleep</code></pre><p>有关如何挂起系统的信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#sect-Managing_Services_with_systemd-Power-Suspend" title="暂停系统">“暂停系统”一节</a> 。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="working-with-systemd-unit-files_managing-services-with-systemd"></a>使用systemd单元文件</h1></div></div></div><p>单元文件包含描述单元并定义其行为的配置指令。几个<code class="literal">systemctl</code>命令在后台使用单元文件。要进行更精细的调整，系统管理员必须手动编辑或创建单元文件。<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Introduction-Units-Locations" title="表3.1。系统单元文件位置">表3.1“系统单元文件位置”</a>列出了三个主要目录，其中单元文件存储在系统中， <code class="literal">/etc/systemd/system/</code>目录是为系统管理员创建或自定义的单元文件保留的。
			</p><p>单元文件名采用以下形式：</p><pre class="literallayout"><span class="emphasis"><em>unit_name</em></span>.<span class="emphasis"><em>type_extension</em></span></pre><p>这里， <span class="emphasis"><em>unit_name</em></span>代表单元的名称， <span class="emphasis"><em>type_extension</em></span>标识单元类型，有关<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Introduction-Units-Types" title="Table 3.2. Available systemd unit types">单元类型</a>的完整列表，请<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Introduction-Units-Types" title="表3.2。可用的systemd单元类型">参见表3.2“可用的systemd单元类型”</a> 。例如，系统中通常存在<code class="literal">sshd.service</code>和<code class="literal">sshd.socket</code>单元。
			</p><p>可以使用其他配置文件的目录来补充单元文件。例如，要向<code class="literal">sshd.service</code>添加自定义配置选项，请创建<code class="literal">sshd.service.d/custom.conf</code>文件并在其中插入其他指令。有关配置目录的更多信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Modify" title="修改现有的单元文件">“修改现有单元文件”一节</a> 。
			</p><p>此外，可以创建<code class="literal">sshd.service.wants/</code>和<code class="literal">sshd.service.requires/</code>目录。这些目录包含指向<code class="literal">sshd</code>服务依赖项的单元文件的符号链接。符号链接在安装期间根据[Install]单元文件选项自动创建，或者在运行时根据[Unit]选项自动创建。也可以手动创建这些目录和符号链接。有关[安装]和[单位]选项的更多详细信息，请参阅下表。
			</p><p>许多单元文件选项可以使用所谓的<span class="strong"><strong>单元说明符</strong></span>来设置 - 通配符字符串在加载单元文件时用单元参数动态替换。这样可以创建通用单元文件，用作生成实例化单元的模板。有关详细信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Instantiated_Units" title="使用实例化单元">“使用实例化单元”一节</a> 。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Unit_File_Structure"></a>了解单元文件结构</h2></div></div></div><p>单元文件通常由三部分组成：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">[Unit]</code>部分 - 包含不依赖于单元类型的通用选项。这些选项提供单元描述，指定单元的行为，并设置与其他单元的依赖关系。有关最常用[单位]选项的列表，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Unit_Sec_Options" title="表3.9。重要的[单位]部分选项">表3.9，“重要[单位]部分选项”</a> 。
						</li><li class="listitem"><code class="literal">[Unit type]</code>部分 - 如果单元具有特定于类型的指令，则这些指令在按单元类型命名的部分下分组。例如，服务单元文件包含<code class="literal">[Service]</code>部分。
						</li><li class="listitem"><code class="literal">[Install]</code>部分 - 包含有关<code class="literal">systemctl enable</code>和<code class="literal">disable</code>命令使用的单元安装的信息。有关<code class="literal">[Install]</code>部分的选项列表，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Install_Sec_Options" title="表3.11。重要的[安装]部分选项">表3.11，“重要[Install]部分选项”</a> 。
						</li></ul></div><div class="table"><a id="tabl-Managing_Services_with_systemd-Unit_Sec_Options"></a><p class="title"><strong>表3.9。重要的[单位]部分选项</strong></p><div class="table-contents"><table border="1" summary="Important [Unit] section options"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项<a href="#ftn.idm140276619584432" class="footnote" id="idm140276619584432"><sup class="footnote">[a]</sup></a>部分，请参见<code class="literal">systemd.unit(5)</code>手册页。</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">描述</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>对单位的有意义的描述。此文本显示在<code class="literal">systemctl status</code>命令的输出中。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">文档</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>提供引用该单元文档的URI列表。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">After</code> <a href="#ftn.idm140276619569104" class="footnote" id="idm140276619569104"><sup class="footnote">[b]</sup></a>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>定义单位的启动顺序。只有在<code class="literal">After</code>中指定的单位处于活动状态后，才会启动本机。与<code class="literal">Requires</code>不同， <code class="literal">After</code>未明确激活指定的单位。<code class="literal">Before</code>选项具有与<code class="literal">After</code>相反的功能。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">需要</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>配置对其他单元的依赖性。<code class="literal">Requires</code>中列出的单位与本机一起激活。如果任何所需单元无法启动，则不会激活该单元。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">希望</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>配置比<code class="literal">Requires</code>弱的依赖项。如果列出的任何单元未成功启动，则对单元激活没有影响。这是建立自定义单元依赖关系的推荐方法。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">冲突</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>配置负依赖，与<code class="literal">Requires</code>相反。
								</p>
								 </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idm140276619584432" class="footnote"><p><a href="#idm140276619584432" class="simpara"><sup class="simpara">[a]</sup></a>有关[单位<a href="#idm140276619584432" class="simpara"><sup class="simpara">]</sup></a>中可配置选项的完整列表</p></div><div id="ftn.idm140276619569104" class="footnote"><p><a href="#idm140276619569104" class="simpara"><sup class="simpara">[b]</sup></a>在大多数情况下，仅使用<code class="literal">After</code>和<code class="literal">Before</code>单元文件选项设置排序依赖关系就足够了。如果还使用<code class="literal">Wants</code> （推荐）或<code class="literal">Requires</code>设置需求依赖关系，则仍需要指定排序依赖关系。这是因为排序和需求依赖性彼此独立地工作。
									</p></div></td></tr></tbody></table></div></div><div class="table"><a id="tabl-Managing_Services_with_systemd-Service_Sec_Options"></a><p class="title"><strong>表3.10。重要的[服务]部分选项</strong></p><div class="table-contents"><table border="1" summary="Important [Service] section options"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项<a href="#ftn.idm140276619535840" class="footnote" id="idm140276619535840"><sup class="footnote">[a]</sup></a>部分，请参见<code class="literal">systemd.service(5)</code>手册页。</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">类型</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>配置影响<code class="literal">ExecStart</code>功能和相关选项的单元进程启动类型。之一：</p>
								 <p>

								</p>
								 <p>* <code class="literal">simple</code> - 默认值。从<code class="literal">ExecStart</code>开始的过程是服务的主要过程。
								</p>
								 <p>* <code class="literal">forking</code> - 从<code class="literal">ExecStart</code>开始的过程产生一个子进程，该进程成为服务的主要进程。启动完成后，父进程退出。
								</p>
								 <p>* <code class="literal">oneshot</code> - 这种类型与<code class="literal">simple</code>类似，但是在启动后续单元之前进程退出。
								</p>
								 <p>* <code class="literal">dbus</code> - 此类型与<code class="literal">simple</code>类似，但后续单元仅在主进程获得D-Bus名称后启动。
								</p>
								 <p>* <code class="literal">notify</code> - 此类型与<code class="literal">simple</code>类似，但只有在通过sd_notify（）函数发送通知消息后才会启动后续单元。
								</p>
								 <p>* <code class="literal">idle</code> - 类似于<code class="literal">simple</code> ，服务二进制文件的实际执行被延迟，直到所有作业完成，这避免了将状态输出与shell输出服务混合。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">ExecStart</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>指定启动设备时要执行的命令或脚本。<code class="literal">ExecStartPre</code>和<code class="literal">ExecStartPost</code>指定要在<code class="literal">ExecStart</code>之前和之后执行的自定义命令。<code class="literal">Type=oneshot</code>可以指定多个自定义命令，然后按顺序执行。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">ExecStop</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>指定单元停止时要执行的命令或脚本。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">ExecReload</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>指定重新加载单元时要执行的命令或脚本。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">重新开始</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>启用此选项后，服务将在其进程退出后重新启动，但<code class="literal">systemctl</code>命令将执行干净停止。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">RemainAfterExit</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>如果设置为True，即使退出所有进程，该服务也会被视为活动状态。默认值为False。如果配置了<code class="literal">Type=oneshot</code>则此选项特别有用。
								</p>
								 </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idm140276619535840" class="footnote"><p><a href="#idm140276619535840" class="simpara"><sup class="simpara">[a]</sup></a>有关[服务中<a href="#idm140276619535840" class="simpara"><sup class="simpara">]可</sup></a>配置选项的完整列表</p></div></td></tr></tbody></table></div></div><div class="table"><a id="tabl-Managing_Services_with_systemd-Install_Sec_Options"></a><p class="title"><strong>表3.11。重要的[安装]部分选项</strong></p><div class="table-contents"><table border="1" summary="Important [Install] section options"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">选项<a href="#ftn.idm140276559011744" class="footnote" id="idm140276559011744"><sup class="footnote">[a]</sup></a>部分，请参见<code class="literal">systemd.unit(5)</code>手册页。</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">别号</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>为单元提供以空格分隔的其他名称列表。大多数<code class="literal">systemctl</code>命令（不包括<code class="literal">systemctl enable</code> ）可以使用别名而不是实际的单元名称。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">RequiredBy</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>依赖于单位的单位列表。启用此单元后， <code class="literal">RequiredBy</code>列出的单元将获得对该单元的<code class="literal">Require</code>依赖性。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">WantedBy</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>弱单位的单位清单。启用此单位后， <code class="literal">WantedBy</code>列出的单位将获得与该单位的<code class="literal">Want</code>相关性。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">也</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>指定要与设备一起安装或卸载的单元列表。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">DefaultInstance</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>仅限实例化单元，此选项指定为其启用单元的默认实例。请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Instantiated_Units" title="使用实例化单元">“使用实例化单元”一节</a>
								</p>
								 </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idm140276559011744" class="footnote"><p><a href="#idm140276559011744" class="simpara"><sup class="simpara">[a]</sup></a>有关[安装<a href="#idm140276559011744" class="simpara"><sup class="simpara">]</sup></a>中可配置选项的完整列表</p></div></td></tr></tbody></table></div></div><p>可用于微调单元配置的一系列选项。以下示例显示了系统上安装的服务单元。此外，可以按照<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Instantiated_Units" title="使用实例化单元">使用实例化单元</a>中所述的方式动态创建单元来定义单元文件选项。
				</p><div class="example"><a id="exam-Managing_Services_with_systemd-postfix_unit_file"></a><p class="title"><strong>例3.16。 postfix.service单元文件</strong></p><div class="example-contents"><p>以下是<span class="strong"><strong><span class="package">后缀</span></strong></span>包当前提供的<code class="literal">/usr/lib/systemd/system/postfix.service</code>单元文件的内容：</p><pre class="literallayout">[Unit]
Description=Postfix Mail Transport Agent
After=syslog.target network.target
Conflicts=sendmail.service exim.service

[Service]
Type=forking
PIDFile=/var/spool/postfix/pid/master.pid
EnvironmentFile=-/etc/sysconfig/network
ExecStartPre=-/usr/libexec/postfix/aliasesdb
ExecStartPre=-/usr/libexec/postfix/chroot-update
ExecStart=/usr/sbin/postfix start
ExecReload=/usr/sbin/postfix reload
ExecStop=/usr/sbin/postfix stop

[Install]
WantedBy=multi-user.target</pre><p>[Unit]部分描述了服务，指定了排序依赖关系以及冲突单元。在[Service]中，指定在单元激活，停止和重新加载期间执行一系列自定义脚本。<code class="literal">EnvironmentFile</code>指向定义服务的环境变量的位置， <code class="literal">PIDFile</code>为服务的主进程指定稳定的PID。最后，[Install]部分列出了依赖于服务的单元。
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Unit_File_Create"></a>创建自定义单元文件</h2></div></div></div><p>从头开始创建单元文件有几种用例：您可以运行自定义守护程序，创建某个现有服务<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#ex-Managing_Services_with_systemd-Multiple_sshd" title="Example 3.18. Creating a second instance of the sshd service">的第二个实例</a> （如<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#ex-Managing_Services_with_systemd-Multiple_sshd" title="例3.18。创建sshd服务的第二个实例">创建sshd服务的第二个实例</a> ），或导入SysV init脚本（ <a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Convert" title="Converting SysV init scripts to unit files">转换中的</a>更多内容） <a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Convert" title="将SysV init脚本转换为单元文件">SysV init脚本到单元文件</a> ）。另一方面，如果您只想修改或扩展现有单元的行为，请使用<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Modify" title="修改现有的单元文件">修改现有单元文件中的说明</a> 。以下过程描述了创建自定义服务的一般过程：</p><div class="orderedlist"><a id="proc-Managing_Services_with_systemd-Unit_File_Create"></a><ol class="orderedlist"><li class="listitem">使用自定义服务准备可执行文件。这可以是自定义创建的脚本，也可以是软件提供商提供的可执行文件。如果需要，准备一个PID文件以保存自定义服务主进程的常量PID。还可以包含环境文件来存储服务的shell变量。确保源脚本是可执行的（通过执行<code class="literal">chmod a+x</code> ）并且不是交互式的。
						</li><li class="listitem"><p class="simpara">在<code class="literal">/etc/systemd/system/</code>目录中创建一个单元文件，并确保它具有正确的文件权限。以<code class="literal">root</code>身份执行：</p><pre class="literallayout"><code class="literal">touch /etc/systemd/system/<span class="emphasis"><em>name</em></span>.service</code>

<code class="literal">chmod 664 /etc/systemd/system/<span class="emphasis"><em>name</em></span>.service</code></pre><p class="simpara">将<span class="emphasis"><em>name</em></span>替换为要创建的服务的名称。请注意，该文件不需要是可执行的。
						</p></li><li class="listitem"><p class="simpara">打开上一步中创建的<code class="literal"><span class="emphasis"><em>name</em></span> .service</code>文件，然后添加服务配置选项。根据您要创建的服务类型，可以使用多种选项，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Structure" title="了解单元文件结构">“了解单元文件结构”一节</a> 。以下是与网络相关的服务的示例单元配置：</p><pre class="literallayout">[Unit]
Description=<span class="emphasis"><em>service_description</em></span>
After=network.target

[Service]
ExecStart=<span class="emphasis"><em>path_to_executable</em></span>
Type=forking
PIDFile=<span class="emphasis"><em>path_to_pidfile</em></span>

[Install]
WantedBy=default.target</pre><p class="simpara">哪里：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<span class="emphasis"><em>service_description</em></span>是一个信息性描述，显示在日志日志文件和<code class="literal">systemctl status</code>命令的输出中。
								</li><li class="listitem"><code class="literal">After</code>设置确保仅在网络运行后启动服务。添加以空格分隔的其他相关服务或目标列表。
								</li><li class="listitem">
									<span class="emphasis"><em>path_to_executable</em></span>代表实际服务可执行文件的路径。
								</li><li class="listitem">
									<code class="literal">Type=forking</code>用于进行fork系统调用的守护进程。使用<span class="emphasis"><em>path_to_pidfile中</em></span>指定的PID创建服务的主进程。在<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Service_Sec_Options" title="表3.10。重要的[服务]部分选项">表3.10“重要[服务]部分选项”中</a>查找其他启动类型。
								</li><li class="listitem">
									<code class="literal">WantedBy</code>说明应该启动服务的目标。可以将这些目标视为旧运行级别概念的替代，有关详细信息，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#working-with-systemd-targets_managing-services-with-systemd" title="使用systemd目标">“使用systemd目标”一节</a> 。
								</li></ul></div></li><li class="listitem"><p class="simpara">通过以<code class="literal">root</code>身份执行以下命令，通知<span class="strong"><strong><span class="application">systemd</span></strong></span>存在新<code class="literal"><span class="emphasis"><em>name</em></span> .service</code>文件：</p><pre class="literallayout"><code class="literal">systemctl daemon-reload</code>

<code class="literal">systemctl start <span class="emphasis"><em>name</em></span>.service</code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">警告</h3><p>始终在创建新单元文件或修改现有单元文件后运行<code class="literal">systemctl daemon-reload</code>命令。否则， <code class="literal">systemctl start</code>或<code class="literal">systemctl enable</code>命令可能会因磁盘上<span class="strong"><strong><span class="application">systemd</span></strong></span>和实际服务单元文件的状态不匹配而失败。请注意，在具有大量单元的系统上，这可能需要很长时间，因为每个单元的状态必须在重新加载期间被序列化并随后反序列化。
							</p></div></li></ol></div><div class="example"><a id="exam-Managing_Services_with_systemd-Emacs_Service"></a><p class="title"><strong>例3.17。创建emacs.service文件</strong></p><div class="example-contents"><p>使用<span class="strong"><strong><span class="application">Emacs</span></strong></span>文本编辑器时，让它在后台运行通常更快更方便，而不是在编辑文件时启动程序的新实例。以下步骤说明如何为Emacs创建单元文件，以便可以像处理服务一样处理它。
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">在<code class="literal">/etc/systemd/system/</code>目录中创建一个单元文件，并确保它具有正确的文件权限。以<code class="literal">root</code>身份执行：</p><pre class="literallayout">~]# touch /etc/systemd/system/emacs.service</pre><pre class="literallayout">~]# chmod 664 /etc/systemd/system/emacs.service</pre></li><li class="listitem"><p class="simpara">将以下内容添加到文件中：</p><pre class="literallayout">[Unit]
Description=Emacs: the extensible, self-documenting text editor

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=always

[Install]
WantedBy=default.target</pre><p class="simpara">使用上面的配置， <code class="literal">/usr/bin/emacs</code>可执行文件在服务启动时以守护进程模式启动。SSH_AUTH_SOCK环境变量使用代表运行时目录的“％t”单位说明符设置。如果意外退出，该服务还会重新启动emacs进程。
							</p></li><li class="listitem"><p class="simpara">执行以下命令重新加载配置并启动自定义服务：</p><pre class="literallayout">~]# systemctl daemon-reload</pre><pre class="literallayout">~]# systemctl start emacs.service</pre></li></ol></div><p>由于编辑器现在已注册为systemd服务，因此您可以使用所有标准<code class="literal">systemctl</code>命令。例如，运行<code class="literal">systemctl status emacs</code>以显示编辑器的状态或<code class="literal">systemctl enable emacs</code>以使编辑器在系统引导时自动启动。
					</p></div></div><div class="example"><a id="ex-Managing_Services_with_systemd-Multiple_sshd"></a><p class="title"><strong>例3.18。创建sshd服务的第二个实例</strong></p><div class="example-contents"><p>系统管理员通常需要配置和运行多个服务实例。这是通过创建原始服务配置文件的副本并修改某些参数来完成的，以避免与服务的主要实例发生冲突。以下过程说明如何创建<code class="literal">sshd</code>服务的第二个实例：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">创建将由第二个守护程序使用的<code class="literal">sshd_config</code>文件的副本：</p><pre class="literallayout">~]# cp /etc/ssh/sshd{,-second}_config</pre></li><li class="listitem"><p class="simpara">编辑在上一步中创建的<code class="literal">sshd-second_config</code>文件，为第二个守护程序分配不同的端口号和PID文件：</p><pre class="literallayout">Port 22220
PidFile /var/run/sshd-second.pid</pre><p class="simpara">有关<code class="literal">Port</code>和<code class="literal">PidFile</code>选项的更多信息，请参见<code class="literal">sshd_config</code> （5）手册页。确保您选择的端口未被任何其他服务使用。在运行服务之前，PID文件不必存在，它在服务启动时自动生成。
							</p></li><li class="listitem"><p class="simpara">为<code class="literal">sshd</code>服务创建systemd单元文件的副本：</p><pre class="literallayout">~]# cp /usr/lib/systemd/system/sshd.service /etc/systemd/system/sshd-second.service</pre></li><li class="listitem"><p class="simpara">更改上一步中创建的<code class="literal">sshd-second.service</code> ，如下所示：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">修改<code class="literal">Description</code>选项：</p><pre class="literallayout">Description=OpenSSH server second instance daemon</pre></li><li class="listitem"><p class="simpara">将sshd.service添加到<code class="literal">After</code>选项中指定的服务，以便第二个实例仅在第一个实例已经启动后才启动：</p><pre class="literallayout">After=syslog.target network.target auditd.service sshd.service</pre></li><li class="listitem">sshd的第一个实例包括密钥生成，因此删除<span class="strong"><strong>ExecStartPre = / usr / sbin / sshd-keygen</strong></span>行。
									</li><li class="listitem"><p class="simpara">将<code class="literal">-f /etc/ssh/sshd-second_config</code>参数添加到<code class="literal">sshd</code>命令，以便使用备用配置文件：</p><pre class="literallayout">ExecStart=/usr/sbin/sshd -D -f /etc/ssh/sshd-second_config $OPTIONS</pre></li><li class="listitem"><p class="simpara">经过上述修改后，sshd-second.service应如下所示：</p><pre class="literallayout">[Unit]
Description=OpenSSH server second instance daemon
After=syslog.target network.target auditd.service sshd.service

[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D -f /etc/ssh/sshd-second_config $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target</pre></li></ol></div></li><li class="listitem"><p class="simpara">如果使用SELinux，请将第二个sshd实例的端口添加到SSH端口，否则将拒绝第二个sshd实例绑定到端口：</p><pre class="literallayout">~]# semanage port -a -t ssh_port_t -p tcp 22220</pre></li><li class="listitem"><p class="simpara">启用sshd-second.service，以便在启动时自动启动：</p><pre class="literallayout">~]# systemctl enable sshd-second.service</pre><p class="simpara">使用<code class="literal">systemctl status</code>命令验证sshd-second.service是否正在运行。此外，通过连接到服务来验证端口是否已正确启用：</p><pre class="literallayout">~]$ <code class="literal">ssh -p 22220 user@server</code></pre><p class="simpara">如果正在使用防火墙，请确保已正确配置防火墙，以便允许连接到第二个sshd实例。
							</p></li></ol></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">要了解如何正确选择自定义单元文件的排序和依赖关系的目标，请参阅以下文章</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										<a class="link" href="https://access.redhat.com/solutions/3120581">如何编写强制执行特定服务的服务单元文件</a>
									</li><li class="listitem">
										<a class="link" href="https://access.redhat.com/solutions/3116611">如何确定systemd服务单元定义应具有的依赖关系</a>
									</li></ul></div></dd></dl></div><p>红帽知识库文章中提供了有关单元文件中的排序和依赖项触发的一些实际案例的附加信息。 <a class="link" href="https://access.redhat.com/solutions/3120801">是否有关于编写单元文件的有用信息？</a>
				</p><p>如果要为<code class="literal">systemd</code>启动的服务设置限制，请参阅Red Hat知识库文章<a class="link" href="https://access.redhat.com/solutions/1257953">如何在RHEL 7和systemd中设置服务限制</a> 。需要在服务的单元文件中设置这些限制。请注意， <code class="literal">systemd</code>忽略了<code class="literal">/etc/security/limits.conf</code>和<code class="literal">/etc/security/limits.d/*.conf</code>配置文件中设置的限制。这些文件中定义的限制由PAM在启动登录会话时设置，但是<code class="literal">systemd</code>启动的守护程序不使用PAM登录会话。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Unit_File_Convert"></a>将SysV init脚本转换为单元文件</h2></div></div></div><p>在花时间将SysV init脚本转换为单元文件之前，请确保转换尚未在其他位置完成。Red Hat Enterprise Linux上安装的所有核心服务都带有默认的单元文件，这同样适用于许多第三方软件包。
				</p><p>将init脚本转换为单元文件需要分析脚本并从中提取必要的信息。根据此数据，您可以创建单元文件。由于init脚本可能因服务类型而有很大差异，因此您可能需要使用更多配置选项进行翻译，而不是本章所述。请注意，systemd单元不再支持init脚本可用的某些级别的自定义。
				</p><p>转换所需的大部分信息都在脚本的标题中提供。以下示例显示了用于在Red Hat Enterprise Linux 6上启动<code class="literal">postfix</code>服务的init脚本的开始部分：</p><pre class="literallayout"><span class="marked">!/bin/bash # postfix Postfix Mail Transfer Agent # chkconfig: 2345 80 30 # description: Postfix is a Mail Transport Agent, which is the program that moves mail from one machine to another. # processname: master # pidfile: /var/spool/postfix/pid/master.pid # config: /etc/postfix/main.cf # config: /etc/postfix/master.cf <span class="marked"/> BEGIN INIT INFO # Provides: postfix MTA # Required-Start: $local_fs $network $remote_fs # Required-Stop: $local_fs $network $remote_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: start and stop postfix # Description: Postfix is a Mail Transport Agent, which is the program that moves mail from one machine to another. </span># END INIT INFO</pre><p>在上面的例子中，只有开始<span class="strong"><strong>的chkconfig＃</strong></span>和<span class="strong"><strong>＃描述</strong></span>线是强制性的，所以你可能找不到在不同的初始化文件的其余部分。<span class="strong"><strong>BEGIN INIT INFO</strong></span>和<span class="strong"><strong>END INIT INFO</strong></span>行之间的文本称为<span class="strong"><strong>Linux标准库（LSB）标题</strong></span> 。如果指定，LSB头包含定义服务描述，依赖项和默认运行级别的指令。以下是旨在收集新单元文件所需数据的分析任务的概述。以postfix init脚本为例，请参见<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#exam-Managing_Services_with_systemd-postfix_unit_file" title="例3.16。 postfix.service单元文件">例3.16“postfix.service unit file”中</a>生成的postfix单元文件。
				</p><h4><a id="Managing_Services_with_systemd-Init_Desc"></a>查找服务说明</h4><p>在<span class="strong"><strong>#description</strong></span>开头的行上查找有关脚本的描述性信息。将此说明与单元文件的[Unit]部分的<code class="literal">Description</code>选项中的服务名称一起使用。LSB标头可能包含<span class="strong"><strong>＃Short-Description</strong></span>和<span class="strong"><strong>#Description</strong></span>行上的类似数据。
				</p><h4><a id="Managing_Services_with_systemd-Init_Deps"></a>查找服务依赖项</h4><p>LSB头可能包含几个指令，这些指令形成服务之间的依赖关系。其中大多数可以转换为systemd单元选项，请<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Init_Deps" title="表3.12。LSB标头中的依赖选项">参见表3.12“LSB头中的依赖选项”</a>
				</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Init_Deps"></a><p class="title"><strong>表3.12。LSB标头中的依赖选项</strong></p><div class="table-contents"><table border="1" summary="Dependency options from the LSB header"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">LSB选项</th><th valign="top" style="text-align:left">描述</th><th valign="top" style="text-align:left">单位文件等价</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">提供</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>指定可在其他init脚本中引用的服务的引导设施名称（带有“$”前缀）。这不再需要，因为单元文件通过文件名引用其他单元。
								</p>
								 </td><td valign="top" style="text-align:left"> <p>-</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">所需启动</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>包含所需服务的引导设施名称。这被转换为排序依赖性，引导设施名称被相应服务的单元文件名或它们所属的目标替换。例如，在<code class="literal">postfix</code>情况下，$ network上的Required-Start依赖项被转换为After依赖于network.target。
								</p>
								 </td><td valign="top" style="text-align:left"> <p>
									<code class="literal">After</code> ， <code class="literal">Before</code>
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">如若启动</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>构成比Required-Start更弱的依赖关系。失败应该启动依赖项不会影响服务启动。
								</p>
								 </td><td valign="top" style="text-align:left"> <p>
									<code class="literal">After</code> ， <code class="literal">Before</code>
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">Required-Stop</code> ， <code class="literal">Should-Stop</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>构成负面依赖关系。
								</p>
								 </td><td valign="top" style="text-align:left"> <p>
									<code class="literal">冲突</code>
								</p>
								 </td></tr></tbody></table></div></div><h4><a id="Managing_Services_with_systemd-Init_Targs"></a>查找服务的默认目标</h4><p>以<span class="strong"><strong>#chkconfig</strong></span>开头的行包含三个数值。最重要的是表示服务启动的默认运行级别的第一个数字。将这些运行级别映射到等效的systemd目标。然后在单元文件的[Install]部分的<code class="literal">WantedBy</code>选项中列出这些目标。例如， <code class="literal">postfix</code>先前在运行级别2,3,4和5中启动，转换为multi-user.target和graphical.target。请注意，graphical.target依赖于multiuser.target，因此没有必要同时指定两者，如<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#exam-Managing_Services_with_systemd-postfix_unit_file" title="例3.16。 postfix.service单元文件">例3.16“postfix.service unit file”</a> 。您可以在LSB标头中的<span class="strong"><strong>＃Default-Start</strong></span>和<span class="strong"><strong>#Default-Stop</strong></span>行中找到有关默认和禁用运行级别的信息。
				</p><p><span class="strong"><strong>#chkconfig</strong></span>行上指定的其他两个值表示init脚本的启动和关闭优先级。如果它加载init脚本，则<span class="strong"><strong><span class="application">systemd</span></strong></span>会解释这些值，但没有等效的单元文件。
				</p><h4><a id="Managing_Services_with_systemd-Init_Runlevels"></a>查找服务使用的文件</h4><p>Init脚本需要从专用目录加载函数库，并允许导入配置，环境和PID文件。环境变量在init脚本头中以<span class="strong"><strong>#config</strong></span>开头的行上指定，该行转换为<code class="literal">EnvironmentFile</code>单元文件选项。在<span class="strong"><strong>#pidfile</strong></span> init脚本行上指定的PID文件将使用<code class="literal">PIDFile</code>选项导入到单元文件中。
				</p><p>未包含在init脚本标头中的关键信息是服务可执行文件的路径，以及服务所需的其他一些文件。在以前版本的Red Hat Enterprise Linux中，init脚本使用Bash case语句来定义服务在默认操作（如<span class="strong"><strong>启动</strong></span> ， <span class="strong"><strong>停止</strong></span>或<span class="strong"><strong>重新启动</strong></span> ）以及自定义操作上的行为。以下来自<code class="literal">postfix</code> init脚本的摘录显示了在服务启动时要执行的代码块。
				</p><pre class="literallayout">conf_check() {
    [ -x /usr/sbin/postfix ] || exit 5
    [ -d /etc/postfix ] || exit 6
    [ -d /var/spool/postfix ] || exit 5
}

make_aliasesdb() {
	if [ "$(/usr/sbin/postconf -h alias_database)" == "hash:/etc/aliases" ]
	then
		# /etc/aliases.db might be used by other MTA, make sure nothing
		# has touched it since our last newaliases call
		[ /etc/aliases -nt /etc/aliases.db ] ||
			[ "$ALIASESDB_STAMP" -nt /etc/aliases.db ] ||
			[ "$ALIASESDB_STAMP" -ot /etc/aliases.db ] || return
		/usr/bin/newaliases
		touch -r /etc/aliases.db "$ALIASESDB_STAMP"
	else
		/usr/bin/newaliases
	fi
}

start() {
	[ "$EUID" != "0" ] &amp;&amp; exit 4
	# Check that networking is up.
	[ ${NETWORKING} = "no" ] &amp;&amp; exit 1
	conf_check
	# Start daemons.
	echo -n $"Starting postfix: "
	make_aliasesdb &gt;/dev/null 2&gt;&amp;1
	[ -x $CHROOT_UPDATE ] &amp;&amp; $CHROOT_UPDATE
	/usr/sbin/postfix start 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog start"
	RETVAL=$?
	[ $RETVAL -eq 0 ] &amp;&amp; touch $lockfile
        echo
	return $RETVAL
}</pre><p>init脚本的可扩展性允许指定从<code class="literal">start()</code>函数块调用的两个自定义函数<code class="literal">conf_check()</code>和<code class="literal">make_aliasesdb()</code> 。仔细看看，上面的代码中提到了几个外部文件和目录：主服务可执行文件<code class="literal">/usr/sbin/postfix</code> ， <code class="literal">/etc/postfix/</code>和<code class="literal">/var/spool/postfix/</code> configuration目录，以及<code class="literal">/usr/sbin/postconf/</code>目录。
				</p><p>
					<span class="strong"><strong><span class="application">Systemd</span></strong></span>仅支持预定义的操作，但允许使用<code class="literal">ExecStart</code> ， <code class="literal">ExecStartPre</code> ， <code class="literal">ExecStartPost</code> ， <code class="literal">ExecStop</code>和<code class="literal">ExecReload</code>选项执行自定义可执行文件。<code class="literal">/usr/sbin/postfix</code>以及支持脚本在服务启动时执行。请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#exam-Managing_Services_with_systemd-postfix_unit_file" title="例3.16。 postfix.service单元文件">例3.16“postfix.service unit file”中</a>的<code class="literal">postfix</code>单元文件。
				</p><p>转换复杂的init脚本需要了解脚本中每个语句的用途。某些语句特定于操作系统版本，因此您无需翻译它们。另一方面，在新环境中可能需要进行一些调整，包括单元文件以及服务可执行文件和支持文件。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Unit_File_Modify"></a>修改现有的单元文件</h2></div></div></div><p>系统上安装的服务带有默认的单元文件，这些文件存储在<code class="literal">/usr/lib/systemd/system/</code>目录中。系统管理员不应直接修改这些文件，因此任何自定义都必须限制在<code class="literal">/etc/systemd/system/</code>目录中的配置文件中。根据所需更改的范围，选择以下方法之一：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">在<code class="literal">/etc/systemd/system/ <span class="emphasis"><em>unit</em></span> .d/</code>创建补充配置文件的目录。对于大多数用例，建议使用此方法。它允许使用其他功能扩展默认配置，同时仍然引用原始单元文件。因此，自动应用对包升级引入的默认单元的更改。有关详细信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Extending_Unit_Config" title="扩展默认单元配置">扩展默认单元配置</a> 。
						</li><li class="listitem">在<code class="literal">/etc/systemd/system/</code>创建原始单元文件<code class="literal">/usr/lib/systemd/system/</code>的副本并在那里进行更改。副本将覆盖原始文件，因此不会应用随程序包更新引入的更改。无论包更新如何，此方法对于进行重要的单位更改非常有用。有关详细信息，请参阅<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Overriding_Unit_Mod" title="覆盖默认单位配置">覆盖默认单元配置</a> 。
						</li></ul></div><p>要返回到设备的默认配置，只需删除<code class="literal">/etc/systemd/system/</code>自定义创建的配置文件。要在不重新引导系统的情况下将更改应用于单元文件，请执行：</p><pre class="literallayout"><code class="literal">systemctl daemon-reload</code></pre><p><code class="literal">daemon-reload</code>选项重新加载所有单元文件并重新创建整个依赖关系树，这是立即将任何更改应用于单元文件所需的。作为替代方案，您可以使用以下命令获得相同的结果，该命令必须在<code class="literal">root</code>用户下执行：</p><pre class="literallayout"><code class="literal">init q</code></pre><p>此外，如果修改后的单元文件属于正在运行的服务，则必须重新启动此服务才能接受新设置：</p><pre class="literallayout"><code class="literal">systemctl restart <span class="emphasis"><em>name</em></span>.service</code></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">重要</h3><p>要修改由SysV initscript处理的服务的属性（如依赖关系或超时），请不要修改initscript本身。而是为服务创建<code class="literal">systemd</code>插入配置文件，如<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Extending_Unit_Config" title="扩展默认单元配置">扩展默认单元配置</a>和<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Overriding_Unit_Mod" title="覆盖默认单位配置">覆盖默认单元配置中所述</a> 。然后以与普通<code class="literal">systemd</code>服务相同的方式管理此服务。
					</p><p>例如，要扩展<code class="literal">network</code>服务的配置，请不要修改<code class="literal">/etc/rc.d/init.d/network</code> initscript文件。相反，创建新的目录<code class="literal">/etc/systemd/system/network.service.d/</code>和<code class="literal">systemd</code>投递文件<code class="literal">/etc/systemd/system/network.service.d/ <span class="emphasis"><em>my_config</em></span> .conf</code> 。然后，将修改后的值放入drop-in文件中。注意： <code class="literal">systemd</code>将<code class="literal">network</code>服务知道为<code class="literal">network.service</code> ，这就是创建的目录必须被称为<code class="literal">network.service.d</code>
					</p></div><h4><a id="Managing_Services_with_systemd-Extending_Unit_Config"></a>扩展默认单元配置</h4><p>要使用其他配置选项扩展默认单元文件，请首先在<code class="literal">/etc/systemd/system/</code>创建配置目录。如果扩展服务单元，请以<code class="literal">root</code>身份执行以下命令：</p><pre class="literallayout"><code class="literal">mkdir /etc/systemd/system/<span class="emphasis"><em>name</em></span>.service.d/</code></pre><p>将<span class="emphasis"><em>name</em></span>替换<span class="emphasis"><em>为</em></span>要扩展的服务的名称。以上语法适用于所有单位类型。
				</p><p>在上一步中创建的目录中创建配置文件。请注意，文件名必须以<span class="strong"><strong>.conf</strong></span>后缀结尾。类型：</p><pre class="literallayout">touch /etc/systemd/system/name.service.d/config_name.conf</pre><p>将<span class="emphasis"><em>config_name</em></span>替换为配置文件的名称。此文件遵循正常的单元文件结构，因此必须在相应的部分下指定所有指令，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Unit_File_Structure" title="了解单元文件结构">“了解单元文件结构”一节</a> 。
				</p><p>例如，要添加自定义依赖项，请使用以下内容创建配置文件：</p><pre class="literallayout">[Unit]
Requires=<span class="emphasis"><em>new_dependency</em></span>
After=<span class="emphasis"><em>new_dependency</em></span></pre><p>其中<span class="emphasis"><em>new_dependency</em></span>表示<span class="emphasis"><em>要将</em></span>单元标记为依赖项。另一个示例是在主进程退出后重新启动服务的配置文件，延迟为30秒：</p><pre class="literallayout">[Service]
Restart=always
RestartSec=30</pre><p>建议创建仅针对一个任务的小配置文件。这些文件可以轻松移动或链接到其他服务的配置目录。
				</p><p>要应用对单元所做的更改，请以<code class="literal">root</code>身份执行：</p><pre class="literallayout"><code class="literal">systemctl daemon-reload</code>
<code class="literal">systemctl restart <span class="emphasis"><em>name</em></span>.service</code></pre><div class="example"><a id="exam-Managing_Services_with_systemd-Extending_Unit_Config"></a><p class="title"><strong>例3.19。扩展httpd.service配置</strong></p><div class="example-contents"><p>要修改httpd.service单元以便在启动Apache服务时自动执行自定义shell脚本，请执行以下步骤。首先，创建一个目录和一个自定义配置文件：</p><pre class="literallayout">~]# mkdir /etc/systemd/system/httpd.service.d/</pre><pre class="literallayout">~]# touch /etc/systemd/system/httpd.service.d/custom_script.conf</pre><p>如果要使用Apache自动启动的脚本位于<code class="literal">/usr/local/bin/custom.sh</code> ，请将以下文本插入<code class="literal">custom_script.conf</code>文件：</p><pre class="literallayout">[Service]
ExecStartPost=/usr/local/bin/custom.sh</pre><p>要应用单位更改，请执行：</p><pre class="literallayout">~]# systemctl daemon-reload</pre><pre class="literallayout">~]# systemctl restart httpd.service</pre></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p><code class="literal">/etc/systemd/system/</code>配置目录的配置文件优先于<code class="literal">/usr/lib/systemd/system/</code>单元文件。因此，如果配置文件包含只能指定一次的选项（如<code class="literal">Description</code>或<code class="literal">ExecStart</code> ，则会覆盖此选项的默认值。请注意，在<a class="link" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Monitoring_Overrides" title="监控覆盖单位">监视覆盖单位中</a>描述的<code class="literal">systemd-delta</code>命令的输出中，此类单位始终标记为[EXTENDED]，即使总而言之，某些选项实际上已被覆盖。
					</p></div><h4><a id="Managing_Services_with_systemd-Overriding_Unit_Mod"></a>覆盖默认单位配置</h4><p>要在更新提供单元文件的程序包后进行更改，请先将文件复制到<code class="literal">/etc/systemd/system/</code>目录。为此，请以<code class="literal">root</code>身份执行以下命令：</p><pre class="literallayout"><code class="literal">cp /usr/lib/systemd/system/<span class="emphasis"><em>name</em></span>.service /etc/systemd/system/<span class="emphasis"><em>name</em></span>.service</code></pre><p>其中<span class="emphasis"><em>name</em></span>代表您要修改的服务单位的名称。以上语法适用于所有单位类型。
				</p><p>使用文本编辑器打开复制的文件，然后进行所需的更改。要应用单位更改，请以<code class="literal">root</code>身份执行：</p><pre class="literallayout"><code class="literal">systemctl daemon-reload</code>
<code class="literal">systemctl restart <span class="emphasis"><em>name</em></span>.service</code></pre><div class="example"><a id="Overriding_Unit_Mod-Change-timout-limit"></a><p class="title"><strong>例3.20。更改超时限制</strong></p><div class="example-contents"><p>您可以指定每个服务的超时值，以防止故障服务冻结系统。否则，对于正常服务，超时默认设置为90秒，对于SysV兼容服务，默认设置为300秒。
					</p><p>例如，要扩展<code class="literal">httpd</code>服务的超时限制：</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">将<code class="literal">httpd</code>单元文件复制到<code class="literal">/etc/systemd/system/</code>目录：</p><pre class="literallayout"><code class="literal">cp /usr/lib/systemd/system/httpd.service /etc/systemd/system/httpd.service</code></pre></li><li class="listitem"><p class="simpara">打开文件<code class="literal">/etc/systemd/system/httpd.service</code>并在<code class="literal">[Service]</code>部分中指定<code class="literal">TimeoutStartUSec</code>值：</p><pre class="literallayout"><span class="emphasis"><em>…​</em></span>
[Service]
<span class="emphasis"><em>…​</em></span>
PrivateTmp=true
<span class="strong"><strong>TimeoutStartSec=10</strong></span>

[Install]
WantedBy=multi-user.target
<span class="emphasis"><em>…​</em></span></pre></li><li class="listitem"><p class="simpara">重新加载<code class="literal">systemd</code>守护程序：</p><pre class="literallayout"><code class="literal">systemctl daemon-reload</code></pre></li><li class="listitem"><p class="simpara">
								<span class="strong"><strong>可选的。</strong></span> 验证新的超时值：</p><pre class="literallayout"><code class="literal">systemctl show httpd -p TimeoutStartUSec</code></pre></li></ol></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>要全局更改超时限制，请在<code class="literal">/etc/systemd/system.conf</code>文件中输入<code class="literal">DefaultTimeoutStartSec</code> 。
					</p></div><h4><a id="Managing_Services_with_systemd-Monitoring_Overrides"></a>监控覆盖单位</h4><p>要显示已覆盖或已修改的单元文件的概述，请使用以下命令：</p><pre class="literallayout"><code class="literal">systemd-delta</code></pre><p>例如，上述命令的输出可能如下所示：</p><pre class="literallayout">[EQUIVALENT] /etc/systemd/system/default.target → /usr/lib/systemd/system/default.target
[OVERRIDDEN] /etc/systemd/system/autofs.service → /usr/lib/systemd/system/autofs.service

--- /usr/lib/systemd/system/autofs.service      2014-10-16 21:30:39.000000000 -0400
+ /etc/systemd/system/autofs.service  2014-11-21 10:00:58.513568275 -0500
@@ -8,7 +8,8 @@
 EnvironmentFile=-/etc/sysconfig/autofs
 ExecStart=/usr/sbin/automount $OPTIONS --pid-file /run/autofs.pid
 ExecReload=/usr/bin/kill -HUP $MAINPID
-TimeoutSec=180
+TimeoutSec=240
+Restart=Always

 [Install]
 WantedBy=multi-user.target

[MASKED]     /etc/systemd/system/cups.service → /usr/lib/systemd/system/cups.service
[EXTENDED]   /usr/lib/systemd/system/sssd.service → /etc/systemd/system/sssd.service.d/journal.conf

4 overridden configuration files found.</pre><p>
					<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Override_types" title="表3.13。 systemd-delta差异类型">表3.13“systemd-delta差异类型”</a>列出了可以出现在<code class="literal">systemd-delta</code>输出中的覆盖类型。请注意，如果覆盖了文件，则<code class="literal">systemd-delta</code>默认显示类似于<code class="literal">diff</code>命令输出的更改摘要。
				</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Override_types"></a><p class="title"><strong>表3.13。 systemd-delta差异类型</strong></p><div class="table-contents"><table border="1" summary="systemd-delta difference types"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">类型</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>[MASKED]</p>
								 </td><td valign="top" style="text-align:left"> <p>屏蔽的单元文件，有关单元屏蔽的说明，请参阅<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#Managing_Services_with_systemd-Services-Disable" title="禁用服务">“禁用服务”一节</a> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>[当量]</p>
								 </td><td valign="top" style="text-align:left"> <p>未修改的副本，覆盖原始文件但内容不同，通常是符号链接。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>[REDIRECTED]</p>
								 </td><td valign="top" style="text-align:left"> <p>重定向到另一个文件的文件。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>[重写]</p>
								 </td><td valign="top" style="text-align:left"> <p>覆盖和更改文件。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>[扩展]</p>
								 </td><td valign="top" style="text-align:left"> <p>使用<code class="literal">/etc/systemd/system/ <span class="emphasis"><em>unit</em></span> .d/</code>目录中的.conf文件扩展的文件。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>[UNCHANGED]</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当使用<code class="literal">--type=unchanged</code>选项时， <code class="literal">--type=unchanged</code>显示未修改的文件。
								</p>
								 </td></tr></tbody></table></div></div><p>最好在系统更新后运行<code class="literal">systemd-delta</code> ，以检查当前是否有自定义配置覆盖的默认单元的更新。也可以仅将输出限制为某种差异类型。例如，要仅查看被覆盖的单元，请执行：</p><pre class="literallayout"><code class="literal">systemd-delta --type=overridden</code></pre><p>如果要编辑单元文件并使用提交的更改自动创建插入文件，请使用以下命令：</p><pre class="literallayout">~]# systemctl edit <span class="emphasis"><em>unit_name.type_extension</em></span></pre><p>要转储应用所有覆盖和插件的单元配置，请使用以下命令：</p><pre class="literallayout">~]# systemctl cat <span class="emphasis"><em>unit_name.type_extension</em></span></pre><p>将<span class="emphasis"><em>unit_name.type_extension</em></span>替换为所需单元的名称及其类型，例如<code class="literal">tuned.service</code> 。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Managing_Services_with_systemd-Instantiated_Units"></a>使用实例化单元</h2></div></div></div><p>可以在运行时从单个模板配置文件中实例化多个单元。“@”字符用于标记模板并将单元与其关联。可以从另一个单元文件（使用<code class="literal">Requires</code>或<code class="literal">Wants</code>选项）或<code class="literal">systemctl start</code>命令启动实例化单元。实例化的服务单元按以下方式命名：</p><pre class="literallayout"><span class="emphasis"><em>template_name</em></span>@<span class="emphasis"><em>instance_name</em></span>.service</pre><p>其中<span class="emphasis"><em>template_name</em></span>代表模板配置文件的名称。将<span class="emphasis"><em>instance_name</em></span>替换为单元实例的名称。有几个实例可以指向相同的模板文件，其中包含该单元所有实例的通用配置选项。模板单元名称的格式为：</p><pre class="literallayout"><span class="emphasis"><em>unit_name</em></span>@.service</pre><p>例如，以下<code class="literal">Wants</code>在单元文件中设置：</p><pre class="literallayout">Wants=getty@ttyA.service getty@ttyB.service</pre><p>首先对系统搜索给定的服务单元。如果找不到这样的单元，则忽略“@”和类型后缀之间的部分， <span class="strong"><strong><span class="application">systemd</span></strong></span>搜索<code class="literal">getty@.service</code>文件，从中读取配置，然后启动服务。
				</p><p>通配符（称为<span class="strong"><strong>单位说明符</strong></span> ）可用于任何单位配置文件。单位说明符替换某些单位参数，并在运行时进行解释。<a class="xref" href="managing-services-with-systemd_configuring-basic-system-settings.html#tabl-Managing_Services_with_systemd-Unit_Specifiers" title="表3.14。重要的单位指定者">表3.14，“重要单元说明符”</a>列出了对模板单元特别有用的单元说明符。
				</p><div class="table"><a id="tabl-Managing_Services_with_systemd-Unit_Specifiers"></a><p class="title"><strong>表3.14。重要的单位指定者</strong></p><div class="table-contents"><table border="1" summary="Important unit specifiers"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">单位说明符</th><th valign="top" style="text-align:left">含义</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％N</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>完整的单位名称</p>
								 </td><td valign="top" style="text-align:left"> <p>代表完整的单位名称，包括类型后缀。<code class="literal">%N</code>具有相同的含义，但也用ASCII代码替换禁用的字符。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％p</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>前缀名称</p>
								 </td><td valign="top" style="text-align:left"> <p>代表已删除类型后缀的单元名称。对于实例化单元，％p代表“@”字符前的单元名称部分。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％一世</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>实例名称</p>
								 </td><td valign="top" style="text-align:left"> <p>实例化单元名称的一部分是“@”字符和类型后缀之间的部分。<code class="literal">%I</code>具有相同的含义，但也替换了ASCII码的禁用字符。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％H</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>主机名</p>
								 </td><td valign="top" style="text-align:left"> <p>在加载单元配置的时间点代表正在运行的系统的主机名。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％T</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>运行时目录</p>
								 </td><td valign="top" style="text-align:left"> <p>表示运行时目录，该目录是<code class="literal">root</code>用户的<code class="literal">/run</code> ，或者是非特权用户的XDG_RUNTIME_DIR变量的值。
								</p>
								 </td></tr></tbody></table></div></div><p>有关单元说明符的完整列表，请参见<code class="literal">systemd.unit(5)</code>手册页。
				</p><p>例如， <code class="literal">getty@.service</code>模板包含以下指令：</p><pre class="literallayout">[Unit]
Description=Getty on %I
…​
[Service]
ExecStart=-/sbin/agetty --noclear %I $TERM
…​</pre><p>当getty@ttyA.service和getty@ttyB.service在上面的模板中实例化时， <code class="literal">Description</code> = <span class="strong"><strong>在ttyA</strong></span> <span class="strong"><strong>上</strong></span>解析为<span class="strong"><strong>Getty，在ttyB</strong></span> <span class="strong"><strong>上</strong></span>解析为<span class="strong"><strong>Getty</strong></span> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="optimizing-systemd-to-shorten-the-boot-time_managing-services-with-systemd"></a>优化systemd以缩短启动时间</h1></div></div></div><p>有一个默认启用的systemd单元文件列表。由这些单元文件定义的系统服务在引导时自动运行，这会影响引导时间。
			</p><p>本节介绍：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">检查系统启动性能的工具。
					</li><li class="listitem">默认情况下启用systemd单元的目的，以及可以安全地禁用此类systemd单元以缩短启动时间的环境。
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="examining-system-boot-performance_optimizing-systemd-to-shorten-the-boot-time"></a>检查系统启动性能</h2></div></div></div><p>要检查系统引导性能，可以使用<code class="literal">systemd-analyze</code>命令。此命令有许多选项可用。但是，本节仅介绍对系统调整可能很重要的选定部分，以缩短启动时间。
				</p><p>有关所有选项的完整列表和详细说明，请参见<code class="literal">systemd-analyze</code>手册页。
				</p><h4><a id="prerequisites_9"></a>先决条件</h4><p>在开始检查systemd以调整启动时间之前，您可能希望列出所有已启用的服务：</p><pre class="literallayout">~]$ systemctl list-unit-files --state=enabled</pre><h4><a id="analyzing_overall_boot_time"></a>分析整体启动时间</h4><h5><a id="procedure_10"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">有关上次成功启动所用时间的总体信息，请使用：</li></ul></div><pre class="literallayout">~]$ systemd-analyze</pre><h4><a id="analyzing_unit_initialization_time"></a>分析单元初始化时间</h4><h5><a id="procedure_11"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">有关每个systemd单元的初始化时间的信息，请使用：</li></ul></div><pre class="literallayout">~]$ systemd-analyze blame</pre><p>输出根据上次成功引导期间初始化所用的时间按降序列出单位。
				</p><h4><a id="identifying_critical_units"></a>确定关键单位</h4><h5><a id="procedure_12"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">要确定在上次成功启动时花费最多时间初始化的单元，请使用：</li></ul></div><pre class="literallayout">~]$ systemd-analyze critical-chain</pre><p>输出突出显示使用红色严重减慢启动速度的单位。
				</p><div class="figure"><a id="idm140276560717968"></a><p class="title"><strong>图3.1。systemd-analyze critical-chain命令的输出</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/systemd-analyze-critical.png" alt="systemd分析关键"></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="a-guide-to-selecting-services-that-can-be-safely-disabled_optimizing-systemd-to-shorten-the-boot-time"></a>选择可安全禁用的服务的指南</h2></div></div></div><p>如果您发现系统的启动时间很长，则可以通过禁用默认启动时启用的某些服务来缩短它。
				</p><p>要列出此类服务，请运行：</p><pre class="literallayout">~]$ systemctl list-unit-files --state=enabled</pre><p>要禁用服务，请运行：</p><pre class="literallayout">~]# systemctl disable <span class="emphasis"><em>service_name</em></span></pre><p>但是，某些服务必须保持启用状态，以便您的操作系统安全并以您需要的方式运行。
				</p><p>您可以使用下表作为选择可以安全禁用的服务的指南。该表列出了在最小安装的Red Hat Enterprise Linux 8上默认启用的所有服务，并为每个服务指出是否可以安全地禁用此服务。
				</p><p>该表还提供了有关可以禁用服务的环境的更多信息，或者您不应禁用该服务的原因。
				</p><div class="table"><a id="idm140276560706464"></a><p class="title"><strong>表3.15。默认情况下在最小安装RHEL 8上启用的服务</strong></p><div class="table-contents"><table border="1" summary="Services enabled by default on a minimal installation of RHEL 8"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">服务名称</th><th valign="top" style="text-align:left">可以禁用吗？</th><th valign="top" style="text-align:left">更多信息</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>auditd.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要来自内核的审核消息时，才禁用<code class="literal">auditd.service</code> 。请注意，如果禁用<code class="literal">auditd.service</code> ，则不会生成<code class="literal">/var/log/audit/audit.log</code>文件。因此，您无法追溯审查某些经常审查的操作或事件，例如用户登录，服务启动或密码更改。另请注意，auditd有两部分：内核部分和服务本身。通过使用<code class="literal">systemctl disable auditd</code>命令，您只能禁用服务，而不能禁用内核部分。要完全禁用系统审计，请在内核命令行上设置<code class="literal">audit=0</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>autovt @。服务</p>
								 </td><td valign="top" style="text-align:left"> <p>没有</p>
								 </td><td valign="top" style="text-align:left"> <p>此服务仅在确实需要时运行，因此不需要禁用它。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>crond.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>请注意，如果禁用crond.service，则不会运行crontab中的任何项目。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>DBUS-org.fedoraproject。FirewallD1.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p><code class="literal">firewalld.service</code>的符号链接
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>DBUS，org.freedesktop.NetworkManager.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p><code class="literal">NetworkManager.service</code>的符号链接
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>DBUS-org.freedesktop.nm-dispatcher.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p><code class="literal">NetworkManager-dispatcher.service</code>符号链接
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>firewalld.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>禁用<code class="literal">firewalld.service</code>只有当你不需要防火墙。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>盖蒂@。服务</p>
								 </td><td valign="top" style="text-align:left"> <p>没有</p>
								 </td><td valign="top" style="text-align:left"> <p>此服务仅在确实需要时运行，因此不需要禁用它。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>进口state.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要从网络存储启动时，才禁用<code class="literal">import-state.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>irqbalance.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您只有一个CPU时才禁用<code class="literal">irqbalance.service</code> 。不要在具有多个CPU的系统上禁用<code class="literal">irqbalance.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>kdump.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要来自内核崩溃的报告时，才禁用<code class="literal">kdump.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>loadmodules.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>除非存在<code class="literal">/etc/rc.modules</code>或<code class="literal">/etc/sysconfig/modules</code>目录，否则不会启动此服务，这意味着它不会在最小的RHEL 8安装上启动。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>LVM2-monitor.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在不使用逻辑卷管理器（LVM）时禁用<code class="literal">lvm2-monitor.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>microcode.service</p>
								 </td><td valign="top" style="text-align:left"> <p>没有</p>
								 </td><td valign="top" style="text-align:left"> <p>不要禁用该服务，因为它提供了CPU中微码软件的更新。</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>NetworkManager的-dispatcher.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要有关网络配置更改的通知时（例如，在静态网络中），才禁用<code class="literal">NetworkManager-dispatcher.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>NetworkManager的-WAIT-online.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您在引导后不需要可用的网络连接时，才禁用<code class="literal">NetworkManager-wait-online.service</code> 。如果启用该服务，则在网络连接工作之前，系统不会完成引导。这可能会显着延长启动时间。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>NetworkManager.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在不需要连接到网络时禁用<code class="literal">NetworkManager.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>NIS-domainname.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在不使用网络信息服务（NIS）时禁用<code class="literal">nis-domainname.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>rhsmcertd.service</p>
								 </td><td valign="top" style="text-align:left"> <p>没有</p>
								 </td><td valign="top" style="text-align:left"> </td></tr><tr><td valign="top" style="text-align:left"> <p>rngd.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您的系统上不需要大量熵，或者您没有任何类型的硬件生成器时，才禁用<code class="literal">rngd.service</code> 。请注意，在需要大量良好熵的环境中，例如用于生成X.509证书的系统（例如FreeIPA服务器），该服务是必需的。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>rsyslog.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要持久性日志或将<code class="literal">systemd-journald</code>设置为持久模式时，才禁用<code class="literal">rsyslog.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>SELinux的autorelabel-mark.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在不使用SELinux时才禁用<code class="literal">selinux-autorelabel-mark.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>sshd.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要OpenSSH服务器进行远程登录时，才禁用<code class="literal">sshd.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>sssd.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当没有用户通过网络登录系统时（例如，使用LDAP或Kerberos），才禁用<code class="literal">sssd.service</code> 。如果禁用<code class="literal">sssd.service</code> Red Hat建议禁用所有<code class="literal">sssd-*</code>单元。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>syslog.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p><code class="literal">rsyslog.service</code>的别名
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>tuned.service</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在需要使用性能调整时才禁用<code class="literal">tuned.service</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>LVM2-lvmpolld.socket</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅在不使用逻辑卷管理器（LVM）时禁用<code class="literal">lvm2-lvmpolld.socket</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>DNF-makecache.timer</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要自动更新包元数据时，才禁用<code class="literal">dnf-makecache.timer</code> 。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>未绑定-anchor.timer</p>
								 </td><td valign="top" style="text-align:left"> <p>是</p>
								 </td><td valign="top" style="text-align:left"> <p>仅当您不需要每日更新DNS安全扩展（DNSSEC）的根信任锚时，才禁用<code class="literal">unbound-anchor.timer</code> 。Unbound解析程序和解析程序库使用此根信任锚进行DNSSEC验证。
								</p>
								 </td></tr></tbody></table></div></div><p>要查找有关服务的更多信息，可以运行以下命令之一：</p><pre class="literallayout">~]$ systemctl cat &lt;service_name&gt;</pre><pre class="literallayout">~]$ systemctl help &lt;service_name&gt;</pre><p><code class="literal">systemctl cat</code>命令提供位于<code class="literal">/usr/lib/systemd/system/&lt;service&gt;</code>下的服务文件的内容，以及所有适用的覆盖。适用的覆盖包括<code class="literal">/etc/systemd/system/&lt;service&gt;</code>文件中的单元文件覆盖或来自相应<code class="literal">unit.type.d</code>目录的drop-in文件。
				</p><p>有关<code class="literal">systemd.unit</code>文件的更多信息，请参见<code class="literal">systemd.unit</code>手册页。
				</p><p><code class="literal">systemctl help</code>命令显示特定服务的手册页。
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="systemd-additional-resources_managing-services-with-systemd"></a>其他资源</h1></div></div></div><p>有关systemd及其在Red Hat Enterprise Linux上的使用的更多信息，请参阅下面列出的资源。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="installed_documentation_2"></a>已安装的文档</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">systemctl</code> （1） - <code class="literal">systemctl</code>命令行实用程序的手册页提供了受支持的选项和命令的完整列表。
						</li><li class="listitem">
							<code class="literal">systemd</code> （1） - <code class="literal">systemd</code>系统和服务管理器的手册页提供了有关其概念和文档可用命令行选项和环境变量，支持的配置文件和目录，已识别信号和可用内核选项的更多信息。
						</li><li class="listitem">
							<code class="literal">systemd-delta</code> （1） - <code class="literal">systemd-delta</code>实用程序的手册页，允许查找扩展和重写的配置文件。
						</li><li class="listitem">
							<code class="literal">systemd.directives(7)</code> - 名为<code class="literal">systemd.directives</code>的手册页提供了有关systemd指令的详细信息。
						</li><li class="listitem">
							<code class="literal">systemd.unit</code> （5） - 名为<code class="literal">systemd.unit</code>的手册页提供了有关systemd单元文件的详细信息，并记录了所有可用的配置选项。
						</li><li class="listitem">
							<code class="literal">systemd.service</code> （5） - 名为<code class="literal">systemd.service</code>的手册页记录了服务单元文件的格式。
						</li><li class="listitem">
							<code class="literal">systemd.target</code> （5） - 名为<code class="literal">systemd.target</code>的手册页记录了目标单元文件的格式。
						</li><li class="listitem">
							<code class="literal">systemd.kill</code> （5） - 名为<code class="literal">systemd.kill</code>的手册页记录了进程终止程序的配置。
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="online_documentation_2"></a>在线文档</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="http://www.freedesktop.org/wiki/Software/systemd">systemd主页</a> - 项目主页提供了有关systemd的更多信息。
						</li></ul></div></div></div></div></body></html>