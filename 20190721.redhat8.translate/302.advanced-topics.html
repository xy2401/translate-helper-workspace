<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 高级主题</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 高级主题</h1></div></div></div><p>本节介绍超出介绍性教程范围但在实际RPM包装中有用的主题。
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="signing-packages_advanced-topics"></a>签名包</h1></div></div></div><p>签名包以确保没有第三方可以更改其内容。用户可以在下载程序包时使用HTTPS协议添加额外的安全层。
			</p><p>签名包有三种方式：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="xref" href="advanced-topics.html#adding-a-signature_signing-packages" title="将签名添加到现有包中">“将签名添加到现有包”一节</a> 。
					</li><li class="listitem">
						<a class="xref" href="advanced-topics.html#replacing-the-signature_signing-packages" title="替换现有包上的签名">“更换已存在的包上的签名”一节</a> 。
					</li><li class="listitem">
						<a class="xref" href="advanced-topics.html#signing-a-package-at-build-time_signing-packages" title="在构建时签署包">“在构建时签署包”一节</a> 。
					</li></ul></div><p>为了能够对包进行签名，您需要创建一个GNU Privacy Guard（GPG）密钥，如<a class="xref" href="advanced-topics.html#creating-a-gpg-key_signing-packages" title="Creating a GPG key">“创建GPG密钥”一节</a>中<a class="xref" href="advanced-topics.html#creating-a-gpg-key_signing-packages" title="创建GPG密钥">所述</a> 。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-a-gpg-key_signing-packages"></a>创建GPG密钥</h2></div></div></div><h4><a id="procedure_19"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">生成GNU Privacy Guard（GPG）密钥对：</p><pre class="literallayout"># gpg --gen-key</pre></li><li class="listitem"><p class="simpara">确认并查看生成的密钥：</p><pre class="literallayout"># gpg --list-keys</pre></li><li class="listitem"><p class="simpara">导出公钥：</p><pre class="literallayout"># gpg --export -a '&lt;Key_name&gt;' &gt; RPM-GPG-KEY-pmanager</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>包括为密钥选择的实名，而不是&lt;Key_name&gt;。
							</p></div></li><li class="listitem"><p class="simpara">将导出的公钥导入RPM数据库：</p><pre class="literallayout"># rpm --import RPM-GPG-KEY-pmanager</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="adding-a-signature_signing-packages"></a>将签名添加到现有包中</h2></div></div></div><p>本节介绍在没有签名的情况下构建包时最常见的情况。签名在包发布之前添加。
				</p><p>要向包中添加签名，请使用<code class="literal">rpm-sign</code>包提供的<code class="literal">--addsign</code>选项。
				</p><p>拥有多个签名可以将包的所有权路径从包构建器记录到最终用户。
				</p><h4><a id="procedure_20"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">向包中添加签名：</p><pre class="literallayout">$ rpm --addsign blather-7.9-1.x86_64.rpm</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>您应该输入密码来解锁签名的密钥。
							</p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="checking-the-signatures-of-a-package-with-multiple-signatures_signing-packages"></a>检查具有多个签名的包的签名</h2></div></div></div><h4><a id="procedure_21"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要检查具有多个签名的包的签名，请运行以下命令：</p><pre class="literallayout">$ rpm --checksig blather-7.9-1.x86_64.rpm
blather-7.9-1.x86_64.rpm: size pgp pgp md5 OK</pre><p class="simpara"><code class="literal">rpm --checksig</code>命令输出中的两个<code class="literal">pgp</code>字符串显示该包已签名两次。
						</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="a-practical-example-of-adding-a-signature_signing-packages"></a>将签名添加到现有包的实际示例</h2></div></div></div><p>本节介绍将签名添加到现有包中可能有用的示例情况。
				</p><p>公司的一个部门创建一个包，并用部门的密钥签名。然后，公司总部检查包裹的签名，并将公司签名添加到包裹中，说明签名的包裹是真实的。
				</p><p>通过两个签名，包裹可以通往零售商。零售商检查签名，如果匹配，也会添加签名。
				</p><p>该软件包现在可以用于想要部署软件包的公司。在检查包装上的每个签名后，他们知道它是真实的副本。根据部署公司的内部控制，他们可以选择添加自己的签名，以通知其员工该包已获得公司批准</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="replacing-the-signature_signing-packages"></a>替换现有包上的签名</h2></div></div></div><p>此过程描述如何更改公钥而无需重建每个包。
				</p><h4><a id="procedure_22"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要更改公钥，请运行以下命令：</p><pre class="literallayout">$ rpm --resign blather-7.9-1.x86_64.rpm</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>您应该输入密码来解锁签名的密钥。
							</p></div></li></ul></div><p><code class="literal">--resign</code>选项还允许您更改多个包的公钥，如以下过程所示。
				</p><h4><a id="procedure_23"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要更改多个包的公钥，请执行：</p><pre class="literallayout">$ rpm --resign b*.rpm</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>您应该输入密码来解锁签名的密钥。
							</p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="signing-a-package-at-build-time_signing-packages"></a>在构建时签署包</h2></div></div></div><h4><a id="procedure_24"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">使用<code class="literal">rpmbuild</code>命令构建包：</p><pre class="literallayout">$ rpmbuild blather-7.9.spec</pre></li><li class="listitem"><p class="simpara">使用<code class="literal">--addsign</code>选项使用<code class="literal">rpmsign</code>命令对包进行<code class="literal">--addsign</code> ：</p><pre class="literallayout">$ rpmsign --addsign blather-7.9-1.x86_64.rpm</pre></li><li class="listitem">（可选）验证包的签名：</li></ol></div><pre class="literallayout">$ rpm --checksig blather-7.9-1.x86_64.rpm
blather-7.9-1.x86_64.rpm: size pgp md5 OK</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>在构建和签署多个包时，请使用以下语法避免多次输入Pretty Good Privacy（PGP）密码。
					</p><pre class="literallayout">$ rpmbuild -ba --sign b*.spec</pre><p>请注意，您应该输入密码来解锁签名的密钥。
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="more-on-macros_advanced-topics"></a>更多关于宏</h1></div></div></div><p>本节介绍选定的内置RPM宏。有关此类宏的详尽列表，请参阅<a class="link" href="http://rpm.org/user_doc/macros.html">RPM文档</a> 。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="defining-your-own-macros_more-on-macros"></a>定义自己的宏</h2></div></div></div><p>以下部分介绍如何创建自定义宏。
				</p><h4><a id="procedure_25"></a>程序</h4><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">在RPM SPEC文件中包含以下行：</p><pre class="literallayout">%global &lt;name&gt;[(opts)] &lt;body&gt;</pre></li></ul></div><p>围绕<code class="literal">\</code>所有空格都被删除。名称可以由字母数字字符和字符<code class="literal">_</code>组成，并且长度必须至少为3个字符。包含<code class="literal">(opts)</code>字段是可选的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">Simple</code>宏不包含<code class="literal">(opts)</code>字段。在这种情况下，仅执行递归宏扩展。
						</li><li class="listitem">
							<code class="literal">Parametrized</code>宏包含<code class="literal">(opts)</code>字段。括号之间的<code class="literal">opts</code>字符串在宏调用开始时传递给<code class="literal">getopt(3)</code>以进行<code class="literal">argc/argv</code>处理。
						</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>较旧的RPM SPEC文件使用<code class="literal">%define &lt;name&gt; &lt;body&gt;</code>宏模式。<code class="literal">%define</code>和<code class="literal">%global</code>宏之间的差异如下：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">%define</code>具有本地范围。它适用于SPEC文件的特定部分。使用时会扩展<code class="literal">%define</code>宏的主体。
							</li><li class="listitem">
								<code class="literal">%global</code>具有全球范围。它适用于整个SPEC文件。<code class="literal">%global</code>宏的主体在定义时间扩展。
							</li></ul></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">重要</h3><p>即使它们已被注释掉，或宏的名称被赋予SPEC文件的<code class="literal">%changelog</code>部分，也会对宏进行评估。要注释掉宏，请使用<code class="literal">%%</code> 。例如： <code class="literal">%%global</code> 。
					</p></div><h4><a id="additional_resources_5"></a>其他资源</h4><p>有关宏功能的全面信息，请参阅<a class="link" href="http://rpm.org/user_doc/macros.html">RPM文档</a> 。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using-the-setup-macro_more-on-macros"></a>使用％setup宏</h2></div></div></div><p>本节介绍如何使用<code class="literal">%setup</code>宏的不同变体构建包含源代码tarball的包。请注意，可以组合宏变体<code class="literal">rpmbuild</code>输出说明了<code class="literal">%setup</code>宏的标准行为。在每个阶段的开始，宏输出<code class="literal">Executing(%…​)</code> ，如下例所示。
				</p><div class="example"><a id="idm140116105892208"></a><p class="title"><strong>例4.1。示例<code class="literal">%setup</code>宏输出</strong></p><div class="example-contents"><pre class="literallayout">Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.DhddsG</pre><p>shell输出设置为<code class="literal">set -x</code> enabled。要查看<code class="literal">/var/tmp/rpm-tmp.DhddsG</code> ，使用<code class="literal">--debug</code>选项，因为<code class="literal">rpmbuild</code>在成功构建后删除临时文件。这将显示环境变量的设置，后跟例如：</p><pre class="literallayout">cd '/builddir/build/BUILD'
rm -rf 'cello-1.0'
/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xof -
STATUS=$?
if [ $STATUS -ne 0 ]; then
  exit $STATUS
fi
cd 'cello-1.0'
/usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .</pre></div></div><p><code class="literal">%setup</code>宏：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">确保我们在正确的目录中工作。
						</li><li class="listitem">删除以前构建的残留物。
						</li><li class="listitem">解压缩源tarball。
						</li><li class="listitem">设置一些默认权限。
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-setup-q-option"></a>使用％setup -q宏</h3></div></div></div><p><code class="literal">-q</code>选项限制<code class="literal">%setup</code>宏的详细程度。只有<code class="literal">tar -xof</code>执行，而不是<code class="literal">tar -xvvof</code> 。使用此选项作为第一个选项。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-setup-n-option"></a>使用％setup -n宏</h3></div></div></div><p><code class="literal">-n</code>选项用于指定扩展tarball中目录的名称。
					</p><p>这用于扩展tarball中的目录与预期名称不同的名称（ <code class="literal">%{name}-%{version}</code> ），这可能导致<code class="literal">%setup</code>宏出错。
					</p><p>例如，如果包名称是<code class="literal">cello</code> ，但源代码在<code class="literal">hello-1.0.tgz</code>存档并包含<code class="literal">hello/</code>目录，则SPEC文件内容需要如下所示：</p><pre class="literallayout">Name: cello
Source0: <a class="link" href="https://example.com/%{name}/release/hello-%{version}.tar.gz">https://example.com/%{name}/release/hello-%{version}.tar.gz</a>
…
%prep
%setup -n hello</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-setup-c-option"></a>使用％setup -c宏</h3></div></div></div><p>如果源代码tarball不包含任何子目录，则使用<code class="literal">-c</code>选项，并且在解压缩后，存档中的文件将填充当前目录。
					</p><p>然后<code class="literal">-c</code>选项创建目录并进入存档扩展，如下所示：</p><pre class="literallayout">/usr/bin/mkdir -p cello-1.0
cd 'cello-1.0'</pre><p>存档扩展后，目录不会更改。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-setup-dt-option"></a>使用％setup -D和％setup -T宏</h3></div></div></div><p><code class="literal">-D</code>选项禁用删除源代码目录，如果多次使用<code class="literal">%setup</code>宏，则特别有用。使用<code class="literal">-D</code>选项时，不使用以下行：</p><pre class="literallayout">rm -rf 'cello-1.0'</pre><p><code class="literal">-T</code>选项通过从脚本中删除以下行来禁用源代码tarball的扩展：</p><pre class="literallayout">/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xvvof -</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-setup-ab-option"></a>使用％setup -a和％setup -b宏</h3></div></div></div><p><code class="literal">-a</code>和<code class="literal">-b</code>选项扩展了特定的来源：</p><p><code class="literal">-b</code>选项代表<code class="literal">before</code> ，它在进入工作目录之前扩展特定的源。<code class="literal">-a</code>选项代表<code class="literal">after</code> ，并在进入后扩展这些源。他们的参数是SPEC文件前导码中的源编号。
					</p><p>在以下示例中， <code class="literal">cello-1.0.tar.gz</code>存档包含一个空<code class="literal">examples</code>目录。这些示例在单独的<code class="literal">examples.tar.gz</code> tarball中提供，它们会扩展到同名目录中。在这种情况下，如果要在进入工作目录后展开<code class="literal">Source1</code> ，请使用<code class="literal">-a 1</code> ：</p><pre class="literallayout">Source0: <a class="link" href="https://example.com/%{name}/release/%{name}-%{version}.tar.gz">https://example.com/%{name}/release/%{name}-%{version}.tar.gz</a>
Source1: examples.tar.gz
…
%prep
%setup -a 1</pre><p>在下面的示例中，示例在单独的<code class="literal">cello-1.0-examples.tar.gz</code> tarball中提供，它扩展为<code class="literal">cello-1.0/examples</code> 。在这种情况下，使用<code class="literal">-b 1</code> ，在进入工作目录之前展开<code class="literal">Source1</code> ：</p><pre class="literallayout">Source0: <a class="link" href="https://example.com/%{name}/release/%{name}-%{version}.tar.gz">https://example.com/%{name}/release/%{name}-%{version}.tar.gz</a>
Source1: %{name}-%{version}-examples.tar.gz
…
%prep
%setup -b 1</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="common-rpm-macros-in-the-files-section_more-on-macros"></a> ％files部分中的常见RPM宏</h2></div></div></div><p>本节列出了SPEC文件的<code class="literal">%files</code>部分中所需的高级RPM宏。
				</p><div class="table"><a id="idm140116105694720"></a><p class="title"><strong>表4.1。<code class="literal">%files</code>部分中的高级RPM宏</strong></p><div class="table-contents"><table border="1" summary="Advanced RPM Macros in the %files section"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">宏</th><th valign="top" style="text-align:left">定义</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>％执照</p>
								 </td><td valign="top" style="text-align:left"> <p>宏标识列为LICENSE文件的文件，它将由RPM安装和标记。示例： <code class="literal">%license LICENSE</code>
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％DOC</p>
								 </td><td valign="top" style="text-align:left"> <p>宏标识一个列为文档的文件，它将由RPM安装和标记。该宏用于有关打包软件的文档以及代码示例和各种随附项目。如果包含代码示例，则应注意从文件中删除可执行模式。示例： <code class="literal">%doc README</code>
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>DIR％</p>
								 </td><td valign="top" style="text-align:left"> <p>宏确保路径是此RPM拥有的目录。这很重要，以便RPM文件清单准确地知道卸载时要清理的目录。示例： <code class="literal">%dir %{_libdir}/%{name}</code>
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％配置（了noreplace）</p>
								 </td><td valign="top" style="text-align:left"> <p>宏确保以下文件是配置文件，因此如果文件已从原始安装校验和进行了修改，则不应在程序包安装或更新时覆盖（或替换）该文件。如果有更改，则在升级或安装时将使用<code class="literal">.rpmnew</code>附加到文件名末尾创建文件，以便不修改目标系统上预先存在或已修改的文件。示例： <code class="literal">%config(noreplace) %{_sysconfdir}/%{name}/%{name}.conf</code>
								</p>
								 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="displaying-the-built-in-macros_more-on-macros"></a>显示内置宏</h2></div></div></div><p>Red Hat Enterprise Linux提供了多个内置RPM宏。
				</p><h4><a id="procedure_26"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">要显示所有内置RPM宏，请运行：</p><pre class="literallayout">rpm --showrc</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>输出相当大。要缩小结果范围，请使用上面的命令和<code class="literal">grep</code>命令。
							</p></div></li><li class="listitem"><p class="simpara">要查找有关系统RPM版本的RPM宏的信息，请运行：</p><pre class="literallayout">rpm -ql rpm</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>RPM宏是输出目录结构中标题为<code class="literal">macros</code>的文件。
							</p></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rpm-distribution-macros_more-on-macros"></a> RPM分发宏</h2></div></div></div><p>根据正在打包的软件的语言实现或分发的特定指导原则，不同的发行版提供不同的推荐RPM宏集。
				</p><p>推荐的RPM宏集通常作为RPM包提供，随时可以与<code class="literal">yum</code>包管理器一起安装。
				</p><p>安装后，可以在<code class="literal">/usr/lib/rpm/macros.d/</code>目录中找到宏文件。
				</p><p>要显示原始RPM宏定义，请运行：</p><pre class="literallayout">rpm --showrc</pre><p>以上输出显示原始RPM宏定义。
				</p><p>要确定宏的功能以及在打包RPM时它如何有用，请运行<code class="literal">rpm --eval</code>命令，并将宏的名称用作其参数：</p><pre class="literallayout">rpm --eval %{_MACRO}</pre><p>有关更多信息，请参见<code class="literal">rpm</code>手册页。
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using-the-custom-macros_more-on-macros"></a>创建自定义宏</h3></div></div></div><p>您可以使用自定义宏覆盖<code class="literal">~/.rpmmacros</code>文件中的分发宏。您所做的任何更改都会影响计算机上的每个构建。
					</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">警告</h3><p>建议不要在<code class="literal">~/.rpmmacros</code>文件中定义任<code class="literal">~/.rpmmacros</code> 。此类宏不会出现在其他计算机上，用户可能希望尝试重建您的程序包。
						</p></div><p>要覆盖宏，请运行：</p><pre class="literallayout">%_topdir /opt/some/working/directory/rpmbuild</pre><p>您可以从上面的示例创建目录，包括通过<code class="literal">rpmdev-setuptree</code>实用程序的所有子目录。默认情况下，此宏的值为<code class="literal">~/rpmbuild</code> 。
					</p><pre class="literallayout">%_smp_mflags -l3</pre><p>上面的宏通常用于传递给Makefile，例如<code class="literal">make %{?_smp_mflags}</code> ，并在构建阶段设置多个并发进程。默认情况下，它设置为<code class="literal">-jX</code> ，其中<code class="literal">X</code>是多个核心。如果更改核心数，则可以加快或减慢程序包的构建速度。
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="epoch-scriplets-and-triggers_advanced-topics"></a> Epoch，Scriptlets和Triggers</h1></div></div></div><p>本节介绍<code class="literal">Epoch</code> ， <code class="literal">Scriptlets</code>和<code class="literal">Triggers</code> ，它们代表RMP SPEC文件的高级指令。
			</p><p>所有这些指令不仅影响SPEC文件，还影响安装了最终RPM的终端机器。
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="packaging-epoch_epoch-scriplets-and-triggers"></a> Epoch指令</h2></div></div></div><p><code class="literal">Epoch</code>指令允许基于版本号定义加权依赖性。
				</p><p>如果此指令未在RPM SPEC文件中列出，则根本不设置<code class="literal">Epoch</code>指令。这与普遍认为没有将<code class="literal">Epoch</code>结果设置为0的<code class="literal">Epoch</code>相反。但是，为了解析，YUM实用程序将未设置的<code class="literal">Epoch</code>视为与0的<code class="literal">Epoch</code>相同。
				</p><p>但是，通常会省略在SPEC文件中列出<code class="literal">Epoch</code> ，因为在比较软件包版本时，大多数情况下引入<code class="literal">Epoch</code>值会使预期的RPM行为发生偏差。
				</p><div class="example"><a id="idm140116045504304"></a><p class="title"><strong>例4.2。使用Epoch</strong></p><div class="example-contents"><p>如果使用<code class="literal">Epoch: 1</code>和<code class="literal">Version: 1.0</code>安装<code class="literal">foobar</code>包，并且其他人使用<code class="literal">Version: 2.0</code>打包<code class="literal">foobar</code>但没有<code class="literal">Epoch</code>指令，则新版本将永远不会被视为更新。原因是<code class="literal">Epoch</code>版本优于传统的<code class="literal">Name-Version-Release</code>标记，表示RPM包的版本控制。
					</p></div></div><p>因此使用<code class="literal">Epoch</code>是非常罕见的。但是， <code class="literal">Epoch</code>通常用于解决升级排序问题。该问题可能表现为软件版本号方案中的上游更改或包含字母字符的版本的副作用，这些字母字符无法始终基于编码进行可靠比较。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="scriptlets_epoch-scriplets-and-triggers"></a> Scriptlets指令</h2></div></div></div><p>
					<span class="strong"><strong>Scriptlet</strong></span>是一系列RPM指令，在安装或删除包之前或之后执行。
				</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">警告</h3><p>仅将<span class="strong"><strong>Scriptlet</strong></span>用于在构建时或启动脚本中无法完成的任务。
					</p></div><h5><a id="scriptlets_directives"></a> Scriptlets指令</h5><p>请注意，存在一组常见的<span class="strong"><strong>Scriptlet</strong></span>指令。它们类似于SPEC文件节标题，例如<code class="literal">%build</code>或<code class="literal">%install</code> 。它们由多行代码段定义，通常编写为标准POSIX shell脚本。但是，它们也可以用其他编程语言编写，目标机器的发行版可以接受RPM。RPM文档包含可用语言的详尽列表。
				</p><p>下表包括执行顺序中列出的<span class="strong"><strong>Scriptlet</strong></span>指令。请注意，包含脚本的包安装在<code class="literal">%pre</code>和<code class="literal">%post</code>指令之间，并且它在<code class="literal">%preun</code>和<code class="literal">%postun</code>指令之间被卸载。
				</p><div class="table"><a id="idm140115989106976"></a><p class="title"><strong>表4.2。Scriptlet指令</strong></p><div class="table-contents"><table border="1" summary="Scriptlet directives"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">指示</th><th valign="top" style="text-align:left">定义</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％pretrans</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在安装或删除任何包之前执行的Scriptlet。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％的预</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在目标系统上安装软件包之前执行的Scriptlet。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％后</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在目标系统上安装软件包之后执行的Scriptlet。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％preun</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在从目标系统卸载软件包之前执行的Scriptlet。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％postun</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在从目标系统卸载软件包之后执行的Scriptlet。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>
									<code class="literal">％posttrans</code>
								</p>
								 </td><td valign="top" style="text-align:left"> <p>在事务结束时执行的Scriptlet。
								</p>
								 </td></tr></tbody></table></div></div><h5><a id="scriptlets_macros"></a> Scriptlets宏</h5><p><span class="strong"><strong>Scriptlets</strong></span>指令也适用于RPM宏。
				</p><p>以下示例显示了systemd scriptlet宏的使用，该宏确保systemd被通知有关新的单元文件。
				</p><pre class="literallayout">$ rpm --showrc | grep systemd
-14: <span class="emphasis"><em>transaction_systemd_inhibit %{</em></span>plugindir}/systemd_inhibit.so
-14: _journalcatalogdir /usr/lib/systemd/catalog
-14: _presetdir /usr/lib/systemd/system-preset
-14: _unitdir   /usr/lib/systemd/system
-14: _userunitdir       /usr/lib/systemd/user
/usr/lib/systemd/systemd-binfmt %{?<span class="strong"><strong>} &gt;/dev/null 2&gt;&amp;1 || : /usr/lib/systemd/systemd-sysctl %{?</strong></span>} &gt;/dev/null 2&gt;&amp;1 || :
-14: systemd_post
-14: systemd_postun
-14: systemd_postun_with_restart
-14: systemd_preun
-14: systemd_requires
Requires(post): systemd
Requires(preun): systemd
Requires(postun): systemd
-14: systemd_user_post  %systemd_post --user --global %{?<span class="strong"><strong>} -14: systemd_user_postun %{nil} -14: systemd_user_postun_with_restart %{nil} -14: systemd_user_preun systemd-sysusers %{?</strong></span>} &gt;/dev/null 2&gt;&amp;1 || :
echo %{?<span class="strong"><strong>} | systemd-sysusers - &gt;/dev/null 2&gt;&amp;1 || : systemd-tmpfiles --create %{?</strong></span>} &gt;/dev/null 2&gt;&amp;1 || :

$ rpm --eval %{systemd_post}

if [ $1 -eq 1 ] ; then
        # Initial installation
        systemctl preset  &gt;/dev/null 2&gt;&amp;1 || :
fi

$ rpm --eval %{systemd_postun}

systemctl daemon-reload &gt;/dev/null 2&gt;&amp;1 || :

$ rpm --eval %{systemd_preun}

if [ $1 -eq 0 ] ; then
        # Package removal, not upgrade
        systemctl --no-reload disable  &gt; /dev/null 2&gt;&amp;1 || :
        systemctl stop  &gt; /dev/null 2&gt;&amp;1 || :
fi</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="triggers_epoch-scriplets-and-triggers"></a>触发器指令</h2></div></div></div><p>
					<span class="strong"><strong>触发器</strong></span>是RPM指令，它提供了在程序包安装和卸载期间进行交互的方法。
				</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">警告</h3><p>
						<span class="strong"><strong>触发器</strong></span>可以在意外的时间执行，例如在更新包含的包时。<span class="strong"><strong>触发器</strong></span>很难调试，因此它们需要以健壮的方式实现，以便在意外执行时不会破坏任何内容。出于这些原因，Red Hat建议尽量减少<span class="strong"><strong>触发器</strong></span>的使用。
					</p></div><p>下面列出了执行顺序和每个现有<span class="strong"><strong>触发器</strong></span>的详细信息：</p><pre class="literallayout">all-%pretrans
…​
any-%triggerprein (%triggerprein from other packages set off by new install)
new-%triggerprein
new-%pre      for new version of package being installed
…​           (all new files are installed)
new-%post     for new version of package being installed

any-%triggerin (%triggerin from other packages set off by new install)
new-%triggerin
old-%triggerun
any-%triggerun (%triggerun from other packages set off by old uninstall)

old-%preun    for old version of package being removed
…​           (all old files are removed)
old-%postun   for old version of package being removed

old-%triggerpostun
any-%triggerpostun (%triggerpostun from other packages set off by old un
            install)
…​
all-%posttrans</pre><p>以上项目位于<code class="literal">/usr/share/doc/rpm-4.*/triggers</code>文件中。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using-non-shell-scripts-in-a-spec-file_epoch-scriplets-and-triggers"></a>在SPEC文件中使用非shell脚本</h2></div></div></div><p>SPEC文件中的<code class="literal">-p</code> scriptlet选项使用户能够调用特定的解释器而不是默认的shell脚本解释器（ <code class="literal">-p /bin/sh</code> ）。
				</p><p>以下过程描述了如何创建脚本，该脚本在安装<code class="literal">pello.py</code>程序后打印出一条消息：</p><h4><a id="procedure_27"></a>程序</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem">打开<code class="literal">pello.spec</code>文件。
						</li><li class="listitem"><p class="simpara">找到以下行：</p><pre class="literallayout">install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/</pre></li><li class="listitem"><p class="simpara">在上面的行下面插入：</p><pre class="literallayout">%post -p /usr/bin/python3
print("This is {} code".format("python"))</pre></li><li class="listitem">按照<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="Building RPMs">“构建RPM”一节</a>中<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="构建RPM">的说明</a>构建程序包。
						</li><li class="listitem"><p class="simpara">安装你的包裹：</p><pre class="literallayout"># yum install /home/&lt;username&gt;/rpmbuild/RPMS/noarch/pello-0.1.2-1.el8.noarch.rpm</pre></li><li class="listitem"><p class="simpara">安装后检查输出消息：</p><pre class="literallayout">Installing       : pello-0.1.2-1.el8.noarch                              1/1
Running scriptlet: pello-0.1.2-1.el8.noarch                              1/1
This is python code</pre></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>要使用Python 3脚本， <code class="literal">install -m</code>在SPEC文件中的<code class="literal">install -m</code>下包含以下行：</p><pre class="literallayout">%post -p /usr/bin/python3</pre><p>要使用Lua脚本， <code class="literal">install -m</code>在SPEC文件中的<code class="literal">install -m</code>下包含以下行：</p><pre class="literallayout">%post -p &lt;lua&gt;</pre><p>这样，您可以在SPEC文件中指定任何解释器。
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="rpm-conditionals_advanced-topics"></a> RPM条件</h1></div></div></div><p>RPM条件允许条件包含SPEC文件的各个部分。
			</p><p>条件包含通常涉及：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">特定于架构的部分</li><li class="listitem">特定于操作系统的部分</li><li class="listitem">各种版本的操作系统之间的兼容性问题</li><li class="listitem">宏的存在和定义</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rpm-conditionals-syntax_rpm-conditionals"></a> RPM条件语法</h2></div></div></div><p>RPM条件使用以下语法：</p><p>如果<span class="emphasis"><em>表达式</em></span>为true，则执行一些操作：</p><pre class="literallayout">%if expression
…​
%endif</pre><p>如果<span class="emphasis"><em>表达式</em></span>为true，则执行一些操作，在其他情况下，执行另一个操作：</p><pre class="literallayout">%if expression
…​
%else
…​
%endif</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rpm-conditionals-examples_rpm-conditionals"></a> RPM条件示例</h2></div></div></div><p>本节提供了RPM条件的多个示例。
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="the_if_conditionals"></a> ％if条件</h3></div></div></div><div class="example"><a id="idm140116096756704"></a><p class="title"><strong>例4.3。使用％if条件来处理Red Hat Enterprise Linux 8与其他操作系统之间的兼容性</strong></p><div class="example-contents"><pre class="literallayout">%if 0%{?rhel} == 8
sed -i '/AS_FUNCTION_DESCRIBE/ s/^/<span class="marked">/' configure.in sed -i '/AS_FUNCTION_DESCRIBE/ s/^/</span>/' acinclude.m4
%endif</pre></div></div><p>此条件在支持AS_FUNCTION_DESCRIBE宏方面处理RHEL 8与其他操作系统之间的兼容性。如果包是为RHEL构建的，则定义<code class="literal">%rhel</code>宏，并将其扩展为RHEL版本。如果其值为8，表示包是为RHEL 8构建的，则从autoconfig脚本中删除对RHEL 8不支持的AS_FUNCTION_DESCRIBE的引用。
					</p><div class="example"><a id="idm140116045804496"></a><p class="title"><strong>例4.4。使用％if条件来处理宏的定义</strong></p><div class="example-contents"><pre class="literallayout">%define ruby_archive %{name}-%{ruby_version}
%if 0%{?milestone:1}%{?revision:1} != 0
%define ruby_archive %{ruby_archive}-%{?milestone}%{?!milestone:%{?revision:r%{revision}}}
%endif</pre></div></div><p>此条件处理宏的定义。如果设置了<code class="literal">%milestone</code>或<code class="literal">%revision</code>宏，则重新定义定义上游tarball名称的<code class="literal">%ruby_archive</code>宏。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="specialized_variants_of_if_conditionals"></a> ％if条件的特殊变体</h3></div></div></div><p>在<code class="literal">%ifarch</code>条件， <code class="literal">%ifnarch</code>条件和<code class="literal">%ifos</code>条件是专门变种<code class="literal">%if</code>条件句。这些变体是常用的，因此它们有自己的宏。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="the_ifarch_conditional"></a> ％ifarch条件</h4></div></div></div><p><code class="literal">%ifarch</code>条件用于开始特定于体系结构的SPEC文件的块。接下来是一个或多个体系结构说明符，每个说明符用逗号或空格分隔。
						</p><div class="example"><a id="idm140116076332544"></a><p class="title"><strong>例4.5。％ifarch条件的示例用法</strong></p><div class="example-contents"><pre class="literallayout">%ifarch i386 sparc
…​
%endif</pre></div></div><p><code class="literal">%ifarch</code>和<code class="literal">%endif</code>之间的SPEC文件的所有内容仅在32位AMD和Intel体系结构或基于Sun SPARC的系统上处理。
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="the_ifnarch_conditional"></a> ％ifnarch条件</h4></div></div></div><p><code class="literal">%ifnarch</code>条件具有反向逻辑而不是<code class="literal">%ifarch</code>条件。
						</p><div class="example"><a id="idm140116082257776"></a><p class="title"><strong>例4.6。％ifnarch条件的示例用法</strong></p><div class="example-contents"><pre class="literallayout">%ifnarch alpha
…​
%endif</pre></div></div><p>仅当在基于Digital Alpha / AXP的系统上未执行时，才会处理<code class="literal">%ifnarch</code>和<code class="literal">%endif</code>之间的SPEC文件的所有内容。
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="the_ifos_conditional"></a> ％ifos有条件</h4></div></div></div><p><code class="literal">%ifos</code>条件用于控制基于构建操作系统的处理。它后面可以跟一个或多个操作系统名称。
						</p><div class="example"><a id="idm140116097255488"></a><p class="title"><strong>例4.7。％ifos条件的示例用法</strong></p><div class="example-contents"><pre class="literallayout">%ifos linux
…​
%endif</pre></div></div><p>仅当构建在Linux系统上完成时，才会处理<code class="literal">%ifos</code>和<code class="literal">%endif</code>之间的SPEC文件的所有内容。
						</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="packaging-python3_advanced-topics"></a>包装Python 3 RPMs</h1></div></div></div><p>大多数Python项目使用Setuptools进行打包，并在<code class="literal">setup.py</code>文件中定义包信息。有关Setuptools打包的详细信息，请参阅<a class="link" href="https://setuptools.readthedocs.io/en/latest/">Setuptools文档</a> 。
			</p><p>您还可以将Python项目打包到RPM包中，与Setuptools包装相比，它提供了以下优势：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">包在其他RPM（甚至非Python）上的依赖关系的规范</li><li class="listitem"><p class="simpara">加密签名</p><p class="simpara">通过加密签名，可以使用操作系统的其余部分验证，集成和测试RPM包的内容。
					</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Typical-Python-RPM-package-spec-file-description"></a> Python RPM包的典型SPEC文件描述</h2></div></div></div><p>与非Python RPM SPEC文件相比，Python项目的RPM SPEC文件具有一些细节。最值得注意的是，Python库的任何RPM包的名称必须始终包含<code class="literal">python3</code>前缀。
				</p><p><span class="strong"><strong><code class="literal">python3-detox</code>包</strong></span>的以下SPEC文件<span class="strong"><strong>示例</strong></span>中显示了其他细节。有关此类细节的说明，请参阅示例下面的注释。
				</p><pre class="programlisting">%global modname detox                                                           <a id="CO1-1"/><span><img src="images/callouts/1.png" alt="1"/></span>

Name:           python3-detox                                                   <a id="CO1-2"/><span><img src="images/callouts/2.png" alt="2"/></span>
Version:        0.12
Release:        4%{?dist}
Summary:        Distributing activities of the tox tool
License:        MIT
URL:             https://pypi.io/project/detox
Source0:        https://pypi.io/packages/source/d/%{modname}/%{modname}-%{version}.tar.gz

BuildArch:      noarch

BuildRequires:  python36-devel                                                  <a id="CO1-3"/><span><img src="images/callouts/3.png" alt="3"/></span>
BuildRequires:  python3-setuptools
BuildRequires:  python36-rpm-macros
BuildRequires:  python3-six
BuildRequires:  python3-tox
BuildRequires:  python3-py
BuildRequires:  python3-eventlet

%?python_enable_dependency_generator                                            <a id="CO1-4"/><span><img src="images/callouts/4.png" alt="4"/></span>

%description

Detox is the distributed version of the tox python testing tool. It makes efficient use of multiple CPUs by running all possible activities in parallel.
Detox has the same options and configuration that tox has, so after installation you can run it in the same way and with the same options that you use for tox.

    $ detox

%prep
%autosetup -n %{modname}-%{version}

%build
%py3_build                                                                      <a id="CO1-5"/><span><img src="images/callouts/5.png" alt="5"/></span>

%install
%py3_install

%check
%{__python3} setup.py test                                                      <a id="CO1-6"/><span><img src="images/callouts/6.png" alt="6"/></span>

%files -n python3-%{modname}
%doc CHANGELOG
%license LICENSE
%{_bindir}/detox
%{python3_sitelib}/%{modname}/
%{python3_sitelib}/%{modname}-%{version}*

%changelog
...</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td valign="top" align="left"><p><a href="#CO1-1"><span><img src="images/callouts/1.png" alt="1"></span></a> </p></td><td valign="top" align="left"><p><span class="strong"><strong>modname</strong></span>宏包含Python项目的名称。在这个例子中，它是<code class="literal">detox</code> 。
						</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-2"><span><img src="images/callouts/2.png" alt="2"></span></a> </p></td><td valign="top" align="left"><p>将Python项目打包到RPM时，总是需要将<code class="literal">python3</code>前缀添加到项目的原始名称中。这里的原始名称是<code class="literal">detox</code> ， <span class="strong"><strong>RPM</strong></span>的<span class="strong"><strong>名称</strong></span>是<code class="literal">python3-detox</code> 。
						</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-3"><span><img src="images/callouts/3.png" alt="3"></span></a> </p></td><td valign="top" align="left"><p>
							<span class="strong"><strong>BuildRequires</strong></span>指定构建和测试此包所需的包。在BuildRequires中，始终包含提供构建Python包所需工具的项： <code class="literal">python36-devel</code>和<code class="literal">python3-setuptools</code> 。<code class="literal">python36-rpm-macros</code>包是必需的，因此带有<code class="literal">/usr/bin/python3</code> shebangs的文件会自动更改为<code class="literal">/usr/bin/python3.6</code> 。有关更多信息，请参阅<a class="xref" href="advanced-topics.html#python-shebang-mangling" title="在Python脚本中处理hashbang">“在Python脚本中处理hashbangs”一节</a> 。
						</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-4"><span><img src="images/callouts/4.png" alt="4"></span></a> </p></td><td valign="top" align="left"><p>每个Python包都需要一些其他包才能正常工作。此类包也需要在SPEC文件中指定。要指定<span class="strong"><strong>依赖项</strong></span> ，可以使用<span class="strong"><strong>％python_enable_dependency_generator</strong></span>宏自动使用<code class="literal">setup.py</code>文件中定义的依赖项。如果包具有未使用Setuptools指定的依赖项，请在其他<code class="literal">Requires</code>指令中指定它们。
						</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-5"><span><img src="images/callouts/5.png" alt="五"></span></a> </p></td><td valign="top" align="left"><p><span class="strong"><strong>％py3_build</strong></span>和<span class="strong"><strong>％py3_install</strong></span>宏分别运行<code class="literal">setup.py build</code>和<code class="literal">setup.py install</code>命令，并附加参数以指定安装位置，要使用的解释器以及其他详细信息。
						</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-6"><span><img src="images/callouts/6.png" alt="6"></span></a> </p></td><td valign="top" align="left"><p><span class="strong"><strong>check</strong></span>部分提供了一个运行正确Python版本的宏。<span class="strong"><strong>％{__ python3}</strong></span>宏包含Python 3解释器的路径，例如<code class="literal">/usr/bin/python3</code> 。我们建议始终使用宏而不是文字路径。
						</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Common-macros-for-Python-RPM-packages"></a> Python 3 RPM包的常用宏</h2></div></div></div><p>在SPEC文件中，始终使用下面的宏而不是硬编码它们的值。
				</p><p>在宏名称中，始终使用<code class="literal">python3</code>或<code class="literal">python2</code>而不是unversioned <code class="literal">python</code> 。
				</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">宏</th><th valign="top" style="text-align:left">正常定义</th><th valign="top" style="text-align:left">描述</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>％{__ python3}</p>
								 </td><td valign="top" style="text-align:left"> <p>在/ usr / bin中/ python3</p>
								 </td><td valign="top" style="text-align:left"> <p>Python 3解释器</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} python3_version</p>
								 </td><td valign="top" style="text-align:left"> <p>3.6</p>
								 </td><td valign="top" style="text-align:left"> <p>Python 3解释器的完整版本。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} python3_sitelib</p>
								 </td><td valign="top" style="text-align:left"> <p>/usr/lib/python3.6/site-packages</p>
								 </td><td valign="top" style="text-align:left"> <p>安装纯Python模块的地方。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} python3_sitearch</p>
								 </td><td valign="top" style="text-align:left"> <p>/usr/lib64/python3.6/site-packages</p>
								 </td><td valign="top" style="text-align:left"> <p>包含特定于体系结构的扩展的模块的位置。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％py3_build</p>
								 </td><td valign="top" style="text-align:left"> </td><td valign="top" style="text-align:left"> <p>使用适合系统包的参数运行<code class="literal">setup.py build</code>命令。
								</p>
								 </td></tr><tr><td valign="top" style="text-align:left"> <p>％py3_install</p>
								 </td><td valign="top" style="text-align:left"> </td><td valign="top" style="text-align:left"> <p>使用适合系统包的参数运行<code class="literal">setup.py install</code>命令。
								</p>
								 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="automatic_provides_for_python_rpm_packages"></a>自动提供Python RPM包</h2></div></div></div><p>打包Python项目时，请确保在生成的RPM中包含以下目录（如果存在）：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">.dist-信息</code>
						</li><li class="listitem">
							<code class="literal">.egg-信息</code>
						</li><li class="listitem">
							<code class="literal">.egg链接</code>
						</li></ul></div><p>从这些目录中，RPM构建过程自动生成虚拟<code class="literal">pythonX.Ydist</code>提供，例如<code class="literal">python3.6dist(detox)</code> 。这些虚拟提供由<span class="strong"><strong>％python_enable_dependency_generator</strong></span>宏指定的包使用。
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="python-shebang-mangling"></a>在Python脚本中处理hashbang</h2></div></div></div><p>在Red Hat Enterprise Linux 8中，可执行的Python脚本应该使用hashbangs（shebangs）至少明确指定主要的Python版本。
				</p><p>构建任何RPM包时会自动运行<code class="literal">/usr/lib/rpm/redhat/brp-mangle-shebangs</code> buildroot策略（BRP）脚本，并尝试更正所有可执行文件中的hashbang。遇到带有模糊hashbang的Python脚本时，BRP脚本将生成错误，例如：</p><pre class="literallayout">#! /usr/bin/python</pre><p>要么</p><pre class="literallayout">#! /usr/bin/env python</pre><p>要修改Python脚本中的hashbang，导致RPM构建时出现这些构建错误，请使用<code class="literal">platform-python-devel</code>包中的<code class="literal">pathfix.py</code>脚本：</p><pre class="literallayout">pathfix.py -pn -i %{__python3} <span class="emphasis"><em>PATH</em></span> …​</pre><p>可以指定多个<code class="literal"><span class="emphasis"><em>PATH s</em></span></code> 。如果<code class="literal"><span class="emphasis"><em>PATH</em></span></code>是一个目录， <code class="literal">pathfix.py</code>递归扫描任何与模式<code class="literal">^[a-zA-Z0-9_]+\.py$</code> 。py <code class="literal">^[a-zA-Z0-9_]+\.py$</code>匹配的Python脚本，而不仅仅是那些带有模糊hashbang的Python脚本。将此命令添加到<code class="literal">%prep</code>部分或<code class="literal">%install</code>部分的末尾。
				</p><p>或者，修改打包的Python脚本，使其符合预期的格式。为此， <code class="literal">pathfix.py</code>也可以在RPM构建过程之外使用。在RPM构建之外运行<code class="literal">pathfix.py</code> ，请将上面示例中的<code class="literal"><span class="emphasis"><em>__python3</em></span></code>替换为<code class="literal"><span class="emphasis"><em>__python3</em></span></code>的路径，例如<code class="literal">/usr/bin/python3</code> 。
				</p><p>如果打包的Python脚本需要Python版本2，请在上面的命令中将数字3替换为2。
				</p><p>另外， <code class="literal">/usr/bin/python3</code>形式的hashbangs默认用来自用于Red Hat Enterprise Linux系统工具的<code class="literal">platform-python</code>包指向Python的hashbangs替换。
				</p><p>要将自定义包中的<code class="literal">/usr/bin/python3</code> hashbangs更改为指向从Application Stream安装的Python版本，格式为<code class="literal">/usr/bin/python3.6</code> ，请将<code class="literal">python36-rpm-macros</code>包添加到<span class="strong"><strong>BuildRequires</strong></span>部分的SPEC文件：</p><pre class="literallayout">BuildRequires:  python36-rpm-macros</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>要防止BRP脚本进行hashbang检查和修改，请使用以下RPM指令：</p><pre class="literallayout">%undefine %brp_mangle_shebangs</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ruby-gem-packages_advanced-topics"></a> RubyGems包</h1></div></div></div><p>本节介绍RubyGems包的内容，以及如何将它们重新打包为RPM。</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="what-rubygems-are_ruby-gem-packages"></a> RubyGems是什么</h2></div></div></div><p>Ruby是一种动态的，解释性的，反射的，面向对象的通用编程语言。
				</p><p>用Ruby编写的程序通常使用RubyGems项目打包，该项目提供特定的Ruby打包格式。
				</p><p>由RubyGems创建的包称为gems，它们也可以重新打包到RPM中。
				</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title">注意</h3><p>本文档涉及与带有<code class="literal">gem</code>前缀的RubyGems概念相关的术语，例如.gemspec用于<code class="literal">gem specification</code> ，与RPM相关的术语是不合格的。
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ruby-gem-rpm-relation_ruby-gem-packages"></a> RubyGems如何与RPM相关</h2></div></div></div><p>RubyGems代表Ruby自己的打包格式。但是，RubyGems包含类似于RPM所需的元数据，这使得从RubyGems到RPM的转换成为可能。</p><p>根据<a class="link" href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Ruby/#_rubygems">Ruby Packaging Guidelines</a> ，可以通过以下方式将RubyGems包重新打包到RPM中：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">这样的RPM适合分布的其余部分。
						</li><li class="listitem">最终用户可以通过安装适当的RPM打包gem来满足gem的依赖关系。
						</li></ul></div><p>RubyGems使用与RPM类似的术语，例如SPEC文件，包名，依赖项和其他项。
				</p><p>为了适应RHEL RPM发行版的其余部分，RubyGems创建的包必须遵循下面列出的约定：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">宝石的名称必须遵循以下模式：</p><pre class="literallayout">rubygem-%{gem_name}</pre></li><li class="listitem"><p class="simpara">要实现shebang行，必须使用以下字符串：</p><pre class="literallayout">#!/usr/bin/ruby</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating-rpm-packages-from-rubygems_ruby-gem-packages"></a>从RubyGems包创建RPM包</h2></div></div></div><p>本节介绍如何从RubyGems创建的包创建RPM包。
				</p><p>要为RubyGems包创建源RPM，需要两个文件：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">一个宝石文件</li><li class="listitem">RPM SPEC文件</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="rubygems-spec-file-conventions"></a> RubyGems SPEC文件约定</h3></div></div></div><p>RubyGems SPEC文件必须满足以下约定：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">包含<code class="literal">%{gem_name}</code>的定义，这是gem的规范中的名称。
							</li><li class="listitem">包的源必须是已发布的gem存档的完整URL;包的版本必须是gem的版本。
							</li><li class="listitem"><p class="simpara">包含<code class="literal">BuildRequires:</code>一个定义如下的指令，以便能够引入构建所需的宏。
							</p><pre class="literallayout">BuildRequires:rubygems-devel</pre></li><li class="listitem">不包含任何RubyGems <code class="literal">Requires</code>或<code class="literal">Provides</code> ，因为它们是自动生成的。
							</li><li class="listitem"><p class="simpara">除非要显式指定Ruby版本兼容性，否则不包含如下定义的<code class="literal">BuildRequires:</code>指令：</p><pre class="literallayout">Requires: ruby(release)</pre><p class="simpara">自动生成的RubyGems依赖（ <code class="literal">Requires: ruby(rubygems)</code> ）就足够了。
							</p></li></ul></div><h4><a id="macros"></a>宏</h4><p><code class="literal">rubygems-devel</code>包提供了对RubyGems创建的包有用的宏。
					</p><div class="table"><a id="idm140116083079552"></a><p class="title"><strong>表4.3。RubyGems的宏</strong></p><div class="table-contents"><table border="1" summary="RubyGems&#39; macros"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th valign="top" style="text-align:left">宏名称</th><th valign="top" style="text-align:left">扩展路径</th><th valign="top" style="text-align:left">用法</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>％{} gem_dir</p>
									 </td><td valign="top" style="text-align:left"> <p>的/ usr /共享/宝石</p>
									 </td><td valign="top" style="text-align:left"> <p>gem结构的顶级目录。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_instdir</p>
									 </td><td valign="top" style="text-align:left"> <p>％{} gem_dir /宝石/％{} gem_name  - ％{}版本</p>
									 </td><td valign="top" style="text-align:left"> <p>目录与gem的实际内容。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_libdir</p>
									 </td><td valign="top" style="text-align:left"> <p>％{gem_instdir} / lib中</p>
									 </td><td valign="top" style="text-align:left"> <p>gem的库目录。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_cache</p>
									 </td><td valign="top" style="text-align:left"> <p>％{} gem_dir /缓存/％{} gem_name  - ％{}版本.gem</p>
									 </td><td valign="top" style="text-align:left"> <p>缓存的宝石。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_spec</p>
									 </td><td valign="top" style="text-align:left"> <p>％{} gem_dir /规格/％{} gem_name  - ％{}版本.gemspec</p>
									 </td><td valign="top" style="text-align:left"> <p>gem规范文件。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_docdir</p>
									 </td><td valign="top" style="text-align:left"> <p>％{} gem_dir / DOC /％{} gem_name  - ％{}版本</p>
									 </td><td valign="top" style="text-align:left"> <p>宝石的RDoc文档。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％{} gem_extdir_mri</p>
									 </td><td valign="top" style="text-align:left"> <p>％{_ LIBDIR} /宝石/红宝石/％{} gem_name  - ％{}版本</p>
									 </td><td valign="top" style="text-align:left"> <p>gem扩展名的目录。
									</p>
									 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="rubygems-spec-file-example"></a> RubyGems SPEC文件示例</h3></div></div></div><p>本节提供了用于构建gem的示例SPEC文件及其特定部分的说明。
					</p><div class="title"><strong>示例RubyGems SPEC文件</strong></div><p>
							
</p><pre class="literallayout">%prep
%setup -q -n  %{gem_name}-%{version}

# Modify the gemspec if necessary
# Also apply patches to code if necessary
%patch0 -p1

%build
# Create the gem as gem install only works on a gem file
gem build ../%{gem_name}-%{version}.gemspec

# %%gem_install compiles any C extensions and installs the gem into ./%%gem_dir
# by default, so that we can move it into the buildroot in %%install
%gem_install

%install
mkdir -p %{buildroot}%{gem_dir}
cp -a ./%{gem_dir}/* %{buildroot}%{gem_dir}/

# If there were programs installed:
mkdir -p %{buildroot}%{_bindir}
cp -a ./%{_bindir}/* %{buildroot}%{_bindir}

# If there are C extensions, copy them to the extdir.
mkdir -p %{buildroot}%{gem_extdir_mri}
cp -a .%{gem_extdir_mri}/{gem.build_complete,*.so} %{buildroot}%{gem_extdir_mri}/</pre><p>

						</p><p>下表解释了RubyGems SPEC文件中特定项的细节：</p><div class="table"><a id="idm140116089344336"></a><p class="title"><strong>表4.4。RubyGems的SPEC指令细节</strong></p><div class="table-contents"><table border="1" summary="RubyGems&#39; SPEC directives specifics"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">SPEC指令</th><th valign="top" style="text-align:left">RubyGems具体细节</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>％准备</p>
									 </td><td valign="top" style="text-align:left"> <p>RPM可以直接解压缩gem档案，因此您可以运行<code class="literal">gem unpack</code> comamnd从gem中提取源代码。<code class="literal">%setup -n %{gem_name}-%{version}</code>宏提供了解压缩gem的目录。在同一目录级别，将自动创建<code class="literal">%{gem_name}-%{version}.gemspec</code>文件，该文件可用于稍后重建gem，修改<code class="literal">.gemspec</code>或将修补程序应用于代码。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％建立</p>
									 </td><td valign="top" style="text-align:left"> <p>该指令包括用于将软件构建为机器代码的命令或一系列命令。<code class="literal">%gem_install</code>宏仅在gem档案上运行，并且使用下一个gem构建重新创建gem。然后， <code class="literal">%gem_install</code>使用创建的gem文件来构建代码并将其安装到临时目录中，默认情况下为<code class="literal">./%{gem_dir}</code> 。<code class="literal">%gem_install</code>宏<code class="literal">%gem_install</code>构建和安装代码。在安装之前，已构建的源将放入自动创建的临时目录中。
									</p>
									 <p><code class="literal">%gem_install</code>宏接受另外两个选项： <code class="literal">-n &lt;gem_file&gt;</code> ，它允许覆盖用于安装的gem; <code class="literal">-d &lt;install_dir&gt;</code> ，它可以覆盖gem安装目标;建议不要使用此选项。
									</p>
									 <p><code class="literal">%gem_install</code>宏不得用于安装到<code class="literal">%{buildroot}</code> 。
									</p>
									 </td></tr><tr><td valign="top" style="text-align:left"> <p>％安装</p>
									 </td><td valign="top" style="text-align:left"> <p>安装将在<code class="literal">%{buildroot}</code>层次结构中执行。您可以创建所需的目录，然后将临时目录中安装的内容复制到<code class="literal">%{buildroot}</code>层次结构中。如果此gem创建共享对象，则会将它们移动到特定于体系结构的<code class="literal">%{gem_extdir_mri}</code>路径中。
									</p>
									 </td></tr></tbody></table></div></div><p>有关RubyGems SPEC文件的更多信息，请参阅<a class="link" href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Ruby/">Ruby Packaging Guidelines</a> 。
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="converting-rubygem-rpm-spec"></a>使用gem2rpm将RubyGems包转换为RPM SPEC文件</h3></div></div></div><p><code class="literal">gem2rpm</code>实用程序将RubyGems包转换为RPM SPEC文件。
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="installing-gem2rpm"></a>安装gem2rpm</h4></div></div></div><h6><a id="procedure_28"></a>程序</h6><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">要从<a class="link" href="https://rubygems.org/">RubyGems.org</a>安装<code class="literal">gem2rpm</code> ，请运行：</li></ul></div><pre class="literallayout">$ gem install gem2rpm</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="displaying-gem2rpm-options"></a>显示gem2rpm的所有选项</h4></div></div></div><h6><a id="procedure_29"></a>程序</h6><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要查看<code class="literal">gem2rpm</code>所有选项，请运行：</p><pre class="literallayout">gem2rpm --help</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="converting-rubygems-with-gem2rpm"></a>使用gem2rpm将RubyGems包转换为RPM SPEC文件</h4></div></div></div><h6><a id="procedure_30"></a>程序</h6><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">下载最新版本的gem，并为此gem生成RPM SPEC文件：</li></ul></div><pre class="literallayout">$ gem2rpm --fetch &lt;gem_name&gt; &gt; &lt;gem_name&gt;.spec</pre><p>所描述的过程基于gem的元数据中提供的信息创建RPM SPEC文件。但是，gem错过了一些通常在RPM中提供的重要信息，例如许可证和更改日志。因此需要编辑生成的SPEC文件。
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="editing-gem2rpm-templates"></a>编辑gem2rpm模板</h4></div></div></div><p>建议编辑生成RPM SPEC文件的模板，而不是生成的SPEC文件本身。
						</p><p>该模板是标准的嵌入式Ruby（ERB）文件，其中包含下表中列出的变量。
						</p><div class="table"><a id="idm140116087093248"></a><p class="title"><strong>表4.5。gem2rpm模板中的变量</strong></p><div class="table-contents"><table border="1" summary="Variables in the gem2rpm template"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th valign="top" style="text-align:left">变量</th><th valign="top" style="text-align:left">说明</th></tr></thead><tbody><tr><td valign="top" style="text-align:left"> <p>包</p>
										 </td><td valign="top" style="text-align:left"> <p>gem的<code class="literal">Gem::Package</code>变量。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>规范</p>
										 </td><td valign="top" style="text-align:left"> <p>gem的<code class="literal">Gem::Specification</code>变量（与format.spec相同）。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>配置</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::Configuration</code>变量，可以重新定义spec模板助手中使用的默认宏或规则。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>runtime_dependencies</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::RpmDependencyList</code>变量提供包运行时依赖项的列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>development_dependencies</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::RpmDependencyList</code>变量提供包开发依赖项的列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>测试</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::TestSuite</code>变量提供允许执行的测试框架列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>档</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::RpmFileList</code>变量提供包中未过滤的文件列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>main_files</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::RpmFileList</code>变量提供适合主包的文件列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>doc_files</p>
										 </td><td valign="top" style="text-align:left"> <p><code class="literal">Gem2Rpm::RpmFileList</code>变量提供适合<code class="literal">-doc</code>子包的文件列表。
										</p>
										 </td></tr><tr><td valign="top" style="text-align:left"> <p>格式</p>
										 </td><td valign="top" style="text-align:left"> <p>gem的<code class="literal">Gem::Format</code>变量。请注意，此变量现已弃用。
										</p>
										 </td></tr></tbody></table></div></div><h5><a id="procedure_31"></a>程序</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">要查看所有可用模板，请运行：</p><pre class="literallayout">$ gem2rpm --templates</pre></li></ul></div><p>要编辑<code class="literal">gem2rpm</code>模板，请遵循以下过程：</p><h5><a id="procedure_32"></a>程序</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">保存默认模板：</p><pre class="literallayout">$ gem2rpm -T &gt; rubygem-&lt;gem_name&gt;.spec.template</pre></li><li class="listitem">根据需要编辑模板。
								</li><li class="listitem"><p class="simpara">使用编辑的模板生成SPEC文件：</p><pre class="literallayout">$ gem2rpm -t rubygem-&lt;gem_name&gt;.spec.template &lt;gem_name&gt;-&lt;latest_version.gem &gt; &lt;gem_name&gt;-GEM.spec</pre></li></ol></div><p>您现在可以使用编辑的模板构建RPM包，如<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="Building RPMs">“构建RPM”一节</a>中<a class="xref" href="packaging-software_packaging-and-distributing-software.html#building-rpms_packaging-software" title="构建RPM">所述</a> 。
						</p></div></div></div></div></div></body></html>