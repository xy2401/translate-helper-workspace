<html  xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 9. 配置应用程序以通过PKCS＃11使用加密硬件</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"></head><body ><div class="chapter"><div class="titlepage"><div><div><h1 class="title">Chapter 9. 配置应用程序以通过PKCS＃11使用加密硬件</h1></div></div></div><p>在专用加密设备上分离部分秘密信息，例如用于最终用户身份验证的智能卡和加密令牌以及用于服务器应用程序的硬件安全模块（HSM），可提供额外的安全保护。在Red Hat Enterprise Linux 8中，通过PKCS＃11 API对加密硬件的支持在不同的应用程序中是一致的，并且在加密硬件上隔离秘密并不是一项复杂的任务。
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="cryptographic-hardware-support-through-pkcs-11_configuring-applications-to-use-cryptographic-hardware-through-pkcs-11"></a>通过PKCS＃11支持加密硬件</h1></div></div></div><p>PKCS＃11（公钥加密标准）为加密设备定义了一个应用程序编程接口（API），用于保存加密信息并执行加密功能。这些设备称为令牌，它们可以用硬件或软件实现。
			</p><p>可以存储在PKCS＃11令牌中的存储对象类型集包括证书;数据对象;以及公钥，私钥或秘密密钥。这些对象可以通过PKCS＃11 URI方案唯一标识。
			</p><p>PKCS＃11 URI提供了一种标准方法，用于根据PKCS＃11模块的属性识别PKCS＃11模块上的特定对象。这使您能够以URI的形式配置具有相同配置字符串的所有库和应用程序。</p><p>Red Hat Enterprise Linux 8默认为智能卡提供OpenSC PKCS＃11驱动程序。但是，硬件令牌和HSM可以拥有自己的PKCS＃11模块，这些模块在红帽企业Linux中没有对应的模块。您可以使用<code class="literal">p11-kit</code>工具注册此类PKCS＃11模块，该工具可作为系统中已注册智能卡驱动程序的包装程序。
			</p><p>要使您自己的PKCS＃11模块在系统上运行，请将新文本文件添加到<code class="literal">/etc/pkcs11/modules/</code>目录</p><p>将您自己的PKCS＃11模块添加到系统中只需要在<code class="literal">/etc/pkcs11/modules/</code>目录中创建一个新的文本文件。例如， <code class="literal">p11-kit</code>的OpenSC配置文件如下所示：</p><pre class="screen">$ cat /usr/share/p11-kit/modules/opensc.module
module: opensc-pkcs11.so</pre><h3><a id="additional_resources_5"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="https://tools.ietf.org/html/rfc7512">PKCS＃11 URI方案</a>
					</li><li class="listitem">
						<a class="link" href="https://access.redhat.com/blogs/766093/posts/1976313">控制对智能卡的访问</a>
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="using-ssh-keys-stored-on-a-smart-card_configuring-applications-to-use-cryptographic-hardware-through-pkcs-11"></a>使用存储在智能卡上的SSH密钥</h1></div></div></div><p>红帽企业版Linux 8使您可以使用存储在OpenSSH客户端上的智能卡上的RSA和ECDSA密钥。
			</p><h3><a id="prerequisites"></a>先决条件</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">在客户端，安装<code class="literal">opensc</code>软件包并运行<code class="literal">pcscd</code>服务。
					</li></ul></div><h3><a id="procedure_3"></a>程序</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">列出OpenSC PKCS＃11模块提供的所有密钥，包括其PKCS＃11 URI，并将输出保存到<span class="emphasis"><em>keys.pub</em></span>文件：</p><pre class="screen">$ ssh-keygen -D pkcs11: &gt; <span class="emphasis"><em>keys.pub</em></span>
$ ssh-keygen -D pkcs11:
ssh-rsa AAAAB3NzaC1yc2E...KKZMzcQZzx pkcs11:id=%02;object=SIGN%20pubkey;token=SSH%20key;manufacturer=piv_II?module-path=/usr/lib64/pkcs11/opensc-pkcs11.so
ecdsa-sha2-nistp256 AAA...J0hkYnnsM= pkcs11:id=%01;object=PIV%20AUTH%20pubkey;token=SSH%20key;manufacturer=piv_II?module-path=/usr/lib64/pkcs11/opensc-pkcs11.so</pre></li><li class="listitem"><p class="simpara">要使用远程服务器（ <span class="emphasis"><em>example.com</em></span> ）上的智能卡启用身份验证，请将公钥传输到远程服务器。使用<code class="literal">ssh-copy-id</code>命令和上一步中创建的<span class="emphasis"><em>keys.pub</em></span> ：</p><pre class="screen">ssh-copy-id -f -i <span class="emphasis"><em>keys.pub</em></span> <span class="emphasis"><em>username@example.com</em></span></pre></li><li class="listitem"><p class="simpara">要使用步骤1中<code class="literal">ssh-keygen -D</code>命令输出中的ECDSA密钥连接到<span class="emphasis"><em>example.com</em></span> ，您只能使用唯一引用密钥的URI子集，例如：</p><pre class="screen">$ ssh -i "pkcs11:id=%01?module-path=/usr/lib64/pkcs11/opensc-pkcs11.so" <span class="emphasis"><em>example.com</em></span>
Enter PIN for 'SSH key':
[example.com] $</pre></li><li class="listitem"><p class="simpara">您可以在<code class="literal">~/.ssh/config</code>文件中使用相同的URI字符串使配置成为永久性：</p><pre class="screen">$ cat ~/.ssh/config
IdentityFile "pkcs11:id=%01?module-path=/usr/lib64/pkcs11/opensc-pkcs11.so"
$ ssh <span class="emphasis"><em>example.com</em></span>
Enter PIN for 'SSH key':
[example.com] $</pre><p class="simpara">由于OpenSSH使用<code class="literal">p11-kit-proxy</code>包装器并且OpenSC PKCS＃11模块已注册到PKCS＃11 Kit，因此您可以简化以前的命令：</p><pre class="screen">$ ssh -i "pkcs11:id=%01" <span class="emphasis"><em>example.com</em></span>
Enter PIN for 'SSH key':
[example.com] $</pre></li></ol></div><p>如果跳过PKCS＃11 URI的<code class="literal">id=</code>部分，OpenSSH将加载代理模块中可用的所有密钥。这可以减少所需的打字数量：</p><pre class="screen">$ ssh -i pkcs11: <span class="emphasis"><em>example.com</em></span>
Enter PIN for 'SSH key':
[example.com] $</pre><h3><a id="additional_resources_6"></a>其他资源</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="https://fedoramagazine.org/fedora-28-better-smart-card-support-openssh/">Fedora 28：OpenSSH中更好的智能卡支持</a>
					</li><li class="listitem">
						<code class="literal">p11-kit(8)</code>手册页</li><li class="listitem">
						<code class="literal">ssh(1)</code>手册页</li><li class="listitem">
						<code class="literal">ssh-keygen(1)</code>手册页</li><li class="listitem">
						<code class="literal">pcscd(8)</code>手册页</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="using-hsms-protecting-private-keys-in-apache-and-nginx_configuring-applications-to-use-cryptographic-hardware-through-pkcs-11"></a>使用HSM保护Apache和Nginx中的私钥</h1></div></div></div><p><code class="literal">Apache</code>和<code class="literal">Nginx</code> HTTP服务器可以使用存储在硬件安全模块（HSM）上的私钥，这有助于防止密钥泄露和中间人攻击。请注意，这通常需要繁忙服务器的高性能HSM。
			</p><div class="title"><strong><code class="literal">Apache</code> HTTP服务器</strong></div><p>对于HTTPS协议形式的安全通信， <code class="literal">Apache</code> HTTP服务器（ <code class="literal">httpd</code> ）使用OpenSSL库。OpenSSL本身不支持PKCS＃11。要使用HSM，您必须安装<code class="literal">openssl-pkcs11</code>软件包，该软件包通过引擎接口提供对PKCS＃11模块的访问。您可以使用PKCS＃11 URI而不是常规文件名在<code class="literal">/etc/httpd/conf.d/ssl.conf</code>配置文件中指定服务器密钥和证书，例如：</p><pre class="screen">SSLCertificateFile    "pkcs11:id=%01;token=softhsm;type=cert"
SSLCertificateKeyFile "pkcs11:id=%01;token=softhsm;type=private?pin-value=111111"</pre><p>安装<code class="literal">httpd-manual</code>软件包以获取<code class="literal">Apache</code> HTTP Server的完整文档，包括TLS配置。中可用的指令<code class="literal">/etc/httpd/conf.d/ssl.conf</code>配置文件中详细地描述<a class="link" href="javascript:void(0);">/usr/share/httpd/manual/mod/mod_ssl.html</a> 。
			</p><div class="title"><strong><code class="literal">Nginx</code> HTTP和代理服务器</strong></div><p>由于<code class="literal">Nginx</code>还使用OpenSSL进行加密操作，因此对PKCS＃11的支持必须通过<code class="literal">openssl-pkcs11</code>引擎。<code class="literal">Nginx</code>目前仅支持从HSM加载私钥，并且证书必须作为常规文件单独提供。修改<code class="literal">ssl_certificate</code>配置文件的<code class="literal">ssl_certificate_key</code>部分中的<code class="literal">server</code>和<code class="literal">/etc/nginx/nginx.conf</code>选项：</p><pre class="screen">ssl_certificate     /path/to/cert.pem
ssl_certificate_key "engine:pkcs11:pkcs11:token=softhsm;id=%01;type=private?pin-value=111111";</pre><p>请注意， <code class="literal">engine:pkcs11:</code>配置文件中的PKCS＃11 URI需要<code class="literal">Nginx</code>前缀。这是因为其他<code class="literal">pkcs11</code>前缀引用了引擎名称。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuring-applications-to-authenticate-using-certificates-from-smart-cards_configuring-applications-to-use-cryptographic-hardware-through-pkcs-11"></a>配置应用程序以使用智能卡中的证书进行身份验证</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">使用<code class="literal">wget</code>网络下载程序可以指定PKCS＃11 URI而不是本地存储的私钥的路径，从而简化了为需要安全存储的私钥和证书的任务创建脚本的过程。例如：</p><pre class="screen">$ wget --private-key 'pkcs11:token=softhsm;id=%01;type=private?pin-value=111111' --certificate 'pkcs11:token=softhsm;id=%01;type=cert' https://example.com/</pre><p class="simpara">有关更多信息，请参见<code class="literal">wget(1)</code>手册页。
					</p></li><li class="listitem"><p class="simpara">指定<code class="literal">curl</code>工具使用的PKCS＃11 URI是类似的：</p><pre class="screen">$ curl --key 'pkcs11:token=softhsm;id=%01;type=private?pin-value=111111' --cert 'pkcs11:token=softhsm;id=%01;type=cert' <a class="link" href="https://example.com/">https://example.com/</a></pre><p class="simpara">有关更多信息，请参见<code class="literal">curl(1)</code>手册页。
					</p></li><li class="listitem"><code class="literal">Firefox</code> Web浏览器自动加载<code class="literal">p11-kit-proxy</code>模块。这意味着系统中每个支持的智能卡都会被自动检测到。对于使用TLS客户端身份验证，无需其他设置，并且当服务器请求时，会自动使用智能卡中的密钥。
					</li></ul></div><div class="title"><strong>在自定义应用程序中使用PKCS＃11 URI</strong></div><p>如果您的应用程序使用<code class="literal">GnuTLS</code>或<code class="literal">NSS</code>库，则内置对PKCS＃11的支持可确保对PKCS＃11 URI的支持。此外，由于<code class="literal">OpenSSL</code>引擎，依赖<code class="literal">openssl-pkcs11</code>库的应用程序可以访问加密硬件模块。
				</p><p>对于需要在智能卡上使用私钥且不使用<code class="literal">NSS</code> ， <code class="literal">GnuTLS</code>或<code class="literal">OpenSSL</code> ，请使用<code class="literal">p11-kit</code>实现注册PKCS＃11模块。
			</p><p>有关更多信息，请参见<code class="literal">p11-kit(8)</code>手册页。
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="related-information-configuring-applications-to-use-cryptographic-hardware-through-pkcs-11"></a>相关信息</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<code class="literal">pkcs11.conf(5)</code>手册页</li></ul></div></div></div></body></html>