<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Key Programming Considerations</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQLJ Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQLJ Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96458-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="intro-to-SQLJ.html" title="Previous" type="text/html">
      <link rel="next" href="basic-language-features.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JSQLJ">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="intro-to-SQLJ.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="basic-language-features.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Key Programming Considerations</li>
            </ol>
            <a id="GUID-89D0620E-5E57-492D-9D3A-6A04F2171701" name="GUID-89D0620E-5E57-492D-9D3A-6A04F2171701"></a><a id="JSQLJ185"></a>
            
            <h2 id="JSQLJ-GUID-89D0620E-5E57-492D-9D3A-6A04F2171701" class="sect2"><span class="enumeration_chapter">4 </span> Key Programming Considerations
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses key issues to consider before developing and running your SQLJ application, and also provides a summary and sample applications. The following topics are discussed:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A">Selection of the JDBC Driver</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">Connection Considerations</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-EA345D88-D2AE-4118-986A-472764A6E1A4">NULL-Handling</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0">Exception-Handling Basics</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">Basic Transaction Control</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-E1A4C501-C265-43F6-98A3-D3F46044348A">Summary: First Steps in SQLJ Code</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD">Oracle-Specific Code Generation (No Profiles)</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-841EEFAD-3954-43D0-A270-679762CFBDED">ISO Standard Code Generation</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A">Requirements and Restrictions for Naming</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34">Considerations for SQLJ in the Middle Tier</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ186"></a><div class="props_rev_3"><a id="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A" name="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A"></a><h3 id="JSQLJ-GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A" class="sect3">Selection of the JDBC Driver</h3>
               <div>
                  <p>You must consider which Java Database Connectivity (JDBC) driver will be appropriate for your situation and whether it may be advantageous to use different drivers for translation and run time. You must choose or register the appropriate driver class for each and then specify the driver in your connection URL.</p>
                  <div class="infoboxnote" id="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A__GUID-0CB42930-D50B-4C24-B317-784718CACAEE">
                     <p class="notep1">Note:</p>
                     <p>Your application will require an Oracle JDBC driver if you use Oracle-specific code generation or if you use ISO SQLJ standard code generation with Oracle customizer, even if your code does not actually use Oracle-specific features.</p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7">Overview of Oracle JDBC Drivers</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E46F37A1-9E59-416E-A735-B5804D7A3094">Driver Selection for Translation</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">Driver Selection and Registration for Run Time</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ188"></a><a id="JSQLJ189"></a><a id="JSQLJ190"></a><a id="JSQLJ191"></a><a id="JSQLJ192"></a><a id="JSQLJ187"></a><div class="props_rev_3"><a id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7" name="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7"></a><h4 id="JSQLJ-GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7" class="sect4">Overview of Oracle JDBC Drivers</h4>
                  <div>
                     <p>Oracle provides the following JDBC drivers:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Oracle Call Interface (OCI) driver: For client-side use with an Oracle client installation.</p>
                        </li>
                        <li>
                           <p>Thin driver: A pure Java driver for client-side use, particularly with applets. It does not require an Oracle client installation.</p>
                        </li>
                        <li>
                           <p>Server-side Thin driver: Is functionally the same as the client-side Thin driver, but is for code that runs inside Oracle Database instance and needs to access a remote server.</p>
                        </li>
                        <li>
                           <p>Server-side internal driver: For code that runs inside the target server, that is, inside Oracle Database instance that it must access.</p>
                        </li>
                     </ul>
                     <p>Oracle Database 12<span class="italic">c </span>Release 1 (12.1) provides client-side drivers compatible with JDK 6 and JDK 7.
                     </p>
                     <div class="infoboxnotealso" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-AEFEC7BA-81C0-4547-A933-20583517BB65">
                        <p class="notep1">See Also:</p>
                        <p><a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-D6975767-9F5A-4B30-8910-9298DDD7FEF0" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                     </div>
                     <div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-905852A1-47DC-4D29-A1E7-694DF7D3F931">
                        <p class="notep1">Note:</p>
                        <p>Remember that your choices may differ between translation time and run time. For example, you may want to use Oracle JDBC OCI driver at translation time for semantics-checking, but Oracle JDBC Thin driver at run time.</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-9548D4B8-9B70-474E-A41B-5C4A433FC47E">Core JDBC Functionality</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The core functionality of all Oracle JDBC drivers is the same. They support the same feature set, syntax, programming interfaces, and Oracle extensions.</p>
                        <p>All Oracle JDBC drivers are supported by the <code class="codeph">oracle.jdbc.OracleDriver</code> class.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-0344D805-84F7-4403-B0B8-BE69EFB602DE">JDBC OCI Driver</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC OCI driver accesses the database by calling the OCI directly from Java, providing the highest compatibility with the different Oracle Database versions. These drivers support installed Oracle Net adapters, including interprocess communication (IPC), named pipes, TCP/IP, and IPX/SPX.</p>
                        <p>The use of native methods to call C entry points makes the OCI driver dependent on the Oracle platform, requiring an Oracle client installation that includes Oracle Net. Therefore it is not suitable for applets.</p>
                        <p>Connection strin<a id="d8416e209" class="indexterm-anchor"></a>gs for the OCI driver are of the following form, where <span class="italic"><code class="codeph">tns</code></span> is an optional TNS alias or full TNS specification:
                        </p><pre class="oac_no_warn" dir="ltr">jdbc:oracle:oci:@&lt;<span class="italic">tns</span>&gt;
</pre><div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-402FBB1B-9C41-4BA1-AD9B-A89D7BB2CD83">
                           <p class="notep1">Note:</p>
                           <p>For backward compatibility, <code class="codeph">oci8</code> is still acceptable instead of <code class="codeph">oci</code>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-7FDFA77F-AC81-4FA9-8835-9EABD30FC177">JDBC Thin Driver</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC Thin driver is a platform-independent, pure Java implementation that uses Java sockets to connect directly to Oracle Database from any Oracle or non-Oracle client. It can be downloaded into a browser simultaneously with the Java applet being run.</p>
                        <p>The JDBC Thin driver supports only TCP/IP protocol and requires a TNS listener to be listening on TCP/IP sockets from the database server. When the JDBC Thin driver is used with an applet, the client browser must have the capability to support Java sockets.</p>
                        <p>Connection str<a id="d8416e242" class="indexterm-anchor"></a>ings for the JDBC Thin driver are typically of the following form:
                        </p><pre class="oac_no_warn" dir="ltr">jdbc:oracle:thin:@<span class="italic">host</span>:<span class="italic">port</span>/<span class="italic">servicename</span>
</pre><div class="infoboxnotealso" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-6391BCFD-AFAD-4913-AFEF-CCF711730266">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-D6975767-9F5A-4B30-8910-9298DDD7FEF0" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for information about database service names
                           </p>
                        </div>
                        <p>In Oracle Database 12<span class="italic">c </span>Release 2 (12.2), connection strings using SIDs are deprecated, but are still supported for backward compatibility:
                        </p><pre class="oac_no_warn" dir="ltr">jdbc:oracle:thin:@<span class="italic">host</span>:<span class="italic">port</span>:<span class="italic">sid</span></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-F8E386C5-E19B-4BC7-8F03-311BE5849705">JDBC Server-Side Thin Driver</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC server-side Thin driver offers the same functionality as the client-side JDBC Thin driver, but runs inside the database and accesses a remote server. This is useful in accessing one Oracle Database instance from inside another, such as from a Java stored procedure.</p>
                        <p>Connection strin<a id="d8416e289" class="indexterm-anchor"></a>gs for the server-side Thin driver are the same as for the client-side Thin driver.
                        </p>
                        <div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-5E6FB464-4CE9-4EEA-BEF3-9865D5A47C31">
                           <p class="notep1">Note:</p>
                           <p>In order to leave the originating database when using the server-side Thin driver, the user account must have <code class="codeph">SocketPermission</code> assigned. Refer to the<a href="../jjdbc/JDBC-getting-started.html#JJDBC-GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA" target="_blank"><span class="italic"> Oracle Database JDBC Developer's Guide</span></a> for more information. Also, refer to the<a href="../jjdev/database-contents-Oracle-JVM-security.html#JJDEV-GUID-54515619-575D-4EFB-B745-F857A07813A6" target="_blank"><span class="italic"> Oracle Database Java Developer's Guide </span></a>for general information about <code class="codeph">SocketPermission</code> and other permissions.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-134F9E31-40BD-4DB4-9C69-9CF478B7B754">JDBC Server-Side Internal Driver</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC server-side internal driver provides support for any Java code that runs inside the target Oracle Database instance where the SQL operations are to be performed. The server-side internal driver enables Oracle Java virtual machine (JVM) to communicate directly with the SQL engine. This driver is the default JDBC driver for SQLJ code running as a stored procedure, stored function, or trigger in Oracle Database 12<span class="italic">c </span>Release 2 (12.2).
                        </p>
                        <p>Con<a id="d8416e324" class="indexterm-anchor"></a>nection strings for the server-side internal driver are of the following form:
                        </p><pre class="oac_no_warn" dir="ltr">jdbc:oracle:kprb:
</pre><p>If your SQLJ code uses the default connection context, then SQLJ automatically uses this driver for code running in Oracle JVM.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ193"></a><div class="props_rev_3"><a id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094" name="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094"></a><h4 id="JSQLJ-GUID-E46F37A1-9E59-416E-A735-B5804D7A3094" class="sect4">Driver Selection for Translation</h4>
                  <div>
                     <div class="section">
                        <p>Use SQLJ option settings, either on the command line or in a properties file, to choose the driver manager class and specify a driver for translation. </p>
                        <p>Use the SQLJ <code class="codeph">-driver</code> option to choose any driver manager class other than <code class="codeph">OracleDriver</code>, which is the default. 
                        </p>
                        <p>Specify the particular JDBC driver to choose, such as JDBC Thin or JDBC OCI for Oracle Database, as part of the connection URL you specify in the SQLJ <code class="codeph">-url</code> option.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094__GUID-D3754998-DE62-4ABC-A67B-58E354617C46">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">Connection Options</a>"</span></p>
                        </div>
                        <p>You will typically, but not necessarily, use the same driver that you use in your source code for the run-time connection.</p>
                        <div class="infoboxnote" id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094__GUID-E5CE27DC-3F52-4C85-9D4E-9B669CCA97A7">
                           <p class="notep1">Note:</p>
                           <p>Remember that the <code class="codeph">-driver</code> option does not choose a particular driver. It registers a driver class with the driver manager. One driver class might be used for multiple driver protocols, such as <code class="codeph">OracleDriver</code>, which is used for all of Oracle JDBC protocols.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ194"></a><div class="props_rev_3"><a id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425" name="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425"></a><h4 id="JSQLJ-GUID-EDC7B103-DC71-490F-BF36-9FD95B155425" class="sect4">Driver Selection and Registration for Run Time</h4>
                  <div>
                     <div class="section">
                        <p>To connect to the database at run time, you must <span class="italic">register</span> one or more drivers that will understand the URLs you specify for any of your connection instances, whether they are instances of the <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class or of any connection context classes that you declare.
                        </p>
                        <p>If you are using an Oracle JDBC driver and create a default connection using the <code class="codeph">Oracle.connect()</code> method, then SQLJ handles this automatically. The <code class="codeph">Oracle.connect()</code> method registers the <code class="codeph">oracle.jdbc.OracleDriver</code> class.
                        </p>
                        <p>If you are using an Oracle JDBC driver, but do not use <code class="codeph">Oracle.connect()</code>, then you must manually register the <code class="codeph">OracleDriver</code> class, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
</pre><p>If you are not using an Oracle JDBC driver, then you must register some appropriate driver class, as follows:</p><pre class="oac_no_warn" dir="ltr">DriverManager.registerDriver(new <span class="italic">mydriver.jdbc.driver.MyDriver()</span>);
</pre><p>In any case, you must also set your connection URL, user name, and password.</p>
                        <div class="infoboxnotealso" id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425__GUID-AFAFAF43-1E44-4A4C-964D-52ACB9DE9F80">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">Single Connection or Multiple Connections Using DefaultContext</a>"</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425__GUID-F71E74ED-0699-45D3-9A0A-CEA7E8A6241E">
                           <p class="notep1">Note:</p>
                           <p>As an alternative to using the JDBC driver manager in establishing JDBC connections, you can use data sources. You can specify a data source in a <code class="codeph">with</code> clause, as described in <span class="q">"<a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a>"</span>. For general information about data sources, refer to the<a href="../jjdbc/data-sources-and-URLs.html#JJDBC-GUID-38C56493-EC9F-45CA-B650-411C6A2A7AF0" target="_blank"><span class="italic"> Oracle Database JDBC Developer's Guide</span></a>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ195"></a><div class="props_rev_3"><a id="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D" name="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D"></a><h3 id="JSQLJ-GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D" class="sect3">Connection Considerations</h3>
               <div>
                  <div class="section">
                     <p>When deciding what database connection or connections you will need for your SQLJ application, consider the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Will you need just one database connection or multiple connections? </p>
                        </li>
                        <li>
                           <p>If using multiple connections (possibly to multiple schemas), then will each connection use SQL entities of the same name: tables of the same name, columns of the same name and data types, stored procedures of the same name and signature, and so on? </p>
                        </li>
                        <li>
                           <p>Will you need different connections for translation and run time or will the same suffice for both?</p>
                        </li>
                     </ul>
                     <p>A SQLJ executable statement can specify a particular connection context instance, either of <code class="codeph">DefaultContext</code> or of a declared connection context class, for its database connection. Alternatively, it can omit the connection context specification and use the default connection, which is an instance of <code class="codeph">DefaultContext</code> that was previously set as the default. 
                     </p>
                     <div class="infoboxnote" id="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D__GUID-DF1EBA5B-8DFE-4A64-B2EA-F9A90743A9D7">
                        <p class="notep1">Note:</p>
                        <p>If your operations will use different sets of SQL entities, then you will typically want to declare and use additional connection context classes.</p>
                     </div>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">Single Connection or Multiple Connections Using DefaultContext</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC">Closing Connections</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C">Multiple Connections Using Declared Connection Context Classes</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">More About the Oracle Class</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1">More About the DefaultContext Class</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9">Connection for Translation</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F">Connection for Customization</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSQLJ197"></a><a id="JSQLJ198"></a><a id="JSQLJ196"></a><div class="props_rev_3"><a id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04" name="GUID-DFB81879-F28E-47FD-A419-67C647F34B04"></a><h4 id="JSQLJ-GUID-DFB81879-F28E-47FD-A419-67C647F34B04" class="sect4">Single Connection or Multiple Connections Using DefaultContext</h4>
                  <div>
                     <div class="section">
                        <p>This section discusses scenarios where you will use connection instances of only the <code class="codeph">DefaultContext</code> class. 
                        </p>
                        <p>This is typical if you are using a single connection, or multiple connections that use SQL entities with the same names and data types.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-CAB8F78E-979A-4E9A-A762-87FC9C6CED60">Single Connection</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>For a single connection, use one instance of the <code class="codeph">DefaultContext</code> class specifying the database URL, user name, and password, when you construct your <code class="codeph">DefaultContext</code> object.
                        </p>
                        <p>You can use the <code class="codeph">connect()</code> method of the <code class="codeph">oracle.sqlj.runtime.Oracle</code> class to accomplish this. Calling this method automatically initializes the default connection context instance. This method has several signatures, including ones that allow you to specify user name, password, and URL, either directly or using a properties file. In the following example, the properties file <code class="codeph">connect.properties</code> is used:
                        </p><pre class="oac_no_warn" dir="ltr">Oracle.connect(<span class="italic">MyClass.</span>class, "connect.properties");
</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-1538380B-EB1D-4E27-BBF7-D4495EE5649F">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">connect.properties</code> file is searched for relative to the specified class. In the example, if <code class="codeph">MyClass</code> is located in <code class="codeph">my-package</code>, then <code class="codeph">connect.properties</code> must be found in the same package location, <code class="codeph">my-package</code>.
                           </p>
                        </div>
                        <p>If you use <code class="codeph">connect.properties</code>, then you must edit it appropriately and package it with your application. In this example, you must also import the <code class="codeph">oracle.sqlj.runtime.Oracle</code> class.
                        </p>
                        <p>Alternatively, you can specify user name, password, and URL directly:</p><pre class="oac_no_warn" dir="ltr">Oracle.connect("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr");
</pre><p>In this example, the connection will use the JDBC Thin driver to connect the <code class="codeph">HR</code> user with the password, <code class="codeph">hr</code>, to a database on the computer, <code class="codeph">localhost</code>, through port <code class="codeph">5221</code>, where <code class="codeph">myservice</code> is the name of the database service for the connection.
                        </p>
                        <p>Either of these examples creates a special static instance of the <code class="codeph">DefaultContext</code> class and installs it as your default connection. It is not necessary to do anything with this <code class="codeph">DefaultContext</code> instance directly.
                        </p>
                        <p>Once you have completed these steps, you do not need to specify the connection for any of the SQLJ executable statements in your application, if you want them all to use the default connection.</p>
                        <p>Note that in using a JDBC Thin driver, the URL must include the host name, port number, and service name (or SID, which is deprecated in Oracle Database 12<span class="italic">c </span>Release 2 (12.2)), as in the preceding example. Also, the database must have a listener running at the specified port. In using the JDBC OCI driver, no service name (or SID) is required if you intend to use the default account of the client, as will be the case in examples in this document. Alternatively, you can use name-value pairs.
                        </p>
                        <div class="infoboxnotealso" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-239303B2-1B6C-407E-9195-AE70FC1BCD24">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/index.html" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide </span></a>for more information
                           </p>
                        </div>
                        <p>The following URL will connect to the default account of the client:</p><pre class="oac_no_warn" dir="ltr">jdbc:oracle:oci:@
</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-D9D7FD59-75EF-4B4A-9030-EAB1CA4614F9">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">Oracle.connect()</code> will not set your default connection if one had already been set. In that case, it returns <code class="codeph">null</code>. This enables you to use the same code on a client or in the server. If you do want to override your default connection, then use the static <code class="codeph">setDefaultContext()</code> method of <code class="codeph">DefaultContext</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">Oracle.connect()</code> method defaults to a <code class="codeph">false</code> setting of the auto-commit flag. However, it also has signatures to set it explicitly. In the Oracle JDBC implementation, the auto-commit flag defaults to <code class="codeph">true</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>You can optionally specify <code class="codeph">getClass()</code> instead of <code class="codeph">MyClass.class</code> in the <code class="codeph">Oracle.connect()</code> call, as long as you are not calling <code class="codeph">getClass()</code> from a static method. The <code class="codeph">getClass()</code> method is used in some of the SQLJ demo applications.
                                 </p>
                              </li>
                              <li>
                                 <p>You can access the static <code class="codeph">DefaultContext</code> instance, which corresponds to your default connection, as follows:
                                 </p><pre class="oac_no_warn" dir="ltr">DefaultContext.getDefaultContext();
</pre></li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-360EF2DC-8DD9-49F2-8043-A1FA225802C4">Multiple Connections</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>For multiple connections, you can create and use additional instances of the <code class="codeph">DefaultContext</code> class, while optionally still using the default connection.
                        </p>
                        <p>You can use the <code class="codeph">Oracle.getConnection()</code> method to instantiate <code class="codeph">DefaultContext</code>, as in the following examples.
                        </p>
                        <p>First, consider a case where you want most statements to use the default connection, but other statements to use a different connection. You must create one additional instance of <code class="codeph">DefaultContext</code>:
                        </p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx = Oracle.getConnection (
   "jdbc:oracle:thin:@localhost2:5221/myservice2", "bill", "lion");
</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-DD65EDB6-69E3-498F-9859-3484B28F85B5">
                           <p class="notep1">Note:</p>
                           <p><code class="codeph">ctx</code> could also use the <code class="codeph">HR</code>/<code class="codeph">hr</code> schema, if you want to perform multiple sets of operations on the same schema.
                           </p>
                        </div>
                        <p>When you want to use the default connection, it is not necessary to specify a connection context:</p><pre class="oac_no_warn" dir="ltr">#sql { SQL operation };
</pre><p>This is actually a shortcut for the following:</p><pre class="oac_no_warn" dir="ltr">#sql [DefaultContext.getDefaultContext()] { <span class="italic">SQL operation</span> };
</pre><p>When you want to use the additional connection, specify <code class="codeph">ctx</code> as the connection:
                        </p><pre class="oac_no_warn" dir="ltr">#sql [ctx] { <span class="italic">SQL operation</span> };
</pre><p>Next, consider situations where you want to use multiple connections, where each of them is a named <code class="codeph">DefaultContext</code> instance. This enables you to switch your connection back and forth.
                        </p>
                        <p>The following statements establish multiple connections to the same schema (in case you want to use multiple Oracle Database sessions or transactions, for example). Instantiate the <code class="codeph">DefaultContext</code> class for each connection you will need:
                        </p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx1 = Oracle.getConnection
   ("jdbc:oracle:thin:@localhost1:5221/myservice1", "HR", "hr");
DefaultContext ctx2 = Oracle.getConnection
   ("jdbc:oracle:thin:@localhost1:5221/myservice1", "HR", "hr");
</pre><p>This creates two connection context instances that would use the same schema, connecting to <code class="codeph">HR/hr</code> using service <code class="codeph">myservice1</code> on the computer <code class="codeph">localhost1</code>, using Oracle JDBC Thin driver.
                        </p>
                        <p>Now, consider a case where you would want multiple connections to different schemas. Again, instantiate the <code class="codeph">DefaultContext</code> class for each connection you will need:
                        </p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx1 = Oracle.getConnection
   ("jdbc:oracle:thin:@localhost1:5221/myservice1", "HR", "hr");
DefaultContext ctx2 = Oracle.getConnection
   ("jdbc:oracle:thin:@localhost2:5221/myservice2", "bill", "lion");
</pre><p>This creates two connection context instances that use Oracle JDBC Thin driver but use different schemas. The <code class="codeph">ctx1</code> object connects to <code class="codeph">HR/hr</code> using service <code class="codeph">myservice1</code> on the computer <code class="codeph">localhost1</code>, while the <code class="codeph">ctx2</code> object connects to <code class="codeph">bill/lion</code> using service <code class="codeph">myservice2</code> on the computer <code class="codeph">localhost2</code>.
                        </p>
                        <p>There are two ways to switch back and forth between these connections for the SQLJ executable statements in your application:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If you switch back and forth frequently, then you can specify the connection for each statement in your application:</p><pre class="oac_no_warn" dir="ltr">#sql [ctx1] { <span class="italic">SQL operation</span> };
...
#sql [ctx2] { <span class="italic">SQL operation</span> };
</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-941D383C-4F97-484B-9D08-8E10638DD98F">
                                 <p class="notep1">Note:</p>
                                 <p>Include the square brackets around the connection context instance name; they are part of the syntax.</p>
                              </div>
                           </li>
                           <li>
                              <p><a id="d8416e911" class="indexterm-anchor"></a>If you use either of the connections several times in a row within your code flow, then you can periodically use the static <code class="codeph">setDefaultContext()</code> method of the <code class="codeph">DefaultContext</code> class to reset the default connection. This method initializes the default connection context instance. This way, you can avoid specifying connections in your SQLJ statements.
                              </p><pre class="oac_no_warn" dir="ltr">DefaultContext.setDefaultContext(ctx1);
#sql { <span class="italic">SQL operation</span> };   // These three statements all use ctx1
#sql { <span class="italic">SQL operation</span> };
#sql { <span class="italic">SQL operation</span> };
...
DefaultContext.setDefaultContext(ctx2);
#sql { <span class="italic">SQL operation</span> };   // These three statements all use ctx2
#sql { <span class="italic">SQL operation</span> };
#sql { <span class="italic">SQL operation</span> };
</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-0FAC9209-D1B8-4BC2-94A1-8A760FBBEC61">
                                 <p class="notep1">Note:</p>
                                 <p>Because the preceding statements do not specify connection contexts, at translation time they will all be checked against the default connection context.</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ199"></a><div class="props_rev_3"><a id="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC" name="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC"></a><h4 id="JSQLJ-GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC" class="sect4">Closing Connections</h4>
                  <div>
                     <div class="section">
                        <p>It is advisable to close your connection context instances when you are done, preferably in a <code class="codeph">finally</code> clause of a <code class="codeph">try</code> block (in case your application terminates with an exception).
                        </p>
                        <p>The <code class="codeph">DefaultContext</code> class, as well as any connection context classes that you declare, includes a <code class="codeph">close()</code> method. Calling this method closes the SQLJ connection context instance and, by default, also closes the underlying JDBC connection instance and the physical connection.
                        </p>
                        <p>In addition, the <code class="codeph">oracle.sqlj.runtime.Oracle</code> class has a static <code class="codeph">close()</code> method to close the default connection only. In the following example, presume <code class="codeph">ctx</code> is an instance of any connection context class:
                        </p><pre class="oac_no_warn" dir="ltr">...
finally
{
   ctx.close();
}
...
</pre><p>Alternatively, if the <code class="codeph">finally</code> clause is not within a <code class="codeph">try</code> block in case a SQL exception is encountered:
                        </p><pre class="oac_no_warn" dir="ltr">...
finally
{
   try { ctx.close(); } catch(SQLException ex) {...}
}
...
</pre><p>Or, to close the default connection, the <code class="codeph">Oracle</code> class also provides a <code class="codeph">close()</code> method:
                        </p><pre class="oac_no_warn" dir="ltr">...
finally
{
   Oracle.close();
}
...
</pre><p>Always commit or roll back any pending changes before closing the connection. Whether there would be an implicit <code class="codeph">COMMIT</code> operation as the connection is closed is not specified in the JDBC standard and may vary from vendor to vendor. For Oracle, there is an implicit <code class="codeph">COMMIT</code> when a connection is closed, and an implicit <code class="codeph">ROLLBACK</code> when a connection is garbage-collected without being closed, but it is not advisable to rely on these mechanisms.
                        </p>
                        <div class="infoboxnote" id="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC__GUID-BF05E52D-85EA-47C4-BE04-19E3462E53F3">
                           <p class="notep1">Note:</p>
                           <p>It is also possible to close a connection context instance without closing the underlying connection (in case the underlying connection is shared).</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ200"></a><div class="props_rev_3"><a id="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C" name="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C"></a><h4 id="JSQLJ-GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C" class="sect4">Multiple Connections Using Declared Connection Context Classes</h4>
                  <div>
                     <p>For multiple connections that use different sets of SQL entities, it is advantageous to use connection context declarations to define additional connection context classes. Having a separate connection context class for each set of SQL entities that you use enables SQLJ to do more rigorous semantics-checking of your code.</p>
                     <div class="infoboxnotealso" id="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C__GUID-4C96E253-DC1D-45CC-AC30-287DE4463D1B">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">Connection Contexts</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ202"></a><a id="JSQLJ203"></a><a id="JSQLJ201"></a><div class="props_rev_3"><a id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3" name="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3"></a><h4 id="JSQLJ-GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3" class="sect4">More About the Oracle Class</h4>
                  <div>
                     <p>The Oracle SQLJ implementation provides the <code class="codeph">oracle.sqlj.runtime.Oracle</code> class to simplify the process of creating and using instances of the <code class="codeph">DefaultContext</code> class.
                     </p>
                     <p>The static <code class="codeph">connect()</code> method initializes the default connection context instance, instantiating a <code class="codeph">DefaultContext</code> object and installing it as your default connection. You do not need to assign or use the <code class="codeph">DefaultContext</code> instance returned by <code class="codeph">connect()</code>. If you had already established a default connection, then <code class="codeph">connect()</code> returns <code class="codeph">null</code>.
                     </p>
                     <p>The static <code class="codeph">getConnection()</code> method simply instantiates a <code class="codeph">DefaultContext</code> object and returns it. You can use the returned instance as desired.
                     </p>
                     <p>Both methods register Oracle JDBC driver manager automatically if the <code class="codeph">oracle.jdbc.OracleDriver</code> class is found in the <code class="codeph">CLASSPATH</code>. The static <code class="codeph">close()</code> method closes the default connection.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-2A842A7A-1D3A-4035-983E-0BC7DF3ED3E6">Signatures of the Oracle.connect() and Oracle.getConnection() Methods</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Both the method have signatures that take the following parameter sets as input:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>URL (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>), auto-commit flag (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), <code class="codeph">java.util.Properties</code> object containing properties for the connection
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), <code class="codeph">java.util.Properties</code> object, auto-commit flag (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>) fully specifying the connection, including user name and password
                              </p>
                              <p>The following is an example of the format of a URL string specifying user name (<code class="codeph">HR</code>) and password (<code class="codeph">hr</code>) when using Oracle JDBC drivers, in this case the JDBC Thin driver:
                              </p><pre class="oac_no_warn" dir="ltr">"jdbc:oracle:thin:HR/hr@localhost:5221/myservice"
</pre></li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), auto-commit flag (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">java.lang.Class</code> object for the class relative to which the properties file is loaded, name of properties file (<code class="codeph">String</code>)
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">java.lang.Class</code> object, name of properties file (<code class="codeph">String</code>), auto-commit flag (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">java.lang.Class</code> object, name of properties file (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>)
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">java.lang.Class</code> object, name of properties file (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>), auto-commit flag (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>JDBC connection object (<code class="codeph">Connection</code>)
                              </p>
                           </li>
                           <li>
                              <p>SQLJ connection context object</p>
                           </li>
                        </ul>
                        <p>These last two signatures inherit an existing database connection. When you inherit a connection, you will also inherit the auto-commit setting of that connection.</p>
                        <p>The auto-commit flag specifies whether SQL operations are automatically committed. For the <code class="codeph">Oracle.connect()</code> and <code class="codeph">Oracle.getConnection()</code> methods only, the default is <code class="codeph">false</code>. If that is the setting you want, then you can use one of the signatures that does not take auto-commit as input. However, anytime you use a constructor to create an instance of a connection context class, including <code class="codeph">DefaultContext</code>, you must specify the auto-commit setting. In the Oracle JDBC implementation, the default for the auto-commit flag is <code class="codeph">true</code>. 
                        </p>
                        <div class="infoboxnotealso" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-689BBE2A-7AB8-4A1A-A555-4EE8D623282C">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">Basic Transaction Control</a>"</span> and <span class="q">"<a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">Single Connection or Multiple Connections Using DefaultContext</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-5D0E0DC9-96FD-4A4F-9725-6101B8F40301">Optional Oracle.close() Method Parameters</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In using the <code class="codeph">Oracle.close()</code> method to close the default connection, you have the option of specifying whether or not to close the underlying physical database connection. By default it is closed. This is relevant if you are sharing this physical connection between multiple connection objects, either SQLJ connection context instances or JDBC connection instances.
                        </p>
                        <p>You can keep the underlying physical connection open as follows:</p><pre class="oac_no_warn" dir="ltr">Oracle.close(ConnectionContext.KEEP_CONNECTION);
</pre><p>You can close the underlying physical connection (default behavior) as follows:</p><pre class="oac_no_warn" dir="ltr">Oracle.close(ConnectionContext.CLOSE_CONNECTION);
</pre><p><code class="codeph">KEEP_CONNECTION</code> and <code class="codeph">CLOSE_CONNECTION</code> are static constants of the <code class="codeph">ConnectionContext</code> interface.
                        </p>
                        <div class="infoboxnotealso" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-6F98EB3E-0104-4BB8-A125-32483ED5F168">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">Closing Shared Connections</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ205"></a><a id="JSQLJ206"></a><a id="JSQLJ207"></a><a id="JSQLJ208"></a><a id="JSQLJ204"></a><div class="props_rev_3"><a id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1" name="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1"></a><h4 id="JSQLJ-GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1" class="sect4">More About the DefaultContext Class</h4>
                  <div>
                     <p>The <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class provides a complete default implementation of a connection context class. As with classes created using a connection context declaration, the <code class="codeph">DefaultContext</code> class implements the <code class="codeph">sqlj.runtime.ConnectionContext</code> interface. The <code class="codeph">DefaultContext</code> class has the same class definition that would have been generated by the SQLJ translator from the declaration:
                     </p><pre class="oac_no_warn" dir="ltr">#sql public context DefaultContext;
</pre><div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-25464FBB-2DDE-4500-BC25-40245AABB2E1">DefaultContext Methods</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following are the key methods of the <code class="codeph">DefaultContext</code> class:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">getConnection()</code></p>
                              <p>Gets the underlying JDBC connection object. This is useful if you want to have JDBC code in your application, which is one way to use dynamic SQL operations. You can also use the <code class="codeph">setAutoCommit()</code> method of the underlying JDBC connection object to set the auto-commit flag for the connection.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setDefaultContext()</code></p>
                              <p>Sets the default connection your application uses. This is a <code class="codeph">static</code> method and takes a <code class="codeph">DefaultContext</code> instance as input. SQLJ executable statements that do not specify a connection context instance will use the default connection that you define using this method or the <code class="codeph">Oracle.connect()</code> method.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getDefaultContext()</code></p>
                              <p>Returns the <code class="codeph">DefaultContext</code> instance currently defined as the default connection for your application. This is a <code class="codeph">static</code> method.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">close()</code></p>
                              <p>Closes the connection context instance.</p>
                           </li>
                        </ul>
                        <p>The <code class="codeph">getConnection()</code> and <code class="codeph">close()</code> methods are specified in the <code class="codeph">sqlj.runtime.ConnectionContext</code> interface.
                        </p>
                        <div class="infoboxnote" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-CCFD9BDD-2276-4964-BB1D-ECF47B0FCBEE">
                           <p class="notep1">Note:</p>
                           <p>On a client, <code class="codeph">getDefaultContext()</code> returns <code class="codeph">null</code> if <code class="codeph">setDefaultContext()</code> was not previously called. However, if a data source object has been bound under "<code class="codeph">jdbc/defaultDataSource</code>" in JNDI, then the client will use this data source object as its default connection.
                           </p>
                           <p>In the server, <code class="codeph">getDefaultContext()</code> returns the default connection, which is the connection to the server itself.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-2CF45392-2A16-4135-A3C4-B487253B0855">DefaultContext Constructors</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>It is typical to instantiate <code class="codeph">DefaultContext</code> using the <code class="codeph">Oracle.connect()</code> or <code class="codeph">Oracle.getConnection()</code> method. However, if you want to create an instance directly, then there are five constructors for <code class="codeph">DefaultContext</code>. The different input parameter sets for these constructors are: 
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>URL (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>), auto-commit (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), <code class="codeph">java.util.Properties</code> object, auto-commit (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code> fully specifying connection and including user name and password), auto-commit setting (<code class="codeph">boolean</code>)
                              </p>
                              <p>The following is an example of the format of a URL specifying user name and password when using Oracle JDBC drivers, in this case the JDBC Thin driver:</p><pre class="oac_no_warn" dir="ltr">"jdbc:oracle:thin:HR/hr@localhost:5221/myservice"
</pre></li>
                           <li>
                              <p>JDBC connection object (<code class="codeph">Connection</code>)
                              </p>
                           </li>
                           <li>
                              <p>SQLJ connection context object</p>
                           </li>
                        </ul>
                        <p>The last two signatures inherit an existing database connection. When you inherit a connection, you will also inherit the auto-commit setting of that connection.</p>
                        <p>Following is an example of constructing a <code class="codeph">DefaultContext</code> instance:
                        </p><pre class="oac_no_warn" dir="ltr">DefaultContext defctx = new DefaultContext
   ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", false);</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-24500EC5-B80A-49E7-BA9C-6970578E2571">Notes About Connection Context Constructors:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-67FF6542-92B2-4197-AF33-E0E24CEA3820">
                           <p class="notep1">Note:</p>
                           <p>You must keep the following in mind when using connection context constructors:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>It is important to note that connection context class constructors, unlike the <code class="codeph">Oracle.connect()</code> method, require an auto-commit setting.
                                 </p>
                              </li>
                              <li>
                                 <p>To use any of the first three constructors listed, you must first register your JDBC driver. This happens automatically if you are using an Oracle JDBC driver and call <code class="codeph">Oracle.connect()</code>. Refer to <span class="q">"<a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">Driver Selection and Registration for Run Time</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>Connection context classes that you declare generally have the same constructor signatures as the <code class="codeph">DefaultContext</code> class. However, if you declare a connection context class to be associated with a data source, a different set of constructors is provided. Refer to <span class="q">"<a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">Standard Data Source Support</a>"</span> for more information.
                                 </p>
                              </li>
                              <li>
                                 <p>When using the constructor that takes a JDBC connection object, do not initialize the connection context instance with a null JDBC connection.</p>
                              </li>
                              <li>
                                 <p>The auto-commit setting determines whether SQL operations are automatically committed. Refer to <span class="q">"<a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">Basic Transaction Control</a>"</span> for more information.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-18CADC75-479F-4BFD-BAD0-0C0F39097EA7">Optional DefaultContext close() Method Parameters</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When you close a connection context instance, you have the option of specifying whether or not to close the underlying physical connection. By default it is closed. This is relevant if you are sharing the physical connection between multiple connection objects, either SQLJ connection context instances or JDBC connection instances. The following examples presume a <code class="codeph">DefaultContext</code> instance <code class="codeph">defctx</code>.
                        </p>
                        <p>To keep the underlying physical connection open, use the following:</p><pre class="oac_no_warn" dir="ltr">defctx.close(ConnectionContext.KEEP_CONNECTION);
</pre><p>To close the underlying physical connection, which is the default behavior, use the following:</p><pre class="oac_no_warn" dir="ltr">defctx.close(ConnectionContext.CLOSE_CONNECTION);
</pre><p><code class="codeph">KEEP_CONNECTION</code> and <code class="codeph">CLOSE_CONNECTION</code> are static constants of the <code class="codeph">ConnectionContext</code> interface.
                        </p>
                        <div class="infoboxnotealso" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-C4CF2F07-5C8F-4416-A97C-F98EB2D58703">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">Closing Shared Connections</a>"</span> for more information about using these parameters and about shared connections
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ209"></a><div class="props_rev_3"><a id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9" name="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9"></a><h4 id="JSQLJ-GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9" class="sect4">Connection for Translation</h4>
                  <div>
                     <div class="section">
                        <p>If you want to use online semantics-checking during tra<a id="d8416e1710" class="indexterm-anchor"></a>nslation, then you must specify a database connection for SQLJ to use. These are referred to as <span class="bold">exemplar schemas</span>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9__GUID-E1F28580-BDC0-4D47-A236-454914D10875">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E">Connection Context Concepts</a>"</span></p>
                        </div>
                        <p>You can use different connections for translation and run time. In fact, it is often necessary or preferable to do so. It might be necessary if you are not developing the application in the same kind of environment that it will run in. But even if the run-time connection is available during translation, it might be preferable to create an account with a narrower set of resources so that your online checking will be tighter. This would be true if your application uses only a small subset of the SQL entities available in the run-time connection. Your online checking would be tighter and more meaningful if you create an exemplar schema consisting only of SQL entities that your application actually uses.</p>
                        <p>Use the SQLJ translator connection options, either on the command line or in a properties file, to specify a connection for translation.</p>
                        <div class="infoboxnotealso" id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9__GUID-ACC8594B-D41F-4C5A-9EA5-FF8ADCC4C17F">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">Connection Options</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ210"></a><div class="props_rev_3"><a id="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F" name="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F"></a><h4 id="JSQLJ-GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F" class="sect4">Connection for Customization</h4>
                  <div>
                     <p>Generally, Oracle customization does not require a database connection. However, the Oracle SQLJ implementation does support customizer connections. This is useful in two circumstances:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If you are using Oracle customizer with the <code class="codeph">optcols</code> option enabled, then a connection is required. This option allows iterator column type and size definitions for performance optimization.
                           </p>
                        </li>
                        <li>
                           <p>If you are using <code class="codeph">SQLCheckerCustomizer</code>, a specialized customizer that performs semantics-checking on profiles, then a connection is required if you are using an online checker, which is true by default.
                           </p>
                        </li>
                     </ul>
                     <p>For Oracle-specific code generation, the SQLJ translator has an <code class="codeph">-optcols</code> option with the same functionality. The <code class="codeph">SQLCheckerCustomizer</code> is invoked through Oracle customizer harness <code class="codeph">verify</code> option. Use the customizer harness <code class="codeph">user</code>, <code class="codeph">password</code>, <code class="codeph">url</code>, and <code class="codeph">driver</code> options to specify connection parameters for whatever customizer you are using, as appropriate.
                     </p>
                     <div class="infoboxnotealso" id="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F__GUID-6DF2B38E-33C0-43AE-8FF4-03192A23E2B5">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="appendix.html#GUID-B2FDCFA4-3938-417B-BD40-4A9EAB8DB4FA">Oracle Customizer Column Definition Option (optcols)</a>"</span>.
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="appendix.html#GUID-B0B2AAD4-3AE2-43F1-A38E-37D48343C353">SQLCheckerCustomizer for Profile Semantics-Checking</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="appendix.html#GUID-C5D50F74-E805-4DDA-AC81-353C94C40A21">Customizer Harness Options for Connections</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ211"></a><div class="props_rev_3"><a id="GUID-EA345D88-D2AE-4118-986A-472764A6E1A4" name="GUID-EA345D88-D2AE-4118-986A-472764A6E1A4"></a><h3 id="JSQLJ-GUID-EA345D88-D2AE-4118-986A-472764A6E1A4" class="sect3">NULL-Handling</h3>
               <div>
                  <p>Java primitive types, such as <code class="codeph">int</code>, <code class="codeph">double</code>, or <code class="codeph">float</code>, cannot have null values. You must consider this in choosing your result expression and host expression types.
                  </p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-0C865EA3-6881-46EA-AD86-7491F19494B2">Wrapper Classes for NULL-Handling</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-70958B5D-E010-4C42-9F1C-297B398DC938">Examples of NULL-Handling </a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ212"></a><div class="props_rev_3"><a id="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2" name="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2"></a><h4 id="JSQLJ-GUID-0C865EA3-6881-46EA-AD86-7491F19494B2" class="sect4">Wrapper Classes for NULL-Handling</h4>
                  <div>
                     <p>SQLJ consistently enforces retrieving SQL <code class="codeph">NULL</code> as Java <code class="codeph">null</code>, in contrast to JDBC, which retrieves <code class="codeph">NULL</code> as <code class="codeph">0</code> or <code class="codeph">false</code> for certain data types. Therefore, do not use Java primitive types in SQLJ for output variables in situations where a SQL <code class="codeph">NULL</code> may be received, because Java primitive types cannot take <code class="codeph">null</code> values.
                     </p>
                     <p>This pertains to result expressions, output or input-output host expressions, and iterator column types. If the receiving Java type is primitive and an attempt is made to retrieve a SQL <code class="codeph">NULL</code>, then a <code class="codeph">sqlj.runtime.SQLNullException</code> is thrown and no assignment is made.
                     </p>
                     <p>To avoid the possibility of <code class="codeph">NULL</code> being assigned to Java primitives, use the following wrapper classes instead of primitive types:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">java.lang.Boolean</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Byte</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Short</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Integer</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Long</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Double</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang.Float</code></p>
                        </li>
                     </ul>
                     <p>In case you must convert back to a primitive value, each of these wrapper classes has an <span class="italic"><code class="codeph">xxx</code></span><code class="codeph">Value()</code> method. For example, <code class="codeph">intValue()</code> returns an <code class="codeph">int</code> value from an <code class="codeph">Integer</code> object and <code class="codeph">floatValue()</code> returns a <code class="codeph">float</code> value from a <code class="codeph">Float</code> object. For example, presuming <code class="codeph">intobj</code> is an <code class="codeph">Integer</code> object:
                     </p><pre class="oac_no_warn" dir="ltr">int j = intobj.intValue();
</pre><div class="infoboxnote" id="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2__GUID-4BBAB10B-14C1-4CA9-9F66-8DF0F805C0CF">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">SQLNullException</code> is a subclass of the standard <code class="codeph">java.sql.SQLException</code> class.
                              </p>
                           </li>
                           <li>
                              <p>Because Java objects can have <code class="codeph">null</code> values, there is no need for indicator variables in SQLJ, such as those used in other host languages like C, C++, and COBOL. 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ214"></a><a id="JSQLJ215"></a><a id="JSQLJ213"></a><div class="props_rev_3"><a id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938" name="GUID-70958B5D-E010-4C42-9F1C-297B398DC938"></a><h4 id="JSQLJ-GUID-70958B5D-E010-4C42-9F1C-297B398DC938" class="sect4">Examples of NULL-Handling </h4>
                  <div>
                     <div class="section">
                        <p>The following examples show the use of the <code class="codeph">java.lang</code> wrapper classes to handle <code class="codeph">NULL</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-D58FBB6E-B849-4332-978A-FA2E83C8EB6F">Example: Null Input Host Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In the following example, a <code class="codeph">Float</code> object is used to pass a <code class="codeph">null</code> value to the database:
                        </p><pre class="oac_no_warn" dir="ltr">int empno = 7499;
Float commission = null;

#sql { UPDATE employees SET commission_pct = :commission WHERE employee_id = :empno };
</pre><p>You cannot use the Java primitive type <code class="codeph">float</code> to accomplish this.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-A34344DF-B5C8-4B64-8B18-C621DC17FD84">Example: Null Iterator Rows</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In the following example, a <code class="codeph">Double</code> column type is used in an iterator to allow for the possibility of <code class="codeph">null</code> data.
                        </p>
                        <p>For each employee in the <code class="codeph">employee</code> table whose salary is at least $50,000, the employee name (<code class="codeph">FIRST_NAME</code>) and commission (<code class="codeph">COMMISSION_PCT</code>) are selected into the iterator. Then each row is tested to determine if the <code class="codeph">COMMISSION_PCT</code> field is, in fact, null. If so, then it is processed accordingly.
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmployeeIter (String first_name, Double commission);

EmployeeIter ei;
#sql ei = { SELECT first_name, commission_pct FROM employees WHERE salary &gt;= 50000 };

while (ei.next())
{
   if (ei.commission_pct() == null) 
      System.out.println(ei.first_name() + " is not on commission.");
}
ei.close();
...
</pre><div class="infoboxnote" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-3B97D3EA-0F0A-442A-B3FF-81DE6E8BA14F">
                           <p class="notep1">Note:</p>
                           <p>To execute a <code class="codeph">WHERE</code> clause comparison against <code class="codeph">NULL</code>, use the following SQL syntax:
                           </p><pre class="oac_no_warn" dir="ltr">...WHERE :x IS NULL
</pre></div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ216"></a><div class="props_rev_3"><a id="GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0" name="GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0"></a><h3 id="JSQLJ-GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0" class="sect3">Exception-Handling Basics</h3>
               <div>
                  <p>This section covers the basics of handling exceptions in SQLJ application, including requirements for error-checking. This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E">SQLJ and JDBC Exception-Handling Requirements</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-889158EE-29C1-4F10-A955-B94801353C67">Processing Exceptions</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-9EA4834A-717F-4177-9901-418F806A8EC2">Using SQLException Subclasses</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ218"></a><a id="JSQLJ217"></a><div class="props_rev_3"><a id="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E" name="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E"></a><h4 id="JSQLJ-GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E" class="sect4">SQLJ and JDBC Exception-Handling Requirements</h4>
                  <div>
                     <p>Because SQLJ executable statements result in JDBC calls through <code class="codeph">sqlj.runtime</code>, and JDBC requires SQL exceptions to be caught or thrown, SQLJ also requires SQL exceptions to be caught or thrown in any block containing SQLJ executable statements. Your source code will generate errors during compilation if you do not include appropriate exception-handling.
                     </p>
                     <p>Handling SQL exceptions requires the <code class="codeph">SQLException</code> class, which is included in the standard JDBC <code class="codeph">java.sql.*</code> package.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E__GUID-8346C744-1111-4D9D-980A-042A53812C71">Example: Exception Handling</p>
                     </div>
                     <!-- class="section" -->
                     <p>This example demonstrates the basic exception-handling required in SQLJ applications. The code declares a <code class="codeph">main</code> method with a <code class="codeph">try/catch</code> block and another method, which throws <code class="codeph">SQLException</code> when an exception is encountered. The code is as follows:
                     </p><pre class="oac_no_warn" dir="ltr">    /* Import SQLExceptions class.  The SQLException comes from
       JDBC. Executable #sql clauses result in calls to JDBC, so methods
       containing executable #sql clauses must either catch or throw
       SQLException.
    */
import java.sql.* ;
import oracle.sqlj.runtime.Oracle;

    // iterator for the select

#sql iterator MyIter (String ITEM_NAME);

public class TestInstallSQLJ 
{
    //Main method
  public static void main (String args[]) 
  {
    try { 

    // Set the default connection to the URL, user, and password
    // specified in your connect.properties file
      Oracle.connect(TestInstallSQLJ.class, "connect.properties");

      TestInstallSQLJ ti = new TestInstallSQLJ();

    // This method throws SQLException. Therefore, it ic called within a try block
      ti.runExample();

    } catch (SQLException e) { 
      System.err.println("Error running the example: " + e);
    }

  } //End of method main

  //Method that runs the example
  void runExample() throws SQLException
  {
      //Issue SQL command to clear the SALES table
    #sql { DELETE FROM SALES };
    #sql { INSERT INTO SALES(ITEM_NAME) VALUES ('Hello, SQLJ!')};

    MyIter iter;
    #sql iter = { SELECT ITEM_NAME FROM SALES };

    while (iter.next()) {
      System.out.println(iter.ITEM_NAME());
    }
  }
}
</pre></div>
               </div><a id="JSQLJ220"></a><a id="JSQLJ221"></a><a id="JSQLJ219"></a><div class="props_rev_3"><a id="GUID-889158EE-29C1-4F10-A955-B94801353C67" name="GUID-889158EE-29C1-4F10-A955-B94801353C67"></a><h4 id="JSQLJ-GUID-889158EE-29C1-4F10-A955-B94801353C67" class="sect4">Processing Exceptions</h4>
                  <div>
                     <div class="section">
                        <p>This section discusses ways to process and interpret exceptions in your SQLJ application. During run time, exceptions may be raised from any of the following:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SQLJ run time</p>
                           </li>
                           <li>
                              <p>JDBC driver</p>
                           </li>
                           <li>
                              <p>RDBMS</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__GUID-9468E406-CE40-426E-BDAF-FBE5D18837E9">Printing Error Text</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The example in the previous section showed how to catch SQL exceptions and output the error messages. Part of that code is as follows:</p><pre class="oac_no_warn" dir="ltr">...
try {
...
} catch (SQLException e) { 
      System.err.println("Error running the example: " + e); 
}
...
</pre><p>This will print the error text from the <code class="codeph">SQLException</code> object. 
                        </p>
                        <p>You can also retrieve error information using the <code class="codeph">getMessage()</code>, <code class="codeph">getErrorCode()</code>, and <code class="codeph">getSQLState()</code> methods the <code class="codeph">SQLException</code> class.
                        </p>
                        <p>Printing the error text, as in this example, prints the error message with some additional text, such as <code class="codeph">SQLException</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__I1006260">
                        <p class="subhead3" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__GUID-A83A6B23-AAB3-4D55-87F9-ED6D47C92DFD">Retrieving SQL States and Error Codes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">java.sql.SQLException</code> class and subclasses include the <code class="codeph">getMessage()</code>, <code class="codeph">getErrorCode()</code>, and <code class="codeph">getSQLState()</code> methods. Depending on where the exception or error originated and how they are implemented there, the following methods provide additional information:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">String getMessage()</code></p>
                              <p>If the error originates in the SQLJ run time or JDBC driver, then this method returns the error message with no prefix. If the error originates in the RDBMS, then it returns the error message prefixed by the <code class="codeph">ORA</code> number.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getErrorCode()</code></p>
                              <p>If the error originates in the SQLJ run time, then this method returns no meaningful information. If the error originates in the JDBC driver or RDBMS, then it returns the five-digit <code class="codeph">ORA</code> number as an integer.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">String getSQLState()</code></p>
                              <p>If the error originates in the SQLJ run time, then this method returns a string with a five-digit code indicating the SQL state. If the error originates in the JDBC driver, then it returns no meaningful information. If the error originates in the RDBMS, then it returns the five-digit SQL state. Your application should have appropriate code to handle <code class="codeph">null</code> values returned.
                              </p>
                           </li>
                        </ul>
                        <p>The following example prints the error message and also checks the SQL state:</p><pre class="oac_no_warn" dir="ltr">...
try {
...
} catch (SQLException e) { 
      System.err.println("Error running the example: " + e); 
      String sqlState = e.getSQLState();
      System.err.println("SQL state = " + sqlState); 
}
...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ222"></a><div class="props_rev_3"><a id="GUID-9EA4834A-717F-4177-9901-418F806A8EC2" name="GUID-9EA4834A-717F-4177-9901-418F806A8EC2"></a><h4 id="JSQLJ-GUID-9EA4834A-717F-4177-9901-418F806A8EC2" class="sect4">Using SQLException Subclasses</h4>
                  <div>
                     <div class="section">
                        <p>For more specific error-checking, use any available and appropriate subclasses of the <code class="codeph">java.sql.SQLException</code> class.
                        </p>
                        <p>SQLJ provides the <code class="codeph">sqlj.runtime.NullException</code> class, which is a subclass of <code class="codeph">java.sql.SQLException</code>. You can use this exception in situations where a <code class="codeph">NULL</code> might be returned into a Java primitive variable.
                        </p>
                        <p>For batch-enabled environments, there is also the standard <code class="codeph">java.sql.BatchUpdateException</code> subclass. Refer to <span class="q">"<a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006173">Error Conditions During Batch Execution</a>"</span> for further information.
                        </p>
                        <p>When you use a subclass of <code class="codeph">SQLException</code>, catch the subclass exception before catching <code class="codeph">SQLException</code>, as in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">...
try {
...
} catch (SQLNullException ne) {
     System.err.println("Null value encountered: " + ne); }
  catch (SQLException e) { 
     System.err.println("Error running the example: " + e); }
...
</pre><p>This is because a subclass exception can also be caught as a <code class="codeph">SQLException</code>. If you catch <code class="codeph">SQLException</code> first, then execution will not proceed to the part where you have coded special processing for the subclass exception.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ223"></a><div class="props_rev_3"><a id="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97" name="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97"></a><h3 id="JSQLJ-GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97" class="sect3">Basic Transaction Control</h3>
               <div>
                  <p>This section discusses how to manage data updates. It covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-6F534A06-48D0-4CDD-A547-75747A1808AD">Overview of Transactions</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB">Automatic Commits Versus Manual Commits</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E226849C-2017-489F-BAAF-66B79C6D1982">Specifying Auto-Commit as You Define a Connection</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404">Modifying Auto-Commit in an Existing Connection</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">Using Manual COMMIT and ROLLBACK</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B">Effect of Commits and Rollbacks on Iterators and Result Sets</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">Using Savepoints</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97__GUID-7DFD9605-74AA-4EEF-A0F4-64DF0A6D4B33">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">Advanced Transaction Control</a>"</span></p>
                  </div>
               </div><a id="JSQLJ224"></a><div class="props_rev_3"><a id="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD" name="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD"></a><h4 id="JSQLJ-GUID-6F534A06-48D0-4CDD-A547-75747A1808AD" class="sect4">Overview of Transactions</h4>
                  <div>
                     <p>A <span class="bold">transaction</span> is a sequence of SQL operations that Oracle treats as a single unit. A transaction begins with the first executable SQL statement after any of the following:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Connection to the database</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT</code> (committing data updates, either automatically or manually)
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ROLLBACK</code> (canceling data updates)
                           </p>
                        </li>
                     </ul>
                     <p>A transaction ends with a <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> operation.
                     </p>
                     <div class="infoboxnote" id="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD__GUID-58412C19-4172-4470-A6DD-CEE6D049E28F">
                        <p class="notep1">Note:</p>
                        <p>In Oracle Database 12<span class="italic">c </span>Release 2 (12.2), all data definition language (DDL) statements, such as <code class="codeph">CREATE</code> and <code class="codeph">ALTER</code>, include an implicit <code class="codeph">COMMIT</code>. This will commit not only the DDL statement, but all the preceding data manipulation language (DML) statements, such as <code class="codeph">INSERT</code>, <code class="codeph">DELETE</code>, and <code class="codeph">UPDATE</code>, that have not yet been committed or rolled back.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ225"></a><div class="props_rev_3"><a id="GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB" name="GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB"></a><h4 id="JSQLJ-GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB" class="sect4">Automatic Commits Versus Manual Commits</h4>
                  <div>
                     <p>In using SQLJ or JDBC, you can either have your data updates automatically committed or commit them manually. In either case, each <code class="codeph">COMMIT</code> operation starts a new transaction. You can specify that changes be committed automatically by enabling the auto-commit flag. This can be done either when you define a SQLJ connection or by using the <code class="codeph">setAutoCommit()</code> method of the underlying JDBC connection object of an existing connection. You can use manual control by disabling the auto-commit flag and using SQLJ <code class="codeph">COMMIT</code> and <code class="codeph">ROLLBACK</code> statements.
                     </p>
                     <p>Enabling auto-commit may be more convenient, but gives you less control. For example, you have no option to roll back changes. In addition, some SQLJ or JDBC features are incompatible with auto-commit mode. For example, you must disable the auto-commit flag for update batching or <code class="codeph">SELECT FOR UPDATE</code> syntax to work properly.
                     </p>
                  </div>
               </div><a id="JSQLJ226"></a><div class="props_rev_3"><a id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982" name="GUID-E226849C-2017-489F-BAAF-66B79C6D1982"></a><h4 id="JSQLJ-GUID-E226849C-2017-489F-BAAF-66B79C6D1982" class="sect4">Specifying Auto-Commit as You Define a Connection</h4>
                  <div>
                     <p>When you use the <code class="codeph">Oracle.connect()</code> or <code class="codeph">Oracle.getConnection()</code> method to create a <code class="codeph">DefaultContext</code> instance and define a connection, the auto-commit flag is set to <code class="codeph">false</code> by default. However, there are signatures of these methods that enable you to set this flag explicitly. The auto-commit flag is always the last parameter. 
                     </p>
                     <p>The following is an example of instantiating <code class="codeph">DefaultContext</code> and using the default <code class="codeph">false</code> setting for auto-commit mode:
                     </p><pre class="oac_no_warn" dir="ltr">Oracle.getConnection
   ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr");
</pre><p>Alternatively, you can specify a <code class="codeph">true</code> setting as follows:
                     </p><pre class="oac_no_warn" dir="ltr">Oracle.getConnection
   ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", true);
</pre><div class="infoboxnotealso" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-7EBB3568-728C-4B61-AC15-8979D0D9DE59">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">More About the Oracle Class</a>"</span></p>
                     </div>
                     <p>If you use a constructor to create a connection context instance, either of <code class="codeph">DefaultContext</code> or of a declared connection context class, then you must specify the auto-commit setting. Again, it is the last parameter, as in the following example:
                     </p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx = new DefaultContext
   ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", false);
</pre><div class="infoboxnotealso" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-CD68D3C1-8056-4AD9-AB40-484AE26E974B">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="key-programming-considerations.html#GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1">More About the DefaultContext Class</a>"</span></p>
                     </div>
                     <p>If you have reason to create a JDBC <code class="codeph">Connection</code> instance directly, then the auto-commit flag is set to <code class="codeph">true</code> by default if your program runs on a client, or <code class="codeph">false</code> by default if it runs in the server. You cannot specify an auto-commit setting when you create a JDBC <code class="codeph">Connection</code> instance directly, but you can use the <code class="codeph">setAutoCommit()</code> method to alter the setting.
                     </p>
                     <div class="infoboxnote" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-ACEBD3BC-4518-4D6F-8251-ADB650ABDC6B">
                        <p class="notep1">Note:</p>
                        <p>Auto-commit functionality is <span class="italic">not</span> supported by the JDBC server-side internal driver.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ227"></a><div class="props_rev_3"><a id="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404" name="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404"></a><h4 id="JSQLJ-GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404" class="sect4">Modifying Auto-Commit in an Existing Connection</h4>
                  <div>
                     <div class="section">
                        <p>There is typically no reason to change the auto-commit flag setting for an existing connection, but you can if you desire. You can do this by using the <code class="codeph">setAutoCommit()</code> method of the underlying JDBC connection object.
                        </p>
                        <p>You can retrieve the underlying JDBC connection object by using the <code class="codeph">getConnection()</code> method of any SQLJ connection context instance, whether it is an instance of the <code class="codeph">DefaultContext</code> class or of a connection context class that you declared.
                        </p>
                        <p>You can accomplish these two steps at once, as follows:</p><pre class="oac_no_warn" dir="ltr">ctx.getConnection().setAutoCommit(false);
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">ctx.getConnection().setAutoCommit(true);
</pre><p> In these examples, <code class="codeph">ctx</code> is a SQLJ connection context instance.
                        </p>
                        <div class="infoboxnote" id="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404__GUID-1453BFB3-C9F4-41EE-AAAB-B575A69C881B">
                           <p class="notep1">Note:</p>
                           <p>Do <span class="italic">not</span> alter the auto-commit setting in the middle of a transaction.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ228"></a><div class="props_rev_3"><a id="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7" name="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7"></a><h4 id="JSQLJ-GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7" class="sect4">Using Manual COMMIT and ROLLBACK</h4>
                  <div>
                     <div class="section">
                        <p>If you disable the auto-commit flag, then you must manually commit any data updates. To commit any changes that have been executed since the last <code class="codeph">COMMIT</code> operation, use the SQLJ <code class="codeph">COMMIT</code> statement, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { COMMIT };
</pre><p>To roll back any changes that have been executed since the last <code class="codeph">COMMIT</code> operation, use the SQLJ <code class="codeph">ROLLBACK</code> statement, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { ROLLBACK };
</pre><div class="infoboxnote" id="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7__GUID-A1101A79-50EF-49B2-B6BA-2759DFFC2F1B">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Do not use the <code class="codeph">COMMIT</code> and <code class="codeph">ROLLBACK</code> commands when auto-commit is enabled. This will result in unspecified behavior, or even SQL exceptions could be raised.
                                 </p>
                              </li>
                              <li>
                                 <p>You can also roll back to a specified savepoint. Refer to <span class="q">"<a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">Using Savepoints</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>All DDL statements in Oracle SQL syntax include an implicit <code class="codeph">COMMIT</code> operation. There is no special SQLJ functionality in this regard. Such statements follow standard Oracle SQL rules.
                                 </p>
                              </li>
                              <li>
                                 <p>If auto-commit mode is off and you close a connection context instance from a client application, then any changes since your last <code class="codeph">COMMIT</code> will be committed, unless you close the connection context instance with <code class="codeph">KEEP_CONNECTION</code>. Refer to <span class="q">"<a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">Closing Shared Connections</a>"</span> for more information. 
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ229"></a><div class="props_rev_3"><a id="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B" name="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B"></a><h4 id="JSQLJ-GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B" class="sect4">Effect of Commits and Rollbacks on Iterators and Result Sets</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">COMMIT</code> and <code class="codeph">ROLLBACK</code> operations do <span class="italic">not</span> affect open result sets and iterators. The result sets and iterators will still be open. Usually, all that is relevant to their content is the state of the database at the time of execution of the <code class="codeph">SELECT</code> statements that populated them.
                        </p>
                        <div class="infoboxnote" id="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B__GUID-27045A12-841B-4FF8-9403-54CECE27F15B">
                           <p class="notep1">Note:</p>
                           <p>An exception to this is if you declared an iterator class with <code class="codeph">sensitivity=SENSITIVE</code>. In this case, changes to the underlying result set may be seen whenever the iterator is scrolled outside of its window size. For more information about scrollable iterators, refer to <span class="q">"<a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a>"</span>. For more information about the underlying scrollable result sets, refer to the<a href="../jjdbc/resultset.html#JJDBC-GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" target="_blank"><span class="italic"> Oracle Database JDBC Developer's Guide</span></a>.
                           </p>
                        </div>
                        <p>This also applies to <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, and <code class="codeph">DELETE</code> statements that are executed after the <code class="codeph">SELECT</code> statements. Execution of these statements does not affect the contents of open result sets and iterators.
                        </p>
                        <p>Consider a situation where you <code class="codeph">SELECT</code>, then <code class="codeph">UPDATE</code>, and then <code class="codeph">COMMIT</code>. A nonsensitive result set or iterator populated by the <code class="codeph">SELECT</code> statement will be unaffected by the <code class="codeph">UPDATE</code> and <code class="codeph">COMMIT</code>.
                        </p>
                        <p>As a further example, consider a situation where you <code class="codeph">UPDATE</code>, then <code class="codeph">SELECT</code>, and then <code class="codeph">ROLLBACK</code>. A nonsensitive result set or iterator populated by the <code class="codeph">SELECT</code> will still contain the updated data, regardless of the subsequent <code class="codeph">ROLLBACK</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ231"></a><a id="JSQLJ232"></a><a id="JSQLJ230"></a><div class="props_rev_3"><a id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5" name="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5"></a><h4 id="JSQLJ-GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5" class="sect4">Using Savepoints</h4>
                  <div>
                     <div class="section">
                        <p>The JDBC 3.0 specification added support for savepoints. A <span class="bold">savepoint</span> is a defined point in a transaction that you can roll back to, if desired, instead of rolling back the entire transaction. The savepoint is the point in the transaction where the <code class="codeph">SAVEPOINT</code> statement appears.
                        </p>
                        <p>In Oracle9<span class="italic">i</span> Database Release 2 (9.2), SQLJ first included Oracle-specific syntax to support savepoints. In Oracle Database 12<span class="italic">c </span>Release 2 (12.2), SQLJ adds support for ISO SQLJ standard savepoint syntax.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-3EA842B2-7BAE-4E1D-B3D0-3E8E63F69A07">Support for ISO SQLJ Standard Savepoint Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In ISO SQLJ standard syntax, use a string literal in a <code class="codeph">SAVEPOINT</code> statement to designate a name for a savepoint. This can be done as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { SAVEPOINT savepoint1 };
</pre><p>If you want to roll back changes to that savepoint, then you can refer to the specified name later in a <code class="codeph">ROLLBACK TO</code> statement, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { ROLLBACK TO savepoint1 };
</pre><p>Use a <code class="codeph">RELEASE SAVEPOINT</code> statement if you no longer need the savepoint:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { RELEASE SAVEPOINT savepoint1 };
</pre><p>Savepoints are saved in the SQLJ execution context, which has methods that parallel the functionality of these three statements.</p>
                        <div class="infoboxnotealso" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-C84800EF-D3D6-4A3A-AB6F-A13B1FE37E04">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123">Savepoint Methods</a>"</span></p>
                        </div>
                        <p>Because any <code class="codeph">COMMIT</code> operation ends the transaction, this also releases all savepoints of the transaction.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-9CDD0D04-4D92-48E5-847D-2039EA653809">Oracle SQLJ Savepoint Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In addition to the ISO SQLJ standard syntax, the following Oracle-specific syntax for savepoints is supported. Note that the Oracle syntax uses string host expressions, rather than string literals.</p>
                        <p>You can set a savepoint as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { SET SAVEPOINT :<span class="italic">savepoint</span> };
</pre><p>The host expression, <span class="italic"><code class="codeph">savepoint</code></span> in this example, is a variable that specifies the name of the savepoint as a Java <code class="codeph">String</code>. 
                        </p>
                        <p>You can roll back to a savepoint as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { ROLLBACK TO :<span class="italic">savepoint</span> };
</pre><p>To release a savepoint, use the following SQLJ statement:</p><pre class="oac_no_warn" dir="ltr">#sql { RELEASE :<span class="italic">savepoint</span> };
</pre><div class="infoboxnote" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-1CD8CB90-2AD0-4441-ABEB-89DDE1B46B62">
                           <p class="notep1">Note:</p>
                           <p>Oracle-specific syntax will continue to be supported for backward compatibility. Note the following differences between Oracle syntax and ISO SQLJ standard syntax:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Oracle syntax takes string variables rather than string literals.</p>
                              </li>
                              <li>
                                 <p>Oracle syntax uses <code class="codeph">SET SAVEPOINT</code> instead of <code class="codeph">SAVEPOINT</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Oracle syntax uses <code class="codeph">RELEASE</code> instead of <code class="codeph">RELEASE SAVEPOINT</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ234"></a><a id="JSQLJ235"></a><a id="JSQLJ236"></a><a id="JSQLJ237"></a><a id="JSQLJ238"></a><a id="JSQLJ239"></a><a id="JSQLJ240"></a><a id="JSQLJ233"></a><div class="props_rev_3"><a id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A" name="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A"></a><h3 id="JSQLJ-GUID-E1A4C501-C265-43F6-98A3-D3F46044348A" class="sect3">Summary: First Steps in SQLJ Code</h3>
               <div>
                  <p>The best way to summarize the SQLJ executable statement features and functionality discussed to this point is by examining short but complete programs. This section presents two such examples.</p>
                  <p>The first example, presented one step at a time and then again in its entirety, uses a <code class="codeph">SELECT INTO</code> statement to perform a single-row query of two columns from a table of employees. If you want to run the example, ensure that you change the parameters in the <code class="codeph">connect.properties</code> file to settings that will let you connect to an appropriate database.
                  </p>
                  <p>The second example, slightly more complicated, will make use of a SQLJ iterator for a multi-row query.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-4AD92035-6A85-425C-9E74-45E7D8FDC141">Import Required Classes</p>
                  </div>
                  <!-- class="section" -->
                  <p>Import any JDBC or SQLJ packages you will need. You will need at least some of the classes in the <code class="codeph">java.sql</code> package:
                  </p><pre class="oac_no_warn" dir="ltr">import java.sql.*;
</pre><p>You may not need all the <code class="codeph">java.sql</code> package. Key classes are <code class="codeph">java.sql.SQLException</code> and any classes that you refer to explicitly. For example, <code class="codeph">java.sql.Date</code> and <code class="codeph">java.sql.ResultSet</code>.
                  </p>
                  <p>You will need the following package for the <code class="codeph">Oracle</code> class, which you typically use to instantiate <code class="codeph">DefaultContext</code> objects and establish your default connection:
                  </p><pre class="oac_no_warn" dir="ltr">import oracle.sqlj.runtime.*;
</pre><p>If you will be using any SQLJ run-time classes directly in your code, then import the following packages:</p><pre class="oac_no_warn" dir="ltr">import sqlj.runtime.*;
import sqlj.runtime.ref.*;
</pre><p>However, even if your code does not use any SQLJ run-time classes directly, it will be sufficient to have them in the <code class="codeph">CLASSPATH</code>.
                  </p>
                  <p>Key run-time classes include <code class="codeph">ResultSetIterator</code> and <code class="codeph">ExecutionContext</code> in the <code class="codeph">sqlj.runtime</code> package and <code class="codeph">DefaultContext</code> in the <code class="codeph">sqlj.runtime.ref</code> package.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-C3D20B50-15DB-49D6-91F4-7FB92AF42460">Register JDBC Drivers and Set Default Connection</p>
                  </div>
                  <!-- class="section" -->
                  <p>Declare the <code class="codeph">SimpleExample</code> class with a constructor that uses the static <code class="codeph">Oracle.connect()</code> method to set the default connection. This also registers Oracle JDBC drivers.
                  </p>
                  <p>This uses a signature of <code class="codeph">connect()</code> that takes the URL, user name, and password from the <code class="codeph">connect.properties</code> file. An example of this file is in the directory <span class="italic"><code class="codeph">ORACLE_HOME</code></span><code class="codeph">/sqlj/demo</code> and also in <span class="q">"<a href="getting-started.html#GUID-896CA936-1CD5-4478-90CD-1E0738E94204">Set Up the Run-Time Connection</a>"</span>.
                  </p><pre class="oac_no_warn" dir="ltr">public class SimpleExample {

  public SimpleExample() throws SQLException {
    // Set default connection (as defined in connect.properties).
    Oracle.connect(getClass(), "connect.properties");
  }
</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-2D3A22AF-D03B-410A-89E7-21433B7322E8">Set Up Exception Handling</p>
                  </div>
                  <!-- class="section" -->
                  <p>Create a <code class="codeph">main()</code> that calls the <code class="codeph">SimpleExample</code> constructor and then sets up a <code class="codeph">try/catch</code> block to handle any SQL exceptions thrown by the <code class="codeph">runExample()</code> method, which performs the real work of this application:
                  </p><pre class="oac_no_warn" dir="ltr">...
public static void main (String [] args) {
    
   try {
      SimpleExample o1 = new SimpleExample();
      o1.runExample();
   }
   catch (SQLException ex) {
      System.err.println("Error running the example: " + ex);
   }
}
...
</pre><p>You can also use a <code class="codeph">try/catch</code> block inside a <code class="codeph">finally</code> clause when you close the connection, presuming the <code class="codeph">finally</code> clause is not already inside a <code class="codeph">try/catch</code> block in case of SQL exceptions:
                  </p><pre class="oac_no_warn" dir="ltr">finally
{
   try { Oracle.close(); } catch(SQLException ex) {...}
}</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-0EF134D5-7B22-4604-89A3-84000FF674A8">Set Up Host Variables, Execute SQLJ Clause, Process Results</p>
                  </div>
                  <!-- class="section" -->
                  <p>Create a <code class="codeph">runExample()</code> method that performs the following:
                  </p>
                  <ol>
                     <li>
                        <p>Throws any SQL exceptions to the <code class="codeph">main()</code> method for processing.
                        </p>
                     </li>
                     <li>
                        <p>Declares Java host variables. </p>
                     </li>
                     <li>
                        <p>Executes a SQLJ clause that binds the Java host variables into an embedded <code class="codeph">SELECT</code> statement and selects the data into the host variables.
                        </p>
                     </li>
                     <li>
                        <p>Prints the results.</p>
                     </li>
                  </ol>
                  <p>The code for this method is as follows:</p><pre class="oac_no_warn" dir="ltr">void runExample() throws SQLException {
     
     System.out.println( "Running the example--" );
     
     // Declare two Java host variables--
     Float salary;
     String empname;

     // Use SELECT INTO statement to execute query and retrieve values.
      #sql { SELECT first_name, salary INTO :empname, :salary FROM employees
             WHERE employee_id = 7499 };
     
     // Print the results--
     System.out.println("Name is " + empname + ", and Salary is " + salary);
  }
}    // Closing brace of SimpleExample class
</pre><p>This example declares <code class="codeph">salary</code> and <code class="codeph">empname</code> as Java host variables. The SQLJ clause then selects data from the <code class="codeph">first_name</code> and <code class="codeph">salary</code> columns of the <code class="codeph">employees</code> table and places the data into the host variables. Finally, the values of <code class="codeph">salary</code> and <code class="codeph">empname</code> are printed.
                  </p>
                  <p>Note that this <code class="codeph">SELECT</code> statement could select only one row of the <code class="codeph">employees</code> table, because the <code class="codeph">employee_id</code> column in the <code class="codeph">WHERE</code> clause is the primary key of the table.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-15ABEF01-8919-49FB-9489-7A4E980E8B90">Example of Single-Row Query using SELECT INTO</p>
                  </div>
                  <!-- class="section" -->
                  <p>This section presents the entire <code class="codeph">SimpleExample</code> class from the previous step-by-step sections. Because this is a single-row query, no iterator is required.
                  </p><pre class="oac_no_warn" dir="ltr">// Import SQLJ classes:
import sqlj.runtime.*;
import sqlj.runtime.ref.*;
import oracle.sqlj.runtime.*;

// Import standard java.sql package:
import java.sql.*;

public class SimpleExample {

  public SimpleExample() throws SQLException {
    // Set default connection (as defined in connect.properties).
    Oracle.connect(getClass(), "connect.properties");
  }

  public static void main (String [] args) throws SQLException {
    
    try {
      SimpleExample o1 = new SimpleExample();
      o1.runExample();
    }
    catch (SQLException ex) {
      System.err.println("Error running the example: " + ex);
    }
  }

  finally
  {
     try { Oracle.close(); } catch(SQLException ex) {...}
  }

  void runExample() throws SQLException {
     
     System.out.println( "Running the example--" );
     
     // Declare two Java host variables--
     Float salary;
     String empname;

     // Use SELECT INTO statement to execute query and retrieve values.
        #sql { SELECT first_name, salary INTO :empname, :salary FROM employees
              WHERE employee_id = 7499 };
     
     // Print the results--
     System.out.println("Name is " + empname + ", and Salary is " + salary);
  }
}</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-75E7D96E-C42C-4B74-93F7-A5B2D11AA39D">Set Up a Named Iterator</p>
                  </div>
                  <!-- class="section" -->
                  <p>This example builds on the previous example by adding a named iterator and using it for a multiple-row query.</p>
                  <p>First, declare the iterator class. Use object types <code class="codeph">Integer</code> and <code class="codeph">Float</code>, instead of primitive types <code class="codeph">int</code> and <code class="codeph">float</code>, wherever there is the possibility of <code class="codeph">NULL</code> values.
                  </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpRecs(
      int empno,       // This column cannot be null, so int is OK.
                       // (If null is possible, use Integer.)
      String ename,
      String job,
      Integer mgr,
      Date hiredate,
      Float sal,
      Float comm,
      int deptno);
</pre><p>Next, instantiate the <code class="codeph">EmpRecs</code> class and populate it with query results.
                  </p><pre class="oac_no_warn" dir="ltr">EmpRecs employees;

#sql employees = { SELECT employee_id, first_name, job_id, manager_id, hire_date,
                   salary, commission_pct, department_tno FROM employees };
</pre><p>Then, use the <code class="codeph">next()</code> method of the iterator to print the results.
                  </p><pre class="oac_no_warn" dir="ltr">    while (employees.next())  {
      System.out.println( "Name:       " + employees.first_name() );
      System.out.println( "EMPNO:      " + employees.employee_id() );
      System.out.println( "Job:        " + employees.job_id() );
      System.out.println( "Manager:    " + employees.manager_id) );
      System.out.println( "Date hired: " + employees.hire_date() );
      System.out.println( "Salary:     " + employees.salary() );
      System.out.println( "Commission: " + employees.commission_pct() );
      System.out.println( "Department: " + employees.department_no() );
      System.out.println();
    }
</pre><p>Finally, close the iterator.</p><pre class="oac_no_warn" dir="ltr">employees.close();</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-6A94BA4E-F4C5-4F25-A12A-81C98D74BDF7">Example of Multiple-Row Query Using Named Iterator</p>
                  </div>
                  <!-- class="section" -->
                  <p>This example uses a named iterator for a multiple-row query that selects several columns of data from a table of employees.</p>
                  <p>Apart from use of the named iterator, this example is conceptually similar to the previous single-row query example.</p><pre class="oac_no_warn" dir="ltr">// Import SQLJ classes:
import sqlj.runtime.*;
import sqlj.runtime.ref.*;
import oracle.sqlj.runtime.*;

// Import standard java.sql package:
import java.sql.*;

// Declare a SQLJ iterator.
// Use object types (Integer, Float) for mgr, sal, And comm rather
// than primitive types to allow for possible null selection.

#sql iterator EmpRecs(
      int empno,       // This column cannot be null, so int is OK.
                       // (If null is possible, Integer is required.)
      String ename,
      String job,
      Integer mgr,
      Date hiredate,
      Float sal,
      Float comm,
      int deptno);

// This is the application class.  
public class EmpDemo1App {

   public EmpDemo1App() throws SQLException {
      // Set default connection (as defined in connect.properties).
      Oracle.connect(getClass(), "connect.properties");
   }

  public static void main(String[] args) {

    try {
      EmpDemo1App app = new EmpDemo1App();
      app.runExample();
    }
    catch( SQLException exception ) {
      System.err.println( "Error running the example: " + exception );
    }
  }

  finally
  {
     try { Oracle.close(); } catch(SQLException ex) {...}
  }

  void runExample() throws SQLException  {
    System.out.println("\nRunning the example.\n" );

    // The query creates a new instance of the iterator and stores it in
    // the variable 'employees' of type 'EmpRecs'.  SQLJ translator has
    // automatically declared the iterator so that it has methods for
    // accessing the rows and columns of the result set.

    EmpRecs employees;

    #sql employees = { SELECT employee_id, first_name, job_id, manager_id, hire_date,
                       salary, commission_pct, department_no FROM employees };

    // Print the result using the iterator.

    // Note how the next row is accessed using method 'next()', and how
    // the columns can be accessed with methods that are named after the
    // actual database column names.

    while (employees.next())  {
      System.out.println( "Name:       " + employees.first_name() );
      System.out.println( "EMPNO:      " + employees.employee_id() );
      System.out.println( "Job:        " + employees.job_id() );
      System.out.println( "Manager:    " + employees.manager_id() );
      System.out.println( "Date hired: " + employees.hire_date() );
      System.out.println( "Salary:     " + employees.salary() );
      System.out.println( "Commission: " + employees.commission_pct() );
      System.out.println( "Department: " + employees.department_no() );
      System.out.println();
    }

    // You must close the iterator when it's no longer needed.
    employees.close() ;
  }
}</pre></div>
            </div><a id="JSQLJ241"></a><div class="props_rev_3"><a id="GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD" name="GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD"></a><h3 id="JSQLJ-GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD" class="sect3">Oracle-Specific Code Generation (No Profiles)</h3>
               <div>
                  <p>Throughout this manual there is general and standard discussion of the SQLJ run-time layer and SQLJ profiles. However, the Oracle SQLJ implementation, by default, generates Oracle-specific code with direct calls to Oracle JDBC driver instead of generating ISO SQLJ standard code that calls the SQLJ run time. With Oracle-specific code generation, there are no profile files, and the role of the SQLJ run-time layer is greatly reduced during program execution. Oracle-specific code supports all Oracle-specific extended features.</p>
                  <p>Code generation is determined through the SQLJ translator <code class="codeph">-codegen</code> option. The default setting for Oracle-specific code generation is <code class="codeph">-codegen=oracle</code>. Alternatively, you can set <code class="codeph">-codegen=iso</code> for code generation according to the ISO SQLJ standard.
                  </p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968">Code Considerations and Limitations with Oracle-Specific Code Generation</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-82E999E2-B04C-4182-956F-0FC08B70BE36">SQLJ Usage Changes with Oracle-Specific Code Generation</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-A19B87D2-C37F-43F2-B7B8-00E383441565">Advantages and Disadvantages of Oracle-Specific Code Generation</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ242"></a><div class="props_rev_3"><a id="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9" name="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9"></a><h4 id="JSQLJ-GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9" class="sect4">Environment Requirements for Oracle-Specific Code Generation</h4>
                  <div>
                     <div class="section">
                        <p>Be aware of the following requirements of your environment if you use Oracle-specific code generation: </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must use an Oracle11<span class="italic">g</span> or later version of JDBC driver, because Oracle-specific code generation requires JDBC statement caching functionality.
                              </p>
                           </li>
                           <li>
                              <p>The generic SQLJ run time library, <code class="codeph">runtime</code>, is not supported for Oracle-specific code generation. You must have one of the following Oracle SQLJ run time libraries in the <code class="codeph">CLASSPATH</code>:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">runtime12.jar</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">runtime12ee.jar</code></p>
                                 </li>
                              </ul>
                              <div class="infoboxnotealso" id="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9__GUID-124D88A3-0D60-474F-AD95-640242D669C5">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="getting-started.html#GUID-59D43923-4D2A-42FB-8F03-9CF1F3B60C67">Requirements for Using the Oracle SQLJ Implementation</a>"</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ243"></a><div class="props_rev_3"><a id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968" name="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968"></a><h4 id="JSQLJ-GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968" class="sect4">Code Considerations and Limitations with Oracle-Specific Code Generation</h4>
                  <div>
                     <div class="section">
                        <p>When coding a SQLJ application where Oracle-specific code generation will be used, be aware of the following programming considerations and restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>To use a nondefault statement cache size, you must include appropriate method calls in your code, because Oracle customizer <code class="codeph">stmtcache</code> option is unavailable.
                              </p>
                           </li>
                           <li>
                              <p>Do not mix Oracle-specific generated code with ISO SQLJ standard generated code in the same application. However, if Oracle-specific code and ISO SQLJ standard code <span class="italic">must</span> share the same connection, do one of the following:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Ensure that the Oracle-specific code and ISO standard code use different SQLJ execution context instances. Refer to <span class="q">"<a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">Execution Contexts</a>"</span> for information about SQLJ execution contexts.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Place a transaction boundary, that is, as a manual <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> statement, between the two kinds of code.
                                    </p>
                                 </li>
                              </ul>
                              <p>This limitation regarding mixing code is especially significant for server-side code, because all Java code running in a given session uses the same JDBC connection and SQLJ connection context.</p>
                           </li>
                           <li>
                              <p>Do not rely on side effects in parameter expressions when values are returned from the database. Oracle-specific code generation does not create temporary variables for evaluation of <code class="codeph">OUT</code> parameters, <code class="codeph">IN OUT</code> parameters, <code class="codeph">SELECT INTO</code> variables, or return arguments on SQL statements.
                              </p>
                              <p>For example, avoid statements such as the following:</p><pre class="oac_no_warn" dir="ltr">#sql { SELECT * FROM EMPLOYEES INTO :(x[i++]), :(f_with_sideffect()[i++]),
                              :(a.b[i]) };
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">#sql x[i++] = { VALUES f(:INOUT (x[i++]), :OUT (f_with_sideffect())) };
</pre><p>Evaluation of arguments is performed <span class="italic">in place</span> in the generated code. This may result in different behavior than when evaluation is according to ISO SQLJ standards.
                              </p>
                           </li>
                           <li>
                              <p>Type maps for Oracle object functionality assumes that the corresponding Java classes implement the <code class="codeph">java.sql.SQLData</code> interface. If you use type maps for Oracle object functionality, then your iterator declarations and connection context declarations must specify the same type maps. Specify this through the <code class="codeph">with</code> clause.
                              </p>
                              <p>For example, if you declare a connection context class as follows:</p><pre class="oac_no_warn" dir="ltr">#sql context TypeMapContext with (typeMap="MyTypeMap");
</pre><p>and you populate an iterator instance from a SQLJ statement that uses an instance of this connection context class, as follows:</p><pre class="oac_no_warn" dir="ltr">TypeMapContext tmc = new TypeMapContext(...);
...
MyIterator it;
#sql [tmc] it = ( SELECT pers, addr FROM tab WHERE ...);
</pre><p>then the iterator declaration is required to have specified the same type map, as follows:</p><pre class="oac_no_warn" dir="ltr">#sql iterator MyIterator with (typeMap="MyTypeMap") 
              (Person pers, Address addr);
</pre><div class="infoboxnotealso" id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968__GUID-F99BF9D5-2A70-475B-84DB-C63DCDAD10B4">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D">Custom Java Class Requirements</a>"</span> and <span class="q">"<a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a>"</span></p>
                              </div>
                              <div class="infoboxnote" id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968__GUID-4F738BA6-7E0E-42FA-961B-9F4D5BD1369B">
                                 <p class="notep1">Note:</p>
                                 <p>The reason for this restriction is that with Oracle-specific code generation, all iterator getter methods are fully generated as Oracle JDBC calls during translation. To generate the proper calls, the SQLJ translator must know whether an iterator will be used with a particular type map.</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ244"></a><div class="props_rev_3"><a id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36" name="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36"></a><h4 id="JSQLJ-GUID-82E999E2-B04C-4182-956F-0FC08B70BE36" class="sect4">SQLJ Usage Changes with Oracle-Specific Code Generation</h4>
                  <div>
                     <p>Some options that were previously available only as Oracle customizer options are useful with Oracle-specific code generation as well. Because profile customization is not applicable with Oracle-specific code generation, these options have been made available through other means.</p>
                     <p>To alter the statement cache size or disable statement caching when generating Oracle-specific code, use method calls in your code instead of using the customizer <code class="codeph">stmtcache</code> option. The <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class, as well as any connection context class you declare, now has the following static methods:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">setDefaultStmtCacheSize(int)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">int getDefaultStmtCacheSize()</code></p>
                        </li>
                     </ul>
                     <p>It also has the following instance methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">setStmtCacheSize(int)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">int getStmtCacheSize()</code></p>
                        </li>
                     </ul>
                     <p>By default, statement caching is enabled.</p>
                     <div class="infoboxnotealso" id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36__GUID-3F467AA3-77DC-43CD-A87D-B243929FBA94">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="performance-and-debugging.html#GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A">Statement Caching</a>"</span></p>
                     </div>
                     <p>In addition, the following options are available as front-end Oracle SQLJ translator options as well as Oracle customizer options:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">-optcols</code>: Enable iterator column type and size definitions to optimize performance.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-optparams</code>: Enable parameter size definitions to optimize JDBC resource allocation. This option is used in conjunction with <code class="codeph">optparamdefaults</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-optparamdefaults</code>: Set parameter size defaults for particular data types. This option is used in conjunction with <code class="codeph">optparams</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-fixedchar</code>: Enable <code class="codeph">CHAR</code> comparisons with blank padding for <code class="codeph">WHERE</code> clauses.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36__GUID-21F6BC4A-4E9A-4641-BF04-5968527A9237">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-51E9826F-8FD9-48CD-9423-9DA8CDC10180">Options for Code Generation_ Optimizations_ and CHAR Comparisons</a>"</span></p>
                     </div>
                     <p>Be aware of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use the <code class="codeph">-optcols</code> option only if you are using online semantics-checking, where you have used the SQLJ translator <code class="codeph">-user</code>, <code class="codeph">-password</code>, and <code class="codeph">-url</code> options appropriately to request a database connection during translation.
                           </p>
                        </li>
                        <li>
                           <p>The functionality of the <code class="codeph">-optcols</code>, <code class="codeph">-optparams</code>, and <code class="codeph">-optparamdefaults</code> options, including default values, is the same as for the corresponding customizer options.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ246"></a><div class="props_rev_3"><a id="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565" name="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565"></a><h4 id="JSQLJ-GUID-A19B87D2-C37F-43F2-B7B8-00E383441565" class="sect4">Advantages and Disadvantages of Oracle-Specific Code Generation</h4>
                  <div>
                     <p>Oracle-specific code generation offers following advantages over ISO standard code generation:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Applications run more efficiently. The code calls JDBC application programming interfaces (APIs) directly, placing run-time performance directly at the JDBC level. The role of the intermediate SQLJ run-time layer is greatly reduced during program execution.</p>
                        </li>
                        <li>
                           <p>Applications are smaller in size.</p>
                        </li>
                        <li>
                           <p>No profile files (<code class="codeph">.ser</code>) are produced. This is especially convenient if you are loading a translated application into the database or porting it to another system, because there are fewer components.
                           </p>
                        </li>
                        <li>
                           <p>Translation is faster, because there is no profile customization step.</p>
                        </li>
                        <li>
                           <p>During execution, Oracle SQLJ run time and Oracle JDBC driver use the same statement cache resources, so partitioning resources between the two is unnecessary.</p>
                        </li>
                        <li>
                           <p>Having the SQL-specific information appear in the Java class files instead of in separate profile files avoids potential security issues.</p>
                        </li>
                        <li>
                           <p>You need not have to rewrite your code to take advantage of possible future Oracle JDBC performance enhancements, such as enhancements being considered for execution of static SQL code. Future releases of Oracle SQLJ translator will handle this automatically.</p>
                        </li>
                        <li>
                           <p>The use of Java reflection at run time is eliminated, and thus, provides full portability to browser environments.</p>
                        </li>
                     </ul>
                     <p>However. there are a few disadvantages:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Oracle-specific generated code may not be portable to generic JDBC platforms.</p>
                        </li>
                        <li>
                           <p>Profile-specific functionality is not available. For example, you cannot perform customizations at a later date to use Oracle customizer harness <code class="codeph">-debug</code>, <code class="codeph">-verify</code>, and <code class="codeph">-print</code> options.
                           </p>
                           <div class="infoboxnotealso" id="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565__GUID-F7E19961-18EF-40B9-A52A-82EC868C4A36">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="appendix.html#GUID-C5D50F74-E805-4DDA-AC81-353C94C40A21">Customizer Harness Options for Connections</a>"</span> and <span class="q">"<a href="appendix.html#GUID-B820810A-DDDF-4E42-A3C9-AF04F4DC7075">AuditorInstaller Customizer for Debugging</a>"</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ247"></a><div class="props_rev_3"><a id="GUID-841EEFAD-3954-43D0-A270-679762CFBDED" name="GUID-841EEFAD-3954-43D0-A270-679762CFBDED"></a><h3 id="JSQLJ-GUID-841EEFAD-3954-43D0-A270-679762CFBDED" class="sect3">ISO Standard Code Generation</h3>
               <div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-2381F925-E6BF-4D99-AFED-52542E882ECE">Environment Requirements for ISO Standard Code Generation</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73">SQLJ Translator and SQLJ Run Time</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-41FD26F1-774D-4944-B048-8787AA128B46">SQLJ Profiles</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-C11983AD-9623-45AF-B649-56438BC8B8E0">SQLJ Translation Steps</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93">Summary of Translator Input and Output</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-7E45FD80-5D57-495A-8849-154C8271FCDC">SQLJ Run-Time Processing</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC">Deployment Scenarios</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ248"></a><div class="props_rev_3"><a id="GUID-2381F925-E6BF-4D99-AFED-52542E882ECE" name="GUID-2381F925-E6BF-4D99-AFED-52542E882ECE"></a><h4 id="JSQLJ-GUID-2381F925-E6BF-4D99-AFED-52542E882ECE" class="sect4">Environment Requirements for ISO Standard Code Generation</h4>
                  <div>
                     <p>The Oracle SQLJ implementation, by default, generates Oracle-specific code with direct calls to Oracle JDBC driver instead of generating ISO standard code that calls the SQLJ run time. The following is a typical environment setup for ISO standard code generation:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>SQLJ code generation: <code class="codeph">-codegen=iso</code></p>
                        </li>
                        <li>
                           <p>SQLJ translation library: <code class="codeph">translator.jar</code></p>
                        </li>
                        <li>
                           <p>SQLJ run-time library: <code class="codeph">runtime12.jar</code> with JDK 6 or JDK 7, and Oracle Database 12<span class="italic">c </span>Release 2 (12.2)
                           </p>
                        </li>
                        <li>
                           <p>JDBC drivers: Oracle Database 12<span class="italic">c </span>Release 2 (12.2)<code class="codeph">ojdbc6.jar</code> or <code class="codeph">ojdbc7.jar</code></p>
                        </li>
                        <li>
                           <p>JDK version: JDK 6 or JDK 7</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ249"></a><div class="props_rev_3"><a id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73" name="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73"></a><h4 id="JSQLJ-GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73" class="sect4">SQLJ Translator and SQLJ Run Time</h4>
                  <div>
                     <p>The following section describes the differences in Oracle SQLJ implementation in case of ISO standard code generation:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>SQLJ translator: Along with the <code class="codeph">.java</code> file, the translator also produces one or more SQLJ profiles for ISO standard code generation. These profiles contain information about the embedded SQL operations. SQLJ then automatically invokes a Java compiler to produce <code class="codeph">.class</code> files from the <code class="codeph">.java</code> file.
                           </p>
                           <div class="infoboxnotealso" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-2715F2A6-F467-44CB-AE48-20B3E05177F0">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-BDC15EAD-5848-43A6-8261-19D3BD12C189">SQLJ Translator Functionality</a>"</span></p>
                           </div>
                        </li>
                        <li>
                           <p>SQLJ run time: For ISO standard code generation, the SQLJ run time implements the desired actions of the SQL operations by accessing the database using a JDBC driver. The generic ISO SQLJ standard does not require the SQLJ run time to use a JDBC driver to access the database.</p>
                           <div class="infoboxnotealso" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-EDBD5168-F7BE-4C98-B551-6269B57D6AC9">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-FADAA0D5-A849-4E26-BEFE-47D7073D21B6">SQLJ  Run Time</a>"</span><a href="translator-run-time-functionality.html#GUID-AFF5C519-028E-4554-98E8-B8FF103515D1">SQLJ Run Time</a></p>
                           </div>
                        </li>
                     </ul>
                     <p>In addition to the translator and run time, there is a component known as the <a id="d8416e4168" class="indexterm-anchor"></a><span class="bold">customizer</span> that plays a role. A customizer tailors SQLJ profiles for a particular database implementation and vendor-specific features and data types. By default, for ISO standard code, the SQLJ front end invokes an Oracle customizer to tailor your profiles for Oracle Database instance and Oracle-specific features and data types.
                     </p>
                     <p>When you use Oracle customizer during translation, your application will require the SQLJ run time and an Oracle JDBC driver when it runs.</p>
                     <div class="infoboxnote" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-AE9AB712-4F1F-49C8-9BF0-B783E070CF29">
                        <p class="notep1">Note:</p>
                        <p>Since Oracle Database 10<span class="italic">g</span> Release 1, only Oracle JDBC drivers are supported with SQLJ.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ250"></a><div class="props_rev_3"><a id="GUID-41FD26F1-774D-4944-B048-8787AA128B46" name="GUID-41FD26F1-774D-4944-B048-8787AA128B46"></a><h4 id="JSQLJ-GUID-41FD26F1-774D-4944-B048-8787AA128B46" class="sect4">SQLJ Profiles</h4>
                  <div>
                     <p>With ISO standard code generation, SQLJ profiles are serialized Java resources or classes generated by the SQLJ translator, which contain details about the embedded SQL statements. The translator creates these profiles. Then, depending on the translator option settings, it either serializes the profiles and puts them into binary resource files or puts them into <code class="codeph">.class</code> files.
                     </p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-330EDB33-4131-46B6-9A29-3841364AB613">Overview of Profiles</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-957F54E4-3F66-40CC-A251-50F2A11295EF">Binary Portability</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ251"></a><div class="props_rev_3"><a id="GUID-330EDB33-4131-46B6-9A29-3841364AB613" name="GUID-330EDB33-4131-46B6-9A29-3841364AB613"></a><h5 id="JSQLJ-GUID-330EDB33-4131-46B6-9A29-3841364AB613" class="sect5">Overview of Profiles</h5>
                     <div>
                        <p>SQLJ profiles are used in ISO standard code for implementing the embedded SQL operations in SQLJ executable statements. Profiles contain information about the SQL operations and the types and modes of data being accessed. A profile consists of a collection of entries, where each entry maps to one SQL operation. Each entry fully specifies the corresponding SQL operation, describing each of the parameters used in processing this instruction.</p>
                        <p>SQLJ generates a profile for each connection context class in your application, where each connection context class corresponds to a particular set of SQL entities you use in your database operations. There is one default connection context class, and you can declare additional classes. The ISO SQLJ standard requires that the profiles be of standard format and content. Therefore, for your application to use vendor-specific extended features, your profiles must be customized. By default, this occurs automatically, with your profiles being customized to use Oracle-specific extended features.</p>
                        <p>Profile customization enables vendors to add value in the following ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Vendors can support their own specific data types and SQL syntax. For example, Oracle customizer maps standard JDBC <code class="codeph">PreparedStatement</code> method calls in translated SQLJ code to <code class="codeph">OraclePreparedStatement</code> method calls, which provide support for Oracle type extensions.
                              </p>
                           </li>
                           <li>
                              <p>Vendors can improve performance through specific optimizations.</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-330EDB33-4131-46B6-9A29-3841364AB613__GUID-C5E80838-B6D8-47B9-A0E3-BD7363198355">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>By default, SQLJ profile file names have the <code class="codeph">.ser</code> extension, but this does not mean that all <code class="codeph">.ser</code> files are profiles. Other serialized objects can use this extension, and a SQLJ program unit can use serialized objects other than its profiles. Optionally, profiles can be converted to <code class="codeph">.class</code> files instead of <code class="codeph">.ser</code> files.
                                 </p>
                              </li>
                              <li>
                                 <p>A SQLJ profile is not produced if there are no SQLJ executable statements in the source code.</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="JSQLJ252"></a><div class="props_rev_3"><a id="GUID-957F54E4-3F66-40CC-A251-50F2A11295EF" name="GUID-957F54E4-3F66-40CC-A251-50F2A11295EF"></a><h5 id="JSQLJ-GUID-957F54E4-3F66-40CC-A251-50F2A11295EF" class="sect5">Binary Portability</h5>
                     <div>
                        <p>SQLJ-generated profile files support binary portability. That is, you can port them as is and use them with other kinds of databases or in other environments, if you have not used vendor-specific data types or features. This is true for generated <code class="codeph">.class</code> files as well.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ254"></a><a id="JSQLJ253"></a><div class="props_rev_3"><a id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0" name="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0"></a><h4 id="JSQLJ-GUID-C11983AD-9623-45AF-B649-56438BC8B8E0" class="sect4">SQLJ Translation Steps</h4>
                  <div>
                     <p>For ISO standard code generation (<code class="codeph">-codegen=iso</code>), the translator processes the SQLJ source code, converts SQL operations to SQLJ run-time calls, and generates Java output code and one or more SQLJ profiles. A separate profile is generated for each connection context class in the source code, where a different connection context class is typically used for each interrelated set of SQL entities that is used in the operations.
                     </p>
                     <p>Generated Java code is put into a <code class="codeph">.java</code> output file containing the following:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Any class definitions and Java code from the <code class="codeph">.sqlj</code> source file
                           </p>
                        </li>
                        <li>
                           <p>Class definitions created as a result of the SQLJ iterator and connection context declarations</p>
                           <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-13B25BDB-97D2-4927-9D63-A055AA4065B9">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">Overview of SQLJ Declarations</a>"</span></p>
                           </div>
                        </li>
                        <li>
                           <p>A class definition for a specialized class known as the <a id="d8416e4376" class="indexterm-anchor"></a><span class="bold">profile-keys</span> class that SQLJ generates and uses in conjunction with the profiles (for ISO standard SQLJ code generation only)
                           </p>
                        </li>
                        <li>
                           <p>Calls <span>to the SQLJ run time </span>to implement the actions of the embedded SQL operations
                           </p>
                        </li>
                     </ul>
                     <p>Generated profiles contain information about all the embedded SQL statements in the SQLJ source code, such as actions to take, data types being manipulated, and tables being accessed. When the application is run, the SQLJ run time accesses the profiles to retrieve the SQL operations and passes them to the JDBC driver.</p>
                     <p>By default, profiles are put into <code class="codeph">.ser</code> serialized resource files, but SQLJ can optionally convert the <code class="codeph">.ser</code> files to <code class="codeph">.class</code> files as part of the translation.
                     </p>
                     <p>The compiler compiles the generated Java source file and produces Java <code class="codeph">.class</code> files as appropriate. This includes a <code class="codeph">.class</code> file for each class that is defined, each of the SQLJ declarations, and the profile-keys class. The JVM then invokes Oracle customizer or other specified customizer to customize the profiles generated.
                     </p>
                     <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-4C825FDA-558D-4076-B486-7BFDDEEAFD36">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="translator-run-time-functionality.html#GUID-D48A9F0A-67FD-4B49-B219-7EC6FEE1F4E3">Internal Translator Operations</a>"</span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-791A6B65-5B0D-4816-A844-454E0AE041D0">General SQLJ Notes</p>
                     </div>
                     <!-- class="section" -->
                     <p>Consider the following when translating and running SQLJ applications for ISO specific code generation:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Along with compiling existing <code class="codeph">.java</code> files on the command line and making them available for type resolution, as for Oracle-specific code generation, you need to:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Customize the existing profiles</p>
                              </li>
                              <li>
                                 <p>Customize the Java Archive (JAR) files containing profiles</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-AE5CB55E-F78F-4085-8688-3A85A892F9D2">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-F40E0AE9-4103-4878-B21B-7B0BC275F67C">Translator Command Line and Properties Files</a>"</span></p>
                           </div>
                        </li>
                        <li>
                           <p>SQLJ generates profiles and the profile-keys class only if your source code includes SQLJ executable statements.</p>
                        </li>
                        <li>
                           <p>If you use Oracle customizer during translation, then your application requires Oracle SQLJ run time and an Oracle JDBC driver when it runs, even if your code does not use Oracle-specific features. You can avoid this by specifying <code class="codeph">-profile=false</code> when you translate, to bypass Oracle-specific customization.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ255"></a><div class="props_rev_3"><a id="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93" name="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93"></a><h4 id="JSQLJ-GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93" class="sect4">Summary of Translator Input and Output</h4>
                  <div>
                     <p>We have seen what the SQLJ translator takes as input, what it produces as output, and where it places its output in case of Oracle-specific code generation. This section covers the same topics for ISO standard code generation:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-45B0510B-7684-4001-94D0-03ABAFEAA962">Translator Input</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85">Translator Output</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D">Output File Locations</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93__GUID-828BD0ED-85D7-4126-ADF8-335692DA10F8">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-68C57EA9-1ECC-424A-902C-25C087DB9AA0">Summary of Translator Input and Output</a>"</span></p>
                     </div>
                  </div><a id="JSQLJ256"></a><div class="props_rev_3"><a id="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962" name="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962"></a><h5 id="JSQLJ-GUID-45B0510B-7684-4001-94D0-03ABAFEAA962" class="sect5">Translator Input</h5>
                     <div>
                        <p>Similar to Oracle -specific code generation, the SQLJ translator takes one or more <code class="codeph">.sqlj</code> source files as input, which can be specified on the command line. The name of the main <code class="codeph">.sqlj</code> file is based on the public class it defines, if any, else on the first class it defines.
                        </p>
                        <div class="infoboxnotealso" id="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962__GUID-C728BA11-D297-4CFF-B7F0-6E5F04FDDF57">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-F6F8C7BD-70B8-4C22-B98F-CD44962D3243">Translator Input</a>"</span></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ257"></a><div class="props_rev_3"><a id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85" name="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85"></a><h5 id="JSQLJ-GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85" class="sect5">Translator Output</h5>
                     <div>
                        <p>The translation step produces a Java source file for each <code class="codeph">.sqlj</code> file in the application and at least one application profile for ISO standard code generation, presuming the source code uses SQLJ executable statements.
                        </p>
                        <p>SQLJ generates Java source files and application profiles as follows:</p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-A6EB9074-65B9-4E0F-A4E7-F0E7C216366F">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-AB5D0342-DC8A-4435-8B40-8EE70875DBB3">Translator Output</a>"</span></p>
                        </div>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Similar to Oracle-specific code generation, Java source files are <code class="codeph">.java</code> files with the same base names as the <code class="codeph">.sqlj</code> files.
                              </p>
                           </li>
                           <li>
                              <p>The application profile files, if applicable, contain information about the SQL operations of the SQLJ application. There is one profile for each connection class that is used in the application. The profiles have names with the same base name as the main <code class="codeph">.sqlj</code> file and the following extensions:
                              </p><pre class="oac_no_warn" dir="ltr">_SJProfile0.ser
_SJProfile1.ser
_SJProfile2.ser
...
</pre><p>For example, for <code class="codeph">MyClass.sqlj</code> the translator produces:
                              </p><pre class="oac_no_warn" dir="ltr">MyClass_SJProfile0.ser
</pre><p>The <code class="codeph">.ser</code> file extension indicates that the profiles are serialized. The <code class="codeph">.ser</code> files are binary files.
                              </p>
                              <div class="infoboxnote" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-4B9A5A56-B581-45F6-889C-7CF654FBD511">
                                 <p class="notep1">Note:</p>
                                 <p>The <code class="codeph">-ser2class</code> translator option instructs the translator to generate profiles as <code class="codeph">.class</code> files instead of <code class="codeph">.ser</code> files. Other than the file name extension, the naming is the same.
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>Similar to the compilation step of Oracle-specific code generation, compiling the Java source file into multiple class files generates one <code class="codeph">.class</code> file for each class defined in the <code class="codeph">.sqlj</code> source file. But in case of ISO code generation, a <code class="codeph">.class</code> file is also generated for a class known as the <a id="d8416e4621" class="indexterm-anchor"></a><span class="bold">profile-keys</span> class that the translator generates and uses with the profiles to implement the SQL operations. Additional <code class="codeph">.class</code> files are produced if you declare any SQLJ iterators or connection contexts. Also, like Oracle-specific code generation, separate <code class="codeph">.class</code> files are produced for any inner classes or anonymous classes in the code.
                        </p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-3BB5BBAA-C232-453D-9F84-ADDBE9D80128">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">Overview of SQLJ Declarations</a>"</span></p>
                        </div>
                        <p>The <code class="codeph">.class</code> files are named as follows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p> Like Oracle-specific code generation, the class file for each class defined consists of the name of the class with the <code class="codeph">.class</code> extension.
                              </p>
                           </li>
                           <li>
                              <p>The profile-keys class that the translator generates is named according to the base name of the main <code class="codeph">.sqlj</code> file, plus the following:
                              </p><pre class="oac_no_warn" dir="ltr">_SJProfileKeys
</pre><p>So, the class file has the following extension:</p><pre class="oac_no_warn" dir="ltr">_SJProfileKeys.class
</pre><p>For example, for <code class="codeph">MyClass.sqlj</code>, the translator together with the compiler produces:
                              </p><pre class="oac_no_warn" dir="ltr">MyClass_SJProfileKeys.class
</pre></li>
                           <li>
                              <p>Like Oracle-specific code generation, the translator names iterator classes and connection context classes according to how you declare them.</p>
                           </li>
                        </ul>
                        <p>The customization step alters the profiles but produces no additional output.</p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-9680D6F5-5B44-4294-843B-55B1DF25512E">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="translator-run-time-functionality.html#GUID-1C3E2732-1185-4961-BA6B-5BA97A35EA48">Profile Customization (ISO Code Generation)</a>"</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-24EDEE96-542F-4BA2-882D-4BAEE28753B0">
                           <p class="notep1">Note:</p>
                           <p>It is not necessary to reference SQLJ profiles or the profile-keys class directly. This is all handled automatically.</p>
                        </div>
                     </div>
                  </div><a id="JSQLJ258"></a><div class="props_rev_3"><a id="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D" name="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D"></a><h5 id="JSQLJ-GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D" class="sect5">Output File Locations</h5>
                     <div>
                        <p>The output file locations are the same for both Oracle-specific code generation and ISO standard code generation.</p>
                        <div class="infoboxnotealso" id="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D__GUID-E4F17A1B-CD8B-4B67-A7A2-67789A0DD958">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-88DCEAAC-F9CD-43BD-BC31-CE3F3745FBD7">Output File Locations</a>"</span></p>
                        </div>
                     </div>
                  </div>
               </div><a id="JSQLJ259"></a><div class="props_rev_3"><a id="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC" name="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC"></a><h4 id="JSQLJ-GUID-7E45FD80-5D57-495A-8849-154C8271FCDC" class="sect4">SQLJ Run-Time Processing</h4>
                  <div>
                     <p>This section discusses run-time processing for ISO standard code during program execution.</p>
                     <p>For ISO standard SQLJ applications, the SQLJ run time reads the profiles and creates connected profiles, which incorporate database connections. Then the following occurs each time the application must access the database:</p>
                     <ol>
                        <li>
                           <p>SQLJ-generated application code uses methods in a SQLJ-generated profile-keys class to access the connected profile and read the relevant SQL operations. There is a mapping between SQLJ executable statements in the application and SQL operations in the profile.</p>
                        </li>
                        <li>
                           <p>The SQLJ-generated application code calls the SQLJ run time, which reads the SQL operations from the profile.</p>
                        </li>
                        <li>
                           <p>The SQLJ run time calls the JDBC driver and passes the SQL operations to the driver.</p>
                        </li>
                        <li>
                           <p>The SQLJ run time passes any input parameters to the JDBC driver.</p>
                        </li>
                        <li>
                           <p>The JDBC driver executes the SQL operations.</p>
                        </li>
                        <li>
                           <p>If any data is to be returned, then the database sends it to the JDBC driver, which sends it to the SQLJ run time for use by your application.</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC__GUID-CF10EACA-F8EA-4DD9-8A1B-A0E55C1D1AAD">
                        <p class="notep1">Note:</p>
                        <p>Passing input parameters can also be referred to as binding input parameters or binding host expressions. The terms host variables, host expressions, bind variables, and bind expressions are all used to describe Java variables or expressions that are used as input or output for SQL operations.</p>
                     </div>
                  </div>
               </div><a id="JSQLJ260"></a><div class="props_rev_3"><a id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC" name="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC"></a><h4 id="JSQLJ-GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC" class="sect4">Deployment Scenarios</h4>
                  <div>
                     <p>We have discussed how to run Oracle-specific SQLJ code in the following scenarios:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>From an applet</p>
                        </li>
                        <li>
                           <p>In the server (optionally running the SQLJ translator in the server as well)</p>
                        </li>
                     </ul>
                     <p>There are a few considerations that you need to make while running your ISO standard code from an applet:</p>
                     <div class="infoboxnotealso" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-8F075DE2-C541-4659-A512-62EC3DD7D5F4">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="intro-to-SQLJ.html#GUID-24B99BA3-A097-447B-82F6-E234FFD7B9CA">Alternative Deployment Scenarios</a>"</span></p>
                     </div>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You must package all the SQLJ run-time packages with your applet. The packages are:</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime
sqlj.runtime.ref
sqlj.runtime.profile
sqlj.runtime.profile.ref
sqlj.runtime.error
</pre><p>Also package the following if you used Oracle customization:</p><pre class="oac_no_warn" dir="ltr">oracle.sqlj.runtime
oracle.sqlj.runtime.error
</pre><p>These packages are included with your Oracle installation in one of several run-time libraries in the <span class="italic"><code class="codeph">ORACLE_HOME</code></span><code class="codeph">/lib</code> directory.
                           </p>
                           <div class="infoboxnotealso" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-18822C04-ACAB-4BB2-8710-528B09D7BAA1">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="getting-started.html#GUID-59D43923-4D2A-42FB-8F03-9CF1F3B60C67">Requirements for Using the Oracle SQLJ Implementation</a>"</span></p>
                           </div>
                        </li>
                        <li>
                           <p>Some browsers, such as Netscape Navigator 4.x, do not support resource files with a <code class="codeph">.ser</code> extension, which is the extension used by the SQLJ serialized object files that are used for profiles. However, the Sun Microsystems Java plug-in supports <code class="codeph">.ser</code> files.
                           </p>
                           <p>Alternatively, if you do not want to use the plug-in, then the Oracle SQLJ implementation offers the <code class="codeph">-ser2class</code> option to convert <code class="codeph">.ser</code> files to <code class="codeph">.class</code> files during translation.
                           </p>
                           <div class="infoboxnote" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-E169ECA7-E861-48E4-9B42-550706509E06">
                              <p class="notep1">Note:</p>
                              <p>This consideration <span class="italic">does not</span> apply to the default Oracle-specific code generation, where no profiles are produced.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>Applets using Oracle-specific features require Oracle SQLJ run time to work. Oracle SQLJ run time consists of the classes in the SQLJ run-time library file under <code class="codeph">oracle.sqlj.*</code>. Oracle SQLJ <code class="codeph">runtime.jar</code> library requires the Java Reflection API, <code class="codeph">java.lang.reflect.*</code>. Most browsers do not support the Reflection API or impose security restrictions, but the Sun Microsystems Java plug-in provides support for the Reflection API.
                           </p>
                           <p>With ISO standard code generation, the following SQLJ language features always require the Java Reflection API, regardless of the version of the SQLJ run time you are using:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">CAST</code> statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">REF CURSOR</code> parameters or <code class="codeph">REF CURSOR</code> columns being retrieved from the database as instances of a SQLJ iterator
                                 </p>
                              </li>
                              <li>
                                 <p>Retrieval of <code class="codeph">java.sql.Ref</code>, <code class="codeph">Struct</code>, <code class="codeph">Array</code>, <code class="codeph">Blob</code>, or <code class="codeph">Clob</code> objects
                                 </p>
                              </li>
                              <li>
                                 <p>Retrieval of SQL objects as instances of Java classes implementing the <code class="codeph">oracle.sql.ORAData</code> or <code class="codeph">java.sql.SQLData</code> interfaces
                                 </p>
                                 <div class="infoboxnote" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-B29A307C-3983-4A02-B03D-252D28225339">
                                    <p class="notep1">Note:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>An exception to the preceding is if you use SQLJ in a mode that is fully compatible with ISO. That is, if you use SQLJ in an environment that complies with J2EE and you translate and run your program with the SQLJ <code class="codeph">runtime12ee.jar</code> library, and you employ connection context type maps as specified by ISO. In this case, instances of <code class="codeph">java.sql.Ref</code>, <code class="codeph">Struct</code>, <code class="codeph">Array</code>, <code class="codeph">Blob</code>, <code class="codeph">Clob</code>, and <code class="codeph">SQLData</code> are being retrieved without the use of reflection.
                                          </p>
                                       </li>
                                       <li>
                                          <p>If you use Oracle-specific code generation, then you will eliminate the use of reflection in all of the instances listed.</p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ261"></a><div class="props_rev_3"><a id="GUID-C45C47C7-D321-4162-8287-180A05B36BF3" name="GUID-C45C47C7-D321-4162-8287-180A05B36BF3"></a><h3 id="JSQLJ-GUID-C45C47C7-D321-4162-8287-180A05B36BF3" class="sect3">Oracle-Specific Code Generation Versus ISO Standard Code Generation</h3>
               <div>
                  <p>The Oracle SQLJ implementation provides the option of Oracle-specific code generation, where Oracle JDBC calls are generated directly in the code. This is the default behavior. In the case of Oracle-specific code generation, you must be aware of the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>There are no profile files, and therefore, there is no customization step during translation.</p>
                     </li>
                     <li>
                        <p>At run time, SQL operations do not have to go through the SQLJ run-time layer, because JDBC calls, instead of the SQLJ run-time calls, are directly generated in the translated code.</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JSQLJ262"></a><div class="props_rev_3"><a id="GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A" name="GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A"></a><h3 id="JSQLJ-GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A" class="sect3">Requirements and Restrictions for Naming</h3>
               <div>
                  <div class="section">
                     <p>There are four areas to consider in discussing naming requirements, naming restrictions, and reserved words:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The Java namespace, including additional restrictions imposed by SQLJ on the naming of local variables and classes</p>
                        </li>
                        <li>
                           <p>The SQLJ namespace</p>
                        </li>
                        <li>
                           <p>The SQL namespace</p>
                        </li>
                        <li>
                           <p>Source file names</p>
                        </li>
                     </ul>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF">Java Namespace: Local Variable and Class Naming Restrictions</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D">SQLJ Namespace</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-2F273683-DDBA-4118-9D4B-740148B010CB">SQL Namespace</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805">File Name Requirements and Restrictions</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSQLJ264"></a><a id="JSQLJ265"></a><a id="JSQLJ263"></a><div class="props_rev_3"><a id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF" name="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF"></a><h4 id="JSQLJ-GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF" class="sect4">Java Namespace: Local Variable and Class Naming Restrictions</h4>
                  <div>
                     <p>The Java namespace applies to all standard Java statements and declarations, including the naming of Java classes and local variables. All standard Java naming restrictions apply, and you should avoid the use of Java reserved words.</p>
                     <p>In addition, SQLJ places minor restrictions on the naming of local variables and classes.</p>
                     <div class="infoboxnote" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-36C1CD79-A49F-45DC-ADCB-CBE5B7B85E96">
                        <p class="notep1">Note:</p>
                        <p>Naming restrictions particular to host variables are discussed in <span class="q">"<a href="basic-language-features.html#GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7">Restrictions on Host Expressions</a>"</span>.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-D67AE11F-D7DA-4B94-9027-F64EEA27DA3D">Local Variable Naming Restrictions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Some of the functionality of the SQLJ translator results in minor restrictions in naming local variables. The SQLJ translator replaces each SQLJ executable statement with a statement block, where the SQLJ executable statement is of the standard syntax:</p><pre class="oac_no_warn" dir="ltr">#sql { SQL operation };  
</pre><p>SQLJ may use temporary variable declarations within a generated statement block. The name of any such temporary variables will include the following prefix:</p><pre class="oac_no_warn" dir="ltr"> __sJT_
</pre><div class="infoboxnote" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-BEC66924-FE37-44A2-8A47-9B04D3DCD0B2">
                           <p class="notep1">Note:</p>
                           <p>There are two underscores at the beginning and one at the end.</p>
                        </div>
                        <p>The following declarations are examples of those that might occur in a SQLJ-generated statement block:</p><pre class="oac_no_warn" dir="ltr">int __sJT_index;
Object __sJT_key;
java.sql.PreparedStatement __sJT_stmt;
</pre><p>The string <code class="codeph">__sJT_</code> is a reserved prefix for SQLJ-generated variable names. SQLJ programmers must not use this string as a prefix for the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Names of variables declared in blocks that include executable SQL statements</p>
                           </li>
                           <li>
                              <p>Names of parameters to methods that contain executable SQL statements </p>
                           </li>
                           <li>
                              <p>Names of fields in classes that contain executable SQL statements, or whose subclasses or enclosed classes contain executable SQL statements </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-EC4977A2-DB56-4423-AD86-CD48986A1A10">Class Naming Restrictions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Be aware of the following minor restrictions in naming classes in SQLJ applications:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must not declare class names that may conflict with SQLJ internal classes. In particular, a top-level class cannot have a name of the following form, where <code class="codeph">a</code> is the name of an existing class in the SQLJ application:
                              </p><pre class="oac_no_warn" dir="ltr">a_SJb
</pre><p>where, <code class="codeph">a</code> and <code class="codeph">b</code> are legal Java identifiers.
                              </p>
                              <p>For example, if your application class is <code class="codeph">Foo</code> in file <code class="codeph">Foo.sqlj</code>, then SQLJ generates a profile-keys class called <code class="codeph">Foo_SJProfileKeys</code>. Do not declare a class name that conflicts with this.
                              </p>
                           </li>
                           <li>
                              <p>A class containing SQLJ executable statements must not have a name that is the same as the first component of the name of any package that includes a Java type used in the application. Examples of class names to avoid are <code class="codeph">java</code>, <code class="codeph">sqlj</code>, and <code class="codeph">oracle</code> (case-sensitive). As another example, if your SQLJ statements use host variables whose type is <code class="codeph">abc.def.MyClass</code>, then you cannot use <code class="codeph">abc</code> as the name of the class that uses these host variables.
                              </p>
                              <p>To avoid this restriction, follow Java naming conventions recommending that package names start in lowercase and class names start in uppercase.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ266"></a><div class="props_rev_3"><a id="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D" name="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D"></a><h4 id="JSQLJ-GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D" class="sect4">SQLJ Namespace</h4>
                  <div>
                     <p>The <span class="bold">SQLJ namespace</span> refers to <code class="codeph">#sql</code> class declarations and the portion of <code class="codeph">#sql</code> executable statements outside the curly braces.
                     </p>
                     <div class="infoboxnote" id="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D__GUID-57EEA60E-F96E-4018-B4D0-C9803A13A62E">
                        <p class="notep1">Note:</p>
                        <p>Restrictions particular to the naming of iterator columns are discussed in <span class="q">"<a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">Using Named Iterators</a>"</span>.
                        </p>
                     </div>
                     <p>Avoid using the following SQLJ reserved words as class names for declared connection context classes or iterator classes, in <code class="codeph">with</code> or <code class="codeph">implements</code> clauses, or in iterator column type declaration lists:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">iterator</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">context</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">with</code></p>
                        </li>
                     </ul>
                     <p>For example, do not have an iterator class or instance called <code class="codeph">iterator</code> or a connection context class or instance called <code class="codeph">context</code>.
                     </p>
                     <p>However, note that it is permissible to have a stored function return variable whose name is any of these words.</p>
                  </div>
               </div><a id="JSQLJ267"></a><div class="props_rev_3"><a id="GUID-2F273683-DDBA-4118-9D4B-740148B010CB" name="GUID-2F273683-DDBA-4118-9D4B-740148B010CB"></a><h4 id="JSQLJ-GUID-2F273683-DDBA-4118-9D4B-740148B010CB" class="sect4">SQL Namespace</h4>
                  <div>
                     <p>The <span class="bold">SQL namespace</span> refers to the portion of a SQLJ executable statement inside the curly braces. Standard SQL naming restrictions apply here.
                     </p>
                     <div class="infoboxnotealso" id="GUID-2F273683-DDBA-4118-9D4B-740148B010CB__GUID-D0CF8246-EBCA-480E-8962-2040E88EDBBC">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#SQLRF-GUID-1164C6E0-ABAB-49C2-8821-6B6C5047FEDD" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                     </div>
                     <p>However, note that host expressions follow rules of the Java namespace, not the SQL namespace. This applies to the name of a host variable and to everything between the outer parentheses of a host expression.</p>
                  </div>
               </div><a id="JSQLJ268"></a><div class="props_rev_3"><a id="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805" name="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805"></a><h4 id="JSQLJ-GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805" class="sect4">File Name Requirements and Restrictions</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ source files have the <code class="codeph">.sqlj</code> file name extension. If the source file declares a public class (maximum of one), then the base name of the file must match the name of this class (case-sensitive). If the source file does not declare a public class, then the file name must still be a legal Java identifier, and it is recommended that the file name match the name of the first defined class.
                        </p>
                        <p>For example, if you define the public class <code class="codeph">MySource</code> in your source file, then your file name must be:
                        </p><pre class="oac_no_warn" dir="ltr">MySource.sqlj
</pre><div class="infoboxnote" id="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805__GUID-E4992A85-BFB0-44B4-AAA7-D1A00FA85FB1">
                           <p class="notep1">Note:</p>
                           <p>These file naming requirements follow the Java Language Specification (JLS) and are not SQLJ-specific. These requirements do not directly apply in Oracle Database 12<span class="italic">c </span>Release 2 (12.2), but it is still advisable to adhere to them.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ269"></a><div class="props_rev_3"><a id="GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34" name="GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34"></a><h3 id="JSQLJ-GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34" class="sect3">Considerations for SQLJ in the Middle Tier</h3>
               <div>
                  <div class="section">
                     <p>There are special considerations if you run SQLJ in the middle tier, such as in an Oracle9<span class="italic">i </span>Application Server Containers for J2EE (OC4J) environment.
                     </p>
                     <p>Oracle JDBC drivers provide Oracle-specific interfaces in the <code class="codeph">oracle.jdbc</code> package. The Oracle SQLJ libraries <code class="codeph">runtime12.jar</code> and <code class="codeph">runtime12ee.jar</code> make full use of these interfaces, but these libraries are not compatible with Oracle JDBC implementations prior to Oracle9<span class="italic">i</span> Application Server.
                     </p>
                     <p>In Oracle9<span class="italic">i</span> Application Server, connections are established through data sources, which typically return instances of the <code class="codeph">oracle.jdbc.OracleConnection</code> interface instead of the older <code class="codeph">oracle.jdbc.driver.OracleConnection</code> class. This is necessary for certain connection functionality, such as distributed transactions (XA). To support such features, connection objects must implement the new interface.
                     </p>
                     <p>This has the following consequences, relevant in an Oracle9<span class="italic">i</span> Application Server middle-tier environment, or any situation where data sources are used:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For maximum portability and flexibility of your code, use <code class="codeph">oracle.jdbc.OracleXXX</code> types instead of <code class="codeph">oracle.jdbc.driver.OracleXXX</code> types.
                           </p>
                        </li>
                        <li>
                           <p>For custom Java types (typically for SQL objects and collections), implement <code class="codeph">oracle.sql.ORAData</code>.
                           </p>
                        </li>
                        <li>
                           <p>Do not use the SQLJ <code class="codeph">runtime</code> library. Use <code class="codeph">runtime12</code> or <code class="codeph">runtime12ee</code> instead (depending on your environment). The run time library is backward compatible with older JDBC drivers, such as those in Oracle8<span class="italic">i</span> Database release 8.1.7, so supports the <code class="codeph">oracle.jdbc.driver.OracleXXX</code> types, not the <code class="codeph">oracle.jdbc.OracleXXX</code> types.
                           </p>
                           <p>However, if you must use the <code class="codeph">runtime</code> library for some reason, then set the option <code class="codeph">-profile=false</code> during translation. In this case, your program will not use Oracle-specific customization and, therefore, will not fail if passed an <code class="codeph">oracle.jdbc.OracleConnection</code> instance instead of an <code class="codeph">oracle.jdbc.driver.OracleConnection</code> instance. In this circumstance, Oracle-specific features will <span class="italic">not</span> be supported.
                           </p>
                        </li>
                     </ul>
                     <p>To facilitate management of connections obtained through data sources and connection JavaBeans (for SQLJ JavaServer Pages), the Oracle SQLJ implementation provides a number of APIs in the <code class="codeph">runtime12ee</code> library.
                     </p>
                     <p>For general information about SQLJ support for data sources and connection JavaBeans, refer to the following sections:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">Standard Data Source Support</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75">SQLJ-Specific Data Sources</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-51755815-E5DB-41A3-8427-8969A0B90404">SQLJ-Specific Connection JavaBeans for JavaServer Pages</a>"</span></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>