<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Oracle Dynamic SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="C-Plus-Plus-Applications.html" title="Previous" type="text/html">
      <link rel="next" href="ANSI-dynamic-SQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="C-Plus-Plus-Applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="ANSI-dynamic-SQL.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name"> Applications </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Oracle Dynamic SQL</li>
            </ol>
            <a id="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494" name="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494"></a><a id="LNPCC3991"></a>
            
            <h2 id="LNPCC-GUID-3B9E253A-F03D-431D-A77E-84C02C43F494" class="sect2"><span class="enumeration_chapter">13 </span> Oracle Dynamic SQL
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter shows you how to use Oracle Dynamic SQL, an advanced programming technique that adds flexibility and functionality to your applications. You will learn four methods for writing programs that accept and process SQL statements at run time. This chapter contains the following topics:</p>
               <div class="infoboxnote" id="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494__GUID-4932366D-E9D8-49FD-8490-59E0FB39DC60">
                  <p class="notep1">Note:</p>
                  <p>Oracle Dynamic SQL does not support object types, cursor variables, arrays of structs, DML returning clauses, Unicode variables, and LOBs. Use ANSI Dynamic SQL method 4 instead.</p>
               </div>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2">What is Dynamic SQL?</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-8379C305-7618-4573-BED4-5B1BB6986508">Advantages and Disadvantages of Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64">When to Use Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06">Requirements for Dynamic SQL Statements </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1">How Dynamic SQL Statements are Processed </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD">Methods for Using Dynamic SQL </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-3731826A-5EF8-4839-86FE-0C02E31313CD">Using Method 1 </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2">Using Method 2 </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24">Using Method 3 </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">Using Method 4 </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4">About Using the DECLARE STATEMENT Statement </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89">About Using PL/SQL </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC">Dynamic SQL Statement Caching</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3992"></a><div class="props_rev_3"><a id="GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2" name="GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2"></a><h3 id="LNPCC-GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2" class="sect3"><span class="enumeration_section">13.1 </span>What is Dynamic SQL?
               </h3>
               <div>
                  <p>Most database applications do a specific job. For example, a simple program might prompt the user for an employee number, then update rows in the EMP and DEPT tables. In this case, you know the makeup of the UPDATE statement at precompile time. That is, you know which tables might be changed, the constraints defined for each table and column, which columns might be updated, and the datatype of each column.<a id="d73629e116" class="indexterm-anchor"></a> 
                  </p>
                  <p>However, some applications must accept (or build) and process a variety of SQL statements at run time. For example, a general-purpose report writer must build different SELECT statements for the various reports it generates. In this case, the statement's makeup is unknown until run time. Such statements can, and probably will, change from execution to execution. They are aptly called <span class="italic">dynamic</span> SQL statements.<a id="d73629e126" class="indexterm-anchor"></a> 
                  </p>
                  <p>Unlike static SQL statements, dynamic SQL statements are not embedded in your source program. Instead, they are stored in character strings input to or built by the program at run time. They can be entered interactively or read from a file.<a id="d73629e133" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3993"></a><div class="props_rev_3"><a id="GUID-8379C305-7618-4573-BED4-5B1BB6986508" name="GUID-8379C305-7618-4573-BED4-5B1BB6986508"></a><h3 id="LNPCC-GUID-8379C305-7618-4573-BED4-5B1BB6986508" class="sect3"><span class="enumeration_section">13.2 </span>Advantages and Disadvantages of Dynamic SQL
               </h3>
               <div>
                  <p>Host programs that accept and process dynamically defined SQL statements are more versatile than plain embedded SQL programs. Dynamic SQL statements can be built interactively with input from users having little or no knowledge of SQL.<a id="d73629e162" class="indexterm-anchor"></a> 
                  </p>
                  <p>For example, your program might simply prompt users for a search condition to be used in the WHERE clause of a SELECT, UPDATE, or DELETE statement. A more complex program might allow users to choose from menus listing SQL operations, table and view names, column names, and so on. Thus, dynamic SQL lets you write highly flexible applications.<a id="d73629e169" class="indexterm-anchor"></a> 
                  </p>
                  <p>However, some dynamic queries require complex coding, the use of special data structures, and more runtime processing. While you might not notice the added processing time, you might find the coding difficult unless you fully understand dynamic SQL concepts and methods.</p>
               </div>
            </div><a id="LNPCC3994"></a><div class="props_rev_3"><a id="GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64" name="GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64"></a><h3 id="LNPCC-GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64" class="sect3"><span class="enumeration_section">13.3 </span>When to Use Dynamic SQL
               </h3>
               <div>
                  <p>In practice, static SQL will meet nearly all your programming needs. Use dynamic SQL only if you need its open-ended flexibility. Its use is suggested when one of the following items is unknown at precompile time:<a id="d73629e201" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Text of the SQL statement (commands, clauses, and so on) </p>
                     </li>
                     <li>
                        <p>The number of host variables </p>
                     </li>
                     <li>
                        <p>The datatypes of host variables </p>
                     </li>
                     <li>
                        <p>References to database objects such as columns, indexes, sequences, tables, usernames, and views </p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCC3995"></a><div class="props_rev_3"><a id="GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06" name="GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06"></a><h3 id="LNPCC-GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06" class="sect3"><span class="enumeration_section">13.4 </span>Requirements for Dynamic SQL Statements 
               </h3>
               <div>
                  <p>To represent a dynamic SQL statement, a character string must contain the text of a valid SQL statement, but <span class="italic">not</span> contain the EXEC SQL clause, or the statement terminator, or any of the following embedded SQL commands:<a id="d73629e246" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>ALLOCATE</p>
                     </li>
                     <li>
                        <p>CLOSE </p>
                     </li>
                     <li>
                        <p>DECLARE </p>
                     </li>
                     <li>
                        <p>DESCRIBE </p>
                     </li>
                     <li>
                        <p>EXECUTE </p>
                     </li>
                     <li>
                        <p>FETCH </p>
                     </li>
                     <li>
                        <p>FREE</p>
                     </li>
                     <li>
                        <p>GET</p>
                     </li>
                     <li>
                        <p>INCLUDE </p>
                     </li>
                     <li>
                        <p>OPEN </p>
                     </li>
                     <li>
                        <p>PREPARE </p>
                     </li>
                     <li>
                        <p>SET</p>
                     </li>
                     <li>
                        <p>WHENEVER </p>
                     </li>
                  </ul>
                  <p>In most cases, the character string can contain <span class="italic">dummy</span> host variables. They hold places in the SQL statement for actual host variables. Because dummy host variables are just placeholders, you do not declare them and can name them anything you like. For example, Oracle makes no distinction between the following two strings:<a id="d73629e297" class="indexterm-anchor"></a><a id="d73629e301" class="indexterm-anchor"></a><a id="d73629e305" class="indexterm-anchor"></a><a id="d73629e309" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM EMP WHERE MGR = :mgr_number AND JOB = :job_title' 
'DELETE FROM EMP WHERE MGR = :m AND JOB = :j' </pre></div>
            </div><a id="LNPCC3996"></a><div class="props_rev_3"><a id="GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1" name="GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1"></a><h3 id="LNPCC-GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1" class="sect3"><span class="enumeration_section">13.5 </span>How Dynamic SQL Statements are Processed 
               </h3>
               <div>
                  <p>Typically, an application program prompts the user for the text of a SQL statement and the values of host variables used in the statement. Oracle then parses the SQL statement to ensure it meets syntax rules.</p>
                  <p>Next, Oracle <span class="italic">binds</span> the host variables to the SQL statement. That is, Oracle gets the addresses of the host variables so that it can read or write their values. <a id="d73629e345" class="indexterm-anchor"></a> <a id="d73629e350" class="indexterm-anchor"></a> 
                  </p>
                  <p>Then Oracle <span class="italic">executes</span> the SQL statement. That is, Oracle does what the SQL statement requested, such as deleting rows from a table. 
                  </p>
                  <p>The SQL statement can be executed repeatedly using new values for the host variables.<a id="d73629e362" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3998"></a><a id="LNPCC3997"></a><div class="props_rev_3"><a id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD" name="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD"></a><h3 id="LNPCC-GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD" class="sect3"><span class="enumeration_section">13.6 </span>Methods for Using Dynamic SQL 
               </h3>
               <div>
                  <p>This section introduces four methods you can use to define dynamic SQL statements. It briefly describes the capabilities and limitations of each method, then offers guidelines for choosing the right method. Later sections show you how to use the methods, and include example programs that you can study.<a id="d73629e391" class="indexterm-anchor"></a> 
                  </p>
                  <p>The four methods are increasingly general. That is, Method 2 encompasses Method 1, Method 3 encompasses Methods 1 and 2, and so on. However, each method is most useful for handling a certain kind of SQL statement, as <a href="Oracle-dynamic-SQL.html#GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__CHDGGGEB" title="Methods for Using Dynamic SQL">Table 13-1</a> shows:
                  </p>
                  <div class="tblformal" id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__CHDGGGEB">
                     <p class="titleintable">Table 13-1 Methods for Using Dynamic SQL</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Methods for Using Dynamic SQL" summary="Methods for Using Dynamic SQL" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d73629e413">Method</th>
                              <th align="left" valign="bottom" width="69%" id="d73629e416">Kind of SQL Statement</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e421" headers="d73629e413 ">
                                 <p>1</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e421 d73629e416 ">
                                 <p>non-query without host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e428" headers="d73629e413 ">
                                 <p>2</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e428 d73629e416 ">
                                 <p>non-query with known number of input host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e435" headers="d73629e413 ">
                                 <p>3</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e435 d73629e416 ">
                                 <p>query with known number of select-list items and input host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e442" headers="d73629e413 ">
                                 <p>4</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e442 d73629e416 ">
                                 <p>query with unknown number of select-list items or input host variables</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__GUID-DD2F8328-899F-4F5C-9F71-CCE4CB8A136C">
                     <p class="notep1">Note:</p>
                     <p>The term <span class="italic">select-list item</span> includes column names and expressions such as SAL * 1.10 and MAX(SAL). 
                     </p>
                  </div>
               </div><a id="LNPCC3999"></a><div class="props_rev_3"><a id="GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17" name="GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17"></a><h4 id="LNPCC-GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17" class="sect4"><span class="enumeration_section">13.6.1 </span>Method 1 
                  </h4>
                  <div>
                     <p>This method lets your program accept or build a dynamic SQL statement, then immediately execute it using the EXECUTE IMMEDIATE command. The SQL statement must not be a query (SELECT statement) and must not contain any placeholders for input host variables. For example, the following host strings qualify:<a id="d73629e478" class="indexterm-anchor"></a><a id="d73629e482" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM EMP WHERE DEPTNO = 20' 
'GRANT SELECT ON EMP TO scott' 
</pre><p>With Method 1, the SQL statement is parsed every time it is executed. </p>
                  </div>
               </div><a id="LNPCC4000"></a><div class="props_rev_3"><a id="GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254" name="GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254"></a><h4 id="LNPCC-GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254" class="sect4"><span class="enumeration_section">13.6.2 </span>Method 2 
                  </h4>
                  <div>
                     <p>This method lets your program accept or build a dynamic SQL statement, then process it using the PREPARE and EXECUTE commands. The SQL statement must not be a query. The number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time. For example, the following host strings fall into this category:  <a id="d73629e515" class="indexterm-anchor"></a><a id="d73629e519" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP (ENAME, JOB) VALUES (:emp_name, :job_title)' 
'DELETE FROM EMP WHERE EMPNO = :emp_number' 
</pre><p>With Method 2, the SQL statement is parsed just once, but can be executed many times with different values for the host variables. SQL data definition statements such as CREATE and GRANT are executed when they are PREPAREd.<a id="d73629e528" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4001"></a><div class="props_rev_3"><a id="GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E" name="GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E"></a><h4 id="LNPCC-GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E" class="sect4"><span class="enumeration_section">13.6.3 </span>Method 3 
                  </h4>
                  <div>
                     <p>This method lets your program accept or build a dynamic query, then process it using the PREPARE command with the DECLARE, OPEN, FETCH, and CLOSE cursor commands. The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables must be known at precompile time. For example, the following host strings qualify:<a id="d73629e558" class="indexterm-anchor"></a><a id="d73629e562" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'SELECT DEPTNO, MIN(SAL), MAX(SAL) FROM EMP GROUP BY DEPTNO' 
'SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :dept_number' </pre></div>
               </div><a id="LNPCC4002"></a><div class="props_rev_3"><a id="GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D" name="GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D"></a><h4 id="LNPCC-GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D" class="sect4"><span class="enumeration_section">13.6.4 </span>Method 4 
                  </h4>
                  <div>
                     <p>This method lets your program accept or build a dynamic SQL statement, then process it using descriptors. The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables can be unknown until run time. For example, the following host strings fall into this category:<a id="d73629e593" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP (&lt;unknown&gt;) VALUES (&lt;unknown&gt;)' 
'SELECT &lt;unknown&gt; FROM EMP WHERE DEPTNO = 20'
 </pre><p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or input host variables. </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">Using Method 4</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4003"></a><div class="props_rev_3"><a id="GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638" name="GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638"></a><h4 id="LNPCC-GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638" class="sect4"><span class="enumeration_section">13.6.5 </span>Guidelines 
                  </h4>
                  <div>
                     <p>With all four methods, you must store the dynamic SQL statement in a character string, which must be a host variable or quoted literal. When you store the SQL statement in the string, omit the keywords EXEC SQL and the ';' statement terminator. <a id="d73629e635" class="indexterm-anchor"></a> <a id="d73629e640" class="indexterm-anchor"></a> 
                     </p>
                     <p>With Methods 2 and 3, the number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time. </p>
                     <p>Each succeeding method imposes fewer constraints on your application, but is more difficult to code. As a rule, use the simplest method you can. However, if a dynamic SQL statement will be executed repeatedly by Method 1, use Method 2 instead to avoid reparsing for each execution. </p>
                     <p>Method 4 provides maximum flexibility, but requires complex coding and a full understanding of dynamic SQL concepts. In general, use Method 4 only if you cannot use Methods 1, 2, or 3. </p>
                     <p>The decision logic in <a href="Oracle-dynamic-SQL.html#GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B__I13156">Figure 13-1</a> will help you choose the right method.<a id="d73629e655" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC4005"></a><a id="LNPCC4004"></a><div class="props_rev_3"><a id="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B" name="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B"></a><h5 id="LNPCC-GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B" class="sect5"><span class="enumeration_section">13.6.5.1 </span>About Avoiding Common Errors 
                     </h5>
                     <div>
                        <p>If you precompile using the command-line option DBMS=V6_CHAR, blank-pad the array before storing the SQL statement. That way, you clear extraneous characters. This is especially important when you reuse the array for different SQL statements. As a rule, always initialize (or re-initialize) the host string before storing the SQL statement. Do <span class="italic">not</span> null-terminate the host string. Oracle does not recognize the null terminator as an end-of-string sentinel. Instead, Oracle treats it as part of the SQL statement. 
                        </p>
                        <p>If you precompile with the command-line option DBMS=V8, make sure that the string is null terminated before you execute the PREPARE or EXECUTE IMMEDIATE statement.</p>
                        <p>Regardless of the value of DBMS, if you use a VARCHAR variable to store the dynamic SQL statement, make sure the length of the VARCHAR is set (or reset) correctly before you execute the PREPARE or EXECUTE IMMEDIATE statement.</p>
                        <div class="figure" id="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B__I13156">
                           <p class="titleinfigure">Figure 13-1  Choosing the Right Method</p><img src="img/lnpcc009.gif" width="496" alt="Description of Figure 13-1 follows" title="Description of Figure 13-1 follows" longdesc="img_text/lnpcc009.html"><br><a href="img_text/lnpcc009.html">Description of "Figure 13-1  Choosing the Right Method"</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4006"></a><div class="props_rev_3"><a id="GUID-3731826A-5EF8-4839-86FE-0C02E31313CD" name="GUID-3731826A-5EF8-4839-86FE-0C02E31313CD"></a><h3 id="LNPCC-GUID-3731826A-5EF8-4839-86FE-0C02E31313CD" class="sect3"><span class="enumeration_section">13.7 </span>Using Method 1 
               </h3>
               <div>
                  <div class="section">
                     <p>The simplest kind of dynamic SQL statement results only in "success" or "failure" and uses no host variables. Some examples follow:<a id="d73629e722" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM table_name WHERE column_name = constant' 
'CREATE TABLE table_name ...' 
'DROP INDEX index_name' 
'UPDATE table_name SET column_name = constant' 
'GRANT SELECT ON table_name TO username' 
'REVOKE RESOURCE FROM username' 
</pre><p>Method 1 parses, then immediately executes the SQL statement using the EXECUTE IMMEDIATE command. The command is followed by a character string (host variable or literal) containing the SQL statement to be executed, which cannot be a query. </p>
                     <p>The syntax of the EXECUTE IMMEDIATE statement follows:<a id="d73629e733" class="indexterm-anchor"></a><a id="d73629e737" class="indexterm-anchor"></a><a id="d73629e741" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE { :host_string | string_literal }; 
</pre><p>In the following example, you use the host variable <span class="italic">dyn_stmt</span> to store SQL statements input by the user: 
                     </p><pre class="oac_no_warn" dir="ltr">char dyn_stmt[132]; 
... 
for (;;) 
{ 
    printf("Enter SQL statement: "); 
    gets(dyn_stmt); 
    if (*dyn_stmt == '\0') 
        break; 
    /* dyn_stmt now contains the text of a SQL statement */ 
    EXEC SQL EXECUTE IMMEDIATE :dyn_stmt; 
} 
... 
</pre><p>You can also use string literals, as the following example shows: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE 'REVOKE RESOURCE FROM MILLER'; 
</pre><p>Because EXECUTE IMMEDIATE parses the input SQL statement before every execution, Method 1 is best for statements that are executed only once. Data definition language statements usually fall into this category. </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4007"></a><div class="props_rev_3"><a id="GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62" name="GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62"></a><h4 id="LNPCC-GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62" class="sect4"><span class="enumeration_section">13.7.1 </span>Example Program: Dynamic SQL Method 1
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following program uses dynamic SQL Method 1 to create a table, insert a row, commit the insert, then drop the table. This program is available on-line in your demo directory in the file <code class="codeph">sample6.pc</code>.<a id="d73629e789" class="indexterm-anchor"></a><a id="d73629e793" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">
/*
 *  sample6.pc: Dynamic SQL Method 1
 *
 *  This program uses dynamic SQL Method 1 to create a table,
 *  insert a row, commit the insert, then drop the table.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* Include the SQL Communications Area, a structure through
 * which ORACLE makes runtime status information such as error
 * codes, warning flags, and diagnostic text available to the
 * program.
 */
#include &lt;sqlca.h&gt;

/* Include the ORACLE Communications Area, a structure through
 * which ORACLE makes additional runtime status information
 * available to the program.
 */
#include &lt;oraca.h&gt;

/* The ORACA=YES option must be specified to enable you
 * to use the ORACA.
 */

EXEC ORACLE OPTION (ORACA=YES);

/* Specifying the RELEASE_CURSOR=YES option instructs Pro*C
 * to release resources associated with embedded SQL
 * statements after they are executed.  This ensures that
 * ORACLE does not keep parse locks on tables after data
 * manipulation operations, so that subsequent data definition
 * operations on those tables do not result in a parse-lock
 * error.
 */

EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

void dyn_error();


main()
{
/* Declare the program host variables. */
    char    *username = "SCOTT";
    char    *password = "TIGER";
    char    *dynstmt1;
    char     dynstmt2[10];
    VARCHAR  dynstmt3[80];

/* Call routine dyn_error() if an ORACLE error occurs. */

    EXEC SQL WHENEVER SQLERROR DO dyn_error("Oracle error:");

/* Save text of current SQL statement in the ORACA if an
 * error occurs.
 */
    oraca.orastxtf = ORASTFERR;

/* Connect to Oracle. */

    EXEC SQL CONNECT :username IDENTIFIED BY :password;
    puts("\nConnected to ORACLE.\n");

/* Execute a string literal to create the table.  This
 * usage is actually not dynamic because the program does
 * not determine the SQL statement at run time.
 */
    puts("CREATE TABLE dyn1 (col1 VARCHAR2(4))");

    EXEC SQL EXECUTE IMMEDIATE
         "CREATE TABLE dyn1 (col1 VARCHAR2(4))";

/* Execute a string to insert a row.  The string must
 * be null-terminated.  This usage is dynamic because the
 * SQL statement is a string variable whose contents the
 * program can determine at run time.
 */
    dynstmt1 = "INSERT INTO DYN1 values ('TEST')";
    puts(dynstmt1);

    EXEC SQL EXECUTE IMMEDIATE :dynstmt1;

/* Execute a SQL statement in a string to commit the insert.
 * Pad the unused trailing portion of the array with spaces.
 * Do NOT null-terminate it.
 */
    strncpy(dynstmt2, "COMMIT    ", 10);
    printf("%.10s\n", dynstmt2);

    EXEC SQL EXECUTE IMMEDIATE :dynstmt2;

/* Execute a VARCHAR to drop the table.  Set the .len field
 * to the length of the .arr field.
 */
    strcpy(dynstmt3.arr, "DROP TABLE DYN1");
    dynstmt3.len = strlen(dynstmt3.arr);
    puts((char *) dynstmt3.arr);

    EXEC SQL EXECUTE IMMEDIATE :dynstmt3;

/* Commit any outstanding changes and disconnect from Oracle. */
    EXEC SQL COMMIT RELEASE;

    puts("\nHave a good day!\n");

    return 0;
}


void
dyn_error(msg)
char *msg;
{
/* This is the Oracle error handler.
 * Print diagnostic text containing the error message,
 * current SQL statement, and location of error.
 */
    printf("\n%.*s\n",
       sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
    printf("in \"%.*s...\'\n",
        oraca.orastxt.orastxtl, oraca.orastxt.orastxtc);
    printf("on line %d of %.*s.\n\n",
        oraca.oraslnr, oraca.orasfnm.orasfnml,
        oraca.orasfnm.orasfnmc);

/* Disable Oracle error checking to avoid an infinite loop
 * should another error occur within this routine as a 
 * result of the rollback.
 */
    EXEC SQL WHENEVER SQLERROR CONTINUE;

/* Roll back any pending changes and disconnect from Oracle. */
    EXEC SQL ROLLBACK RELEASE;

    exit(1);
}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4008"></a><div class="props_rev_3"><a id="GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2" name="GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2"></a><h3 id="LNPCC-GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2" class="sect3"><span class="enumeration_section">13.8 </span>Using Method 2 
               </h3>
               <div>
                  <div class="section">
                     <p>What Method 1 does in one step, Method 2 does in two. The dynamic SQL statement, which cannot be a query, is first PREPAREd (named and parsed), then EXECUTEd. </p>
                     <p>With Method 2, the SQL statement can contain placeholders for input host variables and indicator variables. You can PREPARE the SQL statement once, then EXECUTE it repeatedly using different values of the host variables. Furthermore, you need <span class="italic">not</span> rePREPARE the SQL statement after a COMMIT or ROLLBACK (unless you log off and reconnect).<a id="d73629e830" class="indexterm-anchor"></a><a id="d73629e834" class="indexterm-anchor"></a><a id="d73629e838" class="indexterm-anchor"></a><a id="d73629e842" class="indexterm-anchor"></a><a id="d73629e846" class="indexterm-anchor"></a> 
                     </p>
                     <p>You can use EXECUTE for non-queries with Method 4. </p>
                     <p>The syntax of the PREPARE statement follows: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name 
    FROM { :host_string | string_literal }; 
</pre><p>PREPARE parses the SQL statement and gives it a name. </p>
                     <p>The <span class="italic">statement_name</span> is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be declared in the Declare Section. It simply designates the PREPAREd statement you want to EXECUTE. 
                     </p>
                     <p>The syntax of the EXECUTE statement is </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name [USING host_variable_list];
 </pre><p>where <span class="italic">host_variable_list</span> stands for the following syntax: 
                     </p><pre class="oac_no_warn" dir="ltr">:host_variable1[:indicator1] [, host_variable2[:indicator2], ...] 
</pre><p>EXECUTE executes the parsed SQL statement, using the values supplied for each input host variable. </p>
                     <p>In the following example, the input SQL statement contains the placeholder <span class="italic">n</span>: 
                     </p><pre class="oac_no_warn" dir="ltr">... 
int emp_number    INTEGER; 
char delete_stmt[120], search_cond[40];; 
... 
strcpy(delete_stmt, "DELETE FROM EMP WHERE EMPNO = :n AND "); 
printf("Complete the following statement's search condition--\n"); 
printf("%s\n", delete_stmt); 
gets(search_cond); 
strcat(delete_stmt, search_cond); 
 
EXEC SQL PREPARE sql_stmt FROM :delete_stmt; 
for (;;) 
{ 

    printf("Enter employee number: "); 
    gets(temp);
    emp_number = atoi(temp); 
    if (emp_number == 0) 
        break; 
    EXEC SQL EXECUTE sql_stmt USING :emp_number; 
} 
... 
</pre><p>With Method 2, you must know the datatypes of input host variables at precompile time. In the last example, <span class="italic">emp_number</span> was declared as an <span class="bold">int</span>. It could also have been declared as type <span class="bold">float</span>, or even a <span class="bold">char</span>, because Oracle supports all these datatype conversions to the internal Oracle NUMBER datatype. 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4009"></a><div class="props_rev_3"><a id="GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD" name="GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD"></a><h4 id="LNPCC-GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD" class="sect4"><span class="enumeration_section">13.8.1 </span>The USING Clause 
                  </h4>
                  <div>
                     <p>When the SQL statement is EXECUTEd, input host variables in the USING clause replace corresponding placeholders in the PREPAREd dynamic SQL statement.<a id="d73629e926" class="indexterm-anchor"></a><a id="d73629e930" class="indexterm-anchor"></a> 
                     </p>
                     <p>Every placeholder in the PREPAREd dynamic SQL statement must correspond to a different host variable in the USING clause. So, if the same placeholder appears two or more times in the PREPAREd statement, each appearance must correspond to a host variable in the USING clause.<a id="d73629e937" class="indexterm-anchor"></a> 
                     </p>
                     <p>The names of the placeholders need not match the names of the host variables. However, the order of the placeholders in the PREPAREd dynamic SQL statement must match the order of corresponding host variables in the USING clause. <a id="d73629e944" class="indexterm-anchor"></a> <a id="d73629e949" class="indexterm-anchor"></a> 
                     </p>
                     <p>If one of the host variables in the USING clause is an array, all must be arrays. </p>
                     <p>To specify NULLs, you can associate indicator variables with host variables in the USING clause. </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C">Indicator Variables</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4010"></a><div class="props_rev_3"><a id="GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5" name="GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5"></a><h4 id="LNPCC-GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5" class="sect4"><span class="enumeration_section">13.8.2 </span>Example Program: Dynamic SQL Method 2
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following program uses dynamic SQL Method 2 to insert two rows into the EMP table, then delete them. This program is available on-line in your demo directory, in the file <code class="codeph">sample7.pc</code>.<a id="d73629e995" class="indexterm-anchor"></a><a id="d73629e999" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">/*
 *  sample7.pc: Dynamic SQL Method 2
 *
 *  This program uses dynamic SQL Method 2 to insert two rows into
 *  the EMP table, then delete them.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define USERNAME "SCOTT"
#define PASSWORD "TIGER"

/* Include the SQL Communications Area, a structure through
 * which ORACLE makes runtime status information such as error
 * codes, warning flags, and diagnostic text available to the
 * program.
 */
#include &lt;sqlca.h&gt;

/* Include the ORACLE Communications Area, a structure through
 * which ORACLE makes additional runtime status information
 * available to the program.
 */
#include &lt;oraca.h&gt;

/* The ORACA=YES option must be specified to enable use of
 * the ORACA.
 */
EXEC ORACLE OPTION (ORACA=YES);

char    *username = USERNAME;
char    *password = PASSWORD;
VARCHAR  dynstmt[80];
int      empno   = 1234;
int      deptno1 = 97;
int      deptno2 = 99;


/* Handle SQL runtime errors. */
void dyn_error();


main()
{
/* Call dyn_error() whenever an error occurs
 * processing an embedded SQL statement.
 */
    EXEC SQL WHENEVER SQLERROR DO dyn_error("Oracle error");

/* Save text of current SQL statement in the ORACA if an
 * error occurs.
 */
    oraca.orastxtf = ORASTFERR;

/* Connect to Oracle. */

    EXEC SQL CONNECT :username IDENTIFIED BY :password;
    puts("\nConnected to Oracle.\n");

/* Assign a SQL statement to the VARCHAR dynstmt.  Both
 * the array and the length parts must be set properly.
 * Note that the statement contains two host-variable
 * placeholders, v1 and v2, for which actual input
 * host variables must be supplied at EXECUTE time.
 */
    strcpy(dynstmt.arr,
        "INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:v1, :v2)");
    dynstmt.len = strlen(dynstmt.arr);

/* Display the SQL statement and its current input host
 * variables.
 */
    puts((char *) dynstmt.arr);
    printf("   v1 = %d,  v2 = %d\n", empno, deptno1);

/* The PREPARE statement associates a statement name with
 * a string containing a SQL statement.  The statement name
 * is a SQL identifier, not a host variable, and therefore
 * does not appear in the Declare Section.

 * A single statement name can be PREPAREd more than once,
 * optionally FROM a different string variable.
 */
    EXEC SQL PREPARE S FROM :dynstmt;

/* The EXECUTE statement executes a PREPAREd SQL statement
 * USING the specified input host variables, which are
 * substituted positionally for placeholders in the
 * PREPAREd statement.  For each occurrence of a
 * placeholder in the statement there must be a variable
 * in the USING clause.  That is, if a placeholder occurs
 * multiple times in the statement, the corresponding
 * variable must appear multiple times in the USING clause.
 * The USING clause can be omitted only if the statement
 * contains no placeholders.
 *
 * A single PREPAREd statement can be EXECUTEd more
 * than once, optionally USING different input host
 * variables.
 */
    EXEC SQL EXECUTE S USING :empno, :deptno1;

/* Increment empno and display new input host variables. */

    empno++;
    printf("   v1 = %d,  v2 = %d\n", empno, deptno2);

/* ReEXECUTE S to insert the new value of empno and a
 * different input host variable, deptno2.
 * A rePREPARE is unnecessary.
 */
    EXEC SQL EXECUTE S USING :empno, :deptno2;

/* Assign a new value to dynstmt. */

    strcpy(dynstmt.arr,
        "DELETE FROM EMP WHERE DEPTNO = :v1 OR DEPTNO = :v2");
    dynstmt.len = strlen(dynstmt.arr);

/* Display the new SQL statement and its current input host
 * variables.
 */
    puts((char *) dynstmt.arr);
    printf("   v1 = %d,    v2 = %d\n", deptno1, deptno2);

/* RePREPARE S FROM the new dynstmt. */

    EXEC SQL PREPARE S FROM :dynstmt;

/* EXECUTE the new S to delete the two rows previously
 * inserted.
 */
    EXEC SQL EXECUTE S USING :deptno1, :deptno2;

/* Commit any pending changes and disconnect from Oracle. */

    EXEC SQL COMMIT RELEASE;
    puts("\nHave a good day!\n");
    exit(0);
}


void 
dyn_error(msg)
char *msg;
{
/* This is the ORACLE error handler.
 * Print diagnostic text containing error message,
 * current SQL statement, and location of error.
 */
    printf("\n%s", msg);
    printf("\n%.*s\n",
        sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
    printf("in \"%.*s...\"\n",
        oraca.orastxt.orastxtl, oraca.orastxt.orastxtc);
    printf("on line %d of %.*s.\n\n",
        oraca.oraslnr, oraca.orasfnm.orasfnml,
        oraca.orasfnm.orasfnmc);

/* Disable ORACLE error checking to avoid an infinite loop
 * should another error occur within this routine.
 */
    EXEC SQL WHENEVER SQLERROR CONTINUE;

/* Roll back any pending changes and 
 * disconnect from Oracle.
 */
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4011"></a><div class="props_rev_3"><a id="GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24" name="GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24"></a><h3 id="LNPCC-GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24" class="sect3"><span class="enumeration_section">13.9 </span>Using Method 3 
               </h3>
               <div>
                  <div class="section">
                     <p>Method 3 is similar to Method 2 but combines the PREPARE statement with the statements needed to define and manipulate a cursor. This allows your program to accept and process queries. In fact, if the dynamic SQL statement is a query, you <span class="italic">must</span> use Method 3 or 4.<a id="d73629e1035" class="indexterm-anchor"></a> 
                     </p>
                     <p>For Method 3, the number of columns in the query select list and the number of placeholders for input host variables must be known at precompile time. However, the names of database objects such as tables and columns need not be specified until run time. Names of database objects cannot be host variables. Clauses that limit, group, and sort query results (such as WHERE, GROUP BY, and ORDER BY) can also be specified at run time. </p>
                     <p>With Method 3, you use the following sequence of embedded SQL statements:<a id="d73629e1044" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM { :host_string | string_literal }; 
DECLARE cursor_name CURSOR FOR statement_name; 
OPEN cursor_name [USING host_variable_list]; 
FETCH cursor_name INTO host_variable_list; 
CLOSE cursor_name; 
</pre><p>Scrollable Cursors can also be used with Method 3. The following sequence of embedded SQL statements must be used for scrollable cursors.</p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM { :host_string | string_literal }; 
DECLARE  cursor_name  SCROLL CURSOR FOR statement_name; 
OPEN cursor_name [USING host_variable_list]; 
FETCH  [ FIRST| PRIOR|NEXT|LAST|CURRENT | RELATIVE fetch_offset 
               |ABSOLUTE fetch_offset ]  cursor_name INTO host_variable_list; 
CLOSE cursor_name;
</pre><p>Now we look at what each statement does. </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4012"></a><div class="props_rev_3"><a id="GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE" name="GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE"></a><h4 id="LNPCC-GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE" class="sect4"><span class="enumeration_section">13.9.1 </span>PREPARE (Dynamic SQL)
                  </h4>
                  <div>
                     <p>PREPARE parses the dynamic SQL statement and gives it a name. In the following example, PREPARE parses the query stored in the character string <span class="italic">select_stmt</span> and gives it the name <span class="italic">sql_stmt</span>:<a id="d73629e1087" class="indexterm-anchor"></a><a id="d73629e1091" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">char select_stmt[132] =
     "SELECT MGR, JOB FROM EMP WHERE SAL &lt; :salary"; 
EXEC SQL PREPARE sql_stmt FROM :select_stmt; 
</pre><p>Commonly, the query WHERE clause is input from a terminal at run time or is generated by the application. </p>
                     <p>The identifier <span class="italic">sql_stmt</span> is <span class="italic">not</span> a host or program variable, but must be unique. It designates a particular dynamic SQL statement. 
                     </p>
                     <p>The following statement is correct also:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM SELECT MGR, JOB FROM EMP WHERE SAL &lt; :salary;
</pre><p>The following prepare statement, which uses the '%' wildcard, is correct also:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE S FROM select ename FROM test WHERE ename LIKE 'SMIT%';</pre></div>
               </div><a id="LNPCC4013"></a><div class="props_rev_3"><a id="GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0" name="GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0"></a><h4 id="LNPCC-GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0" class="sect4"><span class="enumeration_section">13.9.2 </span>DECLARE (Dynamic SQL)
                  </h4>
                  <div>
                     <p>DECLARE defines a cursor by giving it a name and associating it with a specific query. Continuing our example, DECLARE defines a cursor named <span class="italic">emp_cursor</span> and associates it with <span class="italic">sql_stmt</span>, as follows: <a id="d73629e1146" class="indexterm-anchor"></a> <a id="d73629e1151" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt; 
</pre><p>The identifiers <span class="italic">sql_stmt</span> and <span class="italic">emp_cursor</span> are <span class="italic">not</span> host or program variables, but must be unique. If you declare two cursors using the same statement name, the precompiler considers the two cursor names synonymous. 
                     </p>
                     <p>We can define a scrollable cursor named emp_cursor and associate it with sql_stmt as follows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor SCROLL CURSOR FOR sql_stmt;</pre><p></p>
                     <p>For example, if you execute the statements </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM :select_stmt; 
EXEC SQL DECLARE emp_cursor FOR sql_stmt; 
EXEC SQL PREPARE sql_stmt FROM :delete_stmt; 
EXEC SQL DECLARE dept_cursor FOR sql_stmt; 
</pre><p>when you OPEN <span class="italic">emp_cursor</span>, you will process the dynamic SQL statement stored in <span class="italic">delete_stmt</span>, not the one stored in <span class="italic">select_stmt.</span> 
                     </p>
                  </div>
               </div><a id="LNPCC4014"></a><div class="props_rev_3"><a id="GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20" name="GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20"></a><h4 id="LNPCC-GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20" class="sect4"><span class="enumeration_section">13.9.3 </span>OPEN (Dynamic SQL)
                  </h4>
                  <div>
                     <p>OPEN allocates an Oracle cursor, binds input host variables, and executes the query, identifying its active set. OPEN also positions the cursor on the first row in the active set and zeroes the rows-processed count kept by the third element of <span class="italic">sqlerrd</span> in the SQLCA. Input host variables in the USING clause replace corresponding placeholders in the PREPAREd dynamic SQL statement. <a id="d73629e1217" class="indexterm-anchor"></a> <a id="d73629e1222" class="indexterm-anchor"></a> 
                     </p>
                     <p>In our example, OPEN allocates <span class="italic">emp_cursor</span> and assigns the host variable <span class="italic">salary</span> to the WHERE clause, as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor USING :salary; </pre></div>
               </div><a id="LNPCC4015"></a><div class="props_rev_3"><a id="GUID-9B7A9994-EA3E-466F-A643-5D310D97D556" name="GUID-9B7A9994-EA3E-466F-A643-5D310D97D556"></a><h4 id="LNPCC-GUID-9B7A9994-EA3E-466F-A643-5D310D97D556" class="sect4"><span class="enumeration_section">13.9.4 </span>FETCH (Dynamic SQL)
                  </h4>
                  <div>
                     <p>FETCH returns a row from the active set, assigns column values in the select list to corresponding host variables in the INTO clause, and advances the cursor to the next row. If there are no more rows, FETCH returns the "no data found" Oracle error code to <span class="italic">sqlca.sqlcode</span>. <a id="d73629e1264" class="indexterm-anchor"></a> <a id="d73629e1269" class="indexterm-anchor"></a> 
                     </p>
                     <p>In our example, FETCH returns a row from the active set and assigns the values of columns MGR and JOB to host variables <span class="italic">mgr_number</span> and <span class="italic">job_title</span>, as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO :mgr_number, :job_title; 
</pre><p>If the cursor is declared in SCROLL mode, you can then use the various FETCH orientation modes to randomly access the result set.</p>
                  </div>
               </div><a id="LNPCC4016"></a><div class="props_rev_3"><a id="GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574" name="GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574"></a><h4 id="LNPCC-GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574" class="sect4"><span class="enumeration_section">13.9.5 </span>CLOSE (Dynamic SQL)
                  </h4>
                  <div>
                     <p>CLOSE disables the cursor. Once you CLOSE a cursor, you can no longer FETCH from it. </p>
                     <p>In our example, CLOSE disables <span class="italic">emp_cursor</span>, as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor; </pre></div>
               </div><a id="LNPCC4017"></a><div class="props_rev_3"><a id="GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5" name="GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5"></a><h4 id="LNPCC-GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5" class="sect4"><span class="enumeration_section">13.9.6 </span>Example Program: Dynamic SQL Method 3
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following program uses dynamic SQL Method 3 to retrieve the names of all employees in a given department from the EMP table. This program is available on-line in your demo directory, in the file <code class="codeph">sample8.pc </code> <a id="d73629e1346" class="indexterm-anchor"></a><a id="d73629e1350" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">
/*
 *  sample8.pc:  Dynamic SQL Method 3
 *
 *  This program uses dynamic SQL Method 3 to retrieve the names
 *  of all employees in a given department from the EMP table.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define USERNAME "SCOTT"
#define PASSWORD "TIGER"

/* Include the SQL Communications Area, a structure through
 * which ORACLE makes runtime status information such as error
 * codes, warning flags, and diagnostic text available to the
 * program. Also include the ORACA.
 */
#include &lt;sqlca.h&gt;
#include &lt;oraca.h&gt;

/* The ORACA=YES option must be specified to enable use of
 * the ORACA.
 */
EXEC ORACLE OPTION (ORACA=YES);

char    *username = USERNAME;
char    *password = PASSWORD;
VARCHAR  dynstmt[80];
VARCHAR  ename[10];
int      deptno = 10;

void dyn_error();


main()
{
/* Call dyn_error() function on any error in
 * an embedded SQL statement.
 */
    EXEC SQL WHENEVER SQLERROR DO dyn_error("Oracle error");

/* Save text of SQL current statement in the ORACA if an
 * error occurs.
 */
    oraca.orastxtf = ORASTFERR;

/* Connect to Oracle. */

    EXEC SQL CONNECT :username IDENTIFIED BY :password;
    puts("\nConnected to Oracle.\n");

/* Assign a SQL query to the VARCHAR dynstmt.  Both the
 * array and the length parts must be set properly.  Note
 * that the query contains one host-variable placeholder,
 * v1, for which an actual input host variable must be
 * supplied at OPEN time.
 */
    strcpy(dynstmt.arr,
        "SELECT ename FROM emp WHERE deptno = :v1");
    dynstmt.len = strlen(dynstmt.arr);

/* Display the SQL statement and its current input host
 * variable.
 */
    puts((char *) dynstmt.arr);
    printf("   v1 = %d\n", deptno);
    printf("\nEmployee\n");
    printf("--------\n");

/* The PREPARE statement associates a statement name with
 * a string containing a SELECT statement.  The statement
 * name is a SQL identifier, not a host variable, and
 * therefore does not appear in the Declare Section.

 * A single statement name can be PREPAREd more than once,
 * optionally FROM a different string variable.
 */
    EXEC SQL PREPARE S FROM :dynstmt;

/* The DECLARE statement associates a cursor with a
 * PREPAREd statement.  The cursor name, like the statement
 * name, does not appear in the Declare Section.

 * A single cursor name cannot be DECLAREd more than once.
 */
    EXEC SQL DECLARE C CURSOR FOR S;

/* The OPEN statement evaluates the active set of the
 * PREPAREd query USING the specified input host variables,
 * which are substituted positionally for placeholders in
 * the PREPAREd query.  For each occurrence of a
 * placeholder in the statement there must be a variable
 * in the USING clause.  That is, if a placeholder occurs
 * multiple times in the statement, the corresponding
 * variable must appear multiple times in the USING clause.

 * The USING clause can be omitted only if the statement
 * contains no placeholders.  OPEN places the cursor at the
 * first row of the active set in preparation for a FETCH.

 * A single DECLAREd cursor can be OPENed more than once,
 * optionally USING different input host variables.
 */
    EXEC SQL OPEN C USING :deptno;

/* Break the loop when all data have been retrieved. */

    EXEC SQL WHENEVER NOT FOUND DO break;

/* Loop until the NOT FOUND condition is detected. */

    for (;;)
    {
/* The FETCH statement places the select list of the
 * current row into the variables specified by the INTO
 * clause, then advances the cursor to the next row.  If
 * there are more select-list fields than output host
 * variables, the extra fields will not be returned.
 * Specifying more output host variables than select-list
 * fields results in an ORACLE error.
 */
        EXEC SQL FETCH C INTO :ename;

/* Null-terminate the array before output. */
        ename.arr[ename.len] = '\0';
        puts((char *) ename.arr);
        }

/* Print the cumulative number of rows processed by the
 * current SQL statement.
 */
    printf("\nQuery returned %d row%s.\n\n", sqlca.sqlerrd[2],
        (sqlca.sqlerrd[2] == 1) ? "" : "s");

/* The CLOSE statement releases resources associated with
 * the cursor.
 */
    EXEC SQL CLOSE C;

/* Commit any pending changes and disconnect from Oracle. */
    EXEC SQL COMMIT RELEASE;
    puts("Sayonara.\n");
    exit(0);
}

void
dyn_error(msg)
char *msg;
{
    printf("\n%s", msg);
    sqlca.sqlerrm.sqlerrmc[sqlca.sqlerrm.sqlerrml] = '\0';
    oraca.orastxt.orastxtc[oraca.orastxt.orastxtl] = '\0';
    oraca.orasfnm.orasfnmc[oraca.orasfnm.orasfnml] = '\0';
    printf("\n%s\n", sqlca.sqlerrm.sqlerrmc);
    printf("in \"%s...\"\n", oraca.orastxt.orastxtc);
    printf("on line %d of %s.\n\n", oraca.oraslnr,
       oraca.orasfnm.orasfnmc);

/* Disable ORACLE error checking to avoid an infinite loop
 * should another error occur within this routine.
 */
    EXEC SQL WHENEVER SQLERROR CONTINUE;

/* Release resources associated with the cursor. */
    EXEC SQL CLOSE C;

/* Roll back any pending changes and disconnect from Oracle. */  
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4018"></a><div class="props_rev_3"><a id="GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E" name="GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E"></a><h3 id="LNPCC-GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E" class="sect3"><span class="enumeration_section">13.10 </span>Using Method 4 
               </h3>
               <div>
                  <div class="section">
                     <p>This section gives an overview of Oracle Dynamic SQL Method 4. Oracle Dynamic SQL Method 4 does not support object types, results sets, arrays of structs, or LOBs.</p>
                     <p>ANSI SQL does support all datatypes. Use ANSI SQL for all new applications. </p>
                     <p>There is a kind of dynamic SQL statement that your program cannot process using Method 3. When the number of select-list items or placeholders for input host variables is unknown until run time, your program must use a descriptor. A <span class="italic">descriptor</span> is an area of memory used by your program and Oracle to hold a complete description of the variables in a dynamic SQL statement.<a id="d73629e1389" class="indexterm-anchor"></a><a id="d73629e1393" class="indexterm-anchor"></a><a id="d73629e1397" class="indexterm-anchor"></a> 
                     </p>
                     <p>Recall that for a multirow query, you FETCH selected column values INTO a list of declared output host variables. If the select list is unknown, the host-variable list cannot be established at precompile time by the INTO clause. For example, you know the following query returns two column values: </p><pre class="oac_no_warn" dir="ltr">SELECT ename, empno FROM emp WHERE deptno = :dept_number; 
</pre><p>However, if you let the user define the select list, you might not know how many column values the query will return. </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI Dynamic SQL</a></li>
                        <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle Dynamic SQL: Method 4</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4019"></a><div class="props_rev_3"><a id="GUID-126A218A-D65F-4442-BC69-38D1896A3441" name="GUID-126A218A-D65F-4442-BC69-38D1896A3441"></a><h4 id="LNPCC-GUID-126A218A-D65F-4442-BC69-38D1896A3441" class="sect4"><span class="enumeration_section">13.10.1 </span> Need for the SQLDA 
                  </h4>
                  <div>
                     <p>To process this kind of dynamic query, your program must issue the DESCRIBE SELECT LIST command and declare a data structure called the SQL Descriptor Area (SQLDA). Because it holds descriptions of columns in the query select list, this structure is also called a <span class="italic">select descriptor</span>.<a id="d73629e1450" class="indexterm-anchor"></a><a id="d73629e1454" class="indexterm-anchor"></a><a id="d73629e1458" class="indexterm-anchor"></a><a id="d73629e1462" class="indexterm-anchor"></a><a id="d73629e1466" class="indexterm-anchor"></a><a id="d73629e1470" class="indexterm-anchor"></a><a id="d73629e1474" class="indexterm-anchor"></a><a id="d73629e1478" class="indexterm-anchor"></a></p>
                     <p>Likewise, if a dynamic SQL statement contains an unknown number of placeholders for input host variables, the host-variable list cannot be established at precompile time by the USING clause. </p>
                     <p>To process the dynamic SQL statement, your program must issue the DESCRIBE BIND VARIABLES command and declare another kind of SQLDA called a <span class="italic">bind descriptor</span> to hold descriptions of the placeholders for input host variables. (Input host variables are also called <span class="italic">bind variables</span>.)<a id="d73629e1492" class="indexterm-anchor"></a><a id="d73629e1496" class="indexterm-anchor"></a><a id="d73629e1498" class="indexterm-anchor"></a> 
                     </p>
                     <p>If your program has more than one active SQL statement (it might have OPENed two or more cursors, for example), each statement must have its own SQLDA(s). However, non-concurrent cursors can reuse SQLDAs. There is no set limit on the number of SQLDAs in a program. </p>
                  </div>
               </div><a id="LNPCC4020"></a><div class="props_rev_3"><a id="GUID-EF4B376D-E13C-4D07-B60D-964B49957645" name="GUID-EF4B376D-E13C-4D07-B60D-964B49957645"></a><h4 id="LNPCC-GUID-EF4B376D-E13C-4D07-B60D-964B49957645" class="sect4"><span class="enumeration_section">13.10.2 </span>The DESCRIBE Statement 
                  </h4>
                  <div>
                     <p>DESCRIBE initializes a descriptor to hold descriptions of select-list items or input host variables. </p>
                     <p>If you supply a select descriptor, the DESCRIBE SELECT LIST statement examines each select-list item in a PREPAREd dynamic query to determine its name, datatype, constraints, length, scale, and precision. It then stores this information in the select descriptor.<a id="d73629e1532" class="indexterm-anchor"></a> 
                     </p>
                     <p>If you supply a bind descriptor, the DESCRIBE BIND VARIABLES statement examines each placeholder in a PREPAREd dynamic SQL statement to determine its name, length, and the datatype of its associated input host variable. It then stores this information in the bind descriptor for your use. For example, you might use placeholder names to prompt the user for the values of input host variables.<a id="d73629e1539" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4021"></a><div class="props_rev_3"><a id="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E" name="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E"></a><h4 id="LNPCC-GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E" class="sect4"><span class="enumeration_section">13.10.3 </span>What is a SQLDA? 
                  </h4>
                  <div>
                     <p>A SQLDA is a host-program data structure that holds descriptions of select-list items or input host variables.<a id="d73629e1568" class="indexterm-anchor"></a> 
                     </p>
                     <p>SQLDA variables are <span class="italic">not</span> defined in the Declare Section. 
                     </p>
                     <p>The select SQLDA contains the following information about a query select list:<a id="d73629e1580" class="indexterm-anchor"></a><a id="d73629e1584" class="indexterm-anchor"></a> 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Maximum number of columns that can be DESCRIBEd </p>
                        </li>
                        <li>
                           <p>Actual number of columns found by DESCRIBE </p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store column values </p>
                        </li>
                        <li>
                           <p>Lengths of column values </p>
                        </li>
                        <li>
                           <p>Datatypes of column values </p>
                        </li>
                        <li>
                           <p>Addresses of indicator-variable values </p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store column names </p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store column names </p>
                        </li>
                        <li>
                           <p>Current lengths of column names </p>
                        </li>
                     </ul>
                     <p>The bind SQLDA contains the following information about the input host variables in a SQL statement: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Maximum number of placeholders that can be DESCRIBEd </p>
                        </li>
                        <li>
                           <p>Actual number of placeholders found by DESCRIBE </p>
                        </li>
                        <li>
                           <p>Addresses of input host variables </p>
                        </li>
                        <li>
                           <p>Lengths of input host variables </p>
                        </li>
                        <li>
                           <p>Datatypes of input host variables </p>
                        </li>
                        <li>
                           <p>Addresses of indicator variables </p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store placeholder names </p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store placeholder names </p>
                        </li>
                        <li>
                           <p>Current lengths of placeholder names </p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store indicator-variable names </p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store indicator-variable names </p>
                        </li>
                        <li>
                           <p>Current lengths of indicator-variable names </p>
                           <div class="infoboxnotealso" id="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E__GUID-1F810159-0D1B-46B4-A38A-F0BE828120C2">
                              <p class="notep1">See Also:</p>
                              <p><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">  Oracle Dynamic SQL:  Method 4</a> for information on the SQLDA structure and variable names.
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4022"></a><div class="props_rev_3"><a id="GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE" name="GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE"></a><h4 id="LNPCC-GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE" class="sect4"><span class="enumeration_section">13.10.4 </span>About Implementing Oracle Method 4 
                  </h4>
                  <div>
                     <p>With Oracle Method 4, you generally use the following sequence of embedded SQL statements:<a id="d73629e1687" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name 
    FROM { :host_string | string_literal }; 
EXEC SQL DECLARE cursor_name CURSOR FOR statement_name; 
EXEC SQL DESCRIBE BIND VARIABLES FOR statement_name 
    INTO bind_descriptor_name; 
EXEC SQL OPEN cursor_name 
    [USING DESCRIPTOR bind_descriptor_name]; 
EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name 
    INTO select_descriptor_name; 
EXEC SQL FETCH cursor_name 
    USING DESCRIPTOR select_descriptor_name; 
EXEC SQL CLOSE cursor_name; 
</pre><p>However, select and bind descriptors need not work in tandem. So, if the number of columns in a query select list is known, but the number of placeholders for input host variables is unknown, you can use the Method 4 OPEN statement with the following Method 3 FETCH statement: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO host_variable_list; 
</pre><p>Conversely, if the number of placeholders for input host variables is known, but the number of columns in the select list is unknown, you can use the Method 3 OPEN statement </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor_name [USING host_variable_list]; 
</pre><p>with the Method 4 FETCH statement. </p>
                     <p>EXECUTE can be used for nonqueries with Method 4. </p>
                  </div>
               </div><a id="LNPCC4023"></a><div class="props_rev_3"><a id="GUID-D9A439AF-10AC-48CE-A5D6-107437285D74" name="GUID-D9A439AF-10AC-48CE-A5D6-107437285D74"></a><h4 id="LNPCC-GUID-D9A439AF-10AC-48CE-A5D6-107437285D74" class="sect4"><span class="enumeration_section">13.10.5 </span>Restriction
                  </h4>
                  <div>
                     <p>In Dynamic SQL Method 4, you cannot bind a host array to a PL/SQL procedure with a parameter of type "table."</p>
                  </div>
               </div>
            </div><a id="LNPCC4024"></a><div class="props_rev_3"><a id="GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4" name="GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4"></a><h3 id="LNPCC-GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4" class="sect3"><span class="enumeration_section">13.11 </span>About Using the DECLARE STATEMENT Statement 
               </h3>
               <div>
                  <p>With Methods 2, 3, and 4, you might need to use the statement<a id="d73629e1755" class="indexterm-anchor"></a><a id="d73629e1759" class="indexterm-anchor"></a><a id="d73629e1763" class="indexterm-anchor"></a><a id="d73629e1767" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT db_name] DECLARE statement_name STATEMENT; 
</pre><p>where <span class="italic">db_name</span> and <span class="italic">statement_name</span> are identifiers used by the precompiler, <span class="italic">not</span> host or program variables. 
                  </p>
                  <p>DECLARE STATEMENT declares the name of a dynamic SQL statement so that the statement can be referenced by PREPARE, EXECUTE, DECLARE CURSOR, and DESCRIBE. It is required if you want to execute the dynamic SQL statement at a nondefault database. An example using Method 2 follows:<a id="d73629e1787" class="indexterm-anchor"></a><a id="d73629e1791" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT remote_db DECLARE sql_stmt STATEMENT; 
EXEC SQL PREPARE sql_stmt FROM :dyn_string; 
EXEC SQL EXECUTE sql_stmt; 
</pre><p>In the example, <span class="italic">remote_db</span> tells Oracle where to EXECUTE the SQL statement. 
                  </p>
                  <p>With Methods 3 and 4, DECLARE STATEMENT is also required if the DECLARE CURSOR statement precedes the PREPARE statement, as shown in the following example: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE sql_stmt STATEMENT; 
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt; 
EXEC SQL PREPARE sql_stmt FROM :dyn_string;
</pre><p>The usual sequence of statements is </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM :dyn_string; 
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt; </pre></div><a id="LNPCC4025"></a><div class="props_rev_3"><a id="GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867" name="GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867"></a><h4 id="LNPCC-GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867" class="sect4"><span class="enumeration_section">13.11.1 </span>About Using Host Arrays 
                  </h4>
                  <div>
                     <p>The use of host arrays in static SQL and dynamic SQL is similar. For example, to use input host arrays with dynamic SQL Method 2, simply use the syntax<a id="d73629e1834" class="indexterm-anchor"></a><a id="d73629e1838" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name USING host_array_list; 
</pre><p>where <span class="italic">host_array_list</span> contains one or more host arrays. 
                     </p>
                     <p>Similarly, to use input host arrays with Method 3, use the following syntax: </p><pre class="oac_no_warn" dir="ltr">OPEN cursor_name USING host_array_list; 
</pre><p>To use output host arrays with Method 3, use the following syntax: </p><pre class="oac_no_warn" dir="ltr">FETCH cursor_name INTO host_array_list; 
</pre><p>With Method 4, you must use the optional FOR clause to tell Oracle the size of your input or output host array. </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle Dynamic SQL: Method 4</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC4026"></a><div class="props_rev_3"><a id="GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89" name="GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89"></a><h3 id="LNPCC-GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89" class="sect3"><span class="enumeration_section">13.12 </span>About Using PL/SQL 
               </h3>
               <div>
                  <p>The Pro*C/C++ Precompiler treats a PL/SQL block like a single SQL statement. So, like a SQL statement, a PL/SQL block can be stored in a string host variable or literal. When you store the PL/SQL block in the string, omit the keywords EXEC SQL EXECUTE, the keyword END-EXEC, and the ';' statement terminator.<a id="d73629e1894" class="indexterm-anchor"></a><a id="d73629e1898" class="indexterm-anchor"></a> 
                  </p>
                  <p>However, there are two differences in the way the precompiler handles SQL and PL/SQL: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The precompiler treats all PL/SQL host variables as <span class="italic">input</span> host variables whether they serve as input or output host variables (or both) inside the PL/SQL block. 
                        </p>
                     </li>
                     <li>
                        <p>You cannot FETCH from a PL/SQL block because it might contain any number of SQL statements. </p>
                     </li>
                  </ul>
               </div><a id="LNPCC4027"></a><div class="props_rev_3"><a id="GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718" name="GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718"></a><h4 id="LNPCC-GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718" class="sect4"><span class="enumeration_section">13.12.1 </span>With Method 1 
                  </h4>
                  <div>
                     <p>If the PL/SQL block contains no host variables, you can use Method 1 to EXECUTE the PL/SQL string in the usual way.<a id="d73629e1939" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4028"></a><div class="props_rev_3"><a id="GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5" name="GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5"></a><h4 id="LNPCC-GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5" class="sect4"><span class="enumeration_section">13.12.2 </span>With Method 2 
                  </h4>
                  <div>
                     <p>If the PL/SQL block contains a known number of input and output host variables, you can use Method 2 to PREPARE and EXECUTE the PL/SQL string in the usual way.<a id="d73629e1968" class="indexterm-anchor"></a> 
                     </p>
                     <p>You must put <span class="italic">all</span> host variables in the USING clause. When the PL/SQL string is EXECUTEd, host variables in the USING clause replace corresponding placeholders in the PREPAREd string. Though the precompiler treats all PL/SQL host variables as input host variables, values are assigned correctly. Input (program) values are assigned to input host variables, and output (column) values are assigned to output host variables. 
                     </p>
                     <p>Every placeholder in the PREPAREd PL/SQL string must correspond to a host variable in the USING clause. So, if the same placeholder appears two or more times in the PREPAREd string, each appearance must correspond to a host variable in the USING clause.<a id="d73629e1980" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4029"></a><div class="props_rev_3"><a id="GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8" name="GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8"></a><h4 id="LNPCC-GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8" class="sect4"><span class="enumeration_section">13.12.3 </span>With Method 3 
                  </h4>
                  <div>
                     <p>Methods 2 and 3 are the same except that Method 3 allows FETCHing. Since you cannot FETCH from a PL/SQL block, just use Method 2 instead.<a id="d73629e2010" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4030"></a><div class="props_rev_3"><a id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A" name="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A"></a><h4 id="LNPCC-GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A" class="sect4"><span class="enumeration_section">13.12.4 </span>With Oracle Method 4 
                  </h4>
                  <div>
                     <p>If the PL/SQL block contains an unknown number of input or output host variables, you must use Method 4.<a id="d73629e2039" class="indexterm-anchor"></a> 
                     </p>
                     <p>To use Method 4, you set up one bind descriptor for all the input and output host variables. Executing DESCRIBE BIND VARIABLES stores information about input <span class="italic">and</span> output host variables in the bind descriptor. Because the precompiler treats all PL/SQL host variables as input host variables, executing DESCRIBE SELECT LIST has no effect. 
                     </p>
                     <div class="infoboxnotewarn" id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A__GUID-79CC48E6-44E0-4DFE-9829-170DD83B496C">
                        <p class="notep1">WARNING:</p>
                        <p>In dynamic SQL Method 4, you cannot bind a host array to a PL/SQL procedure with a parameter of type "table."</p>
                     </div>
                     <div class="infoboxnotewarn" id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A__GUID-F14B1294-D473-4E35-A025-F7515677F4FE">
                        <p class="notep1">WARNING:</p>
                        <p>Do not use ANSI-style Comments (- -) in a PL/SQL block that will be processed dynamically because end-of-line characters are ignored. As a result, ANSI-style Comments extend to the end of the block, not just to the end of a line. Instead, use C-style Comments (/* ... */).<a id="d73629e2055" class="indexterm-anchor"></a><a id="d73629e2059" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <p></p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle Dynamic SQL: Method 4</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4032"></a><a id="LNPCC4031"></a><div class="props_rev_3"><a id="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC" name="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC"></a><h3 id="LNPCC-GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC" class="sect3"><span class="enumeration_section">13.13 </span>Dynamic SQL Statement Caching
               </h3>
               <div>
                  <div class="section">
                     <p>Statement caching refers to the feature that provides and manages a cache of statements for each session. In the server, it means that cursors are ready to be used without the statement being parsed again. Statement caching can be enabled in the precompiler applications, which will help in the performance improvement of all applications that rely on the dynamic SQL statements. Performance improvement is achieved by removing the overhead of parsing the dynamic statements on reuse. </p>
                     <p>You can obtain this performance improvement by using a new command line option, <code class="codeph">stmt_cache</code>  (for the statement cache size), which will enable the statement caching of the dynamic statements. By enabling the new option, the statement cache will be created at session creation time. The caching is only applicable for the dynamic statements and the cursor cache for the static statements co-exists with this feature.
                     </p>
                     <p>The command line option <code class="codeph">stmt_cache</code> can be given any value in the range of 0 to 65535.  Statement caching is disabled by default (value 0). The <code class="codeph">stmt_cache</code> option can be set to hold the anticipated number of distinct dynamic SQL statements in the application.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC__GUID-CEE8240B-2ED2-4936-98C9-EBF7975638A3">
                     <p class="titleinexample">Example 13-1 Using the stmt_cache Option</p>
                     <p>This example demonstrates the use of the <code class="codeph">stmt_cache</code> option. In this program, you insert rows into a table and select the inserted rows by using the cursor in the loop. When the stmt_cache option is used to precompile this program, the performance increases compared to a normal precompilation.
                     </p><pre class="oac_no_warn" dir="ltr">/*
 *  stmtcache.pc
 *
 *  NOTE: 
 *  When this program is used to measure the performance with and without
 *  stmt_cache option, do the following changes in the program,
 *  1. Increase ROWSCNT to high value, say 10000.
 *  2. Remove all the print statements, usually which comsumes significant
 *     portion of the total program execution time.
 * 
 *  HINT: In Linux, gettimeofday() can be used to measure time. 
 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;oraca.h&gt;
 
#define ROWSCNT 10
 
char    *username = "scott";
char    *password = "tiger";
 
/* Function prototypes */
void sql_error(char *msg);
void selectdata();
void insertdata();
 
int main()
{
  EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error");
 
  /* Connect using the default schema scott/tiger */
  EXEC SQL CONNECT :username IDENTIFIED BY :password;
 
  /* core functions to insert and select the data */
  insertdata();
  selectdata();
 
/* Rollback pll the changes and disconnect from Oracle. */
  EXEC SQL ROLLBACK WORK RELEASE;
 
  exit(0);
}
 
/*Insert the data for ROWSCNT items into tpc2sc01 */
void insertdata()
{
  varchar dynstmt[80];
  int i;
  varchar ename[10];
  float comm;
  char *str;
 
  /* Allocates temporary buffer */
  str = (char *)malloc (11 * sizeof(char));
 
  strcpy ((char *)dynstmt.arr,
          "INSERT INTO bonus (ename, comm) VALUES (:ename, :comm)");
  dynstmt.len = strlen(dynstmt.arr);
  EXEC SQL PREPARE S FROM :dynstmt;
 
  printf ("Inserts %d rows into bonus table using dynamic SQL statement\n",
          ROWSCNT);
  for (i=1; i&lt;=ROWSCNT; i++)
  {
    sprintf (str, "EMP_%05d",i);
    strcpy (ename.arr, str);
    comm = i;
    ename.len = strlen (ename.arr);
    EXEC SQL EXECUTE S USING :ename, :comm;
  }
 
  free(str);
}
 
/* Select the data using the cursor */
void selectdata()
{
  varchar dynstmt[80];
  varchar ename[10];
  float comm;
  int i;
 
  strcpy((char *)dynstmt.arr,
         "SELECT ename, comm FROM bonus WHERE comm = :v1");
  dynstmt.len = (unsigned short)strlen((char *)dynstmt.arr);
 
  printf ("Fetches the inserted rows using using dynamic SQL statement\n\n");
  printf ("  ENAME      COMMISSION\n\n");
 
  for (i=1; i&lt;=ROWSCNT; i++)
  {
    /* Do the prepare in the loop so that the advantage of stmt_caching 
       is visible*/
    EXEC SQL PREPARE S FROM :dynstmt;
 
    EXEC SQL DECLARE C CURSOR FOR S;
    EXEC SQL OPEN C USING :i;
 
    EXEC SQL WHENEVER NOT FOUND DO break;
 
    /* Loop until the NOT FOUND condition is detected. */
    for (;;)
    {
      EXEC SQL FETCH C INTO :ename, :comm;
      ename.arr[ename.len] = '\0';
      printf ("%10s    %7.2f\n", ename.arr, comm);
    }
    /* Close the cursor so that the reparsing is not required for stmt_cache */
    EXEC SQL CLOSE C;
  }
}
 
void sql_error(char *msg)
{
    printf("\n%s", msg);
    sqlca.sqlerrm.sqlerrmc[sqlca.sqlerrm.sqlerrml] = '\0';
    oraca.orastxt.orastxtc[oraca.orastxt.orastxtl] = '\0';
    oraca.orasfnm.orasfnmc[oraca.orasfnm.orasfnml] = '\0';
    printf("\n%s\n", sqlca.sqlerrm.sqlerrmc);
    printf("in \"%s...\"\n", oraca.orastxt.orastxtc);
    printf("on line %d of %s.\n\n", oraca.oraslnr,
       oraca.orasfnm.orasfnmc);
 
   /* Disable ORACLE error checking to avoid an infinite loop
    * should another error occur within this routine.
    */
    EXEC SQL WHENEVER SQLERROR CONTINUE;
 
    /* Release resources associated with the cursor. */
    EXEC SQL CLOSE C;
 
    /* Roll back any pending changes and disconnect from Oracle. */  
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(1);
}</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>