<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Performance Tuning</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="Oracle-reserved-words-keywords-namespaces.html" title="Previous" type="text/html">
      <link rel="next" href="syntactic-and-semantic-checking.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-reserved-words-keywords-namespaces.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="syntactic-and-semantic-checking.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Performance Tuning</li>
            </ol>
            <a id="GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE" name="GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE"></a><a id="ZZPRE962"></a>
            
            <h2 id="ZZPRE-GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE" class="sect2"><span class="enumeration_chapter">C </span> Performance Tuning
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This appendix contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="performance-tuning.html#GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853">What Causes Poor Performance?</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B">How Can Performance be Improved?</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-F45C7950-E32D-4755-9131-281EA1211B6B">Using Host Arrays</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7">Using Embedded PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50">Optimizing SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0">About Using Indexes</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4">Taking Advantage of Row-Level Locking</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-0E9592D6-734E-456B-A29F-3C96CC236248">About Eliminating Unnecessary Parsing</a></p>
                  </li>
               </ul>
               <p>This appendix shows you some simple, easy-to-apply methods for improving the performance of your applications. Using these methods, you can often reduce processing time by 25% or more.</p>
            </div><a id="ZZPRE963"></a><div class="props_rev_3"><a id="GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853" name="GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853"></a><h3 id="ZZPRE-GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853" class="sect3"><span class="enumeration_section">C.1 </span>What Causes Poor Performance?
               </h3>
               <div>
                  <p><a id="d83369e90" class="indexterm-anchor"></a>One cause of poor performance is high Oracle communication overhead. Oracle must process SQL statements one at a time. Thus, each statement results in another call to Oracle and higher overhead. In a networked environment, SQL statements must be sent over the network, adding to network traffic. Heavy network traffic can slow down your application significantly.
                  </p>
                  <p>Another cause of poor performance is inefficient SQL statements. Because SQL is so flexible, you can get the same result with two different statements, but one statement might be less efficient. For example, the following two <code class="codeph">SELECT</code> statements return the same rows (the name and number of every department having at least one employee):
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT DNAME, DEPTNO
 FROM DEPT
 WHERE DEPTNO IN (SELECT DEPTNO FROM EMP);
EXEC SQL SELECT DNAME, DEPTNO
 FROM DEPT
 WHERE EXISTS
 (SELECT DEPTNO FROM EMP WHERE DEPT.DEPTNO = EMP.DEPTNO);
</pre><p>However, the first statement is slower because it does a time-consuming full scan of the <code class="codeph">EMP</code> table for every department number in the <code class="codeph">DEPT</code> table. Even if the <code class="codeph">DEPTNO</code> column in <code class="codeph">EMP</code> is indexed, the index is not used because the subquery lacks a <code class="codeph">WHERE</code> clause naming <code class="codeph">DEPTNO</code>.
                  </p>
                  <p>A third cause of poor performance is unnecessary parsing and binding. Recall that before executing a SQL statement, Oracle must parse and bind it. Parsing means examining the SQL statement to make sure it follows syntax rules and refers to valid database objects. Binding means associating host variables in the SQL statement with their addresses so that Oracle can read or write their values.</p>
                  <p>Many applications manage cursors poorly. This results in unnecessary parsing and binding, which adds noticeably to processing overhead.</p>
               </div>
            </div><a id="ZZPRE964"></a><div class="props_rev_3"><a id="GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B" name="GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B"></a><h3 id="ZZPRE-GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B" class="sect3"><span class="enumeration_section">C.2 </span>How Can Performance be Improved?
               </h3>
               <div>
                  <p>If you are unhappy with the performance of your precompiled programs, there are several ways you can reduce overhead.</p>
                  <p>You can greatly reduce Oracle communication overhead, especially in networked environments, by:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Using host arrays</p>
                     </li>
                     <li>
                        <p>Using embedded PL/SQL</p>
                     </li>
                  </ul>
                  <p>You can reduce processing overhead --sometimes dramatically-- by:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Optimizing SQL statements</p>
                     </li>
                     <li>
                        <p>Using indexes</p>
                     </li>
                     <li>
                        <p>Taking advantage of row-level locking</p>
                     </li>
                     <li>
                        <p>Eliminating unnecessary parsing</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE965"></a><div class="props_rev_3"><a id="GUID-F45C7950-E32D-4755-9131-281EA1211B6B" name="GUID-F45C7950-E32D-4755-9131-281EA1211B6B"></a><h3 id="ZZPRE-GUID-F45C7950-E32D-4755-9131-281EA1211B6B" class="sect3"><span class="enumeration_section">C.3 </span>Using Host Arrays
               </h3>
               <div>
                  <p>Host arrays can boost performance because they let you manipulate an entire collection of data with a single SQL statement. For example, suppose you want to insert salaries for 300 employees into the <code class="codeph">EMP</code> table. Without arrays your program must do 300 individual inserts--one for each employee. With arrays, only one <code class="codeph">INSERT</code> is necessary. Consider the following statement:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP (SAL) VALUES (:salary);
</pre><p><a id="d83369e209" class="indexterm-anchor"></a>If <span class="italic">salary</span> is a simple host variable, Oracle executes the <code class="codeph">INSERT</code> statement once, inserting a single row into the <code class="codeph">EMP</code> table. In that row, the <code class="codeph">SAL</code> column has the value of <span class="italic">salary</span>. To insert 300 rows this way, you must execute the <code class="codeph">INSERT</code> statement 300 times.
                  </p>
                  <p>However, if <span class="italic">salary</span> is a host array of size 300, Oracle inserts all 300 rows into the <code class="codeph">EMP</code> table at once. In each row, the <code class="codeph">SAL</code> column has the value of an element in the <span class="italic">salary</span> array.
                  </p>
                  <p>For more information, see <a href="using-host-arrays.html#GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F"> Using Host Arrays</a></p>
               </div>
            </div><a id="ZZPRE967"></a><a id="ZZPRE966"></a><div class="props_rev_3"><a id="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7" name="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7"></a><h3 id="ZZPRE-GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7" class="sect3"><span class="enumeration_section">C.4 </span>Using Embedded PL/SQL
               </h3>
               <div>
                  <p>As <a href="performance-tuning.html#GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7__BABGCIDB">Figure C-1</a> shows, if your application is database-intensive, you can use control structures to group SQL statements in a PL/SQL block, then send the entire block to Oracle. This can drastically reduce communication between your application and Oracle. 
                  </p>
                  <p><a id="d83369e278" class="indexterm-anchor"></a>Also, you can use PL/SQL subprograms to reduce calls from your application to Oracle. For example, to execute ten individual SQL statements, ten calls are required, but to execute a subprogram containing ten SQL statements, only one call is required. 
                  </p>
                  <p><a id="d83369e284" class="indexterm-anchor"></a>Unlike anonymous blocks, PL/SQL subprograms can be compiled separately and stored in an Oracle database. When called, they are passed to the PL/SQL engine immediately. Moreover, only one copy of a subprogram need be loaded into memory for execution by multiple users.
                  </p>
                  <div class="figure" id="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7__BABGCIDB">
                     <p class="titleinfigure">Figure C-1 PL/SQL Boosts Performance</p><img src="img/image015.gif" alt="Description of Figure C-1 follows" title="Description of Figure C-1 follows" longdesc="img_text/image015.html"><br><a href="img_text/image015.html">Description of "Figure C-1 PL/SQL Boosts Performance"</a></div>
                  <!-- class="figure" -->
                  <p>PL/SQL can also cooperate with Oracle application development tools such as Oracle Forms and Oracle Reports. By adding procedural processing power to these tools, PL/SQL boosts performance. Using PL/SQL, a tool can do any computation quickly and efficiently without calling on Oracle. This saves time and <a id="d83369e296" class="indexterm-anchor"></a>reduces network traffic. For more information, see <a href="using-embedded-PLSQL.html#GUID-F6E58CB5-C25B-47EE-B349-314F28961A56"> Using Embedded PL/SQL</a> and the <a href="../lnpls/overview.html#LNPLS-GUID-2FBCFBBE-6B42-4DB8-83F3-55B63B75B1EB" target="_blank"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.
                  </p>
               </div>
            </div><a id="ZZPRE968"></a><div class="props_rev_3"><a id="GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50" name="GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50"></a><h3 id="ZZPRE-GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50" class="sect3"><span class="enumeration_section">C.5 </span>Optimizing SQL Statements
               </h3>
               <div>
                  <p>For every SQL statement, the Oracle optimizer generates an <span class="italic">execution plan</span>, which is a series of steps that Oracle takes to execute the statement. These steps are determined by rules given in the<a href="../adfns/fundamentals.html#ADFNS-GUID-EBCEA9FE-4F25-40DF-B5FD-682C3692E92F" target="_blank"><span class="italic"> Oracle Database Advanced Application Developer's Guide</span></a>. Following these rules will help you write optimal SQL statements.
                  </p>
               </div><a id="ZZPRE969"></a><div class="props_rev_3"><a id="GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA" name="GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA"></a><h4 id="ZZPRE-GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA" class="sect4"><span class="enumeration_section">C.5.1 </span>Optimizer Hints
                  </h4>
                  <div>
                     <p>For every SQL statement, the Oracle optimizer generates an <span class="italic">execution plan</span>, which is a series of steps that Oracle takes to execute the statement. In some cases, you can suggest to Oracle the way to optimize a SQL statement. These suggestions, called <a id="d83369e377" class="indexterm-anchor"></a><span class="italic">hints</span>, let you influence decisions made by the optimizer.
                     </p>
                     <p>Hints are not directives; they merely help the optimizer do its job. Some hints limit the scope of information used to optimize a SQL statement, while others suggest overall strategies. You can use hints to specify the:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Optimization approach for a SQL statement</p>
                        </li>
                        <li>
                           <p>Access path for each referenced table</p>
                        </li>
                        <li>
                           <p>Join order for a join</p>
                        </li>
                        <li>
                           <p>Method used to join tables</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ZZPRE970"></a><div class="props_rev_3"><a id="GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742" name="GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742"></a><h4 id="ZZPRE-GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742" class="sect4"><span class="enumeration_section">C.5.2 </span>Giving Hints
                  </h4>
                  <div>
                     <p>You give hints to the optimizer by placing them in a C-style comment immediately after the verb in a <code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statement. You can choose rule-based or cost-based optimization. With cost-based optimization, hints help maximize throughput or response time. In the following example, the <code class="codeph">ALL_ROWS</code> hint helps maximize query throughput:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT /*+ ALL_ROWS (cost-based) */ EMPNO, ENAME, SAL
 INTO :emp_number, :emp_name, :salary -- host arrays
 FROM EMP
 WHERE DEPTNO = :dept_number;
</pre><p>The plus sign (+), which must immediately follow the comment opener, indicates that the comment contains one or more hints. Notice that the comment can contain remarks and hints.</p>
                     <p>For more information about optimizer hints, see <a href="../adfns/performance-and-scalability.html#ADFNS-GUID-826DD1D3-C722-4915-8790-E870D6B5123A" target="_blank">Performance and Scalability</a>.
                     </p>
                  </div>
               </div><a id="ZZPRE971"></a><div class="props_rev_3"><a id="GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3" name="GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3"></a><h4 id="ZZPRE-GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3" class="sect4"><span class="enumeration_section">C.5.3 </span>Trace Facility
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use the SQL trace facility and the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement to identify SQL statements that might be slowing down your application. The trace facility generates statistics for every SQL statement executed by Oracle. From these statistics, you can determine which statements take the most time to process. Then, you can concentrate your tuning efforts on those statements.
                        </p>
                        <p>The <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement shows the execution plan for each SQL statement in your application. You can use the execution plan to identify inefficient SQL statements.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE972"></a><div class="props_rev_3"><a id="GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0" name="GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0"></a><h3 id="ZZPRE-GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0" class="sect3"><span class="enumeration_section">C.6 </span>About Using Indexes
               </h3>
               <div>
                  <p><a id="d83369e505" class="indexterm-anchor"></a>Using rowids, an <span class="italic">index</span> associates each distinct value in a table column with the rows containing that value. An index is created with the <code class="codeph">CREATE INDEX</code> statement.
                  </p>
                  <p>You can use indexes to boost the performance of queries that return less than 15% of the rows in a table. A query that returns 15% or more of the rows in a table is executed faster by a <span class="italic">full scan</span><a id="d83369e518" class="indexterm-anchor"></a>, that is, by reading all rows sequentially. Any query that names an indexed column in its <code class="codeph">WHERE</code> clause can use the index. For guidelines that help you choose which columns to index, see <a href="../adfns/performance-and-scalability.html#ADFNS-GUID-826DD1D3-C722-4915-8790-E870D6B5123A" target="_blank">Performance and Scalability</a>.
                  </p>
               </div>
            </div><a id="ZZPRE973"></a><div class="props_rev_3"><a id="GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4" name="GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4"></a><h3 id="ZZPRE-GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4" class="sect3"><span class="enumeration_section">C.7 </span>Taking Advantage of Row-Level Locking
               </h3>
               <div>
                  <p><a id="d83369e549" class="indexterm-anchor"></a>By default, Oracle locks data at the row level rather than the table level. Row-level locking allows multiple users to access different rows in the same table concurrently. The resulting performance gain is significant.
                  </p>
                  <p>You can specify table-level locking, but it lessens the effectiveness of the transaction processing option. For more information about table locking, see <span class="q">"<a href="defining-controlling-transactions.html#GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA">About Using the LOCK TABLE Statement</a>"</span>.
                  </p>
                  <p>Applications that do online transaction processing benefit most from row-level locking. If your application relies on table-level locking, modify it to take advantage of row-level locking. In general, avoid explicit table-level locking.</p>
               </div>
            </div><a id="ZZPRE974"></a><div class="props_rev_3"><a id="GUID-0E9592D6-734E-456B-A29F-3C96CC236248" name="GUID-0E9592D6-734E-456B-A29F-3C96CC236248"></a><h3 id="ZZPRE-GUID-0E9592D6-734E-456B-A29F-3C96CC236248" class="sect3"><span class="enumeration_section">C.8 </span>About Eliminating Unnecessary Parsing
               </h3>
               <div>
                  <p>Eliminating unnecessary parsing requires correct handling of cursors and selective use of the following cursor management options:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">MAXOPENCURSORS</code><a id="d83369e590" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p><code class="codeph">HOLD_CURSOR</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">RELEASE_CURSOR</code></p>
                     </li>
                  </ul>
                  <p>These options affect implicit and explicit cursors, the cursor cache, and private SQL areas. </p>
                  <p>You can use the ORACA to get cursor cache statistics. See <span class="q">"<a href="error-handling-diagnostics.html#GUID-EECD612B-7EA7-4C51-A8FD-5F7EC854F510">About Using the Oracle Communications Area</a>"</span>.
                  </p>
               </div><a id="ZZPRE975"></a><div class="props_rev_3"><a id="GUID-D681627C-8D13-4881-908F-07B230DB0EA4" name="GUID-D681627C-8D13-4881-908F-07B230DB0EA4"></a><h4 id="ZZPRE-GUID-D681627C-8D13-4881-908F-07B230DB0EA4" class="sect4"><span class="enumeration_section">C.8.1 </span>About Handling Explicit Cursors
                  </h4>
                  <div>
                     <p>Recall that there are two types of cursors: implicit and explicit. Oracle implicitly declares a cursor for all data definition and data manipulation statements. However, for queries that return more than one row, you must explicitly declare a cursor (or use host arrays). You use the <code class="codeph">DECLARE CURSOR</code> statement to declare an explicit cursor. How you handle the opening and closing of explicit cursors affects performance.
                     </p>
                     <p>If you need to reevaluate the active set, simply reopen the cursor. The <code class="codeph">OPEN</code> statement will use any new host-variable values. You can save processing time if you do not close the cursor first.
                     </p>
                     <p><a id="d83369e642" class="indexterm-anchor"></a>To make performance tuning easier, the precompiler lets you reopen an already open cursor. However, this is an Oracle extension to the ANSI/ISO embedded SQL standard. So, when <code class="codeph">MODE=ANSI</code>, you must close a cursor before reopening it.
                     </p>
                     <p>Only <code class="codeph">CLOSE</code> a cursor when you want to free the resources (memory and locks) acquired by opening the cursor. For example, your program should close all cursors before exiting.
                     </p>
                  </div>
               </div><a id="ZZPRE976"></a><div class="props_rev_3"><a id="GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4" name="GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4"></a><h4 id="ZZPRE-GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4" class="sect4"><span class="enumeration_section">C.8.2 </span>Cursor Control
                  </h4>
                  <div>
                     <p>In general, there are three ways to control an explicitly declared cursor:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use the <code class="codeph">DECLARE</code>, <code class="codeph">OPEN</code>, and <code class="codeph">CLOSE</code> statements
                           </p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">PREPARE</code>, <code class="codeph">DECLARE</code>, <code class="codeph">OPEN</code>, and <code class="codeph">CLOSE</code> statements
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT</code> closes the cursor when <code class="codeph">MODE=ANSI</code></p>
                        </li>
                     </ul>
                     <p>With the first way, beware of unnecessary parsing. The <code class="codeph">OPEN</code> statement does the parsing, but only if the parsed statement is unavailable because the cursor was closed or never opened. Your program should <code class="codeph">DECLARE</code> the cursor, reopen it every time the value of a host variable changes, and <code class="codeph">CLOSE</code> it only when the SQL statement is no longer needed.
                     </p>
                     <p>With the second way (dynamic SQL Methods 3 and 4), the <code class="codeph">PREPARE</code> statement does the parsing, and the parsed statement is available until a <code class="codeph">CLOSE</code> statement is executed. Your program should prepare the SQL statement and <code class="codeph">DECLARE</code> the cursor, reopen the cursor every time the value of a host variable changes, rePREPARE the SQL statement and reopen the cursor if the SQL statement changes, and <code class="codeph">CLOSE</code> the cursor only when the SQL statement is no longer needed.
                     </p>
                     <p>When possible, avoid placing <code class="codeph">OPEN</code> and <code class="codeph">CLOSE</code> statements in a loop; this is a potential cause of unnecessary reparsing of the SQL statement. In the next example, both the <code class="codeph">OPEN</code> and <code class="codeph">CLOSE</code> statements are inside the outer <code class="codeph">while</code> loop. When <code class="codeph">MODE=ANSI</code>, the <code class="codeph">CLOSE</code> statement must be positioned as shown, because ANSI requires a cursor to be closed before being reopened.
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ename, sal from emp where sal &gt; :salary and 
 sal &lt;= :salary + 1000; 
salary = 0; 
while (salary &lt; 5000) 
{ 
 EXEC SQL OPEN emp_cursor; 
 while (SQLCODE==0) 
 { 
 EXEC SQL FETCH emp_cursor INTO .... 
 ... 
 } 
 salary += 1000; 
 EXEC SQL CLOSE emp_cursor; 
}
</pre><p>With <code class="codeph">MODE=ORACLE</code>, however, a <code class="codeph">CLOSE</code> statement can execute without the cursor being opened. By placing the <code class="codeph">CLOSE</code> statement outside the outer <code class="codeph">while</code> loop, you can avoid possible reparsing at each iteration of the <code class="codeph">OPEN</code> statement.
                     </p><pre class="oac_no_warn" dir="ltr">... 
while (salary &lt; 5000) 
{ 
 EXEC SQL OPEN emp_cursor; 
 while (sqlca.sqlcode==0) 
 { 
 EXEC SQL FETCH emp_cursor INTO .... 
 ... 
 } 
 salary += 1000; 
} 
EXEC SQL CLOSE emp_cursor;
</pre></div>
               </div><a id="ZZPRE977"></a><div class="props_rev_3"><a id="GUID-513A69BF-C606-42DD-A091-143BC387190E" name="GUID-513A69BF-C606-42DD-A091-143BC387190E"></a><h4 id="ZZPRE-GUID-513A69BF-C606-42DD-A091-143BC387190E" class="sect4"><span class="enumeration_section">C.8.3 </span>About Using the Cursor Management Options
                  </h4>
                  <div>
                     <p>A SQL statement need be parsed only once unless you change its makeup. For example, you change the makeup of a query by adding a column to its select list or <code class="codeph">WHERE</code> clause. The <code class="codeph">HOLD_CURSOR</code>, <code class="codeph">RELEASE_CURSOR</code>, and <code class="codeph">MAXOPENCURSORS</code> options give you some control over how Oracle manages the parsing and reparsing of SQL statements. Declaring an explicit cursor gives you maximum control over parsing.
                     </p>
                  </div>
               </div><a id="ZZPRE979"></a><a id="ZZPRE978"></a><div class="props_rev_3"><a id="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03" name="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03"></a><h4 id="ZZPRE-GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03" class="sect4"><span class="enumeration_section">C.8.4 </span>Private SQL Areas and Cursor Cache
                  </h4>
                  <div>
                     <p><a id="d83369e839" class="indexterm-anchor"></a>When a data manipulation statement is executed, its associated cursor is linked to an entry in the cursor cache. The cursor cache is a continuously updated area of memory used for cursor management. The cursor cache entry is in turn linked to a private SQL area.
                     </p>
                     <p>The <a id="d83369e846" class="indexterm-anchor"></a>private SQL area, a work area created dynamically at run time by Oracle, contains the parsed SQL statement, the addresses of host variables, and other information needed to process the statement. An explicit cursor lets you name a SQL statement, access the information in its private SQL area, and, to some extent, control its processing.
                     </p>
                     <p><a href="performance-tuning.html#GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03__BABJGEHE">Figure C-2</a> represents the cursor cache after your program has done an insert and a delete.
                     </p>
                     <div class="figure" id="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03__BABJGEHE">
                        <p class="titleinfigure">Figure C-2 Cursors Linked through the Cursor Cache</p><img src="img/image016.gif" alt="Description of Figure C-2 follows" title="Description of Figure C-2 follows" longdesc="img_text/image016.html"><br><a href="img_text/image016.html">Description of "Figure C-2 Cursors Linked through the Cursor Cache"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ZZPRE980"></a><div class="props_rev_3"><a id="GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95" name="GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95"></a><h4 id="ZZPRE-GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95" class="sect4"><span class="enumeration_section">C.8.5 </span>Resource Use
                  </h4>
                  <div>
                     <p>The maximum number of open cursors in each user session is set by the Oracle initialization parameter <code class="codeph">OPEN_CURSORS</code>.
                     </p>
                     <p><code class="codeph">MAXOPENCURSORS</code> specifies the <span class="italic">initial</span> size of the cursor cache. If a new cursor is needed and there are no free cache entries, Oracle tries to reuse an entry. Its success depends on the values of <code class="codeph">HOLD_CURSOR</code> and <code class="codeph">RELEASE_CURSOR</code> and, for explicit cursors, on the status of the cursor itself.
                     </p>
                     <p>If the value of <code class="codeph">MAXOPENCURSORS</code> is less than the number of cache entries actually needed, Oracle uses the first cache entry marked as reusable. For example, suppose the cache entry <span class="italic">E</span>(1) for an <code class="codeph">INSERT</code> statement is marked as reusable, and the number of cache entries already equals <code class="codeph">MAXOPENCURSORS</code>. If the program executes a new statement, cache entry <span class="italic">E</span>(1) and its private SQL area might be reassigned to the new statement. To reexecute the <code class="codeph">INSERT</code> statement, Oracle would have to reparse it and reassign another cache entry.
                     </p>
                     <p>Oracle allocates an additional cache entry if it cannot find one to reuse. For example, if <code class="codeph">MAXOPENCURSORS=8</code> and all eight entries are active, a ninth is created. If necessary, Oracle keeps allocating additional cache entries until it runs out of memory or reaches the limit set by <code class="codeph">OPEN_CURSORS</code>. This dynamic allocation adds to processing overhead.
                     </p>
                     <p>Thus, specifying a low value for <code class="codeph">MAXOPENCURSORS</code> saves memory but causes potentially expensive dynamic allocations and deallocations of new cache entries. Specifying a high value for <code class="codeph">MAXOPENCURSORS</code> assures speedy execution but uses more memory.
                     </p>
                  </div>
               </div><a id="ZZPRE981"></a><div class="props_rev_3"><a id="GUID-D9C675E4-9D48-4E18-B119-311BD493468F" name="GUID-D9C675E4-9D48-4E18-B119-311BD493468F"></a><h4 id="ZZPRE-GUID-D9C675E4-9D48-4E18-B119-311BD493468F" class="sect4"><span class="enumeration_section">C.8.6 </span>Infrequent Execution
                  </h4>
                  <div>
                     <p>Sometimes, the link between an <span class="italic">infrequently</span> executed SQL statement and its private SQL area should be temporary.
                     </p>
                     <p>When <code class="codeph">HOLD_CURSOR=NO</code> (the default), after Oracle executes the SQL statement and the cursor is closed, the precompiler marks the link between the cursor and cursor cache as reusable. The link is reused as soon as the cursor cache entry to which it points is needed for another SQL statement. This frees memory allocated to the private SQL area and releases parse locks. However, because a prepared cursor must remain active, its link is maintained even when <code class="codeph">HOLD_CURSOR=NO</code>.
                     </p>
                     <p><a id="d83369e969" class="indexterm-anchor"></a>When <code class="codeph">RELEASE_CURSOR=YES</code>, after Oracle executes the SQL statement and the cursor is closed, the private SQL area is automatically freed and the parsed statement lost. This might be necessary if, for example, <code class="codeph">MAXOPENCURSORS</code> is set low at your site to conserve memory.
                     </p>
                     <p>If a data manipulation statement precedes a data definition statement and they reference the same tables, specify <code class="codeph">RELEASE_CURSOR=YES</code> for the data manipulation statement. This avoids a conflict between the parse lock obtained by the data manipulation statement and the exclusive lock required by the data definition statement.
                     </p>
                     <p>When <code class="codeph">RELEASE_CURSOR=YES</code>, the link between the private SQL area and the cache entry is immediately removed and the private SQL area freed. Even if you specify <code class="codeph">HOLD_CURSOR=YES</code>, Oracle must still reallocate memory for a private SQL area and reparse the SQL statement before executing it because <code class="codeph">RELEASE_CURSOR=YES</code> overrides <code class="codeph">HOLD_CURSOR=YES</code>.
                     </p>
                     <p>Nonetheless, when <code class="codeph">RELEASE_CURSOR=YES</code>, the reparse might not require extra processing because Oracle caches the parsed representations of SQL statements and PL/SQL blocks in its <span class="italic">Shared SQL Cache</span>. Even if its cursor is closed, the parsed representation remains available until it is aged out of the cache.
                     </p>
                  </div>
               </div><a id="ZZPRE982"></a><div class="props_rev_3"><a id="GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1" name="GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1"></a><h4 id="ZZPRE-GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1" class="sect4"><span class="enumeration_section">C.8.7 </span>Frequent Execution
                  </h4>
                  <div>
                     <p>The links between a <span class="italic">frequently</span> executed SQL statement and its private SQL area should be maintained, because the private SQL area contains all the information needed to execute the statement. Maintaining access to this information makes subsequent execution of the statement much faster.
                     </p>
                     <p>When <code class="codeph">HOLD_CURSOR=YES</code>, the link between the cursor and cursor cache is maintained after Oracle executes the SQL statement. Thus, the parsed statement and allocated memory remain available. This is useful for SQL statements that you want to keep active because it avoids unnecessary reparsing.
                     </p>
                     <p>When <code class="codeph">HOLD_CURSOR=YES</code> and <code class="codeph">RELEASE_CURSOR=NO</code> (the default), the link between the cache entry and the private SQL area is maintained after Oracle executes the SQL statement and is not reused unless the number of open cursors exceeds the value of <code class="codeph">MAXOPENCURSORS</code>. This is useful for SQL statements that are executed often because the parsed statement and allocated memory remain available.
                     </p>
                     <p>Using the defaults, <code class="codeph">HOLD_CURSOR=YES</code> and <code class="codeph">RELEASE_CURSOR=NO</code>, after executing a SQL statement with an earlier Oracle version, its parsed representation remains available. With Oracle database version 7, under similar conditions, the parsed representation remains available only until it is aged out of the Shared SQL Cache. Normally, this is not a problem, but you might get unexpected results if the definition of a referenced object changes before the SQL statement is reparsed.
                     </p>
                  </div>
               </div><a id="ZZPRE984"></a><a id="ZZPRE983"></a><div class="props_rev_3"><a id="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4" name="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4"></a><h4 id="ZZPRE-GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4" class="sect4"><span class="enumeration_section">C.8.8 </span>Parameter Interactions
                  </h4>
                  <div>
                     <div class="section">
                        <p><a href="performance-tuning.html#GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4__BABJGAGG" title="parameter interactions">Table C-1</a> shows how <code class="codeph">HOLD_CURSOR</code> and <code class="codeph">RELEASE_CURSOR</code> interact. Notice that <code class="codeph">HOLD_CURSOR=NO</code> overrides <code class="codeph">RELEASE_CURSOR=NO</code> and that <code class="codeph">RELEASE_CURSOR=YES</code> overrides <code class="codeph">HOLD_CURSOR=YES</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4__BABJGAGG">
                        <p class="titleintable">Table C-1 HOLD_CURSOR RELEASE_CURSOR Interactions</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="HOLD_CURSOR RELEASE_CURSOR Interactions" summary="parameter interactions" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d83369e1114">HOLD_CURSOR</th>
                                 <th align="left" valign="bottom" width="27%" id="d83369e1117">RELEASE_CURSOR</th>
                                 <th align="left" valign="bottom" width="46%" id="d83369e1120">Links are:</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1125" headers="d83369e1114 ">
                                    <p>NO</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1125 d83369e1117 ">
                                    <p>NO</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1125 d83369e1120 ">
                                    <p>marked as reusable</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1135" headers="d83369e1114 ">
                                    <p>YES</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1135 d83369e1117 ">
                                    <p>NO</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1135 d83369e1120 ">
                                    <p>maintained</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1145" headers="d83369e1114 ">
                                    <p>NO</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1145 d83369e1117 ">
                                    <p>YES</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1145 d83369e1120 ">
                                    <p>removed immediately</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1155" headers="d83369e1114 ">
                                    <p>YES</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1155 d83369e1117 ">
                                    <p>YES</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1155 d83369e1120 ">
                                    <p>removed immediately</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>