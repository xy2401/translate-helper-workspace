<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>SQL for Modeling</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="sql-pattern-matching-data-warehouses.html" title="Previous" type="text/html">
      <link rel="next" href="advanced-analytical-sql-data-warehouses.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-pattern-matching-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="advanced-analytical-sql-data-warehouses.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">Relational Analytics </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL for Modeling</li>
            </ol>
            <a id="GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237" name="GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237"></a>
            
            <h2 id="DWHSG-GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237" class="sect2"><span class="enumeration_chapter">22 </span>SQL for Modeling
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses using SQL modeling, and includes:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C">Overview of SQL Modeling in Data Warehouses</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF">Basic Topics in SQL Modeling</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282">Advanced Topics in SQL Modeling</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-983B5378-4FCA-4452-B615-3A39B491F1E4">Performance Considerations with SQL Modeling</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8757"></a><a id="DWHSG8756"></a><div class="props_rev_3"><a id="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C" name="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C"></a><h3 id="DWHSG-GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C" class="sect3"><span class="enumeration_section">22.1 </span>Overview of SQL Modeling in Data Warehouses
               </h3>
               <div>
                  <p>The <code class="codeph">MODEL</code> clause<a id="d90648e71" class="indexterm-anchor"></a><a id="d90648e73" class="indexterm-anchor"></a> brings a new level of power and flexibility to SQL calculations. With the <code class="codeph">MODEL</code> clause, you can create a multidimensional array from query results and then apply formulas (called rules) to this array to calculate new values. The rules can range from basic arithmetic to simultaneous equations using recursion. For some applications, the <code class="codeph">MODEL</code> clause can replace PC-based spreadsheets. Models in SQL leverage Oracle Database's strengths in scalability, manageability, collaboration, and security. The core query engine can work with unlimited quantities of data. By defining and executing models within the database, users avoid transferring large data sets to and from separate modeling environments. Models can be shared easily across workgroups, ensuring that calculations are consistent for all applications. Just as models can be shared, access can also be controlled precisely with Oracle's security features. With its rich functionality, the <code class="codeph">MODEL</code> clause can enhance all types of applications.
                  </p>
                  <p>The <code class="codeph">MODEL</code> clause enables you to create a multidimensional array by mapping the columns of a query into three groups: partitioning, dimension, and measure columns. These elements perform the following tasks:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Partition columns define the logical blocks of the result set in a way similar to the partitions of the analytical functions described in <a href="sql-analysis-reporting-data-warehouses.html#GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" title="Approximate aggregates are computed using SQL functions that return approximate results. They are used primarily in data exploration queries where exact values are not required and approximations are acceptable.The LISTAGG function orders data within each group based on the ORDER BY clause and then concatenates the values of the measure column.Oracle Database provides a set of SQL functions that return approximate percentile results. These functions can be used to monitor quality, track social media activity, monitor performance, and search for outliers within a data set.">SQL for Analysis and Reporting</a>. Rules in the <code class="codeph">MODEL</code> clause are applied to each partition independent of other partitions. Thus, partitions serve as a boundary point for parallelizing the <code class="codeph">MODEL</code> computation.
                        </p>
                     </li>
                     <li>
                        <p>Dimension columns define the multi-dimensional array and are used to identify cells within a partition. By default, a full combination of dimensions should identify just one cell in a partition. In default mode, they can be considered analogous to the key of a relational table.</p>
                     </li>
                     <li>
                        <p>Measures are equivalent to the measures of a fact table in a star schema. They typically contain numeric values such as sales units or cost. Each cell is accessed by specifying its full combination of dimensions. Note that each partition may have a cell that matches a given combination of dimensions.</p>
                     </li>
                  </ul>
                  <p>The <code class="codeph">MODEL</code> clause enables you to specify rules to manipulate the measure values of the cells in the multi-dimensional array defined by partition and dimension columns. Rules access and update measure column values by directly specifying dimension values. The references used in rules result in a highly readable model. Rules are concise and flexible, and can use wild cards and looping constructs for maximum expressiveness. Oracle Database evaluates the rules in an efficient way, parallelizes the model computation whenever possible, and provides a seamless integration of the <code class="codeph">MODEL</code> clause with other SQL clauses. The <code class="codeph">MODEL</code> clause, thus, is a scalable and manageable way of computing business models in the database.
                  </p>
                  <p><a href="sql-modeling-data-warehouses.html#GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C__I1024102">Figure 22-1</a> offers a conceptual overview of the modeling feature of SQL. The figure has three parts. The top segment shows the concept of dividing a typical table into partition, dimension, and measure columns. The middle segment shows two rules that calculate the value of <code class="codeph">Prod1</code> and <code class="codeph">Prod2</code> for the year 2002. Finally, the third part shows the output of a query that applies the rules to such a table with hypothetical data. The unshaded output is the original data as it is retrieved from the database, while the shaded output shows the rows calculated by the rules. Note that results in partition <code class="codeph">A</code> are calculated independently from results of partition <code class="codeph">B</code>.
                  </p>
                  <div class="figure" id="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C__I1024102">
                     <p class="titleinfigure">Figure 22-1 Model Elements</p><img src="img/dwhsg116.gif" alt="Description of Figure 22-1 follows" title="Description of Figure 22-1 follows" longdesc="img_text/dwhsg116.html"><br><a href="img_text/dwhsg116.html">Description of "Figure 22-1 Model Elements"</a></div>
                  <!-- class="figure" -->
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7">How Data is Processed in a SQL Model</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF">Why Use SQL Modeling in Data Warehouses?</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8">About SQL Modeling Capabilities</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9305"></a><a id="DWHSG8758"></a><div class="props_rev_3"><a id="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7" name="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7"></a><h4 id="DWHSG-GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7" class="sect4"><span class="enumeration_section">22.1.1 </span>How Data is Processed in a SQL Model
                  </h4>
                  <div>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">Figure 22-2</a> <a id="d90648e195" class="indexterm-anchor"></a>shows the flow of processing within a simple <code class="codeph">MODEL</code> clause. In this case, you will follow data through a <code class="codeph">MODEL</code> clause that includes three rules. One of the rules updates an existing value, while the other two create new values for a forecast. The figure shows that the rows of data retrieved by a query are fed into the <code class="codeph">MODEL</code> clause and rearranged into an array. Once the array is defined, rules are applied one by one to the data. The shaded cells in <a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">Figure 22-2</a> represent new data created by the rules and the cells enclosed by ovals represent the source data for the new values. Finally, the data, including both its updated values and newly created values, is rearranged into row form and presented as the results of the query. Note that no data is inserted into any table by this query.
                     </p>
                     <div class="figure" id="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">
                        <p class="titleinfigure">Figure 22-2 Model Flow Processing</p><img src="img/dwhsg120.png" alt="Description of Figure 22-2 follows" title="Description of Figure 22-2 follows" longdesc="img_text/dwhsg120.html"><br><a href="img_text/dwhsg120.html">Description of "Figure 22-2 Model Flow Processing"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="DWHSG8760"></a><div class="props_rev_3"><a id="GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF" name="GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF"></a><h4 id="DWHSG-GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF" class="sect4"><span class="enumeration_section">22.1.2 </span>Why Use SQL Modeling in Data Warehouses?
                  </h4>
                  <div>
                     <p>Oracle modeling enables you to perform sophisticated calculations on your data. A typical case is when you want to apply business rules to data and then generate reports. Because Oracle Database integrates modeling calculations into the database, performance and manageability are enhanced significantly. Consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR(country, 1, 20) country, 
      SUBSTR(product, 1, 15) product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL
  PARTITION BY (country) DIMENSION BY (product, year)
  MEASURES (sales sales)
  RULES 
  (sales['Bounce', 2002] = sales['Bounce', 2001] + sales['Bounce', 2000],
   sales['Y Box', 2002] = sales['Y Box', 2001],
   sales['All_Products', 2002] = sales['Bounce', 2002] + sales['Y Box', 2002])
ORDER BY country, product, year;
</pre><p>This query partitions the data in <code class="codeph">sales_view</code> (which is illustrated in <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>"</span>) on country so that the model computation, as defined by the three rules, is performed on each country. This model calculates the sales of Bounce in 2002 as the sum of its sales in 2000 and 2001, and sets the sales for Y Box in 2002 to the same value as they were in 2001. Also, it introduces a new product category All_Products (<code class="codeph">sales_view</code> does not have the product All_Products) for year 2002 to be the sum of sales of Bounce and Y Box for that year. The output of this query is as follows, where bold text indicates new values:
                     </p><pre class="oac_no_warn" dir="ltr">COUNTRY              PRODUCT               YEAR      SALES
-------------------- --------------- ---------- ----------
Italy                Bounce                1999    2474.78
Italy                Bounce                2000    4333.69
Italy                Bounce                2001     4846.3
<span class="bold">Italy                Bounce                2002    9179.99</span>
...
Italy                Y Box                 1999   15215.16
Italy                Y Box                 2000   29322.89
Italy                Y Box                 2001   81207.55
<span class="bold">Italy                Y Box                 2002   81207.55</span>
...
<span class="bold">Italy                All_Products          2002   90387.54</span>
...
Japan                Bounce                1999     2961.3
Japan                Bounce                2000    5133.53
Japan                Bounce                2001     6303.6
<span class="bold">Japan                Bounce                2002   11437.13</span>
...
Japan                Y Box                 1999   22161.91
Japan                Y Box                 2000   45690.66
Japan                Y Box                 2001   89634.83
<span class="bold">Japan                Y Box                 2002   89634.83</span>
...
<span class="bold">Japan                All_Products          2002  101071.96</span>
...
</pre><p>Note that, while the sales values for Bounce and Y Box exist in the input, the values for All_Products are derived.</p>
                  </div>
               </div><a id="DWHSG8761"></a><div class="props_rev_3"><a id="GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8" name="GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8"></a><h4 id="DWHSG-GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8" class="sect4"><span class="enumeration_section">22.1.3 </span>About SQL Modeling Capabilities
                  </h4>
                  <div>
                     <p>Oracle Database provides the following capabilities with the <code class="codeph">MODEL</code> clause:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Cell addressing using dimension values</p>
                           <p>Measure columns in individual rows are treated like cells in a multi-dimensional array and can be referenced and updated using dimension values. For example, in a fact table <code class="codeph">ft(country, year, sales)</code>, you can designate <code class="codeph">country</code> and <code class="codeph">year</code> to be dimension columns and <code class="codeph">sales</code> to be the measure and reference sales for a given country and year as <code class="codeph">sales[country='Spain', year=1999]</code>. This gives you the sales value for Spain in 1999. You can also use a shorthand form <code class="codeph">sales['Spain', 1999]</code>, which has the same meaning. There are a few semantic differences between these notations, though. See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-9ACD704F-0428-4F49-BF96-47486713E97E">About Cell Referencing in SQL Modeling</a>"</span> for further details.
                           </p>
                        </li>
                        <li>
                           <p>Symbolic array computation</p>
                           <p>You can specify a series of formulas, called rules, to operate on the data. Rules can invoke functions on individual cells or on a set or range of cells. An example involving individual cells is the following:</p><pre class="oac_no_warn" dir="ltr">sales[country='Spain',year=2001] = sales['Spain',2000]+ sales['Spain',1999]
</pre><p>This sets the sales in Spain for the year 2001 to the sum of sales in Spain for 1999 and 2000. An example involving a range of cells is the following:</p><pre class="oac_no_warn" dir="ltr">sales[country='Spain',year=2001] = 
   MAX(sales)['Spain',year BETWEEN 1997 AND 2000]
</pre><p>This sets the sales in Spain for the year 2001 equal to the maximum sales in Spain between 1997 and 2000.</p>
                        </li>
                        <li>
                           <p><code class="codeph">UPSERT</code>, <code class="codeph">UPSERT</code> <code class="codeph">ALL</code>, and <code class="codeph">UPDATE</code> options
                           </p>
                           <p>Using the <code class="codeph">UPSERT</code> option, which is the default, you can create cell values that do not exist in the input data. If the cell referenced exists in the data, it is updated. If the cell referenced does not exist in the data, and the rule uses appropriate notation, then the cell is inserted. The <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> option enables you to have <code class="codeph">UPSERT</code> behavior for a wider variety of rules. The <code class="codeph">UPDATE</code> option, on the other hand, would never insert any new cells.
                           </p>
                           <p>You can specify these options globally, in which case they apply to all rules, or per each rule. If you specify an option at the rule level, it overrides the global option. Consider the following rules:</p><pre class="oac_no_warn" dir="ltr">UPDATE sales['Spain', 1999] = 3567.99,
UPSERT sales['Spain', 2001] = sales['Spain', 2000]+ sales['Spain', 1999]
</pre><p>The first rule updates the cell for sales in Spain for 1999. The second rule updates the cell for sales in Spain for 2001 if it exists, otherwise, it creates a new cell.</p>
                        </li>
                        <li>
                           <p>Wildcard specification of dimensions</p>
                           <p>You can use <code class="codeph">ANY</code> and <code class="codeph">IS</code> <code class="codeph">ANY</code> to specify all values in a dimension. As an example, consider the following statement:
                           </p><pre class="oac_no_warn" dir="ltr">sales[ANY, 2001] = sales['Japan', 2000]
</pre><p>This rule sets the 2001 sales of all countries equal to the sales value of Japan for the year 2000. All values for the dimension, including nulls, satisfy the <code class="codeph">ANY</code> specification. You can also specify this using an <code class="codeph">IS</code> <code class="codeph">ANY</code> predicate as in the following:
                           </p><pre class="oac_no_warn" dir="ltr">sales[country IS ANY, 2001] = sales['Japan', 2000]
</pre></li>
                        <li>
                           <p>Accessing dimension values using the <code class="codeph">CV</code> function
                           </p>
                           <p>You can use the <code class="codeph">CV</code> function on the right side of a rule to access the value of a dimension column of the cell referenced on the left side of a rule. It enables you to combine multiple rules performing similar computation into a single rule, thus resulting in concise specification. For example, you can combine the following rules:
                           </p><pre class="oac_no_warn" dir="ltr">sales[country='Spain', year=2002] = 1.2 * sales['Spain', 2001],
sales[country='Italy', year=2002] = 1.2 * sales['Italy', 2001],
sales[country='Japan', year=2002] = 1.2 * sales['Japan', 2001]
</pre><p>They can be combined into one single rule:</p><pre class="oac_no_warn" dir="ltr">sales[country IN ('Spain', 'Italy', 'Japan'), year=2002] = 1.2 * 
   sales[CV(country), 2001]
</pre><p>Observe that the <code class="codeph">CV</code> function passes the value for the <code class="codeph">country</code> dimension from the left to the right side of the rule.
                           </p>
                        </li>
                        <li>
                           <p>Ordered computation</p>
                           <p>For rules updating a set of cells, the result may depend on the ordering of dimension values. You can force a particular order for the dimension values by specifying an <code class="codeph">ORDER</code> <code class="codeph">BY</code> in the rule. An example is the following rule:
                           </p><pre class="oac_no_warn" dir="ltr">sales[country IS ANY, year BETWEEN 2000 AND 2003] ORDER BY year = 
  1.05 * sales[CV(country), CV(year)-1]
</pre><p>This ensures that the years are referenced in increasing chronological order.</p>
                        </li>
                        <li>
                           <p>Automatic rule ordering</p>
                           <p>Rules in the <code class="codeph">MODEL</code> clause can be automatically ordered based on dependencies among the cells using the <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> keywords. For example, in the following assignments, the last two rules will be processed before the first rule because the first depends on the second and third:
                           </p><pre class="oac_no_warn" dir="ltr">RULES AUTOMATIC ORDER
{sales[c='Spain', y=2001] = sales[c='Spain', y=2000] 
  + sales[c='Spain', y=1999]
sales[c='Spain', y=2000] = 50000,
sales[c='Spain', y=1999] = 40000}
</pre></li>
                        <li>
                           <p>Iterative rule evaluation</p>
                           <p>You can specify iterative rule evaluation, in which case the rules are evaluated iteratively until the termination condition is satisfied. Consider the following specification:</p><pre class="oac_no_warn" dir="ltr">MODEL DIMENSION BY (x) MEASURES (s)
  RULES ITERATE (4) (s[x=1] = s[x=1]/2)
</pre><p>This statement specifies that the formula <code class="codeph">s[x=1] = s[x=1]/2</code> evaluation be repeated four times. The number of iterations is specified in the <code class="codeph">ITERATE</code> option of the <code class="codeph">MODEL</code> clause. It is also possible to specify a termination condition by using an <code class="codeph">UNTIL</code> clause.
                           </p>
                           <p>Iterative rule evaluation is an important tool for modeling recursive relationships between entities in a business application. For example, a loan amount might depend on the interest rate where the interest rate in turn depends on the amount of the loan.</p>
                        </li>
                        <li>
                           <p>Reference models</p>
                           <p>A model can include multiple ref models, which are read-only arrays. Rules can reference cells from different reference models. Rules can update or insert cells in only one multi-dimensional array, which is called the main model. The use of reference models enables you to relate models with different dimensionality. For example, assume that, in addition to the fact table <code class="codeph">ft(country, year, sales)</code>, you have a table with currency conversion ratios <code class="codeph">cr(country, ratio)</code> with <code class="codeph">country</code> as the dimension column and <code class="codeph">ratio</code> as the measure. Each row in this table gives the conversion ratio of that country's currency to that of US dollar. These two tables could be used in rules such as the following:
                           </p><pre class="oac_no_warn" dir="ltr">dollar_sales['Spain',2001] = sales['Spain',2000] * ratio['Spain']
</pre></li>
                        <li>
                           <p>Scalable computation</p>
                           <p>You can partition data and evaluate rules within each partition independent of other partitions. This enables parallelization of model computation based on partitions. For example, consider the following model:</p><pre class="oac_no_warn" dir="ltr">MODEL PARTITION BY (country) DIMENSION BY (year) MEASURES (sales)
  (sales[year=2001] = AVG(sales)[year BETWEEN 1990 AND 2000]
</pre><p>The data is partitioned by country and, within each partition, you can compute the sales in 2001 to be the average of sales in the years between 1990 and 2000. Partitions can be processed in parallel and this results in a scalable execution of the model.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8762"></a><div class="props_rev_3"><a id="GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF" name="GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF"></a><h3 id="DWHSG-GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF" class="sect3"><span class="enumeration_section">22.2 </span>Basic Topics in SQL Modeling
               </h3>
               <div>
                  <p>This section introduces some of the basic ideas and uses for models, and includes:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-562DD586-2629-4890-89FF-DC2D693C10FF">MODEL Clause Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B">Keywords in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-9ACD704F-0428-4F49-BF96-47486713E97E">About Cell Referencing in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9">About Rules for SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181">Order of Evaluation of SQL Modeling Rules</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-E23B515C-A552-40EA-B9D1-BB76AE843663">Global and Local Keywords for SQL Modeling Rules</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1">UPDATE, UPSERT, and UPSERT ALL Behavior</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-921A7D68-3982-460E-A0FC-AD50954710D3">Treatment of NULLs and Missing Cells in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3715019F-674C-4CFA-BEAE-08F4C5757596">About Reference Models in SQL Modeling</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8763"></a><div class="props_rev_3"><a id="GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7" name="GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7"></a><h4 id="DWHSG-GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7" class="sect4"><span class="enumeration_section">22.2.1 </span>Base Schema for SQL Modeling Examples
                  </h4>
                  <div>
                     <p>This chapter's examples are based on the following view <code class="codeph">sales_view</code>, which is derived from the <code class="codeph">sh</code> sample schema.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW sales_view AS
SELECT country_name country, prod_name product, calendar_year year,
  SUM(amount_sold) sales, COUNT(amount_sold) cnt,
  MAX(calendar_year) KEEP (DENSE_RANK FIRST ORDER BY SUM(amount_sold) DESC)
  OVER (PARTITION BY country_name, prod_name) best_year,
  MAX(calendar_year) KEEP (DENSE_RANK LAST ORDER BY SUM(amount_sold) DESC)
  OVER (PARTITION BY country_name, prod_name) worst_year
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND sales.prod_id = products.prod_id AND
  sales.cust_id =customers.cust_id AND customers.country_id=countries.country_id
GROUP BY country_name, prod_name, calendar_year;
</pre><p>This query computes <code class="codeph">SUM</code> and <code class="codeph">COUNT</code> aggregates on the sales data grouped by country, product, and year. It will report for each product sold in a country, the year when the sales were the highest for that product in that country. This is called the <code class="codeph">best_year</code> of the product. Similarly, <code class="codeph">worst_year</code> gives the year when the sales were the lowest.
                     </p>
                  </div>
               </div><a id="DWHSG8765"></a><a id="DWHSG8764"></a><div class="props_rev_3"><a id="GUID-562DD586-2629-4890-89FF-DC2D693C10FF" name="GUID-562DD586-2629-4890-89FF-DC2D693C10FF"></a><h4 id="DWHSG-GUID-562DD586-2629-4890-89FF-DC2D693C10FF" class="sect4"><span class="enumeration_section">22.2.2 </span>MODEL Clause Syntax
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">MODEL</code> clause enables you to define multi-dimensional calculations on the data in the SQL query block. In multi-dimensional applications, a fact table consists of columns that uniquely identify a row with the rest serving as dependent measures or attributes. The <code class="codeph">MODEL</code> clause lets you specify the <code class="codeph">PARTITION</code>, <code class="codeph">DIMENSION</code>, and <code class="codeph">MEASURE</code> columns that define the multi-dimensional array, the rules that operate on this multi-dimensional array, and the processing options.
                        </p>
                        <p>The <code class="codeph">MODEL</code> clause contains a list of updates representing array computation within a partition and is a part of a SQL query block. Its structure is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">MODEL
[&lt;global reference options&gt;]
[&lt;reference models&gt;]
[MAIN &lt;main-name&gt;]
  [PARTITION BY (&lt;cols&gt;)]
  DIMENSION BY (&lt;cols&gt;)
  MEASURES (&lt;cols&gt;)
  [&lt;reference options&gt;]
  [RULES]  &lt;rule options&gt;
  (&lt;rule&gt;, &lt;rule&gt;,.., &lt;rule&gt;)
  &lt;global reference options&gt; ::= &lt;reference options&gt; &lt;ret-opt&gt;
   &lt;ret-opt&gt; ::= RETURN {ALL|UPDATED} ROWS
  &lt;reference options&gt; ::=
  [IGNORE NAV | [KEEP NAV]
  [UNIQUE DIMENSION | UNIQUE SINGLE REFERENCE]
  &lt;rule options&gt; ::=
  [UPDATE | UPSERT | UPSERT ALL]
  [AUTOMATIC ORDER | SEQUENTIAL ORDER]
  [ITERATE (&lt;number&gt;)  [UNTIL &lt;condition&gt;]]
  &lt;reference models&gt; ::= REFERENCE ON &lt;ref-name&gt; ON (&lt;query&gt;)
  DIMENSION BY (&lt;cols&gt;) MEASURES (&lt;cols&gt;) &lt;reference options&gt;
</pre><p>Each rule represents an assignment. Its left side references a cell or a set of cells and the right side can contain expressions involving constants, host variables, individual cells or aggregates over ranges of cells. For example, consider the query in <a href="sql-modeling-data-warehouses.html#GUID-562DD586-2629-4890-89FF-DC2D693C10FF__i1019340">Example 22-1</a>, this is based on the view <code class="codeph">sales_view</code> created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-562DD586-2629-4890-89FF-DC2D693C10FF__i1019340">
                        <p class="titleinexample">Example 22-1 Simple Query with the MODEL Clause</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR(country,1,20) country, SUBSTR(product,1,15) product, year, sales
FROM sales_view
WHERE country in ('Italy', 'Japan')
MODEL
  RETURN UPDATED ROWS
  MAIN simple_model
  PARTITION BY (country)
  DIMENSION BY (product, year)
  MEASURES (sales)
  RULES
   (sales['Bounce', 2001] = 1000,
    sales['Bounce', 2002] = sales['Bounce', 2001] + sales['Bounce', 2000],
    sales['Y Box', 2002] = sales['Y Box', 2001])
ORDER BY country, product, year;
</pre><p>This query defines model computation on the rows from <code class="codeph">sales_view</code> for the countries Italy and Japan. This model has been given the name <code class="codeph">simple_model</code>. It partitions the data on country and defines, within each partition, a two-dimensional array on product and year. Each cell in this array holds the value of the sales measure. The first rule of this model sets the sales of Bounce in year 2001 to 1000. The next two rules define that the sales of Bounce in 2002 are the sum of its sales in years 2001 and 2000, and the sales of Y Box in 2002 are same as that of the previous year 2001.
                        </p>
                        <p>Specifying <code class="codeph">RETURN</code> <code class="codeph">UPDATED</code> <code class="codeph">ROWS</code> makes the preceding query return only those rows that are updated or inserted by the model computation. By default or if you use <code class="codeph">RETURN</code> <code class="codeph">ALL</code> <code class="codeph">ROWS</code>, you would get all rows not just the ones updated or inserted by the <code class="codeph">MODEL</code> clause. The query produces the following output:
                        </p><pre class="oac_no_warn" dir="ltr">COUNTRY              PRODUCT               YEAR      SALES
-------------------- --------------- ---------- ----------
Italy                Bounce                2001       1000
Italy                Bounce                2002    5333.69
Italy                Y Box                 2002   81207.55
Japan                Bounce                2001       1000
Japan                Bounce                2002    6133.53
Japan                Y Box                 2002   89634.83
</pre><p>Note that the <code class="codeph">MODEL</code> clause does not update or insert rows into database tables. The following query illustrates this by showing that <code class="codeph">sales_view</code> has not been altered:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR(country,1,20) country, SUBSTR(product,1,15) product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan');

COUNTRY              PRODUCT               YEAR      SALES
-------------------- --------------- ---------- ----------
Italy                Bounce                1999    2474.78
Italy                Bounce                2000    4333.69
Italy                Bounce                2001     4846.3
...
</pre><p>Observe that the update of the sales value for Bounce in the 2001 done by this <code class="codeph">MODEL</code> clause is not reflected in the database. If you want to update or insert rows in the database tables, you should use the <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">MERGE</code> statements.
                        </p>
                        <p>In the preceding example, columns are specified in the <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>, and <code class="codeph">MEASURES</code> list. You can also specify constants, host variables, single-row functions, aggregate functions, analytical functions, or expressions involving them as partition and dimension keys and measures. However, you must alias them in <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>, and <code class="codeph">MEASURES</code> lists. You must use aliases to refer these expressions in the rules, <code class="codeph">SELECT</code> list, and the query <code class="codeph">ORDER</code> <code class="codeph">BY</code>. The following example shows how to use expressions and aliases:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT country, p product, year, sales, profits
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL
  RETURN UPDATED ROWS
  PARTITION BY (SUBSTR(country,1,20) AS country)
  DIMENSION BY (product AS p, year)
  MEASURES (sales, 0 AS profits)
  RULES
   (profits['Bounce', 2001] = sales['Bounce', 2001] * 0.25,
    sales['Bounce', 2002] = sales['Bounce', 2001] + sales['Bounce', 2000],
    profits['Bounce', 2002] = sales['Bounce', 2002] * 0.35)
ORDER BY country, year;

COUNTRY   PRODUCT    YEAR   SALES         PROFITS
-------   ---------  ----   --------     --------
Italy     Bounce     2001     4846.3     1211.575
Italy     Bounce     2002    9179.99    3212.9965
Japan     Bounce     2001     6303.6       1575.9
Japan     Bounce     2002   11437.13    4002.9955
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>Note that the alias "0 AS profits" initializes all cells of the profits measure to 0. See <a href="../sqlrf/SELECT.html#SQLRF55254" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information regarding <code class="codeph">MODEL</code> clause syntax.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG0221"></a><div class="props_rev_3"><a id="GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B" name="GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B"></a><h4 id="DWHSG-GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B" class="sect4"><span class="enumeration_section">22.2.3 </span>Keywords in SQL Modeling
                  </h4>
                  <div>
                     <p>This section defines <a id="d90648e833" class="indexterm-anchor"></a><a id="d90648e837" class="indexterm-anchor"></a>keywords used in SQL modeling. It contains the following topics:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68">Assigning Values and Null Handling</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F">Calculation Definition</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8766"></a><div class="props_rev_3"><a id="GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68" name="GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68"></a><h5 id="DWHSG-GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68" class="sect5"><span class="enumeration_section">22.2.3.1 </span>Assigning Values and Null Handling
                     </h5>
                     <div>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">UPSERT</code></p>
                              <p>This updates the measure values of existing cells. If the cells do not exist, and the rule has appropriate notation, they are inserted. If any of the cell references are symbolic, no cells are inserted.</p>
                           </li>
                           <li>
                              <p><code class="codeph">UPSERT</code> <code class="codeph">ALL</code></p>
                              <p>This is similar to <code class="codeph">UPSERT</code>, except it allows a broader set of rule notation to insert new cells.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">UPDATE</code></p>
                              <p>This updates existing cell values. If the cell values do not exist, no updates are done.</p>
                           </li>
                           <li>
                              <p><code class="codeph">IGNORE</code> <code class="codeph">NAV</code></p>
                              <p>For numeric cells, this treats values that are not available as 0. This means that a cell not supplied to <code class="codeph">MODEL</code> by the query result set will be treated as a zero for the calculation. This can be used at a global level for all measures in a model.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">KEEP</code> <code class="codeph">NAV</code></p>
                              <p>This keeps cell values that are not available unchanged. It is useful for making exceptions when <code class="codeph">IGNORE</code> <code class="codeph">NAV</code> is specified at the global level. This is the default, and can be omitted.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8767"></a><div class="props_rev_3"><a id="GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F" name="GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F"></a><h5 id="DWHSG-GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F" class="sect5"><span class="enumeration_section">22.2.3.2 </span>Calculation Definition
                     </h5>
                     <div>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">MEASURES</code></p>
                                 <p>The set of values that are modified or created by the model.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">RULES</code></p>
                                 <p>The expressions that assign values to measures.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code></p>
                                 <p>This causes all rules to be evaluated in an order based on their logical dependencies.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code></p>
                                 <p>This causes rules to be evaluated in the order they are written. This is the default.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code></p>
                                 <p>This is the default, and it means that the combination of <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> columns in the <code class="codeph">MODEL</code> clause must uniquely identify each and every cell in the model. This uniqueness is explicitly verified at query execution when necessary, in which case it may increase processing time.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code></p>
                                 <p>The <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> clauses uniquely identify single point references on the right-hand side of the rules. This may reduce processing time by avoiding explicit checks for uniqueness at query execution.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">RETURN</code> <code class="codeph">[ALL|UPDATED] ROWS</code></p>
                                 <p>This enables you to specify whether to return all rows selected or only those rows updated by the rules. The default is <code class="codeph">ALL</code>, while the alternative is <code class="codeph">UPDATED</code> <code class="codeph">ROWS</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8768"></a><div class="props_rev_3"><a id="GUID-9ACD704F-0428-4F49-BF96-47486713E97E" name="GUID-9ACD704F-0428-4F49-BF96-47486713E97E"></a><h4 id="DWHSG-GUID-9ACD704F-0428-4F49-BF96-47486713E97E" class="sect4"><span class="enumeration_section">22.2.4 </span>About Cell Referencing in SQL Modeling
                  </h4>
                  <div>
                     <p>In <a id="d90648e1065" class="indexterm-anchor"></a><a id="d90648e1067" class="indexterm-anchor"></a><a id="d90648e1071" class="indexterm-anchor"></a>the <code class="codeph">MODEL</code> clause, a relation is treated as a multi-dimensional array of cells. A cell of this multi-dimensional array contains the measure values and is indexed using <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys, within each partition defined by the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keys. For example, consider the following query run on the view <code class="codeph">sales_view</code> created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, sales, best_year, best_year
FROM sales_view
MODEL 
  PARTITION BY (country)
  DIMENSION BY (product, year)
  MEASURES (sales, best_year)  
  (&lt;rules&gt; ..)
ORDER BY country, product, year;
</pre><p>This partitions the data by country and defines within each partition, a two-dimensional array on product and year. The cells of this array contain two measures: <code class="codeph">sales</code> and <code class="codeph">best_year</code>.
                     </p>
                     <p>Accessing the measure value of a cell by specifying the <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys constitutes a cell reference. An example of a cell reference is as follows:
                     </p><pre class="oac_no_warn" dir="ltr">sales[product= 'Bounce', year=2000]
</pre><p>Here, you are accessing the sales value of a cell referenced by product Bounce and the year 2000. In a cell reference, you can specify <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys either symbolically as in the preceding cell reference or positionally as in <code class="codeph">sales['Bounce', 2000]</code>.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D">Symbolic Dimension References</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0">Positional Dimension References</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8769"></a><div class="props_rev_3"><a id="GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D" name="GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D"></a><h5 id="DWHSG-GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D" class="sect5"><span class="enumeration_section">22.2.4.1 </span>Symbolic Dimension References
                     </h5>
                     <div>
                        <p>A symbolic dimension reference (or symbolic reference) is one in which <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> key values are specified with a boolean expression. For example, the cell reference <code class="codeph">sales[year &gt;= 2001]</code> has a symbolic reference on the <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> key year and specifies all cells whose year value is greater than or equal to 2001. An example of symbolic references on product and year dimensions is <code class="codeph">sales[product = 'Bounce', year &gt;= 2001]</code>.
                        </p>
                     </div>
                  </div><a id="DWHSG8770"></a><div class="props_rev_3"><a id="GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0" name="GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0"></a><h5 id="DWHSG-GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0" class="sect5"><span class="enumeration_section">22.2.4.2 </span>Positional Dimension References
                     </h5>
                     <div>
                        <p>A positional dimension reference (or positional reference, in short) is a constant or a constant expression specified for a dimension. For example, the cell reference <code class="codeph">sales['Bounce']</code> has a positional reference on the product dimension and accesses sales value for the product Bounce. The constants (or constant expressions) in a cell reference are matched to the column order specified for <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys. The following example shows the usage of positional references on dimensions:
                        </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2001]
</pre><p>Assuming <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys to be product and year in that order, it accesses the sales value for Bounce and 2001.
                        </p>
                        <p>Based on how they are specified, cell references are either single cell or multi-cell reference.</p>
                     </div>
                  </div>
               </div><a id="DWHSG8771"></a><div class="props_rev_3"><a id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9" name="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9"></a><h4 id="DWHSG-GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9" class="sect4"><span class="enumeration_section">22.2.5 </span>About Rules for SQL Modeling
                  </h4>
                  <div>
                     <p>Mod<a id="d90648e1249" class="indexterm-anchor"></a><a id="d90648e1253" class="indexterm-anchor"></a><a id="d90648e1257" class="indexterm-anchor"></a><a id="d90648e1261" class="indexterm-anchor"></a>el computation is expressed in rules that manipulate the cells of the multi-dimensional array defined by <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>, and <code class="codeph">MEASURES</code> clauses. A rule is an assignment statement whose left side represents a cell or a range of cells and whose right side is an expression involving constants, bind variables, individual cells or an aggregate function on a range of cells. Rules can use wild cards and looping constructs for maximum expressiveness. An example of a rule is the following:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2003] = 1.2 * sales['Bounce', 2002]
</pre><p>This rule says that, for the product Bounce, the sales for 2003 are 20% more than that of 2002.</p>
                     <p>Note that this rule refers to single cells on both the left and right side and is relatively simple. Complex rules can be written with multi-cell references, aggregates, and nested cell references.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-9904F367-8805-42F3-A186-9F3A19B31E35">Single Cell References</p>
                        <p>This type of rule involves single cell reference on the left side with constants and single cell references on the right side. Some examples are the following:</p><pre class="oac_no_warn" dir="ltr">sales[product='Finding Fido', year=2003] = 100000
sales['Bounce', 2003] = 1.2 * sales['Bounce', 2002]
sales[product='Finding Fido', year=2004] = 0.8 * sales['Standard Mouse Pad',
  year=2003] + sales['Finding Fido', 2003]</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-775B96EC-1BD4-403F-BA70-0C90E7A9B9CE">Multi-Cell References on the Right Side</p>
                        <p>Multi-cell references can be used on the right side of rules, in which case an aggregate function needs to be applied on them to convert them to a single value. All existing aggregate functions including analytic aggregates (inverse percentile functions, hypothetical rank and distribution functions and so on) and statistical aggregates (correlation, regression slope and so on), and user-defined aggregate functions can be used. Windowing functions such as <code class="codeph">RANK</code> and <code class="codeph">MOVING_AVG</code> can be used as well. For example, the rule to compute the sales of Bounce for 2003 to be 100 more than the maximum sales in the period 1998 to 2002 would be:
                        </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2003] = 100 + MAX(sales)['Bounce', year BETWEEN 1998 AND 2002]
</pre><p>The following example illustrates the usage of inverse percentile function <code class="codeph">PERCENTILE_DISC</code>. It projects Finding Fido sales for year 2003 to be 30% more than the median sales for products Finding Fido, Standard Mouse Pad, and Boat for all years prior to 2003.
                        </p><pre class="oac_no_warn" dir="ltr">sales[product='Finding Fido', year=2003] = 1.3 * 
  PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY sales) [product IN ('Finding
  Fido','Standard Mouse Pad','Boat'), year &lt; 2003]
</pre><p>Aggregate functions can appear only on the right side of rules. Arguments to the aggregate function can be constants, bind variables, measures of the <code class="codeph">MODEL</code> clause, or expressions involving them. For example, the rule computes the sales of Bounce for 2003 to be the weighted average of its sales for years from 1998 to 2002 would be:
                        </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2003] = 
   AVG(sales * weight)['Bounce', year BETWEEN 1998 AND 2002]</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-48BADB7D-56FE-4641-965A-479E84079982">Multi-Cell References on the Left Side</p>
                        <p>Rules can have multi-cell references on the left side as in the following:</p><pre class="oac_no_warn" dir="ltr">sales['Standard Mouse Pad', year &gt; 2000] = 
   0.2 * sales['Finding Fido', year=2000]
</pre><p>This rule accesses a range of cells on the left side (cells for product Standard Mouse Pad and year greater than 2000) and assigns sales measure of each such cell to the value computed by the right side expression. Computation by the preceding rule is described as "sales of Standard Mouse Pad for years after 2000 is 20% of the sales of Finding Fido for year 2000". This computation is simple in that the right side cell references and hence the right side expression are the same for all cells referenced on the left.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-E88F99EC-1294-416B-8AF2-20E253853A7C">Use of the CV Function</p>
                        <p>The use of the <code class="codeph">CV</code> function provides the capability of relative indexing where dimension values of the cell referenced on the left side are used on the right side cell references. The <code class="codeph">CV</code> function takes a dimension key as its argument, so it provides the value of a <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> key of the cell currently referenced on the left side. As an example, consider the following:
                        </p><pre class="oac_no_warn" dir="ltr">sales[product='Standard Mouse Pad', year&gt;2000] = 
  sales[CV(product), CV(year)] + 0.2 * sales['Finding Fido', 2000]
</pre><p>When the left side references the cell Standard Mouse Pad and 2001, the right side expression would be:</p><pre class="oac_no_warn" dir="ltr">sales['Standard Mouse Pad', 2001] + 0.2 * sales['Finding Fido', 2000]
</pre><p>Similarly, when the left side references the cell Standard Mouse Pad and 2002, the right side expression you would evaluate is:</p><pre class="oac_no_warn" dir="ltr">sales['Standard Mouse Pad', 2002] + 0.2 * sales['Finding Fido', 2000]
</pre><p>It is also possible to use <code class="codeph">CV</code> without any argument as in <code class="codeph">CV()</code> and in which case, positional referencing is implied. <code class="codeph">CV()</code> may be used outside a cell reference, but when used in this way its argument must contain the name of the dimension desired. You can also write the preceding rule as:
                        </p><pre class="oac_no_warn" dir="ltr">sales[product='Standard Mouse Pad', year&gt;2000] = 
  sales[CV(), CV()] + 0.2 * sales['Finding Fido', 2000]
</pre><p>The first <code class="codeph">CV()</code> reference corresponds to <code class="codeph">CV(product)</code> and the latter corresponds to <code class="codeph">CV(year)</code>. The <code class="codeph">CV</code> function can be used only in right side cell references. Another example of the usage of <code class="codeph">CV</code> function is the following:
                        </p><pre class="oac_no_warn" dir="ltr">sales[product IN ('Finding Fido','Standard Mouse Pad','Bounce'), year 
  BETWEEN 2002 AND 2004] = 2 * sales[CV(product), CV(year)-10]
</pre><p>This rule says that, for products Finding Fido, Standard Mouse Pad, and Bounce, the sales for years between 2002 and 2004 will be twice of what their sales were 10 years ago.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-5B68F18B-B873-4FF0-9107-EB0D4B1EED6C">Use of the ANY Wildcard</p>
                        <p>You can use the wild card <code class="codeph">ANY</code> in cell references to match all dimension values including nulls. <code class="codeph">ANY</code> may be used on both the left and right side of rules. For example, a rule for the computation "sales of all products for 2003 are 10% more than their sales for 2002" would be the following:
                        </p><pre class="oac_no_warn" dir="ltr">sales[product IS ANY, 2003] = 1.1 * sales[CV(product), 2002]
</pre><p>Using positional references, it can also be written as:</p><pre class="oac_no_warn" dir="ltr">sales[ANY, 2003] = 1.1 * sales[CV(), 2002]
</pre><p>Note that <code class="codeph">ANY</code> is treated as a symbolic reference even if it is specified positionally, because it really means that (<code class="codeph">dimension IS NOT NULL OR dimension IS NULL</code>).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-9372BE77-A412-401A-A7B0-40707153CE17">Nested Cell References</p>
                        <p>Cell references can be nested. In other words, cell references providing dimension values can be used within a cell reference. An example, assuming <code class="codeph">best_year</code> is a measure, for nested cell reference is given as follows:
                        </p><pre class="oac_no_warn" dir="ltr">sales[product='Bounce', year = best_year['Bounce', 2003]]
</pre><p>Here, the nested cell reference <code class="codeph">best_year['Bounce', 2003]</code> provides value for the dimension key year and is used in the symbolic reference for year. Measures <code class="codeph">best_year</code> and <code class="codeph">worst_year</code> give, for each year (<code class="codeph">y</code>) and product (<code class="codeph">p</code>) combination, the year for which sales of product <code class="codeph">p</code> were highest or lowest. The following rule computes the sales of Standard Mouse Pad for 2003 to be the average of Standard Mouse Pad sales for the years in which Finding Fido sales were highest and lowest:
                        </p><pre class="oac_no_warn" dir="ltr">sales['Standard Mouse Pad', 2003] = (sales[CV(), best_year['Finding Fido',
  CV(year)]] + sales[CV(), worst_year['Finding Fido', CV(year)]]) / 2
</pre><p>Oracle Database allows only one level of nesting, and only single cell references can be used as nested cell references. Aggregates on multi-cell references cannot be used in nested cell references.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8778"></a><div class="props_rev_3"><a id="GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181" name="GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181"></a><h4 id="DWHSG-GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181" class="sect4"><span class="enumeration_section">22.2.6 </span>Order of Evaluation of SQL Modeling Rules
                  </h4>
                  <div>
                     <p>By defau<a id="d90648e1476" class="indexterm-anchor"></a><a id="d90648e1480" class="indexterm-anchor"></a>lt, rules are evaluated in the order they appear in the <code class="codeph">MODEL</code> clause. You can specify an optional keyword <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> in the <code class="codeph">MODEL</code> clause to make such an evaluation order explicit. SQL models with sequential rule order of evaluation are called sequential order models. For example, the following <code class="codeph">RULES</code> specification makes Oracle Database evaluate rules in the specified sequence:
                     </p><pre class="oac_no_warn" dir="ltr">RULES SEQUENTIAL ORDER
 (sales['Bounce', 2001] = 
    sales['Bounce', 2000] + sales['Bounce', 1999],   --Rule R1
  sales['Bounce', 2000] = 50000,                     --Rule R2
  sales['Bounce', 1999] = 40000)                     --Rule R3
</pre><p>Alternatively, the option <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> enables Oracle Database to determine the order of evaluation of rules automatically. Oracle examines the cell references within rules and finds dependencies among rules. If cells referenced on the left side of rule <code class="codeph">R1</code> are referenced on the right side of another rule <code class="codeph">R2</code>, then <code class="codeph">R2</code> is considered to depend on <code class="codeph">R1</code>. In other words, rule <code class="codeph">R1</code> should be evaluated before rule <code class="codeph">R2</code>. If you specify <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> in the preceding example as in:
                     </p><pre class="oac_no_warn" dir="ltr">RULES AUTOMATIC ORDER
 (sales['Bounce', 2001] = sales['Bounce', 2000] + sales['Bounce', 1999],
  sales['Bounce', 2000] = 50000,
  sales['Bounce', 1999] = 40000)
</pre><p>Rules 2 and 3 are evaluated, in some arbitrary order, before rule 1. This is because rule 1 depends on rules 2 and 3 and hence need to be evaluated after rules 2 and 3. The order of evaluation among second and third rules can be arbitrary as they do not depend on one another. The order of evaluation among rules independent of one another can be arbitrary. SQL models with an automatic order of evaluation, as in the preceding fragment, are called automatic order models.</p>
                     <p>In an automatic order model, multiple assignments to the same cell are not allowed. In other words, measure of a cell can be assigned only once. Oracle Database will return an error in such cases as results would be non-deterministic. For example, the following rule specification will generate an error as <code class="codeph">sales['Bounce', 2001]</code> is assigned more than once:
                     </p><pre class="oac_no_warn" dir="ltr">RULES AUTOMATIC ORDER
 (sales['Bounce', 2001] = sales['Bounce', 2000] + sales['Bounce', 1999],
  sales['Bounce', 2001] = 50000,
  sales['Bounce', 2001] = 40000)
</pre><p>The rules assigning the sales of product Bounce for 2001 do not depend on one another and hence, no particular evaluation order can be fixed among them. This leads to non-deterministic results as the evaluation order is arbitrary - <code class="codeph">sales['Bounce', 2001]</code> can be 40000 or 50000 or sum of Bounce sales for years 1999 and 2000. Oracle Database prevents this by disallowing multiple assignments when <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> is specified. However, multiple assignments are fine in sequential order models. If <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> was specified instead of <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> in the preceding example, the result of <code class="codeph">sales['Bounce', 2001]</code> would be 40000.
                     </p>
                  </div>
               </div><a id="DWHSG8779"></a><div class="props_rev_3"><a id="GUID-E23B515C-A552-40EA-B9D1-BB76AE843663" name="GUID-E23B515C-A552-40EA-B9D1-BB76AE843663"></a><h4 id="DWHSG-GUID-E23B515C-A552-40EA-B9D1-BB76AE843663" class="sect4"><span class="enumeration_section">22.2.7 </span>Global and Local Keywords for SQL Modeling Rules
                  </h4>
                  <div>
                     <p>You can specify an <code class="codeph">UPDATE</code>, <code class="codeph">UPSERT</code>, <code class="codeph">UPSERT</code> <code class="codeph">ALL</code>, <code class="codeph">IGNORE</code> <code class="codeph">NAV</code>, and <code class="codeph">KEEP</code> <code class="codeph">NAV</code> option at the global level in the <code class="codeph">RULES</code> clause in which case all rules operate in the respective mode. These options can be specified at a local level with each rule and in which case, they override the global behavior. For example, in the following specification:
                     </p><pre class="oac_no_warn" dir="ltr">RULES UPDATE 
(UPDATE s['Bounce',2001] = sales['Bounce',2000] + sales['Bounce',1999],
 UPSERT s['Y Box', 2001] = sales['Y Box', 2000] + sales['Y Box', 1999],
   sales['Mouse Pad', 2001] = sales['Mouse Pad', 2000] +
   sales['Mouse Pad',1999])
</pre><p>The <code class="codeph">UPDATE</code> option is specified at the global level so, the first and third rules operate in update mode. The second rule operates in upsert mode as an <code class="codeph">UPSERT</code> keyword is specified with that rule. Note that no option was specified for the third rule and hence it inherits the update behavior from the global option.
                     </p>
                  </div>
               </div><a id="DWHSG0222"></a><div class="props_rev_3"><a id="GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1" name="GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1"></a><h4 id="DWHSG-GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1" class="sect4"><span class="enumeration_section">22.2.8 </span>UPDATE, UPSERT, and UPSERT ALL Behavior
                  </h4>
                  <div>
                     <p>You <a id="d90648e1656" class="indexterm-anchor"></a><a id="d90648e1658" class="indexterm-anchor"></a><a id="d90648e1660" class="indexterm-anchor"></a>can determine how cells in rules behave by choosing whether to have <code class="codeph">UPDATE</code>, <code class="codeph">UPSERT</code>, or <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> semantics. By default, rules in the <code class="codeph">MODEL</code> clause have <code class="codeph">UPSERT</code> semantics, though you can specify an optional <code class="codeph">UPSERT</code> keyword to make the upsert semantic explicit.
                     </p>
                     <p>The following sections discuss these three types of behavior:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4">UPDATE Behavior</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA">UPSERT Behavior</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A">UPSERT ALL Behavior</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8780"></a><div class="props_rev_3"><a id="GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4" name="GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4"></a><h5 id="DWHSG-GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4" class="sect5"><span class="enumeration_section">22.2.8.1 </span>UPDATE Behavior
                     </h5>
                     <div>
                        <p>The <code class="codeph">UPDATE</code> option forces strict update mode. In this mode, the rule is ignored if the cell it references on the left side does not exist. If the cell referenced on the left side of a rule exists, then its measure is updated with the value of the right side expression. Otherwise, if a cell reference is positional, a new cell is created (that is, inserted into the multi-dimensional array) with the measure value equal to the value of the right side expression. If a cell reference is not positional, it will not insert cells. Note that if there are any symbolic references in a cell's specification, inserts are not possible in an upsert rule. For example, consider the following rule:
                        </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2003] = sales['Bounce', 2001] + sales ['Bounce', 2002]
</pre><p>The cell for product Bounce and year 2003, if it exists, gets updated with the sum of Bounce sales for years 2001 and 2002, otherwise, it gets created. If you had created the same rule using any symbolic references, no updates would be performed, as in the following:</p><pre class="oac_no_warn" dir="ltr">sales[prod= 'Bounce', year= 2003] = sales['Bounce', 2001] + sales ['Bounce', 2002]</pre></div>
                  </div><a id="DWHSG8781"></a><div class="props_rev_3"><a id="GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA" name="GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA"></a><h5 id="DWHSG-GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA" class="sect5"><span class="enumeration_section">22.2.8.2 </span>UPSERT Behavior
                     </h5>
                     <div>
                        <p>Using <code class="codeph">UPSERT</code> creates a new cell corresponding to the one referenced on the left side of the rule when the cell is missing, and the cell reference contains only positional references qualified by constants. Note that cell references created with <code class="codeph">FOR</code> loops (described in <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282">Advanced Topics in SQL Modeling</a>"</span>) are treated as positional references, so the values <code class="codeph">FOR</code> loops create will be used to insert new cells. Assuming you do not have cells for years greater than 2003, consider the following rule:
                        </p><pre class="oac_no_warn" dir="ltr">UPSERT sales['Bounce', year = 2004] = 1.1 * sales['Bounce', 2002]
</pre><p>This would not create any new cell because of the symbolic reference year = 2004. However, consider the following:</p><pre class="oac_no_warn" dir="ltr">UPSERT sales['Bounce', 2004] = 1.1 * sales['Bounce', 2002]
</pre><p>This would create a new cell for product Bounce for year 2004. On a related note, new cells will not be created if any of the references is <code class="codeph">ANY</code>. This is because <code class="codeph">ANY</code> is a predicate that qualifies all dimensional values including <code class="codeph">NULL</code>. If there is a reference <code class="codeph">ANY</code> for a dimension <code class="codeph">d</code>, then it means the same thing as the predicate (<code class="codeph">d IS NOT NULL </code><code class="codeph">OR</code> <code class="codeph">d IS NULL)</code>.
                        </p>
                        <p>If an <code class="codeph">UPSERT</code> rule uses <code class="codeph">FOR</code> loops in its left side cell references, the list of upsert cells is generated by performing a cross product of all the distinct values for each dimension. Although <code class="codeph">UPSERT</code> with <code class="codeph">FOR</code> loops can be used to densify dimensions (see <span class="q">"<a href="sql-analysis-reporting-data-warehouses.html#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">Data Densification for Reporting</a>"</span>), it is generally preferable to densify using the partitioned outer join operation.
                        </p>
                     </div>
                  </div><a id="DWHSG8782"></a><div class="props_rev_3"><a id="GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A" name="GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A"></a><h5 id="DWHSG-GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A" class="sect5"><span class="enumeration_section">22.2.8.3 </span>UPSERT ALL Behavior
                     </h5>
                     <div>
                        <p><code class="codeph">UPSERT</code> <code class="codeph">ALL</code> behavior allows model rules with existential predicates (comparisons, <code class="codeph">IN</code>, <code class="codeph">ANY</code>, and so on) in their left side to have <code class="codeph">UPSERT</code> behavior. As an example, the following uses <code class="codeph">ANY</code> and creates Bay Area as the combination of San Francisco, San Jose, and Oakland:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT product, time, city, s sales
FROM <span class="italic">cube_subquery</span>
MODEL PARTITION BY (product)
DIMENSION BY (time, city) MEASURES(sales s
RULES UPSERT ALL
(s[ANY, 'Bay Area'] =
   s[CV(), 'San Francisco'] + s[CV(), 'San Jose'] + s[CV(), 'Oakland']
s['2004', ANY] = s['2002', CV()] + s['2003', CV()]);
</pre><p>In this example, the first rule simply inserts a Bay Area cell for each distinct time value, and the second rule inserts a 2004 cell for each distinct city value including Bay Area. This example is relatively simple as the existential predicates used on the left side are <code class="codeph">ANY</code> predicates, but you can also use <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> with more complex calculations.
                        </p>
                        <p>It is important to understand exactly what the <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> operation does, especially in cases where there is more than one symbolic dimension reference. Note that the behavior is different than the behavior of an <code class="codeph">UPSERT</code> rule that uses <code class="codeph">FOR</code> loops.
                        </p>
                        <p>When evaluating an <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> rule, Oracle Database performs the following steps to create a list of cell references to be upserted:
                        </p>
                        <ol>
                           <li>
                              <p>Find the existing cells that satisfy all the symbolic predicates of the cell reference.</p>
                           </li>
                           <li>
                              <p>Using just the dimensions that have symbolic references, find the distinct dimension value combinations of these cells.</p>
                           </li>
                           <li>
                              <p>Perform a cross product of these value combinations with the dimension values specified through positional references.</p>
                           </li>
                           <li>
                              <p>The results of Step 3 are then used to upsert new cells into the array.</p>
                           </li>
                        </ol>
                     </div><a id="DWHSG9413"></a><div class="props_rev_3"><a id="GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5" name="GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5"></a><h6 id="DWHSG-GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5" class="sect6"><span class="enumeration_section">22.2.8.3.1 </span>Example: UPSERT ALL Behavior
                        </h6>
                        <div>
                           <p>To illustrate the four steps described in <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A">UPSERT ALL Behavior</a>"</span>, here is a brief example using abstracted data and a model with three dimensions. Consider a model dimensioned by (<code class="codeph">product</code>, <code class="codeph">time</code>, <code class="codeph">city</code>) with a measure called <code class="codeph">sales</code>. You wish to upsert new sales values for the city of <code class="codeph">z</code>, and these sales values are copied from those of the city of <code class="codeph">y</code>.
                           </p><pre class="oac_no_warn" dir="ltr">UPSERT ALL sales[ANY, ANY, 'z']= sales[CV(product),CV(time),'y']
</pre><p>Our source data set has these four rows:</p><pre class="oac_no_warn" dir="ltr">PROD    TIME   CITY   SALES
   1    2002      x      10
   1    2003      x      15
   2    2002      y      21
   2    2003      y      24
</pre><p>The following explains the details of the four steps, applied to this data:</p>
                           <ol>
                              <li>
                                 <p>Because the symbolic predicates of the rule are <code class="codeph">ANY</code>, any of the rows shown in this example is acceptable.
                                 </p>
                              </li>
                              <li>
                                 <p>The distinct dimension combinations of cells with symbolic predicates that match the condition are: (1, 2002), (1, 2003), (2, 2002), and (2, 2003).</p>
                              </li>
                              <li>
                                 <p>You find the cross product of these dimension combinations with the cells specified with positional references. In this case, it is simply a cross product with the value <code class="codeph">z</code>, and the resulting cell references are: (1, 2002, z), (1, 2003, z), (2, 2002, z), and (2, 2003, z).
                                 </p>
                              </li>
                              <li>
                                 <p>The cells listed in Step 3 will be upserted, with sales calculated based on the city <code class="codeph">y</code>. Because there are no values for product 1 in city <code class="codeph">y</code>, those cells created for product 1 will have <code class="codeph">NULL</code> as their sales value. Of course, a different rule might have generated non-<code class="codeph">NULL</code> results for all the new cells. Our result set includes the four original rows plus four new rows:
                                 </p>
                              </li>
                           </ol><pre class="oac_no_warn" dir="ltr">PROD    TIME   CITY    SALES
   1    2002      x       10
   1    2003      x       15
   2    2002      y       21
   2    2003      y       24
   1    2002      z     NULL
   1    2003      z     NULL
   2    2002      z       21
   2    2003      z       24
</pre><p>It is important to note that these results are not a cross product using all values of all dimensions. If that were the case, you would have cells such as (1,2002, y) and (2,2003, x). Instead, the results here are created using dimension combinations found in existing rows.</p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8783"></a><div class="props_rev_3"><a id="GUID-921A7D68-3982-460E-A0FC-AD50954710D3" name="GUID-921A7D68-3982-460E-A0FC-AD50954710D3"></a><h4 id="DWHSG-GUID-921A7D68-3982-460E-A0FC-AD50954710D3" class="sect4"><span class="enumeration_section">22.2.9 </span>Treatment of NULLs and Missing Cells in SQL Modeling
                  </h4>
                  <div>
                     <p>Applications using models would not only have to deal with non-deterministic values for a cell measure in the form of <code class="codeph">NULL</code>, but also with non-determinism in the form of missing cells. A cell, referenced by a single cell reference, that is missing in the data is called a missing cell. The <code class="codeph">MODEL</code> clause provides a default treatment for nulls and missing cells that is consistent with the ANSI SQL standard and also provides options to treat them in other useful ways according to business logic, for example, to treat nulls as zero for arithmetic operations.
                     </p>
                     <p>By default, <code class="codeph">NULL</code> cell measure values are treated the same way as nulls are treated elsewhere in SQL. For example, in the following rule:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2001] = sales['Bounce', 1999] + sales['Bounce', 2000]
</pre><p>The right side expression would evaluate to <code class="codeph">NULL</code> if Bounce sales for one of the years 1999 and 2000 is <code class="codeph">NULL</code>. Similarly, aggregate functions in rules would treat <code class="codeph">NULL</code> values in the same way as their regular behavior where <code class="codeph">NULL</code> values are ignored during aggregation.
                     </p>
                     <p>Missing cells are treated as cells with <code class="codeph">NULL</code> measure values. For example, in the preceding rule, if the cell for Bounce and 2000 is missing, then it is treated as a <code class="codeph">NULL</code> value and the right side expression would evaluate to <code class="codeph">NULL</code>.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4">Distinguishing Missing Cells from NULLs</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF">Use Defaults for Missing Cells and NULLs</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-BA310B2D-1395-4424-9C3C-89173CE17601">Using NULLs in a Cell Reference</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8784"></a><div class="props_rev_3"><a id="GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4" name="GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4"></a><h5 id="DWHSG-GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4" class="sect5"><span class="enumeration_section">22.2.9.1 </span>Distinguishing Missing Cells from NULLs
                     </h5>
                     <div>
                        <div class="section">
                           <p>The functions <code class="codeph">PRESENTV</code> and <code class="codeph">PRESENTNNV</code> enable you to identify missing cells and distinguish them from <code class="codeph">NULL</code> values. These functions take a single cell reference and two expressions as arguments as in <code class="codeph">PRESENTV(cell, expr1, expr2)</code>. <code class="codeph">PRESENTV</code> returns the first expression <code class="codeph">expr1</code> if the cell <code class="codeph">cell</code> is existent in the data input to the <code class="codeph">MODEL</code> clause. Otherwise, it returns the second expression <code class="codeph">expr2</code>. For example, consider the following:
                           </p><pre class="oac_no_warn" dir="ltr">PRESENTV(sales['Bounce', 2000], 1.1*sales['Bounce', 2000], 100)
</pre><p>If the cell for product Bounce and year 2000 exists, it returns the corresponding sales multiplied by 1.1, otherwise, it returns 100. Note that if sales for the product Bounce for year 2000 is <code class="codeph">NULL</code>, the preceding specification would return <code class="codeph">NULL</code>.
                           </p>
                           <p>The <code class="codeph">PRESENTNNV</code> function not only checks for the presence of a cell but also whether it is <code class="codeph">NULL</code> or not. It returns the first expression <code class="codeph">expr1</code> if the cell exists and is not <code class="codeph">NULL</code>, otherwise, it returns the second expression <code class="codeph">expr2</code>. For example, consider the following:
                           </p><pre class="oac_no_warn" dir="ltr">PRESENTNNV(sales['Bounce', 2000], 1.1*sales['Bounce', 2000], 100)
</pre><p>This would return <code class="codeph">1.1*sales['Bounce', 2000]</code> if <code class="codeph">sales['Bounce', 2000]</code> exists and is not <code class="codeph">NULL</code>. Otherwise, it returns 100.
                           </p>
                           <p>Applications can use the <code class="codeph">IS PRESENT</code> predicate in their model to check the presence of a cell in an explicit fashion.This predicate returns <code class="codeph">TRUE</code> if cell exists and <code class="codeph">FALSE</code> otherwise. The preceding example using <code class="codeph">PRESENTNNV</code> can be written using <code class="codeph">IS</code> <code class="codeph">PRESENT</code> as:
                           </p><pre class="oac_no_warn" dir="ltr">CASE WHEN sales['Bounce', 2000] IS PRESENT AND sales['Bounce', 2000] IS NOT NULL
THEN 1.1 * sales['Bounce', 2000]
ELSE 100
END
</pre><p>The <code class="codeph">IS PRESENT</code> predicate, like the <code class="codeph">PRESENTV</code> and <code class="codeph">PRESENTNNV</code> functions, checks for cell existence in the input data, that is, the data as existed before the execution of the <code class="codeph">MODEL</code> clause. This enables you to initialize multiple measures of a cell newly inserted by an <code class="codeph">UPSERT</code> rule. For example, if you want to initialize sales and profit values of a cell, if it does not exist in the data, for product Bounce and year 2003 to 1000 and 500 respectively, you can do so by the following:
                           </p><pre class="oac_no_warn" dir="ltr">RULES
 (UPSERT sales['Bounce', 2003] =
    PRESENTV(sales['Bounce', 2003], sales['Bounce', 2003], 1000),
  UPSERT profit['Bounce', 2003] = 
    PRESENTV(profit['Bounce', 2003], profit['Bounce', 2003], 500))
</pre><p>The <code class="codeph">PRESENTV</code> functions used in this formulation return <code class="codeph">TRUE</code> or <code class="codeph">FALSE</code> based on the existence of the cell in the input data. If the cell for Bounce and 2003 gets inserted by one of the rules, based on their evaluation order, <code class="codeph">PRESENTV</code> function in the other rule would still evaluate to <code class="codeph">FALSE</code>. You can consider this behavior as a preprocessing step to rule evaluation that evaluates and replaces all <code class="codeph">PRESENTV</code> and <code class="codeph">PRESENTNNV</code> functions and <code class="codeph">IS</code> <code class="codeph">PRESENT</code> predicate by their respective values.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8785"></a><div class="props_rev_3"><a id="GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF" name="GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF"></a><h5 id="DWHSG-GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF" class="sect5"><span class="enumeration_section">22.2.9.2 </span>Use Defaults for Missing Cells and NULLs
                     </h5>
                     <div>
                        <p>The <code class="codeph">MODEL</code> clause, by default, treats missing cells as cells with <code class="codeph">NULL</code> measure values. An optional <code class="codeph">KEEP</code> <code class="codeph">NAV</code> keyword can be specified in the <code class="codeph">MODEL</code> clause to get this behavior.If your application wants to default missing cells and nulls to some values, you can do so by using <code class="codeph">IS</code> <code class="codeph">PRESENT</code>, <code class="codeph">IS</code> <code class="codeph">NULL</code> predicates and <code class="codeph">PRESENTV</code>, <code class="codeph">PRESENTNNV</code> functions. But it may become cumbersome if you have lot of single cell references and rules. You can use <code class="codeph">IGNORE</code> <code class="codeph">NAV</code> option instead of the default <code class="codeph">KEEP</code> <code class="codeph">NAV</code> option to default nulls and missing cells to:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>0 for numeric data</p>
                           </li>
                           <li>
                              <p>Empty string for character/string data</p>
                           </li>
                           <li>
                              <p>01-JAN-2001 for data type data</p>
                           </li>
                           <li>
                              <p><code class="codeph">NULL</code> for all other data types
                              </p>
                           </li>
                        </ul>
                        <p>Consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT product, year, sales
FROM sales_view
WHERE country = 'Poland'
MODEL
  DIMENSION BY (product, year) MEASURES (sales sales) IGNORE NAV
  RULES UPSERT
  (sales['Bounce', 2003] = sales['Bounce', 2002] + sales['Bounce', 2001]);
</pre><p>In this, the input to the <code class="codeph">MODEL</code> clause does not have a cell for product Bounce and year 2002. Because of <code class="codeph">IGNORE</code> <code class="codeph">NAV</code> option, <code class="codeph">sales['Bounce', 2002]</code> value would default to 0 (as sales is of numeric type) instead of <code class="codeph">NULL</code>. Thus, <code class="codeph">sales['Bounce', 2003]</code> value would be same as that of <code class="codeph">sales['Bounce', 2001]</code>.
                        </p>
                     </div>
                  </div><a id="DWHSG8786"></a><div class="props_rev_3"><a id="GUID-BA310B2D-1395-4424-9C3C-89173CE17601" name="GUID-BA310B2D-1395-4424-9C3C-89173CE17601"></a><h5 id="DWHSG-GUID-BA310B2D-1395-4424-9C3C-89173CE17601" class="sect5"><span class="enumeration_section">22.2.9.3 </span>Using NULLs in a Cell Reference
                     </h5>
                     <div>
                        <div class="section">
                           <p>To use <code class="codeph">NULL</code> values in a cell reference, you must use one of the following:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Positional reference using wild card <code class="codeph">ANY</code> as in <code class="codeph">sales[ANY]</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Symbolic reference using the <code class="codeph">IS</code> <code class="codeph">ANY</code> predicate as in <code class="codeph">sales[product IS ANY]</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Positional reference of <code class="codeph">NULL</code> as in <code class="codeph">sales[NULL]</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Symbolic reference using <code class="codeph">IS</code> <code class="codeph">NULL</code> predicate as in <code class="codeph">sales[product IS NULL]</code>.
                                 </p>
                              </li>
                           </ul>
                           <p>Note that symbolic reference <code class="codeph">sales[product = NULL]</code> would not test for nulls in the product dimension. This behavior conforms with the standard handling of nulls by SQL.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8787"></a><div class="props_rev_3"><a id="GUID-3715019F-674C-4CFA-BEAE-08F4C5757596" name="GUID-3715019F-674C-4CFA-BEAE-08F4C5757596"></a><h4 id="DWHSG-GUID-3715019F-674C-4CFA-BEAE-08F4C5757596" class="sect4"><span class="enumeration_section">22.2.10 </span>About Reference Models in SQL Modeling
                  </h4>
                  <div>
                     <p>In addition to the multi-dimensional array on which rules operate, which is called the main model, one or more read-only multi-dimensional arrays, called reference models, can be created and referenced in the <code class="codeph">MODEL</code> clause to act as look-up tables for the main model. Like the main model, a reference model is defined over a query block and has <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> and <code class="codeph">MEASURES</code> clauses to indicate its dimensions and measures respectively. A reference model is created by the following subclause:
                     </p><pre class="oac_no_warn" dir="ltr">REFERENCE model_name ON (query) DIMENSION BY (cols) MEASURES (cols) 
   [reference options]
</pre><p>Like the main model, a multi-dimensional array for the reference model is built before evaluating the rules. But, unlike the main model, reference models are read-only in that their cells cannot be updated and no new cells can be inserted after they are built. Thus, the rules in the main model can access cells of a reference model, but they cannot update or insert new cells into the reference model. The following is an example using a currency conversion table as a reference model:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE dollar_conv_tbl(country VARCHAR2(30), exchange_rate NUMBER);
INSERT INTO dollar_conv_tbl VALUES('Poland', 0.25);
INSERT INTO dollar_conv_tbl VALUES('France', 0.14);
...
</pre><p>Now, to convert the projected sales of Poland and France for 2003 to the US dollar, you can use the dollar conversion table as a reference model as in the following command. The view sales_view was created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, year, sales, dollar_sales
FROM sales_view 
GROUP BY country, year
MODEL
  REFERENCE conv_ref ON (SELECT country, exchange_rate FROM dollar_conv_tbl)
    DIMENSION BY (country) MEASURES (exchange_rate) IGNORE NAV
  MAIN conversion
    DIMENSION BY (country, year)
    MEASURES (SUM(sales) sales, SUM(sales) dollar_sales) IGNORE NAV
RULES
(dollar_sales['France', 2003] = sales[CV(country), 2002] * 1.02 * 
   conv_ref.exchange_rate['France'], 
   dollar_sales['Poland', 2003] = 
      sales['Poland', 2002] * 1.05 * exchange_rate['Poland']);
</pre><p>Observe in this example that:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A one dimensional reference model named <code class="codeph">conv_ref</code> is created on rows from the table <code class="codeph">dollar_conv_tbl</code> and that its measure <code class="codeph">exchange_rate</code> has been referenced in the rules of the main model.
                           </p>
                        </li>
                        <li>
                           <p>The main model (called <code class="codeph">conversion</code>) has two dimensions, country and year, whereas the reference model <code class="codeph">conv_ref</code> has one dimension, country.
                           </p>
                        </li>
                        <li>
                           <p>Different styles of accessing the <code class="codeph">exchange_rate</code> measure of the reference model. For France, it is rather explicit with <code class="codeph">model_name.measure_name</code> notation <code class="codeph">conv_ref.exchange_rate</code>, whereas for Poland, it is a simple <code class="codeph">measure_name</code> reference <code class="codeph">exchange_rate</code>. The former notation needs to be used to resolve any ambiguities in column names across main and reference models.
                           </p>
                        </li>
                     </ul>
                     <p>Growth rates, in this example, are hard coded in the rules. The growth rate for France is 2% and that of Poland is 5%. But they could come from a separate table and you can have a reference model defined on top of that. Assume that you have a <code class="codeph">growth_rate(country, year, rate)</code> table defined as the following:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE growth_rate_tbl(country VARCHAR2(30), 
   year NUMBER, growth_rate NUMBER);
INSERT INTO growth_rate_tbl VALUES('Poland', 2002, 2.5);
INSERT INTO growth_rate_tbl VALUES('Poland', 2003, 5);
...
INSERT INTO growth_rate_tbl VALUES('France', 2002, 3);
INSERT INTO growth_rate_tbl VALUES('France', 2003, 2.5);
</pre><p>Then the following query computes the projected sales in dollars for 2003 for all countries:</p><pre class="oac_no_warn" dir="ltr">SELECT country, year, sales, dollar_sales
FROM sales_view 
GROUP BY country, year 
MODEL
  REFERENCE conv_ref ON
          (SELECT country, exchange_rate FROM dollar_conv_tbl)
           DIMENSION BY (country c) MEASURES (exchange_rate) IGNORE NAV
  REFERENCE growth_ref ON 
          (SELECT country, year, growth_rate FROM growth_rate_tbl)
           DIMENSION BY (country c, year y) MEASURES (growth_rate) IGNORE NAV
  MAIN projection
   DIMENSION BY (country, year) MEASURES (SUM(sales) sales, 0 dollar_sales)
  IGNORE NAV 
  RULES  
  (dollar_sales[ANY, 2003] = sales[CV(country), 2002] * 
   growth_rate[CV(country), CV(year)] * 
   exchange_rate[CV(country)]);
</pre><p>This query shows the capability of the <code class="codeph">MODEL</code> clause in dealing with and relating objects of different dimensionality. Reference model <code class="codeph">conv_ref</code> has one dimension while the reference model <code class="codeph">growth_ref</code> and the main model have two dimensions. Dimensions in the single cell references on reference models are specified using the <code class="codeph">CV</code> function thus relating the cells in main model with the reference model. This specification, in effect, is performing a relational join between main and reference models.
                     </p>
                     <p>Reference models also help you convert keys to sequence numbers, perform computations using sequence numbers (for example, where a prior period would be used in a subtraction operation), and then convert sequence numbers back to keys. For example, consider a view that assigns sequence numbers to years:</p><pre class="oac_no_warn" dir="ltr">CREATE or REPLACE VIEW year_2_seq (i, year) AS 
SELECT ROW_NUMBER() OVER (ORDER BY calendar_year), calendar_year 
FROM (SELECT DISTINCT calendar_year FROM TIMES); 
</pre><p>This view can define two lookup tables: integer-to-year <code class="codeph">i2y</code>, which maps sequence numbers to integers, and year-to-integer <code class="codeph">y2i</code>, which performs the reverse mapping. The references <code class="codeph">y2i.i[year]</code> and <code class="codeph">y2i.i[year] - 1</code> return sequence numbers of the current and previous years respectively and the reference <code class="codeph">i2y.y[y2i.i[year]-1]</code> returns the year key value of the previous year. The following query demonstrates such a usage of reference models:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, sales, prior_period
FROM sales_view
MODEL
  REFERENCE y2i ON (SELECT year, i FROM year_2_seq) DIMENSION BY (year y) 
   MEASURES (i)
  REFERENCE i2y ON (SELECT year, i FROM year_2_seq) DIMENSION BY (i) 
   MEASURES (year y)
  MAIN projection2 PARTITION BY (country)
  DIMENSION BY (product, year) 
  MEASURES (sales, CAST(NULL AS NUMBER) prior_period)
(prior_period[ANY, ANY] = sales[CV(product), i2y.y[y2i.i[CV(year)]-1]])
ORDER BY country, product, year;
</pre><p>Nesting of reference model cell references is evident in the preceding example. Cell reference on the reference model <code class="codeph">y2i</code> is nested inside the cell reference on <code class="codeph">i2y</code> which, in turn, is nested in the cell reference on the main SQL model. There is no limitation on the levels of nesting you can have on reference model cell references. However, you can only have two levels of nesting on the main SQL model cell references.
                     </p>
                     <p>Finally, the following are restrictions on the specification and usage of reference models:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Reference models cannot have a <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause.
                           </p>
                        </li>
                        <li>
                           <p>The query block on which the reference model is defined cannot be correlated to an outer query.</p>
                        </li>
                        <li>
                           <p>Reference models must be named and their names should be unique.</p>
                        </li>
                        <li>
                           <p>All references to the cells of a reference model should be single cell references.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8788"></a><div class="props_rev_3"><a id="GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282" name="GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282"></a><h3 id="DWHSG-GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282" class="sect3"><span class="enumeration_section">22.3 </span>Advanced Topics in SQL Modeling
               </h3>
               <div>
                  <p>This section discusses more advanced topics in SQL modeling, and includes:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-13071F40-90AB-4E4F-AA33-A8827236939D">FOR Loops in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B">Iterative Models in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999">Rule Dependency in AUTOMATIC ORDER Models</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-2523C916-C744-46B1-8D53-DF03204EAF85">Ordered Rules in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-6B79CCE3-69E2-444C-84BE-50672330C546">Analytic Functions in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8">Unique Dimensions Versus Unique Single References in SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AD6A9B81-492F-4724-9517-7758C4A98365">Rules and Restrictions when Using SQL for Modeling</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG0223"></a><div class="props_rev_3"><a id="GUID-13071F40-90AB-4E4F-AA33-A8827236939D" name="GUID-13071F40-90AB-4E4F-AA33-A8827236939D"></a><h4 id="DWHSG-GUID-13071F40-90AB-4E4F-AA33-A8827236939D" class="sect4"><span class="enumeration_section">22.3.1 </span>FOR Loops in SQL Modeling
                  </h4>
                  <div>
                     <p>Th<a id="d90648e2680" class="indexterm-anchor"></a>e <code class="codeph">MODEL</code> clause provides a <code class="codeph">FOR</code> construct that can be used inside rules to express computations more compactly. It can be used on both the left and right side of a rule. <code class="codeph">FOR</code> loops are treated as positional references when on the left side of a rule. For example, consider the following computation, which estimates the sales of several products for 2004 to be 10% higher than their sales for 2003:
                     </p><pre class="oac_no_warn" dir="ltr">RULES UPSERT
(sales['Bounce', 2004] = 1.1 * sales['Bounce', 2003],
 sales['Standard Mouse Pad', 2004] = 1.1 * sales['Standard Mouse Pad', 2003],
...
 sales['Y Box', 2004] = 1.1 * sales['Y Box', 2003])
</pre><p>The <code class="codeph">UPSERT</code> option is used in this computation so that cells for these products and 2004 will be inserted if they are not previously present in the multi-dimensional array. This is rather bulky as you have to have as many rules as there are products. Using the <code class="codeph">FOR</code> construct, this computation can be represented compactly and with exactly the same semantics as in:
                     </p><pre class="oac_no_warn" dir="ltr">RULES UPSERT 
(sales[FOR product IN ('Bounce', 'Standard Mouse Pad', ..., 'Y Box'), 2004] = 
   1.1 * sales[CV(product), 2003])
</pre><p>If you write a specification similar to this, but without the <code class="codeph">FOR</code> keyword as in the following:
                     </p><pre class="oac_no_warn" dir="ltr">RULES UPSERT 
(sales[product IN ('Bounce', 'Standard Mouse Pad', ..., 'Y Box'), 2004] = 
   1.1 * sales[CV(product), 2003])
</pre><p>You would get <code class="codeph">UPDATE</code> semantics even though you have specified <code class="codeph">UPSERT</code>. In other words, existing cells will be updated but no new cells will be created by this specification. This is because the multi-cell reference on product is a symbolic reference and symbolic references do not permit insertion of new cells. You can view a <code class="codeph">FOR</code> construct as a macro that generates multiple rules with positional references from a single rule, thus preserving the <code class="codeph">UPSERT</code> semantics. Conceptually, the following rule:
                     </p><pre class="oac_no_warn" dir="ltr">sales[FOR product IN ('Bounce', 'Standard Mouse Pad', ..., 'Y Box'),
      FOR year IN (2004, 2005)] = 1.1 * sales[CV(product), CV(year)-1]
</pre><p>Can be treated as an ordered collection of the following rules:</p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2004] = 1.1 * sales[CV(product), CV(year)-1],
sales['Bounce', 2005] = 1.1 * sales[CV(product), CV(year)-1],
sales['Standard Mouse Pad', 2004] = 1.1 * 
  sales[CV(product), CV(year)-1],
sales['Standard Mouse Pad', 2005] = 1.1 * sales[CV(product),
 CV(year)-1],
...
sales['Y Box', 2004] = 1.1 * sales[CV(product), CV(year)-1],
sales['Y Box', 2005] = 1.1 * sales[CV(product), CV(year)-1]
</pre><p>The <code class="codeph">FOR</code> construct in the preceding examples is of type <code class="codeph">FOR</code> <code class="codeph">dimension</code> <code class="codeph">IN</code> <span class="italic"><code class="codeph">(list of values)</code></span>. Values in the list should be single-value expressions such as expressions of constants, single-cell references, and so on. In the last example, there are separate <code class="codeph">FOR</code> constructs on product and year. It is also possible to specify all dimensions using one <code class="codeph">FOR</code> construct and specify the values using multi-column <code class="codeph">IN</code> lists. Consider for example, if you want only to estimate sales for Bounce in 2004, Standard Mouse Pad in 2005 and Y Box in 2004 and 2005. This can be formulated as the following:
                     </p><pre class="oac_no_warn" dir="ltr">sales[FOR (product, year) IN (('Bounce', 2004), ('Standard Mouse Pad', 2005),
  ('Y Box', 2004), ('Y Box', 2005))] = 
     1.1 * sales[CV(product), CV(year)-1]
</pre><p>This <code class="codeph">FOR</code> construct should be of the form <code class="codeph">FOR (d1, ..., dn) IN ((d1_val1, ..., dn_val1), ..., (d1_valm, ..., dn_valm)]</code> when there are n dimensions <code class="codeph">d1, ..., dn</code> and <code class="codeph">m</code> values in the list.
                     </p>
                     <p>In some cases, the list of values for a dimension in <code class="codeph">FOR</code> can be retrieved from a table or a subquery. Oracle Database provides a type of <code class="codeph">FOR</code> construct as in <code class="codeph">FOR</code> <code class="codeph">dimension</code> <code class="codeph">IN</code> <span class="italic"><code class="codeph">(subquery)</code></span> to handle these cases. For example, assume that the products of interest are stored in a table <code class="codeph">interesting_products</code>, then the following rule estimates their sales in 2004 and 2005:
                     </p><pre class="oac_no_warn" dir="ltr">sales[FOR product IN (SELECT product_name FROM interesting_products)
    FOR year IN (2004, 2005)] = 1.1 * sales[CV(product), CV(year)-1]
</pre><p>As another example, consider the scenario where you want to introduce a new country, called <code class="codeph">new_country</code>, with sales that mimic those of Poland for all products and years where there are sales in Poland. This is accomplished by issuing the following statement:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, s
FROM sales_view
MODEL
DIMENSION BY (country, product, year)
MEASURES (sales s) IGNORE NAV
RULES UPSERT
(s[FOR (country, product, year) IN 
       (SELECT DISTINCT 'new_country', product, year
        FROM sales_view
        WHERE country = 'Poland')] = s['Poland',CV(),CV()])
ORDER BY country, year, product;
</pre><p>The view sales_view was created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>.
                     </p>
                     <p>Note the multi-column <code class="codeph">IN</code>-list produced by evaluating the subquery in this specification. The subquery used to obtain the <code class="codeph">IN</code>-list cannot be correlated to outer query blocks.
                     </p>
                     <p>Note that the upsert list created by the rule is a cross-product of the distinct values for each dimension. For example, if there are 10 values for country, 5 values for year, and 3 values for product, you will generate an upsert list containing 150 cells.</p>
                     <p>If you know that the values of interest come from a discrete domain, you can use <code class="codeph">FOR</code> construct <code class="codeph">FOR dimension FROM value1 TO value2 [INCREMENT | DECREMENT] value3</code>. This specification results in values between <code class="codeph">value1</code> and <code class="codeph">value2</code> by starting from <code class="codeph">value1</code> and incrementing (or decrementing) by <code class="codeph">value3</code>. The values <code class="codeph">value1</code>, <code class="codeph">value2</code>, and <code class="codeph">value3</code> should be single-value expressions. For example, the following rule:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', FOR year FROM 2001 TO 2005 INCREMENT 1] = 
  sales['Bounce', year=CV(year)-1] * 1.2
</pre><p>This is semantically equivalent to the following rules in order:</p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2001] = sales['Bounce', 2000] * 1.2,
sales['Bounce', 2002] = sales['Bounce', 2001] * 1.2,
...
sales['Bounce', 2005] = sales['Bounce', 2004] * 1.2
</pre><p>This kind of <code class="codeph">FOR</code> construct can be used for dimensions of numeric, date and datetime data types. The type for increment/decrement expression <code class="codeph">value3</code> should be numeric for numeric dimensions and can be numeric or interval for dimensions of date or datetime types. Also, <code class="codeph">value3</code> should be positive. Oracle Database returns an error if you use <code class="codeph">FOR year FROM 2005 TO 2001 INCREMENT -1</code>. You should use either <code class="codeph">FOR year FROM 2005 TO 2001 DECREMENT 1</code> or <code class="codeph">FOR year FROM 2001 TO 2005 INCREMENT 1</code>.
                     </p>
                     <p>To generate string values, you can use the <code class="codeph">FOR</code> construct <code class="codeph">FOR dimension LIKE string FROM value1 TO value2 [INCREMENT | DECREMENT] value3</code>. The string <code class="codeph">string</code> should contain only one <code class="codeph">%</code> character. This specification results in string by replacing <code class="codeph">%</code> with values between <code class="codeph">value1</code> and <code class="codeph">value2</code> with appropriate increment/decrement value <code class="codeph">value3</code>. For example, consider the following rule:
                     </p><pre class="oac_no_warn" dir="ltr">sales[FOR product LIKE 'product-%' FROM 1 TO 3 INCREMENT 1, 2003] = 
sales[CV(product), 2002] * 1.2
</pre><p>This is equivalent to the following:</p><pre class="oac_no_warn" dir="ltr">sales['product-1', 2003] = sales['product-1', 2002] * 1.2,
sales['product-2', 2003] = sales['product-2', 2002] * 1.2,
sales['product-3', 2003] = sales['product-3', 2002] * 1.2
</pre><p>In <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> models, rules represented by a <code class="codeph">FOR</code> construct are evaluated in the order they are generated. On the contrary, rule evaluation order would be dependency based if <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> is specified. For example, the evaluation order for the rules represented by the rule:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', FOR year FROM 2004 TO 2001 DECREMENT 1] = 
  1.1 * sales['Bounce', CV(year)-1]
</pre><p>For <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> models, the rules would be generated in this order:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2004] = 1.1 * sales['Bounce', 2003],
sales['Bounce', 2003] = 1.1 * sales['Bounce', 2002],
sales['Bounce', 2002] = 1.1 * sales['Bounce', 2001],
sales['Bounce', 2001] = 1.1 * sales['Bounce', 2000]
</pre><p>While for <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> models, the order would be equivalent to:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2001] = 1.1 * sales['Bounce', 2000],
sales['Bounce', 2002] = 1.1 * sales['Bounce', 2001],
sales['Bounce', 2003] = 1.1 * sales['Bounce', 2002],
sales['Bounce', 2004] = 1.1 * sales['Bounce', 2003]</pre><div class="infoboxnotealso" id="GUID-13071F40-90AB-4E4F-AA33-A8827236939D__GUID-8A4D96B2-B038-4C73-9D9B-0C93CC9466B5">
                        <p class="notep1">See Also:</p>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-10CEB733-E962-4506-BD07-9583251D339A">Evaluation of Formulas with FOR Loops</a></p>
                     </div>
                  </div><a id="DWHSG8789"></a><div class="props_rev_3"><a id="GUID-10CEB733-E962-4506-BD07-9583251D339A" name="GUID-10CEB733-E962-4506-BD07-9583251D339A"></a><h5 id="DWHSG-GUID-10CEB733-E962-4506-BD07-9583251D339A" class="sect5"><span class="enumeration_section">22.3.1.1 </span>Evaluation of Formulas with FOR Loops
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">FOR</code> loop construct provides an iterative mechanism to generate single-value references for a dimension or for all dimensions (in the case of multi-column for <code class="codeph">IN</code> lists). The evaluation of a formula with <code class="codeph">FOR</code> loops on its left side basically consists of evaluation of the right side of the formula for each single-value reference generated by these <code class="codeph">FOR</code> loops and assigning the result to the specified cell with this single-value reference. The generation of these single reference values is called "unfolding the <code class="codeph">FOR</code> loop". These unfolded cells are evaluated in the order they are generated during the unfolding process.
                           </p>
                           <p>How unfolding is performed depends on the <code class="codeph">UPSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">UPDATE</code> <code class="codeph">ALL</code> behavior specified for the rule and the specific characteristics of the rule. To understand this, a discussion of two stages of query processing is needed: query plan creation and query execution. Query plan creation is a stage where certain rule references are resolved in order to create an efficient query execution plan. Query execution is the stage where all remaining unresolved references must be determined. <code class="codeph">FOR</code> loops may be unfolded at either query plan generation or at query execution. Below the details of the unfolding decision are discussed.
                           </p>
                           <div class="infoboxnotealso" id="GUID-10CEB733-E962-4506-BD07-9583251D339A__GUID-26F0C850-E639-40E1-A537-14FA3CEC3B33">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-E00D151E-FA8B-48A9-9B21-62723787C075">Unfolding For UPDATE and UPSERT Rules</a></p>
                                 </li>
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-8A41F257-4B7D-4837-A99D-7BA897711617">Unfolding For UPSERT ALL: Rules</a></p>
                                 </li>
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-DDC92205-4633-4F44-A768-5D3E17254B9F">Restrictions on Using FOR Loop Expressions on the Left Side of Formulas</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG8790"></a><div class="props_rev_3"><a id="GUID-E00D151E-FA8B-48A9-9B21-62723787C075" name="GUID-E00D151E-FA8B-48A9-9B21-62723787C075"></a><h6 id="DWHSG-GUID-E00D151E-FA8B-48A9-9B21-62723787C075" class="sect6"><span class="enumeration_section">22.3.1.1.1 </span>Unfolding For UPDATE and UPSERT Rules
                        </h6>
                        <div>
                           <div class="section">
                              <p>When using <code class="codeph">UPDATE</code> or <code class="codeph">UPSERT</code> rules, if unfolding the left side of a rule is guaranteed to generate single cell references, the unfolding is done at query execution. If the unfolding process cannot generate single cell references, unfolding is performed at query plan creation and a copy of the same formula for each generated reference by the unfolding process is created. For example, the unfolding of the following formula occurs at query execution as unfolding generates single cell references:
                              </p><pre class="oac_no_warn" dir="ltr">sales[FOR product IN ('prod1', 'prod2'), 2003] = sales[CV(product), 2002] * 1.2
</pre><p>However, consider the following formula, where unfolding reference values do not produce single value references due to the existence of a predicate on another dimension:</p><pre class="oac_no_warn" dir="ltr">sales[FOR product in ('prod1', 'prod2'), year &gt;= 2003]  
   = sales[CV(product), 2002] * 1.2
</pre><p>There is no single-value reference on the year dimension, so even when the <code class="codeph">FOR</code> loop is unfolded on the product dimension, there will be no single-value references on the left side of this formula. This means that the unfolding occurs at query plan creation and physically replace the original formula with the following formulas:
                              </p><pre class="oac_no_warn" dir="ltr">sales['prod1', year &gt;= 2003]  = sales[CV(product), 2002] * 1.2,
sales['prod2', year &gt;= 2003]  = sales[CV(product), 2002] * 1.2
</pre><p>The analysis and optimizations performed within the <code class="codeph">MODEL</code> clause are done after unfolding at query plan creation (if that is what occurs), so, from that point on, everything is as if the multiple rules are specified explicitly in the <code class="codeph">MODEL</code> clause. By performing unfolding at query plan creation in these cases, more accurate analysis and better optimization of formula evaluation is achieved. One thing to note is that there may be an increase in the number of formulas and, if this increase pushes the total number of formulas beyond the maximum limit, Oracle Database signals an error.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="DWHSG8791"></a><div class="props_rev_3"><a id="GUID-8A41F257-4B7D-4837-A99D-7BA897711617" name="GUID-8A41F257-4B7D-4837-A99D-7BA897711617"></a><h6 id="DWHSG-GUID-8A41F257-4B7D-4837-A99D-7BA897711617" class="sect6"><span class="enumeration_section">22.3.1.1.2 </span>Unfolding For UPSERT ALL: Rules
                        </h6>
                        <div>
                           <div class="section">
                              <p>Rules with <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> behavior have a very different approach to unfolding <code class="codeph">FOR</code> loops. No matter what predicates are used, an <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> rule will unfold <code class="codeph">FOR</code> loops at query execution. This behavior avoids certain FOR loop restrictions discussed in the next section. However, there is a trade-off of fewer restrictions versus more optimized query plans. An <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> rule tends toward slower performance than a similar <code class="codeph">UPSERT</code> or <code class="codeph">UPDATE</code> rule, and this should be considered when designing models.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="DWHSG8792"></a><div class="props_rev_3"><a id="GUID-DDC92205-4633-4F44-A768-5D3E17254B9F" name="GUID-DDC92205-4633-4F44-A768-5D3E17254B9F"></a><h6 id="DWHSG-GUID-DDC92205-4633-4F44-A768-5D3E17254B9F" class="sect6"><span class="enumeration_section">22.3.1.1.3 </span>Restrictions on Using FOR Loop Expressions on the Left Side of Formulas
                        </h6>
                        <div>
                           <div class="section">
                              <p>Restrictions on the use of <code class="codeph">FOR</code> loop constructs are determined based on whether the unfolding takes place at query plan creation or at query execution. If a formula with <code class="codeph">FOR</code> loops on its left side is unfolded at query plan creation (due to the reasons explained in the previous section), the expressions that need to be evaluated for unfolding must be expressions of constants whose values are available at query plan creation. For example, consider the following statement:
                              </p><pre class="oac_no_warn" dir="ltr">sales[For product like 'prod%' from ITERATION_NUMBER 
to ITERATION_NUMBER+1, year &gt;= 2003] =  sales[CV(product), 2002]*1.2
</pre><p>If this rule does not have <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> specified for its behavior, it is unfolded at query plan creation. Because the value of the <code class="codeph">ITERATION_NUMBER</code> is not known at query plan creation, and the value is needed to evaluate start and end expressions, Oracle Database signals an error unless that rule is unfolded at query execution. However, the following rule would be unfolded at query plan creation without any errors: the value of <code class="codeph">ITERATION_NUMBER</code> is not needed for unfolding in this case, even though it appears as an expression in the <code class="codeph">FOR</code> loop:
                              </p><pre class="oac_no_warn" dir="ltr">sales[For product in ('prod'||ITERATION_NUMBER, 'prod'||(ITERATION_NUMBER+1)),
 year &gt;= 2003] =  sales[CV(product), 2002]*1.2
</pre><p>Expressions that have any of the following conditions cannot be evaluated at query plan creation:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>nested cell references</p>
                                 </li>
                                 <li>
                                    <p>reference model look-ups</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ITERATION_NUMBER</code> references
                                    </p>
                                 </li>
                              </ul>
                              <p>Rules with <code class="codeph">FOR</code> loops that require the results of such expressions causes an error if unfolded at query plan creation. However, these expressions will not cause any error if unfolding is done at query execution.
                              </p>
                              <p>If a formula has subqueries in its <code class="codeph">FOR</code> loop constructs and this formula requires compile-time unfolding, these subqueries are evaluated at query plan creation so that unfolding can happen. Evaluating a subquery at query plan creation can render a cursor non-sharable, which means the same query may need to be recompiled every time it is issued. If unfolding of such a formula is deferred to query execution, no compile-time evaluation is necessary and the formula has no impact on the sharability of the cursor.
                              </p>
                              <p>Subqueries in the <code class="codeph">FOR</code> loops of a formula can reference tables in the <code class="codeph">WITH</code> clause if the formula is to be unfolded at query execution. If the formula has to be unfolded at query plan creation, Oracle Database signals an error.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8793"></a><div class="props_rev_3"><a id="GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B" name="GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B"></a><h4 id="DWHSG-GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B" class="sect4"><span class="enumeration_section">22.3.2 </span>Iterative Models in SQL Modeling
                  </h4>
                  <div>
                     <p>Using the <code class="codeph">ITERATE</code> option of the <code class="codeph">MODEL</code> clause, you can evaluate rules iteratively for a certain number of times, which you can specify as an argument to the <code class="codeph">ITERATE</code> clause. <code class="codeph">ITERATE</code> can be specified only for <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> models and such models are referred to as iterative models. For example, consider the following:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT x, s FROM DUAL
MODEL 
  DIMENSION BY (1 AS x) MEASURES (1024 AS s)
  RULES UPDATE ITERATE (4)
(s[1] = s[1]/2);
</pre><p>In Oracle, the table <code class="codeph">DUAL</code> has only one row. Hence this model defines a 1-dimensional array, dimensioned by x with a measure <code class="codeph">s</code>, with a single element <code class="codeph">s[1] = 1024</code>. The rule <code class="codeph">s[1] = s[1]/2</code> evaluation will be repeated four times. The result of this query is a single row with values 1 and 64 for columns <code class="codeph">x</code> and <code class="codeph">s</code> respectively. The number of iterations arguments for the <code class="codeph">ITERATE</code> clause should be a positive integer constant. Optionally, you can specify an early termination condition to stop rule evaluation before reaching the maximum iteration. This condition is specified in the <code class="codeph">UNTIL</code> subclause of <code class="codeph">ITERATE</code> and is checked at the end of an iteration. So, you will have at least one iteration when <code class="codeph">ITERATE</code> is specified. The syntax of the <code class="codeph">ITERATE</code> clause is:
                     </p><pre class="oac_no_warn" dir="ltr">ITERATE (number_of_iterations) [ UNTIL (condition) ]
</pre><p>Iterative evaluation stops either after finishing the specified number of iterations or when the termination condition evaluates to <code class="codeph">TRUE</code>, whichever comes first.
                     </p>
                     <p>In some cases, you may want the termination condition to be based on the change, across iterations, in value of a cell. Oracle Database provides a mechanism to specify such conditions in that it enables you to access cell values as they existed before and after the current iteration in the <code class="codeph">UNTIL</code> condition. Oracle's <code class="codeph">PREVIOUS</code> function takes a single cell reference as an argument and returns the measure value of the cell as it existed after the previous iteration. You can also access the current iteration number by using the system variable <code class="codeph">ITERATION_NUMBER</code>, which starts at value 0 and is incremented after each iteration. By using <code class="codeph">PREVIOUS</code> and <code class="codeph">ITERATION_NUMBER</code>, you can construct complex termination conditions.
                     </p>
                     <p>Consider the following iterative model that specifies iteration over rules till the change in the value of <code class="codeph">s[1]</code> across successive iterations falls below 1, up to a maximum of 1000 times:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT x, s, iterations FROM DUAL
MODEL 
  DIMENSION BY (1 AS x) MEASURES (1024 AS s, 0 AS iterations)
  RULES ITERATE (1000) UNTIL ABS(PREVIOUS(s[1]) - s[1]) &lt; 1
 (s[1] = s[1]/2, iterations[1] = ITERATION_NUMBER);
</pre><p>The absolute value function (<code class="codeph">ABS</code>) can be helpful for termination conditions because you may not know if the most recent value is positive or negative. Rules in this model will be iterated over 11 times as after 11th iteration the value of <code class="codeph">s[1]</code> would be 0.5. This query results in a single row with values 1, 0.5, 10 for <code class="codeph">x</code>, <code class="codeph">s</code> and iterations respectively.
                     </p>
                     <p>You can use the <code class="codeph">PREVIOUS</code> function only in the <code class="codeph">UNTIL</code> condition. However, <code class="codeph">ITERATION_NUMBER</code> can be anywhere in the main model. In the following example, <code class="codeph">ITERATION_NUMBER</code> is used in cell references:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, sales
FROM sales_view
MODEL
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  IGNORE NAV
  RULES ITERATE(3)
(sales['Bounce', 2002 + ITERATION_NUMBER] = sales['Bounce', 1999 
  + ITERATION_NUMBER]);
</pre><p>This statement achieves an array copy of sales of Bounce from cells in the array 1999-2001 to 2002-2005.</p>
                     <p>The view <code class="codeph">sales_view</code> was created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>.
                     </p>
                  </div>
               </div><a id="DWHSG8794"></a><div class="props_rev_3"><a id="GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999" name="GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999"></a><h4 id="DWHSG-GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999" class="sect4"><span class="enumeration_section">22.3.3 </span>Rule Dependency in AUTOMATIC ORDER Models
                  </h4>
                  <div>
                     <p>Oracle Database determines the order of evaluation of rules in an <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model based on their dependencies. A rule is evaluated only after the rules it depends on are evaluated. The algorithm chosen to evaluate the rules is based on the dependency analysis and whether rules in your model have circular (or cyclical) dependencies. A cyclic dependency can be of the form "rule A depends on B and rule B depends on A" or of the self-cyclic "rule depending on itself" form. An example of the former is:
                     </p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2002] = 1.5 * sales['Y Box', 2002],
sales['Y Box', 2002] = 100000 / sales['Bounce', 2002
</pre><p>An example of the latter is:</p><pre class="oac_no_warn" dir="ltr">sales['Bounce', 2002] = 25000 / sales['Bounce', 2002]
</pre><p>However, there is no self-cycle in the following rule as different measures are being accessed on the left and right side:</p><pre class="oac_no_warn" dir="ltr">projected_sales['Bounce', 2002] = 25000 / sales['Bounce', 2002]
</pre><p>When the analysis of an <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model finds that the rules have no circular dependencies, Oracle Database evaluates the rules in their dependency order. For example, in the following <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model:
                     </p><pre class="oac_no_warn" dir="ltr">MODEL DIMENSION BY (prod, year) MEASURES (sale sales) IGNORE NAV
  RULES AUTOMATIC ORDER
 (sales['SUV', 2001] = 10000,
  sales['Standard Mouse Pad', 2001] = sales['Finding Fido', 2001] 
    * 0.10 + sales['Boat', 2001] * 0.50,
  sales['Boat', 2001] = sales['Finding Fido', 2001] 
    * 0.25 + sales['SUV', 2001]* 0.75,
  sales['Finding Fido', 2001] = 20000)
</pre><p>Rule 2 depends on rules 3 and 4, while rule 3 depends on rules 1 and 4, and rules 1 and 4 do not depend on any rule. Oracle, in this case, will find that the rule dependencies are acyclic and evaluate rules in one of the possible evaluation orders (1, 4, 3, 2) or (4, 1, 3, 2). This type of rule evaluation is called an <code class="codeph">ACYCLIC</code> algorithm.
                     </p>
                     <p>In some cases, Oracle Database may not be able to ascertain that your model is acyclic even though there is no cyclical dependency among the rules. This can happen if you have complex expressions in your cell references. Oracle Database assumes that the rules are cyclic and employs a <code class="codeph">CYCLIC</code> algorithm that evaluates the model iteratively based on the rules and data. Iteration stops as soon as convergence is reached and the results are returned. Convergence is defined as the state in which further executions of the model will not change values of any of the cell in the model. Convergence is certain to be reached when there are no cyclical dependencies.
                     </p>
                     <p>If your <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model has rules with cyclical dependencies, Oracle Database employs the earlier mentioned <code class="codeph">CYCLIC</code> algorithm. Results are produced if convergence can be reached within the number of iterations Oracle is going to try the algorithm. Otherwise, Oracle reports a cycle detection error. You can circumvent this problem by manually ordering the rules and specifying <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>.
                     </p>
                  </div>
               </div><a id="DWHSG8796"></a><a id="DWHSG8795"></a><div class="props_rev_3"><a id="GUID-2523C916-C744-46B1-8D53-DF03204EAF85" name="GUID-2523C916-C744-46B1-8D53-DF03204EAF85"></a><h4 id="DWHSG-GUID-2523C916-C744-46B1-8D53-DF03204EAF85" class="sect4"><span class="enumeration_section">22.3.4 </span>Ordered Rules in SQL Modeling
                  </h4>
                  <div>
                     <p>An ordered rule is one that has <code class="codeph">ORDER BY</code> specified on the left side. It accesses cells in the order prescribed by <code class="codeph">ORDER BY</code> and applies the right side computation. When you have <code class="codeph">ANY</code> or symbolic references on the left side of a rule but without the <code class="codeph">ORDER BY</code> clause, Oracle might return an error saying that the rule's results depend on the order in which cells are accessed and hence are non-deterministic. Consider the following <code class="codeph">SEQUENTIAL ORDER</code> model:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT t, s
FROM sales, times
WHERE sales.time_id = times.time_id
GROUP BY calendar_year
MODEL 
  DIMENSION BY (calendar_year t) MEASURES (SUM(amount_sold) s)
  RULES SEQUENTIAL ORDER
  (s[ANY] = s[CV(t)-1]);
</pre><p>This query attempts to set, for all years <code class="codeph">t</code>, sales <code class="codeph">s</code> value for a year to the sales value of the prior year. Unfortunately, the result of this rule depends on the order in which the cells are accessed. If cells are accessed in the ascending order of year, the result would be that of column 3 in <a href="sql-modeling-data-warehouses.html#GUID-2523C916-C744-46B1-8D53-DF03204EAF85__CHDGBCFI" title="This table displays results of a query that uses SEQUENTIAL ORDER.">Table 22-1</a>. If they are accessed in descending order, the result would be that of column 4.
                     </p>
                     <div class="tblformal" id="GUID-2523C916-C744-46B1-8D53-DF03204EAF85__CHDGBCFI">
                        <p class="titleintable">Table 22-1 Ordered Rules</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Ordered Rules" summary="This table displays results of a query that uses SEQUENTIAL ORDER." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d90648e3520">t</th>
                                 <th align="left" valign="bottom" width="25%" id="d90648e3523">s</th>
                                 <th align="left" valign="bottom" width="23%" id="d90648e3526">If ascending</th>
                                 <th align="left" valign="bottom" width="31%" id="d90648e3529">If descending</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3534" headers="d90648e3520 ">
                                    <p>1998</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3534 d90648e3523 ">
                                    <p>1210000982</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3534 d90648e3526 ">
                                    <p>null</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3534 d90648e3529 ">
                                    <p>null</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3547" headers="d90648e3520 ">
                                    <p>1999</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3547 d90648e3523 ">
                                    <p>1473757581</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3547 d90648e3526 ">
                                    <p>null</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3547 d90648e3529 ">
                                    <p>1210000982</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3560" headers="d90648e3520 ">
                                    <p>2000</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3560 d90648e3523 ">
                                    <p>2376222384</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3560 d90648e3526 ">
                                    <p>null</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3560 d90648e3529 ">
                                    <p>1473757581</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3573" headers="d90648e3520 ">
                                    <p>2001</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3573 d90648e3523 ">
                                    <p>1267107764</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3573 d90648e3526 ">
                                    <p>null</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3573 d90648e3529 ">
                                    <p>2376222384</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>If you want the cells to be considered in descending order and get the result given in column 4, you should specify:</p><pre class="oac_no_warn" dir="ltr">SELECT t, s
FROM sales, times
WHERE sales.time_id = times.time_id
GROUP BY calendar_year
MODEL 
  DIMENSION BY (calendar_year t) MEASURES (SUM(amount_sold) s)
  RULES SEQUENTIAL ORDER
  (s[ANY] ORDER BY t DESC = s[CV(t)-1]);
</pre><p>In general, you can use any <code class="codeph">ORDER</code> <code class="codeph">BY</code> specification as long as it produces a unique order among cells that match the left side cell reference. Expressions in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> of a rule can involve constants, measures and dimension keys and you can specify the ordering options <code class="codeph">[ASC | DESC] [NULLS FIRST | NULLS LAST]</code> to get the order you want.
                     </p>
                     <p>You can also specify <code class="codeph">ORDER</code> <code class="codeph">BY</code> for rules in an <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model to make Oracle consider cells in a particular order during rule evaluation. Rules are never considered self-cyclic if they have <code class="codeph">ORDER</code> <code class="codeph">BY</code>. For example, to make the following <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model with a self-cyclic formula acyclic:
                     </p><pre class="oac_no_warn" dir="ltr">MODEL
  DIMENSION BY (calendar_year t) MEASURES (SUM(amount_sold) s)
  RULES AUTOMATIC ORDER
  (s[ANY] = s[CV(t)-1])
</pre><p>You must provide the order in which cells need to be accessed for evaluation using <code class="codeph">ORDER</code> <code class="codeph">BY</code>. For example, you can say:
                     </p><pre class="oac_no_warn" dir="ltr">s[ANY] ORDER BY t = s[CV(t) - 1]
</pre><p>Then Oracle Database picks an <code class="codeph">ACYCLIC</code> algorithm (which is certain to produce the result) for formula evaluation.
                     </p>
                  </div>
               </div><a id="DWHSG0224"></a><div class="props_rev_3"><a id="GUID-6B79CCE3-69E2-444C-84BE-50672330C546" name="GUID-6B79CCE3-69E2-444C-84BE-50672330C546"></a><h4 id="DWHSG-GUID-6B79CCE3-69E2-444C-84BE-50672330C546" class="sect4"><span class="enumeration_section">22.3.5 </span>Analytic Functions in SQL Modeling
                  </h4>
                  <div>
                     <p><a id="d90648e3672" class="indexterm-anchor"></a><a id="d90648e3674" class="indexterm-anchor"></a><a id="d90648e3678" class="indexterm-anchor"></a><a id="d90648e3680" class="indexterm-anchor"></a>Analytic functions (also known as window functions) can be used in the right side of rules. The ability to use analytic functions adds expressive power and flexibility to the <code class="codeph">MODEL</code> clause.The following example combines an analytic function with the <code class="codeph">MODEL</code> clause. First, you create a view <code class="codeph">sales_rollup_time</code> that uses the <code class="codeph">GROUPING_ID</code> function to calculate an identifier for different levels of aggregations. You then use the view in a query that calculates the cumulative sum of sales at both the quarter and year levels.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE VIEW sales_rollup_time
AS
SELECT country_name country, calendar_year year, calendar_quarter_desc quarter,
GROUPING_ID(calendar_year, calendar_quarter_desc) gid, SUM(amount_sold) sale,
COUNT(amount_sold) cnt
FROM sales, times, customers, countries
WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id
  AND customers.country_id = countries.country_id
GROUP BY country_name, calendar_year, ROLLUP(calendar_quarter_desc)
ORDER BY gid, country, year, quarter;

SELECT country, year, quarter, sale, csum
FROM sales_rollup_time
WHERE country IN ('United States of America', 'United Kingdom')
MODEL DIMENSION BY (country, year, quarter)
MEASURES (sale, gid, 0 csum)
(
csum[any, any, any] =
  SUM(sale) OVER (PARTITION BY country, DECODE(gid,0,year,null)
ORDER BY year, quarter
ROWS UNBOUNDED PRECEDING)
)
ORDER BY country, gid, year, quarter;

COUNTRY                              YEAR QUARTER       SALE       CSUM
------------------------------ ---------- ------- ---------- ----------
United Kingdom                       1998 1998-01  484733.96  484733.96
United Kingdom                       1998 1998-02  386899.15  871633.11
United Kingdom                       1998 1998-03  402296.49  1273929.6
United Kingdom                       1998 1998-04  384747.94 1658677.54
United Kingdom                       1999 1999-01  394911.91  394911.91
United Kingdom                       1999 1999-02  331068.38  725980.29
United Kingdom                       1999 1999-03  383982.61  1109962.9
United Kingdom                       1999 1999-04  398147.59 1508110.49
United Kingdom                       2000 2000-01  424771.96  424771.96
United Kingdom                       2000 2000-02  351400.62  776172.58
United Kingdom                       2000 2000-03  385137.68 1161310.26
United Kingdom                       2000 2000-04   390912.8 1552223.06
United Kingdom                       2001 2001-01  343468.77  343468.77
United Kingdom                       2001 2001-02  415168.32  758637.09
United Kingdom                       2001 2001-03  478237.29 1236874.38
United Kingdom                       2001 2001-04  437877.47 1674751.85
United Kingdom                       1998         1658677.54 1658677.54
United Kingdom                       1999         1508110.49 3166788.03
United Kingdom                       2000         1552223.06 4719011.09
United Kingdom                       2001         1674751.85 6393762.94
...  /*and similar output for the US*/
</pre><p>There are some specific restrictions when using analytic functions. See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-AD6A9B81-492F-4724-9517-7758C4A98365">Rules and Restrictions when Using SQL for Modeling</a>"</span> for more information. 
                     </p>
                  </div>
               </div><a id="DWHSG8797"></a><div class="props_rev_3"><a id="GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8" name="GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8"></a><h4 id="DWHSG-GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8" class="sect4"><span class="enumeration_section">22.3.6 </span>Unique Dimensions Versus Unique Single References in SQL Modeling
                  </h4>
                  <div>
                     <p>The <code class="codeph">MODEL</code> clause, in its default behavior, requires the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys to uniquely identify each row in the input to the model. Oracle verifies that and returns an error if the data is not unique. Uniqueness of the input rowset on the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys guarantees that any single cell reference accesses one and only one cell in the model. You can specify an optional <code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code> keyword in the <code class="codeph">MODEL</code> clause to make this behavior explicit. For example, the following query run on the view <code class="codeph">sales_view</code> that is created as described in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, sales
FROM sales_view
WHERE country IN ('France', 'Poland')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product) MEASURES (sales sales)
  IGNORE NAV RULES UPSERT
(sales['Bounce'] = sales['All Products'] * 0.24); 
</pre><p>This would return a uniqueness violation error as the rowset input to model is not unique on <code class="codeph">country</code> and <code class="codeph">product</code> because <code class="codeph">year</code> is also needed:
                     </p><pre class="oac_no_warn" dir="ltr">ERROR at line 2:ORA-32638: Non unique addressing in MODEL dimensions
</pre><p>However, the following query does not return such an error:</p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  RULES UPSERT
(sales['Bounce', 2003] = sales['All Products', 2002] * 0.24);
</pre><p>Input to the <code class="codeph">MODEL</code> clause in this case is unique on <code class="codeph">country</code>, <code class="codeph">product</code>, and <code class="codeph">year</code> as shown in:
                     </p><pre class="oac_no_warn" dir="ltr">COUNTRY   PRODUCT                         YEAR   SALES
-------   -----------------------------   ----   --------
Italy     1.44MB External 3.5" Diskette   1998    3141.84
Italy     1.44MB External 3.5" Diskette   1999    3086.87
Italy     1.44MB External 3.5" Diskette   2000    3440.37
Italy     1.44MB External 3.5" Diskette   2001     855.23
...
</pre><p>If you want to relax this uniqueness checking, you can specify <code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code> keyword. This can save processing time. In this case, the <code class="codeph">MODEL</code> clause checks the uniqueness of only the single cell references appearing on the right side of rules. So the query that returned the uniqueness violation error would be successful if you specify <code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code> instead of <code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code>.
                     </p>
                     <p>Another difference between <code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code> and <code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code> semantics is the number of cells that can be updated by a rule with a single cell reference on left side. In the case of <code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code>, such a rule can update at most one row as only one cell would match the single cell reference on the left side. This is because the input rowset would be unique on <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys. With <code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code>, all cells that match the left side single cell reference would be updated by the rule.
                     </p>
                  </div>
               </div><a id="DWHSG0225"></a><div class="props_rev_3"><a id="GUID-AD6A9B81-492F-4724-9517-7758C4A98365" name="GUID-AD6A9B81-492F-4724-9517-7758C4A98365"></a><h4 id="DWHSG-GUID-AD6A9B81-492F-4724-9517-7758C4A98365" class="sect4"><span class="enumeration_section">22.3.7 </span>Rules and Restrictions when Using SQL for Modeling
                  </h4>
                  <div>
                     <div class="section">
                        <p>The f<a id="d90648e3909" class="indexterm-anchor"></a>ollowing general rules and restrictions apply when using the <code class="codeph">MODEL</code> clause:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The only columns that can be updated are the columns specified in the <code class="codeph">MEASURES</code> subclause of the main SQL model. Measures of reference models cannot be updated.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">MODEL</code> clause is evaluated after all clauses in the query block except <code class="codeph">SELECT</code> <code class="codeph">DISTINCT</code>, and <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause are evaluated. These clauses and expressions in the <code class="codeph">SELECT</code> list are evaluated after the <code class="codeph">MODEL</code> clause.
                              </p>
                           </li>
                           <li>
                              <p>If your query has a <code class="codeph">MODEL</code> clause, then the query's <code class="codeph">SELECT</code> and <code class="codeph">ORDER</code> <code class="codeph">BY</code> lists cannot contain aggregates or analytic functions. If needed, these can be specified in <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>, and <code class="codeph">MEASURES</code> lists and need to be aliased. Aliases can then be used in the <code class="codeph">SELECT</code> or <code class="codeph">ORDER</code> <code class="codeph">BY</code> clauses. In the following example, the analytic function <code class="codeph">RANK</code> is specified and aliased in the <code class="codeph">MEASURES</code> list of the <code class="codeph">MODEL</code> clause, and its alias is used in the <code class="codeph">SELECT</code> list so that the outer query can order resulting rows based on their ranks.
                              </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, s, RNK
FROM (SELECT country, product, year, s, rnk
      FROM sales_view
      MODEL
        PARTITION BY (country) DIMENSION BY (product, year)
        MEASURES (sales s, year y, RANK() OVER (ORDER BY sales) rnk)
        RULES UPSERT
          (s['Bounce Increase 90-99', 2001] =
             REGR_SLOPE(s, y) ['Bounce', year BETWEEN 1990 AND 2000],
           s['Bounce', 2001] = s['Bounce', 2000] * 
          (1+s['Bounce increase 90-99', 2001])))
WHERE product &lt;&gt; 'Bounce Increase 90-99'
ORDER BY country, year, rnk, product;
</pre></li>
                           <li>
                              <p>When there is a multi-cell reference on the right hand side of a rule, you need to apply a function to aggregate the measure values of multiple cells referenced into a single value. You can use any kind of aggregate function for this purpose: regular, analytic aggregate (inverse percentile, hypothetical rank and distribution), or user-defined aggregate.</p>
                           </li>
                           <li>
                              <p>Only rules with positional single cell references on the left side have <code class="codeph">UPSERT</code> semantics. All other rules have <code class="codeph">UPDATE</code> semantics, even when you specify the <code class="codeph">UPSERT</code> option for them.
                              </p>
                           </li>
                           <li>
                              <p>Negative increments are not allowed in <code class="codeph">FOR</code> loops. Also, no empty <code class="codeph">FOR</code> loops are allowed. <code class="codeph">FOR d FROM 2005 TO 2001 INCREMENT -1</code> is illegal. You should use <code class="codeph">FOR d FROM 2005 TO 2001 DECREMENT 1</code> instead. <code class="codeph">FOR d FROM 2005 TO 2001 INCREMENT 1</code> is illegal as it designates an empty loop.
                              </p>
                           </li>
                           <li>
                              <p>You cannot use nested query expressions (subqueries) in rules except in the <code class="codeph">FOR</code> construct. For example, it would be illegal to issue the following:
                              </p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM sales_view WHERE country = 'Poland'
MODEL DIMENSION BY (product, year)
  MEASURES (sales sales)
  RULES UPSERT
  (sales['Bounce', 2003] = sales['Bounce', 2002] + 
   (SELECT SUM(sales) FROM sales_view));
</pre><p>This is because the rule has a subquery on its right side. Instead, you can rewrite the preceding query in the following legal way:</p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM sales_view WHERE country = 'Poland'
MODEL DIMENSION BY (product, year)
  MEASURES (sales sales, (SELECT SUM(sales) FROM sales_view) AS grand_total)
  RULES UPSERT
  (sales['Bounce', 2003] =sales['Bounce', 2002] + 
   grand_total['Bounce', 2002]);
</pre></li>
                           <li>
                              <p>You can also use subqueries in the <code class="codeph">FOR</code> construct specified on the left side of a rule. However, they:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Cannot be correlated</p>
                                 </li>
                                 <li>
                                    <p>Must return fewer than 10,000 rows</p>
                                 </li>
                                 <li>
                                    <p>Cannot be a query defined in the <code class="codeph">WITH</code> clause
                                    </p>
                                 </li>
                                 <li>
                                    <p>Will make the cursor unsharable</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>Nested cell references have the following restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Nested cell references must be single cell references. Aggregates on nested cell references are not supported. So, it would be illegal to say <code class="codeph">s['Bounce', MAX(best_year)['Bounce', ANY]]</code>.
                              </p>
                           </li>
                           <li>
                              <p>Only one level of nesting is supported for nested cell references on the main model. So, for example, <code class="codeph">s['Bounce', best_year['Bounce', 2001]]</code> is legal, but <code class="codeph">s['Bounce', best_year['Bounce', best_year['Bounce', 2001]]]</code> is not.
                              </p>
                           </li>
                           <li>
                              <p>Nested cell references appearing on the left side of rules in an <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> model should not be updated in any rule of the model. This restriction ensures that the rule dependency relationships do not arbitrarily change (and hence cause non-deterministic results) due to updates to reference measures.
                              </p>
                              <p>There is no such restriction on nested cell references in a <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> model. Also, this restriction is not applicable on nested references appearing on the right side of rules in both <code class="codeph">SEQUENTIAL</code> or <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> models.
                              </p>
                           </li>
                        </ul>
                        <p>Reference models have the following restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The query defining the reference model cannot be correlated to any outer query. It can, however, be a query with subqueries, views, and so on.</p>
                           </li>
                           <li>
                              <p>Reference models cannot have a <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause.
                              </p>
                           </li>
                           <li>
                              <p>Reference models cannot be updated.</p>
                           </li>
                        </ul>
                        <p>Window functions have the following restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The expressions in the <code class="codeph">OVER</code> clause can be expressions of constants, measures, keys from <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> of the <code class="codeph">MODEL</code> clause, and single cell expressions. Aggregates are not permitted inside the <code class="codeph">OVER</code> clause. Therefore, the following is okay:
                              </p><pre class="oac_no_warn" dir="ltr">rnk[ANY, ANY, ANY] = RANK() OVER (PARTITION BY prod, country ORDER BY sale)
</pre><p>While the following is not:</p><pre class="oac_no_warn" dir="ltr">rnk[ANY, ANY, ANY] = RANK() OVER (PARTITION BY prod, country ORDER BY SUM(sale))
</pre></li>
                           <li>
                              <p>Rules with window functions on their right side cannot have an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause on their left side.
                              </p>
                           </li>
                           <li>
                              <p>Window functions and aggregate functions cannot both be on the right side of a rule.</p>
                           </li>
                           <li>
                              <p>Window functions can only be used on the right side of an <code class="codeph">UPDATE</code> rule.
                              </p>
                           </li>
                           <li>
                              <p>If a rule has a <code class="codeph">FOR</code> loop on its left side, a window function cannot be used on the right side of the rule.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG0226"></a><div class="props_rev_3"><a id="GUID-983B5378-4FCA-4452-B615-3A39B491F1E4" name="GUID-983B5378-4FCA-4452-B615-3A39B491F1E4"></a><h3 id="DWHSG-GUID-983B5378-4FCA-4452-B615-3A39B491F1E4" class="sect3"><span class="enumeration_section">22.4 </span>Performance Considerations with SQL Modeling
               </h3>
               <div>
                  <p>The <a id="d90648e4213" class="indexterm-anchor"></a>following sections describe topics that affect performance when using the <code class="codeph">MODEL</code> clause:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-703FA761-BFB3-467D-BB48-41C95E4E1879">Parallel Execution and SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-4BBCBDA9-2B4E-41A6-A313-345806591206">Aggregate Computation and SQL Modeling</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B">Using EXPLAIN PLAN to Understand Model Queries</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8798"></a><div class="props_rev_3"><a id="GUID-703FA761-BFB3-467D-BB48-41C95E4E1879" name="GUID-703FA761-BFB3-467D-BB48-41C95E4E1879"></a><h4 id="DWHSG-GUID-703FA761-BFB3-467D-BB48-41C95E4E1879" class="sect4"><span class="enumeration_section">22.4.1 </span>Parallel Execution and SQL Modeling
                  </h4>
                  <div>
                     <p><code class="codeph">MODEL</code> c<a id="d90648e4261" class="indexterm-anchor"></a>lause computation is scalable in terms of the number of processors you have. Scalability is achieved by performing the <code class="codeph">MODEL</code> computation in parallel across the partitions defined by the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause. Data is distributed among processing elements (also called parallel query slaves) based on the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> key values such that all rows with the same values for the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keys will go to the same slave. Note that the internal processing of partitions will not create a one-to-one match of logical and internally processed partitions. This way, each slave can finish <code class="codeph">MODEL</code> clause computation independent of other slaves. The data partitioning can be hash based or range based. Consider the following <code class="codeph">MODEL</code> clause:
                     </p><pre class="oac_no_warn" dir="ltr">MODEL 
  PARTITION BY (country) DIMENSION BY (product, time) MEASURES (sales)
  RULES UPDATE
  (sales['Bounce', 2002] = 1.2 * sales['Bounce', 2001],
   sales['Car', 2002] = 0.8 * sales['Car', 2001])
</pre><p>Here input data will be partitioned among slaves based on the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> key <code class="codeph">country</code> and this partitioning can be hash or range based. Each slave will evaluate the rules on the data it receives.
                     </p>
                     <p>Parallelism of the model computation is governed or limited by the way you specify the <code class="codeph">MODEL</code> clause. If your <code class="codeph">MODEL</code> clause has no <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keys, then the computation cannot be parallelized (with exceptions mentioned in the following). If <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keys have very low cardinality, then the degree of parallelism will be limited. In such cases, Oracle identifies the <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> keys that can used for partitioning. For example, consider a <code class="codeph">MODEL</code> clause equivalent to the preceding one, but without <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keys as in the following:
                     </p><pre class="oac_no_warn" dir="ltr">MODEL 
  DIMENSION BY (country, product, time) MEASURES (sales)
  RULES UPDATE
  (sales[ANY, 'Bounce', 2002] = 1.2 * sales[CV(country), 'Bounce', 2001],
   sales[ANY, 'Car', 2002] = 0.8 * sales[CV(country), 'Car', 2001])
</pre><p>In this case, Oracle Database identifies that it can use the <code class="codeph">DIMENSION</code> <code class="codeph">BY</code> key <code class="codeph">country</code> for partitioning and uses <code class="codeph">region</code> as the basis of internal partitioning. It partitions the data among slaves on <code class="codeph">country</code> and thus effects parallel execution.
                     </p>
                  </div>
               </div><a id="DWHSG8799"></a><div class="props_rev_3"><a id="GUID-4BBCBDA9-2B4E-41A6-A313-345806591206" name="GUID-4BBCBDA9-2B4E-41A6-A313-345806591206"></a><h4 id="DWHSG-GUID-4BBCBDA9-2B4E-41A6-A313-345806591206" class="sect4"><span class="enumeration_section">22.4.2 </span>Aggregate Computation and SQL Modeling
                  </h4>
                  <div>
                     <p>The <code class="codeph">MODEL</code> clause processes aggregates in two different ways: first, the regular fashion in which data in the partition is scanned and aggregated and second, an efficient window style aggregation. The first type as illustrated in the following introduces a new dimension member ALL_2002_products and computes its value to be the sum of year 2002 sales for all products:
                     </p><pre class="oac_no_warn" dir="ltr">MODEL PARTITION BY (country) DIMENSION BY (product, time) MEASURES (sale sales)
RULES UPSERT 
 (sales['ALL_2002_products', 2002] = SUM(sales)[ANY, 2002])
</pre><p>To evaluate the aggregate sum in this case, each partition will be scanned to find the cells for 2002 for all products and they will be aggregated. If the left side of the rule were to reference multiple cells, then Oracle will have to compute the right side aggregate by scanning the partition for each cell referenced on the left. For example, consider the following example:</p><pre class="oac_no_warn" dir="ltr">MODEL PARTITION BY (country) DIMENSION BY (product, time)
  MEASURES (sale sales, 0 avg_exclusive)
  RULES UPDATE
  (avg_exclusive[ANY, 2002] =  AVG(sales)[product &lt;&gt; CV(product), CV(time)])
</pre><p>This rule calculates a measure called <code class="codeph">avg_exclusive</code> for every product in 2002. The measure <code class="codeph">avg_exclusive</code> is defined as the average sales of all products excluding the current product. In this case, Oracle scans the data in a partition for every product in 2002 to calculate the aggregate, and this may be expensive.
                     </p>
                     <p>Oracle Database optimizes the evaluation of such aggregates in some scenarios with window-style computation as used in analytic functions. These scenarios involve rules with multi-cell references on their left side and computing window computations such as moving averages, cumulative sums and so on. Consider the following example:</p><pre class="oac_no_warn" dir="ltr">MODEL PARTITION BY (country) DIMENSION BY (product, time)
  MEASURES (sale sales, 0 mavg)
  RULES UPDATE
  (mavg[product IN ('Bounce', 'Y Box', 'Mouse Pad'), ANY] =
   AVG(sales)[CV(product), time BETWEEN CV(time) 
   AND CV(time) - 2])
</pre><p>It computes the moving average of sales for products Bounce, Y Box, and Mouse Pad over a three year period. It would be very inefficient to evaluate the aggregate by scanning the partition for every cell referenced on the left side. Oracle identifies the computation as being in window-style and evaluates it efficiently. It sorts the input on product, time and then scans the data once to compute the moving average. You can view this rule as an analytic function being applied on the sales data for products Bounce, Y Box, and Mouse Pad:</p><pre class="oac_no_warn" dir="ltr">AVG(sales) OVER (PARTITION BY product ORDER BY time
RANGE BETWEEN 2 PRECEDING AND CURRENT ROW)
</pre><p>This computation style is called <code class="codeph">WINDOW (IN MODEL) SORT</code>. This style of aggregation is applicable when the rule has a multi-cell reference on its left side with no <code class="codeph">ORDER</code> <code class="codeph">BY</code>, has a simple aggregate (<code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">STDEV</code>, and <code class="codeph">VAR</code>) on its right side, only one dimension on the right side has a boolean predicate (<code class="codeph">&lt;</code>, <code class="codeph">&lt;=</code>, <code class="codeph">&gt;</code>, <code class="codeph">&gt;=</code>, <code class="codeph">BETWEEN</code>), and all other dimensions on the right are qualified with <code class="codeph">CV</code>.
                     </p>
                  </div>
               </div><a id="DWHSG8800"></a><div class="props_rev_3"><a id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B" name="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B"></a><h4 id="DWHSG-GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B" class="sect4"><span class="enumeration_section">22.4.3 </span>Using EXPLAIN PLAN to Understand Model Queries
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle's explain plan facility is fully aware of models. You will see a line in your query's main explain plan output showing the model and the algorithm used. Reference models are tagged with the keyword <code class="codeph">REFERENCE</code> in the plan output. Also, Oracle annotates the plan with <code class="codeph">WINDOW (IN MODEL) SORT</code> if any of the rules qualify for window-style aggregate computation.
                        </p>
                        <p>By examining an explain plan, you can find out the algorithm chosen to evaluate your model. If your model has <code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> semantics, then <code class="codeph">ORDERED</code> is displayed. For <code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> models, Oracle displays <code class="codeph">ACYCLIC</code> or <code class="codeph">CYCLIC</code> based on whether it chooses <code class="codeph">ACYCLIC</code> or <code class="codeph">CYCLIC</code> algorithm for evaluation. In addition, the plan output will have an annotation <code class="codeph">FAST</code> in case of <code class="codeph">ORDERED</code> and <code class="codeph">ACYCLIC</code> algorithms if all left side cell references are single cell references and aggregates, if any, on the right side of rules are simple arithmetic non-distinct aggregates like <code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">AVG</code>, and so on. Rule evaluation in this case would be highly efficient and hence the annotation <code class="codeph">FAST</code>. Thus, the output you will see in the explain plan would be <code class="codeph">MODEL {ORDERED [FAST] | ACYCLIC [FAST] | CYCLIC}</code>.
                        </p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJHDHC">Using ORDERED FAST: Example</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDFHADC">Using ORDERED: Example</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDBBCII">Using ACYCLIC FAST: Example</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJABEC">Using ACYCLIC: Example</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDDGGEC">Using CYCLIC: Example</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJHDHC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-48DDF661-809D-42B5-9FE7-55256FE13F4C">Using ORDERED FAST: Example</p>
                        <p>This model has only single cell references on the left side of rules and the aggregate <code class="codeph">AVG</code> on the right side of first rule is a simple non-distinct aggregate:
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  RULES UPSERT
  (sales['Bounce', 2003] = AVG(sales)[ANY, 2002] * 1.24,
   sales['Y Box', 2003] = sales['Bounce', 2003] * 0.25);</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDFHADC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-897048E6-BBC9-4C63-9B84-FD1DD2B39772">Using ORDERED: Example</p>
                        <p>Because the left side of the second rule is a multi-cell reference, the <code class="codeph">FAST</code> method will not be chosen in the following:
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  RULES UPSERT
  (sales['Bounce', 2003] = AVG(sales)[ANY, 2002] * 1.24,
   sales[prod &lt;&gt; 'Bounce', 2003] = sales['Bounce', 2003] * 0.25);</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDBBCII">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-7159D42A-3CA2-43F8-8458-8539219D64BD">Using ACYCLIC FAST: Example</p>
                        <p>Rules in this model are not cyclic and the explain plan will show <code class="codeph">ACYCLIC</code>. The <code class="codeph">FAST</code> method is chosen in this case as well.
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  RULES UPSERT AUTOMATIC ORDER
  (sales['Y Box', 2003] = sales['Bounce', 2003] * 0.25,
   sales['Bounce', 2003] = sales['Bounce', 2002] / SUM(sales)[ANY, 2002] * 2 *
   sales['All Products', 2003],
   sales['All Products', 2003] = 200000);</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJABEC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-7D82901B-DA7E-4838-AB97-25CFAB78F909">Using ACYCLIC: Example</p>
                        <p>Rules in this model are not cyclic. The <code class="codeph">PERCENTILE_DISC</code> aggregate that gives the median sales for year 2002, in the second rule is not a simple aggregate function. Therefore, Oracle will not choose the <code class="codeph">FAST</code> method, and the explain plan will just show <code class="codeph">ACYCLIC</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  RULES UPSERT AUTOMATIC ORDER
  (sales['Y Box', 2003] = sales['Bounce', 2003] * 0.25,
   sales['Bounce',2003] = PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY
   sales)[ANY,2002] / SUM(sales)[ANY, 2002] * 2 * sales['All Products', 2003],
   sales['All Products', 2003] = 200000);</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDDGGEC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-034BA99E-3248-46D1-985A-6522B0A15789">Using CYCLIC: Example</p>
                        <p>Oracle chooses <code class="codeph">CYCLIC</code> algorithm for this model as there is a cycle among second and third rules.
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT country, product, year, sales
FROM sales_view
WHERE country IN ('Italy', 'Japan')
MODEL UNIQUE DIMENSION
  PARTITION BY (country) DIMENSION BY (product, year) MEASURES (sales sales)
  IGNORE NAV RULES UPSERT AUTOMATIC ORDER
  (sales['All Products', 2003] = 200000,
   sales['Y Box', 2003] = sales['Bounce', 2003] * 0.25,
   sales['Bounce', 2003] = sales['Y Box', 2003] + 
    (sales['Bounce', 2002] / SUM(sales)[ANY, 2002] * 2 * 
     sales['All Products', 2003]));</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8806"></a><div class="props_rev_3"><a id="GUID-195E4085-EE47-4122-AED6-F358C0C2F716" name="GUID-195E4085-EE47-4122-AED6-F358C0C2F716"></a><h3 id="DWHSG-GUID-195E4085-EE47-4122-AED6-F358C0C2F716" class="sect3"><span class="enumeration_section">22.5 </span>Examples of SQL Modeling
               </h3>
               <div>
                  <p>The examples in this section assume that in addition to <code class="codeph">sales_view</code> (created in <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">Base Schema for SQL Modeling Examples</a>), you have the following view defined. It finds monthly totals of sales and quantities by product and country.
                  </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW sales_view2 AS
SELECT country_name country, prod_name product, calendar_year year,
  calendar_month_name month, SUM(amount_sold) sale, COUNT(amount_sold) cnt
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND
      sales.prod_id = products.prod_id AND
      sales.cust_id = customers.cust_id AND
      customers.country_id = countries.country_id
GROUP BY country_name, prod_name, calendar_year, calendar_month_name;
</pre><p>This section contains the following examples:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-0EA4B496-C9D5-4596-A727-3CB15853E245">SQL Modeling Example 1: Calculating Sales Differences</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37">SQL Modeling Example 2: Calculating Percentage Change</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F">SQL Modeling Example 3: Calculating Net Present Value</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-A768891C-B572-4860-890A-85143BFEBF9C">SQL Modeling Example 4: Calculating Using Simultaneous Equations</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203">SQL Modeling Example 5: Calculating Using Regression</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C">SQL Modeling Example 6: Calculating Mortgage Amortization</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9207"></a><div class="props_rev_3"><a id="GUID-0EA4B496-C9D5-4596-A727-3CB15853E245" name="GUID-0EA4B496-C9D5-4596-A727-3CB15853E245"></a><h4 id="DWHSG-GUID-0EA4B496-C9D5-4596-A727-3CB15853E245" class="sect4"><span class="enumeration_section">22.5.1 </span>SQL Modeling Example 1: Calculating Sales Differences
                  </h4>
                  <div>
                     <div class="section">
                        <p>Show the sales for Italy and Spain and the difference between the two for each product. The difference should be placed in a new row with <code class="codeph">country = 'Diff Italy-Spain'</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT product, country, sales
FROM sales_view
WHERE country IN ('Italy', 'Spain')
GROUP BY product, country
MODEL 
  PARTITION BY (product) DIMENSION BY (country) MEASURES (SUM(sales) AS sales)
  RULES UPSERT
  (sales['DIFF ITALY-SPAIN'] = sales['Italy'] - sales['Spain']);
</pre><p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9208"></a><div class="props_rev_3"><a id="GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37" name="GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37"></a><h4 id="DWHSG-GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37" class="sect4"><span class="enumeration_section">22.5.2 </span>SQL Modeling Example 2: Calculating Percentage Change
                  </h4>
                  <div>
                     <div class="section">
                        <p>If sales for each product in each country grew (or declined) at the same monthly rate from November 2000 to December 2000 as they did from October 2000 to November 2000, what would the fourth quarter's sales be for the whole company and for each country?</p><pre class="oac_no_warn" dir="ltr">SELECT country, SUM(sales)
FROM (SELECT product, country, month, sales
      FROM sales_view2
      WHERE year=2000 AND month IN ('October','November')
MODEL 
  PARTITION BY (product, country) DIMENSION BY (month) MEASURES (sale sales)
  RULES
   (sales['December']=(sales['November'] /sales['October']) *sales['November']))
GROUP BY GROUPING SETS ((),(country));
</pre><p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9209"></a><div class="props_rev_3"><a id="GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F" name="GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F"></a><h4 id="DWHSG-GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F" class="sect4"><span class="enumeration_section">22.5.3 </span>SQL Modeling Example 3: Calculating Net Present Value
                  </h4>
                  <div>
                     <div class="section">
                        <p>You <a id="d90648e4781" class="indexterm-anchor"></a>want to calculate the net present value (NPV) of a series of periodic cash flows. Your scenario involves two projects, each of which starts with an initial investment at time 0, represented as a negative cash flow. The initial investment is followed by three years of positive cash flow. First, create a table (<code class="codeph">cash_flow</code>) and populate it with some data, as in the following statements:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE cash_flow (year DATE, i INTEGER, prod VARCHAR2(3), amount NUMBER);
INSERT INTO cash_flow VALUES (TO_DATE('1999', 'YYYY'),  0,  'vcr',  -100.00);
INSERT INTO cash_flow VALUES (TO_DATE('2000', 'YYYY'),  1,  'vcr',   12.00);
INSERT INTO cash_flow VALUES (TO_DATE('2001', 'YYYY'),  2,  'vcr',  10.00);
INSERT INTO cash_flow VALUES (TO_DATE('2002', 'YYYY'),  3,  'vcr',  20.00);
INSERT INTO cash_flow VALUES (TO_DATE('1999', 'YYYY'),  0,  'dvd',  -200.00);
INSERT INTO cash_flow VALUES (TO_DATE('2000', 'YYYY'),  1,  'dvd',  22.00);
INSERT INTO cash_flow VALUES (TO_DATE('2001', 'YYYY'),  2,  'dvd',  12.00);
INSERT INTO cash_flow VALUES (TO_DATE('2002', 'YYYY'),  3,  'dvd',  14.00);
</pre><p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                        <p>To calculate the NPV using a discount rate of 0.14, issue the following statement:</p><pre class="oac_no_warn" dir="ltr">SELECT year, i, prod, amount, npv
FROM cash_flow
MODEL PARTITION BY (prod)
  DIMENSION BY (i)
  MEASURES (amount, 0 npv, year)
  RULES
    (npv[0] = amount[0],
     npv[i !=0] ORDER BY i =
       amount[CV()]/ POWER(1.14,CV(i)) + npv[CV(i)-1]); 

YEAR               I PRO     AMOUNT        NPV
--------- ---------- --- ---------- ----------
01-AUG-99          0 dvd       -200       -200
01-AUG-00          1 dvd         22 -180.70175
01-AUG-01          2 dvd         12 -171.46814
01-AUG-02          3 dvd         14 -162.01854
01-AUG-99          0 vcr       -100       -100
01-AUG-00          1 vcr         12 -89.473684
01-AUG-01          2 vcr         10 -81.779009
01-AUG-02          3 vcr         20 -68.279579</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9210"></a><div class="props_rev_3"><a id="GUID-A768891C-B572-4860-890A-85143BFEBF9C" name="GUID-A768891C-B572-4860-890A-85143BFEBF9C"></a><h4 id="DWHSG-GUID-A768891C-B572-4860-890A-85143BFEBF9C" class="sect4"><span class="enumeration_section">22.5.4 </span>SQL Modeling Example 4: Calculating Using Simultaneous Equations
                  </h4>
                  <div>
                     <div class="section">
                        <p>You <a id="d90648e4825" class="indexterm-anchor"></a>want your interest expenses to equal 30% of your net income (net=pay minus tax minus interest). Interest is tax deductible from gross, and taxes are 38% of salary and 28% capital gains. You have salary of $100,000 and capital gains of $15,000. Net income, taxes, and interest expenses are unknown. Observe that this is a simultaneous equation (net depends on interest, which depends on net), thus the <code class="codeph">ITERATE</code> clause is included.
                        </p>
                        <p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                        <p>First, create a table called <code class="codeph">ledger</code>:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE  ledger  (account  VARCHAR2(20), balance  NUMBER(10,2) );
</pre><p>Then, insert the following five rows:</p><pre class="oac_no_warn" dir="ltr">INSERT INTO ledger VALUES  ('Salary', 100000);
INSERT INTO ledger VALUES  ('Capital_gains', 15000);
INSERT INTO ledger VALUES  ('Net', 0);
INSERT INTO ledger VALUES  ('Tax', 0);
INSERT INTO ledger VALUES  ('Interest', 0);
</pre><p>Next, issue the following statement:</p><pre class="oac_no_warn" dir="ltr">SELECT s, account
FROM ledger 
MODEL 
  DIMENSION  BY (account) MEASURES (balance s)
  RULES  ITERATE (100)
  (s['Net']=s['Salary']-s['Interest']-s['Tax'],
 s['Tax']=(s['Salary']-s['Interest'])*0.38 + s['Capital_gains']*0.28,
  s['Interest']=s['Net']*0.30);
</pre><p>The output (with numbers rounded) is:</p><pre class="oac_no_warn" dir="ltr">         S ACCOUNT
---------- --------------------
    100000 Salary
     15000 Capital_gains
48735.2445 Net
36644.1821 Tax
14620.5734 Interest</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9211"></a><div class="props_rev_3"><a id="GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203" name="GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203"></a><h4 id="DWHSG-GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203" class="sect4"><span class="enumeration_section">22.5.5 </span>SQL Modeling Example 5: Calculating Using Regression
                  </h4>
                  <div>
                     <div class="section">
                        <p>The sales of Bounce in 2001 will increase in comparison to 2000 as they did in the last three years (between 1998 and 2000). To calculate the increase, use the regression function <code class="codeph">REGR_SLOPE</code> as follows. Because you are calculating the next period's value, it is sufficient to add the slope to the 2000 value.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM
 (SELECT country, product, year, projected_sale, sales
  FROM sales_view
  WHERE country IN ('Italy', 'Japan') AND product IN ('Bounce')
MODEL
  PARTITION BY (country) DIMENSION BY (product, year)
  MEASURES (sales sales, year y, CAST(NULL AS NUMBER) projected_sale) IGNORE NAV
  RULES UPSERT
  (projected_sale[FOR product IN ('Bounce'), 2001] = 
             sales[CV(), 2000] + 
             REGR_SLOPE(sales, y)[CV(), year BETWEEN 1998 AND 2000]))
ORDER BY country, product, year;
</pre><p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                        <p>The output is as follows:</p><pre class="oac_no_warn" dir="ltr">COUNTRY    PRODUCT           YEAR   PROJECTED_SALE  SALES
-------    -------           ----   --------------  -------
Italy      Bounce            1999                    2474.78
Italy      Bounce            2000                    4333.69
Italy      Bounce            2001           6192.6   4846.3
Japan      Bounce            1999                    2961.3
Japan      Bounce            2000                    5133.53
Japan      Bounce            2001          7305.76   6303.6</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9212"></a><div class="props_rev_3"><a id="GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C" name="GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C"></a><h4 id="DWHSG-GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C" class="sect4"><span class="enumeration_section">22.5.6 </span>SQL Modeling Example 6: Calculating Mortgage Amortization
                  </h4>
                  <div>
                     <div class="section">
                        <p>This<a id="d90648e4920" class="indexterm-anchor"></a><a id="d90648e4922" class="indexterm-anchor"></a> example creates mortgage amortization tables for any number of customers, using information about mortgage loans selected from a table of mortgage facts. First, create two tables and insert needed data:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">mortgage_facts</code></p>
                              <p>Holds information about individual customer loans, including the name of the customer, the fact about the loan that is stored in that row, and the value of that fact. The facts stored for this example are loan (<code class="codeph">Loan</code>), annual interest rate (<code class="codeph">Annual_Interest</code>), and number of payments (<code class="codeph">Payments</code>) for the loan. Also, the values for two customers, Smith and Jones, are inserted.
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mortgage_facts (customer VARCHAR2(20), fact VARCHAR2(20),
  amount  NUMBER(10,2));
INSERT INTO mortgage_facts  VALUES ('Smith', 'Loan', 100000);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Annual_Interest', 12);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Payments', 360);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Payment', 0);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Loan', 200000);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Annual_Interest', 12);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Payments', 180);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Payment', 0);
</pre></li>
                           <li>
                              <p><code class="codeph">mortgage</code></p>
                              <p>Holds output information for the calculations. The columns are customer, payment number (<code class="codeph">pmt_num</code>), principal applied in that payment (<code class="codeph">principalp</code>), interest applied in that payment (<code class="codeph">interestp</code>), and remaining loan balance (<code class="codeph">mort_balance</code>). In order to upsert new cells into a partition, you need to have at least one row pre-existing per partition. Therefore, you seed the mortgage table with the values for the two customers before they have made any payments. This seed information could be easily generated using a SQL <code class="codeph">INSERT</code> statement based on the <code class="codeph">mortgage_facts</code> table.
                              </p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">CREATE TABLE mortgage_facts (customer VARCHAR2(20), fact VARCHAR2(20), 
   amount  NUMBER(10,2));

INSERT INTO mortgage_facts  VALUES ('Smith', 'Loan', 100000);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Annual_Interest', 12);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Payments', 360);
INSERT INTO mortgage_facts  VALUES ('Smith', 'Payment', 0);
INSERT INTO mortgage_facts  VALUES ('Smith', 'PaymentAmt', null);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Loan', 200000);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Annual_Interest', 12);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Payments', 180);
INSERT INTO mortgage_facts  VALUES ('Jones', 'Payment', 0);
INSERT INTO mortgage_facts  VALUES ('Jones', 'PaymentAmt', null);


CREATE TABLE mortgage (customer VARCHAR2(20), pmt_num NUMBER(4),
   principalp NUMBER(10,2), interestp NUMBER(10,2), mort_balance NUMBER(10,2));

INSERT INTO mortgage VALUES ('Jones',0, 0, 0, 200000);
INSERT INTO mortgage VALUES ('Smith',0, 0, 0, 100000);
</pre><p>See <span class="q">"<a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">Examples of SQL Modeling</a>"</span> for information about the views required to run this example.
                        </p>
                        <p>The following SQL statement is complex, so individual lines have been annotated as needed. These lines are explained in more detail later.</p><pre class="oac_no_warn" dir="ltr">SELECT c, p, m, pp, ip
FROM MORTGAGE
MODEL                                                                  --See 1
REFERENCE R ON
   (SELECT customer, fact, amt                                         --See 2
    FROM mortgage_facts
    MODEL DIMENSION BY (customer, fact) MEASURES (amount amt)          --See 3
      RULES
       (amt[any, 'PaymentAmt']= (amt[CV(),'Loan']*
          Power(1+ (amt[CV(),'Annual_Interest']/100/12),
                  amt[CV(),'Payments']) *
         (amt[CV(),'Annual_Interest']/100/12)) /
         (Power(1+(amt[CV(),'Annual_Interest']/100/12),
                amt[CV(),'Payments']) - 1)
       )
    )
  DIMENSION BY (customer cust, fact) measures (amt)                     --See 4
MAIN amortization
  PARTITION BY (customer c)                                             --See 5
  DIMENSION BY (0 p)                                                    --See 6
  MEASURES (principalp pp, interestp ip, mort_balance m, customer mc)   --See 7
  RULES
    ITERATE(1000) UNTIL (ITERATION_NUMBER+1 =
r.amt[mc[0],'Payments'])                                                --See 8
    (ip[ITERATION_NUMBER+1] = m[CV()-1] *
       r.amt[mc[0], 'Annual_Interest']/1200,                            --See 9
     pp[ITERATION_NUMBER+1] = r.amt[mc[0], 'PaymentAmt'] - ip[CV()],    --See 10
      m[ITERATION_NUMBER+1] = m[CV()-1] - pp[CV()]                      --See 11
    )
ORDER BY c, p;
</pre><p>The following numbers refer to the numbers listed in the example:</p>
                        <p>1: This is the start of the main model definition.</p>
                        <p>2 through 4: These lines mark the start and end of the reference model labeled <code class="codeph">R</code>. This model defines a <code class="codeph">SELECT</code> statement that calculates the monthly payment amount for each customer's loan. The <code class="codeph">SELECT</code> statement uses its own <code class="codeph">MODEL</code> clause starting at the line labeled 3 with a single rule that defines the <code class="codeph">amt</code> value based on information from the <code class="codeph">mortgage_facts</code> table. The measure returned by reference model <code class="codeph">R</code> is <code class="codeph">amt</code>, dimensioned by customer name <code class="codeph">cust</code> and fact value <code class="codeph">fact</code> as defined in the line labeled 4.
                        </p>
                        <p>The reference model is computed once and the values are then used in the main model for computing other calculations. Reference model <code class="codeph">R</code> will return a row for each existing row of <code class="codeph">mortgage_facts</code>, and it will return the newly calculated rows for each customer where the fact type is <code class="codeph">Payment</code> and the <code class="codeph">amt</code> is the monthly payment amount. If you wish to use a specific amount from the <code class="codeph">R</code> output, you address it with the expression <code class="codeph">r.amt[&lt;customer_name&gt;,&lt;fact_name&gt;]</code>.
                        </p>
                        <p>5: This is the continuation of the main model definition. You will partition the output by customer, aliased as <code class="codeph">c</code>.
                        </p>
                        <p>6: The main model is dimensioned with a constant value of 0, aliased as <code class="codeph">p</code>. This represents the payment number of a row.
                        </p>
                        <p>7: Four measures are defined: <code class="codeph">principalp (pp)</code> is the principal amount applied to the loan in the month, <code class="codeph">interestp (ip)</code> is the interest paid that month, <code class="codeph">mort_balance (m)</code> is the remaining mortgage value after the payment of the loan, and <code class="codeph">customer (mc)</code> is used to support the partitioning.
                        </p>
                        <p>8: This begins the rules block. It will perform the rule calculations up to 1000 times. Because the calculations are performed once for each month for each customer, the maximum number of months that can be specified for a loan is 1000. Iteration is stopped when the <code class="codeph">ITERATION_NUMBER+1</code> equals the amount of payments derived from reference <code class="codeph">R</code>. Note that the value from reference <code class="codeph">R</code> is the <code class="codeph">amt</code> (amount) measure defined in the reference clause. This reference value is addressed as <code class="codeph">r.amt[&lt;customer_name&gt;,&lt;fact&gt;]</code>. The expression used in the iterate line,  <code class="codeph">"r.amt[mc[0], 'Payments']"</code> is resolved to be the amount from reference <code class="codeph">R</code>, where the customer name is the value resolved by <code class="codeph">mc[0]</code>. Because each partition contains only one customer, <code class="codeph">mc[0]</code> can have only one value. Thus <code class="codeph">"r.amt[mc[0], 'Payments']"</code> yields the reference clause's value for the number of payments for the current customer. This means that the rules will be performed as many times as there are payments for that customer.
                        </p>
                        <p>9 through 11: The first two rules in this block use the same type of <code class="codeph">r.amt</code> reference that was explained in 8. The difference is that the ip rule defines the fact value as <code class="codeph">Annual_Interest</code>. Note that each rule refers to the value of one of the other measures. The expression used on the left side of each rule, <code class="codeph">"[ITERATION_NUMBER+1]"</code> will create a new dimension value, so the measure will be upserted into the result set. Thus the result will include a monthly amortization row for all payments for each customer. 
                        </p>
                        <p>The final line of the example sorts the results by customer and loan payment number.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>