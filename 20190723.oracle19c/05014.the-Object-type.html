<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>The Object Type Translator</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="about-Collections.html" title="Previous" type="text/html">
      <link rel="next" href="user-exits.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="about-Collections.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="user-exits.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name"> Applications </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> The Object Type Translator</li>
            </ol>
            <a id="GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE" name="GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE"></a><a id="LNPCC019"></a>
            
            <h2 id="LNPCC-GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE" class="sect2"><span class="enumeration_chapter">19 </span> The Object Type Translator
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses the OTT (Object Type Translator)<a id="d101336e22" class="indexterm-anchor"></a>, which maps database object types, LOB types, and collection types to C structs for use in Pro*C/C++ applications. 
               </p>
               <p>The chapter includes the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="the-Object-type.html#GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F">OTT Overview</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-AA1C144E-3E94-47E5-A391-16318A9E262D">What is the Object Type Translator</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3">AUsing OTT with OCI Applications</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942">About Using OTT with Pro*C/C++ Applications</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0">OTT Reference</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4435"></a><div class="props_rev_3"><a id="GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F" name="GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F"></a><h3 id="LNPCC-GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F" class="sect3"><span class="enumeration_section">19.1 </span>OTT Overview
               </h3>
               <div>
                  <p>OTT (The Object Type Translator) assists in the development of applications that make use of user-defined types in an Oracle server.</p>
                  <p>Through the use of SQL CREATE TYPE statements, you can create object types. The definitions of these types are stored in the database, and can be used in the creation of database tables. Once these tables are populated, an OCI, Pro*C/C++, or Java programmer can access objects stored in the tables.</p>
                  <p>An application that accesses object data must be able to represent the data in a host language format. This is accomplished by representing object types as C structs. It would be possible for a programmer to code struct declarations by hand to represent database object types, but this can be very time-consuming and error-prone if many types are involved. OTT simplifies this step by automatically generating appropriate struct declarations. For Pro*C/C++, the application only needs to include the header file generated by OTT. In OCI, the application also needs to call an initialization function generated by OTT.</p>
                  <p>In addition to creating structs that represent stored datatypes, OTT also generates parallel indicator structs which indicate whether an object type or its fields are NULL.</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">LOBs</a></li>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                        <li><a href="about-Collections.html#GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA">Collections</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4436"></a><div class="props_rev_3"><a id="GUID-AA1C144E-3E94-47E5-A391-16318A9E262D" name="GUID-AA1C144E-3E94-47E5-A391-16318A9E262D"></a><h3 id="LNPCC-GUID-AA1C144E-3E94-47E5-A391-16318A9E262D" class="sect3"><span class="enumeration_section">19.2 </span>What is the Object Type Translator
               </h3>
               <div>
                  <p>The Object Type Translator (OTT) converts database definitions of object types and named collection types into C struct declarations which can be included in an OCI or Pro*C/C++ application.</p>
                  <p>Both OCI programmers and Pro*C/C++ programmers must explicitly invoke OTT to translate database types to C representations. OCI programmers must also initialize a data structure called the <span class="italic">Type Version Table</span> with information about the user-defined types required by the program. Code to perform this initialization is generated by OTT. In Pro*C/C++, the type version information is recorded in the <code class="codeph">OUTTYPE</code> file which is passed as a parameter to Pro*C/C++.
                  </p>
                  <p>On most operating systems, OTT is invoked on the command line. It takes as input an <code class="codeph">INTYPE</code> file, and it generates an <code class="codeph">OUTTYPE</code> file and one or more C header files and an optional implementation file (for OCI programmers). The following is an example of a command that invokes OTT:
                  </p><pre class="oac_no_warn" dir="ltr">ott userid=scott/tiger intype=demoin.typ outtype=demoout.typ code=c hfile=demo.h</pre><p></p>
                  <p>This command causes OTT to connect to the database with username <span class="italic">scott</span> and password <span class="italic">tiger</span>, and translate database types to C structs, based on instructions in the <code class="codeph">INTYPE</code> file, <span class="italic"><code class="codeph">demoin.typ</code></span>. The resulting structs are output to the header file, <span class="italic">demo.h</span>, for the host language (C) specified by the <code class="codeph">CODE</code> parameter. The <code class="codeph">OUTTYPE</code> file, <span class="italic"><code class="codeph">demoout.typ</code></span>, receives information about the translation.
                  </p>
                  <p>Each of these parameters is described in more detail in later sections of this chapter.</p>
                  <p>Sample <code class="codeph">demoin.typ</code> file:
                  </p><pre class="oac_no_warn" dir="ltr">CASE=LOWER
TYPE employee
</pre><p>Sample <code class="codeph">demoout.typ</code> file:
                  </p><pre class="oac_no_warn" dir="ltr">CASE = LOWER
TYPE SCOTT.EMPLOYEE AS employee
  VERSION = "$8.0"
  HFILE = demo.h
</pre><p>In this example, the <code class="codeph">demoin.typ</code> file contains the type to be translated, preceded by TYPE (for example, TYPE employee). The structure of the <code class="codeph">OUTTYPE</code> file is similar to the <code class="codeph">INTYPE</code> file, with the addition of information obtained by OTT.
                  </p>
                  <p>Once OTT has completed the translation, the header file contains a C struct representation of each type specified in the <code class="codeph">INTYPE</code> file, and a NULL indicator struct corresponding to each type. For example, if the employee type listed in the <code class="codeph">INTYPE</code> file was defined as
                  </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT
(
    name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary     NUMBER
);
</pre><p>the header file generated by OTT (<code class="codeph">demo.h</code>) includes, among other items, the following declarations:
                  </p><pre class="oac_no_warn" dir="ltr">struct employee
{
    OCIString * name;
    OCINumber empno;
    OCINumber deptno;
    OCIDate   hiredate;
    OCINumber salary;
};
typedef struct emp_type emp_type;

struct employee_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd deptno;
    OCIInd hiredate;
    OCIInd salary;
};
typedef struct employee_ind employee_ind;
</pre><p>The datatypes that appear in the struct declarations (for example, <span class="bold">OCIString</span> and <span class="bold">OCIInd</span>) are special datatypes which were new in Oracle 8.
                  </p>
                  <p>The following sections describe these aspects of using OTT:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="the-Object-type.html#GUID-FF35352F-4611-4341-813E-0E955DA528F5">About Creating Types in the Database</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2">About Invoking OTT</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530">The OTT Command Line</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338">The INTYPE File</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9">OTT Datatype Mappings</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4">NULL Indicator Structs</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-A9A00891-FD32-4B0A-813A-4064DF43557B">OTT Support for Type Inheritance</a></p>
                     </li>
                  </ul>
                  <p>The remaining sections of the chapter discuss the use of OTT with OCI and Pro*C/C++, followed by a reference section that describes command line syntax, parameters, <code class="codeph">INTYPE</code> file structure, nested <code class="codeph">#include</code> file generation, schema names usage, default name mapping, and restrictions.
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="the-Object-type.html#GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9">OTT Datatype Mappings</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4437"></a><div class="props_rev_3"><a id="GUID-FF35352F-4611-4341-813E-0E955DA528F5" name="GUID-FF35352F-4611-4341-813E-0E955DA528F5"></a><h4 id="LNPCC-GUID-FF35352F-4611-4341-813E-0E955DA528F5" class="sect4"><span class="enumeration_section">19.2.1 </span>About Creating Types in the Database
                  </h4>
                  <div>
                     <p>The first step in using OTT is to create object types or named collection types and store them in the database. This is accomplished through the use of the SQL CREATE TYPE statement.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4438"></a><div class="props_rev_3"><a id="GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2" name="GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2"></a><h4 id="LNPCC-GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2" class="sect4"><span class="enumeration_section">19.2.2 </span>About Invoking OTT
                  </h4>
                  <div>
                     <p>The next step is to invoke OTT.</p>
                     <p>You can specify OTT parameters on the command line, or in a file called a configuration file. Certain parameters can also be specified in the <code class="codeph">INTYPE</code> file.
                     </p>
                     <p>If you specify a parameter in more than one place, its value on the command line will take precedence over its value in the <code class="codeph">INTYPE</code> file, which takes precedence over its value in a user-defined configuration file, which takes precedence over its value in the default configuration file.
                     </p>
                     <p>For global options -- that is, options on the command line or options at the beginning of the <code class="codeph">INTYPE</code> file before any TYPE statements -- the value on the command line overrides the value in the <code class="codeph">INTYPE</code> file. (The options that can be specified globally in the <code class="codeph">INTYPE</code> file are <code class="codeph">CASE</code>, <code class="codeph">CODE</code>, <code class="codeph">INITFILE</code>, <code class="codeph">OUTDIR</code>, and <code class="codeph">INITFUNC</code>, but not <code class="codeph">HFILE</code>.) Anything in the <code class="codeph">INTYPE</code> file in a TYPE specification applies to a particular type only, and overrides anything on the command line that would otherwise apply to the type. So if you enter <code class="codeph">TYPE person HFILE=p.h</code>, it applies to <code class="codeph">person</code> only and overrides the <code class="codeph">HFILE</code> on the command line. The statement is not considered a command-line parameter.
                     </p>
                  </div><a id="LNPCC4439"></a><div class="props_rev_3"><a id="GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12" name="GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12"></a><h5 id="LNPCC-GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12" class="sect5"><span class="enumeration_section">19.2.2.1 </span>Command Line
                     </h5>
                     <div>
                        <div class="section">
                           <p>Parameters (also called options) set on the command line override any set elsewhere.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4440"></a><div class="props_rev_3"><a id="GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0" name="GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0"></a><h5 id="LNPCC-GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0" class="sect5"><span class="enumeration_section">19.2.2.2 </span>Configuration File
                     </h5>
                     <div>
                        <div class="section">
                           <p>A configuration file is a text file that contains OTT parameters. Each non-blank line in the file contains one parameter, with its associated value or values. If more than one parameter is put on a line, only the first one will be used. No whitespace may occur on any non-blank line of a configuration file.</p>
                           <p>A configuration file can be named on the command line. In addition, a default configuration file is always read. This default configuration file must always exist, but can be empty. The name of the default configuration file is <code class="codeph">ottcfg.cfg</code>, and the location of the file is system-specific. See your platform-specific documentation for further information.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4441"></a><div class="props_rev_3"><a id="GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC" name="GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC"></a><h5 id="LNPCC-GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC" class="sect5"><span class="enumeration_section">19.2.2.3 </span>INTYPE File
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">INTYPE</code> file gives a list of types for OTT to translate. 
                           </p>
                           <p>The parameters <code class="codeph">CASE</code>, <code class="codeph">HFILE</code>, <code class="codeph">INITFUNC</code>, and <code class="codeph">INITFILE</code> can appear in the <code class="codeph">INTYPE</code> file. 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338">The INTYPE File</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4442"></a><div class="props_rev_3"><a id="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530" name="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530"></a><h4 id="LNPCC-GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530" class="sect4"><span class="enumeration_section">19.2.3 </span>The OTT Command Line
                  </h4>
                  <div>
                     <p>On most platforms, OTT is invoked on the command line.   You can specify the input and output files and the database connection information, among other things. Consult your platform-specific documentation to see how to invoke OTT on your platform. </p>
                     <p>The following is an example (example 1) of an OTT invocation from the command line:</p><pre class="oac_no_warn" dir="ltr">ott userid=scott/tiger intype=demoin.typ outtype=demoout.typ code=c hfile=demo.h</pre><div class="infoboxnote" id="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530__GUID-18ACB56E-8EAB-49C3-97EE-AFEC587CC8A2">
                        <p class="notep1">Note:</p>
                        <p>No spaces are permitted around the equals sign (=).</p>
                     </div>
                     <p>The following sections describe the elements of the command line used in this example.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="the-Object-type.html#GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0">OTT Reference</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC4443"></a><div class="props_rev_3"><a id="GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782" name="GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782"></a><h5 id="LNPCC-GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782" class="sect5"><span class="enumeration_section">19.2.3.1 </span>OTT
                     </h5>
                     <div>
                        <div class="section">
                           <p>Causes OTT to be invoked. It must be the first item on the command line.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4444"></a><div class="props_rev_3"><a id="GUID-FC89B923-810B-46A8-86E8-2E5962363B2F" name="GUID-FC89B923-810B-46A8-86E8-2E5962363B2F"></a><h5 id="LNPCC-GUID-FC89B923-810B-46A8-86E8-2E5962363B2F" class="sect5"><span class="enumeration_section">19.2.3.2 </span>Userid
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the database connection information which OTT will use. In example one, OTT will attempt to connect with username <span class="italic">scott</span> and password <span class="italic">tiger</span>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4445"></a><div class="props_rev_3"><a id="GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413" name="GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413"></a><h5 id="LNPCC-GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413" class="sect5"><span class="enumeration_section">19.2.3.3 </span>INTYPE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the name of the <code class="codeph">INTYPE</code> file which will be used. In example 1, the name of the <code class="codeph">INTYPE</code> file is specified as <span class="italic"><code class="codeph">demoin.typ</code></span>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4446"></a><div class="props_rev_3"><a id="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8" name="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8"></a><h5 id="LNPCC-GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8" class="sect5"><span class="enumeration_section">19.2.3.4 </span>OUTTYPE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the name of the <code class="codeph">OUTTYPE</code> file. When OTT generates the C header file, it also writes information about the translated types into the <code class="codeph">OUTTYPE</code> file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.
                           </p>
                           <p>In example one, the name of the OUTTYPE file is specified as <span class="italic"><code class="codeph">demoout.typ</code></span>.
                           </p>
                           <div class="infoboxnote" id="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8__GUID-F4123970-5857-4488-A840-1019949744C4">
                              <p class="notep1">Note:</p>
                              <p>If the file specified by <code class="codeph">OUTTYPE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4447"></a><div class="props_rev_3"><a id="GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77" name="GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77"></a><h5 id="LNPCC-GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77" class="sect5"><span class="enumeration_section">19.2.3.5 </span>CODE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the target language for the translation. The following options are available:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>C (equivalent to ANSI_C)</p>
                              </li>
                              <li>
                                 <p>ANSI_C (for ANSI C)</p>
                              </li>
                              <li>
                                 <p>KR_C (for Kernighan &amp; Ritchie C)</p>
                              </li>
                           </ul>
                           <p>There is currently no default value, so this parameter is required.</p>
                           <p>Struct declarations are identical in both C dialects. The style in which the initialization function defined in the <code class="codeph">INITFILE</code> file is defined depends on whether KR_C is used. If the <code class="codeph">INITFILE</code> option is not used, all three options are equivalent.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4448"></a><div class="props_rev_3"><a id="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32" name="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32"></a><h5 id="LNPCC-GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32" class="sect5"><span class="enumeration_section">19.2.3.6 </span>HFILE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the name of the C header file to which the generated structs should be written. In example 1, the generated structs will be stored in a file called <code class="codeph">demo.h</code>.
                           </p>
                           <div class="infoboxnote" id="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32__GUID-10FAE0BF-E45A-4F60-8EC4-B0BF742151B8">
                              <p class="notep1">Note:</p>
                              <p>If the file specified by <code class="codeph">HFILE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4449"></a><div class="props_rev_3"><a id="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602" name="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602"></a><h5 id="LNPCC-GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602" class="sect5"><span class="enumeration_section">19.2.3.7 </span>INITFILE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the use of the C source file into which the type initialization function is to be written. </p>
                           <p>The initialization function is only needed in OCI programs. In Pro*C/C++ programs, the Pro*C/C++ runtime library initializes types for the user.</p>
                           <div class="infoboxnote" id="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602__GUID-ED488FC5-398A-468B-8DC6-557529461D47">
                              <p class="notep1">Note:</p>
                              <p>If the file specified by <code class="codeph">INITFILE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4450"></a><div class="props_rev_3"><a id="GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9" name="GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9"></a><h5 id="LNPCC-GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9" class="sect5"><span class="enumeration_section">19.2.3.8 </span>INITFUNC
                     </h5>
                     <div>
                        <div class="section">
                           <p>Specifies the name of the initialization function to be defined in the <code class="codeph">INITFILE</code>.
                           </p>
                           <p>If this parameter is not used and an initialization function is generated, the name of the initialization function will be the same as the base name of the <code class="codeph">INITFILE</code>.
                           </p>
                           <p>This function is only needed in OCI programs.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4451"></a><div class="props_rev_3"><a id="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338" name="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338"></a><h4 id="LNPCC-GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338" class="sect4"><span class="enumeration_section">19.2.4 </span>The INTYPE File
                  </h4>
                  <div>
                     <p>When you run OTT, the <code class="codeph">INTYPE</code> file tells OTT which database types should be translated. It can also control the naming of the generated structs. You can create the <code class="codeph">INTYPE</code> file, or use the <code class="codeph">OUTTYPE</code> file of a previous invocation of OTT. If the <code class="codeph">INTYPE</code> parameter is not used, all types in the schema to which OTT connects are translated.
                     </p>
                     <p>The following is a simple example of a user-created <code class="codeph">INTYPE</code> file:
                     </p><pre class="oac_no_warn" dir="ltr">CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE "Person"
TYPE PURCHASE_ORDER AS p_o
</pre><p>The first line, with the <code class="codeph">CASE</code> keyword, indicates that generated C identifiers should be in lower case. However, this <code class="codeph">CASE</code> option is only applied to those identifiers that are not explicitly mentioned in the <code class="codeph">INTYPE</code> file. Thus, <span class="italic">employee</span><code class="codeph"> </code>and <span class="italic">ADDRESS</span> would always result in C structures <code class="codeph">employee</code> and <code class="codeph">ADDRESS</code>, respectively. The members of these structures would be named in lower case.
                     </p>
                     <p>The lines that begin with the TYPE keyword specify which types in the database should be translated. In this case, the<span class="italic"> EMPLOYEE, ADDRESS, ITEM, PERSON, </span>and<span class="italic"> PURCHASE_ORDER</span> types.
                     </p>
                     <p>The TRANSLATE...AS keywords specify that the name of an object attribute should be changed when the type is translated into a C struct. In this case, the SALARY$ attribute of the <code class="codeph">employee</code> type is translated to <code class="codeph">salary</code>.
                     </p>
                     <p>The AS keyword in the final line specifies that the name of an object type should be changed when it is translated into a struct. In this case, the <span class="italic">purchase_order</span> database type is translated into a struct called<span class="italic"> p_o</span>.
                     </p>
                     <p>If you do not use AS to translate a type or attribute name, the database name of the type or attribute will be used as the C identifier name, except that the <code class="codeph">CASE</code> option will be observed, and any characters that cannot be mapped to a legal C identifier character will be replaced by an underscore. Reasons for translating a type or attribute name include:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>the name contains characters other than letters, digits, and underscores</p>
                        </li>
                        <li>
                           <p>the name conflicts with a C keyword</p>
                        </li>
                        <li>
                           <p>the type name conflicts with another identifier in the same scope. This can happen, for example, if the program uses two types with the same name from different schemas.</p>
                        </li>
                        <li>
                           <p>the programmer prefers a different name</p>
                        </li>
                     </ul>
                     <p>OTT may need to translate additional types that are not listed in the <code class="codeph">INTYPE</code> file. This is because OTT analyzes the types in the <code class="codeph">INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary. For example, if the <span class="italic">ADDRESS</span><code class="codeph"> </code>type were not listed in the <code class="codeph">INTYPE</code> file, but the <span class="italic">Person</span> type had an attribute of type <span class="italic">ADDRESS</span>, OTT would still translate <span class="italic">ADDRESS</span> because it is required to define the <span class="italic">Person</span> type.
                     </p>
                     <div class="infoboxnote" id="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338__GUID-458036D6-00D4-4715-9322-9EE3C0DB0831">
                        <p class="notep1">Note:</p>
                        <p>As of Release 1 (9.0.1), users may specify TRANSITIVE = FALSE to <span class="italic">not</span> generate types that are not specified in the <code class="codeph">INTYPE</code> file. TRANSITIVE is set to TRUE by default.
                        </p>
                     </div>
                     <p>A normal case-insensitive SQL identifier can be spelled in any combination of upper and lower case in the <code class="codeph">INTYPE</code> file, and is not quoted.
                     </p>
                     <p>Use quotation marks, such as TYPE "<span class="italic">Person</span>" to reference SQL identifiers that have been created in a case-sensitive manner, for example, CREATE TYPE "<span class="italic">Person</span>". A SQL identifier is case-sensitive if it was quoted when it was declared.
                     </p>
                     <p>Quotation marks can also be used to refer to a SQL identifier that is also an OTT-reserved word, for example, TYPE "CASE". In this case, the quoted name must be in upper case if the SQL identifier was created in a case-insensitive manner, for example, CREATE TYPE Case. If an OTT-reserved word is used to refer to the name of a SQL identifier but is not quoted, OTT will report a syntax error in the <code class="codeph">INTYPE</code> file.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="the-Object-type.html#GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9">CASE</a></li>
                           <li><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">Structure of the INTYPE File</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4452"></a><div class="props_rev_3"><a id="GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9" name="GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9"></a><h4 id="LNPCC-GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9" class="sect4"><span class="enumeration_section">19.2.5 </span>OTT Datatype Mappings
                  </h4>
                  <div>
                     <p>When OTT generates a C struct from a database type, the struct contains one element corresponding to each attribute of the object type. The datatypes of the attributes are mapped to types that are used in Oracle object data types. The datatypes found in Oracle include a set of predefined, primitive types, and provide for the creation of user-defined types, like object types and collections.</p>
                     <p>The set of predefined types includes standard types that are familiar to most programmers, including number and character types. It also includes datatypes that were introduced with Oracle8 (for example, BLOB or CLOB).</p>
                     <p>Oracle also includes a set of predefined types that are used to represent object type attributes in C structs. As an example, consider the following object type definition, and its corresponding OTT-generated struct declarations:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT
(   name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary$    NUMBER);
</pre><p>The OTT output, assuming <code class="codeph">CASE=LOWER</code> and no explicit mappings of type or attribute names, is:
                     </p><pre class="oac_no_warn" dir="ltr">struct employee
{   OCIString * name;
    OCINumber empno;
    OCINumber department;
    OCIDate   hiredate;
    OCINumber salary_;
};
typedef struct emp_type emp_type;
struct employee_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd department;
    OCIInd hiredate;
    OCIInd salary_;
}
typedef struct employee_ind employee_ind;
</pre><p>The indicator struct <code class="codeph">(struct employee_ind)</code> is explained in <span class="q">"<a href="the-Object-type.html#GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4">NULL Indicator Structs</a>"</span>.
                     </p>
                     <p>The datatypes in the struct declarations—<code class="codeph">OCIString</code>, <code class="codeph">OCINumber</code>, <code class="codeph">OCIDate</code>, <code class="codeph">OCIInd</code>—are C mappings of object types introduced in Oracle8. They are used here to map the datatypes of the object type attributes. The <code class="codeph">NUMBER</code> datatype of the <code class="codeph">empno</code> attribute, maps to the new <code class="codeph">OCINumber</code> datatype, for example. These new datatypes can also be used as the types of bind and define variables.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../lnoci/oci-programming-basics.html#LNOCI-GUID-3CA268B4-AFC8-467C-B127-0E15E90A14DB" target="_blank"><span class="italic">OCI Data Structures</span></a></li>
                        </ul>
                     </div>
                  </div><a id="LNPCC4454"></a><a id="LNPCC4455"></a><a id="LNPCC4453"></a><div class="props_rev_3"><a id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A" name="GUID-40348350-2921-4CA0-8609-A66CCE4F952A"></a><h5 id="LNPCC-GUID-40348350-2921-4CA0-8609-A66CCE4F952A" class="sect5"><span class="enumeration_section">19.2.5.1 </span>Mapping Object Datatypes to C
                     </h5>
                     <div>
                        <div class="section">
                           <p>This section describes the mappings of object attribute types to C types generated by OTT. <a href="the-Object-type.html#GUID-40348350-2921-4CA0-8609-A66CCE4F952A__CHDFGJDA" title="Object Datatype Mappings for Object Type Attributes">Table 19-1</a> lists the mappings from types that can be used as attributes of object datatypes that are generated by OTT.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__CHDFGJDA">
                           <p class="titleintable">Table 19-1 Object Datatype Mappings for Object Type Attributes</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Object Datatype Mappings for Object Type Attributes" summary="Object Datatype Mappings for Object Type Attributes" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="54%" id="d101336e1194">Object Attribute Types </th>
                                    <th align="left" valign="bottom" width="46%" id="d101336e1197">C Mapping</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1202" headers="d101336e1194 ">
                                       <p>VARCHAR2(N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1202 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1209" headers="d101336e1194 ">
                                       <p>VARCHAR(N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1209 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1216" headers="d101336e1194 ">
                                       <p>CHAR(N), CHARACTER(N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1216 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1223" headers="d101336e1194 ">
                                       <p>NUMBER, NUMBER(N), NUMBER(N,N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1223 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1230" headers="d101336e1194 ">
                                       <p>NUMERIC, NUMERIC(N), NUMERIC(N,N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1230 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1237" headers="d101336e1194 ">
                                       <p>REAL</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1237 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1244" headers="d101336e1194 ">
                                       <p>INT, INTEGER, SMALLINT</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1244 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1251" headers="d101336e1194 ">
                                       <p>FLOAT, FLOAT(N), DOUBLE PRECISION</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1251 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1258" headers="d101336e1194 ">
                                       <p>DEC, DEC(N), DEC(N,N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1258 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1265" headers="d101336e1194 ">
                                       <p>DECIMAL, DECIMAL(N), DECIMAL(N,N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1265 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1272" headers="d101336e1194 ">
                                       <p>DATE</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1272 d101336e1197 ">
                                       <p>OCIDate *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1280" headers="d101336e1194 ">
                                       <p>BLOB</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1280 d101336e1197 ">
                                       <p>OCIBlobLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1287" headers="d101336e1194 ">
                                       <p>CLOB</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1287 d101336e1197 ">
                                       <p>OCIClobLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1294" headers="d101336e1194 ">
                                       <p>BFILE</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1294 d101336e1197 ">
                                       <p>OCIBFileLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1301" headers="d101336e1194 ">
                                       <p>Nested Object Type</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1301 d101336e1197 ">
                                       <p>C name of the nested object type.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1308" headers="d101336e1194 ">
                                       <p>REF</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1308 d101336e1197 ">
                                       <p>Declared using typedef; equivalent to OCIRef *.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1315" headers="d101336e1194 ">
                                       <p>RAW(N)</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1315 d101336e1197 ">
                                       <p>OCIRaw *</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p><a href="the-Object-type.html#GUID-40348350-2921-4CA0-8609-A66CCE4F952A__G454458" title="Object Datatype Mappings for Collection Types">Table 19-2</a> shows the mappings of named collection types to object datatypes generated by OTT:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__G454458">
                           <p class="titleintable">Table 19-2 Object Datatype Mappings for Collection Types</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Object Datatype Mappings for Collection Types" summary="Object Datatype Mappings for Collection Types" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d101336e1338">Named Collection Type</th>
                                    <th align="left" valign="bottom" width="68%" id="d101336e1341">C Mapping</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d101336e1346" headers="d101336e1338 ">
                                       <p>VARRAY</p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d101336e1346 d101336e1341 ">
                                       <p>Declared using typedef; equivalent to OCIArray *.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d101336e1353" headers="d101336e1338 ">
                                       <p>NESTED TABLE</p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d101336e1353 d101336e1341 ">
                                       <p>Declared using typedef; equivalent to OCITable *.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__GUID-D7D19BC1-470F-48B4-AAD6-D50291D03F52">
                              <p class="notep1">Note:</p>
                              <p>For REF, VARRAY, and NESTED TABLE types, OTT generates a typedef. The type declared in the typedef is then used as the type of the data member in the struct declaration. </p>
                           </div>
                           <p>If an object type includes an attribute of a REF or collection type, a typedef for the REF or collection type is first generated. Then the struct declaration corresponding to the object type is generated. The struct includes an element whose type is a pointer to the REF or collection type.</p>
                           <p>If an object type includes an attribute whose type is another object type, OTT first generates the nested type (if TRANSITIVE = TRUE.) It then maps the object type attribute to a nested struct of the type of the nested object type.</p>
                           <p>The C datatypes to which OTT maps non-object database attribute types are structures, which, except for OCIDate, are opaque.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A">OTT Type Mapping Example</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4456"></a><div class="props_rev_3"><a id="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A" name="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A"></a><h5 id="LNPCC-GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A" class="sect5"><span class="enumeration_section">19.2.5.2 </span>OTT Type Mapping Example
                     </h5>
                     <div>
                        <div class="section">
                           <p>The following example demonstrates the various type mappings created by OTT.</p>
                           <p>Given the following database types:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE my_varray AS VARRAY(5) of integer;

CREATE TYPE object_type AS OBJECT
(object_name    VARCHAR2(20));

CREATE TYPE my_table AS TABLE OF object_type;

CREATE TYPE many_types AS OBJECT
( the_varchar    VARCHAR2(30),
  the_char       CHAR(3),
  the_blob       BLOB,
  the_clob       CLOB,
  the_object     object_type,
  another_ref    REF other_type,
  the_ref        REF many_types,
  the_varray     my_varray,
  the_table      my_table,
  the_date       DATE,
  the_num        NUMBER,
  the_raw        RAW(255));
</pre><p>and an <code class="codeph">INTYPE</code> file that includes:
                           </p><pre class="oac_no_warn" dir="ltr">CASE = LOWER
TYPE many_types
</pre><p>OTT would generate the following C structs:</p>
                           <div class="infoboxnote" id="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A__GUID-BAC39CEC-5273-45CA-B3AD-23BDF48ABE41">
                              <p class="notep1">Note:</p>
                              <p>Comments are provided here to help explain the structs. These comments are not part of actual OTT output.</p>
                           </div><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;             /* part of many_types */
typedef OCITable my_table;              /* part of many_types*/
typedef OCIRef other_type_ref;
struct object_type                      /* part of many_types */
{
   OCIString * object_name;
};
typedef struct object_type object_type;

struct object_type_ind                  /*indicator struct for*/
{                                       /*object_types*/
   OCIInd _atomic;
   OCIInd object_name;
};
typedef struct object_type_ind object_type_ind;

struct many_types
{
   OCIString *        the_varchar;
   OCIString *        the_char;
   OCIBlobLocator *   the_blob;
   OCIClobLocator *   the_clob;
   struct object_type the_object;
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table; 
   OCIDate            the_date;
   OCINumber          the_num;
   OCIRaw *           the_raw;
};
typedef struct many_types many_types;

struct many_types_ind                   /*indicator struct for*/
{                                       /*many_types*/
   OCIInd _atomic;
   OCIInd the_varchar;
   OCIInd the_char;
   OCIInd the_blob;
   OCIInd the_clob;
   struct object_type_ind the_object;   /*nested*/
   OCIInd another_ref;
   OCIInd the_ref;
   OCIInd the_varray;
   OCIInd the_table;
   OCIInd the_date;
   OCIInd the_num;
   OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;

#endif
</pre><p>Notice that even though only one item was listed for translation in the <code class="codeph">INTYPE</code> file, two object types and two named collection types were translated. This is because the OTT parameter <span class="q">"<a href="the-Object-type.html#GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7">TRANSITIVE</a>"</span>, has the default value of TRUE. As described in that section, when TRANSITIVE=TRUE, OTT automatically translates any types which are used as attributes of a type being translated, in order to complete the translation of the listed type.
                           </p>
                           <p>This is not the case for types that are only accessed by a pointer or REF in an object type attribute. For example, although the <span class="italic">many_types</span><code class="codeph"> type contains the attribute </code><span class="italic">another_ref</span><code class="codeph"> </code><span class="italic">REF other_type</span><code class="codeph">, a declaration of struct other_type</code> was not generated.
                           </p>
                           <p>This example also illustrates how typedefs are used to declare VARRAY, NESTED TABLE, and REF types.</p>
                           <p>The typedefs occur near the beginning:</p><pre class="oac_no_warn" dir="ltr">typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;    
typedef OCITable my_table; 
typedef OCIRef other_type_ref;</pre><p></p>
                           <p>In the struct <code class="codeph">many_types</code>, the VARRAY, NESTED TABLE, and REF attributes are declared:
                           </p><pre class="oac_no_warn" dir="ltr">struct many_types
{
   ...
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table;
   ...
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4457"></a><div class="props_rev_3"><a id="GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4" name="GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4"></a><h4 id="LNPCC-GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4" class="sect4"><span class="enumeration_section">19.2.6 </span>NULL Indicator Structs
                  </h4>
                  <div>
                     <p>Each time OTT generates a C struct to represent a database object type, it also generates a corresponding NULL indicator struct. When an object type is selected into a C struct, NULL indicator information can be selected into a parallel struct.</p>
                     <p>For example, the following NULL indicator struct was generated in the example in the previous section:</p><pre class="oac_no_warn" dir="ltr">struct many_types_ind
{
OCIInd _atomic;
OCIInd the_varchar;
OCIInd the_char;
OCIInd the_blob;
OCIInd the_clob;
struct object_type_ind the_object;
OCIInd another_ref;
OCIInd the_ref;
OCIInd the_varray;
OCIInd the_table;
OCIInd the_date;
OCIInd the_num;
OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;
</pre><p>The layout of the NULL struct is important. The first element in the struct (<code class="codeph">_atomic</code>) is the <span class="italic">atomic NULL indicator</span>. This value indicates the NULL status for the object type as a whole. The atomic NULL indicator is followed by an indicator element corresponding to each element in the OTT-generated struct representing the object type.
                     </p>
                     <p>Notice that when an object type contains another object type as part of its definition (in the earlier example, it is the <span class="italic">object_type</span><code class="codeph"> </code>attribute), the indicator entry for that attribute is the NULL indicator struct (<code class="codeph">object_type_ind</code>) corresponding to the nested object type.
                     </p>
                     <p>VARRAYs and NESTED TABLEs contain the NULL information for their elements. The datatype for all other elements of a NULL indicator struct is <code class="codeph">OCIInd</code>.
                     </p>
                     <p>For more information about atomic NULLness, refer to the discussion of object types in <a href="../lnoci/data-types.html#LNOCI-GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" target="_blank">Data Types</a>.
                     </p>
                  </div>
               </div><a id="LNPCC4458"></a><div class="props_rev_3"><a id="GUID-A9A00891-FD32-4B0A-813A-4064DF43557B" name="GUID-A9A00891-FD32-4B0A-813A-4064DF43557B"></a><h4 id="LNPCC-GUID-A9A00891-FD32-4B0A-813A-4064DF43557B" class="sect4"><span class="enumeration_section">19.2.7 </span>OTT Support for Type Inheritance
                  </h4>
                  <div>
                     <p>To support type inheritance of objects, OTT generates a C struct to represent an object subtype by declaring the inherited attributes in an encapsulated struct with the special name '_super', before declaring the new attributes. Thus, for an object subtype that inherits from a supertype, the first element in the struct is named '_super', followed by elements corresponding to each attribute of the subtype.The type of the element named '_super' is the name of the supertype.</p>
                     <p>For example, given the type <code class="codeph">Person_t</code>, with subtype <code class="codeph">Student_t</code> and subtype <code class="codeph">Employee_t, </code>which are created as follows:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT
( ssn     NUMBER,
  name    VARCHAR2(30),
  address VARCHAR2(100)) NOT FINAL;

CREATE TYPE Student_t UNDER Person_t
( deptid NUMBER,
  major  VARCHAR2(30)) NOT FINAL;

CREATE TYPE Employee_t UNDER Person_t
( empid NUMBER,
  mgr   VARCHAR2(30));
</pre><p>and, given an <code class="codeph">INTYPE</code> file which includes:
                     </p><pre class="oac_no_warn" dir="ltr">CASE=SAME
TYPE EMPLOYEE_T
TYPE STUDENT_T
TYPE PERSON_T
</pre><p>OTT generates the following C structs for <code class="codeph">Person_t</code>, <code class="codeph">Student_t</code>, and <code class="codeph">Employee_t </code>and their null indicator structs: 
                     </p><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef EMPLOYEE_T_ref;
typedef OCIRef STUDENT_T_ref;
typedef OCIRef PERSON_T_ref;

struct PERSON_T
{
   OCINumber SSN;
   OCIString * NAME;
   OCIString * ADDRESS;
};
typedef struct PERSON_T PERSON_T;

struct PERSON_T_ind
{
   OCIInd _atomic;
   OCIInd SSN;
   OCIInd NAME;
   OCIInd ADDRESS;
};
typedef struct PERSON_T_ind PERSON_T_ind;

struct EMPLOYEE_T
{
   PERSON_T _super;
   OCINumber EMPID;
   OCIString * MGR;
};
typedef struct EMPLOYEE_T EMPLOYEE_T;

struct EMPLOYEE_T_ind
{
   PERSON_T _super;
   OCIInd EMPID;
   OCIInd MGR;
};
typedef struct EMPLOYEE_T_ind EMPLOYEE_T_ind;

struct STUDENT_T
{
   PERSON_T _super;
   OCINumber DEPTID;
   OCIString * MAJOR;
};
typedef struct STUDENT_T STUDENT_T;

struct STUDENT_T_ind
{
   PERSON_T _super;
   OCIInd DEPTID;
   OCIInd MAJOR;
};
typedef struct STUDENT_T_ind STUDENT_T_ind;

#endif
</pre><p>The earlier C mapping convention allows simple up-casting from an instance of a subtype to an instance of a supertype in C to work properly. For example:</p><pre class="oac_no_warn" dir="ltr">STUDENT_T *stu_ptr = some_ptr;               /* some STUDENT_T instance  */
PERSON_T  *pers_ptr = (PERSON_T *)stu_ptr;   /* up-casting */
</pre><p>The null indicator structs are generated similarly. Note that for the supertype <code class="codeph">Person_t</code> null indicator struct, the first element is '_atomic', and that for the subtypes <code class="codeph">Employee_t</code> and <code class="codeph">Student_t</code> null indicator structs, the first element is '_super' (no atomic element is generated for subtypes).
                     </p>
                  </div><a id="LNPCC4459"></a><div class="props_rev_3"><a id="GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2" name="GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2"></a><h5 id="LNPCC-GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2" class="sect5"><span class="enumeration_section">19.2.7.1 </span>Substitutable Object Attributes
                     </h5>
                     <div>
                        <p>For attributes of NOT FINAL types (and therefore potentially substitutable), the embedded attribute is represented as a pointer.</p>
                        <p>Consider a type <code class="codeph">Book_t</code> created as: 
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT 
( title   VARCHAR2(30),
  author  Person_t     /* substitutable */);
</pre><p>The corresponding C struct generated by OTT contains a pointer to <code class="codeph">Person_t</code>:
                        </p><pre class="oac_no_warn" dir="ltr">struct Book_t
{
  OCIString  *title;
  Person_t   *author;    /* pointer to Person_t struct */
}
</pre><p>The null indicator struct corresponding to the earlier type is:</p><pre class="oac_no_warn" dir="ltr">struct Book_t_ind
{ 
  OCIInd  _atomic;
  OCIInd  title;
  OCIInd  author;
}
</pre><p>Note that the null indicator struct corresponding to the <code class="codeph">author</code> attribute can be obtained from the <code class="codeph">author</code> object itself. 
                        </p>
                        <p>If a type is defined to be FINAL, it cannot have any subtypes. An attribute of a FINAL type is therefore not substitutable. In such cases, the mapping is as before: the attribute struct is inline. Now, if the type is altered and defined to be NOT FINAL, the mapping will have to change. The new mapping is generated by running OTT again.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="about-Objects.html#GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411">OBJECT GET</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4460"></a><div class="props_rev_3"><a id="GUID-5227CAB0-3505-453B-9075-B0ED867C3B49" name="GUID-5227CAB0-3505-453B-9075-B0ED867C3B49"></a><h4 id="LNPCC-GUID-5227CAB0-3505-453B-9075-B0ED867C3B49" class="sect4"><span class="enumeration_section">19.2.8 </span>The OUTTYPE File
                  </h4>
                  <div>
                     <p>The <code class="codeph">OUTTYPE</code> file is named on the OTT command line. When OTT generates the C header file, it also writes the results of the translation into the <code class="codeph">OUTTYPE</code> file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.
                     </p>
                     <p>The <code class="codeph">OUTTYPE</code> file from one OTT run can be used as the <code class="codeph">INTYPE</code> file for a subsequent OTT invocation.
                     </p>
                     <p>For example, given the simple <code class="codeph">INTYPE</code> file used earlier in this chapter
                     </p><pre class="oac_no_warn" dir="ltr">CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE person
TYPE PURCHASE_ORDER AS p_o
</pre><p>the user has chosen to specify the case for OTT-generated C identifiers, and has provided a list of types that should be translated. In two of these types, naming conventions are specified.</p>
                     <p>The following example shows what the <code class="codeph">OUTTYPE</code> file looks like after running OTT:
                     </p><pre class="oac_no_warn" dir="ltr">CASE = LOWER
TYPE EMPLOYEE AS employee
  VERSION = "$8.0"
  HFILE = demo.h
  TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS AS ADDRESS
  VERSION = "$8.0"
  HFILE = demo.h
TYPE ITEM AS item
  VERSION = "$8.0"
  HFILE = demo.h
TYPE "Person" AS Person
  VERSION = "$8.0"
  HFILE = demo.h
TYPE PURCHASE_ORDER AS p_o
  VERSION = "$8.0"
  HFILE = demo.h
</pre><p>When examining the contents of the <code class="codeph">OUTTYPE</code> file, you might discover types listed that were not included in the <code class="codeph">INTYPE</code> specification. For example, if the <code class="codeph">INTYPE</code> file only specified that the <span class="italic">person</span> type was to be translated:
                     </p><pre class="oac_no_warn" dir="ltr">CASE = LOWER
TYPE PERSON
</pre><p>and the definition of the person type includes an attribute of type <span class="italic">address</span>, then the <code class="codeph">OUTTYPE</code> file will include entries for both <code class="codeph">PERSON </code>and <code class="codeph">ADDRESS</code>. The <code class="codeph">person</code> type cannot be translated completely without first translating <span class="italic">address</span>.
                     </p>
                     <p>When the parameter TRANSITIVE has been set to TRUE (it is the default), OTT analyzes the types in the <code class="codeph">INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary.
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC4462"></a><a id="LNPCC4461"></a><div class="props_rev_3"><a id="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3" name="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3"></a><h3 id="LNPCC-GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3" class="sect3"><span class="enumeration_section">19.3 </span>AUsing OTT with OCI Applications
               </h3>
               <div>
                  <div class="section">
                     <p>C header and implementation files that have been generated by OTT can be used by an OCI application that accesses objects in a database server. Incorporate the header file into the OCI code with an <code class="codeph">#include</code> statement.
                     </p>
                     <p>Once the header file has been included, the OCI application can access and manipulate object data in the host language format.</p>
                     <p><a href="the-Object-type.html#GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3__I440389">Figure 19-1</a> shows the steps involved in using OTT with OCI.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>SQL is used to create type definitions in the database.</span></li>
                     <li><span>OTT generates a header file containing C representations of object types and named collection types. It also generates an implementation file, as named with the <code class="codeph">INITFILE</code> option.</span></li>
                     <li><span>The application is written. User-written code in the OCI application declares and calls the <code class="codeph">INITFUNC</code> function.</span></li>
                     <li><span>The header file is included in an OCI source code file.</span></li>
                     <li><span>The OCI application, including the implementation file generated by OTT, is compiled and linked with the OCI libraries.</span></li>
                     <li><span>The OCI executable is run against the Oracle Server.</span></li>
                  </ol>
                  <div class="section">
                     <div class="figure" id="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3__I440389">
                        <p class="titleinfigure">Figure 19-1 Using OTT with OCI</p><img src="img/lnpcc072.gif" width="499" alt="Description of Figure 19-1 follows" title="Description of Figure 19-1 follows" longdesc="img_text/lnpcc072.html"><br><a href="img_text/lnpcc072.html">Description of "Figure 19-1 Using OTT with OCI"</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4463"></a><div class="props_rev_3"><a id="GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782" name="GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782"></a><h4 id="LNPCC-GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782" class="sect4"><span class="enumeration_section">19.3.1 </span>About Accessing and Manipulating Objects with OCI
                  </h4>
                  <div>
                     <p>Within the application, the OCI program can perform bind and define operations using program variables declared to be of types that appear in the OTT-generated header file.</p>
                     <p>For example, an application might fetch a REF to an object using a SQL SELECT statement and then pin that object using the appropriate OCI function. Once the object has been pinned, its attribute data can be accessed and manipulated with other OCI functions.</p>
                     <p>OCI includes a set of datatype mapping and manipulation functions specifically designed to work on attributes of object types and named collection types.</p>
                     <p>Some of the available functions follow:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OCIStringSize()</code> gets the size of an <code class="codeph">OCIString</code> string.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCINumberAdd()</code> adds two <code class="codeph">OCINumber</code> numbers together.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILobIsEqual()</code> compares two LOB locators for equality.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRawPtr()</code> gets a pointer to an <code class="codeph">OCIRaw</code> raw datatype.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCICollAppend()</code> appends an element to a collection type (<code class="codeph">OCIArray </code>or <code class="codeph">OCITable</code>).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCITableFirst()</code> returns the index for the first existing element of a nested table (<code class="codeph">OCITable</code>).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRefIsNull()</code> tests if a REF (<code class="codeph">OCIRef)</code> is NULL
                           </p>
                        </li>
                     </ul>
                     <p>These functions are described in detail in the following chapters of the <a href="../lnoci/index.html" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide</span></a>:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Chapter 2, which covers OCI concepts, including binding and defining</p>
                        </li>
                        <li>
                           <p>Chapter 6, which covers object access and navigation</p>
                        </li>
                        <li>
                           <p>Chapter 7, which covers datatype mapping and manipulation</p>
                        </li>
                        <li>
                           <p>Chapter 12, which lists datatype mapping and manipulation functions</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4464"></a><div class="props_rev_3"><a id="GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22" name="GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22"></a><h4 id="LNPCC-GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22" class="sect4"><span class="enumeration_section">19.3.2 </span>About Calling the Initialization Function
                  </h4>
                  <div>
                     <p>OTT generates a C initialization function if requested. The initialization function tells the environment, for each object type used in the program, which version of the type is used. You can specify a name for the initialization function when invoking OTT with the <code class="codeph">INITFUNC</code> option, or may allow OTT to select a default name based on the name of the implementation file (<code class="codeph">INITFILE</code>) containing the function.
                     </p>
                     <p>The initialization function takes two arguments, an environment handle pointer and an error handle pointer. There is typically a single initialization function, but this is not required. If a program has several separately compiled pieces requiring different types, you may want to execute OTT separately for each piece requiring, for each piece, one initialization file, containing an initialization function.</p>
                     <p>After you create an environment handle by an explicit OCI object call, for example, by calling<span class="bold"> </span><code class="codeph">OCIEnvInit()</code>, you must also call the initialization functions explicitly for each environment handle. This gives each handle access to all the datatypes used in the entire program.
                     </p>
                     <p>If an environment handle is implicitly created using embedded SQL statements, such as EXEC SQL CONTEXT USE and EXEC SQL CONNECT, the handle is initialized implicitly, and the initialization functions need not be called. This is relevant for Pro*C/C++ applications, or when Pro*C/C++ is being combined with OCI applications.</p>
                     <p>The following example shows an initialization function.</p>
                     <p>Given an <code class="codeph">INTYPE</code> file, ex2c.typ, containing
                     </p><pre class="oac_no_warn" dir="ltr">TYPE SCOTT.PERSON
TYPE SCOTT.ADDRESS
</pre><p>and the command line</p><pre class="oac_no_warn" dir="ltr">ott userid=scott/tiger intype=ex2c outtype=ex2co hfile=ex2ch.h initfile=ex2cv.c
</pre><p>OTT generates the following to the file ex2cv.c:</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

sword ex2cv(OCIEnv *env, OCIError *err)
{
   sword status = OCITypeVTInit(env, err);
   if (status == OCI_SUCCESS)
      status = OCITypeVTInsert(env, err,
          "SCOTT", 5,
          "PERSON", 6,
          "$8.0", 4);
    if (status == OCI_SUCCESS)
        status = OCITypeVTInsert(env, err,
           "SCOTT", 5,
           "ADDRESS", 7,
           "$8.0", 4);
    return status;
}
</pre><p>The function<span class="italic"> ex2cv</span> creates the type version table and inserts the types SCOTT.PERSON and SCOTT.ADDRESS.
                     </p>
                     <p>If a program explicitly creates an environment handle, all the initialization functions must be generated, compiled, and linked, because they must be called for each explicitly created handle. If a program does not explicitly create any environment handles, initialization functions are not required.</p>
                     <p>A program that uses an OTT-generated header file must also use the initialization function generated at the same time. More precisely, if a header file generated by OTT is included in a compilation that generates code that is linked into program P, and an environment handle is explicitly created somewhere in program P, the implementation file generated by the same invocation of OTT must also be compiled and linked into program P. Doing this correctly is your responsibility.</p>
                  </div>
               </div><a id="LNPCC4465"></a><div class="props_rev_3"><a id="GUID-C7686FA7-0258-403E-95CF-2D080F422D01" name="GUID-C7686FA7-0258-403E-95CF-2D080F422D01"></a><h4 id="LNPCC-GUID-C7686FA7-0258-403E-95CF-2D080F422D01" class="sect4"><span class="enumeration_section">19.3.3 </span>Tasks of the Initialization Function
                  </h4>
                  <div>
                     <p>The C initialization function supplies version information about the types processed by OTT. It adds to the type-version table the name and version identifier of every OTT-processed object datatype.</p>
                     <p>The type-version table is used by the Open Type Manager (OTM) to determine which version of a type a particular program uses. Different initialization functions generated by OTT at different times may add some of the same types to the type version table. When a type is added more than once, OTM ensures that the same version of the type is registered each time.</p>
                     <p>It is the OCI programmer's responsibility to declare a function prototype for the initialization function, and to call the function.</p>
                     <div class="infoboxnote" id="GUID-C7686FA7-0258-403E-95CF-2D080F422D01__GUID-A1203C4B-892C-4960-B7BD-CD9FDA71077E">
                        <p class="notep1">Note:</p>
                        <p>In the current release of Oracle, each type has only one version. Initialization of the type version table is required only for compatibility with future releases of Oracle.</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4467"></a><a id="LNPCC4466"></a><div class="props_rev_3"><a id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942" name="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942"></a><h3 id="LNPCC-GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942" class="sect3"><span class="enumeration_section">19.4 </span>About Using OTT with Pro*C/C++ Applications
               </h3>
               <div>
                  <div class="section">
                     <p>When building Pro*C/C++ applications, the type-translation process can be simpler than when building OCI-based applications. This is because precompiler-generated code will automatically initialize the type version table.</p>
                     <p>A C header file generated by OTT can be used by a Pro*C/C++ application to access objects in a database server. The header file is incorporated into the code with an <code class="codeph">#include</code> statement. Once the header file has been included, the Pro*C/C++ application can access and manipulate object data in the host language format.
                     </p>
                     <p><a href="the-Object-type.html#GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__I440384">Figure 19-2</a> shows the steps involved in using OTT with Pro*C/C++.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ol>
                        <li>
                           <p>SQL is used to create type definitions in the database.</p>
                        </li>
                        <li>
                           <p>OTT generates a header file containing C representations of object types, REF types, and named collection types. It also generates an <code class="codeph">OUTTYPE</code> file that is passed as the <code class="codeph">INTYPE</code> parameter to Pro*C/C++.
                           </p>
                        </li>
                        <li>
                           <p>The header file is included in a Pro*C/C++ source code file.</p>
                        </li>
                        <li>
                           <p>The Pro*C/C++ application is compiled and linked with the Pro*C/C++ run-time library SQLLIB.</p>
                        </li>
                        <li>
                           <p>The Pro*C/C++ executable is run against the Oracle Server.</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="figure" id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__I440384">
                        <p class="titleinfigure">Figure 19-2 Building an Object-oriented Pro*C/C++ Application</p><img src="img/lnpcc068.gif" width="499" alt="Description of Figure 19-2 follows" title="Description of Figure 19-2 follows" longdesc="img_text/lnpcc068.html"><br><a href="img_text/lnpcc068.html">Description of "Figure 19-2 Building an Object-oriented Pro*C/C++ Application"</a></div>
                     <!-- class="figure" -->
                     <p>As noted in step 2, earlier, the <code class="codeph">OUTTYPE</code> file generated by OTT serves a special purpose for Pro*C/C++ programmers. Pass the <code class="codeph">OUTTYPE</code> file to the new <code class="codeph">INTYPE</code> command line parameter when invoking Pro*C/C++. The contents of this file are used by the precompiler to determine which database types correspond to which OTT-generated structs. OCI programmers must make this association explicitly through the use of special bind, define, and type information access functions.
                     </p>
                     <p>Also, the precompiler generates code to initialize the type version table with the types named in the OTT <code class="codeph">OUTTYPE</code> (Pro*C/C++ <code class="codeph">INTYPE</code>) file.
                     </p>
                     <div class="infoboxnote" id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__GUID-07C9E2E4-5399-448A-8C90-2AD05E48C398">
                        <p class="notep1">Note:</p>
                        <p>Oracle recommends that the <code class="codeph">OUTTYPE</code> file from OTT always serve as the <code class="codeph">INTYPE</code> file to Pro*C/C++. It would be possible for you to write an <code class="codeph">INTYPE</code> file for Pro*C/C++, but this is not recommended, due to the possibility of errors being introduced.
                        </p>
                     </div>
                     <p>One way to manipulate the attributes of objects retrieved from the server is to call the OCI datatype mapping and manipulation functions. Before doing this, the application must first call <code class="codeph">SQLEnvGet()</code> to obtain an OCI environment handle to pass to the OCI functions, and <code class="codeph">SQLSvcCtxGet()</code> to obtain an OCI service context to pass to the OCI functions. There are also Pro*C facilities that can be used to manipulate object attributes. 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                        <li><a href="the-Object-type.html#GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782">About Accessing and Manipulating Objects with OCI</a></li>
                        <li><a href="../lnoci/data-types.html#LNOCI030" target="_blank">https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpcc&amp;id=LNOCI030</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC4468"></a><div class="props_rev_3"><a id="GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0" name="GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0"></a><h3 id="LNPCC-GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0" class="sect3"><span class="enumeration_section">19.5 </span>OTT Reference
               </h3>
               <div>
                  <p>Behavior of OTT is controlled by parameters which can appear on the OTT command line or in a CONFIG file. Certain parameters may also appear in the <code class="codeph">INTYPE</code> file. This section provides detailed information about the following topics:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="the-Object-type.html#GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002">OTT Command Line Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4">OTT Parameters</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-104B9584-F2A9-405A-9E29-7C945219CF46">Where OTT Parameters Can Appear</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">Structure of the INTYPE File</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A">Nested #include File Generation</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E">SCHEMA_NAMES Usage</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-825D5648-2443-490D-90F0-C5748F915A29">Default Name Mapping</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212">Restriction</a></p>
                     </li>
                  </ul>
                  <p>The following conventions are used in this chapter to describe OTT syntax:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Italic strings are to be supplied by the user.</p>
                     </li>
                     <li>
                        <p>Strings in UPPERCASE are entered as shown, except that case is not significant.</p>
                     </li>
                     <li>
                        <p>Square brackets [...] enclose optional items.</p>
                     </li>
                     <li>
                        <p>An ellipsis (...) immediately following an item (or items enclosed in brackets) means that the item can be repeated any number of times. </p>
                     </li>
                     <li>
                        <p>Punctuation symbols other than those described earlier are entered as shown. These include '.', '@', and so on.</p>
                     </li>
                  </ul>
               </div><a id="LNPCC4469"></a><div class="props_rev_3"><a id="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002" name="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002"></a><h4 id="LNPCC-GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002" class="sect4"><span class="enumeration_section">19.5.1 </span>OTT Command Line Syntax
                  </h4>
                  <div>
                     <div class="section">
                        <p>The OTT command-line interface is used when explicitly invoking OTT to translate database types into C structs. This is always required when developing OCI applications or Pro*C/C++ applications that use objects. </p>
                        <p>An OTT command-line statement consists of the keyword <code class="codeph">OTT</code>, followed by a list of OTT parameters.
                        </p>
                        <p>The parameters that can appear on an OTT command-line statement are as follows:</p><pre class="oac_no_warn" dir="ltr">   [USERID=<span class="italic">username</span>/<span class="italic">password</span>[@<span class="italic">db_name</span>]]
   [INTYPE=<span class="italic">in_filename</span>]
   OUTTYPE=<span class="italic">out_filename</span>
   CODE={C|ANSI_C|KR_C}
   [HFILE=<span class="italic">filename</span>]
   [ERRTYPE=<span class="italic">filename</span>]
   [CONFIG=<span class="italic">filename</span>]
   [INITFILE=<span class="italic">filename</span>]
   [INITFUNC=<span class="italic">filename</span>]
   [CASE={SAME|LOWER|UPPER|OPPOSITE}]
   [SCHEMA_NAMES={ALWAYS|IF_NEEDED|FROM_INTYPE}]
   [TRANSITIVE=TRUE|FALSE]
</pre><div class="infoboxnote" id="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002__GUID-A592FFFC-B2B9-45E1-A2A4-C13FD57D90BC">
                           <p class="notep1">Note:</p>
                           <p>Generally, the order of the parameters following the OTT command does not matter, and only the <code class="codeph">OUTTYPE</code> and <code class="codeph">CODE</code> parameters are always required.
                           </p>
                        </div>
                        <p>The <code class="codeph">HFILE</code> parameter is almost always used. If omitted, <code class="codeph">HFILE</code> must be specified individually for each type in the <code class="codeph">INTYPE</code> file. If OTT determines that a type not listed in the <code class="codeph">INTYPE</code> file must be translated, an error will be reported. Therefore, it is safe to omit the <code class="codeph">HFILE</code> parameter only if the <code class="codeph">INTYPE</code> file was previously generated as an OTT <code class="codeph">OUTTYPE</code> file.
                        </p>
                        <p>If the <code class="codeph">INTYPE</code> file is omitted, the entire schema will be translated. See the parameter descriptions in the following section for more information.
                        </p>
                        <p>The following is an example of an OTT command line statement (enter it as one line):</p><pre class="oac_no_warn" dir="ltr">OTT userid=scott/tiger intype=in.typ outtype=out.typ code=c hfile=demo.h errtype=demo.tls case=lower
</pre><p>Each of the OTT command line parameters is described in the following sections.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4470"></a><div class="props_rev_3"><a id="GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4" name="GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4"></a><h4 id="LNPCC-GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4" class="sect4"><span class="enumeration_section">19.5.2 </span>OTT Parameters
                  </h4>
                  <div>
                     <p>Enter parameters on the OTT command line using the following format:</p>
                     <p><span class="italic">parameter</span>=<span class="italic">value</span></p>
                     <p>where <span class="italic">parameter</span> is the literal parameter string and <span class="italic">value</span> is a valid parameter setting. The literal parameter string is not case sensitive.
                     </p>
                     <p>Separate command-line parameters using either spaces or tabs.</p>
                     <p>Parameters can also appear within a configuration file, but, in that case, no whitespace is permitted within a line, and each parameter must appear on a separate line. Additionally, the parameters <code class="codeph">CASE</code>, <code class="codeph">HFILE</code>, <code class="codeph">INITFUNC</code>, and <code class="codeph">INITFILE</code> can appear in the <code class="codeph">INTYPE</code> file.
                     </p>
                  </div><a id="LNPCC4471"></a><div class="props_rev_3"><a id="GUID-75725874-9343-4420-A00C-C5D8A380186B" name="GUID-75725874-9343-4420-A00C-C5D8A380186B"></a><h5 id="LNPCC-GUID-75725874-9343-4420-A00C-C5D8A380186B" class="sect5"><span class="enumeration_section">19.5.2.1 </span>USERID
                     </h5>
                     <div>
                        <div class="section">
                           <p>The USERID parameter specifies the Oracle username, password, and optional database name (Oracle Net database specification string). If the database name is omitted, the default database is assumed. The syntax of this parameter is:</p><pre class="oac_no_warn" dir="ltr">USERID=<span class="italic">username</span>/<span class="italic">password</span>[@<span class="italic">db_name</span>]</pre><p></p>
                           <p>If this is the first parameter, "USERID=" may be omitted as shown here:</p><pre class="oac_no_warn" dir="ltr">OTT <span class="italic">username</span>/<span class="italic">password...</span></pre><p></p>
                           <p>The USERID parameter is optional. If you omit it, OTT automatically attempts to connect to the default database as user CLUSTER$<span class="italic">username</span>, where <span class="italic">username</span> is the user's operating system user name.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4472"></a><div class="props_rev_3"><a id="GUID-2EEAF760-9921-4308-9417-32E1AAB618F8" name="GUID-2EEAF760-9921-4308-9417-32E1AAB618F8"></a><h5 id="LNPCC-GUID-2EEAF760-9921-4308-9417-32E1AAB618F8" class="sect5"><span class="enumeration_section">19.5.2.2 </span>INTYPE
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">INTYPE</code> parameter specifies the name of the file from which to read the list of object type specifications. OTT translates each type in the list. The syntax for this parameter is
                           </p><pre class="oac_no_warn" dir="ltr">INTYPE=<span class="italic">filename</span></pre><p></p>
                           <p>"<code class="codeph">INTYPE=</code>" may be omitted if USERID and <code class="codeph">INTYPE</code> are the first two parameters, in that order, and "USERID=" is omitted. If <code class="codeph">INTYPE</code> is not specified, all types in the user's schema will be translated.
                           </p><pre class="oac_no_warn" dir="ltr">OTT <span class="italic">username</span>/<span class="italic">password filename...</span></pre><p></p>
                           <p>The <code class="codeph">INTYPE</code> file can be thought of as a makefile for type declarations. It lists the types for which C struct declarations are needed.
                           </p>
                           <p>If the file name on the command line or in the <code class="codeph">INTYPE</code> file does not include an extension, a platform-specific extension such as "TYP" or "typ" will be added.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">Structure of the INTYPE File</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4473"></a><div class="props_rev_3"><a id="GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6" name="GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6"></a><h5 id="LNPCC-GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6" class="sect5"><span class="enumeration_section">19.5.2.3 </span>OUTTYPE
                     </h5>
                     <div>
                        <div class="section">
                           <p>The name of a file into which OTT will write type information for all the object datatypes it processes. This includes all types explicitly named in the <code class="codeph">INTYPE</code> file, and may include additional types that are translated (if TRANSITIVE=TRUE) because they are used in the declarations of other types that need to be translated. This file may be used as an <code class="codeph">INTYPE</code> file in a future invocation of OTT.
                           </p><pre class="oac_no_warn" dir="ltr">OUTTYPE=<span class="italic">filename</span></pre><p></p>
                           <p>If the <code class="codeph">INTYPE</code> and <code class="codeph">OUTTYPE</code> parameters refer to the same file, the new <code class="codeph">INTYPE</code> information replaces the old information in the <code class="codeph">INTYPE</code> file. This provides a convenient way for the same <code class="codeph">INTYPE</code> file to be used repeatedly in the cycle of altering types, generating type declarations, editing source code, precompiling, compiling, and debugging.
                           </p>
                           <p><code class="codeph">OUTTYPE</code> must be specified.
                           </p>
                           <p>If the file name on the command line or in the <code class="codeph">INTYPE</code> file does not include an extension, a platform-specific extension such as "TYP" or "typ" will be added.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4474"></a><div class="props_rev_3"><a id="GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D" name="GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D"></a><h5 id="LNPCC-GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D" class="sect5"><span class="enumeration_section">19.5.2.4 </span>CODE
                     </h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">CODE= C|KR_C|ANSI_C</pre><p></p>
                           <p>This is the desired host language for OTT output, that may be specified as <code class="codeph">CODE=C</code>,<code class="codeph"> CODE=KR_C</code>, or <code class="codeph">CODE=ANSI_C</code>.  "<code class="codeph">CODE=C</code>" is equivalent to "<code class="codeph">CODE=ANSI_C</code>".
                           </p>
                           <p>There is no default value for this parameter; it must be supplied.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4475"></a><div class="props_rev_3"><a id="GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E" name="GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E"></a><h5 id="LNPCC-GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E" class="sect5"><span class="enumeration_section">19.5.2.5 </span>INITFILE
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">INITFILE</code> parameter specifies the name of the file where the OTT-generated initialization file is to be written. OTT does not generate the initialization function if you omit this parameter.
                           </p>
                           <p>For Pro*C/C++ programs, the <code class="codeph">INITFILE</code> is not necessary, because the SQLLIB run-time library performs the necessary initializations. An OCI program user must compile and link the <code class="codeph">INITFILE</code> file(s), and must call the initialization function(s) when an environment handle is created.
                           </p>
                           <p>If the file name of an <code class="codeph">INITFILE</code> on the command line or in the <code class="codeph">INTYPE</code> file does not include an extension, a platform-specific extension such as "C" or ".c" will be added.
                           </p><pre class="oac_no_warn" dir="ltr">INITFILE=<span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4476"></a><div class="props_rev_3"><a id="GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53" name="GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53"></a><h5 id="LNPCC-GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53" class="sect5"><span class="enumeration_section">19.5.2.6 </span>INITFUNC
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">INITFUNC</code> parameter is used only in OCI programs. It specifies the name of the initialization function generated by OTT. If this parameter is omitted, the name of the initialization function is derived from the name of the <code class="codeph">INITFILE</code>.
                           </p><pre class="oac_no_warn" dir="ltr">INITFUNC=<span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4477"></a><div class="props_rev_3"><a id="GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2" name="GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2"></a><h5 id="LNPCC-GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2" class="sect5"><span class="enumeration_section">19.5.2.7 </span>HFILE
                     </h5>
                     <div>
                        <div class="section">
                           <p>The name of the include (.h) file to be generated by OTT for the declarations of types that are mentioned in the <code class="codeph">INTYPE</code> file but whose include files are not specified there. This parameter is required unless the include file for each type is specified individually in the <code class="codeph">INTYPE</code> file. This parameter is also required if a type not mentioned in the <code class="codeph">INTYPE</code> file must be generated because other types require it (if TRANSITIVE=TRUE), and these other types are declared in two or more different files.
                           </p>
                           <p>If the file name of an <code class="codeph">HFILE</code> on the command line or in the <code class="codeph">INTYPE</code> file does not include an extension, a platform-specific extension such as "H" or ".h" will be added.
                           </p><pre class="oac_no_warn" dir="ltr">HFILE=<span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4478"></a><div class="props_rev_3"><a id="GUID-C78C0E91-B984-4F93-9396-B84EEE350438" name="GUID-C78C0E91-B984-4F93-9396-B84EEE350438"></a><h5 id="LNPCC-GUID-C78C0E91-B984-4F93-9396-B84EEE350438" class="sect5"><span class="enumeration_section">19.5.2.8 </span>CONFIG
                     </h5>
                     <div>
                        <div class="section">
                           <p>The CONFIG parameter specifies the name of the OTT configuration file, that lists commonly used parameter specifications. Parameter specifications are also read from a system configuration file in a platform-dependent location. All remaining parameter specifications must appear on the command line, or in the <code class="codeph">INTYPE</code> file.
                           </p><pre class="oac_no_warn" dir="ltr">CONFIG=<span class="italic">filename</span> </pre><p></p>
                           <p><span class="bold">Note</span>: A CONFIG parameter is not allowed in the CONFIG file.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4479"></a><div class="props_rev_3"><a id="GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12" name="GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12"></a><h5 id="LNPCC-GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12" class="sect5"><span class="enumeration_section">19.5.2.9 </span>ERRTYPE
                     </h5>
                     <div>
                        <div class="section">
                           <p>If you supply this parameter, a listing of the <code class="codeph">INTYPE</code> file is written to the ERRTYPE file, along with all informational and error messages. Informational and error messages are sent to the standard output whether or not ERRTYPE is specified.
                           </p>
                           <p>Essentially, the ERRTYPE file is a copy of the <code class="codeph">INTYPE</code> file with error messages added. In most cases, an error message will include a pointer to the text that caused the error.
                           </p>
                           <p>If the file name of an ERRTYPE on the command line or in the <code class="codeph">INTYPE</code> file does not include an extension, a platform-specific extension such as "TLS" or "tls" will be added.
                           </p><pre class="oac_no_warn" dir="ltr">ERRTYPE=<span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4480"></a><div class="props_rev_3"><a id="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9" name="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9"></a><h5 id="LNPCC-GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9" class="sect5"><span class="enumeration_section">19.5.2.10 </span>CASE
                     </h5>
                     <div>
                        <div class="section">
                           <p>This parameter affects the case of certain C identifiers generated by OTT. The possible values of <code class="codeph">CASE</code> are <code class="codeph">SAME</code>, <code class="codeph">LOWER</code>, <code class="codeph">UPPER</code>, and <code class="codeph">OPPOSITE</code>. If <code class="codeph">CASE = SAME</code>, the case of letters is not changed when converting database type and attribute names to C identifiers. If <code class="codeph">CASE=LOWER</code>, all uppercase letters are converted to lowercase. If <code class="codeph">CASE=UPPER</code>, all lowercase letters are converted to uppercase. If <code class="codeph">CASE=OPPOSITE</code>, all uppercase letters are converted to lower-case, and vice-versa.
                           </p><pre class="oac_no_warn" dir="ltr">CASE=[SAME|LOWER|UPPER|OPPOSITE]</pre><p></p>
                           <p>This parameter affects only those identifiers (attributes or types not explicitly listed) not mentioned in the <code class="codeph">INTYPE</code> file. Case conversion takes place after a legal identifier has been generated.
                           </p>
                           <div class="infoboxnote" id="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9__GUID-4B6A137A-AB5C-4CF7-BBAE-44EB7751CA25">
                              <p class="notep1">Note:</p>
                              <p>The case of the C struct identifier for a type specifically mentioned in the <code class="codeph">INTYPE</code> is the same as its case in the <code class="codeph">INTYPE</code> file. For example, if the <code class="codeph">INTYPE</code> file includes the following line
                              </p>
                           </div><pre class="oac_no_warn" dir="ltr">TYPE Worker
</pre><p>then OTT will generate</p><pre class="oac_no_warn" dir="ltr">struct Worker {...};
</pre><p>On the other hand, if the <code class="codeph">INTYPE</code> file were written as 
                           </p><pre class="oac_no_warn" dir="ltr">TYPE wOrKeR
</pre><p>OTT would generate</p><pre class="oac_no_warn" dir="ltr">struct wOrKeR {...};
</pre><p>following the case of the <code class="codeph">INTYPE</code> file.
                           </p>
                           <p>Case-insensitive SQL identifiers not mentioned in the <code class="codeph">INTYPE</code> file will appear in upper case if <code class="codeph">CASE=SAME</code>, and in lower case if <code class="codeph">CASE=OPPOSITE</code>. A SQL identifier is case-insensitive if it was not quoted when it was declared.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4481"></a><div class="props_rev_3"><a id="GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C" name="GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C"></a><h5 id="LNPCC-GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C" class="sect5"><span class="enumeration_section">19.5.2.11 </span>SCHEMA_NAMES
                     </h5>
                     <div>
                        <div class="section">
                           <p>This parameter offers control in qualifying the database name of a type from the default schema with a schema name in the <code class="codeph">OUTTYPE</code> file. The <code class="codeph">OUTTYPE</code> file generated by OTT contains information about the types processed by OTT, including the type names.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E">SCHEMA_NAMES Usage</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4482"></a><div class="props_rev_3"><a id="GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7" name="GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7"></a><h5 id="LNPCC-GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7" class="sect5"><span class="enumeration_section">19.5.2.12 </span>TRANSITIVE
                     </h5>
                     <div>
                        <div class="section">
                           <p>Takes the values TRUE (the default) or FALSE. Indicates whether type dependencies not explicitly listed in the <code class="codeph">INTYPE</code> file are to be translated, or not. If TRANSITIVE=FALSE is specified, then types <span class="italic">not</span> mentioned in the <code class="codeph">INTYPE</code> file are not generated. This is the case even if they were used as attribute types of other generated types.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4483"></a><div class="props_rev_3"><a id="GUID-104B9584-F2A9-405A-9E29-7C945219CF46" name="GUID-104B9584-F2A9-405A-9E29-7C945219CF46"></a><h4 id="LNPCC-GUID-104B9584-F2A9-405A-9E29-7C945219CF46" class="sect4"><span class="enumeration_section">19.5.3 </span>Where OTT Parameters Can Appear
                  </h4>
                  <div>
                     <p>Supply OTT parameters on the command line, in a CONFIG file named on the command line, or both. Some parameters are also allowed in the <code class="codeph">INTYPE</code> file.
                     </p>
                     <p>OTT is invoked as follows:</p>
                     <p>OTT <span class="italic">username/password </span>parameters
                     </p>
                     <p>If one of the parameters on the command line is</p>
                     <p>CONFIG=<span class="italic">filename</span></p>
                     <p>additional parameters are read from the configuration file named <span class="italic">filename</span>.
                     </p>
                     <p>In addition, parameters are also read from a default configuration file in a platform-dependent location. This file must exist, but can be empty. Each line in the configuration may contain one parameter, with no whitespace on the line.</p>
                     <p>If OTT is executed without any arguments, an on-line parameter reference is displayed.</p>
                     <p>The types for OTT to translate are named in the file specified by the <code class="codeph">INTYPE</code> parameter. The parameters <code class="codeph">CASE</code>, <code class="codeph">INITFILE</code>, <code class="codeph">INITFUNC</code>, and <code class="codeph">HFILE</code> may also appear in the <code class="codeph">INTYPE</code> file. <code class="codeph">OUTTYPE</code> files generated by OTT include the <code class="codeph">CASE</code> parameter, and include the <code class="codeph">INITFILE</code>, and <code class="codeph">INITFUNC</code> parameters if an initialization file was generated. The <code class="codeph">OUTTYPE</code> file specifies the <code class="codeph">HFILE</code> individually for each type.
                     </p>
                     <p>The case of the OTT command is platform-dependent.</p>
                  </div>
               </div><a id="LNPCC4484"></a><div class="props_rev_3"><a id="GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B" name="GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B"></a><h4 id="LNPCC-GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B" class="sect4"><span class="enumeration_section">19.5.4 </span>Structure of the INTYPE File
                  </h4>
                  <div>
                     <p>The <code class="codeph">INTYPE</code> and <code class="codeph">OUTTYPE</code> files<a id="d101336e3308" class="indexterm-anchor"></a><a id="d101336e3310" class="indexterm-anchor"></a><a id="d101336e3312" class="indexterm-anchor"></a> list the types translated by OTT and provide all the information needed to determine how a type or attribute name is translated to a legal C identifier. These files contain one or more type specifications. These files also may contain specifications of the following options:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">CASE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">HFILE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INITFILE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INITFUNC</code></p>
                        </li>
                     </ul>
                     <p>If the <code class="codeph">CASE</code>, <code class="codeph">INITFILE</code>, or <code class="codeph">INITFUNC</code> options are present, they must precede any type specifications. If these options appear both on the command line and in the <code class="codeph">INTYPE</code> file, the value on the command line is used.
                     </p>
                     <p>For an example of a simple user-defined <code class="codeph">INTYPE</code> file, and of the full <code class="codeph">OUTTYPE</code> file that OTT generates from it, see <span class="q">"<a href="the-Object-type.html#GUID-A9A00891-FD32-4B0A-813A-4064DF43557B">OTT Support for Type Inheritance</a>"</span>.
                     </p>
                  </div><a id="LNPCC4485"></a><div class="props_rev_3"><a id="GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC" name="GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC"></a><h5 id="LNPCC-GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC" class="sect5"><span class="enumeration_section">19.5.4.1 </span>INTYPE File Type Specifications
                     </h5>
                     <div>
                        <p>A type specification in the <code class="codeph">INTYPE</code> names an object datatype that is to be translated. The following is an example of a user-created <code class="codeph">INTYPE</code> file:
                        </p><pre class="oac_no_warn" dir="ltr">TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE PURCHASE_ORDER AS p_o
</pre><p>The structure of a type specification is as follows:</p><pre class="oac_no_warn" dir="ltr">TYPE type_name [AS type_identifier]
[VERSION [=] version_string]
[HFILE [=] hfile_name]
[TRANSLATE{member_name [AS identifier]}...]
</pre><p>The syntax of <span class="italic">type_name</span> is:
                        </p><pre class="oac_no_warn" dir="ltr">[schema_name.]type_name
</pre><p>where <span class="italic">schema_name</span> is the name of the schema that owns the given object datatype, and <span class="italic">type_name</span> is the name of the type. The default schema is that of the user running OTT. The default database is the local database.
                        </p>
                        <p>The components of a type specification are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic">type name</span> is the name of an object datatype.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">type identifier</span> is the C identifier used to represent the type. If omitted, the default name mapping algorithm will be used.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">version string</span> is the version string of the type that was used when the code was generated by a previous invocation of OTT. The version string is generated by OTT and written to the <code class="codeph">OUTTYPE</code> file, that may later be used as the <code class="codeph">INTYPE</code> file when OTT is later executed. The version string does not affect the OTT's operation, but will eventually be used to select which version of the object datatype should be used in the running program.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">hfile name</span> is the name of the header file in which the declarations of the corresponding struct or class appears or will appear. If <span class="italic">hfile name</span> is omitted, the file named by the command-line <code class="codeph">HFILE</code> parameter will be used if a declaration is generated.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">member name</span> is the name of an attribute (data member) which is to be translated to the following <span class="italic">identifier</span>.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">identifier</span> is the C identifier used to represent the attribute in the user program. You can specify identifiers in this way for any number of attributes. The default name mapping algorithm will be used for the attributes that are not mentioned.
                              </p>
                           </li>
                        </ul>
                        <p>An object datatype may need to be translated for one of two reasons:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It appears in the <code class="codeph">INTYPE</code> file.
                              </p>
                           </li>
                           <li>
                              <p>It is required to declare another type that must be translated, and TRANSITIVE = TRUE.</p>
                           </li>
                        </ul>
                        <p>If a type that is not mentioned explicitly is required by types declared in exactly one file, the translation of the required type is written to the same file(s) as the explicitly declared types that require it.</p>
                        <p>If a type that is not mentioned explicitly is required by types declared in two or more different files, the translation of the required type is written to the global <code class="codeph">HFILE</code> file.
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-825D5648-2443-490D-90F0-C5748F915A29">Default Name Mapping</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4486"></a><div class="props_rev_3"><a id="GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A" name="GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A"></a><h4 id="LNPCC-GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A" class="sect4"><span class="enumeration_section">19.5.5 </span>Nested #include File Generation
                  </h4>
                  <div>
                     <p>Every <code class="codeph">HFILE</code> generated by OTT <code class="codeph">#includes</code> other necessary files, and <code class="codeph">#defines</code><code class="codeph"> </code>a symbol constructed from the name of the file, that may be used to determine if the <code class="codeph">HFILE</code> has already been included. Consider, for example, a database with the following types:
                     </p><pre class="oac_no_warn" dir="ltr">create type px1 AS OBJECT (col1 number, col2 integer);
create type px2 AS OBJECT (col1 px1);
create type px3 AS OBJECT (col1 px1);
</pre><p>where the <code class="codeph">INTYPE</code> file contains:
                     </p><pre class="oac_no_warn" dir="ltr">CASE=lower
type pxl
  hfile tott95a.h
type px3
  hfile tott95b.h
</pre><p>If we invoke OTT with</p><pre class="oac_no_warn" dir="ltr">ott scott/tiger tott95i.typ outtype=tott95o.typ code=c
</pre><p>then it will generate the two following header files.</p>
                     <p>File tott95b.h is:</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE
#define TOTT95B_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#ifndef TOTT95A_ORACLE
#include "tott95a.h"
#endif
typedef OCIRef px3_ref;
struct px3
{
   struct px1 col1;
};
typedef struct px3 px3;
struct px3_ind
{
   OCIInd _atomic;
   struct px1_ind col1
};
typedef struct px3_ind px3_ind;
#endif
</pre><p>File tott95a.h is:</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95A_ORACLE
#define TOTT95A_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
typedef OCIRef px1_ref;
struct px1
{
   OCINumber col1;
   OCINumber col2;
}
typedef struct px1 px1;
struct px1_ind
{
   OCIInd _atomic;
   OCIInd col1;
   OCIInd col2;
}
typedef struct px1_ind px1_ind;
#endif
</pre><p>In this file, the symbol TOTT95B_ORACLE is defined first so that the programmer may conditionally include <code class="codeph">tott95b.h</code> without having to worry whether<span class="italic"> </span><code class="codeph">tott95b.h</code> depends on the include file using the following construct:
                     </p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE
#include "tott95b.h"
#endif
</pre><p>Using this technique, you can include "tott95b.h" from some file, say "foo.h", without having to know whether some other file included by "foo.h" also includes "tott95b.h".</p>
                     <p>After the definition of the symbol TOTT95B_ORACLE, the file <code class="codeph">oci.h</code> is <code class="codeph">#includ</code>ed. Every <code class="codeph">HFILE</code> generated by OTT includes <code class="codeph">oci.h</code>, that contains type and function declarations that the Pro*C/C++ or OCI programmer will find useful. This is the only case in which OTT uses angle brackets in an <code class="codeph">#include</code>.
                     </p>
                     <p>Next, the file <code class="codeph">tott95a.h</code> is included because it contains the declaration of "struct px1", that <code class="codeph">tott95b.h</code> requires. When the <code class="codeph">INTYPE</code> file requests that type declarations be written to more than one file, OTT will determine which other files each <code class="codeph">HFILE</code> must include, and will generate the necessary <code class="codeph">#includes</code>.
                     </p>
                     <p>Note that OTT uses quotes in this <code class="codeph">#include</code>. When a program including <code class="codeph">tott95b.h</code> is compiled, the search for <code class="codeph">tott95a.h</code> begins where the source program was found, and will thereafter follow an implementation-defined search rule. If <code class="codeph">tott95a.h</code> cannot be found in this way, a complete file name (for example, a UNIX absolute path name beginning with /) should be used in the <code class="codeph">INTYPE</code> file to specify the location of <code class="codeph">tott95a.h</code>.
                     </p>
                  </div>
               </div><a id="LNPCC4488"></a><a id="LNPCC4487"></a><div class="props_rev_3"><a id="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E" name="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E"></a><h4 id="LNPCC-GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E" class="sect4"><span class="enumeration_section">19.5.6 </span>SCHEMA_NAMES Usage
                  </h4>
                  <div>
                     <p>This parameter affects whether the name of a type from the default schema to which OTT is connected is qualified with a schema name in the <code class="codeph">OUTTYPE</code> file.
                     </p>
                     <p>The name of a type from a schema other that the default schema is always qualified with a schema name in the <code class="codeph">OUTTYPE</code> file.
                     </p>
                     <p>The schema name, or its absence, determines in which schema the type is found during program execution.</p>
                     <p>There are three settings:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>SCHEMA_NAMES=ALWAYS(default)</p>
                           <p>All type names in the <code class="codeph">OUTTYPE</code> file are qualified with a schema name.
                           </p>
                        </li>
                        <li>
                           <p>SCHEMA_NAMES=IF_NEEDED</p>
                           <p>The type names in the <code class="codeph">OUTTYPE</code> file that belong to the default schema are not qualified with a schema name. As always, type names belonging to other schemas are qualified with the schema name.
                           </p>
                        </li>
                        <li>
                           <p>SCHEMA_NAMES=FROM_INTYPE</p>
                           <p>A type mentioned in the <code class="codeph">INTYPE</code> file is qualified with a schema name in the <code class="codeph">OUTTYPE</code> file if, and only if, it was qualified with a schema name in the <code class="codeph">INTYPE</code> file. A type in the default schema that is not mentioned in the <code class="codeph">INTYPE</code> file but that has to be generated because of type dependencies is written with a schema name only if the first type encountered by OTT that depends on it was written with a schema name. However, a type that is not in the default schema to which OTT is connected is always written with an explicit schema name. 
                           </p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">OUTTYPE</code> file generated by OTT is the Pro*C/C++ <code class="codeph">INTYPE</code> file. This file matches database type names to C struct names. This information is used at run-time to make sure that the correct database type is selected into the struct. If a type appears with a schema name in the <code class="codeph">OUTTYPE</code> file (Pro*C/C++ <code class="codeph">INTYPE</code> file), the type will be found in the named schema during program execution. If the type appears without a schema name, the type will be found in the default schema to which the program connects, which may be different from the default schema OTT used.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E__GUID-9F5E42F1-1CD5-445C-BCB7-19E44C761B1C">An Example </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If <code class="codeph">SCHEMA_NAMES</code> is set to <code class="codeph">FROM_INTYPE</code>, and the <code class="codeph">INTYPE</code> file reads:
                        </p><pre class="oac_no_warn" dir="ltr">TYPE Person
TYPE joe.Dept
TYPE sam.Company
</pre><p>then the Pro*C/C++ application that uses the OTT-generated structs will use the types<span class="italic"> sam.Company, joe.Dept, and Person. Person</span> without a schema name refers to the Person type in the schema to which the application is connected.
                        </p>
                        <p>If OTT and the application both connect to schema joe, the application will use the same type (joe.Person) that OTT used. If OTT connected to schema <span class="italic">joe</span> but the application connects to schema mary, the application will use the type mary.Person. This behavior is appropriate only if the same "CREATE TYPE Person" statement has been executed in schema joe and schema mary.
                        </p>
                        <p>On the other hand, the application will use type joe.Dept regardless of to which schema the application is connected. If this is the behavior you want, be sure to include schema names with your type names in the <code class="codeph">INTYPE</code> file.
                        </p>
                        <p>In some cases, OTT translates a type that the user did not explicitly name. For example, consider the following SQL declarations:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Address AS OBJECT
(
street    VARCHAR2(40),
city      VARCHAR(30),
state     CHAR(2),
zip_code  CHAR(10)
);

CREATE TYPE Person AS OBJECT
(
name      CHAR(20),
age       NUMBER,
addr      ADDRESS
);
</pre><p>Now suppose that OTT connects to schema joe, <code class="codeph">SCHEMA_NAMES=FROM_INTYPE</code> is specified, and the user's <code class="codeph">INTYPE</code> files include either
                        </p><pre class="oac_no_warn" dir="ltr">TYPE Person or TYPE joe.Person
</pre><p>but do not mention the type joe.Address, which is used as a nested object type in type<span class="italic"> joe.Person</span>. If "TYPE joe.Person" appeared in the <code class="codeph">INTYPE</code> file, "TYPE joe.Person" and "TYPE joe.Address" will appear in the <code class="codeph">OUTTYPE</code> file. If "Type Person" appeared in the <code class="codeph">INTYPE</code> file, "TYPE Person" and "TYPE Address" will appear in the <code class="codeph">OUTTYPE</code> file.
                        </p>
                        <p>If the <span class="italic">joe.Addres</span>s type is embedded in several types translated by OTT, but is not explicitly mentioned in the <code class="codeph">INTYPE</code> file, the decision of whether to use a schema name is made the first time OTT encounters the embedded <span class="italic">joe.Address </span>type. If, for some reason, the user wants type<span class="italic"> joe.Address</span> to have a schema name but does not want type <span class="italic">Person</span> to have one, you must explicitly request
                        </p><pre class="oac_no_warn" dir="ltr">TYPE      joe.Address
</pre><p>in the <code class="codeph">INTYPE</code> FILE. 
                        </p>
                        <p>In the usual case in which each type is declared in a single schema, it is safest for you to qualify all type names with schema names in the <code class="codeph">INTYPE</code> file. 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4489"></a><div class="props_rev_3"><a id="GUID-825D5648-2443-490D-90F0-C5748F915A29" name="GUID-825D5648-2443-490D-90F0-C5748F915A29"></a><h4 id="LNPCC-GUID-825D5648-2443-490D-90F0-C5748F915A29" class="sect4"><span class="enumeration_section">19.5.7 </span>Default Name Mapping
                  </h4>
                  <div>
                     <p>When OTT creates a C identifier name for an object type or attribute, it translates the name from the database character set to a legal C identifier. First, the name is translated from the database character set to the character set used by OTT. Next, if a translation of the resulting name is supplied in the <code class="codeph">INTYPE</code> file, that translation is used. Otherwise, OTT translates the name character-by-character to the compiler character set, applying the <code class="codeph">CASE</code> option. The following describes this in more detail.
                     </p>
                     <p>When OTT reads the name of a database entity, the name is automatically translated from the database character set to the character set used by OTT. In order for OTT to read the name of the database entity successfully, all the characters of the name must be found in the OTT character set, although a character may have different encodings in the two character sets. </p>
                     <p>The easiest way to guarantee that the character set used by OTT contains all the necessary characters is to make it the same as the database character set. Note, however, that the OTT character set must be a superset of the compiler character set. That is, if the compiler character set is 7-bit ASCII, the OTT character set must include 7-bit ASCII as a subset, and if the compiler character set is 7-bit EBCDIC, the OTT character set must include 7-bit EBCDIC as a subset. The user specifies the character set that OTT uses by setting the NLS_LANG environment variable, or by some other platform-specific mechanism. </p>
                     <p>Once OTT has read the name of a database entity, it translates the name from the character set used by OTT to the compiler's character set. If a translation of the name appears in the <code class="codeph">INTYPE</code> file, OTT uses that translation. 
                     </p>
                     <p>Otherwise, OTT attempts to translate the name as follows: </p>
                     <ol>
                        <li>
                           <p>First, if the OTT character set is a multibyte character set, all multibyte characters in the name that have singlebyte equivalents are converted to those singlebyte equivalents. </p>
                        </li>
                        <li>
                           <p>Next, the name is converted from the OTT character set to the compiler character set. The compiler character set is a singlebyte character set such as US7ASCII. </p>
                        </li>
                        <li>
                           <p>Finally, the case of letters is set according to the <code class="codeph">CASE</code> option in effect, and any character that is not legal in a C identifier, or that has no translation in the compiler character set, is replaced by an underscore. If at least one character is replaced by an underscore, OTT gives a warning message. If all the characters in a name are replaced by underscores, OTT gives an error message. 
                           </p>
                        </li>
                     </ol>
                     <p>Character-by-character name translation does not alter underscores, digits, or singlebyte letters that appear in the compiler character set, so legal C identifiers are not altered. </p>
                     <p>Name translation may, for example, translate accented singlebyte characters such as "o" with an umlaut or "a" with an accent grave to "o" or "a", and may translate a multibyte letter to its singlebyte equivalent. Name translation will typically fail if the name contains multibyte characters that lack singlebyte equivalents. In this case, the user must specify name translations in the <code class="codeph">INTYPE</code> file. 
                     </p>
                     <p>OTT will not detect a naming clash caused by two or more database identifiers being mapped to the same C name, nor will it detect a naming problem where a database identifier is mapped to a C keyword.</p>
                  </div>
               </div><a id="LNPCC4490"></a><div class="props_rev_3"><a id="GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212" name="GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212"></a><h4 id="LNPCC-GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212" class="sect4"><span class="enumeration_section">19.5.8 </span>Restriction
                  </h4>
                  <div>
                     <p>The following restriction affects the use of OTT.</p>
                  </div><a id="LNPCC4491"></a><div class="props_rev_3"><a id="GUID-4274113F-7216-4B8F-97C5-9031B273F9B9" name="GUID-4274113F-7216-4B8F-97C5-9031B273F9B9"></a><h5 id="LNPCC-GUID-4274113F-7216-4B8F-97C5-9031B273F9B9" class="sect5"><span class="enumeration_section">19.5.8.1 </span>File Name Comparison
                     </h5>
                     <div>
                        <p>Currently, OTT determines if two files are the same by comparing the file names provided by the user on the command line or in the <code class="codeph">INTYPE</code> file. But one potential problem can occur when OTT needs to know if two file names refer to the same file. For example, if the OTT-generated file foo.h requires a type declaration written to foo1.h, and another type declaration written to /private/smith/foo1.h, OTT should generate one <code class="codeph">#include</code> if the two files are the same, and two <code class="codeph">#includes</code> if the files are different. In practice, though, it concludes that the two files are different, and generates two <code class="codeph">#includes</code>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#ifndef FOO1_ORACLE
#include "foo1.h"
#endif
#ifndef FOO1_ORACLE
#include "/private/smith/foo1.h"
#endif
</pre><p>If foo1.h and /private/smith/foo1.h are different files, only the first one will be included. If foo1.h and /private/smith/foo1.h are the same file, a redundant <code class="codeph">#include</code> will be written.
                        </p>
                        <p>Therefore, if a file is mentioned several times on the command line or in the <code class="codeph">INTYPE</code> file, each mention of the file should use exactly the same file name.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>