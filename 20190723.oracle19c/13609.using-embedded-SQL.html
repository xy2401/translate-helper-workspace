<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>&nbsp;Using Embedded SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="meeting-program-requirements.html" title="Previous" type="text/html">
      <link rel="next" href="using-embedded-PLSQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="meeting-program-requirements.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-embedded-PLSQL.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">&nbsp;Using Embedded SQL </li>
            </ol>
            <a id="GUID-BDAC918C-E2AB-4F97-8F36-C2B7094CCB98" name="GUID-BDAC918C-E2AB-4F97-8F36-C2B7094CCB98"></a><a id="ZZPRE260"></a>
            
            <h2 id="ZZPRE-GUID-BDAC918C-E2AB-4F97-8F36-C2B7094CCB98" class="sect2"><span class="enumeration_chapter">4 </span>&nbsp;Using Embedded SQL 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter contains the following:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="using-embedded-SQL.html#GUID-3FB978C8-7088-4BB5-8875-31FAD7D30470">About Using Host Variables</a></p>
                  </li>
                  <li>
                     <p><a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">About Using Indicator Variables</a></p>
                  </li>
                  <li>
                     <p><a href="using-embedded-SQL.html#GUID-361C97AB-8CFF-4029-AB10-D478618F47CC">The Basic SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="using-embedded-SQL.html#GUID-0327E691-23A7-48C4-91D7-3447B298545D">Cursors</a></p>
                  </li>
                  <li>
                     <p><a href="using-embedded-SQL.html#GUID-3A7191D8-EAF2-4F34-A24F-3455CCA9C9AC">Cursor Variables</a></p>
                  </li>
               </ul>
               <p>This chapter helps you to understand and apply the basic techniques of embedded SQL programming. You learn how to use host variables, indicator variables, cursors, cursor variables, and the fundamental SQL commands that insert, update, select, and delete Oracle data.</p>
            </div><a id="ZZPRE261"></a><div class="props_rev_3"><a id="GUID-3FB978C8-7088-4BB5-8875-31FAD7D30470" name="GUID-3FB978C8-7088-4BB5-8875-31FAD7D30470"></a><h3 id="ZZPRE-GUID-3FB978C8-7088-4BB5-8875-31FAD7D30470" class="sect3"><span class="enumeration_section">4.1 </span>About Using Host Variables
               </h3>
               <div>
                  <p><a id="d27112e69" class="indexterm-anchor"></a>Oracle uses host variables to pass data and status information to your program; your program uses host variables to pass data to Oracle. 
                  </p>
               </div><a id="ZZPRE262"></a><div class="props_rev_3"><a id="GUID-12C7FB41-F1C3-4C70-A92F-6CA81CD1111C" name="GUID-12C7FB41-F1C3-4C70-A92F-6CA81CD1111C"></a><h4 id="ZZPRE-GUID-12C7FB41-F1C3-4C70-A92F-6CA81CD1111C" class="sect4"><span class="enumeration_section">4.1.1 </span>Output versus Input Host Variables
                  </h4>
                  <div>
                     <p><a id="d27112e99" class="indexterm-anchor"></a>Depending on how they are used, host variables are called output or input host variables. Host variables in the <code class="codeph">INTO</code> clause of a <code class="codeph">SELECT</code> or <code class="codeph">FETCH</code> statement are called <span class="italic">output</span> host variables because they hold column values output by Oracle. Oracle assigns the column values to corresponding output host variables in the <code class="codeph">INTO</code> clause.
                     </p>
                     <p>All other host variables in a SQL statement are called <span class="italic">input</span> host variables because your program inputs their values to Oracle. For example, you use input host variables in the <code class="codeph">VALUES</code> clause of an <code class="codeph">INSERT</code> statement and in the <code class="codeph">SET</code> clause of an <code class="codeph">UPDATE</code> statement. <a id="d27112e137" class="indexterm-anchor"></a>They are also used in the <code class="codeph">WHERE</code>, <code class="codeph">HAVING</code>, and <code class="codeph">FOR</code> clauses. In fact, input host variables can appear in a SQL statement wherever a value or expression is allowed.
                     </p>
                     <p>In an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, you <span class="italic">can</span> use a host variable, but it is treated as a constant or literal, and hence the contents of the host variable have no effect. For example, the SQL statement
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename, empno INTO :name, :number
 FROM emp
 ORDER BY :ord;
</pre><p>appears to contain an input host variable, <span class="italic">ord</span>. However, the host variable in this case is treated as a constant, and regardless of the value of <span class="italic">ord</span>, no ordering is done.
                     </p>
                     <p><a id="d27112e173" class="indexterm-anchor"></a>You cannot use input host variables to supply SQL keywords or the names of database objects. Thus, you cannot use input host variables in data definition statements (sometimes called <span class="italic">DDL</span>) such as <code class="codeph">ALTER</code>, <code class="codeph">CREATE</code>, and <code class="codeph">DROP</code>. In the following example, the <code class="codeph">DROP</code> <code class="codeph">TABLE</code> statement is <span class="italic">invalid</span>:<a id="d27112e200" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; 
 table_name CHARACTER(30); 
EXEC SQL END DECLARE SECTION; 
display 'Table name? '; 
read table_name; 
EXEC SQL DROP TABLE :table_name; -- host variable not allowed
</pre><p>Before Oracle executes a SQL statement containing input host variables, your program must assign values to them. Consider the following example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; 
 emp_number INTEGER; 
 emp_name CHARACTER(20); 
EXEC SQL END DECLARE SECTION; 
-- get values for input host variables 
display 'Employee number? '; 
read emp_number; 
display 'Employee name? '; 
read emp_name; 
EXEC SQL INSERT INTO EMP (EMPNO, ENAME) 
 VALUES (:emp_number, :emp_name);
</pre><p>Notice that the input host variables in the <code class="codeph">VALUES</code> clause of the <code class="codeph">INSERT</code> statement are prefixed with colons.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE263"></a><div class="props_rev_3"><a id="GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A" name="GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A"></a><h3 id="ZZPRE-GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A" class="sect3"><span class="enumeration_section">4.2 </span>About Using Indicator Variables
               </h3>
               <div>
                  <p><a id="d27112e239" class="indexterm-anchor"></a>You can associate any host variable with an optional indicator variable. Each time the host variable is used in a SQL statement, a result code is stored in its associated indicator variable. Thus, indicator variables let you monitor host variables.
                  </p>
                  <p>You use indicator variables in the <code class="codeph">VALUES</code> or <code class="codeph">SET</code> clause to assign nulls to input host variables and in the <code class="codeph">INTO</code> clause to detect nulls or truncated values in output host variables.
                  </p>
               </div><a id="ZZPRE264"></a><div class="props_rev_3"><a id="GUID-048AC3F5-7DE9-484A-B711-568A504DB951" name="GUID-048AC3F5-7DE9-484A-B711-568A504DB951"></a><h4 id="ZZPRE-GUID-048AC3F5-7DE9-484A-B711-568A504DB951" class="sect4"><span class="enumeration_section">4.2.1 </span>Input Variables
                  </h4>
                  <div>
                     <div class="section">
                        <p>For input host variables, the values your program can assign to an indicator variable have the following meanings:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>-1: Oracle will assign a null to the column, ignoring the value of the host variable.</p>
                           </li>
                           <li>
                              <p>&gt;= 0: <a id="d27112e283" class="indexterm-anchor"></a>Oracle will assigns the value of the host variable to the column.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE265"></a><div class="props_rev_3"><a id="GUID-D26B7FAC-FD86-4F0D-967A-317ED9470CD4" name="GUID-D26B7FAC-FD86-4F0D-967A-317ED9470CD4"></a><h4 id="ZZPRE-GUID-D26B7FAC-FD86-4F0D-967A-317ED9470CD4" class="sect4"><span class="enumeration_section">4.2.2 </span>Output Variables
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e310" class="indexterm-anchor"></a>For output<a id="d27112e315" class="indexterm-anchor"></a> host variables, the values Oracle can assign to an indicator variable have the following meanings:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>-2: Oracle assigned a <a id="d27112e324" class="indexterm-anchor"></a>truncated column value to the host variable, but could not assign the original length of the column value to the indicator variable because the number was too large.
                              </p>
                           </li>
                           <li>
                              <p>-1: The column value is null, so the value of the host variable is indeterminate.</p>
                           </li>
                           <li>
                              <p>0: Oracle assigned an intact column value to the host variable.</p>
                           </li>
                           <li>
                              <p>&gt; 0: Oracle assigned a truncated column value to the host variable, assigned the original column length (expressed in characters, instead of bytes, for multibyte Globalization Support host variables) to the indicator variable, and set SQLCODE in the SQLCA to zero.</p>
                           </li>
                        </ul>
                        <p>Remember, an indicator variable must be defined in the Declare Section as a 2-byte integer and, in SQL statements, must be prefixed with a colon and appended to its host variable (unless you use the keyword INDICATOR).</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE266"></a><div class="props_rev_3"><a id="GUID-D512383C-36DB-463E-889E-FF6D4D0454FD" name="GUID-D512383C-36DB-463E-889E-FF6D4D0454FD"></a><h4 id="ZZPRE-GUID-D512383C-36DB-463E-889E-FF6D4D0454FD" class="sect4"><span class="enumeration_section">4.2.3 </span>Inserting Nulls
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e363" class="indexterm-anchor"></a>You can use indicator variables to insert nulls. Before the insert, for each column you want to be null, set the appropriate indicator variable to -1, as shown in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">set ind_comm = -1; 
EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
 VALUES (:emp_number, :commission:ind_comm);
</pre><p>The indicator variable <span class="italic">ind_comm</span> specifies that a null is to be stored in the <code class="codeph">COMM</code> column.
                        </p>
                        <p>You can <a id="d27112e380" class="indexterm-anchor"></a>hardcode the null instead, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
 VALUES (:emp_number, NULL);
</pre><p>While this is less flexible, it might be more readable.</p>
                        <p>Typically, you insert nulls conditionally, as the next example shows:</p><pre class="oac_no_warn" dir="ltr">display 'Enter employee number or 0 if not available: '; 
read emp_number; 
IF emp_number = 0 THEN 
 set ind_empnum = -1; ELSE 
 set ind_empnum = 0; 
ENDIF; 
EXEC SQL INSERT INTO EMP (EMPNO, SAL) 
 VALUES (:emp_number:ind_empnum, :salary);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE267"></a><div class="props_rev_3"><a id="GUID-69547774-BCF8-4E5A-A8E0-89E8A2FD8319" name="GUID-69547774-BCF8-4E5A-A8E0-89E8A2FD8319"></a><h4 id="ZZPRE-GUID-69547774-BCF8-4E5A-A8E0-89E8A2FD8319" class="sect4"><span class="enumeration_section">4.2.4 </span>Handling Returned Nulls
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e415" class="indexterm-anchor"></a>You can also use indicator variables to manipulate returned nulls, as the following example shows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, SAL, COMM 
 INTO :emp_name, :salary, :commission:ind_comm 
 FROM EMP 
 WHERE EMPNO = :emp_number; 
IF ind_comm = -1 THEN 
 set pay = salary; -- commission is null; ignore it 
ELSE 
 set pay = salary + commission; 
ENDIF;
<a id="d27112e422" class="indexterm-anchor"></a></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE268"></a><div class="props_rev_3"><a id="GUID-A5C0B04B-8D8F-476F-B1A8-5D9F246F5B9B" name="GUID-A5C0B04B-8D8F-476F-B1A8-5D9F246F5B9B"></a><h4 id="ZZPRE-GUID-A5C0B04B-8D8F-476F-B1A8-5D9F246F5B9B" class="sect4"><span class="enumeration_section">4.2.5 </span>Fetching Nulls
                  </h4>
                  <div>
                     <div class="section">
                        <p>When DBMS=NATIVE, V7, or V8, if you select or fetch nulls into a host variable that lacks an indicator variable, Oracle issues the following error message:<a id="d27112e449" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">ORA-01405: fetched column value is NULL
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE269"></a><div class="props_rev_3"><a id="GUID-6EE7EA55-D0C3-416F-BE5A-35966F37DC27" name="GUID-6EE7EA55-D0C3-416F-BE5A-35966F37DC27"></a><h4 id="ZZPRE-GUID-6EE7EA55-D0C3-416F-BE5A-35966F37DC27" class="sect4"><span class="enumeration_section">4.2.6 </span>Testing for Nulls
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e478" class="indexterm-anchor"></a>You <a id="d27112e483" class="indexterm-anchor"></a>can use indicator variables in the <code class="codeph">WHERE</code> clause to test for nulls, as the following example shows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE :commission:ind_comm IS NULL ...
</pre><p><a id="d27112e494" class="indexterm-anchor"></a>However, you cannot use a relational operator to compare nulls with each other or with other values. For example, the following <code class="codeph">SELECT</code> statement fails if the <code class="codeph">COMM</code> column contains one or more nulls: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE COMM = :commission:ind_comm;
</pre><p>The next example shows how to compare values for equality when some of them might be nulls:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE (COMM = :commission) OR ((COMM IS NULL) AND 
 (:commission:ind_comm IS NULL));
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE270"></a><div class="props_rev_3"><a id="GUID-B715DA66-1952-421D-8A9E-A9F0A85369BE" name="GUID-B715DA66-1952-421D-8A9E-A9F0A85369BE"></a><h4 id="ZZPRE-GUID-B715DA66-1952-421D-8A9E-A9F0A85369BE" class="sect4"><span class="enumeration_section">4.2.7 </span>Fetching Truncated Values
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e533" class="indexterm-anchor"></a>If you select or fetch a truncated column value into a host variable that lacks an indicator variable,  no error is generated.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE271"></a><div class="props_rev_3"><a id="GUID-361C97AB-8CFF-4029-AB10-D478618F47CC" name="GUID-361C97AB-8CFF-4029-AB10-D478618F47CC"></a><h3 id="ZZPRE-GUID-361C97AB-8CFF-4029-AB10-D478618F47CC" class="sect3"><span class="enumeration_section">4.3 </span>The Basic SQL Statements
               </h3>
               <div>
                  <p>Executable SQL statements let you query, manipulate, and control Oracle data and <a id="d27112e559" class="indexterm-anchor"></a>create, define, and maintain Oracle objects such as tables, views, and indexes. This chapter focuses on <a id="d27112e564" class="indexterm-anchor"></a>data manipulation statements (sometimes called <span class="italic">DML</span>) and cursor control statements. The following SQL statements let you query and <a id="d27112e570" class="indexterm-anchor"></a>manipulate Oracle data:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">SELECT</code>: Returns rows from one or more tables.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">INSERT</code>: Adds new rows to a table.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code>: Modifies rows in a table.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DELETE</code>: Removes rows from a table.
                        </p>
                     </li>
                  </ul>
                  <p>When executing a data manipulation statement such as <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>, your only concern, besides setting the values of any input host variables, is whether the statement succeeds or fails. To find out, you simply check the SQLCA. (Executing any SQL statement sets the SQLCA variables.) You can check in the following two ways:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Implicit checking with the <code class="codeph">WHENEVER</code> statement
                        </p>
                     </li>
                     <li>
                        <p>Explicit checking of SQLCA variables</p>
                     </li>
                  </ul>
                  <p>Alternatively, when <code class="codeph">MODE={ANSI|ANSI14}</code>, you can check the status variable <code class="codeph">SQLSTATE</code> or <code class="codeph">SQLCODE</code>. For more information, see <span class="q">"<a href="error-handling-diagnostics.html#GUID-2C54DB16-AE8F-4D16-901F-C1A2EF5DD8CD">About Using Status Variables when MODE={ANSI|ANSI14}</a>"</span>.
                  </p>
                  <p>When executing a <code class="codeph">SELECT</code> statement (<a id="d27112e638" class="indexterm-anchor"></a>query), however, you must also deal with the rows of data it returns. Queries can be classified as follows:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>queries that return no rows (that is, merely check for existence)</p>
                     </li>
                     <li>
                        <p>queries that return only one row</p>
                     </li>
                     <li>
                        <p>queries that return more than one row</p>
                     </li>
                  </ul>
                  <p><a id="d27112e652" class="indexterm-anchor"></a>Queries that return more than one row require an explicitly declared cursor or cursor variable (or the use of host arrays, which are discussed in <a href="using-host-arrays.html#GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F"> Using Host Arrays</a>). The following embedded SQL statements let you define and control an explicit cursor: 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DECLARE</code>: Names the cursor and associates it with a query.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OPEN</code>: Executes the query and identifies the active set.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">FETCH</code>: Advances the cursor and retrieves each row in the active set, one by one.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOSE</code>: Disables the cursor (the active set becomes undefined).
                        </p>
                     </li>
                  </ul>
                  <p>In the following sections, first you learn how to code <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, and single-row <code class="codeph">SELECT</code> statements. Then, you progress to multi-row <code class="codeph">SELECT</code> statements.
                  </p>
               </div><a id="ZZPRE272"></a><div class="props_rev_3"><a id="GUID-B735173A-E65B-4108-954E-20A19204D18E" name="GUID-B735173A-E65B-4108-954E-20A19204D18E"></a><h4 id="ZZPRE-GUID-B735173A-E65B-4108-954E-20A19204D18E" class="sect4"><span class="enumeration_section">4.3.1 </span>Selecting Rows
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e725" class="indexterm-anchor"></a>Querying the database is a common SQL operation. To issue a query you use the <a id="d27112e730" class="indexterm-anchor"></a><code class="codeph">SELECT</code> statement. In the following <a id="d27112e735" class="indexterm-anchor"></a>example, you query the <code class="codeph">EMP</code> table: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, JOB, SAL + 2000 
 INTO :emp_name, :job_title, :salary 
 FROM EMP 
 WHERE EMPNO = :emp_number;
</pre><p><a id="d27112e746" class="indexterm-anchor"></a>The column names and expressions following the keyword <code class="codeph">SELECT</code> make up the <span class="italic">select list</span>. The select list in our example contains three items. Under the conditions specified in the <code class="codeph">WHERE</code> clause (and following clauses, if present), Oracle returns column values to the host variables in the <code class="codeph">INTO</code> clause. The number of items in the select list should equal the number of host variables in the <code class="codeph">INTO</code> clause, so there is a place to store every returned value. 
                        </p>
                        <p><a id="d27112e767" class="indexterm-anchor"></a>In the simplest case, when a query returns one row, its form is that shown in the last example (in which <code class="codeph">EMPNO</code> is a unique key). However, if a query can return more than one row, you must fetch the rows using a cursor or select them into a host array. 
                        </p>
                        <p>If you write a query to return only one row but it might actually return several rows, the result depends on how you specify the option <code class="codeph">SELECT_ERROR</code>. When <code class="codeph">SELECT_ERROR</code><code class="codeph">=</code><code class="codeph">YES</code> (the default), Oracle issues the following error message if more than one row is returned: 
                        </p><pre class="oac_no_warn" dir="ltr">ORA-01422: exact fetch returns more than requested number of rows
</pre><p>When <code class="codeph">SELECT_ERROR=NO</code>, a row is returned and Oracle generates no error.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE273"></a><div class="props_rev_3"><a id="GUID-45429AA7-E4F8-46D8-8230-299F07E5971D" name="GUID-45429AA7-E4F8-46D8-8230-299F07E5971D"></a><h4 id="ZZPRE-GUID-45429AA7-E4F8-46D8-8230-299F07E5971D" class="sect4"><span class="enumeration_section">4.3.2 </span>Available Clauses
                  </h4>
                  <div>
                     <p>You can use all of the following standard SQL clauses in your <code class="codeph">SELECT</code> statements: <code class="codeph">INTO</code>, <code class="codeph">FROM</code>, <code class="codeph">WHERE</code>, <code class="codeph">CONNECT</code> <code class="codeph">BY</code>, <code class="codeph">START</code> <code class="codeph">WITH</code>, <code class="codeph">GROUP</code> <code class="codeph">BY</code>, <code class="codeph">HAVING</code>, <code class="codeph">ORDER</code> <code class="codeph">BY</code>, and <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> <code class="codeph">OF</code>. 
                     </p>
                  </div>
               </div><a id="ZZPRE274"></a><div class="props_rev_3"><a id="GUID-DBBFD998-6FCA-477A-A52E-AF7DB3DC94FD" name="GUID-DBBFD998-6FCA-477A-A52E-AF7DB3DC94FD"></a><h4 id="ZZPRE-GUID-DBBFD998-6FCA-477A-A52E-AF7DB3DC94FD" class="sect4"><span class="enumeration_section">4.3.3 </span>Inserting Rows
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e895" class="indexterm-anchor"></a>You use the <code class="codeph">INSERT</code> statement to add rows to a table or view. In the following example, you add a row to the <code class="codeph">EMP</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP (EMPNO, ENAME, SAL, DEPTNO) 
 VALUES (:emp_number, :emp_name, :salary, :dept_number);
</pre><p><a id="d27112e909" class="indexterm-anchor"></a>Each column you specify in the column list must belong to the table named in the <a id="d27112e914" class="indexterm-anchor"></a><code class="codeph">INTO</code> <a id="d27112e921" class="indexterm-anchor"></a>clause. The <code class="codeph">VALUES</code> clause specifies the row of values to be inserted. The values can be those of constants, host variables, SQL expressions, or pseudocolumns, such as <code class="codeph">USER</code> and <code class="codeph">SYSDATE</code>.
                        </p>
                        <p>The number of values in the <code class="codeph">VALUES</code> clause must equal the number of names in the column list. However, you can omit the column list if the <code class="codeph">VALUES</code> clause contains a value for each column in the table in the same order they were defined by <code class="codeph">CREATE</code> <code class="codeph">TABLE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE275"></a><div class="props_rev_3"><a id="GUID-B05FC120-CF3B-4A9B-B081-69834E1F1FBB" name="GUID-B05FC120-CF3B-4A9B-B081-69834E1F1FBB"></a><h4 id="ZZPRE-GUID-B05FC120-CF3B-4A9B-B081-69834E1F1FBB" class="sect4"><span class="enumeration_section">4.3.4 </span>Using Subqueries
                  </h4>
                  <div>
                     <div class="section">
                        <p>A <a id="d27112e973" class="indexterm-anchor"></a><span class="italic">subquery</span> is a nested <code class="codeph">SELECT</code> statement. Subqueries let you conduct multipart searches. They can be used to
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>supply values for comparison in the <code class="codeph">WHERE</code>, <code class="codeph">HAVING</code>, and <code class="codeph">START</code> <code class="codeph">WITH</code> clauses of <code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> statements
                              </p>
                           </li>
                           <li>
                              <p>define the set of rows to be inserted by a <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> or <code class="codeph">INSERT</code> statement
                              </p>
                           </li>
                           <li>
                              <p>define values for the <code class="codeph">SET</code> clause of an <code class="codeph">UPDATE</code> statement
                              </p>
                           </li>
                        </ul>
                        <p><a id="d27112e1030" class="indexterm-anchor"></a><a id="d27112e1034" class="indexterm-anchor"></a><a id="d27112e1038" class="indexterm-anchor"></a>For <a id="d27112e1043" class="indexterm-anchor"></a>example, to copy rows from one table to another, replace the <code class="codeph">VALUES</code> clause in an <code class="codeph">INSERT</code> statement with a subquery, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP2 (EMPNO, ENAME, SAL, DEPTNO) 
 SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
 WHERE JOB = :job_title;
</pre><p>Notice how the <code class="codeph">INSERT</code> statement uses the subquery to obtain intermediate results.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE276"></a><div class="props_rev_3"><a id="GUID-A9C81554-7B93-4543-A103-8B6BA375681A" name="GUID-A9C81554-7B93-4543-A103-8B6BA375681A"></a><h4 id="ZZPRE-GUID-A9C81554-7B93-4543-A103-8B6BA375681A" class="sect4"><span class="enumeration_section">4.3.5 </span>Updating Rows
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1083" class="indexterm-anchor"></a>You use the <a id="d27112e1088" class="indexterm-anchor"></a><a id="d27112e1090" class="indexterm-anchor"></a><code class="codeph">UPDATE</code> statement to change the values of specified columns in a table or view. In the following example, you update the <code class="codeph">SAL</code> and <code class="codeph">COMM</code> columns in the <code class="codeph">EMP</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP 
 SET SAL = :salary, COMM = :commission 
 WHERE EMPNO = :emp_number;
</pre><p>You can use the optional <code class="codeph">WHERE</code> clause to specify the conditions under which rows are updated. See <span class="q">"<a href="using-embedded-SQL.html#GUID-45F5EA0B-C639-4A68-9956-8A8C71160357">Using the WHERE Clause</a>"</span>.
                        </p>
                        <p><a id="d27112e1119" class="indexterm-anchor"></a><a id="d27112e1123" class="indexterm-anchor"></a><a id="d27112e1127" class="indexterm-anchor"></a>The <a id="d27112e1132" class="indexterm-anchor"></a><a id="d27112e1134" class="indexterm-anchor"></a><code class="codeph">SET</code> clause lists the names of one or more columns for which you must provide values. You can use a subquery to provide the values, as the following example shows: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP 
 SET SAL = (SELECT AVG(SAL)*1.1 FROM EMP WHERE DEPTNO = 20) 
 WHERE EMPNO = :emp_number;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE277"></a><div class="props_rev_3"><a id="GUID-5374A5E2-CEAF-4E29-981E-86C833A88494" name="GUID-5374A5E2-CEAF-4E29-981E-86C833A88494"></a><h4 id="ZZPRE-GUID-5374A5E2-CEAF-4E29-981E-86C833A88494" class="sect4"><span class="enumeration_section">4.3.6 </span>Deleting Rows
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1166" class="indexterm-anchor"></a>You use the <code class="codeph">DELETE</code> statement to remove rows from a table or view. In the following example, you delete all employees in a given department from the <code class="codeph">EMP</code> table: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP 
 WHERE DEPTNO = :dept_number;
</pre><p><a id="d27112e1180" class="indexterm-anchor"></a>You can use the optional <code class="codeph">WHERE</code> clause to specify the condition under which rows are deleted.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE278"></a><div class="props_rev_3"><a id="GUID-45F5EA0B-C639-4A68-9956-8A8C71160357" name="GUID-45F5EA0B-C639-4A68-9956-8A8C71160357"></a><h4 id="ZZPRE-GUID-45F5EA0B-C639-4A68-9956-8A8C71160357" class="sect4"><span class="enumeration_section">4.3.7 </span>Using the WHERE Clause
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1220" class="indexterm-anchor"></a>You use the <code class="codeph">WHERE</code> clause to select, update, or delete only those rows in a table or view that meet your search condition. The <code class="codeph">WHERE</code>-clause <span class="italic">search condition</span> is a Boolean expression, which can include scalar host variables, host arrays (not in <code class="codeph">SELECT</code> statements), and subqueries. 
                        </p>
                        <p>If you omit the <code class="codeph">WHERE</code> clause, all rows in the table or view are processed. If you omit the <code class="codeph">WHERE</code> clause in an <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code> statement, Oracle sets SQLWARN(5) in the SQLCA to 'W' to warn that all rows were processed.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE279"></a><div class="props_rev_3"><a id="GUID-0327E691-23A7-48C4-91D7-3447B298545D" name="GUID-0327E691-23A7-48C4-91D7-3447B298545D"></a><h3 id="ZZPRE-GUID-0327E691-23A7-48C4-91D7-3447B298545D" class="sect3"><span class="enumeration_section">4.4 </span>Cursors
               </h3>
               <div>
                  <p><a id="d27112e1272" class="indexterm-anchor"></a>When a query returns multiple<a id="d27112e1275" class="indexterm-anchor"></a> rows, you can explicitly define a cursor to:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Process beyond the first row returned by the query</p>
                     </li>
                     <li>
                        <p>Keep track of which row is currently being processed</p>
                     </li>
                  </ul>
                  <p><a id="d27112e1288" class="indexterm-anchor"></a>A cursor identifies the current row in the set of rows returned by the query. This allows your program to process the rows one at a time. The following statements let you define and manipulate a cursor:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DECLARE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OPEN</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">FETCH</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOSE</code></p>
                     </li>
                  </ul>
                  <p><a id="d27112e1311" class="indexterm-anchor"></a>First <a id="d27112e1316" class="indexterm-anchor"></a>you use the <code class="codeph">DECLARE</code> statement to name the cursor and associate it with a query.
                  </p>
                  <p>The <code class="codeph">OPEN</code> statement executes the query and identifies all the rows that meet the query search condition. These rows form a set called the active set of the cursor. <a id="d27112e1329" class="indexterm-anchor"></a>After opening the cursor, you can use it to retrieve the rows returned by its associated query.
                  </p>
                  <p>Rows of the active set are retrieved one by one (unless you use host arrays). You use a <code class="codeph">FETCH</code> statement to retrieve the current row in the active set. You can execute <code class="codeph">FETCH</code> repeatedly until all rows have been retrieved.
                  </p>
                  <p>When you complete fetching rows from the active set, you disable the cursor with a <code class="codeph">CLOSE</code> statement, and the active set becomes undefined.
                  </p>
               </div><a id="ZZPRE280"></a><div class="props_rev_3"><a id="GUID-25DA2AA4-8E1D-45BB-9FC6-CEC7ED9B7FCD" name="GUID-25DA2AA4-8E1D-45BB-9FC6-CEC7ED9B7FCD"></a><h4 id="ZZPRE-GUID-25DA2AA4-8E1D-45BB-9FC6-CEC7ED9B7FCD" class="sect4"><span class="enumeration_section">4.4.1 </span>Declaring a Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1367" class="indexterm-anchor"></a><a id="d27112e1371" class="indexterm-anchor"></a>You use the <code class="codeph">DECLARE</code> statement to define a cursor by giving it a name and associating it with a query, as the following example shows: 
                        </p><pre class="oac_no_warn" dir="ltr"><a id="d27112e1380" class="indexterm-anchor"></a>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, EMPNO, SAL 
 FROM EMP 
 WHERE DEPTNO = :dept_number;
</pre><p><a id="d27112e1386" class="indexterm-anchor"></a>The <a id="d27112e1391" class="indexterm-anchor"></a>cursor name is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be defined in the Declare Section. Therefore, cursor names cannot be passed from one precompilation unit to another. Also, cursor names cannot be hyphenated. They can be any length, but only the first 31 characters are significant. For ANSI compatibility, use cursor names no longer than 18 characters. 
                        </p>
                        <p>The <code class="codeph">SELECT</code> statement associated with the cursor cannot include an <code class="codeph">INTO</code> clause. Rather, the <code class="codeph">INTO</code> clause and list of output host variables are part of the <code class="codeph">FETCH</code> statement.
                        </p>
                        <p><a id="d27112e1414" class="indexterm-anchor"></a>Because it is declarative, the <code class="codeph">DECLARE</code> statement must physically (not just logically) precede all other SQL statements referencing the cursor. That is, <a id="d27112e1422" class="indexterm-anchor"></a>forward references to the cursor are not allowed. In the following example, the <code class="codeph">OPEN</code> statement is misplaced: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor; -- misplaced OPEN statement
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, EMPNO, SAL 
 FROM EMP 
 WHERE ENAME = :emp_name;
</pre><p>The cursor control statements must all occur within the same precompiled unit. For example, you cannot declare a cursor in file A, then open it in file B. </p>
                        <p>Your host program can declare as many cursors as it needs. However, in a given file, every <code class="codeph">DECLARE</code> statement must be unique. That is, you cannot declare two cursors with the same name in one precompilation unit, even across blocks or procedures, because the scope<a id="d27112e1437" class="indexterm-anchor"></a> of a cursor is global within a file.<a id="d27112e1440" class="indexterm-anchor"></a> If you will be using many cursors, you might want to specify the <code class="codeph">MAXOPENCURSORS</code> option. For more information, see <span class="q">"<a href="running-Oracle-precompilers.html#GUID-26711A61-6CA5-47C3-9048-F008760EFDA2">MAXOPENCURSORS</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE281"></a><div class="props_rev_3"><a id="GUID-011D5621-6E16-4175-BD85-AE4C4AE3A38C" name="GUID-011D5621-6E16-4175-BD85-AE4C4AE3A38C"></a><h4 id="ZZPRE-GUID-011D5621-6E16-4175-BD85-AE4C4AE3A38C" class="sect4"><span class="enumeration_section">4.4.2 </span>Opening a Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p>Use the <a id="d27112e1476" class="indexterm-anchor"></a><code class="codeph">OPEN</code> statement to execute the query and identify the active set. In the following <a id="d27112e1481" class="indexterm-anchor"></a>example, a cursor named <span class="italic">emp_cursor</span> is opened.
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor;
</pre><p><code class="codeph">OPEN</code> positions the cursor just before the first row of the active set. It also zeroes the rows-processed count kept by SQLERRD(3) in the SQLCA. However, none of the rows is actually retrieved at this point. That will be done by the <code class="codeph">FETCH</code> statement.
                        </p>
                        <p>After you open a cursor, the query's input host variables are not reexamined until you reopen the cursor. Thus, the active set does not change. <a id="d27112e1500" class="indexterm-anchor"></a>To change the active set, you must reopen the cursor. 
                        </p>
                        <p><a id="d27112e1506" class="indexterm-anchor"></a>Generally, you should close a cursor before reopening it. However, if you specify <code class="codeph">MODE=ORACLE</code> (the default), you need not close a cursor before reopening it. This can boost performance; for details, see <a href="performance-tuning.html#GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE"> Performance Tuning</a> 
                        </p>
                        <p>The amount of work done by OPEN depends on the values of three precompiler options: <code class="codeph">HOLD_CURSOR, RELEASE_CURSOR</code>, and <code class="codeph">MAXOPENCURSORS</code>. For more information, see <span class="q">"<a href="running-Oracle-precompilers.html#GUID-3B46BD40-209C-4426-B8C3-4ABF97C44507">About Using the Precompiler Options</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE282"></a><div class="props_rev_3"><a id="GUID-633132E8-77E9-4FEC-A337-CAE14E2A83FF" name="GUID-633132E8-77E9-4FEC-A337-CAE14E2A83FF"></a><h4 id="ZZPRE-GUID-633132E8-77E9-4FEC-A337-CAE14E2A83FF" class="sect4"><span class="enumeration_section">4.4.3 </span>Fetching from a Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p>You use the <code class="codeph">FETCH</code> statement to retrieve rows from the active set and specify the output host variables that will contain the results. Recall that the <code class="codeph">SELECT</code> statement associated with the cursor cannot include an <code class="codeph">INTO</code> clause. Rather, the <code class="codeph">INTO</code> clause and list of output host variables are part of the <code class="codeph">FETCH</code> statement. In the following example, you fetch into three host variables: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor 
 INTO :emp_name, :emp_number, :salary;
</pre><p>The cursor must have been previously declared and opened. The first time you execute <code class="codeph">FETCH</code>, the cursor moves from before the first row in the active set to the first row. This row becomes the current row. Each subsequent execution of <code class="codeph">FETCH</code> advances the cursor to the next row in the active set, changing the current row. The cursor can only move forward in the active set. To return to a row that has already been fetched, you must reopen the cursor, then begin again at the first row of the active set.
                        </p>
                        <p><a id="d27112e1581" class="indexterm-anchor"></a>If you want to change the active set, you must assign new values to the input host variables in the query associated with the cursor, then reopen the cursor. When <code class="codeph">MODE={ANSI | ANSI14 | ANSI13}</code>, you must close the cursor before reopening it. 
                        </p>
                        <p>As the next example shows, you can fetch from the same cursor using different sets of output host variables. However, corresponding host variables in the <code class="codeph">INTO</code> clause of each <code class="codeph">FETCH</code> statement must have the same datatype.
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 20; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND DO ... 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name1, :salary1; 
 EXEC SQL FETCH emp_cursor INTO :emp_name2, :salary2; 
 EXEC SQL FETCH emp_cursor INTO :emp_name3, :salary3; 
 ... 
ENDLOOP;
</pre><p><a id="d27112e1600" class="indexterm-anchor"></a>If <a id="d27112e1603" class="indexterm-anchor"></a>the active set is empty or contains no more rows, <code class="codeph">FETCH</code> returns the "no data found" Oracle warning code to <code class="codeph">SQLCODE</code> in the SQLCA (or when MODE=ANSI, to the status variable <code class="codeph">SQLSTATE</code>). The status of the output host variables is indeterminate. (In a typical program, the <code class="codeph">WHENEVER NOT FOUND</code> statement detects this error.) To reuse the cursor, you must reopen it. 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE283"></a><div class="props_rev_3"><a id="GUID-9ABBDACE-A92C-4836-8A32-B4586D942738" name="GUID-9ABBDACE-A92C-4836-8A32-B4586D942738"></a><h4 id="ZZPRE-GUID-9ABBDACE-A92C-4836-8A32-B4586D942738" class="sect4"><span class="enumeration_section">4.4.4 </span>Closing a Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1642" class="indexterm-anchor"></a>When finished fetching rows from the active set, you close the cursor to free the resources, such as storage, acquired by opening the cursor. When a cursor is closed, parse locks are released. What resources are freed depends on how you specify the options <code class="codeph">HOLD_CURSOR</code> and <code class="codeph">RELEASE_CURSOR</code>. In the following example, you close the cursor named<code class="codeph"> emp_cursor</code>:<a id="d27112e1654" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor;
</pre><p>You cannot fetch from a closed cursor because its active set becomes undefined. If necessary, you can reopen a cursor (with new values for the input host variables, for example).</p>
                        <p>When <code class="codeph">MODE={ANSI13|ORACLE}</code>, issuing a commit or rollback closes cursors referenced in a <code class="codeph">CURRENT OF</code> clause. Other cursors are unaffected by a commit or rollback and if open, remain open. However, when <code class="codeph">MODE={ANSI|ANSI14}</code>, issuing a commit or rollback closes <span class="italic">all</span> explicit cursors.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE284"></a><div class="props_rev_3"><a id="GUID-272729B1-06E6-44B7-8822-0C61CE6E7BF5" name="GUID-272729B1-06E6-44B7-8822-0C61CE6E7BF5"></a><h4 id="ZZPRE-GUID-272729B1-06E6-44B7-8822-0C61CE6E7BF5" class="sect4"><span class="enumeration_section">4.4.5 </span>Using the CURRENT OF Clause
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e1699" class="indexterm-anchor"></a>You use the <code class="codeph">CURRENT OF</code> <span class="italic">cursor_name</span> clause in a <code class="codeph">DELETE</code> or <code class="codeph">UPDATE</code> statement to refer to the latest row fetched from the named cursor. The cursor must be open and positioned on a row. If no fetch has been done or if the cursor is not open, the <code class="codeph">CURRENT OF</code> clause results in an error and processes no rows. 
                        </p>
                        <p>The <code class="codeph">FOR UPDATE OF</code> clause is optional when you declare a cursor that is referenced in the <code class="codeph">CURRENT OF</code> clause of an <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code> statement. The <code class="codeph">CURRENT OF</code> clause signals the precompiler to add a <code class="codeph">FOR UPDATE</code> clause if necessary. For more information, see <span class="q">"<a href="defining-controlling-transactions.html#GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC">About Using the FOR UPDATE OF Clause</a>"</span>.
                        </p>
                        <p><a id="d27112e1744" class="indexterm-anchor"></a>In the following example, you use the <code class="codeph">CURRENT OF</code> clause to refer to the latest row fetched from a cursor named <span class="italic">emp_cursor</span>: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, SAL FROM EMP WHERE JOB = 'CLERK' 
 FOR UPDATE OF SAL; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND DO ... 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary; 
 ... 
 EXEC SQL UPDATE EMP SET SAL = :new_salary 
 WHERE CURRENT OF emp_cursor; 
ENDLOOP;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE285"></a><div class="props_rev_3"><a id="GUID-545F0608-61CA-4152-B3F8-F11746009412" name="GUID-545F0608-61CA-4152-B3F8-F11746009412"></a><h4 id="ZZPRE-GUID-545F0608-61CA-4152-B3F8-F11746009412" class="sect4"><span class="enumeration_section">4.4.6 </span>Restrictions
                  </h4>
                  <div>
                     <p><a id="d27112e1779" class="indexterm-anchor"></a>An explicit <code class="codeph">FOR UPDATE OF</code> or an implicit <code class="codeph">FOR UPDATE</code> acquires exclusive row locks. All rows are locked at the open, not as they are fetched, and are released when you commit or rollback. If you try to fetch from a <code class="codeph">FOR UPDATE</code> cursor after a commit, Oracle generates the following error:
                     </p><pre class="oac_no_warn" dir="ltr">ORA-01002: fetch out of sequence
</pre><p>You cannot use host arrays with the <code class="codeph">CURRENT OF</code> clause. For an alternative, see <span class="q">"<a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">About Mimicking the CURRENT OF Clause</a>"</span>. Also, you cannot reference multiple tables in an associated <code class="codeph">FOR UPDATE OF</code> clause, which means that you cannot do joins with the <code class="codeph">CURRENT OF</code> clause. Finally, you cannot use the <code class="codeph">CURRENT OF</code> clause in dynamic SQL.
                     </p>
                  </div>
               </div><a id="ZZPRE286"></a><div class="props_rev_3"><a id="GUID-1E88E95D-DD96-4FE2-88C0-A2D8E42EBEE0" name="GUID-1E88E95D-DD96-4FE2-88C0-A2D8E42EBEE0"></a><h4 id="ZZPRE-GUID-1E88E95D-DD96-4FE2-88C0-A2D8E42EBEE0" class="sect4"><span class="enumeration_section">4.4.7 </span>A Typical Sequence of Statements
                  </h4>
                  <div>
                     <p>The following example shows the typical sequence of cursor control statements in an application program:</p><pre class="oac_no_warn" dir="ltr">-- Define a cursor.
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB FROM EMP 
 WHERE EMPNO = :emp_number 
 FOR UPDATE OF JOB; 

-- Open the cursor and identify the active set.
EXEC SQL OPEN emp_cursor; 
-- Exit if the last row was already fetched.
EXEC SQL WHENEVER NOT FOUND DO no_more; 

-- Fetch and process data in a loop.
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name, :job_title; 
 -- host-language statements that operate on the fetched data 
 EXEC SQL UPDATE EMP 
 SET JOB = :new_job_title 
 WHERE CURRENT OF emp_cursor; 
ENDLOOP; 
... 
ROUTINE no_more
BEGIN
-- Disable the cursor.
 EXEC SQL CLOSE emp_cursor; 
 EXEC SQL COMMIT WORK RELEASE; 
 exit program; 
END no_more;
</pre></div>
               </div><a id="ZZPRE287"></a><div class="props_rev_3"><a id="GUID-E003DD77-F11A-4195-B0E7-4A037D99373C" name="GUID-E003DD77-F11A-4195-B0E7-4A037D99373C"></a><h4 id="ZZPRE-GUID-E003DD77-F11A-4195-B0E7-4A037D99373C" class="sect4"><span class="enumeration_section">4.4.8 </span>A Complete Example
                  </h4>
                  <div>
                     <p>The following program illustrates the use of a cursor and the <code class="codeph">FETCH</code> statement. The program prompts for a department number, then displays the names of all employees in that department.
                     </p>
                     <p>All fetches except the final one return a row and, if no errors were detected during the fetch, a success status code. The final fetch fails and returns the "no data found" Oracle warning code to <code class="codeph">SQLCODE</code> in the SQLCA. The cumulative number of rows actually fetched is found in <code class="codeph">SQLERRD(3)</code> in the SQLCA.
                     </p><pre class="oac_no_warn" dir="ltr">-- declare host variables 
EXEC SQL BEGIN DECLARE SECTION; 
 username CHARACTER(20); 
 password CHARACTER(20); 
 emp_name CHARACTER(10); 
 dept_number INTEGER; 
EXEC SQL END DECLARE SECTION; 
-- copy in the SQL Communications Area 
EXEC SQL INCLUDE SQLCA; 

display 'Username? '; 
read username; 
display 'Password? '; 
read password; 

-- handle processing errors 
EXEC SQL WHENEVER SQLERROR DO sql_error; 

-- log on to Oracle 
EXEC SQL CONNECT :username IDENTIFIED BY :password; 
display 'Connected to Oracle'; 

-- declare a cursor 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME FROM EMP WHERE DEPTNO = :dept_number; 

display 'Department number? '; 
read dept_number; 

-- open the cursor and identify the active set 
EXEC SQL OPEN emp_cursor; 

-- exit if the last row was already fetched 
EXEC SQL WHENEVER NOT FOUND DO no_more; 

display 'Employee Name'; 
display '-------------'; 

-- fetch and process data in a loop 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name; display emp_name; 
ENDLOOP;
ROUTINE no_more
BEGIN
 EXEC SQL CLOSE emp_cursor; 
 EXEC SQL COMMIT WORK RELEASE; 
 display 'End of program'; 
 exit program; 
END no_more;

ROUTINE sql_error
BEGIN
 EXEC SQL WHENEVER SQLERROR CONTINUE; 
 EXEC SQL ROLLBACK WORK RELEASE; 
 display 'Processing error'; 
 exit program with an error; 
END sql_error;
</pre></div>
               </div>
            </div><a id="ZZPRE288"></a><div class="props_rev_3"><a id="GUID-3A7191D8-EAF2-4F34-A24F-3455CCA9C9AC" name="GUID-3A7191D8-EAF2-4F34-A24F-3455CCA9C9AC"></a><h3 id="ZZPRE-GUID-3A7191D8-EAF2-4F34-A24F-3455CCA9C9AC" class="sect3"><span class="enumeration_section">4.5 </span>Cursor Variables
               </h3>
               <div>
                  <p>This section gives a brief overview of cursor variables. For more information, see your host language supplement and <a href="../lnpls/static-sql.html#LNPLS-GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" target="_blank">Cursor Variables</a>.
                  </p>
                  <p>When using static embedded SQL with the Pro*COBOL and Pro*FORTRAN Precompilers, you can declare cursor variables. Like a cursor, a cursor variable points to the current row in the active set of a multi-row query. Cursors differ from cursor variables the way constants differ from variables. While a cursor is static, a cursor variable is dynamic, because it is not tied to a specific query. You can open a cursor variable for any type-compatible query.</p>
                  <p>Also, you can assign new values to a cursor variable and pass it as a parameter to subprograms, including subprograms stored in an Oracle database. This gives you a convenient way to centralize data retrieval.</p>
                  <p>First, you declare the cursor variable. After declaring the variable, you use four statements to control a cursor variable:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">ALLOCATE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OPEN ... FOR</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">FETCH</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOSE</code></p>
                     </li>
                  </ul>
                  <p>After you declare the cursor variable and allocate memory for it, you must pass it as an input host variable (bind variable) to PL/SQL, OPEN it FOR a multi-row query on the server side, <code class="codeph">FETCH</code> from it on the client side, then <code class="codeph">CLOSE</code> it on either side.
                  </p>
               </div><a id="ZZPRE289"></a><div class="props_rev_3"><a id="GUID-7B44C2B9-39F2-4344-9F43-5363DB83AAAD" name="GUID-7B44C2B9-39F2-4344-9F43-5363DB83AAAD"></a><h4 id="ZZPRE-GUID-7B44C2B9-39F2-4344-9F43-5363DB83AAAD" class="sect4"><span class="enumeration_section">4.5.1 </span>About Declaring a Cursor Variable
                  </h4>
                  <div>
                     <p>How you declare a cursor variable is dependent on your host language. For instructions about declaring a cursor variable, see your host-language supplement.</p>
                  </div>
               </div><a id="ZZPRE290"></a><div class="props_rev_3"><a id="GUID-6EB733A2-2737-4407-BD1B-5F30A36BCAD7" name="GUID-6EB733A2-2737-4407-BD1B-5F30A36BCAD7"></a><h4 id="ZZPRE-GUID-6EB733A2-2737-4407-BD1B-5F30A36BCAD7" class="sect4"><span class="enumeration_section">4.5.2 </span>Allocating a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>You use the <code class="codeph">ALLOCATE</code> statement to allocate memory for the cursor variable. The syntax follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE &lt;cursor_variable&gt;;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE291"></a><div class="props_rev_3"><a id="GUID-79454522-5A3F-4DB6-A4A0-20D93715E6E9" name="GUID-79454522-5A3F-4DB6-A4A0-20D93715E6E9"></a><h4 id="ZZPRE-GUID-79454522-5A3F-4DB6-A4A0-20D93715E6E9" class="sect4"><span class="enumeration_section">4.5.3 </span>Opening a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e2003" class="indexterm-anchor"></a>You use the <a id="d27112e2008" class="indexterm-anchor"></a><code class="codeph">OPEN ... FOR</code> statement to associate a cursor variable with a multi-row query, execute the query, and identify the active set. The syntax follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN &lt;cursor_variable&gt; FOR &lt;select_statement&gt;;
</pre><p>The <code class="codeph">SELECT</code> statement can reference input host variables and PL/SQL variables, parameters, and functions but cannot be <code class="codeph">FOR UPDATE</code>. In the following example, you open a cursor variable named <span class="italic">emp_cv</span>: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cv FOR SELECT * FROM EMP;
</pre><p><a id="d27112e2029" class="indexterm-anchor"></a>You must open a cursor variable on the server side. You do that by passing it as an input host variable to an anonymous PL/SQL block. At run time, the block is sent to the Oracle Server for execution. In the following example, you declare and initialize a cursor variable, then pass it to a PL/SQL block, which opens the cursor variable:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
-- declare cursor variable
 emp_cur SQL_CURSOR;
EXEC SQL END DECLARE SECTION;
 
-- initialize cursor variable
EXEC SQL ALLOCATE :emp_cur;
 
EXEC SQL EXECUTE
 -- pass cursor variable to PL/SQL block
 BEGIN
 -- open cursor variable
 OPEN :emp_cur FOR SELECT * FROM EMP;
 END;
END-EXEC;
</pre><p>Generally, you pass a cursor variable to PL/SQL by calling a stored procedure that declares a cursor variable as one of its formal parameters. For example, the following packaged procedure opens a cursor variable named <span class="italic">emp_cv</span>:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_data AS
 -- define REF CURSOR type
 TYPE EmpCurTyp IS REF CURSOR RETURN emp%ROWTYPE;
 -- declare formal paramter of that type
 PROCEDURE open_emp_cv (emp_cv IN OUT EmpCurTyp);
END emp_data;
 
CREATE PACKAGE BODY emp_data AS
 PROCEDURE open_emp_cv (emp_cv IN OUT EmpCurTyp) IS
 BEGIN
 -- open cursor variable
 OPEN emp_cv FOR SELECT * FROM emp;
 END open_emp_cv;
END emp_data;
</pre><p>You can call the procedure from any application, as follows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE
 BEGIN 
 emp_data.open_emp_cv(:emp_cur); 
 END; 
END-EXEC;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE292"></a><div class="props_rev_3"><a id="GUID-7625CEB0-92B0-4627-AF4D-9B2BF86F0DD6" name="GUID-7625CEB0-92B0-4627-AF4D-9B2BF86F0DD6"></a><h4 id="ZZPRE-GUID-7625CEB0-92B0-4627-AF4D-9B2BF86F0DD6" class="sect4"><span class="enumeration_section">4.5.4 </span>Fetching from a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e2067" class="indexterm-anchor"></a>After opening a cursor variable for a multi-row query, you use the <code class="codeph">FETCH</code> statement to retrieve rows from the active set one at a time. The syntax follows: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH cursor_variable_name 
 INTO {record_name | variable_name[, variable_name, ...]};
</pre><p>Each column value returned by the cursor variable is assigned to a corresponding field or variable in the <code class="codeph">INTO</code> clause, providing their datatypes are compatible. 
                        </p>
                        <p><a id="d27112e2081" class="indexterm-anchor"></a>The <code class="codeph">FETCH</code> statement must be executed on the client side. In the following <a id="d27112e2087" class="indexterm-anchor"></a>example, you fetch rows into a host record named <span class="italic">emp_rec</span>:
                        </p><pre class="oac_no_warn" dir="ltr">-- exit loop when done fetching
EXEC SQL WHENEVER NOT FOUND DO no_more;
LOOP
 -- fetch row into record
 EXEC SQL FETCH :emp_cur INTO :emp_rec; 
 -- process the data
ENDLOOP;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE293"></a><div class="props_rev_3"><a id="GUID-9EDBE1BA-2041-46A9-9326-4FD959D07DFC" name="GUID-9EDBE1BA-2041-46A9-9326-4FD959D07DFC"></a><h4 id="ZZPRE-GUID-9EDBE1BA-2041-46A9-9326-4FD959D07DFC" class="sect4"><span class="enumeration_section">4.5.5 </span>Closing a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d27112e2119" class="indexterm-anchor"></a>You use the <code class="codeph">CLOSE</code> statement to close a cursor variable, at which point its active set becomes undefined. The syntax follows: 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE cursor_variable_name;
</pre><p>The <code class="codeph">CLOSE</code> statement can be executed on the client side or the server side. In the following example, when the last row is processed, you close the cursor variable <span class="italic">emp_cur</span>:
                        </p><pre class="oac_no_warn" dir="ltr">-- close cursor variable
EXEC SQL CLOSE :emp_cur;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>