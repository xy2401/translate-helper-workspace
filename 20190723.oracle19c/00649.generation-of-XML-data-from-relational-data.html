<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">
      <meta name="description" content="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">
      <title>Generation of XML Data from Relational Data</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Developer's Guide ">
      <meta property="og:description" content="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96222-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="relational-data-to-and-from-XML-data.html" title="Previous" type="text/html">
      <link rel="next" href="relational-views-over-XML-data.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer's Guide">
    <meta name="dcterms.isVersionOf" content="ADXDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="relational-data-to-and-from-XML-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="relational-views-over-XML-data.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="relational-data-to-and-from-XML-data.html" property="item" typeof="WebPage"><span property="name"> Relational Data To and From XML Data</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Generation of XML Data from Relational Data</li>
            </ol>
            <a id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" name="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686"></a><a id="ADXDB1600"></a>
            
            <h2 id="ADXDB-GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" class="sect2"><span class="enumeration_chapter">8 </span> Generation of XML Data from Relational Data
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='generation-of-XML-data-from-relational-data'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F">Overview of Generating XML Data</a><br>You can generate XML data using Oracle XML&nbsp;DB using standard SQL/XML functions, Oracle-specific SQL functions, PL/SQL subprograms from package <code class="codeph">DBMS_XMLGEN</code>, or <code class="codeph">DBURIType</code>.
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967">Generation of XML Data Using SQL Functions</a><br>Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912">Generation of XML Data Using DBMS_XMLGEN</a><br>PL/SQL package <code class="codeph">DBMS_XMLGEN</code> creates XML documents from SQL query results. It retrieves an XML document as a <code class="codeph">CLOB</code> or <code class="codeph">XMLType</code> value. 
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42">SYS_XMLAGG Oracle SQL Function</a><br>Oracle SQL function <code class="codeph">sys_XMLAgg</code> aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named <code class="codeph">ROWSET</code> (by default).
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130">Ordering Query Results Before Aggregating, Using XMLAGG ORDER BY Clause</a><br>To use the <code class="codeph">XMLAgg ORDER BY</code> clause before aggregation, specify the <code class="codeph">ORDER BY</code> clause following the first <code class="codeph">XMLAGG</code> argument. 
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384">Returning a Rowset Using XMLTABLE</a><br>You can use standard SQL/XML function <code class="codeph">XMLTable</code> to return a rowset with relevant portions of a document extracted as multiple rows. 
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686__GUID-52EE5CDD-75CF-48B8-88F5-055B8A1B4116">
                  <p class="notep1">See Also:</p>
                  <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information about constructing XML data using SQL/XML functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLTable</code></p>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="relational-data-to-and-from-XML-data.html#GUID-52910135-EC23-41B2-97EC-116790BF6A3C" title="There are various ways that you can view existing relational data as XML data.">Relational Data To and From XML Data</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4987"></a><div class="props_rev_3"><a id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" name="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F"></a><h3 id="ADXDB-GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" class="sect3"><span class="enumeration_section">8.1 </span>Overview of Generating XML Data
               </h3>
               <div>
                  <p>You can generate XML data using Oracle XML&nbsp;DB using standard SQL/XML functions, Oracle-specific SQL functions, PL/SQL subprograms from package <code class="codeph">DBMS_XMLGEN</code>, or <code class="codeph">DBURIType</code>.
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Use standard SQL/XML functions. See <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a>.
                        </p>
                     </li>
                     <li>
                        <p>Use Oracle SQL functions . See the following sections:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL function XMLColAttVal generates a forest of XML column elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions.">XMLCOLATTVAL Oracle SQL Function</a> 
                              </p>
                           </li>
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="You use Oracle SQL function XMLCDATA to generate an XML CDATA section.">XMLCDATA Oracle SQL Function</a></p>
                           </li>
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL function sys_XMLAgg aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named ROWSET (by default).">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of rows, aggregating several XML documents into one.
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>Use PL/SQL package <code class="codeph">DBMS_XMLGEN</code>. See <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a>.
                        </p>
                     </li>
                     <li>
                        <p>Use a <code class="codeph">DBURIType</code> instance to construct XML documents from database data. See <a href="data-access-using-URIs.html#GUID-0F5F6D4C-0C27-4EC0-926C-CDCC0C1F9798" title="You can generate and store URIs in the database and use them to retrieve the database data they target. There are three kinds of URIs you can use this way: DBUris, XDBUris, and HTTPUris.">Data Access Using URIs</a>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F__GUID-5682D9D5-603D-4EC6-9030-AB6EC2E99703">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                        </li>
                        <li>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="There are several Oracle SQL functions and XMLType APIs for transforming XMLType data using XSLT stylesheets and for validating XMLType instances against an XML schema.">Transformation and Validation of XMLType Data</a></p>
                        </li>
                        <li>
                           <p><a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="There are several PL/SQL packages that provide APIs for XMLType.">PL/SQL APIs for XMLType</a></p>
                        </li>
                        <li>
                           <p><a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="The Java DOM API for XMLType lets you operate on XMLType instances using a DOM. You can use it to manipulate XML data in Java, including fetching it through Java Database Connectivity (JDBC).">Java DOM API for XMLType</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB1620"></a><div class="props_rev_3"><a id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" name="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967"></a><h3 id="ADXDB-GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" class="sect3"><span class="enumeration_section">8.2 </span>Generation of XML Data Using SQL Functions
               </h3>
               <div>
                  <p>Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.</p>
                  <p>The standard XML-generation functions are also known as SQL/XML <strong class="term">publishing</strong> or <strong class="term">generation</strong> functions. 
                  </p>
                  <p>The use of SQL/XML function <code class="codeph">XMLQuery</code> is not limited to generating (publishing) XML data. Function <code class="codeph">XMLQuery</code> is very general and is referred to in this book as a SQL/XML <strong class="term">query and update</strong> function.
                  </p>
                  <p>The following XML-generating SQL functions are Oracle-specific (not part of the SQL/XML standard):</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL function XMLColAttVal generates a forest of XML column elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions.">XMLCOLATTVAL Oracle SQL Function</a>.
                        </p>
                     </li>
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="You use Oracle SQL function XMLCDATA to generate an XML CDATA section.">XMLCDATA Oracle SQL Function</a>.
                        </p>
                     </li>
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL function sys_XMLAgg aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named ROWSET (by default).">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of relational rows, aggregating several XML documents into one.
                        </p>
                     </li>
                  </ul>
                  <p>All of the XML-generation SQL functions convert scalars and user-defined data-type instances to their canonical XML format. In this canonical mapping, user-defined data-type attributes are mapped to XML elements.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a><br>SQL/XML standard function <code class="codeph">XMLElement</code> constructs XML elements from relational data. SQL/XML standard function <code class="codeph">XMLAttributes</code> can be used together with <code class="codeph">XMLElement</code>, to specify attributes for the generated elements.
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB">XMLFOREST SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLForest</code> to construct a forest of XML elements. 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17">XMLCONCAT SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLConcat</code> to construct an XML fragment by concatenating multiple <code class="codeph">XMLType</code> instances. 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB">XMLAGG SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLAgg</code> to construct a forest of XML elements from a collection of XML elements — it is an aggregate function.
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C">XMLPI SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLPI</code> to construct an XML processing instruction (PI). 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915">XMLCOMMENT SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLComment</code> to construct an XML comment. 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8">XMLSERIALIZE SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLSerialize</code> to obtain a string or LOB representation of XML data. 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C">XMLPARSE SQL/XML Function</a><br>You use SQL/XML standard function <code class="codeph">XMLParse</code> to parse a string containing XML data and construct a corresponding <code class="codeph">XMLType</code> instance.
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F">XMLCOLATTVAL Oracle SQL Function</a><br>Oracle SQL function <code class="codeph">XMLColAttVal</code> generates a forest of XML <code class="codeph">column</code> elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions. 
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130">XMLCDATA Oracle SQL Function</a><br>You use Oracle SQL function <code class="codeph">XMLCDATA</code> to generate an XML <code class="codeph">CDATA</code> section. 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967__GUID-6F3CA72A-669C-4BEE-9B68-FC2E2EEC3032">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information about constructing XML data using SQL/XML function <code class="codeph">XMLQuery</code></p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/Oracle-Compliance-with-SQLXML2011.html#SQLRF55529" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about Oracle support for the SQL/XML standard
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4995"></a><a id="ADXDB4996"></a><a id="ADXDB4994"></a><div class="props_rev_3"><a id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77" name="GUID-868E591C-19A1-4E4A-BC2A-013181071B77"></a><h4 id="ADXDB-GUID-868E591C-19A1-4E4A-BC2A-013181071B77" class="sect4"><span class="enumeration_section">8.2.1 </span>XMLELEMENT and XMLATTRIBUTES SQL/XML Functions
                  </h4>
                  <div>
                     <p>SQL/XML standard function <code class="codeph">XMLElement</code> constructs XML elements from relational data. SQL/XML standard function <code class="codeph">XMLAttributes</code> can be used together with <code class="codeph">XMLElement</code>, to specify attributes for the generated elements.
                     </p>
                     <div class="section">
                        <p>SQL/XML standard function <code class="codeph">XMLElement</code> takes as arguments an XML element name, an optional collection of attributes for the element, and zero or more additional arguments that make up the element content. It returns an <code class="codeph">XMLType</code> instance. 
                        </p>
                        <div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">
                           <p class="titleinfigure">Figure 8-1 XMLELEMENT Syntax</p><img src="img/xmlelement.gif" width="502" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/xmlelement.html"><br><a href="img_text/xmlelement.html">Description of "Figure 8-1 XMLELEMENT Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>For an explanation of keywords <code class="codeph">ENTITYESCAPING</code> and <code class="codeph">NOENTITYESCAPING</code>, see <a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>. These keywords are Oracle extensions to standard SQL/XML functions <code class="codeph">XMLElement</code> and <code class="codeph">XMLAttributes</code>.
                        </p>
                        <p>The first argument to function <code class="codeph">XMLElement</code> defines an identifier that names the <span class="italic">root</span> XML element to be created. The root-element identifier argument can be defined using a literal identifier (<span class="italic"><code class="codeph">identifier</code></span>, in <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">Figure 8-1</a>) or by <code class="codeph">EVALNAME</code> followed by an expression (<span class="italic"><code class="codeph">value_expr</code></span>) that evaluates to an identifier. However it is defined, the identifier must not be <code class="codeph">NULL</code> or else an error is raised. The possibility of using <code class="codeph">EVALNAME</code> is an Oracle extension to standard SQL/XML function <code class="codeph">XMLElement</code>.
                        </p>
                        <p>The optional <span class="italic"><code class="codeph">XML-attributes-clause</code></span> argument of function <code class="codeph">XMLElement</code> specifies the attributes of the root element to be generated. <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">Figure 8-2</a> shows the syntax of this argument.
                        </p>
                        <p>In addition to the optional <span class="italic"><code class="codeph">XML-attributes-clause</code></span> argument, function <code class="codeph">XMLElement</code> accepts zero or more <span class="italic"><code class="codeph">value_expr</code></span> arguments that make up the <span class="italic">content</span> of the root element (child elements and text content). If an <span class="italic"><code class="codeph">XML-attributes-clause</code></span> argument is also present then these content arguments must follow the <span class="italic"><code class="codeph">XML-attributes-clause</code></span> argument. Each of the content-argument expressions is evaluated, and the result is converted to XML format. If a value argument evaluates to <code class="codeph">NULL</code>, then no content is created for that argument.
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-228026D6-5437-408D-98D4-2B68F90098BE">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">AS</code> preceding an alias (<span class="italic"><code class="codeph">c_alias</code></span>) is required by the SQL/XML standard, but is optional for Oracle.
                           </p>
                        </div>
                        <p>The optional <span class="italic"><code class="codeph">XML-attributes-clause</code></span> argument uses SQL/XML standard function <code class="codeph">XMLAttributes</code> to specify the <span class="italic">attributes</span> of the root element. Function <code class="codeph">XMLAttributes</code> can be used <span class="italic">only</span> in a call to function <code class="codeph">XMLElement</code>. It cannot be used on its own.
                        </p>
                        <div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">
                           <p class="titleinfigure">Figure 8-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)</p><img src="img/xml_attributes_clause.gif" width="369" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" longdesc="img_text/xml_attributes_clause.html"><br><a href="img_text/xml_attributes_clause.html">Description of "Figure 8-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)"</a></div>
                        <!-- class="figure" -->
                        <p>For an explanation of keywords <code class="codeph">ENTITYESCAPING</code> and <code class="codeph">NOENTITYESCAPING</code>, see <a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>. These keywords are Oracle extensions to standard SQL/XML functions <code class="codeph">XMLElement</code> and <code class="codeph">XMLAttributes</code>.
                        </p>
                        <p>Keywords <code class="codeph">SCHEMACHECK</code> and <code class="codeph">NOSCHEMACHECK</code> determine whether or not a run-time check is made of the generated attributes, to see if any of them specify a schema location that corresponds to an XML schema that is registered with Oracle XML&nbsp;DB, and, if so, to try to generate XML schema-based XML data accordingly. The default behavior is that provided by <code class="codeph">NOSCHEMACHECK</code>: no check is made. In releases prior to 12c Release 1 (12.1), the default behavior is to perform the check. Keyword <code class="codeph">SCHEMACHECK</code> can be used to obtain backward compatibility.
                        </p>
                        <p>A similar check is <span class="italic">always</span> made at <span class="italic">compile</span> time, regardless of the presence or absence of <code class="codeph">NOSCHEMACHECK</code>. This means, in particular, that if you use a string literal to specify an XML schema location attribute value, then a (compile-time) check is made, and, if appropriate, XML schema-based data is generated accordingly.
                        </p>
                        <p>Keywords <code class="codeph">SCHEMACHECK</code> and <code class="codeph">NOSCHEMACHECK</code> are Oracle extensions to standard SQL/XML function <code class="codeph">XMLAttributes</code>.
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-416A016B-0D0B-4BC7-8C0A-73286E22EC20">
                           <p class="notep1">Note:</p>
                           <p>If a view is created to generate XML data, function <code class="codeph">XMLAttributes</code> is used to add XML-schema location references, and the target XML schema has not yet been registered with Oracle XML&nbsp;DB, then the XML data that is generated is not XML schema-based. If the XML schema is subsequently registered, then XML data that is generated thereafter is also <span class="italic">not</span> XML-schema-based. To create XML schema-based data, you must recompile the view.
                           </p>
                        </div>
                        <p>Argument <span class="italic"><code class="codeph">XML-attributes-clause</code></span> itself contains one or more <span class="italic"><code class="codeph">value_expr</code></span> expressions as arguments to function <code class="codeph">XMLAttributes</code>. These are evaluated to obtain the values for the attributes of the root element. (Do not confuse these <span class="italic"><code class="codeph">value_expr</code></span> arguments to function <code class="codeph">XMLAttributes</code> with the <span class="italic"><code class="codeph">value_expr</code></span> arguments to function <code class="codeph">XMLElement</code>, which specify the content of the root element.) The optional <code class="codeph">AS</code> <span class="italic"><code class="codeph">c_alias</code></span> clause for each <span class="italic"><code class="codeph">value_expr</code></span> specifies that the attribute name is <span class="italic"><code class="codeph">c_alias</code></span>, which can be either a string literal or <code class="codeph">EVALNAME</code> followed by an expression that evaluates to a string literal.
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-87072A08-898A-4FD1-A257-7C67307B7786">
                           <p class="notep1">Note:</p>
                           <p>The following are Oracle extensions to the standard SQL/XML syntax:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The possibility of using <code class="codeph">EVALNAME</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The fact that <code class="codeph">AS</code> preceding an alias (<span class="italic"><code class="codeph">c_alias</code></span>) is optional.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>If an attribute value expression evaluates to <code class="codeph">NULL</code>, then no corresponding attribute is created. The data type of an attribute value expression cannot be an object type or a collection.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2">Escape of Characters in Generated XML Data</a><br>As specified by the SQL/XML standard, characters in explicit <span class="italic">identifiers</span> are <span class="italic">not</span> escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions. 
                        </li>
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-18DC2329-2C1D-4A23-9321-82519AAC4527">Formatting of XML Dates and Timestamps</a><br>The XML Schema standard specifies that dates and timestamps in XML data be in standard formats. XML generation functions in Oracle XML&nbsp;DB produce XML dates and timestamps according to this standard.
                        </li>
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774">XMLElement Examples</a><br>Examples here illustrate the use SQL/XML function <code class="codeph">XMLElement</code>.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4997"></a><div class="props_rev_3"><a id="GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" name="GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2"></a><h5 id="ADXDB-GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" class="sect5"><span class="enumeration_section">8.2.1.1 </span>Escape of Characters in Generated XML Data
                     </h5>
                     <div>
                        <p>As specified by the SQL/XML standard, characters in explicit <span class="italic">identifiers</span> are <span class="italic">not</span> escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions. 
                        </p>
                        <p>In particular, it applies to the root-element identifier of <code class="codeph">XMLElement</code> (<span class="italic"><code class="codeph">identifier</code></span>, in <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">Figure 8-1</a>) and to attribute identifier aliases named with <code class="codeph">AS</code> clauses of <code class="codeph">XMLAttributes</code> (see <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">Figure 8-2</a>). 
                        </p>
                        <p>However, other XML data that is generated is <span class="italic">escaped</span>, by default, to ensure that only valid XML <code class="codeph">NameChar</code> characters are generated. As part of generating a valid XML element or attribute name from a SQL identifier, each character that is disallowed in an XML name is replaced with an underscore character (<code class="codeph">_</code>), followed by the hexadecimal Unicode representation of the original character, followed by a second underscore character. For example, the colon character (<code class="codeph">:</code>) is escaped by replacing it with <code class="codeph">_003A_</code>, where 003A is the hexadecimal Unicode representation.
                        </p>
                        <p>Escaping applies to characters in the evaluated <span class="italic"><code class="codeph">value_expr</code></span> arguments to <span class="italic">all</span> SQL/XML functions, including <code class="codeph">XMLElement</code> and <code class="codeph">XMLAttributes</code>. It applies also to the characters of an attribute identifier that is defined implicitly from an <code class="codeph">XMLAttributes</code> attribute value expression that is <span class="italic">not</span> followed by an <code class="codeph">AS</code> clause: the escaped form of the SQL column name is used as the name of the attribute.
                        </p>
                        <p>In some cases, you might not need or want character escaping. If you know, for example, that the XML data being generated is well-formed, then you can save some processing time by inhibiting escaping. You can do that by specifying the keyword <code class="codeph">NOENTITYESCAPING</code> for SQL/XML functions <code class="codeph">XMLElement</code> and <code class="codeph">XMLAttributes</code>. Keyword <code class="codeph">ENTITYESCAPING</code> imposes escaping, which is the default behavior. Keywords <code class="codeph">NOENTITYESCAPING</code> and <code class="codeph">ENTITYESCAPING</code> are Oracle extensions to standard SQL/XML functions <code class="codeph">XMLElement</code> and <code class="codeph">XMLAttributes</code>.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL/XML standard function XMLElement constructs XML elements from relational data. SQL/XML standard function XMLAttributes can be used together with XMLElement, to specify attributes for the generated elements.">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4998"></a><div class="props_rev_3"><a id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527" name="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527"></a><h5 id="ADXDB-GUID-18DC2329-2C1D-4A23-9321-82519AAC4527" class="sect5"><span class="enumeration_section">8.2.1.2 </span>Formatting of XML Dates and Timestamps
                     </h5>
                     <div>
                        <p>The XML Schema standard specifies that dates and timestamps in XML data be in standard formats. XML generation functions in Oracle XML&nbsp;DB produce XML dates and timestamps according to this standard.</p>
                        <p>In releases prior to Oracle Database&nbsp;10g Release 2, the database settings for date and timestamp formats, not the XML Schema standard formats, were used for XML. You can reproduce this <span class="italic">previous</span> behavior by setting the database event 19119, level 0x8, as follows:
                        </p><pre class="pre codeblock"><code>ALTER SESSION SET EVENTS '19119 TRACE NAME CONTEXT FOREVER, LEVEL 0x8';
</code></pre><p>If you must otherwise produce a non-standard XML date or timestamp, use SQL function <code class="codeph">to_char</code> &#x2013; see <a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">Example 8-1</a>.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527__GUID-ADBDB093-4AF5-4520-BCCA-40E86EFABD61">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_xschema_isoformats" target="_blank">XML Schema Part 2: Datatypes, D. ISO 8601 Date and Time Formats</a> for the XML Schema specification of XML date and timestamp formats
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL/XML standard function XMLElement constructs XML elements from relational data. SQL/XML standard function XMLAttributes can be used together with XMLElement, to specify attributes for the generated elements.">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5000"></a><a id="ADXDB5001"></a><a id="ADXDB5002"></a><a id="ADXDB5003"></a><a id="ADXDB5895"></a><a id="ADXDB5004"></a><a id="ADXDB5005"></a><a id="ADXDB4999"></a><div class="props_rev_3"><a id="GUID-49E8774C-E240-47BA-966B-60B28DD50774" name="GUID-49E8774C-E240-47BA-966B-60B28DD50774"></a><h5 id="ADXDB-GUID-49E8774C-E240-47BA-966B-60B28DD50774" class="sect5"><span class="enumeration_section">8.2.1.3 </span>XMLElement Examples
                     </h5>
                     <div>
                        <p>Examples here illustrate the use SQL/XML function <code class="codeph">XMLElement</code>.
                        </p>
                        <div class="section">
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">Example 8-1</a> uses <code class="codeph">XMLElement</code> to generate an XML date with a format that is different from the XML Schema standard date format.
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">Example 8-2</a> uses <code class="codeph">XMLElement</code> to generate an <code class="codeph">Emp</code> element for each employee, with the employee name as the content.
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">Example 8-3</a> uses <code class="codeph">XMLElement</code> to generate an <code class="codeph">Emp</code> element for each employee, with child elements that provide the employee name and hire date.
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">Example 8-4</a> uses <code class="codeph">XMLElement</code> to generate an <code class="codeph">Emp</code> element for each employee, with attributes <code class="codeph">id</code> and <code class="codeph">name</code>.
                           </p>
                           <p>As mentioned in <a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>, characters in the root-element name and the names of any attributes defined by <code class="codeph">AS</code> clauses are <span class="italic">not</span> escaped. Characters in an identifier name are escaped only if the name is created from an evaluated expression (such as a column reference). 
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">Example 8-5</a> shows that, with XML data constructed using <code class="codeph">XMLElement</code>, the root-element name and the attribute name are <span class="italic">not</span> escaped. Invalid XML is produced because greater-than sign (<code class="codeph">&gt;</code>) and a comma (<code class="codeph">,</code>) are not allowed in XML element and attribute names.
                           </p>
                           <p>A full description of character escaping is included in the SQL/XML standard.</p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">Example 8-6</a> illustrates the use of namespaces to create an XML schema-based document. Assuming that an XML schema "<code class="codeph">http://www.oracle.com/Employee.xsd</code>" exists and has no target namespace, the query in <a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">Example 8-6</a> creates an <code class="codeph">XMLType</code> instance conforming to that schema:
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">Example 8-7</a> uses <code class="codeph">XMLElement</code> to generate an XML document with employee and department information, using data from sample database schema table <code class="codeph">hr.departments</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">
                           <p class="titleinexample">Example 8-1 XMLELEMENT: Formatting a Date</p><pre class="oac_no_warn" dir="ltr">-- With standard XML date format:
SELECT XMLElement("Date", hire_date)
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT("DATE",HIRE_DATE)
----------------------------
&lt;Date&gt;2002-06-07&lt;/Date&gt;
 
1 row selected.
 
-- With an alternative date format:
SELECT XMLElement("Date", <span class="bold">to_char</span>(hire_date))
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT("DATE",TO_CHAR(HIRE_DATE))
-------------------------------------
&lt;Date&gt;<span class="bold">07-JUN-02</span>&lt;/Date&gt;
 
1 row selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">
                           <p class="titleinexample">Example 8-2 XMLELEMENT: Generating an Element for Each Employee</p><pre class="oac_no_warn" dir="ltr">SELECT e.employee_id, 
       XMLELEMENT ("Emp", e.first_name ||' '|| e.last_name) AS "RESULT"
   FROM hr.employees e
   WHERE employee_id &gt; 200;
</pre><p>This query produces the following typical result:</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID RESULT
----------- -----------------------------------
        201 &lt;Emp&gt;Michael Hartstein&lt;/Emp&gt;
        202 &lt;Emp&gt;Pat Fay&lt;/Emp&gt;
        203 &lt;Emp&gt;Susan Mavris&lt;/Emp&gt;
        204 &lt;Emp&gt;Hermann Baer&lt;/Emp&gt;
        205 &lt;Emp&gt;Shelley Higgins&lt;/Emp&gt;
        206 &lt;Emp&gt;William Gietz&lt;/Emp&gt;
 
6 rows selected.
</pre><p>SQL/XML function <code class="codeph">XMLElement</code> can also be nested, to produce XML data with a nested structure.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">
                           <p class="titleinexample">Example 8-3 XMLELEMENT: Generating Nested XML </p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Emp", 
                   XMLElement("name", e.first_name ||' '|| e.last_name),
                   XMLElement("hiredate", e.hire_date)) AS "RESULT" 
FROM hr.employees e 
WHERE employee_id &gt; 200;
</pre><p>This query produces the following typical XML result:</p><pre class="oac_no_warn" dir="ltr">RESULT
-----------------------------------------------------------------------
&lt;Emp&gt;&lt;name&gt;Michael Hartstein&lt;/name&gt;&lt;hiredate&gt;2004-02-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Pat Fay&lt;/name&gt;&lt;hiredate&gt;2005-08-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Susan Mavris&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Hermann Baer&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Shelley Higgins&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;William Gietz&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">
                           <p class="titleinexample">Example 8-4 XMLELEMENT: Generating Employee Elements with Attributes ID and Name</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Emp", XMLAttributes(
                           e.employee_id as "ID",
                           e.first_name ||' ' || e.last_name AS "name"))
  AS "RESULT"
  FROM hr.employees e
  WHERE employee_id &gt; 200;
</pre><p>This query produces the following typical XML result fragment:</p><pre class="oac_no_warn" dir="ltr">RESULT
-----------------------------------------------
&lt;Emp ID="201" name="Michael Hartstein"&gt;&lt;/Emp&gt;
&lt;Emp ID="202" name="Pat Fay"&gt;&lt;/Emp&gt;
&lt;Emp ID="203" name="Susan Mavris"&gt;&lt;/Emp&gt;
&lt;Emp ID="204" name="Hermann Baer"&gt;&lt;/Emp&gt;
&lt;Emp ID="205" name="Shelley Higgins"&gt;&lt;/Emp&gt;
&lt;Emp ID="206" name="William Gietz"&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">
                           <p class="titleinexample">Example 8-5 XMLELEMENT: Characters in Generated XML Data Are Not Escaped</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Emp-<span class="bold">&gt;</span>Special", 
                  XMLAttributes(e.last_name || ', ' || e.first_name
                                AS "Last<span class="bold">,</span>First"))
   AS "RESULT"
   FROM hr.employees e
   WHERE employee_id = 201;
</pre><p>This query produces the following result, which is <span class="italic">not</span> well-formed XML:
                           </p><pre class="oac_no_warn" dir="ltr">RESULT
--------------------------------------------------------------------
&lt;Emp-<span class="bold">&gt;</span>Special Last<span class="bold">,</span>First="Hartstein, Michael"&gt;&lt;/Emp-<span class="bold">&gt;</span>Special&gt;

1 row selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">
                           <p class="titleinexample">Example 8-6 Creating a Schema-Based XML Document Using XMLELEMENT with Namespaces</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Employee", 
                  XMLAttributes('http://www.w3.org/2001/XMLSchema' AS
                                  "xmlns:xsi",
                                'http://www.oracle.com/Employee.xsd' AS
                                  "xsi:nonamespaceSchemaLocation"),
                  XMLForest(employee_id, last_name, salary)) AS "RESULT"
   FROM hr.employees
   WHERE department_id = 10;
</pre><p>This creates the following XML document that conforms to XML schema <code class="codeph">Employee.xsd</code>. (The result is shown here pretty-printed, for clarity.)
                           </p><pre class="oac_no_warn" dir="ltr">RESULT
-----------------------------------------------------------------------------
&lt;Employee xmlns:xsi="http://www.w3.org/2001/XMLSchema"
          xsi:nonamespaceSchemaLocation="http://www.oracle.com/Employee.xsd"&gt;
   &lt;EMPLOYEE_ID&gt;200&lt;/EMPLOYEE_ID&gt;
   &lt;LAST_NAME&gt;Whalen&lt;/LAST_NAME&gt;
   &lt;SALARY&gt;4400&lt;/SALARY&gt;
&lt;/Employee&gt;

1 row selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">
                           <p class="titleinexample">Example 8-7 XMLELEMENT: Generating an Element from a User-Defined Data-Type Instance</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE emp_t AS OBJECT ("@EMPNO" NUMBER(4),
                                         ENAME VARCHAR2(10));

CREATE OR REPLACE TYPE emplist_t AS TABLE OF emp_t;

CREATE OR REPLACE TYPE dept_t AS OBJECT ("@DEPTNO" NUMBER(2),
                                         DNAME VARCHAR2(14),
                                         EMP_LIST emplist_t);

SELECT XMLElement("Department",
                  dept_t(department_id,
                         department_name,
                         cast(MULTISET
                              (SELECT employee_id, last_name
                                 FROM hr.employees e
                                 WHERE e.department_id = d.department_id)
                              AS emplist_t)))
  AS deptxml
  FROM hr.departments d
  WHERE d.department_id = 10;
</pre><p>This produces an XML document which contains the <code class="codeph">Department</code> element and the canonical mapping of type <code class="codeph">dept_t</code>.
                           </p><pre class="oac_no_warn" dir="ltr">DEPTXML
-------------
&lt;Department&gt;
  &lt;DEPT_T DEPTNO="10"&gt;
    &lt;DNAME&gt;ACCOUNTING&lt;/DNAME&gt;
    &lt;EMPLIST&gt;
      &lt;EMP_T EMPNO="7782"&gt;
        &lt;ENAME&gt;CLARK&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO="7839"&gt;
        &lt;ENAME&gt;KING&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO="7934"&gt;
        &lt;ENAME&gt;MILLER&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMPLIST&gt;
  &lt;/DEPT_T&gt;
&lt;/Department&gt;

1 row selected.</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL/XML standard function XMLElement constructs XML elements from relational data. SQL/XML standard function XMLAttributes can be used together with XMLElement, to specify attributes for the generated elements.">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB5007"></a><a id="ADXDB5008"></a><a id="ADXDB5009"></a><a id="ADXDB5006"></a><div class="props_rev_3"><a id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" name="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB"></a><h4 id="ADXDB-GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" class="sect4"><span class="enumeration_section">8.2.2 </span>XMLFOREST SQL/XML Function 
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLForest</code> to construct a forest of XML elements. 
                     </p>
                     <div class="section">
                        <p>Its arguments are expressions to be evaluated, with optional aliases. <a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">Figure 8-3</a> describes the <code class="codeph">XMLForest</code> syntax.
                        </p>
                        <div class="figure" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">
                           <p class="titleinfigure">Figure 8-3 XMLFOREST Syntax</p><img src="img/xmlforest.gif" width="444" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" longdesc="img_text/xmlforest.html"><br><a href="img_text/xmlforest.html">Description of "Figure 8-3 XMLFOREST Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Each of the value expressions (<span class="italic"><code class="codeph">value_expr</code></span> in <a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">Figure 8-3</a>) is converted to XML format, and, optionally, identifier <span class="italic"><code class="codeph">c_alias</code></span> is used as the attribute identifier (<span class="italic"><code class="codeph">c_alias</code></span> can be a string literal or <code class="codeph">EVALNAME</code> followed by an expression that evaluates to a string literal). The possibility of using <code class="codeph">EVALNAME</code> is an Oracle extension to standard SQL/XML function <code class="codeph">XMLForest</code>.
                        </p>
                        <p>For an object type or collection, the <code class="codeph">AS</code> clause is required. For other types, the <code class="codeph">AS</code> clause is optional. For a given expression, if the <code class="codeph">AS</code> clause is omitted, then characters in the evaluated value expression are <span class="italic">escaped</span> to form the name of the enclosing tag of the element. The escaping is as defined in <a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &#x2013; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>. If the value expression evaluates to <code class="codeph">NULL</code>, then no element is created for that expression.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">Example 8-8</a> uses <code class="codeph">XMLElement</code> and <code class="codeph">XMLForest</code> to generate an <code class="codeph">Emp</code> element for each employee, with a <code class="codeph">name</code> attribute and with child elements containing the employee hire date and department as the content.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">
                        <p class="titleinexample">Example 8-8 XMLFOREST: Generating Elements with Attribute and Child Elements</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Emp", 
                  XMLAttributes(e.first_name ||' '|| e.last_name AS "name"),
                  XMLForest(e.hire_date, e.department AS "department"))
AS "RESULT"
FROM employees e WHERE e.department_id = 20;
</pre><p>(The <code class="codeph">WHERE</code> clause is used here to keep the example brief.) This query produces the following XML result:
                        </p><pre class="oac_no_warn" dir="ltr">RESULT
-------------------------------------
&lt;Emp name="Michael Hartstein"&gt;
  &lt;HIRE_DATE&gt;2004-02-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;
&lt;Emp name="Pat Fay"&gt;
  &lt;HIRE_DATE&gt;2005-08-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;

2 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__GUID-6B7023B4-A0A7-4D43-AA24-92C36CEC1EB1">
                           <p class="notep1">See Also:</p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">Example 8-19</a></p>
                        </div>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">Example 8-9</a> uses <code class="codeph">XMLForest</code> to generate hierarchical XML data from user-defined data-type instances.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">
                        <p class="titleinexample">Example 8-9 XMLFOREST: Generating an Element from a User-Defined Data-Type Instance</p><pre class="oac_no_warn" dir="ltr">SELECT XMLForest(
  dept_t(department_id,
         department_name,
         cast(MULTISET
              (SELECT employee_id, last_name
                 FROM hr.employees e WHERE e.department_id = d.department_id)
              AS emplist_t))
         AS "Department")
  AS deptxml
  FROM hr.departments d
  WHERE department_id=10;
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>This produces an XML document with element <code class="codeph">Department</code> containing attribute <code class="codeph">DEPTNO</code> and child element <code class="codeph">DNAME</code>. 
                        </p><pre class="oac_no_warn" dir="ltr">DEPTXML
---------------------------------
&lt;Department DEPTNO="10"&gt;
  &lt;DNAME&gt;Administration&lt;/DNAME&gt;
    &lt;EMP_LIST&gt;
      &lt;EMP_T EMPNO="200"&gt;
        &lt;ENAME&gt;Whalen&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMP_LIST&gt;
&lt;/Department&gt;

1 row selected.
</pre><p>You might want to compare this example with <a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">Example 8-7</a> and <a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">Example 8-24</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5017"></a><a id="ADXDB5018"></a><a id="ADXDB5019"></a><a id="ADXDB5016"></a><div class="props_rev_3"><a id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" name="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17"></a><h4 id="ADXDB-GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" class="sect4"><span class="enumeration_section">8.2.3 </span>XMLCONCAT SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLConcat</code> to construct an XML fragment by concatenating multiple <code class="codeph">XMLType</code> instances. 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__I1032783">Figure 8-4</a> shows the <code class="codeph">XMLConcat</code> syntax. Function <code class="codeph">XMLConcat</code> has two forms:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The first form takes as argument an <code class="codeph">XMLSequenceType</code> value, which is a varray of <code class="codeph">XMLType</code> instances, and returns a single <code class="codeph">XMLType</code> instance that is the concatenation of all of the elements of the varray. This form is useful to collapse lists of <code class="codeph">XMLType</code> instances into a single instance.
                              </p>
                           </li>
                           <li>
                              <p>The second form takes an arbitrary number of <code class="codeph">XMLType</code> instances and concatenates them together. If one of the values is <code class="codeph">NULL</code>, then it is ignored in the result. If all the values are <code class="codeph">NULL</code>, then the result is <code class="codeph">NULL</code>. This form is used to concatenate arbitrary number of <code class="codeph">XMLType</code> instances in the same row. Function <code class="codeph">XMLAgg</code> can be used to concatenate <code class="codeph">XMLType</code> instances across rows.
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__I1032783">
                           <p class="titleinfigure">Figure 8-4 XMLCONCAT Syntax</p><img src="img/xmlconcat.gif" width="256" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows" longdesc="img_text/xmlconcat.html"><br><a href="img_text/xmlconcat.html">Description of "Figure 8-4 XMLCONCAT Syntax"</a></div>
                        <!-- class="figure" -->
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">Example 8-10</a> uses SQL/XML function <code class="codeph">XMLConcat</code> to return a concatenation of <code class="codeph">XMLType</code> instances from an <code class="codeph">XMLSequenceType</code> value (a varray of <code class="codeph">XMLType</code> instances). 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">
                        <p class="titleinexample">Example 8-10 XMLCONCAT: Concatenating XMLType Instances from a Sequence</p><pre class="oac_no_warn" dir="ltr">SELECT XMLSerialize(
         CONTENT
         XMLConcat(XMLSequenceType(
                   XMLType('&lt;PartNo&gt;1236&lt;/PartNo&gt;'),
                   XMLType('&lt;PartName&gt;Widget&lt;/PartName&gt;'),
                   XMLType('&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;')))
         AS CLOB)
  AS "RESULT"
  FROM DUAL;
</pre><p>This query returns a single XML fragment. (The result is shown here pretty-printed, for clarity.)</p><pre class="oac_no_warn" dir="ltr">RESULT
---------------
&lt;PartNo&gt;1236&lt;/PartNo&gt;
&lt;PartName&gt;Widget&lt;/PartName&gt;
&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;

1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">Example 8-11</a> uses <code class="codeph">XMLConcat</code> to create and concatenate XML elements for employee first and the last names.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">
                        <p class="titleinexample">Example 8-11 XMLCONCAT: Concatenating XML Elements </p><pre class="oac_no_warn" dir="ltr">SELECT XMLConcat(XMLElement("first", e.first_name), 
                 XMLElement("last", e.last_name))
  AS "RESULT"
  FROM employees e;
</pre><p>This query produces the following XML fragment:</p><pre class="oac_no_warn" dir="ltr">RESULT
--------------------------------------------
&lt;first&gt;Den&lt;/first&gt;&lt;last&gt;Raphaely&lt;/last&gt;
&lt;first&gt;Alexander&lt;/first&gt;&lt;last&gt;Khoo&lt;/last&gt;
&lt;first&gt;Shelli&lt;/first&gt;&lt;last&gt;Baida&lt;/last&gt;
&lt;first&gt;Sigal&lt;/first&gt;&lt;last&gt;Tobias&lt;/last&gt;
&lt;first&gt;Guy&lt;/first&gt;&lt;last&gt;Himuro&lt;/last&gt;
&lt;first&gt;Karen&lt;/first&gt;&lt;last&gt;Colmenares&lt;/last&gt;
 
6 rows selected.</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5021"></a><a id="ADXDB5022"></a><a id="ADXDB5896"></a><a id="ADXDB5023"></a><a id="ADXDB5020"></a><div class="props_rev_3"><a id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" name="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB"></a><h4 id="ADXDB-GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" class="sect4"><span class="enumeration_section">8.2.4 </span>XMLAGG SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLAgg</code> to construct a forest of XML elements from a collection of XML elements — it is an aggregate function.
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__I1032735">Figure 8-5</a> describes the <code class="codeph">XMLAgg</code> syntax.
                        </p>
                        <div class="figure" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__I1032735">
                           <p class="titleinfigure">Figure 8-5 XMLAGG Syntax</p><img src="img/xmlagg.gif" width="335" alt="Description of Figure 8-5 follows" title="Description of Figure 8-5 follows" longdesc="img_text/xmlagg.html"><br><a href="img_text/xmlagg.html">Description of "Figure 8-5 XMLAGG Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>The <code class="codeph">order_by_clause</code> is the following:
                        </p><pre class="oac_no_warn" dir="ltr">ORDER BY [list of: expr [ASC|DESC] [NULLS {FIRST|LAST}]]
</pre><p>Numeric literals are <span class="italic">not</span> interpreted as column positions. For example, <code class="codeph">ORDER BY 1</code> does not mean order by the first column. Instead, numeric literals are interpreted as any other literals.
                        </p>
                        <p>As with SQL/XML function <code class="codeph">XMLConcat</code>, any arguments whose value is <code class="codeph">NULL</code> are dropped from the result. SQL/XML function <code class="codeph">XMLAgg</code> is similar to Oracle SQL function <code class="codeph">sys_XMLAgg</code>, but <code class="codeph">XMLAgg</code> returns a forest of nodes and it does not accept an <code class="codeph">XMLFormat</code> parameter. 
                        </p>
                        <p>SQL/XML function <code class="codeph">XMLAgg</code> can be used to concatenate <code class="codeph">XMLType</code> instances across <span class="italic">multiple rows</span>. It also accepts an optional<code class="codeph"> ORDER BY</code> clause, to order the XML values being aggregated. Function <code class="codeph">XMLAgg</code> produces one aggregated XML result for each group. If there is no group by specified in the query, then it returns a single aggregated XML result for all the rows of the query. 
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">Example 8-12</a> uses SQL/XML functions <code class="codeph">XMLAgg</code> and <code class="codeph">XMLElement</code> to construct a <code class="codeph">Department</code> element that contains <code class="codeph">Employee</code> elements that have employee job ID and last name as their contents. It also orders the <code class="codeph">Employee</code> elements in the department by employee last name. (The result is shown pretty-printed, for clarity.)
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">
                        <p class="titleinexample">Example 8-12 XMLAGG: Generating a Department Element with Child Employee Elements</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Department", XMLAgg(XMLElement("Employee",
                                                  e.job_id||' '||e.last_name)
                                       ORDER BY e.last_name))
  AS "Dept_list"     
  FROM hr.employees e
  WHERE e.department_id = 30 OR e.department_id = 40;

Dept_list
------------------
&lt;Department&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">1</span> row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>The result is a <span class="italic">single</span> row, because <code class="codeph">XMLAgg</code> aggregates the employee rows.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">Example 8-13</a> shows how to use the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause to group the returned set of rows into multiple groups, forming multiple <code class="codeph">Department</code> elements. (The result is shown here pretty-printed, for clarity.) 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">
                        <p class="titleinexample">Example 8-13 XMLAGG: Using GROUP BY to Generate Multiple Department Elements</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Department", XMLAttributes(department_id AS "deptno"), 
                  XMLAgg(XMLElement("Employee", e.job_id||' '||e.last_name)))
   AS "Dept_list"
   FROM hr.employees e
   <span class="bold">GROUP BY e.department_id;</span>

Dept_list
------------------
&lt;Department deptno="<span class="bold">30</span>"&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;&lt;/Department&gt;

&lt;Department deptno="<span class="bold">40</span>"&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">2</span> rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>You can order the employees within each department by using the <code class="codeph">ORDER BY</code> clause inside the <code class="codeph">XMLAgg</code> expression.
                        </p>
                        <div class="infoboxnote" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__GUID-1591AAE9-4479-4F45-906D-B1E9A732D6CF">
                           <p class="notep1">Note:</p>
                           <p>Within the <code class="codeph">ORDER BY</code> clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause.
                           </p>
                        </div>
                        <p>Function <code class="codeph">XMLAgg</code> can be used to reflect the hierarchical nature of some relationships that exist in tables. <a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">Example 8-14</a> generates a department element for department 30. Within this element is a child element <code class="codeph">emp</code> for each employee of the department. Within each employee element is a <code class="codeph">dependent</code> element for each dependent of that employee.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">
                        <p class="titleinexample">Example 8-14 XMLAGG: Generating Nested Elements</p><pre class="oac_no_warn" dir="ltr">SELECT last_name, employee_id FROM employees WHERE department_id = 30;
 
LAST_NAME                 EMPLOYEE_ID
------------------------- -----------
Raphaely                          114
Khoo                              115
Baida                             116
Tobias                            117
Himuro                            118
Colmenares                        119
 
6 rows selected.
 </pre><p>A <code class="codeph">dependents</code> table holds the dependents of each employee.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.dependents (id NUMBER(4) PRIMARY KEY,
                            employee_id NUMBER(4),
                            name VARCHAR2(10));
Table created.
INSERT INTO dependents VALUES (1, 114, 'MARK');
1 row created.
INSERT INTO dependents VALUES (2, 114, 'JACK');
1 row created.
INSERT INTO dependents VALUES (3, 115, 'JANE');
1 row created.
INSERT INTO dependents VALUES (4, 116, 'HELEN');
1 row created.
INSERT INTO dependents VALUES (5, 116, 'FRANK');
1 row created.
COMMIT;
Commit complete.
 </pre><p>The following query generates the XML data for a department that contains the information about dependents. (The result is shown here pretty-printed, for clarity.)</p><pre class="oac_no_warn" dir="ltr">SELECT
  XMLElement(
    "Department",
    XMLAttributes(d.department_name AS "name"),
    (SELECT
       XMLAgg(XMLElement("emp",
                         XMLAttributes(e.last_name AS name),
                         (SELECT XMLAgg(XMLElement("dependent",
                                        XMLAttributes(de.name AS "name")))
                            FROM dependents de
                            WHERE de.employee_id = e.employee_id)))
       FROM employees e
       WHERE e.department_id = d.department_id)) AS "dept_list"
  FROM departments d
  WHERE department_id = 30;
 
dept_list
--------------------------------------------------------------------------------
&lt;Department name="Purchasing"&gt;
  &lt;emp NAME="Raphaely"&gt;
    &lt;dependent name="MARK"&gt;&lt;/dependent&gt;
    &lt;dependent name="JACK"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME="Khoo"&gt;
    &lt;dependent name="JANE"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;
  &lt;emp NAME="Baida"&gt;
    &lt;dependent name="HELEN"&gt;&lt;/dependent&gt;
    &lt;dependent name="FRANK"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME="Tobias"&gt;&lt;/emp&gt;
  &lt;emp NAME="Himuro"&gt;&lt;/emp&gt;
  &lt;emp NAME="Colmenares"&gt;&lt;/emp&gt;
&lt;/Department&gt;
 
1 row selected.</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5025"></a><a id="ADXDB5026"></a><a id="ADXDB5024"></a><div class="props_rev_3"><a id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" name="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C"></a><h4 id="ADXDB-GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" class="sect4"><span class="enumeration_section">8.2.5 </span>XMLPI SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLPI</code> to construct an XML processing instruction (PI). 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">Figure 8-6</a> shows the syntax:
                        </p>
                        <div class="figure" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">
                           <p class="titleinfigure">Figure 8-6 XMLPI Syntax</p><img src="img/xmlpi.gif" width="388" alt="Description of Figure 8-6 follows" title="Description of Figure 8-6 follows" longdesc="img_text/xmlpi.html"><br><a href="img_text/xmlpi.html">Description of "Figure 8-6 XMLPI Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Argument <span class="italic"><code class="codeph">value_expr</code></span> is evaluated, and the string result is appended to the optional identifier (<span class="italic"><code class="codeph">identifier</code></span>), separated by a space. This concatenation is then enclosed between <code class="codeph">"&lt;?"</code> and <code class="codeph">"?&gt;</code>" to create the processing instruction. That is, if <span class="italic"><code class="codeph">string-result</code></span> is the result of evaluating <span class="italic"><code class="codeph">value_expr</code></span>, then the generated processing instruction is <code class="codeph">&lt;?</code><span class="italic"><code class="codeph">identifier</code></span><span class="italic"><code class="codeph"> string-result?&gt;</code></span>. If <span class="italic"><code class="codeph">string-result</code></span> is the empty string, <code class="codeph">''</code>, then the function returns <code class="codeph">&lt;?</code><span class="italic"><code class="codeph">identifier</code></span><span class="italic"><code class="codeph">?&gt;</code></span>.
                        </p>
                        <p>As an alternative to using keyword <code class="codeph">NAME</code> followed by a <span class="italic">literal</span> string <span class="italic"><code class="codeph">identifier</code></span>, you can use keyword <code class="codeph">EVALNAME</code> followed by an expression that evaluates to a string to be used as the identifier. The possibility of using <code class="codeph">EVALNAME</code> is an Oracle extension to standard SQL/XML function <code class="codeph">XMLPI</code>.
                        </p>
                        <p>An error is raised if the constructed XML is not a legal XML processing instruction. In particular:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">identifier</code></span> must <span class="italic">not</span> be the word "<code class="codeph">xml</code>" (uppercase, lowercase, or mixed case).
                              </p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">string-result</code></span> must <span class="italic">not</span> contain the character sequence "<code class="codeph">?&gt;</code>".
                              </p>
                           </li>
                        </ul>
                        <p>Function <code class="codeph">XMLPI</code> returns an instance of <code class="codeph">XMLType</code>. If <span class="italic"><code class="codeph">string-result</code></span> is <code class="codeph">NULL</code>, then it returns <code class="codeph">NULL</code>.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">Example 8-15</a> uses <code class="codeph">XMLPI</code> to generate a simple processing instruction.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">
                        <p class="titleinexample">Example 8-15 Using SQL/XML Function XMLPI</p><pre class="pre codeblock"><code>SELECT XMLPI(NAME "OrderAnalysisComp", 'imported, reconfigured, disassembled')
  AS pi FROM DUAL; 
</code></pre><p>This results in the following output:</p><pre class="pre codeblock"><code>PI
----------------------------------------------------------
&lt;?OrderAnalysisComp imported, reconfigured, disassembled?&gt;

1 row selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5028"></a><a id="ADXDB5029"></a><a id="ADXDB5027"></a><div class="props_rev_3"><a id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" name="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915"></a><h4 id="ADXDB-GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" class="sect4"><span class="enumeration_section">8.2.6 </span>XMLCOMMENT SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLComment</code> to construct an XML comment. 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">Figure 8-7</a> shows the syntax:
                        </p>
                        <div class="figure" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">
                           <p class="titleinfigure">Figure 8-7 XMLComment Syntax</p><img src="img/xmlcomment.gif" width="208" alt="Description of Figure 8-7 follows" title="Description of Figure 8-7 follows" longdesc="img_text/xmlcomment.html"><br><a href="img_text/xmlcomment.html">Description of "Figure 8-7 XMLComment Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Argument <span class="italic"><code class="codeph">value_expr</code></span> is evaluated to a string, and the result is used as the body of the generated XML comment. The result is thus <code class="codeph">&lt;!--</code><span class="italic"><code class="codeph">string-result</code></span><code class="codeph">--&gt;</code>, where <span class="italic"><code class="codeph">string-result</code></span> is the string result of evaluating <span class="italic"><code class="codeph">value_expr</code></span>. If<span class="italic"><code class="codeph"> string-result</code></span> is the empty string, then the comment is empty: <code class="codeph">&lt;!----&gt;</code>.
                        </p>
                        <p>An error is raised if the constructed XML is not a legal XML comment. In particular,<span class="italic"><code class="codeph"> string-result</code></span> must <span class="italic">not</span> contain two consecutive hyphens (<code class="codeph">-</code>): "<code class="codeph">--</code>".
                        </p>
                        <p>Function <code class="codeph">XMLComment</code> returns an instance of <code class="codeph">XMLType</code>. If <span class="italic"><code class="codeph">string-result</code></span> is <code class="codeph">NULL</code>, then the function returns <code class="codeph">NULL</code>. 
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">Example 8-16</a> uses <code class="codeph">XMLComment</code> to generate a simple XML comment.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">
                        <p class="titleinexample">Example 8-16 Using SQL/XML Function XMLCOMMENT</p><pre class="pre codeblock"><code>SELECT XMLComment('This is a comment') AS cmnt FROM DUAL; 
</code></pre><p>This query results in the following output:</p><pre class="pre codeblock"><code>CMNT
--------------------------
&lt;!--This is a comment--&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5034"></a><a id="ADXDB5035"></a><a id="ADXDB5033"></a><div class="props_rev_3"><a id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" name="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8"></a><h4 id="ADXDB-GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" class="sect4"><span class="enumeration_section">8.2.7 </span>XMLSERIALIZE SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLSerialize</code> to obtain a string or LOB representation of XML data. 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">Figure 8-8</a> shows the syntax of <code class="codeph">XMLSerialize</code>:
                        </p>
                        <div class="figure" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">
                           <p class="titleinfigure">Figure 8-8 XMLSerialize Syntax</p><img src="img/xmlserialize.gif" width="474" alt="Description of Figure 8-8 follows" title="Description of Figure 8-8 follows" longdesc="img_text/xmlserialize.html"><br><a href="img_text/xmlserialize.html">Description of "Figure 8-8 XMLSerialize Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Argument <span class="italic"><code class="codeph">value_expr</code></span> is evaluated, and the resulting <code class="codeph">XMLType</code> instance is serialized to produce the content of the created string or LOB. If present<a id="fn_1" name="fn_1" href="#fn_1" onclick="footdisplay(1, "The SQL/XML standard requires argument data-type to be present, but it is optional in the Oracle XML&nbsp;DB implementation of the standard, for ease of use.")"><sup>Foot&nbsp;1</sup></a>, the specified <span class="italic"><code class="codeph">datatype</code></span> must be one of the following (the default data type is <code class="codeph">CLOB</code>):
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">VARCHAR2(</code><span class="italic"><code class="codeph">N</code></span><code class="codeph">)</code>, where <span class="italic"><code class="codeph">N</code></span> is the size in bytes<a id="fn_2" name="fn_2" href="#fn_2" onclick="footdisplay(2, "The limit is 32767 or 4000 bytes, depending on the value of initialization parameter MAX_STRING_SIZE.  See Oracle Database PL/SQL Packages and Types Reference.")"><sup>Foot&nbsp;2</sup></a></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                        </ul>
                        <p>If you specify <code class="codeph">DOCUMENT</code>, then the result of evaluating <span class="italic"><code class="codeph">value_expr</code></span> must be a well-formed document. In particular, it must have a single root. If the result is not a well-formed document, then an error is raised. If you specify <code class="codeph">CONTENT</code>, however, then the result of <span class="italic"><code class="codeph">value_expr</code></span> is <span class="italic">not</span> checked for being well-formed.
                        </p>
                        <p>If <span class="italic"><code class="codeph">value_expr</code></span> evaluates to <code class="codeph">NULL</code> or to the empty string (<code class="codeph">''</code>), then function <code class="codeph">XMLSerialize</code> returns <code class="codeph">NULL</code>.
                        </p>
                        <p>The <code class="codeph">ENCODING</code> clause specifies the character encoding for XML data that is serialized as a <code class="codeph">BLOB</code> instance. <span class="italic"><code class="codeph">xml_encoding_spec</code></span> is an XML encoding declaration (<code class="codeph">encoding="..."</code>). If <span class="italic"><code class="codeph">datatype</code></span> is <code class="codeph">BLOB</code> and you specify an <code class="codeph">ENCODING</code> clause, then the output is encoded as specified, and <span class="italic"><code class="codeph">xml_encoding_spec</code></span> is added to the prolog to indicate the <code class="codeph">BLOB</code> encoding. If you specify an <code class="codeph">ENCODING</code> clause with a <span class="italic"><code class="codeph">datatype</code></span> other than <code class="codeph">BLOB</code>, then an error is raised. For UTF-16 characters, <span class="italic"><code class="codeph">xml_encoding_spec</code></span> must be one of the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">encoding=UTF-16BE</code> &#x2013; Big-endian UTF-16 encoding
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">encoding=UTF-16LE</code> &#x2013; Little-endian UTF-16 encoding
                              </p>
                           </li>
                        </ul>
                        <p>If you specify <code class="codeph">VERSION</code> then the specified version is used in the XML declaration (<code class="codeph">&lt;?xml version="..." ...?&gt;</code>).
                        </p>
                        <p>If you specify <code class="codeph">NO INDENT</code>, then all insignificant whitespace is stripped, so that it does not appear in the output. If you specify <code class="codeph">INDENT SIZE = </code><span class="italic"><code class="codeph">N</code></span>, where <span class="italic"><code class="codeph">N</code></span> is a whole number, then the output is <span class="italic">pretty-printed</span> using a relative indentation of <span class="italic"><code class="codeph">N</code></span> spaces. If <span class="italic"><code class="codeph">N</code></span> is <code class="codeph">0</code>, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but there is no other insignificant whitespace in the output. If you specify <code class="codeph">INDENT</code> without a <code class="codeph">SIZE</code> specification, then 2-space indenting is used. If you specify neither <code class="codeph">NO INDENT</code> nor <code class="codeph">INDENT</code>, then the behavior (pretty-printing or not) is indeterminate.
                        </p>
                        <p><code class="codeph">HIDE DEFAULTS</code> and <code class="codeph">SHOW DEFAULTS</code> apply only to XML schema-based data. If you specify <code class="codeph">SHOW DEFAULTS</code> and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify <code class="codeph">HIDE DEFAULTS</code>, then no such elements or attributes are included in the output. <code class="codeph">HIDE DEFAULTS</code> is the default behavior.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">Example 8-17</a> uses <code class="codeph">XMLSerialize</code> to produce a <code class="codeph">CLOB</code> instance containing serialized XML data.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">
                        <p class="titleinexample">Example 8-17 Using SQL/XML Function XMLSERIALIZE</p><pre class="pre codeblock"><code>SELECT XMLSerialize(DOCUMENT XMLType('&lt;poid&gt;143598&lt;/poid&gt;') AS CLOB)
  AS xmlserialize_doc FROM DUAL; 
</code></pre><p>This results in the following output:</p><pre class="oac_no_warn" dir="ltr">XMLSERIALIZE_DOC
-------------------
&lt;poid&gt;143598&lt;/poid&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5037"></a><a id="ADXDB5038"></a><a id="ADXDB5036"></a><div class="props_rev_3"><a id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" name="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C"></a><h4 id="ADXDB-GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" class="sect4"><span class="enumeration_section">8.2.8 </span>XMLPARSE SQL/XML Function
                  </h4>
                  <div>
                     <p>You use SQL/XML standard function <code class="codeph">XMLParse</code> to parse a string containing XML data and construct a corresponding <code class="codeph">XMLType</code> instance.
                     </p>
                     <div class="section">
                        <p> <a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">Figure 8-9</a> shows the syntax:
                        </p>
                        <div class="figure" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">
                           <p class="titleinfigure">Figure 8-9 XMLParse Syntax</p><img src="img/xmlparse.gif" width="404" alt="Description of Figure 8-9 follows" title="Description of Figure 8-9 follows" longdesc="img_text/xmlparse.html"><br><a href="img_text/xmlparse.html">Description of "Figure 8-9 XMLParse Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Argument <span class="italic"><code class="codeph">value_expr</code></span> is evaluated to produce the string that is parsed. If you specify <code class="codeph">DOCUMENT</code>, then <span class="italic"><code class="codeph">value_expr</code></span> must correspond to a <span class="italic">singly rooted</span>, well-formed XML document. If you specify <code class="codeph">CONTENT</code>, then <span class="italic"><code class="codeph">value_expr</code></span> need only correspond to a well-formed XML fragment (it need not be singly rooted). 
                        </p>
                        <p>Keyword <code class="codeph">WELLFORMED</code> is an Oracle XML&nbsp;DB extension to the SQL/XML standard. When you specify <code class="codeph">WELLFORMED</code>, you are informing the parser that argument <span class="italic"><code class="codeph">value_expr</code></span> is well-formed, so Oracle XML&nbsp;DB does <span class="italic">not</span> check to ensure that it is well-formed. 
                        </p>
                        <p>Function <code class="codeph">XMLParse</code> returns an instance of <code class="codeph">XMLType</code>. If <span class="italic"><code class="codeph">value_expr</code></span> evaluates to <code class="codeph">NULL</code>, then the function returns <code class="codeph">NULL</code>. 
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">Example 8-18</a> uses <code class="codeph">XMLParse</code> to parse a string of XML code and produce an <code class="codeph">XMLType</code> instance.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">
                        <p class="titleinexample">Example 8-18 Using SQL/XML Function XMLPARSE</p><pre class="pre codeblock"><code>SELECT XMLParse(CONTENT 
                '124 &lt;purchaseOrder poNo="12435"&gt;
                       &lt;customerName&gt; Acme Enterprises&lt;/customerName&gt;
                       &lt;itemNo&gt;32987457&lt;/itemNo&gt;
                     &lt;/purchaseOrder&gt;'
                WELLFORMED)
  AS po FROM DUAL d;
</code></pre><p>This results in the following output:</p><pre class="pre codeblock"><code>PO
-----------------------------------------------
124 &lt;purchaseOrder poNo="12435"&gt;
&lt;customerName&gt;Acme Enterprises&lt;/customerName&gt;
&lt;itemNo&gt;32987457&lt;/itemNo&gt;
&lt;/purchaseOrder&gt;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__GUID-04E98AA6-68F4-4304-8052-74E8B3659078">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_rec_xml" target="_blank"><span class="italic">Extensible Markup Language (XML) 1.0</span></a> for the definition of well-formed XML documents and fragments 
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5042"></a><a id="ADXDB5043"></a><a id="ADXDB5041"></a><div class="props_rev_3"><a id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" name="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F"></a><h4 id="ADXDB-GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" class="sect4"><span class="enumeration_section">8.2.9 </span>XMLCOLATTVAL Oracle SQL Function
                  </h4>
                  <div>
                     <p>Oracle SQL function <code class="codeph">XMLColAttVal</code> generates a forest of XML <code class="codeph">column</code> elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions. 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__I1032066">Figure 8-10</a> shows the <code class="codeph">XMLColAttVal</code> syntax.
                        </p>
                        <div class="figure" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__I1032066">
                           <p class="titleinfigure">Figure 8-10 XMLCOLATTVAL Syntax</p><img src="img/xmlcolattval.gif" width="460" alt="Description of Figure 8-10 follows" title="Description of Figure 8-10 follows" longdesc="img_text/xmlcolattval.html"><br><a href="img_text/xmlcolattval.html">Description of "Figure 8-10 XMLCOLATTVAL Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>The arguments are used as the values of the <code class="codeph">name</code> attribute of the <code class="codeph">column</code> element. The <span class="italic"><code class="codeph">c_alias</code></span> values are used as the attribute identifiers.
                        </p>
                        <p>As an alternative to using keyword <code class="codeph">AS</code> followed by a <span class="italic">literal</span> string <span class="italic"><code class="codeph">c_alias</code></span>, you can use <code class="codeph">AS EVALNAME</code> followed by an expression that evaluates to a string to be used as the attribute identifier.
                        </p>
                        <p>Because argument values <span class="italic"><code class="codeph">value_expr</code></span> are used only as attribute <span class="italic">values</span>, they need <span class="italic">not</span> be escaped in any way. This is in contrast to function <code class="codeph">XMLForest</code>. It means that you can use <code class="codeph">XMLColAttVal</code> to transport SQL columns and values without escaping. 
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">Example 8-19</a> uses <code class="codeph">XMLColAttVal</code> to generate an <code class="codeph">Emp</code> element for each employee, with a <code class="codeph">name</code> attribute, and with <code class="codeph">column</code> elements that have the employee hire date and department as the content.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">
                        <p class="titleinexample">Example 8-19 XMLCOLATTVAL: Generating Elements with Attribute and Child Elements</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement("Emp", 
                  XMLAttributes(e.first_name ||' '||e.last_name AS "fullname" ),
                  XMLColAttVal(e.hire_date, e.department_id AS "department"))
  AS "RESULT" 
  FROM hr.employees e
  WHERE e.department_id = 30;
</pre><p>This query produces the following XML result. (The result is shown here pretty-printed, for clarity.)</p><pre class="oac_no_warn" dir="ltr">RESULT
-----------------------------------------------------------
&lt;Emp fullname="Den Raphaely"&gt;
  &lt;column name = "HIRE_DATE"&gt;2002-12-07&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Alexander Khoo"&gt;
  &lt;column name = "HIRE_DATE"&gt;2003-05-18&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Shelli Baida"&gt;
  &lt;column name = "HIRE_DATE"&gt;2005-12-24&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Sigal Tobias"&gt;
  &lt;column name = "HIRE_DATE"&gt;2005-07-24&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Guy Himuro"&gt;
  &lt;column name = "HIRE_DATE"&gt;2006-11-15&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Karen Colmenares"&gt;
  &lt;column name = "HIRE_DATE"&gt;2007-08-10&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
 
6 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__GUID-7F5A3F48-C1D6-4917-9D7C-189CC87BC835">
                        <p class="notep1">See Also:</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">Example 8-8</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5045"></a><a id="ADXDB5046"></a><a id="ADXDB5044"></a><div class="props_rev_3"><a id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" name="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130"></a><h4 id="ADXDB-GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" class="sect4"><span class="enumeration_section">8.2.10 </span>XMLCDATA Oracle SQL Function
                  </h4>
                  <div>
                     <p>You use Oracle SQL function <code class="codeph">XMLCDATA</code> to generate an XML <code class="codeph">CDATA</code> section. 
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">Figure 8-11</a> shows the syntax:
                        </p>
                        <div class="figure" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">
                           <p class="titleinfigure">Figure 8-11 XMLCDATA Syntax</p><img src="img/xmlcdata.gif" width="192" alt="Description of Figure 8-11 follows" title="Description of Figure 8-11 follows" longdesc="img_text/xmlcdata.html"><br><a href="img_text/xmlcdata.html">Description of "Figure 8-11 XMLCDATA Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>Argument <span class="italic"><code class="codeph">value_expr</code></span> is evaluated to a string, and the result is used as the body of the generated XML <code class="codeph">CDATA</code> section, <code class="codeph">&lt;![CDATA[</code><span class="italic"><code class="codeph">string-result</code></span><code class="codeph">]]&gt;</code>, where <span class="italic"><code class="codeph">string-result</code></span> is the result of evaluating <span class="italic"><code class="codeph">value_expr</code></span>. If<span class="italic"><code class="codeph"> string-result</code></span> is the empty string, then the <code class="codeph">CDATA</code> section is empty: <code class="codeph">&lt;![CDATA[]]&gt;</code>.
                        </p>
                        <p>An error is raised if the constructed XML is not a legal XML <code class="codeph">CDATA</code> section. In particular, <span class="italic"><code class="codeph">string-result</code></span> must <span class="italic">not</span> contain two consecutive right brackets (<code class="codeph">]</code>): "<code class="codeph">]]</code>".
                        </p>
                        <p>Function <code class="codeph">XMLCDATA</code> returns an instance of <code class="codeph">XMLType</code>. If <span class="italic"><code class="codeph">string-result</code></span> is <code class="codeph">NULL</code>, then the function returns <code class="codeph">NULL</code>.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">Example 8-20</a> uses <code class="codeph">XMLCDATA</code> to generate an XML <code class="codeph">CDATA</code> section.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">
                        <p class="titleinexample">Example 8-20 Using Oracle SQL Function XMLCDATA</p><pre class="pre codeblock"><code>SELECT XMLElement("PurchaseOrder",
                  XMLElement("Address",
                             XMLCDATA('100 Pennsylvania Ave.'),
                             XMLElement("City", 'Washington, D.C.')))
  AS RESULT FROM DUAL;
                            </code></pre><p>This results in the following output. (The result is shown here pretty-printed, for clarity.)</p><pre class="pre codeblock"><code>RESULT
--------------------------
&lt;PurchaseOrder&gt;
  &lt;Address&gt;
    &lt;![CDATA[100 Pennsylvania Ave.]]&gt;
    &lt;City&gt;Washington, D.C.&lt;/City&gt;
  &lt;/Address&gt;
&lt;/PurchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5047"></a><div class="props_rev_3"><a id="GUID-1490DB76-5832-4023-8F0B-28427901C912" name="GUID-1490DB76-5832-4023-8F0B-28427901C912"></a><h3 id="ADXDB-GUID-1490DB76-5832-4023-8F0B-28427901C912" class="sect3"><span class="enumeration_section">8.3 </span>Generation of XML Data Using DBMS_XMLGEN
               </h3>
               <div>
                  <p>PL/SQL package <code class="codeph">DBMS_XMLGEN</code> creates XML documents from SQL query results. It retrieves an XML document as a <code class="codeph">CLOB</code> or <code class="codeph">XMLType</code> value. 
                  </p>
                  <p>It provides a <span class="italic">fetch</span> interface, whereby you can specify the maximum number of rows to retrieve and the number of rows to skip. For example, the first fetch could retrieve a maximum of ten rows, skipping the first four. This is especially useful for pagination requirements in Web applications. 
                  </p>
                  <p>Package <code class="codeph">DBMS_XMLGEN</code> also provides options for changing tag names for <code class="codeph">ROW</code>, <code class="codeph">ROWSET</code>, and so on. The parameters of the package can restrict the number of rows retrieved and the enclosing tag names.
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC">Using PL/SQL Package DBMS_XMLGEN</a><br>You can use package <code class="codeph">DBMS_XMLGEN</code> to generate XML data from relational data.
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-458675AB-E020-4BFF-8CA9-34D309186F62">Functions and Procedures of Package DBMS_XMLGEN</a><br>PL/SQL package <code class="codeph">DBMS_XMLGEN</code> provides functions and procedures for generating XML data from relational data.
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45">DBMS_XMLGEN Examples</a><br>Examples here illustrate the use of PL/SQL package  <code class="codeph">DBMS_XMLGEN</code>.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-1490DB76-5832-4023-8F0B-28427901C912__GUID-D632695B-2D11-4F88-8760-EB332942519E">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../arpls/DBMS_XMLGEN.html#ARPLS374" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../adxdk/using-XML-SQL-utility.html#ADXDK070" target="_blank"><span><cite>Oracle XML Developer's Kit Programmer's Guide</cite></span></a> (compare <code class="codeph">OracleXMLQuery</code> with <code class="codeph">DBMS_XMLGEN</code>)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5049"></a><a id="ADXDB5048"></a><div class="props_rev_3"><a id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC" name="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC"></a><h4 id="ADXDB-GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC" class="sect4"><span class="enumeration_section">8.3.1 </span>Using PL/SQL Package DBMS_XMLGEN
                  </h4>
                  <div>
                     <p>You can use package <code class="codeph">DBMS_XMLGEN</code> to generate XML data from relational data.
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__I1025437">Figure 8-12</a> illustrates how to use package <code class="codeph">DBMS_XMLGEN</code>. The steps are as follows:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Get the context from the package by supplying a SQL query and calling PL/SQL function <code class="codeph">newContext</code>.</span><div></div>
                        </li>
                        <li class="stepexpand"><span>Pass the context to all procedures or functions in the package to set the various options. For example, to set the <code class="codeph">ROW</code> element name, use <code class="codeph">setRowTag(ctx)</code>, where <code class="codeph">ctx</code> is the context got from the previous <code class="codeph">newContext</code> call.</span><div></div>
                        </li>
                        <li class="stepexpand"><span>Get the XML result, using PL/SQL function <code class="codeph">getXML</code> or <code class="codeph">getXMLType</code>. By setting the maximum number of rows to be retrieved for each fetch using PL/SQL procedure <code class="codeph">setMaxRows</code>, you can call either of these functions repeatedly, retrieving up to the maximum number of rows for each call. These functions return XML data (as a <code class="codeph">CLOB</code> value and as an instance of <code class="codeph">XMLType</code>, respectively), unless there are no rows retrieved. In that case, these functions return <code class="codeph">NULL</code>. To determine how many rows were retrieved, use PL/SQL function <code class="codeph">getNumRowsProcessed</code>.</span><div></div>
                        </li>
                        <li class="stepexpand"><span>You can reset the query to start again and repeat step 3.</span><div></div>
                        </li>
                        <li class="stepexpand"><span>Call PL/SQL procedure <code class="codeph">closeContext</code> to free up any previously allocated resources.</span></li>
                     </ol>
                     <div class="section">
                        <div class="figure" id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__I1025437">
                           <p class="titleinfigure">Figure 8-12 Using PL/SQL Package DBMS_XMLGEN</p><img src="img/adxdb054.gif" width="611" alt="Description of Figure 8-12 follows" title="Description of Figure 8-12 follows" longdesc="img_text/adxdb054.html"><br><a href="img_text/adxdb054.html">Description of "Figure 8-12 Using PL/SQL Package DBMS_XMLGEN"</a></div>
                        <!-- class="figure" -->
                        <p>In conjunction with a SQL query, PL/SQL method <code class="codeph">DBMS_XMLGEN.getXML()</code> typically returns a result similar to the following, as a <code class="codeph">CLOB</code> value:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-87&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-89&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre><p>The default mapping between relational data and XML data is as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Each row returned by the SQL query maps to an XML element with the default element name <code class="codeph">ROW</code>. 
                              </p>
                           </li>
                           <li>
                              <p>Each column returned by the SQL query maps to a child element of the <code class="codeph">ROW</code> element.
                              </p>
                           </li>
                           <li>
                              <p>The entire result is wrapped in a <code class="codeph">ROWSET</code> element. 
                              </p>
                           </li>
                           <li>
                              <p>Binary data is transformed to its hexadecimal representation.</p>
                           </li>
                        </ul>
                        <p>Element names <code class="codeph">ROW</code> and <code class="codeph">ROWSET</code> can be replaced with names you choose, using <code class="codeph">DBMS_XMLGEN</code> procedures <code class="codeph">setRowTagName</code> and <code class="codeph">setRowSetTagName</code>, respectively.
                        </p>
                        <p>The <code class="codeph">CLOB</code> value returned by <code class="codeph">getXML</code> has the same encoding as the database character set. If the database character set is SHIFTJIS, then the XML document returned is also SHIFTJIS.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5051"></a><a id="ADXDB5050"></a><div class="props_rev_3"><a id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62" name="GUID-458675AB-E020-4BFF-8CA9-34D309186F62"></a><h4 id="ADXDB-GUID-458675AB-E020-4BFF-8CA9-34D309186F62" class="sect4"><span class="enumeration_section">8.3.2 </span>Functions and Procedures of Package DBMS_XMLGEN
                  </h4>
                  <div>
                     <p>PL/SQL package <code class="codeph">DBMS_XMLGEN</code> provides functions and procedures for generating XML data from relational data.
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764" title="This table describes DBMS_XMLGEN functions and procedures.">Table 8-1</a> describes the functions and procedures of package <code class="codeph">DBMS_XMLGEN</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764">
                        <p class="titleintable">Table 8-1 DBMS_XMLGEN Functions and Procedures</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="DBMS_XMLGEN Functions and Procedures" summary="This table describes DBMS_XMLGEN functions and procedures." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="41%" id="d55429e3458">Function or Procedure</th>
                                 <th align="left" valign="bottom" width="59%" id="d55429e3461">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3466" headers="d55429e3458 "><pre class="pre codeblock"><code>SUBTYPE ctxHandle IS NUMBER</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3466 d55429e3461 ">
                                    <p>The context handle used by all functions. </p>
                                    <p>Document Type Definition (DTD) or schema specifications: </p>
                                    <p><code class="codeph">NONE CONSTANT NUMBER:= 0;</code></p>
                                    <p><code class="codeph">DTD CONSTANT NUMBER:= 1;</code> 
                                    </p>
                                    <p><code class="codeph">SCHEMA CONSTANT NUMBER:= 2;</code></p>
                                    <p>Can be used in function <code class="codeph">getXML</code> to specify whether to generate a DTD or XML schema or neither (<code class="codeph">NONE</code>). Only the <code class="codeph">NONE</code> specification is supported.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3496" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3496 d55429e3461 ">
                                    <p>Given a query string, generate a new context handle to be used in subsequent functions. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3503" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext(
  queryString IN VARCHAR2)</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3503 d55429e3461 ">
                                    <p>Returns a new context</p>
                                    <p><span class="italic">Parameter:</span> <code class="codeph">queryString</code> <code class="codeph">(IN)</code>- the query string, the result of which must be converted to XML 
                                    </p>
                                    <p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code class="codeph">getXML</code> and other functions to get the XML back from the result.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3527" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext(
  queryString IN SYS_REFCURSOR)
  RETURN ctxHandle;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3527 d55429e3461 ">
                                    <p>Creates a new context handle from a PL/SQL cursor variable. The context handle can be used for the rest of the functions. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3534" headers="d55429e3458 "><pre class="pre codeblock"><code>newContextFromHierarchy(
  queryString IN VARCHAR2)
  RETURN ctxHandle;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3534 d55429e3461 ">
                                    <p><span class="italic">Parameter:</span> <code class="codeph">queryString (IN)</code> - the query string, the result of which must be converted to XML. The query is a hierarchical query typically formed using a <code class="codeph">CONNECT BY</code> clause, and the result must have the same property as the result set generated by a <code class="codeph">CONNECT BY</code> query. The result set must have only two columns, the level number and an XML value. The level number is used to determine the hierarchical position of the XML value within the result XML document.
                                    </p>
                                    <p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code class="codeph">getXML</code> and other functions to get a hierarchical XML with recursive elements back from the result.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3559" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowTag()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3559 d55429e3461 ">
                                    <p>Sets the name of the element separating all the rows. The default name is <code class="codeph">ROW</code>. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3569" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowTag(ctx IN ctxHandle,
          rowTag IN VARCHAR2);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3569 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span> 
                                    </p>
                                    <p><code class="codeph">ctx(IN)</code> - the context handle obtained from the <code class="codeph">newContext</code> call. 
                                    </p>
                                    <p><code class="codeph">rowTag(IN)</code> - the name of the <code class="codeph">ROW</code> element. A <code class="codeph">NULL</code> value for <code class="codeph">rowTag</code> indicates that you do not want the <code class="codeph">ROW</code> element to be present. 
                                    </p>
                                    <p>Call this procedure to set the name of the <code class="codeph">ROW</code> element, if you do not want the default <code class="codeph">ROW</code> name to show up. You can also set <code class="codeph">rowTag</code> to <code class="codeph">NULL</code> to suppress the <code class="codeph">ROW</code> element itself. 
                                    </p>
                                    <p>However, since function <code class="codeph">getXML</code> returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code class="codeph">rowTag</code> value and the <code class="codeph">rowSetTag</code> value (see <code class="codeph">setRowSetTag</code>, next) are <code class="codeph">NULL</code> and there is more than one column or row in the output.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3635" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowSetTag()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3635 d55429e3461 ">
                                    <p>Sets the name of the document root element. The default name is <code class="codeph">ROWSET</code> 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3645" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowSetTag(ctx IN ctxHandle, 
             rowSetTag IN VARCHAR2);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3645 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> &#x2013; the context handle obtained from the <code class="codeph">newContext</code> call.
                                    </p>
                                    <p><code class="codeph">rowSetTag(IN)</code> &#x2013; the name of the document root element to be used in the output. A <code class="codeph">NULL</code> value for <code class="codeph">rowSetTag</code> indicates that you do <span class="italic">not</span> want the <code class="codeph">ROWSET</code> element to be present.
                                    </p>
                                    <p>Call this procedure to set the name of the document root element, if you do not want the default name <code class="codeph">ROWSET</code> to be used. You can set <code class="codeph">rowSetTag</code> to <code class="codeph">NULL</code> to suppress printing of the document root element. 
                                    </p>
                                    <p>However, since function <code class="codeph">getXML</code> returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code class="codeph">rowTag</code> value and the <code class="codeph">rowSetTag</code> value (see <code class="codeph">setRowTag</code>, previous) are <code class="codeph">NULL</code> and there is more than one column or row in the output, or if the <code class="codeph">rowSetTag</code> value is <code class="codeph">NULL</code> and there is more than one row in the output. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3711" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3711 d55429e3461 ">
                                    <p>Gets the XML document by fetching the maximum number of rows specified. It appends the XML document to the <code class="codeph">CLOB</code> passed in.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3721" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML(ctx IN ctxHandle, 
       clobval IN OUT NCOPY clob, 
       dtdOrSchema IN number:= NONE);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3721 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span> 
                                    </p>
                                    <p><code class="codeph">ctx(IN)</code> - The context handle obtained from calling <code class="codeph">newContext</code>.
                                    </p>
                                    <p><code class="codeph">clobval(IN/OUT)</code> - the <code class="codeph">CLOB</code> to which the XML document is to be appended, 
                                    </p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - whether you should generate the DTD or Schema. This parameter is NOT supported. 
                                    </p>
                                    <p>Use this version of function <code class="codeph">getXML</code>, to avoid any extra <code class="codeph">CLOB</code> copies and if you want to reuse the same <code class="codeph">CLOB</code> for subsequent calls. This <code class="codeph">getXML</code> call is more efficient than the next flavor, though this involves that you create the LOB locator. When generating the XML, the number of rows indicated by the <code class="codeph">setSkipRows</code> call are skipped, then the maximum number of rows as specified by the <code class="codeph">setMaxRows</code> call (or the entire result if not specified) is fetched and converted to XML. Use the <code class="codeph">getNumRowsProcessed</code> function to check if any rows were retrieved or not.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3773" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3773 d55429e3461 ">
                                    <p>Generates the XML document and returns it as a <code class="codeph">CLOB</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3783" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML(ctx IN ctxHandle, 
       dtdOrSchema IN number:= NONE) 
  RETURN clob;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3783 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - The context handle obtained from calling <code class="codeph">newContext</code>.
                                    </p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported. 
                                    </p>
                                    <p><span class="italic">Returns:</span> A temporary <code class="codeph">CLOB</code> containing the document. Free the temporary <code class="codeph">CLOB</code> obtained from this function using the <code class="codeph">DBMS_LOB.freeTemporary</code> call.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3818" headers="d55429e3458 "><pre class="pre codeblock"><code>getXMLType(
  ctx IN ctxHandle, 
  dtdOrSchema IN number:= NONE)
  RETURN XMLType;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3818 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - The context handle obtained from calling <code class="codeph">newContext</code>.
                                    </p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported. 
                                    </p>
                                    <p><span class="italic">Returns:</span> An <code class="codeph">XMLType</code> instance containing the document.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3847" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)
  RETURN CLOB;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3847 d55429e3461 ">
                                    <p>Converts the query results from the SQL query string <code class="codeph">sqlQuery</code> to XML format.
                                    </p>
                                    <p><span class="italic">Returns:</span> A <code class="codeph">CLOB</code> instance.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3864" headers="d55429e3458 "><pre class="pre codeblock"><code>getXMLType(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)   
  RETURN XMLType;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3864 d55429e3461 ">
                                    <p>Converts the query results from the SQL query string <code class="codeph">sqlQuery</code> to XML format.
                                    </p>
                                    <p><span class="italic">Returns:</span> An <code class="codeph">XMLType</code> instance.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3881" headers="d55429e3458 "><pre class="pre codeblock"><code>getNumRowsProcessed()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3881 d55429e3461 ">
                                    <p>Gets the number of SQL rows processed when generating XML data using function <code class="codeph">getXML</code>. This count does not include the number of rows <span class="italic">skipped</span> before generating XML data.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3894" headers="d55429e3458 "><pre class="pre codeblock"><code>getNumRowsProcessed(ctx IN ctxHandle) 
  RETURN number;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3894 d55429e3461 ">
                                    <p><span class="italic">Parameter:</span> <code class="codeph">queryString(IN)</code>- the query string, the result of which must be converted to XML
                                    </p>
                                    <p><span class="italic">Returns:</span> The number of SQL rows that were processed in the last call to <code class="codeph">getXML</code>. 
                                    </p>
                                    <p>You can call this to find out if the end of the result set has been reached. This does not include the number of rows <span class="italic">skipped</span> before generating XML data. Use this function to determine the terminating condition if you are calling <code class="codeph">getXML</code> in a loop. <code class="codeph">getXML</code> always generates an XML document even if there are no rows present.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3924" headers="d55429e3458 "><pre class="pre codeblock"><code>setMaxRows()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3924 d55429e3461 ">
                                    <p>Sets the maximum number of rows to fetch from the SQL query result for every invocation of the <code class="codeph">getXML</code> call. It is an error to call this function on a context handle created by function <code class="codeph">newContextFromHierarchy</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3937" headers="d55429e3458 "><pre class="pre codeblock"><code>setMaxRows(ctx IN ctxHandle, 
           maxRows IN NUMBER);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3937 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - the context handle corresponding to the query executed, 
                                    </p>
                                    <p><code class="codeph">maxRows(IN)</code> - the maximum number of rows to get for each call to <code class="codeph">getXML</code>. 
                                    </p>
                                    <p>The <code class="codeph">maxRows</code> parameter can be used when generating paginated results using this utility. For instance when generating a page of XML or HTML data, you can restrict the number of rows converted to XML and then in subsequent calls, you can get the next set of rows and so on. This also can provide for faster response times. It is an error to call this procedure on a context handle created by function <code class="codeph">newContextFromHierarchy</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3964" headers="d55429e3458 "><pre class="pre codeblock"><code>setSkipRows()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3964 d55429e3461 ">
                                    <p>Skips a given number of rows before generating the XML output for every call to <code class="codeph">getXML</code>. It is an error to call this function on a context handle created by function <code class="codeph">newContextFromHierarchy</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3977" headers="d55429e3458 "><pre class="pre codeblock"><code>setSkipRows(ctx IN ctxHandle, 
            skipRows IN NUMBER);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3977 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - the context handle corresponding to the query executed, 
                                    </p>
                                    <p><code class="codeph">skipRows(IN)</code> - the number of rows to skip for each call to <code class="codeph">getXML</code>. 
                                    </p>
                                    <p>The <code class="codeph">skipRows</code> parameter can be used when generating paginated results for stateless Web pages using this utility. For instance when generating the first page of XML or HTML data, you can set <code class="codeph">skipRows</code> to zero. For the next set, you can set the <code class="codeph">skipRows</code> to the number of rows that you got in the first case. It is an error to call this function on a context handle created by function <code class="codeph">newContextFromHierarchy</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4011" headers="d55429e3458 "><pre class="pre codeblock"><code>setConvertSpecialChars()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4011 d55429e3461 ">
                                    <p>Determines whether or not special characters in the XML data must be converted into their escaped XML equivalent. For example, the <code class="codeph">&lt;</code> sign is converted to <code class="codeph">&amp;lt;</code>. The default behavior is to perform escape conversions.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4024" headers="d55429e3458 "><pre class="pre codeblock"><code>setConvertSpecialChars(
  ctx IN ctxHandle, 
  conv IN BOOLEAN);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4024 d55429e3461 ">
                                    <p><span class="italic">Parameters:</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - the context handle to use, 
                                    </p>
                                    <p><code class="codeph">conv(IN)</code> - true indicates that conversion is needed. 
                                    </p>
                                    <p>You can use this function to speed up the XML processing whenever you are sure that the input data cannot contain any special characters such as <span class="bold"><code class="codeph">&lt;</code></span>, <span class="bold"><code class="codeph">&gt;</code></span>, <span class="bold"><code class="codeph">"</code></span>, <span class="bold"><code class="codeph">'</code></span>, and so on, which must be preceded by an escape character. It is expensive to scan the character data to replace the special characters, particularly if it involves a lot of data. So, in cases when the data is XML-safe, this function can be called to improve performance.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4058" headers="d55429e3458 "><pre class="pre codeblock"><code>useItemTagsForColl()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4058 d55429e3461 ">
                                    <p>Sets the name of the collection elements. The default name for collection elements is the type name itself. You can override that to use the name of the column with the <code class="codeph">_ITEM</code> tag appended to it using this function.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4068" headers="d55429e3458 "><pre class="pre codeblock"><code>useItemTagsForColl(ctx IN ctxHandle);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4068 d55429e3461 ">
                                    <p><span class="italic">Parameter:</span> <code class="codeph">ctx(IN)</code> - the context handle. 
                                    </p>
                                    <p>If you have a collection of <code class="codeph">NUMBER</code>, say, the default tag name for the collection elements is <code class="codeph">NUMBER</code>. You can override this action and generate the collection column name with the <code class="codeph">_ITEM</code> tag appended to it, by calling this procedure.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4091" headers="d55429e3458 "><pre class="pre codeblock"><code>restartQuery()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4091 d55429e3461 ">
                                    <p>Restarts the query and generate the XML from the first row again.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4098" headers="d55429e3458 "><pre class="pre codeblock"><code>restartQuery(ctx IN ctxHandle);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4098 d55429e3461 ">
                                    <p><span class="italic">Parameter:</span> <code class="codeph">ctx(IN)</code> - the context handle corresponding to the current query. You can call this to start executing the query again, without having to create a new context.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4110" headers="d55429e3458 "><pre class="pre codeblock"><code>closeContext()</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4110 d55429e3461 ">
                                    <p>Closes a given context and releases all resources associated with that context, including the SQL cursor and bind and define buffers, and so on.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4117" headers="d55429e3458 "><pre class="pre codeblock"><code>closeContext(ctx IN ctxHandle);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4117 d55429e3461 ">
                                    <p><span class="italic">Parameter:</span> <code class="codeph">ctx(IN)</code> - the context handle to close. Closes all resources associated with this handle. After this you cannot use the handle for any other <code class="codeph">DBMS_XMLGEN</code> function call.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4132" headers="d55429e3458 ">
                                    <p><span class="italic">Conversion Functions</span></p><pre class="pre codeblock"><code>convert(
  xmlData IN varchar2, 
  flag IN NUMBER := ENTITY_ENCODE)    
  RETURN VARCHAR2;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4132 d55429e3461 ">
                                    <p>Encodes or decodes the XML data string argument.</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Encoding refers to replacing entity references such as <code class="codeph">&lt;</code> to their escaped equivalent, such as <code class="codeph">&amp;lt;</code>. 
                                          </p>
                                       </li>
                                       <li>
                                          <p>Decoding refers to the reverse conversion.</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4155" headers="d55429e3458 "><pre class="pre codeblock"><code>convert(
  xmlData IN CLOB, 
  flag IN NUMBER := ENTITY_ENCODE) 
  RETURN CLOB;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4155 d55429e3461 ">
                                    <p>Encodes or decodes the passed in XML <code class="codeph">CLOB</code> data.
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Encoding refers to replacing entity references such as <code class="codeph">&lt;</code> to their escaped equivalent, such as <code class="codeph">&amp;lt;</code>. 
                                          </p>
                                       </li>
                                       <li>
                                          <p>Decoding refers to the reverse conversion.</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4178" headers="d55429e3458 ">
                                    <p><span class="italic">NULL Handling</span></p><pre class="pre codeblock"><code>setNullHandling(ctx IN ctxHandle, 
                flag IN NUMBER);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4178 d55429e3461 ">
                                    <p>The <code class="codeph">setNullHandling</code> flag values are: 
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p><code class="codeph">DROP_NULLS CONSTANT NUMBER := 0;</code> 
                                          </p>
                                          <p>This is the default setting and leaves out the tag for <code class="codeph">NULL</code> elements.
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NULL_ATTR CONSTANT NUMBER := 1;</code> 
                                          </p>
                                          <p>This sets <code class="codeph">xsi:nil = "true"</code>.
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">EMPTY_TAG CONSTANT NUMBER := 2;</code> 
                                          </p>
                                          <p>This sets, for example, <code class="codeph">&lt;foo/&gt;</code>. 
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4223" headers="d55429e3458 "><pre class="pre codeblock"><code>useNullAttributeIndicator(
  ctx IN ctxHandle, 
  attrind IN BOOLEAN := TRUE);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4223 d55429e3461 ">
                                    <p><code class="codeph">useNullAttributeIndicator</code> is a shortcut for <code class="codeph">setNullHandling(ctx, NULL_ATTR)</code>. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4235" headers="d55429e3458 "><pre class="pre codeblock"><code>setBindValue(
  ctx IN ctxHandle, 
  bindVariableName IN VARCHAR2, 
  bindValue IN VARCHAR2);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4235 d55429e3461 ">
                                    <p>Sets bind value for the bind variable appearing in the query string associated with the context handle. The query string with bind variables cannot be executed until all of the bind variables are set values using <code class="codeph">setBindValue</code>. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4245" headers="d55429e3458 "><pre class="pre codeblock"><code>clearBindValue(ctx IN ctxHandle);</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4245 d55429e3461 ">
                                    <p>Clears all the bind values for all the bind variables appearing in the query string associated with the context handle. Afterward, all of the bind variables must rebind new values using <code class="codeph">setBindValue</code>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5053"></a><a id="ADXDB5054"></a><a id="ADXDB5055"></a><a id="ADXDB5056"></a><a id="ADXDB5057"></a><a id="ADXDB5058"></a><a id="ADXDB5059"></a><a id="ADXDB5060"></a><a id="ADXDB5061"></a><a id="ADXDB5052"></a><div class="props_rev_3"><a id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45" name="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45"></a><h4 id="ADXDB-GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45" class="sect4"><span class="enumeration_section">8.3.3 </span>DBMS_XMLGEN Examples
                  </h4>
                  <div>
                     <p>Examples here illustrate the use of PL/SQL package  <code class="codeph">DBMS_XMLGEN</code>.
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025636">Example 8-21</a> uses <code class="codeph">DBMS_XMLGEN</code> to create an XML document by selecting employee data from an object-relational table and putting the resulting <code class="codeph">CLOB</code> value into a table.
                        </p>
                        <p>Instead of generating all of the XML data for all rows, you can use the fetch interface of package <code class="codeph">DBMS_XMLGEN</code> to retrieve a fixed number of rows each time. This speeds up response time and can help in scaling applications that need a Document Object Model (DOM) Application Program Interface (API) on the resulting XML, particularly if the number of rows is large.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025688">Example 8-22</a> uses <code class="codeph">DBMS_XMLGEN</code> to retrieve results from table <code class="codeph">HR.employees</code>:
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">Example 8-23</a> uses <code class="codeph">DBMS_XMLGEN</code> with object types to represent nested structures.
                        </p>
                        <p>With relational data, the result is an XML document without nested elements. To obtain nested XML structures, you can use object-relational data, where the mapping is as follows:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic">Object types</span> map to XML elements &#x2013; see <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema is a standard for describing the content and structure of XML documents. You can register, update, and delete an XML schema used with Oracle XML&nbsp;DB. You can define storage structures to use for your XML schema-based data and map XML Schema data types to SQL data types.">XML Schema Storage and Query: Basic</a>.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">Attributes of the type</span> map to sub-elements of the parent element
                              </p>
                              <div class="infoboxnote" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-49DF9813-DEF6-420C-A51F-1D19FB56E4E8">
                                 <p class="notep1">Note:</p>
                                 <p>Complex structures can be obtained by using object types and creating object views or object tables. A canonical mapping is used to map object instances to XML. </p>
                                 <p>When used in column names or attribute names, the at-sign (<code class="codeph">@</code>) is translated into an attribute of the enclosing XML element in the mapping.
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>When you provide a user-defined data-type instance to <code class="codeph">DBMS_XMLGEN</code> functions, the user-defined data-type instance is mapped to an XML document using a canonical mapping: the <span class="italic">attributes</span> of the user-defined data type are mapped to XML <span class="italic">elements</span>. Attributes with names starting with an at-sign character (<code class="codeph">@</code>) are mapped to attributes of the preceding element.
                        </p>
                        <p>User-defined data-type instances can be used for nesting in the resulting XML document. </p>
                        <p>For example, consider the tables <code class="codeph">emp</code> and <code class="codeph">dept</code> defined in <a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">Example 8-24</a>. To generate a hierarchical view of the data, that is, departments with their employees, <a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">Example 8-24</a> defines suitable object types to create the structure inside the database.
                        </p>
                        <p>The default name <code class="codeph">ROW</code> is not present because it was set to <code class="codeph">NULL</code>. The <code class="codeph">deptno</code> and <code class="codeph">empno</code> have become attributes of the enclosing element.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1032455">Example 8-25</a> uses <code class="codeph">DBMS_XMLGEN.getXMLType</code> to generate a purchase order document in XML format using object views.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">Example 8-26</a> shows how to open a cursor variable for a query and use that cursor variable to create a new context handle for <code class="codeph">DBMS_XMLGEN</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-FF45D59E-95C4-422A-8FB3-473410F46631">
                           <p class="notep1">See Also:</p>
                           <p><a href="../lnpls/cursor-variable-declaration.html#LNPLS01312" target="_blank"><span><cite>Oracle Database PL/SQL Language Reference</cite></span></a> for more information about cursor variables (<code class="codeph">REF CURSOR</code>)
                           </p>
                        </div>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">Example 8-27</a> shows how to specify <code class="codeph">NULL</code> handling when using <code class="codeph">DBMS_XMLGEN</code>.
                        </p>
                        <p>Function <code class="codeph">DBMS_XMLGEN.newContextFromHierarchy</code> takes as argument a hierarchical query string, which is typically formulated with a <code class="codeph">CONNECT BY</code> clause. It returns a context that can be used to generate a hierarchical XML document with recursive elements.
                        </p>
                        <p>The hierarchical query returns two columns, the level number (a pseudocolumn generated by <code class="codeph">CONNECT BY</code> query) and an <code class="codeph">XMLType</code> instance. The level is used to determine the position of the <code class="codeph">XMLType</code> value within the hierarchy of the result XML document.
                        </p>
                        <p>It is an error to set the skip number of rows or the maximum number of rows for a context created using <code class="codeph">newContextFromHierarchy</code>.
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">Example 8-28</a> uses <code class="codeph">DBMS_ XMLGEN.newContextFromHierarchy</code> to generate a manager&#x2013;employee hierarchy.
                        </p>
                        <p>If the query string used to create a context contains host variables, you can use PL/SQL method <code class="codeph">setBindValue()</code> to give the variables values before query execution. <a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">Example 8-29</a> illustrates this.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025636">
                        <p class="titleinexample">Example 8-21 DBMS_XMLGEN: Generating Simple XML</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE temp_clob_tab (result CLOB);

DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext(
              'SELECT * FROM hr.employees WHERE employee_id = 101');
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, 'EMPLOYEE');
  -- Get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
</pre><p>That generates the following XML document:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM temp_clob_tab;

RESULT
-------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025688">
                        <p class="titleinexample">Example 8-22 DBMS_XMLGEN: Generating Simple XML with Pagination (Fetch)</p><pre class="oac_no_warn" dir="ltr">-- Create a table to hold the results
CREATE TABLE temp_clob_tab (result clob);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  -- Get the query context;
  qryCtx := DBMS_XMLGEN.newContext('SELECT * FROM hr.employees');
  -- Set the maximum number of rows to be 2
  DBMS_XMLGEN.<span class="bold">setMaxRows</span>(qryCtx, 2);
  LOOP
    -- Get the result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- If no rows were processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
 
    -- Do some processing with the lob data
    --   Insert the results into a table.
    --   You can print the lob out, output it to a stream,
    --   put it in a queue, or do any other processing.
    INSERT INTO temp_clob_tab VALUES(result);
  END LOOP;
  --close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/

SELECT * FROM temp_clob_tab WHERE rownum &lt; 3;

RESULT
----------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-03&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;102&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lex&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;De Haan&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LDEHAAN&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;13-JAN-01&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;103&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alexander&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Hunold&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AHUNOLD&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;590.423.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;03-JAN-06&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;IT_PROG&lt;/JOB_ID&gt;
  &lt;SALARY&gt;9000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;102&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;60&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
2 rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">
                        <p class="titleinexample">Example 8-23 DBMS_XMLGEN: Generating XML Using Object Types</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE new_departments (department_id   NUMBER PRIMARY KEY,
                              department_name VARCHAR2(20));
CREATE TABLE new_employees (employee_id       NUMBER PRIMARY KEY,
                            last_name         VARCHAR2(20),
                            department_id     NUMBER REFERENCES new_departments);
CREATE TYPE emp_t AS OBJECT ("@employee_id"   NUMBER,
                             last_name        VARCHAR2(20));
/
INSERT INTO new_departments VALUES (10, 'SALES');
INSERT INTO new_departments VALUES (20, 'ACCOUNTING');
INSERT INTO new_employees   VALUES (30, 'Scott', 10);
INSERT INTO new_employees   VALUES (31, 'Mary',  10);
INSERT INTO new_employees   VALUES (40, 'John',  20);
INSERT INTO new_employees   VALUES (41, 'Jerry', 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT ("@department_id" NUMBER,
                              department_name  VARCHAR2(20),
                              emplist          emplist_t);
/
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  DBMS_XMLGEN.setRowTag(qryCtx, NULL);
  qryCtx := DBMS_XMLGEN.newContext
    ('SELECT dept_t(department_id,
                    department_name,
                    cast(MULTISET
                         (SELECT e.employee_id, e.last_name
                            FROM new_employees e
                            WHERE e.department_id = d.department_id)
                         AS emplist_t))
        AS deptxml
        FROM new_departments d');
  -- now get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES (result);
  -- close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
SELECT * FROM temp_clob_tab;
</pre><p>Here is the resulting XML:</p><pre class="oac_no_warn" dir="ltr">RESULT
--------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id="10"&gt;
   &lt;DEPARTMENT_NAME&gt;SALES&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id="30"&gt;
     &lt;LAST_NAME&gt;Scott&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id="31"&gt;
     &lt;LAST_NAME&gt;Mary&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id="20"&gt;
   &lt;DEPARTMENT_NAME&gt;ACCOUNTING&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id="40"&gt;
     &lt;LAST_NAME&gt;John&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id="41"&gt;
     &lt;LAST_NAME&gt;Jerry&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">
                        <p class="titleinexample">Example 8-24 DBMS_XMLGEN: Generating XML Using User-Defined Data-Type Instances</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE dept (deptno NUMBER PRIMARY KEY, dname VARCHAR2(20));
CREATE TABLE emp (empno   NUMBER PRIMARY KEY, ename VARCHAR2(20), 
                  deptno  NUMBER REFERENCES dept);
</pre><pre class="oac_no_warn" dir="ltr">-- empno is preceded by an at-sign (@) to indicate that it must 
-- be mapped as an attribute of the enclosing Employee element. 
CREATE TYPE emp_t AS OBJECT ("@empno" NUMBER,  -- empno defined as attribute
                              ename   VARCHAR2(20));
/
INSERT INTO DEPT VALUES (10, 'Sports');
INSERT INTO DEPT VALUES(20, 'Accounting');
INSERT INTO EMP VALUES(200, 'John',  10);
INSERT INTO EMP VALUES(300, 'Jack',  10);
INSERT INTO EMP VALUES(400, 'Mary',  20);
INSERT INTO EMP VALUES(500, 'Jerry', 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT("@deptno" NUMBER, 
                             dname     VARCHAR2(20),
                             emplist   emplist_t);
/
-- Department type dept_t contains a list of employees.
-- You can now query the employee and department tables and get 
-- the result as an XML document, as follows:
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  RESULT CLOB;
BEGIN
  -- get query context
  qryCtx := DBMS_XMLGEN.newContext(
    'SELECT <span class="bold">dept_t</span>(deptno,
                   dname,
                   <span class="bold">cast</span>(<span class="bold">MULTISET</span>
                        (SELECT empno, ename FROM emp e WHERE e.deptno = d.deptno)
                        AS <span class="bold">emplist_t</span>))
       AS deptxml
       FROM dept d');
  -- set maximum number of rows to 5
  DBMS_XMLGEN.setMaxRows(qryCtx, 5);
  -- set no row tag for this result, since there is a single ADT column
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, <span class="bold">NULL</span>);
  LOOP 
    -- get result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- do something with the result
    INSERT INTO temp_clob_tab VALUES (result);
  END LOOP;
END;
/
</pre><p>The <code class="codeph">MULTISET</code> keyword for Oracle SQL function <code class="codeph">cast</code> treats the employees working in the department as a list, which <code class="codeph">cast</code> assigns to the appropriate collection type. A department instance is created using constructor <code class="codeph">dept_t</code>, and <code class="codeph">DBMS_XMLGEN</code> routines create the XML data for the object instance.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM temp_clob_tab;

RESULT
---------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;DEPTXML deptno="10"&gt;
  &lt;DNAME&gt;Sports&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno="200"&gt;
    &lt;ENAME&gt;John&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno="300"&gt;
    &lt;ENAME&gt;Jack&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
 &lt;DEPTXML deptno="20"&gt;
  &lt;DNAME&gt;Accounting&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno="400"&gt;
    &lt;ENAME&gt;Mary&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno="500"&gt;
    &lt;ENAME&gt;Jerry&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1032455">
                        <p class="titleinexample">Example 8-25 DBMS_XMLGEN: Generating an XML Purchase Order</p><pre class="oac_no_warn" dir="ltr">-- Create relational schema and define object views
-- DBMS_XMLGEN maps user-defined data-type attribute names that start
--    with an at-sign (@) to XML attributes
 
-- Purchase Order Object View Model
 
-- PhoneList varray object type
CREATE TYPE phonelist_vartyp AS VARRAY(10) OF VARCHAR2(20)
/
-- Address object type
CREATE TYPE address_typ AS OBJECT(Street VARCHAR2(200),
                                  City   VARCHAR2(200),
                                  State  CHAR(2),
                                  Zip    VARCHAR2(20))
/
-- Customer object type
CREATE TYPE customer_typ AS OBJECT(CustNo    NUMBER,
                                   CustName  VARCHAR2(200),
                                   Address   address_typ,
                                   PhoneList phonelist_vartyp)
/
-- StockItem object type
CREATE TYPE stockitem_typ AS OBJECT("@StockNo" NUMBER,
                                    Price      NUMBER,
                                    TaxRate    NUMBER)
/
-- LineItems object type
CREATE TYPE lineitem_typ AS OBJECT("@LineItemNo" NUMBER,
                                   Item          stockitem_typ,
                                   Quantity      NUMBER,
                                   Discount      NUMBER)
/
-- LineItems ordered collection table
CREATE TYPE lineitems_ntabtyp AS TABLE OF lineitem_typ 
/
-- Purchase Order object type
CREATE TYPE po_typ AUTHID CURRENT_USER
  AS OBJECT(PONO            NUMBER,
            Cust_ref        REF customer_typ,
            OrderDate       DATE,
            ShipDate        TIMESTAMP,
            LineItems_ntab  lineitems_ntabtyp,
            ShipToAddr      address_typ)
/
-- Create Purchase Order relational model tables
-- Customer table
CREATE TABLE customer_tab (CustNo     NUMBER NOT NULL,
                           CustName   VARCHAR2(200),
                           Street     VARCHAR2(200),
                           City       VARCHAR2(200),
                           State      CHAR(2),
                           Zip        VARCHAR2(20),
                           Phone1     VARCHAR2(20),
                           Phone2     VARCHAR2(20),
                           Phone3     VARCHAR2(20),
                           CONSTRAINT cust_pk PRIMARY KEY (CustNo));
-- Purchase Order table
CREATE TABLE po_tab (PONo       NUMBER,        /* purchase order number */
                     Custno     NUMBER     /*  foreign KEY referencing customer */
                                CONSTRAINT po_cust_fk REFERENCES customer_tab, 
                     OrderDate  DATE,          /*  date of order */  
                     ShipDate   TIMESTAMP,     /* date to be shipped */    
                     ToStreet   VARCHAR2(200), /* shipto address */    
                     ToCity     VARCHAR2(200),    
                     ToState    CHAR(2),    
                     ToZip      VARCHAR2(20),
                     CONSTRAINT po_pk PRIMARY KEY(PONo));    
--Stock Table
CREATE TABLE stock_tab (StockNo NUMBER CONSTRAINT stock_uk UNIQUE,
                        Price   NUMBER,
                        TaxRate NUMBER);
--Line Items table
CREATE TABLE lineitems_tab (LineItemNo NUMBER,
                            PONo       NUMBER
                                       CONSTRAINT li_po_fk REFERENCES po_tab,
                            StockNo    NUMBER,
                            Quantity   NUMBER,
                            Discount   NUMBER,
                            CONSTRAINT li_pk PRIMARY KEY (PONo, LineItemNo));
-- Create Object views
-- Customer Object View
CREATE OR REPLACE VIEW customer OF customer_typ
  WITH OBJECT IDENTIFIER(CustNo)
  AS SELECT c.custno, c.custname,
            address_typ(c.street, c.city, c.state, c.zip),
            phonelist_vartyp(phone1, phone2, phone3)
       FROM customer_tab c;
--Purchase order view
CREATE OR REPLACE VIEW po OF po_typ
  WITH OBJECT IDENTIFIER (PONo)
  AS SELECT p.pono, make_ref(Customer, P.Custno), p.orderdate, p.shipdate,
            cast(MULTISET
                 (SELECT lineitem_typ(l.lineitemno,
                                      stockitem_typ(l.stockno, s.price,
                                                    s.taxrate),
                                      l.quantity, l.discount)
                    FROM lineitems_tab l, stock_tab s
                    WHERE l.pono = p.pono AND s.stockno=l.stockno)
                 AS lineitems_ntabtyp),
            address_typ(p.tostreet,p.tocity, p.tostate, p.tozip)
       FROM po_tab p;
-- Create table with XMLType column to store purchase order in XML format
CREATE TABLE po_xml_tab (poid  NUMBER, podoc XMLType)
/
-- Populate data
-------------------
-- Establish Inventory
INSERT INTO stock_tab VALUES(1004, 6750.00, 2);
INSERT INTO stock_tab VALUES(1011, 4500.23, 2);
INSERT INTO stock_tab VALUES(1534, 2234.00, 2);
INSERT INTO stock_tab VALUES(1535, 3456.23, 2);
-- Register Customers
INSERT INTO customer_tab
  VALUES (1, 'Jean Nance', '2 Avocet Drive',
          'Redwood Shores', 'CA', '95054',
          '415-555-1212', NULL, NULL);
INSERT INTO customer_tab
  VALUES (2, 'John Nike', '323 College Drive',
          'Edison', 'NJ', '08820',
          '609-555-1212', '201-555-1212', NULL);
-- Place orders
INSERT INTO po_tab
  VALUES (1001, 1, '10-APR-1997', '10-MAY-1997',
          NULL, NULL, NULL, NULL);
INSERT INTO po_tab
  VALUES (2001, 2, '20-APR-1997', '20-MAY-1997',
          '55 Madison Ave', 'Madison', 'WI', '53715');
-- Detail line items
INSERT INTO lineitems_tab VALUES(01, 1001, 1534, 12,  0);
INSERT INTO lineitems_tab VALUES(02, 1001, 1535, 10, 10);
INSERT INTO lineitems_tab VALUES(01, 2001, 1004,  1,  0);
INSERT INTO lineitems_tab VALUES(02, 2001, 1011,  2,  1);
 
-- Use package DBMS_XMLGEN to generate purchase order in XML format
--   and store XMLType in table po_xml 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  pxml XMLType;
  cxml CLOB;
BEGIN
  -- get query context;
  qryCtx := DBMS_XMLGEN.newContext('SELECT pono,deref(cust_ref) customer,
                                           p.orderdate,
                                           p.shipdate,
                                           lineitems_ntab lineitems,
                                           shiptoaddr
                                      FROM po p');
  -- set maximum number of rows to be 1,
  DBMS_XMLGEN.setMaxRows(qryCtx, 1);
  -- set ROWSET tag to NULL and ROW tag to PurchaseOrder
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryCtx, <span class="bold">NULL</span>);
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, '<span class="bold">PurchaseOrder</span>');
  LOOP 
    -- get purchase order in XML format
    pxml := DBMS_XMLGEN.getXMLType(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- Store XMLType po in po_xml table (get the pono out)
    INSERT INTO po_xml_tab(poid, poDoc)
      VALUES(XMLCast(XMLQuery('//PONO/text()' PASSING pxml RETURNING CONTENT)
                     AS NUMBER),
             pxml);
  END LOOP;
END;
/
</pre><p>This query then produces two XML purchase-order documents:</p><pre class="oac_no_warn" dir="ltr">SELECT XMLSerialize(DOCUMENT x.podoc AS CLOB) xpo FROM po_xml_tab x;

XPO
---------------------------------------------------
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;1001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;1&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;Jean Nance&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;2 Avocet Drive&lt;/STREET&gt;
    &lt;CITY&gt;Redwood Shores&lt;/CITY&gt;
    &lt;STATE&gt;CA&lt;/STATE&gt;
    &lt;ZIP&gt;95054&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;415-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;10-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;10-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo="1"&gt;
    &lt;ITEM StockNo="1534"&gt;
     &lt;PRICE&gt;2234&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;12&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo="2"&gt;
    &lt;ITEM StockNo="1535"&gt;
     &lt;PRICE&gt;3456.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;10&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR/&gt;
 &lt;/PurchaseOrder&gt;
 
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;2001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;2&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;John Nike&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;323 College Drive&lt;/STREET&gt;
    &lt;CITY&gt;Edison&lt;/CITY&gt;
    &lt;STATE&gt;NJ&lt;/STATE&gt;
    &lt;ZIP&gt;08820&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;609-555-1212&lt;/VARCHAR2&gt;
    &lt;VARCHAR2&gt;201-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;20-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;20-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo="1"&gt;
    &lt;ITEM StockNo="1004"&gt;
     &lt;PRICE&gt;6750&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;1&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo="2"&gt;
    &lt;ITEM StockNo="1011"&gt;
     &lt;PRICE&gt;4500.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;2&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;1&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR&gt;
   &lt;STREET&gt;55 Madison Ave&lt;/STREET&gt;
   &lt;CITY&gt;Madison&lt;/CITY&gt;
   &lt;STATE&gt;WI&lt;/STATE&gt;
   &lt;ZIP&gt;53715&lt;/ZIP&gt;
  &lt;/SHIPTOADDR&gt;
 &lt;/PurchaseOrder&gt;
 
2 rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">
                        <p class="titleinexample">Example 8-26 DBMS_XMLGEN: Generating a New Context Handle from a REF Cursor</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (122, 'Scott',  301);
1 row created.
INSERT INTO emp_tab VALUES (123, 'Mary',   472);
1 row created.
INSERT INTO emp_tab VALUES (124, 'John',   93);
1 row created.
INSERT INTO emp_tab VALUES (125, 'Howard', 488);
1 row created.
INSERT INTO emp_tab VALUES (126, 'Sue',    16);
1 row created.
COMMIT;
 
DECLARE
  ctx     NUMBER;
  maxrow  NUMBER;
  xmldoc  CLOB;
  refcur  SYS_REFCURSOR;
BEGIN
  DBMS_LOB.createtemporary(xmldoc, TRUE);
  maxrow := 3;
  OPEN refcur FOR 'SELECT * FROM emp_tab WHERE ROWNUM &lt;= :1' USING maxrow;
  ctx := DBMS_XMLGEN.newContext(refcur);
   -- xmldoc will have 3 rows
  DBMS_XMLGEN.getXML(ctx, xmldoc, DBMS_XMLGEN.NONE);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_LOB.freetemporary(xmldoc);
  CLOSE refcur;
  DBMS_XMLGEN.closeContext(ctx);
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;122&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
  &lt;DEPT_ID&gt;301&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;123&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID&gt;472&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;124&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID&gt;93&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">
                        <p class="titleinexample">Example 8-27 DBMS_XMLGEN: Specifying NULL Handling</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (30, 'Scott', NULL);
1 row created.
INSERT INTO emp_tab VALUES (31, 'Mary', NULL);
1 row created.
INSERT INTO emp_tab VALUES (40, 'John', NULL);
1 row created.
COMMIT;
CREATE TABLE temp_clob_tab (result CLOB);
Table created.
 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext('SELECT * FROM emp_tab where name = :NAME');
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, 'EMPLOYEE');
  -- Drop nulls
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'Scott');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.DROP_NULLS);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Null attribute
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'Mary');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.NULL_ATTR);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Empty tag
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'John');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.EMPTY_TAG);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
 
PL/SQL procedure successfully completed.
 
SELECT * FROM temp_clob_tab;
 
RESULT
-------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;30&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;31&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID xsi:nil = "true"/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;40&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
3 rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">
                        <p class="titleinexample">Example 8-28 DBMS_XMLGEN: Generating Recursive XML with a Hierarchical Query</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sqlx_display (id NUMBER, xmldoc XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result XMLType;
BEGIN
  qryctx := 
    DBMS_XMLGEN.<span class="bold">newContextFromHierarchy</span>(
      'SELECT level, 
              XMLElement("employees", 
                         XMLElement("enumber", employee_id),
                         XMLElement("name", last_name),
                         XMLElement("Salary", salary),
                         XMLElement("Hiredate", hire_date))
         FROM hr.employees
         START WITH last_name=''De Haan'' CONNECT BY PRIOR employee_id=manager_id
         ORDER SIBLINGS BY hire_date');
  result := DBMS_XMLGEN.getxmltype(qryctx);
  DBMS_OUTPUT.put_line('<span class="bold">&lt;result num rows&gt;</span>');
  DBMS_OUTPUT.put_line(<span class="bold">to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx))</span>);
  DBMS_OUTPUT.put_line('<span class="bold">&lt;/result num rows&gt;</span>');
  INSERT INTO sqlx_display VALUES (2, result);
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
<span class="bold">&lt;result num rows&gt;</span>
<span class="bold">6</span>
<span class="bold">&lt;/result num rows&gt;</span>
PL/SQL procedure successfully completed.

SELECT xmldoc FROM sqlx_display WHERE id = 2;

XMLDOC
-----------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;employees&gt;
  &lt;enumber&gt;102&lt;/enumber&gt;
  &lt;name&gt;De Haan&lt;/name&gt;
  &lt;Salary&gt;17000&lt;/Salary&gt;
  &lt;Hiredate&gt;2001-01-13&lt;/Hiredate&gt;
  &lt;employees&gt;
    &lt;enumber&gt;103&lt;/enumber&gt;
    &lt;name&gt;Hunold&lt;/name&gt;
    &lt;Salary&gt;9000&lt;/Salary&gt;
    &lt;Hiredate&gt;2006-01-03&lt;/Hiredate&gt;
    &lt;employees&gt;
      &lt;enumber&gt;105&lt;/enumber&gt;
      &lt;name&gt;Austin&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2005-06-25&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;106&lt;/enumber&gt;
      &lt;name&gt;Pataballa&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2006-02-05&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;107&lt;/enumber&gt;
      &lt;name&gt;Lorentz&lt;/name&gt;
      &lt;Salary&gt;4200&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-02-07&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;104&lt;/enumber&gt;
      &lt;name&gt;Ernst&lt;/name&gt;
      &lt;Salary&gt;6000&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-05-21&lt;/Hiredate&gt;
    &lt;/employees&gt;
  &lt;/employees&gt;
&lt;/employees&gt;

1 row selected.
</pre><p>By default, the <code class="codeph">ROWSET</code> tag is <code class="codeph">NULL</code>: there is no default <code class="codeph">ROWSET</code> tag used to enclose the XML result. However, you can explicitly set the <code class="codeph">ROWSET</code> tag by using procedure <code class="codeph">setRowSetTag</code>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE gg (x XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result CLOB;
BEGIN
  qryctx := DBMS_XMLGEN.newContextFromHierarchy(
              'SELECT level,
                      XMLElement("NAME", last_name) AS myname FROM hr.employees
               CONNECT BY PRIOR employee_id=manager_id
               START WITH employee_id = 102');
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryctx, '<span class="bold">mynum_hierarchy</span>');
  result:=DBMS_XMLGEN.getxml(qryctx);
  DBMS_OUTPUT.put_line('&lt;result num rows&gt;');
  DBMS_OUTPUT.put_line(to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx)));
  DBMS_OUTPUT.put_line('&lt;/result num rows&gt;');
  INSERT INTO gg VALUES(XMLType(result));
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
&lt;result num rows&gt;
6
&lt;/result num rows&gt;
PL/SQL procedure successfully completed.

SELECT * FROM gg;
 
X
----------------------------------------------------------
&lt;?xml version="1.0"?&gt;
<span class="bold">&lt;mynum_hierarchy&gt;</span>
  &lt;NAME&gt;De Haan
    &lt;NAME&gt;Hunold
      &lt;NAME&gt;Ernst&lt;/NAME&gt;
      &lt;NAME&gt;Austin&lt;/NAME&gt;
      &lt;NAME&gt;Pataballa&lt;/NAME&gt;
      &lt;NAME&gt;Lorentz&lt;/NAME&gt;
    &lt;/NAME&gt;
  &lt;/NAME&gt;
<span class="bold">&lt;/mynum_hierarchy&gt;</span>
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">
                        <p class="titleinexample">Example 8-29 DBMS_XMLGEN: Binding Query Variables Using SETBINDVALUE() </p><pre class="oac_no_warn" dir="ltr">-- <span class="bold">Bind one variable</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext(
           'SELECT * FROM employees WHERE employee_id = <span class="bold">:NO</span>');
  DBMS_XMLGEN.<span class="bold">setBindValue</span>(ctx, '<span class="bold">NO</span>', '<span class="bold">145</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;01-OCT-04&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.
</pre><pre class="oac_no_warn" dir="ltr">-- <span class="bold">Bind one variable twice with different values</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext('SELECT * FROM employees
                                   WHERE hire_date = <span class="bold">:MDATE</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">01-OCT-04</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">10-MAR-05</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;145&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;147&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alberto&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Errazuriz&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AERRAZUR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429278&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-05</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;12000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;159&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lindsey&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Smith&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LSMITH&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1345.729268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-97</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_REP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;8000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;146&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.</pre><pre class="oac_no_warn" dir="ltr">-- <span class="bold">Bind two variables</span> 
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext('SELECT * FROM employees
                                   WHERE employee_id = <span class="bold">:NO</span>
                                     AND hire_date = <span class="bold">:MDATE</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">NO</span>', '<span class="bold">145</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">01-OCT-04</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5077"></a><a id="ADXDB5076"></a><div class="props_rev_3"><a id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" name="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42"></a><h3 id="ADXDB-GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" class="sect3"><span class="enumeration_section">8.4 </span>SYS_XMLAGG Oracle SQL Function
               </h3>
               <div>
                  <p>Oracle SQL function <code class="codeph">sys_XMLAgg</code> aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named <code class="codeph">ROWSET</code> (by default).
                  </p>
                  <div class="section">
                     <p>Oracle function <code class="codeph">sys_XMLAgg</code> is similar to standard SQL/XML function <code class="codeph">XMLAgg</code>, but <code class="codeph">sys_XMLAgg</code> returns a single node and it accepts an <code class="codeph">XMLFormat</code> parameter. You can use that parameter to format the resulting XML document in various ways. 
                     </p>
                     <div class="figure" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-44EF0E58-5359-4AE0-B6BF-14DAE9668D71">
                        <p class="titleinfigure">Figure 8-13 SYS_XMLAGG Syntax</p><img src="img/sys_xmlagg.gif" width="269" alt="Description of Figure 8-13 follows" title="Description of Figure 8-13 follows" longdesc="img_text/sys_xmlagg.html"><br><a href="img_text/sys_xmlagg.html">Description of "Figure 8-13 SYS_XMLAGG Syntax"</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-B288356C-F8AA-42FB-941B-5F450F25C773">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../sqlrf/SYS_XMLAGG.html#SQLRF51840" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about <code class="codeph">sys_XMLAgg</code></p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/Format-Models.html#SQLRF51092" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about an <code class="codeph">XMLFormat</code> parameter
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5085"></a><a id="ADXDB5084"></a><div class="props_rev_3"><a id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" name="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130"></a><h3 id="ADXDB-GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" class="sect3"><span class="enumeration_section">8.5 </span>Ordering Query Results Before Aggregating, Using XMLAGG ORDER BY Clause
               </h3>
               <div>
                  <p>To use the <code class="codeph">XMLAgg ORDER BY</code> clause before aggregation, specify the <code class="codeph">ORDER BY</code> clause following the first <code class="codeph">XMLAGG</code> argument. 
                  </p>
                  <div class="section">
                     <p>This is illustrated in <a href="generation-of-XML-data-from-relational-data.html#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">Example 8-30</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">
                     <p class="titleinexample">Example 8-30 Using XMLAGG ORDER BY Clause</p><pre class="pre codeblock"><code>CREATE TABLE dev_tab (dev         NUMBER,
                      dev_total   NUMBER,
                      devname     VARCHAR2(20));
Table created.
INSERT INTO dev_tab VALUES (16, 5,  'Alexis');
1 row created.
INSERT INTO dev_tab VALUES (2,  14, 'Han');
1 row created.
INSERT INTO dev_tab VALUES (1,  2,  'Jess');
1 row created.
INSERT INTO dev_tab VALUES (9,  88, 'Kurt');
1 row created.
COMMIT;
</code></pre><p>The result of the following query is aggregated according to the order of the <code class="codeph">dev</code> column. (The result is shown here pretty-printed, for clarity.)
                     </p><pre class="pre codeblock"><code>SELECT XMLAgg(XMLElement("Dev", 
                         XMLAttributes(dev AS "id", dev_total AS "total"),
                         devname) 
              ORDER BY dev) 
  FROM dev_tab dev_total;

XMLAGG(XMLELEMENT("DEV",XMLATTRIBUTES(DEVAS"ID",DEV_TOTALAS"TOTAL"),DEVNAME)ORDE
--------------------------------------------------------------------------------
&lt;Dev id="<span class="bold">1</span>" total="2"&gt;Jess&lt;/Dev&gt;
&lt;Dev id="<span class="bold">2</span>" total="14"&gt;Han&lt;/Dev&gt;
&lt;Dev id="<span class="bold">9</span>" total="88"&gt;Kurt&lt;/Dev&gt;
&lt;Dev id="<span class="bold">16</span>" total="5"&gt;Alexis&lt;/Dev&gt;
 
1 row selected.</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5087"></a><a id="ADXDB5086"></a><div class="props_rev_3"><a id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" name="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384"></a><h3 id="ADXDB-GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" class="sect3"><span class="enumeration_section">8.6 </span>Returning a Rowset Using XMLTABLE
               </h3>
               <div>
                  <p>You can use standard SQL/XML function <code class="codeph">XMLTable</code> to return a rowset with relevant portions of a document extracted as multiple rows. 
                  </p>
                  <div class="section">
                     <p>This is shown in <a href="generation-of-XML-data-from-relational-data.html#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">Example 8-31</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">
                     <p class="titleinexample">Example 8-31 Returning a Rowset Using XMLTABLE</p><pre class="pre codeblock"><code>CONNECT oe
Enter password: <span class="italic">password</span>

Connected.

SELECT item.descr, item.partid
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem' PASSING OBJECT_VALUE
                COLUMNS descr  VARCHAR2(256) PATH 'Description',
                        partid VARCHAR2(14)  PATH 'Part/@Id') item
  WHERE item.partid = '715515012027'
     OR item.partid = '715515011921'
  ORDER BY partid;
</code></pre><p>This returns a rowset with just the descriptions and part IDs, ordered by part ID.</p><pre class="pre codeblock"><code>DESCR
--------------
PARTID
--------------
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921

My Man Godfrey
715515011921

My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
16 rows selected.</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">Footnote Legend</p>Footnote&nbsp;1: 
            <p>The SQL/XML standard requires argument <span class="italic"><code class="codeph">data-type</code></span> to be present, but it is <span class="italic">optional</span> in the Oracle XML&nbsp;DB implementation of the standard, for ease of use.
            </p><br>Footnote&nbsp;2: 
            <p>The limit is 32767 or 4000 bytes, depending on the value of initialization parameter <code class="codeph">MAX_STRING_SIZE</code>.  See <a href="../sqlrf/Data-Types.html#SQLRF55623" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a>.
            </p><br></div>
      </article>
   </body>
</html>