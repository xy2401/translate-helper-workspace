<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>I/O Configuration and Design</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Performance Tuning Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Performance Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-performance-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-12T22:26:14-07:00">
      <meta name="dcterms.title" content="Database Performance Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2007, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96347-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="part-IV-managing-system-resources.html" title="Previous" type="text/html">
      <link rel="next" href="managing-operating-system-resources.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGDBA">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="part-IV-managing-system-resources.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="managing-operating-system-resources.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Performance Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-IV-managing-system-resources.html" property="item" typeof="WebPage"><span property="name">Managing System Resources </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> I/O Configuration and Design</li>
            </ol>
            <a id="GUID-B89C41F4-B12A-49E1-BFB9-5BF978E2D6B3" name="GUID-B89C41F4-B12A-49E1-BFB9-5BF978E2D6B3"></a><a id="TGDBA015"></a>
            
            <h2 id="TGDBA-GUID-B89C41F4-B12A-49E1-BFB9-5BF978E2D6B3" class="sect2"><span class="enumeration_chapter">17 </span> I/O Configuration and Design
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>The I/O subsystem is a vital component of an Oracle database. This chapter introduces fundamental I/O concepts, discusses the I/O requirements of different parts of the database, and provides sample configurations for I/O subsystem design.</p>
               <p>This chapter includes the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="IO-configuration-and-design.html#GUID-96CEF863-67AC-47BE-8834-8AB42864FC6E">About I/O</a></p>
                  </li>
                  <li>
                     <p><a href="IO-configuration-and-design.html#GUID-FC77DFCF-FFDC-4669-BAC2-3254E3A75468">I/O Configuration</a></p>
                  </li>
                  <li>
                     <p><a href="IO-configuration-and-design.html#GUID-08ED4172-9398-402E-B0C4-4CE88DE87603">I/O Calibration Inside the Database</a></p>
                  </li>
                  <li>
                     <p><a href="IO-configuration-and-design.html#GUID-355C99D8-29C1-421F-8B65-47A3C48324A2">I/O Calibration with the Oracle Orion Calibration Tool</a></p>
                  </li>
               </ul>
            </div><a id="TGDBA94381"></a><div class="props_rev_3"><a id="GUID-96CEF863-67AC-47BE-8834-8AB42864FC6E" name="GUID-96CEF863-67AC-47BE-8834-8AB42864FC6E"></a><h3 id="TGDBA-GUID-96CEF863-67AC-47BE-8834-8AB42864FC6E" class="sect3"><span class="enumeration_section">17.1 </span>About I/O
               </h3>
               <div>
                  <p>Every Oracle database reads or writes data on disk, thus generating <span class="bold">disk I/O</span>. The performance of many software applications is inherently limited by disk I/O. Applications that spend majority of their CPU time waiting for I/O activity to complete are said to be <span class="bold">I/O-bound</span>.
                  </p>
                  <p>Oracle Database is designed so that if an application is well written, its performance should not be limited by I/O. Tuning I/O can enhance the performance of the application if the I/O system is operating at or near capacity and is not able to service the I/O requests within an acceptable time. However, tuning I/O cannot help performance if the application is not I/O-bound (for example, when CPU is the limiting factor).</p>
                  <p>Consider the following database requirements when designing an I/O system:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Storage, such as minimum disk capacity</p>
                     </li>
                     <li>
                        <p>Availability, such as continuous (24 x 7) or business hours only</p>
                     </li>
                     <li>
                        <p>Performance, such as I/O throughput and application response times</p>
                     </li>
                  </ul>
                  <p>Many I/O designs plan for storage and availability requirements with the assumption that performance will not be an issue. This is not always the case. Optimally, the number of disks and controllers to be configured should be determined by I/O throughput and redundancy requirements. The size of disks can then be determined by the storage requirements.</p>
                  <p>When developing an I/O design plan, consider using <span class="bold">Oracle Automatic Storage Management (Oracle ASM)</span>. Oracle ASM is an integrated, high-performance database file system and disk manager that is based on the principle that the database should manage storage instead of requiring an administrator to do it.
                  </p>
                  <p>Oracle recommends that you use Oracle ASM for your database file storage, instead of raw devices or the operating system file system. Oracle ASM provides the following key benefits:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Striping</p>
                     </li>
                     <li>
                        <p>Mirroring</p>
                     </li>
                     <li>
                        <p>Online storage reconfiguration and dynamic rebalancing</p>
                     </li>
                     <li>
                        <p>Managed file creation and deletion</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-96CEF863-67AC-47BE-8834-8AB42864FC6E__GUID-696D8E4F-DD24-448B-9829-23C7A3617562">
                     <p class="notep1">See Also:</p>
                     <p><a href="../ostmg/asm-intro.html#OSTMG036" target="_blank"><span class="italic">Oracle Automatic Storage Management Administrator's Guide</span></a> for additional information about Oracle ASM
                     </p>
                  </div>
               </div>
            </div><a id="TGDBA94385"></a><div class="props_rev_3"><a id="GUID-FC77DFCF-FFDC-4669-BAC2-3254E3A75468" name="GUID-FC77DFCF-FFDC-4669-BAC2-3254E3A75468"></a><h3 id="TGDBA-GUID-FC77DFCF-FFDC-4669-BAC2-3254E3A75468" class="sect3"><span class="enumeration_section">17.2 </span>I/O Configuration
               </h3>
               <div>
                  <p>This section describes the basic information to be gathered and decisions to be made when defining a system's I/O configuration. You want to keep the configuration as simple as possible, while maintaining the required availability, recoverability, and performance. The more complex a configuration becomes, the more difficult it is to administer, maintain, and tune.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-8E417FDE-21AB-4FD7-8935-527EE73D3159">Lay Out the Files Using Operating System or Hardware Striping</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-B36A0F16-20AC-4224-8CFB-8B27AA151A39">Manually Distributing I/O</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-CAC9BBAD-5471-4CEB-B406-C8D88620F892">When to Separate Files</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-10F6D20D-4BA4-434C-A4B0-0E4C7CEEE267">Three Sample Configurations</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41">Oracle Managed Files</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-1D9458EB-7D82-47B7-81D8-A5A34D11C92C">Choosing Data Block Size</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94386"></a><div class="props_rev_3"><a id="GUID-8E417FDE-21AB-4FD7-8935-527EE73D3159" name="GUID-8E417FDE-21AB-4FD7-8935-527EE73D3159"></a><h4 id="TGDBA-GUID-8E417FDE-21AB-4FD7-8935-527EE73D3159" class="sect4"><span class="enumeration_section">17.2.1 </span>Lay Out the Files Using Operating System or Hardware Striping
                  </h4>
                  <div>
                     <p>If your operating system has LVM software or hardware-based striping, then it is possible to distribute I/O using these tools.   Decisions to be made when using an LVM or hardware striping include <strong class="term">stripe depth</strong> and <strong class="term">stripe width</strong>.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Stripe depth is the size of the stripe, sometimes called stripe unit.</p>
                        </li>
                        <li>
                           <p>Stripe width is the product of the stripe depth and the number of drives in the striped set.</p>
                        </li>
                     </ul>
                     <p>Choose these values wisely so that the system is capable of sustaining the required throughput. For an Oracle database, reasonable stripe depths range from 256 KB to 1 MB. Different types of applications benefit from different stripe depths. The optimal stripe depth and stripe width depend on the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-30EB6253-9B52-4462-97F1-D729057DB3C3">Requested I/O Size</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-18150B40-D8AE-4A37-955B-4437CDED92F7">Concurrency of I/O Requests</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-47524569-3954-47F9-90ED-83C2E7671C02">Alignment of Physical Stripe Boundaries with Block Size Boundaries</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-BFC8D260-2D73-407E-AE39-A3E17FA846B2">Manageability of the Proposed System</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94388"></a><a id="TGDBA94387"></a><div class="props_rev_3"><a id="GUID-30EB6253-9B52-4462-97F1-D729057DB3C3" name="GUID-30EB6253-9B52-4462-97F1-D729057DB3C3"></a><h5 id="TGDBA-GUID-30EB6253-9B52-4462-97F1-D729057DB3C3" class="sect5"><span class="enumeration_section">17.2.1.1 </span>Requested I/O Size
                     </h5>
                     <div>
                        <p><a href="IO-configuration-and-design.html#GUID-30EB6253-9B52-4462-97F1-D729057DB3C3__g35578" title="This table describes the Oracle and operating system parameters that can be used to set I/O size.">Table 17-1</a> lists the Oracle Database and operating system parameters that you can use to set I/O size:
                        </p>
                        <div class="tblformal" id="GUID-30EB6253-9B52-4462-97F1-D729057DB3C3__g35578">
                           <p class="titleintable">Table 17-1 Oracle Database and Operating System Operational Parameters</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Database and Operating System Operational Parameters" summary="This table describes the Oracle and operating system parameters that can be used to set I/O size." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d52149e409">Parameter</th>
                                    <th align="left" valign="bottom" width="70%" id="d52149e412">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e417" headers="d52149e409 ">
                                       <p><code class="codeph">DB_BLOCK_SIZE </code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e417 d52149e412 ">
                                       <p>The size of single-block I/O requests. This parameter is also used in combination with multiblock parameters to determine multiblock I/O request size.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e425" headers="d52149e409 ">
                                       <p>OS block size </p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e425 d52149e412 ">
                                       <p>Determines I/O size for redo log and archive log operations.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e432" headers="d52149e409 ">
                                       <p>Maximum OS I/O size </p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e432 d52149e412 ">
                                       <p>Places an upper bound on the size of a single I/O request.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e439" headers="d52149e409 ">
                                       <p><code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT </code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e439 d52149e412 ">
                                       <p>The maximum I/O size for full table scans is computed by multiplying this parameter with <code class="codeph">DB_BLOCK_SIZE</code>. (the upper value is subject to operating system limits). If this value is not set explicitly (or is set to 0), the default value corresponds to the maximum I/O size that can be efficiently performed and is platform-dependent.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e450" headers="d52149e409 ">
                                       <p><code class="codeph">SORT_AREA_SIZE </code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e450 d52149e412 ">
                                       <p>Determines I/O sizes and concurrency for sort operations.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d52149e458" headers="d52149e409 ">
                                       <p><code class="codeph">HASH_AREA_SIZE </code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d52149e458 d52149e412 ">
                                       <p>Determines the I/O size for hash operations.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>In addition to I/O size, the degree of concurrency also helps in determining the ideal stripe depth. Consider the following when choosing stripe width and stripe depth:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>On low-concurrency (sequential) systems, ensure that no single I/O visits the same disk twice. For example, assume that the stripe width is four disks, and the stripe depth is 32K. If a single 1MB I/O request (for example, for a full table scan) is issued by an Oracle server process, then each disk in the stripe must perform eight I/Os to return the requested data. To avoid this situation, the size of the average I/O should be smaller than the stripe width multiplied by the stripe depth. If this is not the case, then a single I/O request made by Oracle Database to the operating system results in multiple physical I/O requests to the same disk.</p>
                           </li>
                           <li>
                              <p>On high-concurrency (random) systems, ensure that no single I/O request is broken up into multiple physical I/O calls. Failing to do this multiplies the number of physical I/O requests performed in your system, which in turn can severely degrade the I/O response times.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="TGDBA94389"></a><div class="props_rev_3"><a id="GUID-18150B40-D8AE-4A37-955B-4437CDED92F7" name="GUID-18150B40-D8AE-4A37-955B-4437CDED92F7"></a><h5 id="TGDBA-GUID-18150B40-D8AE-4A37-955B-4437CDED92F7" class="sect5"><span class="enumeration_section">17.2.1.2 </span>Concurrency of I/O Requests
                     </h5>
                     <div>
                        <p>In a system with a high degree of concurrent small I/O requests, such as in a traditional OLTP environment, it is beneficial to keep the stripe depth large. Using stripe depths larger than the I/O size is called <span class="bold">coarse grain striping</span>. In high-concurrency systems, the stripe depth can be as follows, where <span class="italic"><code class="codeph">n</code></span> &gt; 1:
                        </p><pre class="oac_no_warn" dir="ltr"><span class="italic">n</span> * DB_BLOCK_SIZE
</pre><p>Coarse grain striping allows a disk in the array to service several I/O requests. In this way, a large number of concurrent I/O requests can be serviced by a set of striped disks with minimal I/O setup costs. Coarse grain striping strives to maximize overall I/O throughput. Multiblock reads, as in full table scans, will benefit when stripe depths are large and can be serviced from one drive. Parallel query in a data warehouse environment is also a candidate for coarse grain striping because many individual processes each issue separate I/Os. If coarse grain striping is used in systems that do not have high concurrent requests, then hot spots could result. </p>
                        <p>In a system with a few large I/O requests, such as in a traditional DSS environment or a low-concurrency OLTP system, then it is beneficial to keep the stripe depth small. This is called <span class="bold">fine grain striping</span>. In such systems, the stripe depth is as follows, where <span class="italic"><code class="codeph">n</code></span> is smaller than the multiblock read parameters, such as <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code>:
                        </p><pre class="oac_no_warn" dir="ltr"><span class="italic">n</span> * DB_BLOCK_<a id="d52149e554" class="indexterm-anchor"></a>SIZE
</pre><p>Fine grain striping allows a single I/O request to be serviced by multiple disks. Fine grain striping strives to maximize performance for individual I/O requests or response time.</p>
                     </div>
                  </div><a id="TGDBA94391"></a><a id="TGDBA94390"></a><div class="props_rev_3"><a id="GUID-47524569-3954-47F9-90ED-83C2E7671C02" name="GUID-47524569-3954-47F9-90ED-83C2E7671C02"></a><h5 id="TGDBA-GUID-47524569-3954-47F9-90ED-83C2E7671C02" class="sect5"><span class="enumeration_section">17.2.1.3 </span>Alignment of Physical Stripe Boundaries with Block Size Boundaries
                     </h5>
                     <div>
                        <p>On some Oracle Database ports, a database block boundary may not align with the stripe. If your stripe depth is the same size as the database block, then a single I/O issued by Oracle Database may result in two physical I/O operations.</p>
                        <p>This is not optimal in an OLTP environment. To ensure a higher probability of one logical I/O resulting in no more than one physical I/O, the minimum stripe depth should be at least twice the Oracle block size. <a href="IO-configuration-and-design.html#GUID-47524569-3954-47F9-90ED-83C2E7671C02__g35619" title="This table displays recommended minimum stripe depth for randon access and for sequentiol reads.">Table 17-2</a> shows recommended minimum stripe depth for random access and for sequential reads.
                        </p>
                        <div class="tblformal" id="GUID-47524569-3954-47F9-90ED-83C2E7671C02__g35619">
                           <p class="titleintable">Table 17-2 Minimum Stripe Depth</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Minimum Stripe Depth" summary="This table displays recommended minimum stripe depth for randon access and for sequentiol reads." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d52149e629">Disk Access</th>
                                    <th align="left" valign="bottom" width="69%" id="d52149e632">Minimum Stripe Depth</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d52149e637" headers="d52149e629 ">
                                       <p>Random reads and writes</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d52149e637 d52149e632 ">
                                       <p>The minimum stripe depth is twice the Oracle block size.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d52149e644" headers="d52149e629 ">
                                       <p>Sequential reads</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d52149e644 d52149e632 ">
                                       <p>The minimum stripe depth is twice the value of <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code>, multiplied by the Oracle block&nbsp;size.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-47524569-3954-47F9-90ED-83C2E7671C02__GUID-CAE0F929-D363-4D3F-B620-9D05B681984E">
                           <p class="notep1">See Also:</p>
                           <p>The specific documentation for your platform</p>
                        </div>
                     </div>
                  </div><a id="TGDBA94392"></a><div class="props_rev_3"><a id="GUID-BFC8D260-2D73-407E-AE39-A3E17FA846B2" name="GUID-BFC8D260-2D73-407E-AE39-A3E17FA846B2"></a><h5 id="TGDBA-GUID-BFC8D260-2D73-407E-AE39-A3E17FA846B2" class="sect5"><span class="enumeration_section">17.2.1.4 </span>Manageability of the Proposed System
                     </h5>
                     <div>
                        <p>With an LVM, the simplest configuration to manage is one with a single striped volume over all available disks. In this case, the stripe width encompasses all available disks. All database files reside within that volume, effectively distributing the load evenly. This single-volume layout provides adequate performance in most situations.</p>
                        <p>A single-volume configuration is viable only when used in conjunction with RAID technology that allows easy recoverability, such as RAID 1. Otherwise, losing a single disk means losing all files concurrently and, hence, performing a full database restore and recovery.</p>
                        <p>In addition to performance, there is a manageability concern: the design of the system must allow disks to be added simply, to allow for database growth. The challenge is to do so while keeping the load balanced evenly.</p>
                        <p>For example, an initial configuration can involve the creation of a single striped volume over 64 disks, each disk being 16 GB. This is total disk space of 1 terabyte (TB) for the primary data. Sometime after the system is operational, an additional 80 GB (that is, five disks) must be added to account for future database growth.</p>
                        <p>The options for making this space available to the database include creating a second volume that includes the five new disks. However, an I/O bottleneck might develop, if these new disks are unable to sustain the I/O throughput required for the files placed on them.</p>
                        <p>Another option is to increase the size of the original volume. LVMs are becoming sophisticated enough to allow dynamic reconfiguration of the stripe width, which allows disks to be added while the system is online. This begins to make the placement of all files on a single striped volume feasible in a production environment.</p>
                        <p>If your LVM cannot support dynamically adding disks to the stripe, then it is likely that you need to choose a smaller, more manageable stripe width. Then, when new disks are added, the system can grow by a stripe width.</p>
                        <p>In the preceding example, eight disks might be a more manageable stripe width. This is only feasible if eight disks are capable of sustaining the required number of I/Os each second. Thus, when extra disk space is required, another eight-disk stripe can be added, keeping the I/O balanced across the volumes.</p>
                        <div class="infoboxnote" id="GUID-BFC8D260-2D73-407E-AE39-A3E17FA846B2__GUID-6B1AC983-7541-4F39-B491-1D7558680EF0">
                           <p class="notep1">Note:</p>
                           <p>The smaller the stripe width becomes, the more likely it is that you will need to spend time distributing the files on the volumes, and the closer the procedure becomes to manually distributing I/O.</p>
                        </div>
                     </div>
                  </div>
               </div><a id="TGDBA94393"></a><div class="props_rev_3"><a id="GUID-B36A0F16-20AC-4224-8CFB-8B27AA151A39" name="GUID-B36A0F16-20AC-4224-8CFB-8B27AA151A39"></a><h4 id="TGDBA-GUID-B36A0F16-20AC-4224-8CFB-8B27AA151A39" class="sect4"><span class="enumeration_section">17.2.2 </span>Manually Distributing I/O
                  </h4>
                  <div>
                     <p>If your system does not have an LVM or hardware striping, then I/O must be manually balanced across the available disks by distributing the files according to each file's I/O requirements. In order to make decisions on file placement, you should be familiar with the I/O requirements of the database files and the capabilities of the I/O system. If you are not familiar with this data and do not have a representative workload to analyze, you can make a first guess and then tune the layout as the usage becomes known.</p>
                     <p><a id="d52149e776" class="indexterm-anchor"></a>To stripe disks manually, you need to relate a file's storage requirements to its I/O requirements. 
                     </p>
                     <ol>
                        <li>
                           <p>Evaluate database disk-storage requirements by checking the size of the files and the disks.</p>
                        </li>
                        <li>
                           <p>Identify the expected I/O throughput for each file. Determine which files have the highest I/O rate and which do not have many I/Os. Lay out the files on all the available disks so as to even out the I/O rate.</p>
                        </li>
                     </ol>
                     <p> <a id="d52149e790" class="indexterm-anchor"></a><a id="d52149e794" class="indexterm-anchor"></a>One popular approach to manual I/O distribution suggests separating a frequently used table from its index. This is not correct. During the course of a transaction, the index is read first, and then the table is read. Because these I/Os occur sequentially, the table and index can be stored on the same disk without contention. It is not sufficient to separate a data file simply because the data file contains indexes or table data. The decision to segregate a file should be made only when the I/O rate for that file affects database performance.
                     </p>
                  </div>
               </div><a id="TGDBA94394"></a><div class="props_rev_3"><a id="GUID-CAC9BBAD-5471-4CEB-B406-C8D88620F892" name="GUID-CAC9BBAD-5471-4CEB-B406-C8D88620F892"></a><h4 id="TGDBA-GUID-CAC9BBAD-5471-4CEB-B406-C8D88620F892" class="sect4"><span class="enumeration_section">17.2.3 </span>When to Separate Files
                  </h4>
                  <div>
                     <p>Regardless of whether you use operating system striping or manual I/O distribution, if the I/O system or I/O layout is not able to support the I/O rate required, then you need to separate files with high I/O rates from the remaining files. You can identify such files either at the planning stage or after the system is live.</p>
                     <p>The decision to segregate files should only be driven by I/O rates, recoverability concerns, or manageability issues. (For example, if your LVM does not support dynamic reconfiguration of stripe width, then you might need to create smaller stripe widths to be able to add <span class="italic">n</span> disks at a time to create a new stripe of identical configuration.)
                     </p>
                     <p>Before segregating files, verify that the bottleneck is truly an I/O issue.<span class="bold"> </span>The data produced from investigating the bottleneck identifies which files have the highest I/O rates.
                     </p>
                     <p>The following sections describe how to segregate the following file types:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-BF22AB54-E425-405A-BC4A-2368415AF37F">Tables, Indexes, and TEMP Tablespaces</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-5740500F-777F-40F1-9008-1A62C5F6B66A">Redo Log Files</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128">Archived Redo Logs</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94395"></a><div class="props_rev_3"><a id="GUID-BF22AB54-E425-405A-BC4A-2368415AF37F" name="GUID-BF22AB54-E425-405A-BC4A-2368415AF37F"></a><h5 id="TGDBA-GUID-BF22AB54-E425-405A-BC4A-2368415AF37F" class="sect5"><span class="enumeration_section">17.2.3.1 </span>Tables, Indexes, and TEMP Tablespaces
                     </h5>
                     <div>
                        <p>If the files with high I/O are data files belonging to tablespaces that contain tables and indexes, then identify whether the I/O for those files can be reduced by tuning SQL or application code.<span class="bold"> </span></p>
                        <p>If the files with high-I/O are data files that belong to the <code class="codeph">TEMP</code> tablespace, then investigate whether to tune the SQL statements performing disk sorts to avoid this activity, or to tune the sorting.
                        </p>
                        <p>After the application has been tuned to avoid unnecessary I/O, if the I/O layout is still not able to sustain the required throughput, then consider segregating the high-I/O files.</p>
                     </div>
                  </div><a id="TGDBA94396"></a><div class="props_rev_3"><a id="GUID-5740500F-777F-40F1-9008-1A62C5F6B66A" name="GUID-5740500F-777F-40F1-9008-1A62C5F6B66A"></a><h5 id="TGDBA-GUID-5740500F-777F-40F1-9008-1A62C5F6B66A" class="sect5"><span class="enumeration_section">17.2.3.2 </span>Redo Log Files
                     </h5>
                     <div>
                        <p>If the high-I/O files are redo log files, then consider splitting the redo log files from the other files. <a id="d52149e990" class="indexterm-anchor"></a>Possible configurations can include the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Placing all redo logs on one disk without any other files. Also consider availability; members of the same group should be on different physical disks and controllers for recoverability purposes.</p>
                           </li>
                           <li>
                              <p>Placing each redo log group on a separate disk that does not store any other files.</p>
                           </li>
                           <li>
                              <p>Striping the redo log files across several disks, using an operating system striping tool. (Manual striping is not possible in this situation.)</p>
                           </li>
                           <li>
                              <p>Avoiding the use of RAID 5 for redo logs.</p>
                           </li>
                        </ul>
                        <p>Redo log files are written sequentially by the Log Writer (LGWR) process<a id="d52149e1010" class="indexterm-anchor"></a>. This operation can be made faster if there is no concurrent activity on the same disk. Dedicating a separate disk to redo log files usually ensures that LGWR runs smoothly with no further tuning necessary. If your system supports asynchronous I/O but this feature is not currently configured, then test to see if using this feature is beneficial. Performance bottlenecks related to LGWR are rare.
                        </p>
                     </div>
                  </div><a id="TGDBA94398"></a><a id="TGDBA94397"></a><div class="props_rev_3"><a id="GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128" name="GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128"></a><h5 id="TGDBA-GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128" class="sect5"><span class="enumeration_section">17.2.3.3 </span>Archived Redo Logs
                     </h5>
                     <div>
                        <p>If the archiver is slow, then it might be prudent to prevent I/O contention between the archiver process and LGWR by ensuring that archiver reads and LGWR writes are separated. This is achieved by placing logs on alternating drives. </p>
                        <p>For example, suppose a system has four redo log groups, each group with two members. To create separate-disk access, the eight log files should be labeled 1a, 1b, 2a, 2b, 3a, 3b, 4a, and 4b. This requires at least four disks, plus one disk for archived files.</p>
                        <p>The following figure illustrates how redo members should be distributed across disks to minimize contention.</p>
                        <div class="figure" id="GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128__I21803">
                           <p class="titleinfigure">Figure 17-1 Distributing Redo Members Across Disks</p><img src="img/figure_171_distributing_redo_members_across_disks.png" alt="Description of Figure 17-1 follows" title="Description of Figure 17-1 follows" longdesc="img_text/figure_171_distributing_redo_members_across_disks.html"><br><a href="img_text/figure_171_distributing_redo_members_across_disks.html">Description of "Figure 17-1 Distributing Redo Members Across Disks"</a></div>
                        <!-- class="figure" -->
                        <p>In this example, LGWR switches out of log group 1 (member 1a and 1b) and writes to log group 2 (2a and 2b). Concurrently, the archiver process reads from group 1 and writes to its archive destination. Note how the redo log files are isolated from contention.</p>
                        <div class="infoboxnote" id="GUID-7BC339EF-5491-4F08-A9E3-AE4616A5D128__GUID-A0289EDB-3C81-486E-9D60-3F494843EE07">
                           <p class="notep1">Note:</p>
                           <p>Mirroring<a id="d52149e1082" class="indexterm-anchor"></a> redo log files<a id="d52149e1087" class="indexterm-anchor"></a>, or maintaining multiple copies of each redo log file on separate disks, does not slow LGWR considerably. LGWR writes to each disk in parallel and waits until each part of the parallel write is complete. Thus, a parallel write does not take longer than the longest possible single-disk write.
                           </p>
                        </div>
                        <p>Because redo logs are written serially, drives dedicated to redo log activity generally require limited head movement. This significantly accelerates log writing.</p>
                     </div>
                  </div>
               </div><a id="TGDBA94399"></a><div class="props_rev_3"><a id="GUID-10F6D20D-4BA4-434C-A4B0-0E4C7CEEE267" name="GUID-10F6D20D-4BA4-434C-A4B0-0E4C7CEEE267"></a><h4 id="TGDBA-GUID-10F6D20D-4BA4-434C-A4B0-0E4C7CEEE267" class="sect4"><span class="enumeration_section">17.2.4 </span>Three Sample Configurations
                  </h4>
                  <div>
                     <p>This section contains three high-level examples of configuring I/O systems. These examples include sample calculations that define the disk topology, stripe depths, and so on:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-E4BEEF56-D019-4903-A87B-BA0751FF30EC">Stripe Everything Across Every Disk</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-671FA7BB-AF35-4359-8502-89C533185B16">Move Archive Logs to Different Disks</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-B26312AA-734B-40F4-BC42-341F365290C5">Move Redo Logs to Separate Disks</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94400"></a><div class="props_rev_3"><a id="GUID-E4BEEF56-D019-4903-A87B-BA0751FF30EC" name="GUID-E4BEEF56-D019-4903-A87B-BA0751FF30EC"></a><h5 id="TGDBA-GUID-E4BEEF56-D019-4903-A87B-BA0751FF30EC" class="sect5"><span class="enumeration_section">17.2.4.1 </span>Stripe Everything Across Every Disk
                     </h5>
                     <div>
                        <p>The simplest approach to I/O configuration is to build one giant volume, striped across all available disks. To account for recoverability, the volume is mirrored (RAID 1). The striping unit for each disk should be larger than the maximum I/O size for the frequent I/O operations. This provides adequate performance for most cases.</p>
                     </div>
                  </div><a id="TGDBA94401"></a><div class="props_rev_3"><a id="GUID-671FA7BB-AF35-4359-8502-89C533185B16" name="GUID-671FA7BB-AF35-4359-8502-89C533185B16"></a><h5 id="TGDBA-GUID-671FA7BB-AF35-4359-8502-89C533185B16" class="sect5"><span class="enumeration_section">17.2.4.2 </span>Move Archive Logs to Different Disks
                     </h5>
                     <div>
                        <p>If archived redo log files are striped on the same set of disks as other files, then any I/O requests on those disks could suffer when the database is archiving the redo logs. Moving archived redo log files to separate disks provides the following benefits:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The archive can be performed at very high rate (using sequential I/O).</p>
                           </li>
                           <li>
                              <p>Nothing else is affected by the degraded response time on the archive destination disks.</p>
                           </li>
                        </ul>
                        <p>The number of disks for archive logs is determined by the rate of archive log generation and the amount of archive storage required.</p>
                     </div>
                  </div><a id="TGDBA94402"></a><div class="props_rev_3"><a id="GUID-B26312AA-734B-40F4-BC42-341F365290C5" name="GUID-B26312AA-734B-40F4-BC42-341F365290C5"></a><h5 id="TGDBA-GUID-B26312AA-734B-40F4-BC42-341F365290C5" class="sect5"><span class="enumeration_section">17.2.4.3 </span>Move Redo Logs to Separate Disks
                     </h5>
                     <div>
                        <p>In high-update OLTP systems, the redo logs are write-intensive. Moving the redo log files to disks that are separate from other disks and from archived redo log files has the following benefits:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Writing redo logs is performed at the highest possible rate. Hence, transaction processing performance is at its best.</p>
                           </li>
                           <li>
                              <p>Writing of the redo logs is not impaired with any other I/O.</p>
                           </li>
                        </ul>
                        <p>The number of disks for redo logs is mostly determined by the redo log size, which is generally small compared to current technology disk sizes. Typically, a configuration with two disks (possibly mirrored to four disks for fault tolerance) is adequate. In particular, by having the redo log files alternating on two disks, writing redo log information to one file does not interfere with reading a completed redo log for archiving. </p>
                     </div>
                  </div>
               </div><a id="TGDBA94403"></a><div class="props_rev_3"><a id="GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41" name="GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41"></a><h4 id="TGDBA-GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41" class="sect4"><span class="enumeration_section">17.2.5 </span>Oracle Managed Files
                  </h4>
                  <div>
                     <p>When file systems can contain all Oracle Database data, database administration is simplified by using <span class="bold">Oracle Managed Files</span>. Oracle Database internally uses standard file system interfaces to create and delete files as needed for tablespaces, temp files, online logs, and control files. Administrators only specify the file system directory to be used for a particular type of file. You can specify one default location for data files and up to five multiplexed locations for the control and online redo log files.
                     </p>
                     <p>Oracle Database ensures that a unique file is created and then deleted when it is no longer needed. This reduces corruption caused by administrators specifying the wrong file, reduces wasted disk space consumed by obsolete files, and simplifies creation of test and development databases. It also makes development of portable third-party tools easier, because it eliminates the need to put operating system-specific file names in SQL scripts.</p>
                     <p>New files can be created as Oracle Managed Files, while old ones are administered in the old way. Thus, a database can have a mixture of Oracle Managed Files and user-managed files.</p>
                     <div class="infoboxnote" id="GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41__GUID-326FCB81-BDE4-4F54-B01C-E0FB9B7C5AD6">
                        <p class="notep1">Note:</p>
                        <p>Oracle Managed Files cannot be used with raw devices.</p>
                     </div>
                     <p>Several points should be considered when tuning Oracle Managed Files:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Because Oracle Managed Files require the use of a file system, DBAs give up control over how the data is laid out. Therefore, it is important to correctly configure the file system. </p>
                        </li>
                        <li>
                           <p>Build the file system for Oracle Managed Files on top of an LVM that supports striping. For load balancing and improved throughput, stripe the disks in the file system.</p>
                        </li>
                        <li>
                           <p>Oracle Managed Files work best if used on an LVM that supports dynamically extensible logical volumes. Otherwise, configure the logical volumes as large as possible. </p>
                        </li>
                        <li>
                           <p>Oracle Managed Files work best if the file system provides large extensible files.</p>
                           <div class="infoboxnotealso" id="GUID-B8E5CBB5-5944-44D7-A337-EFE8484A0B41__GUID-0589D22E-1EC3-4056-93CC-228BA23B33ED">
                              <p class="notep1">See Also:</p>
                              <p><a href="../admin/using-oracle-managed-files.html#ADMIN-GUID-4A3C4616-0D81-4BBA-8EAD-FCAA8AD5C15A" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for detailed information about using Oracle Managed Files
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="TGDBA94404"></a><div class="props_rev_3"><a id="GUID-1D9458EB-7D82-47B7-81D8-A5A34D11C92C" name="GUID-1D9458EB-7D82-47B7-81D8-A5A34D11C92C"></a><h4 id="TGDBA-GUID-1D9458EB-7D82-47B7-81D8-A5A34D11C92C" class="sect4"><span class="enumeration_section">17.2.6 </span>Choosing Data Block Size
                  </h4>
                  <div>
                     <p>A <a id="d52149e1472" class="indexterm-anchor"></a><a id="d52149e1476" class="indexterm-anchor"></a>block size of 8 KB is optimal for most systems. However, OLTP systems occasionally use smaller block sizes and DSS systems occasionally use larger block sizes. This section discusses considerations when choosing database block size for optimal performance and contains the following topics:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-5E1FB9C7-28D5-43E9-A7E2-CC83A9261458">Reads</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-9784925C-FCCF-435F-89ED-A504839B2658">Writes</a></p>
                        </li>
                        <li>
                           <p><a href="IO-configuration-and-design.html#GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B">Block Size Advantages and Disadvantages</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-1D9458EB-7D82-47B7-81D8-A5A34D11C92C__GUID-E7F5AD9F-D64F-4DEE-8153-7F455697B099">
                        <p class="notep1">Note:</p>
                        <p>The use of multiple block sizes in a single database instance is not encouraged because of manageability issues.</p>
                     </div>
                  </div><a id="TGDBA94405"></a><div class="props_rev_3"><a id="GUID-5E1FB9C7-28D5-43E9-A7E2-CC83A9261458" name="GUID-5E1FB9C7-28D5-43E9-A7E2-CC83A9261458"></a><h5 id="TGDBA-GUID-5E1FB9C7-28D5-43E9-A7E2-CC83A9261458" class="sect5"><span class="enumeration_section">17.2.6.1 </span>Reads
                     </h5>
                     <div>
                        <p>Regardless of the size of the data, the goal is to minimize the number of reads required to retrieve the desired data.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the rows are small and access is predominantly random, then choose a smaller block size.</p>
                           </li>
                           <li>
                              <p>If the rows are small and access is predominantly sequential, then choose a larger block size.</p>
                           </li>
                           <li>
                              <p>If the rows are small and access is both random and sequential, then it might be effective to choose a larger block size.</p>
                           </li>
                           <li>
                              <p>If the rows are large, such as rows containing large object (LOB) data, then choose a larger block size. </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="TGDBA94406"></a><div class="props_rev_3"><a id="GUID-9784925C-FCCF-435F-89ED-A504839B2658" name="GUID-9784925C-FCCF-435F-89ED-A504839B2658"></a><h5 id="TGDBA-GUID-9784925C-FCCF-435F-89ED-A504839B2658" class="sect5"><span class="enumeration_section">17.2.6.2 </span>Writes
                     </h5>
                     <div>
                        <p>For high-concurrency OLTP systems, consider appropriate values for <code class="codeph">INITRANS</code>, <code class="codeph">MAXTRANS</code>, and <code class="codeph">FREELISTS</code> when using a larger block size. These parameters affect the degree of update concurrency allowed within a block. However, you do not need to specify the value for <code class="codeph">FREELISTS</code> when using automatic se<a id="d52149e1627" class="indexterm-anchor"></a>gment-space management.
                        </p>
                        <p>If you are uncertain about which block size to choose, then try a database block size of 8 KB for most systems that process a large number of transactions. This represents a good compromise and is usually effective. Only systems processing LOB data need more than 8 KB.</p>
                        <div class="infoboxnotealso" id="GUID-9784925C-FCCF-435F-89ED-A504839B2658__GUID-A12D9314-19D5-4BB0-B1D4-08E22083E3C4">
                           <p class="notep1">See Also:</p>
                           <p>The Oracle Database installation documentation specific to your operating system for information about the minimum and maximum block size on your platform</p>
                        </div>
                     </div>
                  </div><a id="TGDBA94408"></a><a id="TGDBA94407"></a><div class="props_rev_3"><a id="GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B" name="GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B"></a><h5 id="TGDBA-GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B" class="sect5"><span class="enumeration_section">17.2.6.3 </span>Block Size Advantages and Disadvantages
                     </h5>
                     <div>
                        <p><a href="IO-configuration-and-design.html#GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B__g35558" title="This table lists the advantages and disadvantages of various block sizesl.">Table 17-3</a> lists the advantages and disadvantages of different block sizes.
                        </p>
                        <div class="tblformalwide" id="GUID-B7D17496-7388-4F9F-BAC1-FA7188580C3B__g35558">
                           <p class="titleintable">Table 17-3 Block Size Advantages and Disadvantages</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Block Size Advantages and Disadvantages" summary="This table lists the advantages and disadvantages of various block sizesl." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="14%" id="d52149e1703">Block Size</th>
                                    <th align="left" valign="bottom" width="37%" id="d52149e1706">Advantages</th>
                                    <th align="left" valign="bottom" width="48%" id="d52149e1709">Disadvantages</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d52149e1714" headers="d52149e1703 ">
                                       <p>Smaller</p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d52149e1714 d52149e1706 ">
                                       <p>Good for small rows with lots of random access.</p>
                                       <p>Reduces block contention.</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d52149e1714 d52149e1709 ">
                                       <p>Has relatively large space overhead due to metadata (that is, block header).</p>
                                       <p>Not recommended for large rows. There might only be a few rows stored for each block, or worse, row chaining if a single row does not fit into a block,</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d52149e1728" headers="d52149e1703 ">
                                       <p>Larger</p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d52149e1728 d52149e1706 ">
                                       <p>Has lower overhead, so there is more room to store data.</p>
                                       <p>Permits reading several rows into the buffer cache with a single I/O (depending on row size and block size). </p>
                                       <p>Good for sequential access or very large rows (such as LOB data).</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d52149e1728 d52149e1709 ">
                                       <p>Wastes space in the buffer cache, if you are doing random access to small rows and have a large block size. For example, with an 8 KB block size and 50 byte row size, you waste 7,950 bytes in the buffer cache when doing random access. </p>
                                       <p>Not good for index blocks used in an OLTP environment, because they increase block contention on the index leaf blocks.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div>
            </div><a id="TGDBA94382"></a><div class="props_rev_3"><a id="GUID-08ED4172-9398-402E-B0C4-4CE88DE87603" name="GUID-08ED4172-9398-402E-B0C4-4CE88DE87603"></a><h3 id="TGDBA-GUID-08ED4172-9398-402E-B0C4-4CE88DE87603" class="sect3"><span class="enumeration_section">17.3 </span>I/O Calibration Inside the Database
               </h3>
               <div>
                  <p>The I/O calibration feature of Oracle Database enables you to assess the performance of the storage subsystem, and determine whether I/O performance problems are caused by the database or the storage subsystem. Unlike other external I/O calibration tools that issue I/Os sequentially, the I/O calibration feature of Oracle Database issues I/Os randomly using Oracle data files to access the storage media, producing results that more closely match the actual performance of the database.</p>
                  <p>The section describes how to use the I/O calibration feature of Oracle Database and contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-7B16A2D4-F360-4271-9F26-B4DCEC36FD89">Prerequisites for I/O Calibration</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-BCAF1968-C076-41FC-9900-3A8681A21419">Running I/O Calibration</a></p>
                     </li>
                  </ul>
                  <p>Oracle Database also provides Orion, an I/O calibration tool. Orion is a tool for predicting the performance of an Oracle database without having to install Oracle or create a database. Unlike other I/O calibration tools, Oracle Orion is expressly designed for simulating Oracle database I/O workloads using the same I/O software stack as Oracle. Orion can also simulate the effect of striping performed by Oracle Automatic Storage Management. For more information, see <span class="q">"<a href="IO-configuration-and-design.html#GUID-355C99D8-29C1-421F-8B65-47A3C48324A2">I/O Calibration with the Oracle Orion Calibration Tool</a>"</span>. 
                  </p>
               </div><a id="TGDBA94383"></a><div class="props_rev_3"><a id="GUID-7B16A2D4-F360-4271-9F26-B4DCEC36FD89" name="GUID-7B16A2D4-F360-4271-9F26-B4DCEC36FD89"></a><h4 id="TGDBA-GUID-7B16A2D4-F360-4271-9F26-B4DCEC36FD89" class="sect4"><span class="enumeration_section">17.3.1 </span>Prerequisites for I/O Calibration
                  </h4>
                  <div>
                     <p>Before running I/O calibration, ensure that the following requirements are met:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The user must be granted the <code class="codeph">SYSDBA</code> privilege
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">timed_statistics</code> must be set to <code class="codeph">TRUE</code></p>
                        </li>
                        <li>
                           <p>Asynchronous I/O must be enabled</p>
                           <p>When using file systems, asynchronous I/O can be enabled by setting the <code class="codeph">FILESYSTEMIO_OPTIONS</code> initialization parameter to <code class="codeph">SETALL</code>.
                           </p>
                        </li>
                        <li>
                           <p>Ensure that asynchronous I/O is enabled for data files by running the following query: </p><pre class="oac_no_warn" dir="ltr">COL NAME FORMAT A50
SELECT NAME,ASYNCH_IO FROM V$DATAFILE F,V$IOSTAT_FILE I
WHERE  F.FILE#=I.FILE_NO
AND    FILETYPE_NAME='Data File';
</pre></li>
                     </ul>
                     <p>Additionally, only one calibration can be performed on a database instance at a time.</p>
                  </div>
               </div><a id="TGDBA94384"></a><div class="props_rev_3"><a id="GUID-BCAF1968-C076-41FC-9900-3A8681A21419" name="GUID-BCAF1968-C076-41FC-9900-3A8681A21419"></a><h4 id="TGDBA-GUID-BCAF1968-C076-41FC-9900-3A8681A21419" class="sect4"><span class="enumeration_section">17.3.2 </span>Running I/O Calibration
                  </h4>
                  <div>
                     <div class="section">
                        <p>The I/O calibration feature of Oracle Database is accessed using the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure. This procedure issues an I/O intensive read-only workload, made up of one megabyte of random of I/Os, to the database files to determine the maximum IOPS (I/O requests per second) and MBPS (megabytes of I/O per second) that can be sustained by the storage subsystem.
                        </p>
                        <p>The I/O calibration occurs in two steps:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>In the first step of I/O calibration with the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure, the procedure issues random database-block-sized reads, by default, 8 KB, to all data files from all database instances. This step provides the maximum IOPS, in the output parameter <code class="codeph">max_iops</code>, that the database can sustain. The value <code class="codeph">max_iops</code> is an important metric for OLTP databases. The output parameter <code class="codeph">actual_latency</code> provides the average latency for this workload. When you need a specific target latency, you can specify the target latency with the input parameter <code class="codeph">max_latency</code> (specifies the maximum tolerable latency in milliseconds for database-block-sized IO requests).
                              </p>
                           </li>
                           <li>
                              <p>The second step of calibration using the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure issues random, 1 MB reads to all data files from all database instances. The second step yields the output parameter <code class="codeph">max_mbps</code>, which specifies the maximum MBPS of I/O that the database can sustain. This step provides an important metric for data warehouses.
                              </p>
                           </li>
                        </ul>
                        <p>The calibration runs more efficiently if the user provides the <code class="codeph">num_physical_disks</code> input parameter, which specifies the approximate number of physical disks in the database storage system.
                        </p>
                        <p>Due to the overhead from running the I/O workload, I/O calibration should only be performed when the database is idle, or during off-peak hours, to minimize the impact of the I/O workload on the normal database workload.</p>
                        <p>To run I/O calibration and assess the I/O capability of the storage subsystem used by Oracle Database, use the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure:
                        </p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON
DECLARE
  lat  INTEGER;
  iops INTEGER;
  mbps INTEGER;
BEGIN
-- DBMS_RESOURCE_MANAGER.CALIBRATE_IO (&lt;DISKS&gt;, &lt;MAX_LATENCY&gt;, iops, mbps, lat);
   DBMS_RESOURCE_MANAGER.CALIBRATE_IO (2, 10, iops, mbps, lat);
 
  DBMS_OUTPUT.PUT_LINE ('max_iops = ' || iops);
  DBMS_OUTPUT.PUT_LINE ('latency  = ' || lat);
  dbms_output.put_line('max_mbps = ' || mbps);
end;
/
</pre><p>When running the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure, consider the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Only run one calibration at a time on databases that use the same storage subsystem. If you simultaneously run the calibration across separate databases that use the same storage subsystem, the calibration will fail.</p>
                           </li>
                           <li>
                              <p>Quiesce the database to minimize I/O on the instance.</p>
                           </li>
                           <li>
                              <p>For Oracle Real Application Clusters (Oracle RAC) configurations, ensure that all instances are opened to calibrate the storage subsystem across nodes.</p>
                           </li>
                           <li>
                              <p>For an Oracle Real Application Clusters (Oracle RAC) database, the workload is simultaneously generated from all instances.</p>
                           </li>
                           <li>
                              <p>The <code class="codeph">num_physical_disks</code> input parameter is optional. By setting the <code class="codeph">num_physical_disks</code> parameter to the approximate number of physical disks in the database's storage system, the calibration can be faster and more accurate.
                              </p>
                           </li>
                           <li>
                              <p>In some cases, asynchronous I/O is permitted for data files, but the I/O subsystem for submitting asynchronous I/O may be maximized, and I/O calibration cannot continue. In such cases, refer to the port-specific documentation for information about checking the maximum limit for asynchronous I/O on the system.</p>
                           </li>
                        </ul>
                        <p>At any time during the I/O calibration process, you can query the calibration status in the <code class="codeph">V$IO_CALIBRATION_STATUS</code> view. After I/O calibration is successfully completed, you can view the results in the <code class="codeph">DBA_RSRC_IO_CALIBRATE</code> table.
                        </p>
                        <div class="infoboxnotealso" id="GUID-BCAF1968-C076-41FC-9900-3A8681A21419__GUID-0F062801-0FC9-4373-A967-84798878492D">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../arpls/DBMS_RESOURCE_MANAGER.html#ARPLS-GUID-90D0674E-6A10-41A9-ABBD-783F908502C3" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about running the <code class="codeph">DBMS_RESOURCE_MANAGER</code>.<code class="codeph">CALIBRATE_IO</code> procedure 
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic">Oracle Database Reference</span> for more information about the <a href="../refrn/V-IO_CALIBRATION_STATUS.html#REFRN-GUID-E7D2C4C2-7EE6-4A7F-A4EE-01686C6CF576" target="_blank"><code class="codeph">V$IO_CALIBRATION_STATUS</code></a> view and <a href="../refrn/DBA_RSRC_IO_CALIBRATE.html#REFRN-GUID-A833CB61-D035-4786-B971-F5AB67C499ED" target="_blank"><code class="codeph">DBA_RSRC_IO_CALIBRATE</code></a> table
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="TGDBA95244"></a><div class="props_rev_3"><a id="GUID-355C99D8-29C1-421F-8B65-47A3C48324A2" name="GUID-355C99D8-29C1-421F-8B65-47A3C48324A2"></a><h3 id="TGDBA-GUID-355C99D8-29C1-421F-8B65-47A3C48324A2" class="sect3"><span class="enumeration_section">17.4 </span>I/O Calibration with the Oracle Orion Calibration Tool
               </h3>
               <div>
                  <p>This section describes the Oracle Orion Calibration Tool and includes the following sections:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-E523FA5B-C002-4528-B43E-58F84790DFEC">Introduction to the Oracle Orion Calibration Tool</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-D0FC09D7-75EE-4FAB-9E52-43432D65C5A3">Getting Started with Orion</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-E5209602-9ED6-4663-AF07-18A140A5D6EA">Orion Input Files</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-580F3E45-D631-4630-AAE2-7B573F685BA5">Orion Parameters</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-6FB98415-D623-4BCD-916E-663E84FE0882">Orion Output Files</a></p>
                     </li>
                     <li>
                        <p><a href="IO-configuration-and-design.html#GUID-54E92BB0-B45B-45C4-8439-D873FC7E9DB8">Orion Troubleshooting</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA95223"></a><a id="TGDBA95222"></a><div class="props_rev_3"><a id="GUID-E523FA5B-C002-4528-B43E-58F84790DFEC" name="GUID-E523FA5B-C002-4528-B43E-58F84790DFEC"></a><h4 id="TGDBA-GUID-E523FA5B-C002-4528-B43E-58F84790DFEC" class="sect4"><span class="enumeration_section">17.4.1 </span>Introduction to the Oracle Orion Calibration Tool
                  </h4>
                  <div>
                     <p>Oracle Orion is a tool for predicting the performance of an Oracle database without having to install Oracle or create a database. Unlike other I/O calibration tools, Oracle Orion is expressly designed for simulating Oracle database I/O workloads using the same I/O software stack as Oracle. Orion can also simulate the effect of striping performed by Oracle Automatic Storage Management.</p>
                     <p><a href="IO-configuration-and-design.html#GUID-E523FA5B-C002-4528-B43E-58F84790DFEC__BABCGCEJ" title="Orion supported I/O workloads">Table 17-4</a> lists the types of I/O workloads that Orion supports.
                     </p>
                     <p>For each type of workload shown in <a href="IO-configuration-and-design.html#GUID-E523FA5B-C002-4528-B43E-58F84790DFEC__BABCGCEJ" title="Orion supported I/O workloads">Table 17-4</a>, Orion can run tests using different I/O loads to measure performance metrics such as MBPS, IOPS, and I/O latency. Load is expressed in terms of the number of outstanding asynchronous I/Os. Internally, for each such load level, the Orion software keeps issuing I/O requests as fast as they complete to maintain the I/O load at that level. For random workloads, using either large or small sized I/Os, the load level is the number of outstanding I/Os. For large sequential workloads, the load level is a combination of the number of sequential streams and the number of outstanding I/Os per stream. Testing a given workload at a range of load levels can help you understand how performance is affected by load.
                     </p>
                     <p>Note the following when you use Orion:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Run Orion when the storage is idle (or pretty close to idle). Orion calibrates the performance of the storage based on the I/O load it generates; Orion is not able to properly assess the performance if non-Orion I/O workloads run simultaneously.</p>
                        </li>
                        <li>
                           <p>If a database has been created on the storage, the storage can alternatively be calibrated using the PL/SQL routine <code class="codeph">dbms_resource_manager.calibrate_io()</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="tblformalwide" id="GUID-E523FA5B-C002-4528-B43E-58F84790DFEC__BABCGCEJ">
                        <p class="titleintable">Table 17-4 Orion I/O Workload Support</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Orion I/O Workload Support" summary="Orion supported I/O workloads" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="28%" id="d52149e2251">Workload</th>
                                 <th align="left" valign="bottom" width="72%" id="d52149e2254">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d52149e2259" headers="d52149e2251 ">
                                    <p>Small Random I/O</p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d52149e2259 d52149e2254 ">
                                    <p>OLTP applications typically generate random reads and writes whose size is equivalent to the database block size, typically 8 KB. Such applications typically care about the throughput in I/Os Per Second (IOPS) and about the average latency (I/O turn-around time) per request. These parameters translate to the transaction rate and transaction turn-around time at the application layer.</p>
                                    <p>Orion simulates a random I/O workload with a given percentage of reads compared to writes, a given I/O size, and a given number of outstanding I/Os. In this Orion workload simulation, the I/Os are distributed across all disks.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d52149e2268" headers="d52149e2251 ">
                                    <p>Large Sequential I/O</p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d52149e2268 d52149e2254 ">
                                    <p>Data warehousing applications, data loads, backups, and restores generate sequential read and write streams composed of multiple outstanding 1 MB I/Os. Such applications are processing large amounts of data, such as a whole table or a whole database and they typically care about the overall data throughput in MegaBytes Per Second (MBPS).</p>
                                    <p>Orion can simulate a given number of sequential read or write streams of a given I/O size with a given number of outstanding I/Os. Orion can optionally simulate Oracle Automatic Storage Management striping when testing sequential streams.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d52149e2277" headers="d52149e2251 ">
                                    <p>Large Random I/O</p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d52149e2277 d52149e2254 ">
                                    <p>A sequential stream typically accesses the disks concurrently with other database traffic. With striping, a sequential stream is spread across many disks. Consequently, at the disk level, multiple sequential streams are seen as random 1 MB I/Os.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d52149e2284" headers="d52149e2251 ">
                                    <p>Mixed Workloads</p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d52149e2284 d52149e2254 ">
                                    <p>Orion can simulate two simultaneous workloads: Small Random I/O and either Large Sequential I/O or Large Random I/O. This workload type enables you to simulate, for example, an OLTP workload of 8 KB random reads and writes with a backup workload of four sequential read streams of 1 MB I/Os.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Each Orion data point is a test for a specific mix of small and large I/O loads sustained for a duration. An Orion test consists of multiple data point tests. These data point tests can be represented as a two-dimensional matrix. Each column in the matrix represents data point tests with the same small I/O load, but varying large I/O loads. Each row represents data point tests with the same large I/O load, but varying small I/O loads. An Orion test can be for a single point, a single row, a single column, or for the whole matrix.</p>
                  </div><a id="TGDBA95224"></a><div class="props_rev_3"><a id="GUID-F236A5F3-1DA4-4D8D-9F92-5519969654D2" name="GUID-F236A5F3-1DA4-4D8D-9F92-5519969654D2"></a><h5 id="TGDBA-GUID-F236A5F3-1DA4-4D8D-9F92-5519969654D2" class="sect5"><span class="enumeration_section">17.4.1.1 </span>Orion Test Targets
                     </h5>
                     <div>
                        <p>You can use Orion to test any disk-based character device that supports asynchronous I/O. Orion has been tested on the following types of targets:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>DAS (direct-attached) storage: You can use Orion to test the performance of one or more local disks, volumes, or files on the local host.</p>
                           </li>
                           <li>
                              <p>SAN (storage-area network) storage: Orion can be run on any host that has all or parts of the SAN storage mapped as character devices. The devices can correspond to striped or un-striped volumes exported by the storage array(s), or individual disks, or one or more whole arrays.</p>
                           </li>
                           <li>
                              <p>NAS (network-attached storage): You can use Orion to test the performance on data files on NAS storage. In general, the performance results on NAS storage are dependent on the I/O patterns with which the data files have been created and updated. Therefore, you should initialize the data files appropriately before running Orion.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="TGDBA95225"></a><div class="props_rev_3"><a id="GUID-59E9F9C5-BC68-4523-AE5B-EA2B812659DB" name="GUID-59E9F9C5-BC68-4523-AE5B-EA2B812659DB"></a><h5 id="TGDBA-GUID-59E9F9C5-BC68-4523-AE5B-EA2B812659DB" class="sect5"><span class="enumeration_section">17.4.1.2 </span>Orion for Oracle Administrators
                     </h5>
                     <div>
                        <p>Oracle administrators can use Orion to evaluate and compare different storage arrays, based on the expected workloads. Oracle administrators can also use Orion to determine the optimal number of network connections, storage arrays, storage array controllers, and disks for the expected peak workloads.</p>
                     </div>
                  </div>
               </div><a id="TGDBA95226"></a><div class="props_rev_3"><a id="GUID-D0FC09D7-75EE-4FAB-9E52-43432D65C5A3" name="GUID-D0FC09D7-75EE-4FAB-9E52-43432D65C5A3"></a><h4 id="TGDBA-GUID-D0FC09D7-75EE-4FAB-9E52-43432D65C5A3" class="sect4"><span class="enumeration_section">17.4.2 </span>Getting Started with Orion
                  </h4>
                  <div>
                     <div class="section">
                        <p>To get started using Orion, do the following:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Select a test name to use with the Orion <code class="codeph">&#x2013;testname</code> parameter. This parameter specifies a unique identifier for your Orion run. For example, use the test name "mytest". For more information, see <span class="q">"<a href="IO-configuration-and-design.html#GUID-580F3E45-D631-4630-AAE2-7B573F685BA5">Orion Parameters</a>"</span>.</span></li>
                        <li class="stepexpand"><span>Create an Orion input file, based on the test name. For example, create a file named <code class="codeph">mytest.lun</code>. In the input file list the raw volumes or files to test. Add one volume name per line. Do not put comments or anything else in the <code class="codeph">.lun</code> file.</span><div>
                              <p>For example, an Orion input file could contain the following:</p><pre class="oac_no_warn" dir="ltr">/dev/raw/raw1
/dev/raw/raw2
/dev/raw/raw3
/dev/raw/raw4
/dev/raw/raw5
/dev/raw/raw6
/dev/raw/raw7
/dev/raw/raw8
</pre><p>For more information, see <span class="q">"<a href="IO-configuration-and-design.html#GUID-E5209602-9ED6-4663-AF07-18A140A5D6EA">Orion Input Files</a>"</span>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Verify that the all volumes specified in the input file, for example mytest.lun, are accessible using the command <code class="codeph">dd</code> or another equivalent file viewing utility. For example, for a typical sanity-check try the following on a Linux system:</span><div><pre class="oac_no_warn" dir="ltr">$ dd if=/dev/raw/raw1 of=/dev/null bs=32k count=1024
</pre><p>Depending on your platform, the file viewing utility you use and its interface may be different.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Verify that your platform has the necessary libraries installed to do asynchronous I/Os. The Orion test is completely dependent on asynchronous I/O. On Linux and Solaris, the library <code class="codeph">libaio</code> must be in the standard <code class="codeph">lib</code> directories or accessible through the shell environment's library path variable (usually <code class="codeph">LD_LIBRARY_PATH</code> or <code class="codeph">LIBPATH</code>, depending on your shell). Windows has built-in asynchronous I/O libraries, so this issue does not apply.</span></li>
                        <li class="stepexpand"><span>As a first test with Orion, use <code class="codeph">&#x2013;run</code> with either the <code class="codeph">oltp</code> or <code class="codeph">dss</code> option. If the database is primarily OLTP, then use <code class="codeph">&#x2013;run oltp</code>. If the database is primarily for data warehousing or analytics, then use <code class="codeph">&#x2013;run dss</code>.</span><div>
                              <p>For example, use the following command to run an OLTP-like workload using the default input file name, <code class="codeph">orion.lun</code>:
                              </p><pre class="oac_no_warn" dir="ltr">$ ./orion -run oltp
</pre><p>The I/O load levels generated by Orion take into account the number of disk spindles being tested (or specified with the <code class="codeph">&#x2013;num_disks</code> parameter). Keep in mind that the number of spindles <span class="italic">may or may not be</span> related to the number of volumes specified in the input file, depending on how these volumes are mapped.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>The section <span class="q">"<a href="IO-configuration-and-design.html#GUID-6FB98415-D623-4BCD-916E-663E84FE0882">Orion Output Files</a>"</span> provides sample results showing the Orion output files. Using the sample file <code class="codeph">mytest_summary.txt</code> is a good starting point for verifying the input parameters and analyzing the output. The sample files <code class="codeph">mytest_*.csv</code> contain comma-delimited values for several I/O performance measures.</span></li>
                     </ol>
                  </div>
               </div><a id="TGDBA95227"></a><div class="props_rev_3"><a id="GUID-E5209602-9ED6-4663-AF07-18A140A5D6EA" name="GUID-E5209602-9ED6-4663-AF07-18A140A5D6EA"></a><h4 id="TGDBA-GUID-E5209602-9ED6-4663-AF07-18A140A5D6EA" class="sect4"><span class="enumeration_section">17.4.3 </span>Orion Input Files
                  </h4>
                  <div>
                     <p>When you specify the Orion <code class="codeph">&#x2013;testname</code> &lt;<span class="italic">testname</span>&gt; parameter, this sets the test name prefix for the Orion input and output filenames. The default value for the <code class="codeph">&#x2013;testname</code> option is "orion".
                     </p>
                     <p>The Orion input file, &lt;<span class="italic">testname</span>&gt;.<code class="codeph">lun</code> should contain a carriage-return-separated list of LUNs.
                     </p>
                  </div>
               </div><a id="TGDBA95228"></a><div class="props_rev_3"><a id="GUID-580F3E45-D631-4630-AAE2-7B573F685BA5" name="GUID-580F3E45-D631-4630-AAE2-7B573F685BA5"></a><h4 id="TGDBA-GUID-580F3E45-D631-4630-AAE2-7B573F685BA5" class="sect4"><span class="enumeration_section">17.4.4 </span>Orion Parameters
                  </h4>
                  <div>
                     <p><a id="d52149e2682" class="indexterm-anchor"></a><a id="d52149e2686" class="indexterm-anchor"></a>Use the Orion command parameters to specify the I/O workload type and to specify other Orion options.
                     </p>
                  </div><a id="TGDBA95230"></a><a id="TGDBA95229"></a><div class="props_rev_3"><a id="GUID-887193BA-64CF-4ECA-AB58-4FBE0937D52F" name="GUID-887193BA-64CF-4ECA-AB58-4FBE0937D52F"></a><h5 id="TGDBA-GUID-887193BA-64CF-4ECA-AB58-4FBE0937D52F" class="sect5"><span class="enumeration_section">17.4.4.1 </span>Orion Required Parameter
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">&#x2013;run</code> parameter is required with the Orion command. <a href="IO-configuration-and-design.html#GUID-887193BA-64CF-4ECA-AB58-4FBE0937D52F__BABCDGFJ" title="Summary of required Orion command line options">Table 17-5</a> describes the <code class="codeph">&#x2013;run</code> parameter.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformalwide" id="GUID-887193BA-64CF-4ECA-AB58-4FBE0937D52F__BABCDGFJ">
                           <p class="titleintable">Table 17-5 Required Orion Parameter</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Required Orion Parameter" summary="Summary of required Orion command line options" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="10%" id="d52149e2766">Option</th>
                                    <th align="left" valign="bottom" width="79%" id="d52149e2769">Description</th>
                                    <th align="left" valign="bottom" width="11%" id="d52149e2772">Default</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d52149e2777" headers="d52149e2766 ">
                                       <p><code class="codeph">&#x2013;run</code> <span class="italic">level</span></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d52149e2777 d52149e2769 ">
                                       <p>Specifies the test run level to be <span class="italic">level</span>. This option provides the run level and allows complex commands to be specified at the advanced level. If not set as <code class="codeph">&#x2013;run advanced</code>, then setting any other parameter, besides <code class="codeph">&#x2013;cache_size</code> or <code class="codeph">&#x2013;verbose</code>, results in an error. 
                                       </p>
                                       <p>Except <span class="bold">advanced</span>, all of the <code class="codeph">&#x2013;run</code> <span class="italic">level</span> settings use a pre-specified set of parameters.
                                       </p>
                                       <p>The <span class="italic">level</span> must be one of:
                                       </p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><span class="bold">oltp</span></p>
                                             <p>Tests with random small (8K) I/Os at increasing loads to determine the maximum IOPS.</p>
                                             <p>This parameter corresponds to the following Orion invocation:</p><pre class="oac_no_warn" dir="ltr">%&gt; ./orion -run advanced \
	-num_large 0 -size_small 8 -type rand \
	-simulate concat -write 0 -duration 60 \
	-matrix row

</pre></li>
                                          <li>
                                             <p><span class="bold">dss</span></p>
                                             <p>Tests with random large (1M) I/Os at increasing loads to determine the maximum throughput.</p>
                                             <p>This parameter corresponds to the following Orion invocation:</p><pre class="oac_no_warn" dir="ltr">
%&gt; ./orion -run advanced \
	-num_small 0 -size_large 1024 -type rand \
	-simulate concat -write 0 -duration 60 \
	-matrix column
</pre></li>
                                          <li>
                                             <p><span class="bold">simple</span></p>
                                             <p>Generates the Small Random I/O and the Large Random I/O workloads for a range of load levels. In this option, small and large I/Os are tested in isolation. The only optional parameters that can be specified at this run level are <code class="codeph">&#x2013;cache_size</code> and <code class="codeph">&#x2013;verbose</code>. 
                                             </p>
                                             <p>This parameter corresponds to the following Orion invocation:</p><pre class="oac_no_warn" dir="ltr">%&gt; ./orion -run advanced \
-size_small 8 -size_large 1024 -type rand \
-simulate concat -write 0 -duration 60 \
-matrix basic
</pre></li>
                                          <li>
                                             <p><span class="bold">normal</span></p>
                                             <p>Same as <code class="codeph">simple</code>, but also generates combinations of the small random I/O and large random I/O workloads for a range of loads. The only optional parameters that can be specified at this run level are <code class="codeph">&#x2013;cache_size</code> and <code class="codeph">&#x2013;verbose</code>. 
                                             </p>
                                             <p>This parameter corresponds to the following Orion invocation:</p><pre class="oac_no_warn" dir="ltr">%&gt; ./orion -run advanced \
-size_small 8 -size_large 1024 -type rand \
-simulate concat -write 0 -duration 60 \
-matrix detailed
</pre></li>
                                          <li>
                                             <p><span class="bold">advanced</span></p>
                                             <p>Tests the workload you specify with optional parameters. Any of the optional parameters can be specified at this run level.</p>
                                          </li>
                                       </ul>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d52149e2777 d52149e2772 ">
                                       <p><code class="codeph">normal</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="TGDBA95232"></a><a id="TGDBA95231"></a><div class="props_rev_3"><a id="GUID-AABADCBD-D209-4099-8853-4CF79803DD49" name="GUID-AABADCBD-D209-4099-8853-4CF79803DD49"></a><h5 id="TGDBA-GUID-AABADCBD-D209-4099-8853-4CF79803DD49" class="sect5"><span class="enumeration_section">17.4.4.2 </span>Orion Optional Parameters
                     </h5>
                     <div>
                        <div class="tblformalwide" id="GUID-AABADCBD-D209-4099-8853-4CF79803DD49__GUID-0D94CD8B-67A9-4DBE-95DB-79B3D3353451">
                           <p class="titleintable">Table 17-6 Optional Orion Parameters</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Optional Orion Parameters" summary="Orion optional input parameters" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d52149e2942">Option</th>
                                    <th align="left" valign="bottom" width="57%" id="d52149e2945">Description</th>
                                    <th align="left" valign="bottom" width="24%" id="d52149e2948">Default</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e2953" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;cache_size</code> <span class="italic">num</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e2953 d52149e2945 ">
                                       <p>Size of the storage array's read or write cache (in MB). For Large Sequential I/O workloads, Orion warms the cache by doing random large I/Os before each data point. Orion uses the cache size to determine the duration for this cache warming operation. If set to 0, do not perform cache warming.</p>
                                       <p>Unless this option is set to 0, Orion issues several unmeasured, random I/Os before each large sequential data point. These I/Os fill up the storage array's cache, if any, with random data so that I/Os from one data point do not result in cache hits for the next data point. Read tests are preceded with junk reads and write tests are preceded with junk writes. If specified, this 'cache warming' is performed until <span class="italic">num</span> MBs of I/O have been read or written.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e2953 d52149e2948 ">
                                       <p>Default Value: </p>
                                       <p>If not specified, warming occurs for a default amount of time (two minutes). That is, issue two minutes of unmeasured random I/Os before each data point.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e2974" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;duration</code> <span class="italic">num_seconds</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e2974 d52149e2945 ">
                                       <p>Set the duration to test each data point in seconds to the value <span class="italic">num_seconds</span>.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e2974 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">60</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e2993" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;help</code></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e2993 d52149e2945 ">
                                       <p>Prints Orion help information. All other options are ignored with help set.</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e2993 d52149e2948 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3002" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;matrix</code> <span class="italic">type</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3002 d52149e2945 ">
                                       <p>Type of mixed workloads to test over a range of loads. An Orion test consists of multiple data point tests. The data point tests can be represented as a two-dimensional matrix.</p>
                                       <p>Each column in the matrix represents data point tests with the same small I/O load, but varying large I/O loads. Each row represents data point tests with the same large I/O load, but varying small I/O loads. An Orion test can be for a single point, a single row, a single column, or the whole matrix, depending on the matrix <span class="italic">type</span>:
                                       </p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><span class="bold">basic:</span> No mixed workload. The Small Random and Large Random/Sequential workloads are tested separately. Test small I/Os only, then large I/Os only.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">detailed:</span> Small Random and Large Random/Sequential workloads are tested in combination. Test entire matrix.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">point:</span> A single data point with <span class="italic">S</span> outstanding Small Random I/Os and <span class="italic">L</span> outstanding Large Random I/Os or sequential streams. <span class="italic">S</span> is set by the <code class="codeph">&#x2013;num_small</code> parameter. <span class="italic">L</span> is set by the <code class="codeph">&#x2013;num_large</code> parameter. Test with <code class="codeph">&#x2013;num_small</code> small I/Os, <code class="codeph">&#x2013;num_large</code> large I/Os.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">col:</span> Large Random/Sequential workloads only. Test a varying large I/O load with <code class="codeph">&#x2013;num_small </code>small I/Os.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">row:</span> Small Random workloads only. Test a varying small I/O load with <code class="codeph">&#x2013;num_large</code> large I/Os.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">max:</span> Same as detailed, but only tests the workload at the maximum load, specified by the <code class="codeph">&#x2013;num_small</code> and <code class="codeph">&#x2013;num_large</code> parameters. Test varying loads up to the <code class="codeph">&#x2013;num_small</code> and <code class="codeph">&#x2013;num_large</code> limits.
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3002 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">basic</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3097" headers="d52149e2942 ">
                                       <p>&#x2013;<code class="codeph">num_disks</code> <span class="italic">value</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3097 d52149e2945 ">
                                       <p>Specify the number of physical disks used by the test. Used to generate a range for the load. Specifies the number of disks (physical spindles). This number <span class="italic">value</span> is used to gauge the range of loads that Orion should test at. Increasing this parameter results in Orion using heavier I/O loads.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3097 d52149e2948 ">
                                       <p>Default Value: the number of LUNs in &lt;<span class="italic">testname</span>&gt;.lun.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3118" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;num_large</code> <span class="italic">value</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3118 d52149e2945 ">
                                       <p>Controls the large I/O load.</p>
                                       <p>Note, this option only applies when <code class="codeph">&#x2013;matrix</code> is specified as: <code class="codeph">row</code>, <code class="codeph">point</code>, or <code class="codeph">max</code>.
                                       </p>
                                       <p>When the <code class="codeph">&#x2013;type</code> option is set to <code class="codeph">rand</code>, the parameter argument <span class="italic">value</span> specifies the number of outstanding large I/Os.
                                       </p>
                                       <p>When the <code class="codeph">&#x2013;type</code> option is set to <code class="codeph">seq</code>, the parameter argument <span class="italic">value</span> specifies the number of sequential I/O streams.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3118 d52149e2948 ">
                                       <p>Default Value: no default</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3168" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;num_smal</code>l
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3168 d52149e2945 ">
                                       <p>Specify the maximum number of outstanding I/Os for the Small Random I/O workload.</p>
                                       <p>Note: this only applies when <code class="codeph">&#x2013;matrix</code> is specified as <code class="codeph">col</code>, <code class="codeph">point</code>, or <code class="codeph">max</code>.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3168 d52149e2948 ">
                                       <p>Default Value: no default</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3194" headers="d52149e2942 ">
                                       <p>&#x2013;<code class="codeph">num_streamIO</code> <span class="italic">num</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3194 d52149e2945 ">
                                       <p>Specify the number of concurrent I/Os per stream as <span class="italic">num</span>.
                                       </p>
                                       <p>Note: this parameter is only used if <code class="codeph">&#x2013;type</code> is <code class="codeph">seq</code>.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3194 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">4</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3222" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;simulate</code> <span class="italic">type</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3222 d52149e2945 ">
                                       <p>Data layout to simulate for Large Sequential I/O workload. Orion tests on a virtual LUN formed by combining specified LUNs in one of these ways. The <span class="italic">type</span> is one:
                                       </p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><span class="bold">concat:</span> A virtual volume is simulated by serially chaining the specified LUNs. A sequential test over this virtual volume will go from some point to the end of each one LUN, followed by the beginning to end of the next LUN, and so on.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">raid0:</span> A virtual volume is simulated by striping across the specified LUNs. Each sequential stream issues I/Os across all LUNs using raid0 striping. The stripe depth is 1M by default, to match the Oracle Automatic Storage Management stripe depth, and can be changed with the <code class="codeph">&#x2013;stripe</code> parameter.
                                             </p>
                                          </li>
                                       </ul>
                                       <p>The offsets for I/Os are determined as follows:</p>
                                       <p>For Small Random and Large Random workloads:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>The LUNs are concatenated into a single virtual LUN (VLUN) and random offsets are chosen within the VLUN.</p>
                                          </li>
                                       </ul>
                                       <p>For Large Sequential workloads:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>With striping (<code class="codeph">&#x2013;simulate</code> <code class="codeph">raid0</code>). The LUNs are used to create a single striped VLUN. With no concurrent Small Random workload, the sequential streams start at fixed offsets within the striped VLUN. For <span class="italic">n</span> streams, stream <span class="italic">i</span> start at offset VLUNsize * (<span class="italic">i</span> + 1) / (<span class="italic">n</span> + 1), unless <span class="italic">n</span> is 1, in which case the single stream start at offset 0. With a concurrent Small Random workload, streams start at random offsets within the striped VLUN.
                                             </p>
                                          </li>
                                          <li>
                                             <p>Without striping (<code class="codeph">&#x2013;simulate</code> <code class="codeph">CONCAT</code>). The LUNs are concatenated into a single VLUN. The streams start at random offsets within the single VLUN.
                                             </p>
                                          </li>
                                       </ul>
                                       <p>This parameter is typically only used if <code class="codeph">&#x2013;type</code> is <code class="codeph">seq</code>.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3222 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">concat</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3308" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;size_large</code> <span class="italic">num</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3308 d52149e2945 ">
                                       <p>Specify the <span class="italic">num</span>, size of the I/Os (in KB) for the Large Random or Sequential I/O workload.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3308 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">1024</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3327" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;size_small</code> <span class="italic">num</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3327 d52149e2945 ">
                                       <p>Specify the num, size of the I/Os (in KB) for the Small Random I/O workload.</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3327 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">8</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3344" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;storax</code> <span class="italic">type</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3344 d52149e2945 ">
                                       <p>API to use for testing I/O workload.</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><span class="bold">skgfr:</span> Use operating system I/O layer.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">oss:</span> Use OSS API for I/O with Cell server in an Exadata machine.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">asmlib:</span> Use ASMLIB disk devices based storage API for I/O.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">odmlib:</span> Use Direct NFS storage based API for I/O.
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3344 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">skgfr</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3381" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;testname</code> <span class="italic">tname</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3381 d52149e2945 ">
                                       <p>Specify the <span class="italic">tname</span> identifier for the test run. When specified, the input file containing the LUN disk or file names must be named &lt;<span class="italic">tname</span>&gt;.lun.
                                       </p>
                                       <p>The output files are named with the prefix &lt;<span class="italic">tname</span>&gt;_.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3381 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">orion</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3408" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;type</code> [<code class="codeph">rand</code> | <code class="codeph">seq</code>]
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3408 d52149e2945 ">
                                       <p>Type of the Large I/O workload.</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><span class="bold">rand</span>: Randomly distributed large I/Os.
                                             </p>
                                          </li>
                                          <li>
                                             <p><span class="bold">seq</span>: Sequential streams of large I/Os.
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3408 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">rand</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3439" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;verbose</code></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3439 d52149e2945 ">
                                       <p>Prints status and tracing information to standard output.</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3439 d52149e2948 ">
                                       <p>Default Value: option not set</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d52149e3450" headers="d52149e2942 ">
                                       <p><code class="codeph">&#x2013;write</code> <span class="italic">num_write</span></p>
                                    </td>
                                    <td align="left" valign="top" width="57%" headers="d52149e3450 d52149e2945 ">
                                       <p>Specify the percentage of I/Os that are writes to <span class="italic">num_write</span>; the rest being reads. 
                                       </p>
                                       <p>This parameter applies to both the Large and Small I/O workloads. For Large Sequential I/Os, each stream is either read-only or write-only; the parameter specifies the percentage of streams that are write-only. The data written to disk is garbage and unrelated to any existing data on the disk.</p>
                                       <p><span class="bold">Caution</span>: write tests obliterate all data on the specified LUNS.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d52149e3450 d52149e2948 ">
                                       <p>Default Value: <code class="codeph">0</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-AABADCBD-D209-4099-8853-4CF79803DD49__GUID-12632449-21E8-4856-BE44-5EE917BB4C88">
                              <p class="notep1">Note:</p>
                              <p>Write tests obliterate all data on the specified LUNS.</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA95233"></a><div class="props_rev_3"><a id="GUID-FF860BB7-BD74-4538-A37B-E1C8B96080F1" name="GUID-FF860BB7-BD74-4538-A37B-E1C8B96080F1"></a><h5 id="TGDBA-GUID-FF860BB7-BD74-4538-A37B-E1C8B96080F1" class="sect5"><span class="enumeration_section">17.4.4.3 </span>Orion Command Line Samples
                     </h5>
                     <div>
                        <div class="section">
                           <p>The following provides sample Orion commands for different types of I/O workloads:</p>
                           <ol>
                              <li>
                                 <p>To evaluate storage for an OLTP database:</p><pre class="oac_no_warn" dir="ltr">-run oltp
</pre></li>
                              <li>
                                 <p>To evaluate storage for a data warehouse:</p><pre class="oac_no_warn" dir="ltr">-run dss
</pre></li>
                              <li>
                                 <p>For a basic set of data:</p><pre class="oac_no_warn" dir="ltr">-run normal
</pre></li>
                              <li>
                                 <p>To understand your storage performance with read-only, small and large random I/O workload:</p><pre class="oac_no_warn" dir="ltr">$ orion -run simple 
</pre></li>
                              <li>
                                 <p>To understand your storage performance with a mixed small and large random I/O workload:</p><pre class="oac_no_warn" dir="ltr">$ orion -run normal 
</pre></li>
                              <li>
                                 <p>To generate combinations of 32KB and 1MB reads to random locations:</p><pre class="oac_no_warn" dir="ltr">$ orion -run advanced -size_small 32 \
-size_large 1024 -type rand -matrix detailed
</pre></li>
                              <li>
                                 <p>To generate multiple sequential 1 MB write streams, simulating 1 MB RAID-0 stripes:</p><pre class="oac_no_warn" dir="ltr">$ orion -run advanced -simulate raid0 \
-stripe 1024 -write 100 -type seq -matrix col -num_small 0
</pre></li>
                              <li>
                                 <p>To generate combinations of 32 KB and 1 MB reads to random locations:</p><pre class="oac_no_warn" dir="ltr"> -run advanced -size_small 32 -size_large 1024 -type rand -matrix detailed
</pre></li>
                              <li>
                                 <p>To generate multiple sequential 1 MB write streams, simulating RAID0 striping:</p><pre class="oac_no_warn" dir="ltr"> -run advanced -simulate raid0 -write 100 -type seq -matrix col -num_small 0
</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="TGDBA95235"></a><a id="TGDBA95234"></a><div class="props_rev_3"><a id="GUID-6FB98415-D623-4BCD-916E-663E84FE0882" name="GUID-6FB98415-D623-4BCD-916E-663E84FE0882"></a><h4 id="TGDBA-GUID-6FB98415-D623-4BCD-916E-663E84FE0882" class="sect4"><span class="enumeration_section">17.4.5 </span>Orion Output Files
                  </h4>
                  <div>
                     <p>The output files for a test run are prefixed by &lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt; where <span class="italic">date</span> is <span class="italic">yyyymmdd_hhmm</span>.
                     </p>
                     <p><a href="IO-configuration-and-design.html#GUID-6FB98415-D623-4BCD-916E-663E84FE0882__BABHBEJC" title="Orion generated output files">Table 17-7</a> lists the Orion output files.
                     </p>
                     <div class="tblformalwide" id="GUID-6FB98415-D623-4BCD-916E-663E84FE0882__BABHBEJC">
                        <p class="titleintable">Table 17-7 Orion Generated Output Files</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Orion Generated Output Files" summary="Orion generated output files" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d52149e3657">Output File</th>
                                 <th align="left" valign="bottom" width="69%" id="d52149e3660">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3665" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_hist.csv
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3665 d52149e3660 ">
                                    <p>Histogram of I/O latencies.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3678" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_iops.csv
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3678 d52149e3660 ">
                                    <p>Performance results of small I/Os in IOPS.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3691" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_lat.csv
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3691 d52149e3660 ">
                                    <p>Latency of small I/Os in microseconds.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3704" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_mbps.csv
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3704 d52149e3660 ">
                                    <p>Performance results of large I/Os in MBPS.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3717" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_summary.txt
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3717 d52149e3660 ">
                                    <p>Summary of the input parameters, along with the minimum small I/O latency (in secs), the maximum MBPS, and the maximum IOPS observed.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d52149e3730" headers="d52149e3657 ">
                                    <p>&lt;<span class="italic">testname</span>&gt;_&lt;<span class="italic">date</span>&gt;_trace.txt
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d52149e3730 d52149e3660 ">
                                    <p>Extended, unprocessed output.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-6FB98415-D623-4BCD-916E-663E84FE0882__GUID-E9BFEC2A-B79D-4DB1-BB21-C74987009CDC">
                        <p class="notep1">Note:</p>
                        <p> If you are performing write tests, be prepared to lose any data stored on the LUNs.</p>
                     </div>
                  </div><a id="TGDBA95238"></a><a id="TGDBA95240"></a><a id="TGDBA95242"></a><a id="TGDBA95236"></a><div class="props_rev_3"><a id="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA" name="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA"></a><h5 id="TGDBA-GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA" class="sect5"><span class="enumeration_section">17.4.5.1 </span>Orion Sample Output Files
                     </h5>
                     <div>
                        <p>Orion creates several output files as specified in <a href="IO-configuration-and-design.html#GUID-6FB98415-D623-4BCD-916E-663E84FE0882__BABHBEJC" title="Orion generated output files">Table 17-7</a>. For the sample "mytest" shown in the section, <span class="q">"<a href="IO-configuration-and-design.html#GUID-D0FC09D7-75EE-4FAB-9E52-43432D65C5A3">Getting Started with Orion</a>"</span>, the output files are:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">mytest_summary.txt</span>: This file contains:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Input parameters</p>
                                 </li>
                                 <li>
                                    <p>Maximum throughput observed for the Large Random/Sequential workload</p>
                                 </li>
                                 <li>
                                    <p>Maximum I/O rate observed for the Small Random workload</p>
                                 </li>
                                 <li>
                                    <p>Minimum latency observed for the Small Random workload</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">mytest_mbps.csv:</span> comma-delimited value file containing the data transfer rate (MBPS) results for the Large Random/Sequential workload. In the general case, this and all other CSV files contains a two-dimensional table. Each row in the table corresponds to a large I/O load level and each column corresponds to a specific small I/O load level. Thus, the column headings are the number of outstanding small I/Os and the row headings are the number of outstanding large I/Os (for random large I/O tests) or the number of sequential streams (for sequential large I/O tests).
                              </p>
                              <p>The following example shows the first few data points of the Orion MBPS output CSV file for "mytest". The simple mytest command-line does not test combinations of large and small I/Os. Hence, the MBPS file has just one column corresponding to 0 outstanding small I/Os. In this example, at a load level of 8 outstanding large reads and no small I/Os, the report data indicates a throughput of 103.06 MBPS.</p><pre class="oac_no_warn" dir="ltr">Large/Small,       <span class="bold">0</span>

1,   <span class="bold">19.18</span>
2,   <span class="bold">37.59</span>
4,   <span class="bold">65.53</span>
6,  <span class="bold"> 87.03</span>
8,  <span class="bold">103.06</span>
10, <span class="bold"> 109.67</span>
. .   . . .
. .   . . .</pre><p>The following graph shows a sample data transfer rate measured at different large I/O load levels. This graph can be generated by loading <code class="codeph">mytest_mbps.csv</code> into a spreadsheet and graphing the data points. Orion does not directly generate such graphs. The x-axis corresponds to the number of outstanding large reads and the y-axis corresponds to the throughput observed.
                              </p>
                              <p>The graph shows typical storage system behavior. As the number of outstanding I/O requests is increased, the throughput increases. However, at a certain point the throughput level stabilizes, indicating the storage system's maximum throughput value.</p>
                              <div class="figure" id="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA__BABHCHCF">
                                 <p class="titleinfigure">Figure 17-2 Sample I/O Load Levels</p><img src="img/figure_172_sample_io_load_levels.gif" alt="Description of Figure 17-2 follows" title="Description of Figure 17-2 follows" longdesc="img_text/figure_172_sample_io_load_levels.html"><br><a href="img_text/figure_172_sample_io_load_levels.html">Description of "Figure 17-2 Sample I/O Load Levels"</a></div>
                              <!-- class="figure" -->
                           </li>
                           <li>
                              <p><span class="bold">mytest_iops.csv</span>: Comma-delimited value file containing the I/O throughput (in IOPS) results for the Small Random workload. Like in the MBPS file, the column headings are the number of outstanding small I/Os and the row headings are the number of outstanding large I/Os, when testing large random, or the number of sequential streams (for large sequential).
                              </p>
                              <p>In the general case, a CSV file contains a two-dimensional table. However, for a simple test where you are not testing combinations of large and small I/Os the results file has just one row. Hence, the IOPS results file just has one row with 0 large I/Os. As shown in the following example, data point with 12 outstanding small reads and no large I/Os provides a sample throughput of 951 IOPS.</p><pre class="oac_no_warn" dir="ltr">Large/Small,     1,     2,     3,     6,     9,    12 . . . .

0,             105,   208,   309,   569,   782,   951 . . . .
</pre><p>The following graph is generated by loading <code class="codeph">mytest_iops.csv</code> into Excel and charting the data. This graph illustrates the IOPS throughput seen at different small I/O load levels.
                              </p>
                              <p>The graph shows typical storage system behavior. As the number of outstanding I/O requests is increased, the throughput increases. However, at a certain point, the throughput level stabilizes, indicating the storage system reaches a maximum throughput value. At higher throughput levels, the latency for the I/O requests also increase significantly. Therefore, it is important to view this data with the latency data provided in the generated latency results in mytest_lat.csv.</p>
                              <div class="figure" id="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA__BABIBEJC">
                                 <p class="titleinfigure">Figure 17-3 I/O Throughput at Different Small I/O Load Levels</p><img src="img/figure_173_io_throughput_at_different_small_io_load_levels.gif" alt="Description of Figure 17-3 follows" title="Description of Figure 17-3 follows" longdesc="img_text/figure_173_io_throughput_at_different_small_io_load_levels.html"><br><a href="img_text/figure_173_io_throughput_at_different_small_io_load_levels.html">Description of "Figure 17-3 I/O Throughput at Different Small I/O Load Levels"</a></div>
                              <!-- class="figure" -->
                           </li>
                           <li>
                              <p><span class="bold">mytest_lat.csv</span>: Comma-delimited value file containing the latency results for the Small Random workload. As with the MBPS and IOPS files, the column headings are the number of outstanding small I/Os and the row headings are the number of outstanding large I/Os (when testing large random I/Os) or the number of sequential streams.
                              </p>
                              <p>In the general case, a CSV file contains a two-dimensional table. However, for a simple test where you are not testing combinations of large and small I/Os the results file has just one row. Hence, the IOPS results file just has one row with 0 large I/Os. In the following example, at a sustained load level of 12 outstanding small reads and no large I/Os, the generated results show an I/O turn-around latency of 22.25 milliseconds.</p><pre class="oac_no_warn" dir="ltr">Large/Small, 1, 2, 3, 6, 9, 12 . . . .

0, 14.22, 14.69, 15.09, 16.98, 18.91, 21.25 . . . .
</pre><p>The following graph is generated by loading <code class="codeph">mytest_lat.csv</code> into Excel and charting the data. This graph illustrates the small I/O latency at different small I/O load levels for mytest.
                              </p>
                              <div class="figure" id="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA__BABEIHJB">
                                 <p class="titleinfigure">Figure 17-4 I/O Latency at Small I/O Load Levels</p><img src="img/figure_174_io_latency_at_small_io_load_levels.gif" alt="Description of Figure 17-4 follows" title="Description of Figure 17-4 follows" longdesc="img_text/figure_174_io_latency_at_small_io_load_levels.html"><br><a href="img_text/figure_174_io_latency_at_small_io_load_levels.html">Description of "Figure 17-4 I/O Latency at Small I/O Load Levels"</a></div>
                              <!-- class="figure" -->
                           </li>
                           <li>
                              <p><span class="bold">mytest_trace.txt</span>: Contains the extended, unprocessed test output.
                              </p>
                              <div class="infoboxnote" id="GUID-606D7B6A-391B-4D39-9B6E-C9146D3D47BA__GUID-012A273C-C364-4CD8-ADF2-CEED48D0F815">
                                 <p class="notep1">Note:</p>
                                 <p>Orion reports errors that occur during a test on standard output.</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="TGDBA95243"></a><div class="props_rev_3"><a id="GUID-54E92BB0-B45B-45C4-8439-D873FC7E9DB8" name="GUID-54E92BB0-B45B-45C4-8439-D873FC7E9DB8"></a><h4 id="TGDBA-GUID-54E92BB0-B45B-45C4-8439-D873FC7E9DB8" class="sect4"><span class="enumeration_section">17.4.6 </span>Orion Troubleshooting
                  </h4>
                  <div>
                     <ol>
                        <li>
                           <p>If you are getting an I/O error on one or more of the volumes specified in the &lt;<span class="italic">testname</span>&gt;.lun file:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Verify that you can access the volume in the same mode as the test, read or write, using a file copy program such as <code class="codeph">dd</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Verify that your host operating system version can do asynchronous I/O.</p>
                              </li>
                              <li>
                                 <p>On Linux and Solaris, the library <code class="codeph">libaio</code> must be in the standard lib directories or accessible through the shell environment's library path variable (usually LD_LIBRARY_PATH or LIBPATH, depending on your shell).
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If you run on NAS storage:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The file system must be properly mounted for Orion to run. Please consult your Oracle Installation Guide for directions (for example, the section, Appendix B "Using NAS Devices" in the Database Installation Guide for Linux x86).</p>
                              </li>
                              <li>
                                 <p>The mytest.lun file should contain one or more paths of existing files. Orion does not work on directories or mount points. The file has to be large enough for a meaningful test. The size of this file should represent the eventual expected size of your datafiles (say, after a few years of use).</p>
                              </li>
                              <li>
                                 <p>You may see poor performance doing asynchronous I/O over NFS on Linux (including 2.6 kernels).</p>
                              </li>
                              <li>
                                 <p>If you are doing read tests and the reads are hitting untouched blocks of the file that were not initialized or previously written, some smart NAS systems may "fake" the read by returning zeroed-out blocks. When this occurs, you see unexpectedly good performance.</p>
                                 <p>The workaround is to write all blocks, using a tool such as <code class="codeph">dd</code>, before performing the read test.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If you run Orion on Windows: Testing on raw partitions requires temporarily mapping the partitions to drive letters and specifying these drive letters in the test.lun file.</p>
                        </li>
                        <li>
                           <p>If you run Orion 32-bit Linux/x86 binary on an x86_64 system: Please copy a 32-bit libaio.so file from a 32-bit computer running the same Linux version.</p>
                        </li>
                        <li>
                           <p>If you are testing with a lot of disks (<code class="codeph">num_disks</code> greater than around 30):
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>You should use the -duration option (see the optional parameters section for more details) to specify a long duration (like 120 seconds or more) for each data point. Since Orion tries to keep all the spindles running at a particular load level, each data point requires a ramp-up time, which implies a longer duration for the test.</p>
                              </li>
                              <li>
                                 <p>You may get the following error message, instructing you to increase the duration value:</p><pre class="oac_no_warn" dir="ltr">Specify a longer -duration value.
</pre><p>A duration of 2x the number of spindles seems to be a good rule of thumb. Depending on your disk technology, your platform may need more or less time.</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If you get an error about libraries being used by Orion:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Linux/Solaris: See I/O error troubleshooting.</p>
                              </li>
                              <li>
                                 <p><span class="bold">NT-Only:</span> Do not move/remove the Oracle libraries included in the distribution. These must be in the same directory as orion.exe.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If you are seeing performance numbers that are "unbelievably good":</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>You may have a large read or write cache, or read and write cache somewhere between the Orion program and the disk spindles. Typically, the storage array controller has the biggest effect. Find out the size of this cache and use the -cache_size advanced option to specify it to Orion (see the optional parameters section for more details).</p>
                              </li>
                              <li>
                                 <p>The total size of your volumes may be really small compared to one or more caches along the way. Try to turn off the cache. This is needed if the other volumes sharing your storage show significant I/O activity in a production environment (and end up using large parts of the shared cache).</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If Orion is reporting a long estimated run time:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The run time increases when <code class="codeph">-num_disks</code> is high. Orion internally uses a linear formula to determine how long it takes to saturate the given number of disks.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">-cache_size</code> parameter affects the run time, even when it is not specified. Orion does cache warming for two minutes per data point by default. If you have turned off the cache, specify <code class="codeph">-cache_size 0</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The run time increases when a long -duration value is specified, as expected.</p>
                              </li>
                           </ul>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>