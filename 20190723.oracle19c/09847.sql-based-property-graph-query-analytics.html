<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <meta name="description" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <title>SQL-Based Property Graph Query and Analytics</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Property Graph Developer’s Guide">
      <meta property="og:description" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Property Graph Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-10T15:23:57-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E94800-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="using-inmemory-analyst-oracle-database.html" title="Previous" type="text/html">
      <link rel="next" href="OPG_APIS-reference.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer's Guide">
    <meta name="dcterms.isVersionOf" content="SPGDG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-inmemory-analyst-oracle-database.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="OPG_APIS-reference.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph Developer’s Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL-Based Property Graph Query and Analytics</li>
            </ol>
            <a id="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" name="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C"></a>
            
            <h2 id="SPGDG-GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" class="sect2"><span class="enumeration_chapter">4 </span>SQL-Based Property Graph Query and Analytics
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can use SQL to query property graph data in Oracle Spatial and Graph.</p>
               <p>For the property graph support in Oracle Spatial and Graph, all the vertices and edges data are persisted in relational form in Oracle Database. For detailed information about the Oracle Spatial and Graph property graph schema objects, see <a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="The property graph PL/SQL and Java APIs use special Oracle Database schema objects.">Property Graph Schema Objects for Oracle Database</a>.
               </p>
               <p>This chapter provides examples of typical graph queries implemented using SQL. The audience includes DBAs as well as application developers who understand SQL syntax and property graph schema objects.</p>
               <p>The benefits of querying directly property graph using SQL include:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>There is no need to bring data outside Oracle Database.</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can leverage the industry-proven SQL engine provided by Oracle Database.</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can easily join or integrate property graph data with other data types (relational, JSON, XML, and so on).</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can take advantage of existing Oracle SQL tuning and database management tools and user interface.</p>
                  </li>
               </ul>
               <p>The examples assume that there is a property graph named <code class="codeph"><span class="bold">connections</span></code> in the current schema. The SQL queries and example output are for illustration purpose only, and your output may be different depending on the data in your <code class="codeph">connections</code> graph. In some examples, the output is reformatted for readability.
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-DA3E5ADB-5851-4686-8418-EFF473794846">Simple Property Graph Queries</a><br>The examples in this topic query vertices, edges, and properties of the graph.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734">Text Queries on Property Graphs</a><br>If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA">Navigation and Graph Pattern Matching</a><br>A key benefit of using a graph data model is that you can easily navigate across entities (people, movies, products, services, events, and so on) that are modeled as vertices, following links and relationships modeled as edges. In addition, graph matching templates can be defined to do such things as detect patterns, aggregate individuals, and analyze trends.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09">Navigation Options: CONNECT BY and Parallel Recursion</a><br>The CONNECT BY clause and parallel recursion provide options for advanced navigation and querying.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734">Pivot</a><br>The PIVOT clause lets you dynamically add columns to a table to create a new table.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6">SQL-Based Property Graph Analytics</a><br>In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC">Property Graph Query Language (PGQL)</a><br>PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;<span class="italic">nodes</span>&nbsp;that are connected to other nodes by&nbsp;<span class="italic">edges</span>, each of which can have key-value pairs (properties) associated with them.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C">Executing PGQL Queries Directly Against Oracle Database</a><br>This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846" name="GUID-DA3E5ADB-5851-4686-8418-EFF473794846"></a><h3 id="SPGDG-GUID-DA3E5ADB-5851-4686-8418-EFF473794846" class="sect3"><span class="enumeration_section">4.1 </span>Simple Property Graph Queries
               </h3>
               <div>
                  <p>The examples in this topic query vertices, edges, and properties of the graph.</p>
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDAVERTEXWITHASPECIFIEDVERTEXID-0857F724">
                     <p class="titleinexample">Example 4-1 Find a Vertex with a Specified Vertex ID</p>
                     <p>This example find the vertex with vertex ID 1 in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select vid, k, v, vn, vt 
      from connectionsVT$ 
      where vid=1;
</code></pre><p>The output might be as follows:</p><pre class="oac_no_warn" dir="ltr">     1 country     United States
     1 name        Barack Obama
     1 occupation  44th president of United States of America
     ...
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDANEDGEWITHASPECIFIEDEDGEID-0857FB2C">
                     <p class="titleinexample">Example 4-2 Find an Edge with a Specified Edge ID</p>
                     <p>This example find the edge with edge ID 100 in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select eid,svid,dvid,k,t,v,vn,vt 
      from connectionsGE$ 
      where eid=1000;
</code></pre><p>The output might be as follows:</p><pre class="oac_no_warn" dir="ltr">    1000  1 2 weight  3  1  1 </pre><p>In the preceding output, the K of the edge property is "weight" and the type ID of the value is 3, indicating a float value.</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__PERFORMSIMPLECOUNTING-085800A7">
                     <p class="titleinexample">Example 4-3 Perform Simple Counting</p>
                     <p>This example performs simple counting in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; -- Get the total number of K/V pairs of all the vertices
SQL&gt; select /*+ parallel */ count(1) 
       from connectionsVT$;

    299

SQL&gt; -- Get the total number of K/V pairs of all the edges
SQL&gt; select /*+ parallel(8) */ count(1) 
       from connectionsGE$;
    164

SQL&gt; -- Get the total number of vertices
SQL&gt; select /*+ parallel */ count(distinct vid) 
       from connectionsVT$;

    78

SQL&gt; -- Get the total number of edges
SQL&gt; select /*+ parallel */ count(distinct eid) 
       from connectionsGE$;

    164
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__GETTHESETOFPROPERTYKEYSUSED-0858058D">
                     <p class="titleinexample">Example 4-4 Get the Set of Property Keys Used</p>
                     <p>This example gets the set of property keys used for the vertices n the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select /*+ parallel */ distinct k 
      from connectionsVT$;

company
show
occupation
type
team
religion
criminal charge
music genre
genre
name
role
political party
country

13 rows selected.

SQL&gt; -- get the set of property keys used for edges
SQL&gt; select /*+ parallel */ distinct k 
       from connectionsGE$;

weight
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDVERTICESWITHAVALUE-085809A2">
                     <p class="titleinexample">Example 4-5 Find Vertices with a Value</p>
                     <p>This example finds vertices with a value (of any property) that is of String type, and where and the value contains two adjacent occurrences of a, e, i, o, or u, regardless of case.n the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select vid, t, k, v 
       from connectionsVT$ 
      where t=1 
        and regexp_like(v, '([aeiou])\1', 'i');

     6        1  name  Jordan Peele 
     6        1  show  Key and Peele
    54        1  name  John Green
        ...
</code></pre><p>It is usually hard to leverage a B-Tree index for the preceding kind of query because it is difficult to know beforehand what kind of regular expression is going to be used. For the above query, you might get the following execution plan. Note that full table scan is chosen by the optimizer.</p><pre class="oac_no_warn" dir="ltr">------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation            | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |                |    15 |   795 |    28    (0)| 00:00:01 |       |       |        |      |           |
|   1 |  PX COORDINATOR      |                |       |       |             |          |       |       |        |      |           |
|   2 |   PX SEND QC (RANDOM)| :TQ10000       |    15 |   795 |    28    (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND) |
|   3 |    PX BLOCK ITERATOR |                |    15 |   795 |    28    (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |           |
|*  4 |     <span class="bold">TABLE ACCESS FULL</span>| CONNECTIONSVT$ |    15 |   795 |    28    (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |           |
------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - filter(INTERNAL_FUNCTION("V") AND  REGEXP_LIKE ("V",U'([aeiou])\005C1','i') AND "T"=1 AND INTERNAL_FUNCTION("K"))
Note
-----
   - Degree of Parallelism is 2 because of table property
</pre><p>If the Oracle Database In-Memory option is available and memory is sufficient, it can help performance to place the table (full table or a set of relevant columns) in memory. One way to achieve that is as follows:</p><pre class="pre codeblock"><code>SQL&gt; alter table connectionsVT$ inmemory;
Table altered.
</code></pre><p>Now, entering the same SQL containing the regular expression shows a plan that performs a "TABLE ACCESS INMEMORY FULL".</p><pre class="oac_no_warn" dir="ltr">--------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name           | Rows  | Bytes | Cost (%CPU)  | Time     | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                |    15 |   795 |    28     (0)| 00:00:01 |       |       |        |      |            |
|   1 |  PX COORDINATOR               |                |       |       |              |          |       |       |        |      |            |
|   2 |   PX SEND QC (RANDOM)         | :TQ10000       |    15 |   795 |    28     (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    PX BLOCK ITERATOR          |                |    15 |   795 |    28     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|*  4 |     <span class="bold">TABLE ACCESS INMEMORY FULL</span>| CONNECTIONSVT$ |    15 |   795 |    28     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
---------------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - filter(INTERNAL_FUNCTION("V") AND  REGEXP_LIKE ("V",U'([aeiou])\005C1','i') AND "T"=1 AND INTERNAL_FUNCTION("K"))
Note
-----
   - Degree of Parallelism is 2 because of table property
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" name="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734"></a><h3 id="SPGDG-GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" class="sect3"><span class="enumeration_section">4.2 </span>Text Queries on Property Graphs
               </h3>
               <div>
                  <p>If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.</p>
                  <p>Oracle Text can process text that is directly stored in the database.&nbsp;The text can be short strings (such as names or addresses), or it can be full-length documents.&nbsp;These documents can be in a variety of textual format.</p>
                  <p>The text can also be in many different languages. Oracle Text can handle any space-separated languages (including character sets such as Greek or Cyrillic). In addition, Oracle Text is able to handle the Chinese, Japanese and Korean pictographic languages)</p>
                  <p>Because the property graph feature uses NVARCHAR typed column for better support of Unicode, it is <span class="bold"><span class="italic">highly recommended</span></span> that UTF8 (AL32UTF8) be used as the database character set.
                  </p>
                  <p>To create an Oracle Text index on the vertices table (or edges table),&nbsp;the ALTER SESSION privilege is required. For example:</p><pre class="pre codeblock"><code>SQL&gt; grant alter session to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>If customization is required, also grant the EXECUTE privilege on CTX_DDL:</p><pre class="pre codeblock"><code>SQL&gt; grant execute on ctx_ddl to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>The following shows some example statements for granting these privileges to SCOTT.</p><pre class="pre codeblock"><code>SQL&gt; conn / as sysdba
Connected.
SQL&gt; -- This is a PDB setup -- 
SQL&gt; alter session set container=orcl;
Session altered.

SQL&gt; grant execute on ctx_ddl to scott;
Grant succeeded.

SQL&gt; grant alter session to scott;
Grant succeeded.
</code></pre><div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-66A640E6-CE39-4297-BED9-0C4D05C028C2">
                     <p class="titleinexample">Example 4-6 <span class="bold">Create a Text Index</span></p>
                     <p>This example creates an Oracle Text index on the vertices table (V column) of the connections graph in the SCOTT schema. Note that unlike the text index capabilities provided by either Apache Lucene or Apache SolrCloud, the Oracle Text index created here is for <span class="bold"><span class="italic">all </span></span> property keys, not just one or a subset of property keys. In addition, if a new property is added to the graph and the property value is of String data type, then it will automatically be included in the same text index.
                     </p>
                     <p>The example uses the OPG_AUTO_LEXER lexer owned by MDSYS.</p><pre class="pre codeblock"><code>SQL&gt; execute opg_apis.create_vertices_text_idx('scott', 'connections', pref_owner=&gt;'MDSYS', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;2);</code></pre><p>If customization is desired, you can use the ctx_ddl.create_preference API. For example:</p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_AUTO_LEXER', 'AUTO_LEXER');

PL/SQL procedure successfully completed.

SQL&gt; execute opg_apis.create_vertices_text_idx('scott', 'connections', pref_owner=&gt;'scott', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;2);

PL/SQL procedure successfully completed.
</code></pre><p>You can now use a rich set of functions provided  by Oracle Text to perform queries against graph elements.</p>
                     <div class="infoboxnote" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-0E694C49-E268-441E-B753-B5284CD9B1D1">
                        <p class="notep1">Note:</p>
                        <p>If you no longer need an Oracle Text index, you can use the drop_vertices_text_idx or opg_apis.drop_edges_text_idx API to drop it. The following statements drop the text indexes on the vertices and edges of a graph named <code class="codeph">connections</code> owned by SCOTT:
                        </p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.drop_vertices_text_Idx('scott', 'connections');
SQL&gt; exec opg_apis.drop_edges_text_Idx('scott', 'connections');</code></pre></div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7359CE86-2325-4159-9CBE-9D0B5B5F2405">
                     <p class="titleinexample">Example 4-7 Find a Vertex that Has a Property Value</p>
                     <p>The following example find a vertex that has a property value (of string type) containing the keyword "Obama".</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v 
       from connectionsVT$ 
      where t=1 
        and contains(v, 'Obama', 1) &gt; 0 
      order by score(1) desc
      ;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows. Note that DOMAIN INDEX appears as an operation in the execution plan.</p><pre class="oac_no_warn" dir="ltr">     1  name    1  Barack Obama

Execution Plan
----------------------------------------------------------
Plan hash value: 1619508090

-----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name            | Rows  | Bytes | Cost (%CPU) | Time     | Pstart| Pstop |
-----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                 |     1 |    56 |     5  (20) | 00:00:01 |       |       |
|   1 |  SORT ORDER BY                      |                 |     1 |    56 |     5  (20) | 00:00:01 |       |       |
|*  2 |   TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |     1 |    56 |     4    (0)| 00:00:01 | ROWID | ROWID |
|*  3 |    <span class="bold">DOMAIN INDEX</span>                     | CONNECTIONSXTV$ |       |       |     4    (0)| 00:00:01 |       |       |
-----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("T"=1 AND INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   3 - access("CTXSYS"."CONTAINS"("V",'Obama',1)&gt;0)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7982C91F-7911-43D3-A2E5-39D5428082D5">
                     <p class="titleinexample">Example 4-8 Fuzzy Match</p>
                     <p>The following example finds a vertex that has a property value (of string type) containing variants of "ameriian" (a deliberate misspelling for this example) Fuzzy match is used.</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v 
       from connectionsVT$ 
      where contains(v, <span class="bold">'fuzzy</span>(ameriian,,,weight)', 1) &gt; 0 
      order by score(1) desc;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows.</p><pre class="oac_no_warn" dir="ltr">     8 role      1  american business man
     9 role      1  american business man
     4 role      1  american economist
     6 role      1  american comedian actor
     7 role      1  american comedian actor
     1 occupation 1 44th president of United States of America

6 rows selected.

Execution Plan
----------------------------------------------------------
Plan hash value: 1619508090

-----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
-----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                 |     1 |    56 |     5  (20)| 00:00:01 |       |       |
|   1 |  SORT ORDER BY                      |                 |     1 |    56 |     5  (20)| 00:00:01 |       |       |
|*  2 |   TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |     1 |    56 |     4   (0)| 00:00:01 | ROWID | ROWID |
|*  3 |    DOMAIN INDEX                     | CONNECTIONSXTV$ |       |       |     4   (0)| 00:00:01 |       |       |
-----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter(INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-80227A76-367F-4735-A49A-94D8C45D704E">
                     <p class="titleinexample">Example 4-9 Query Relaxation</p>
                     <p>The following example is a sophisticated Oracle Text query that implements <span class="bold">query relaxation</span>, which enables you to execute the most restrictive version of a query first, progressively relaxing the query until the required number of matches is obtained. Using query relaxation with queries that contain multiple strings, you can provide guidance for determining the “best” matches, so that these appear earlier in the results than other potential matches.
                     </p>
                     <p>This example searchs for "american actor" with a query relaxation sequence.</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v  
       from connectionsVT$ 
      where <span class="bold">CONTAINS</span> (v,
 '&lt;query&gt;
   &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt;
<span class="bold">     &lt;progression&gt;
       &lt;seq&gt;{american} {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} NEAR {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} AND {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} ACCUM {actor}&lt;/seq&gt;
     &lt;/progression&gt;
   &lt;/textquery&gt;</span>
   &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
  &lt;/query&gt;') &gt; 0;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows.</p><pre class="oac_no_warn" dir="ltr">     7 role       1 american comedian actor
     6 role       1 american comedian actor
    44 occupation 1 actor
     8 role       1 american business man
    53 occupation 1 actor film producer
    52 occupation 1 actor
     4 role       1 american economist
    47 occupation 1 actor
     9 role       1 american business man

9 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2158361449

----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                          | Name         | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                   |                 |       1 |      56 |       4   (0)| 00:00:01 |         |         |
|*  1 |  TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |       1 |      56 |       4   (0)| 00:00:01 | ROWID | ROWID |
|*  2 |   DOMAIN INDEX                     | CONNECTIONSXTV$ |         |         |       4   (0)| 00:00:01 |         |         |
----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter(INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   2 - access("CTXSYS"."CONTAINS"("V",'&lt;query&gt;      &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt;
          &lt;progression&gt;       &lt;seq&gt;{american} {actor}&lt;/seq&gt;    &lt;seq&gt;{american} NEAR {actor}&lt;/seq&gt;
          &lt;seq&gt;{american} AND {actor}&lt;/seq&gt;        &lt;seq&gt;{american} ACCUM {actor}&lt;/seq&gt;    &lt;/progression&gt;
          &lt;/textquery&gt;    &lt;score datatype="INTEGER" algorithm="COUNT"/&gt; &lt;/query&gt;')&gt;0)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-901379A5-6980-47A3-B55A-15B29B3E5344">
                     <p class="titleinexample">Example 4-10 Find an Edge</p>
                     <p>Just as with vertices, you can create an Oracle Text index on the V column of the edges table (GE$) of a property graph. The following example uses the OPG_AUTO_LEXER lexer owned by MDSYS.</p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.create_edges_text_idx('scott', 'connections', pref_owner=&gt;'mdsys', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;4);</code></pre><p>If customization is required, use the ctx_ddl.create_preference API.</p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" name="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA"></a><h3 id="SPGDG-GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" class="sect3"><span class="enumeration_section">4.3 </span>Navigation and Graph Pattern Matching
               </h3>
               <div>
                  <p>A key benefit of using a graph data model is that you can easily navigate across entities (people, movies, products, services, events, and so on) that are modeled as vertices, following links and relationships modeled as edges. In addition, graph matching templates can be defined to do such things as detect patterns, aggregate individuals, and analyze trends.</p>
                  <p>This topic provides graph navigation and pattern matching examples using the example property graph named connections. Most of the SQL statements are relatively simple, but they can be used as building blocks to implement requirements that are more sophisticated. It is generally best to start from something simple, and progressively add complexity.</p>
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__WHOAREAPERSONSCOLLABORATORS-3728428C">
                     <p class="titleinexample">Example 4-11 Who Are a Person's Collaborators?</p>
                     <p>The following SQL ststement finds all entities that a vertex with ID 1 collaborates with. For simplicity, it considers <span class="bold">only </span>outgoing relationships.
                     </p><pre class="pre codeblock"><code>SQL&gt; select dvid, el, k, vn, v 
       from connectionsGE$ 
      where svid=1 
        and el='collaborates';
</code></pre><div class="infoboxnote" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-E9C22EA0-FA62-4D83-9F63-2A5C9565F5B7">
                        <p class="notep1">Note:</p>
                        <p>To find the specific vertex ID of interest, you can perform a text query on the property graph using keywords or fuzzy matching. (For details and examples, see <a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" title="If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.">Text Queries on Property Graphs</a>.)
                        </p>
                     </div>
                     <p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">     2 collaborates weight 1 1
    21 collaborates weight 1 1
    22 collaborates weight 1 1
      ....
    26 collaborates weight 1 1


10 rows selected.


-------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                    | Name            | Rows  | Bytes | Cost (%CPU)| Time      | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
-------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                             |                 |    10 |   460 |     2     (0)| 00:00:01 |       |       |        |      |        |
|   1 |  PX COORDINATOR                              |                 |       |       |              |          |       |       |        |      |        |
|   2 |   PX SEND QC (RANDOM)                        | :TQ10000        |    10 |   460 |     2     (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    PX PARTITION HASH ALL                     |                 |    10 |   460 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |        |
|*  4 |     TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |    10 |   460 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|*  5 |      INDEX RANGE SCAN                        | CONNECTIONSXSE$ |    20 |       |     1     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
-------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates' AND INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   5 - access("SVID"=1)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-78270F51-B255-4B34-BEBB-FB231FC2094F">
                     <p class="titleinexample">Example 4-12 Who Are a Person's Collaborators and What are Their Occupations?</p>
                     <p>The following SQL statement finds collaborators of the vertex with ID 1, and the occupation of each collaborator. A join with the vertices table (VT$) is required.</p><pre class="pre codeblock"><code>SQL&gt; select dvid, vertices.v 
       from connectionsGE$, connectionsVT$ vertices 
      where svid=1 
        and el='collaborates' 
        and dvid=vertices.vid 
        and vertices.k='occupation';
</code></pre><p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">    21  67th United States Secretary of State
    22  68th United States Secretary of State
    23  chancellor
    28  7th president of Iran
    19  junior United States Senator from New York
...


--------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                     | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
--------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                              |                 |     7 |   525 |     7   (0)| 00:00:01 |       |       |     |    |         |
|   1 |  PX COORDINATOR                               |                 |       |       |            |          |       |       |     |    |         |
|   2 |   PX SEND QC (RANDOM)                         | :TQ10000        |     7 |   525 |     7   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    NESTED LOOPS                               |                 |     7 |   525 |     7   (0)| 00:00:01 |       |       |  Q1,00 | PCWP |         |
|   4 |     PX PARTITION HASH ALL                     |                 |    10 |   250 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |         |
|*  5 |      TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |    10 |   250 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |         |
|*  6 |       INDEX RANGE SCAN                        | CONNECTIONSXSE$ |    20 |       |     1   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |         |
|   7 |     PARTITION HASH ITERATOR                   |                 |     1 |       |     0   (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |         |
|*  8 |      TABLE ACCESS BY LOCAL INDEX ROWID        | CONNECTIONSVT$  |       |       |            |          |   KEY |   KEY |  Q1,00 | PCWP |         |
|*  9 |       INDEX UNIQUE SCAN                       | CONNECTIONSXQV$ |     1 |       |     0   (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |         |
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates')
   6 - access("SVID"=1)
   8 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
   9 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'occupation')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-BAEE2D4E-8A3E-44E9-B715-98F3A5C10894">
                     <p class="titleinexample">Example 4-13 Find a Person's Enemies and Aggregate Them by Their Country</p>
                     <p>The following SQL statement finds enemies (that is, those with the <code class="codeph">feuds</code> relationship) of the vertex with ID 1, and aggregates them by their countries. A join with the vertices table (VT$) is required.
                     </p><pre class="pre codeblock"><code>SQL&gt;   select vertices.v, count(1) 
         from connectionsGE$, connectionsVT$ vertices 
        where svid=1 
          and el='feuds'  
          and dvid=vertices.vid 
          and vertices.k='country' 
     group by vertices.v;
</code></pre><p>The example's output and execution plan may be as follows. In this case, the vertex with ID 1 has 3 enemies in the United States and 1 in Russia.</p><pre class="oac_no_warn" dir="ltr">United States      3
Russia             1


------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                     | Name            | Rows   | Bytes  | Cost (%CPU)| Time      | Pstart| Pstop |     TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                              |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |        |      |         |
|   1 |  PX COORDINATOR                               |                 |        |        |             |          |        |        |        |      |         |
|   2 |   PX SEND QC (RANDOM)                         | :TQ10001        |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | P-&gt;S | QC (RAND)  |
|   3 |    HASH GROUP BY                              |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | PCWP |         |
|   4 |     PX RECEIVE                                |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | PCWP |         |
|   5 |      PX SEND HASH                             | :TQ10000        |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,00 | P-&gt;P | HASH     |
|   6 |       HASH GROUP BY                           |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,00 | PCWP |         |
|   7 |        NESTED LOOPS                           |                 |      5 |    375 |      4   (0)| 00:00:01 |        |        |  Q1,00 | PCWP |         |
|   8 |     PX PARTITION HASH ALL                     |                 |      5 |    125 |      2   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWC |         |
|*  9 |      TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |      5 |    125 |      2   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWP |         |
|* 10 |       INDEX RANGE SCAN                        | CONNECTIONSXSE$ |     20 |        |      1   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWP |         |
|  11 |     PARTITION HASH ITERATOR                   |                 |      1 |        |      0   (0)| 00:00:01 |    KEY |    KEY |  Q1,00 | PCWP |         |
|* 12 |      TABLE ACCESS BY LOCAL INDEX ROWID        | CONNECTIONSVT$  |        |        |             |          |    KEY |    KEY |  Q1,00 | PCWP |         |
|* 13 |       INDEX UNIQUE SCAN                       | CONNECTIONSXQV$ |      1 |        |      0   (0)| 00:00:01 |    KEY |    KEY |  Q1,00 | PCWP |         |
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   9 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'feuds')
  10 - access("SVID"=1)
  12 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
  13 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'country')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-6C71C301-6678-478B-AD45-15CAF8CA2C51">
                     <p class="titleinexample">Example 4-14 Find a Person's Collaborators, and aggregate and sort them</p>
                     <p>The following SQL statement finds the collaborators of the vertex with ID 1, aggregates them by their country, and sorts them in ascending order.</p><pre class="pre codeblock"><code>SQL&gt; select vertices.v, count(1) 
      from connectionsGE$, connectionsVT$ vertices 
     where svid=1 
       and el='collaborates' 
       and dvid=vertices.vid 
       and vertices.k='country' 
  group by vertices.v 
  order by count(1) asc;
</code></pre><p>The example output and execution plan may be as follows. In this case, the vertex with ID 1 has the most collaborators in the United States.</p><pre class="oac_no_warn" dir="ltr">Germany        1
Japan          1
Iran           1
United States  7


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                         | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                                  |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |        |      |        |
|   1 |  PX COORDINATOR                                   |                 |       |       |              |          |       |       |        |      |        |
|   2 |   PX SEND QC (ORDER)                              | :TQ10002        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | P-&gt;S | QC (ORDER) |
|   3 |    SORT ORDER BY                                  |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | PCWP |        |
|   4 |     PX RECEIVE                                    |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | PCWP |        |
|   5 |      PX SEND RANGE                                | :TQ10001        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | P-&gt;P | RANGE  |
|   6 |       HASH GROUP BY                               |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | PCWP |        |
|   7 |        PX RECEIVE                                 |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | PCWP |        |
|   8 |     PX SEND HASH                                  | :TQ10000        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,00 | P-&gt;P | HASH   |
|   9 |      HASH GROUP BY                                |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,00 | PCWP |        |
|  10 |       NESTED LOOPS                                |                 |    10 |   750 |     7     (0)| 00:00:01 |       |       |  Q1,00 | PCWP |        |
|  11 |        PX PARTITION HASH ALL                      |                 |    10 |   250 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |        |
|* 12 |         TABLE ACCESS BY LOCAL INDEX ROWID BATCHED | CONNECTIONSGE$  |    10 |   250 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|* 13 |          INDEX RANGE SCAN                         | CONNECTIONSXSE$ |    20 |       |     1     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|  14 |        PARTITION HASH ITERATOR                    |                 |     1 |       |     0     (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |        |
|* 15 |         TABLE ACCESS BY LOCAL INDEX ROWID         | CONNECTIONSVT$  |       |       |        |                |   KEY |   KEY |  Q1,00 | PCWP |        |
|* 16 |          INDEX UNIQUE SCAN                        | CONNECTIONSXQV$ |     1 |       |     0     (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |        |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

  12 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates')
  13 - access("SVID"=1)
  15 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
  16 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'country')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" name="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09"></a><h3 id="SPGDG-GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" class="sect3"><span class="enumeration_section">4.4 </span>Navigation Options: CONNECT BY and Parallel Recursion
               </h3>
               <div>
                  <p>The CONNECT BY clause and parallel recursion provide options for advanced navigation and querying.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>CONNECT BY lets you navigate and find matches in a hierarchical order. To follow outgoing edges, you can use prior dvid = svid to guide the navigation.</p>
                     </li>
                     <li>
                        <p>Parallel recursion lets you perform navigation up to a specified number of hops away.</p>
                     </li>
                  </ul>
                  <p>The examples use a property graph named connections.</p>
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__WHOAREAPERSONSCOLLABORATORS-37415127">
                     <p class="titleinexample">Example 4-15 CONNECT WITH</p>
                     <p>The following SQL statement follows the outgoing edges by 1 hop.</p><pre class="pre codeblock"><code>SQL&gt; select G.dvid
       from connectionsGE$ G
      start with svid = 1
    <span class="bold">connect by</span> nocycle prior dvid = svid and <span class="bold">level &lt;= 1</span>;
</code></pre><p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">         2
         3
         4
         5
         6
         7
         8
         9
        10
        ...
------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                 | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT          |                 |     7 |   273 |     3  (67)| 00:00:01 |       |       |        |      |            |
|*  1 |  CONNECT BY WITH FILTERING|                 |       |       |            |          |       |       |        |      |            |
|   2 |   PX COORDINATOR          |                 |       |       |            |          |       |       |        |      |            |
|   3 |    PX SEND QC (RANDOM)    | :TQ10000        |     2 |    12 |     0   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   4 |     PX PARTITION HASH ALL |                 |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|*  5 |      INDEX RANGE SCAN     | CONNECTIONSXSE$ |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
|*  6 |   FILTER                  |                 |       |       |            |          |       |       |        |      |            |
|   7 |    NESTED LOOPS           |                 |     5 |    95 |     1   (0)| 00:00:01 |       |       |        |      |            |
|   8 |     CONNECT BY PUMP       |                 |       |       |            |          |       |       |        |      |            |
|   9 |     PARTITION HASH ALL    |                 |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |        |      |            |
|* 10 |      INDEX RANGE SCAN     | CONNECTIONSXSE$ |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |        |      |            |
------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("SVID"=PRIOR "DVID")
       filter(LEVEL&lt;=2)
   5 - access("SVID"=1)
   6 - filter(LEVEL&lt;=2)
  10 - access("connect$_by$_pump$_002"."prior dvid "="SVID")
</pre><p>To extend from 1 hop to multiple hops, change 1 in the preceding example to another integer. For example, to change it to 2 hops, specify: <code class="codeph">level &lt;= 2</code></p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__GUID-C848A824-CDA0-4758-B46D-467E3F9E7C54">
                     <p class="titleinexample">Example 4-16 Parallel Recursion</p>
                     <p>The following SQL statement uses recursion within the WITH clause to perform navigation up to 4 hops away, a using recursively defined graph expansion: <code class="codeph">g_exp</code> references <code class="codeph">g_exp</code> in the query, and that defines the recursion. The example also uses the PARALLEL optimizer hint for parallel execution.
                     </p><pre class="pre codeblock"><code>SQL&gt; WITH <span class="bold">g_exp</span>(svid, dvid, depth) as
  ( 
    select svid as svid, dvid as dvid, 0 as depth
      from connectionsGE$
     where svid=1
   union all
     select g2.svid,  g1.dvid, g2.depth + 1
       from <span class="bold">g_exp</span> g2, connectionsGE$ g1
      where g2.dvid=g1.svid
        and g2.depth &lt;= 3
  )   
select  /*+ parallel(4) */ dvid, depth
  from  g_exp
 where svid=1
;
</code></pre><p>The example's output and execution plan may be as follows. Note that <code class="codeph">CURSOR DURATION MEMORY</code> is chosen in the execution, which indicates the graph expansion stores the intermediate data in memory.
                     </p><pre class="oac_no_warn" dir="ltr">        22          4
        25          4
        24          4
         1          4

        23          4
        33          4
        22          4
        22          4
       ...         ...


Execution Plan
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                    | Name                       | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                             |                            |   801 | 31239 |   147   (0)| 00:00:01 |       |       |        |      |            |
|   1 |  TEMP TABLE TRANSFORMATION                   |                            |       |       |            |          |       |       |        |      |            |
|   2 |   LOAD AS SELECT (<span class="bold">CURSOR DURATION MEMORY</span>)    | SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |        |      |            |
|   3 |    UNION ALL (RECURSIVE WITH) BREADTH FIRST  |                            |       |       |            |          |       |       |        |      |            |
|   4 |     PX COORDINATOR                           |                            |       |       |            |          |       |       |        |      |            |
|   5 |      PX SEND QC (RANDOM)                     | :TQ20000                   |     2 |    12 |     0   (0)| 00:00:01 |       |       |  Q2,00 | P-&gt;S | QC (RAND)  |
|   6 |       LOAD AS SELECT (CURSOR DURATION MEMORY)| SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q2,00 | PCWP |            |
|   7 |        PX PARTITION HASH ALL                 |                            |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q2,00 | PCWC |            |
|*  8 |         INDEX RANGE SCAN                     | CONNECTIONSXSE$            |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q2,00 | PCWP |            |
|   9 |     PX COORDINATOR                           |                            |       |       |            |          |       |       |        |      |            |
|  10 |      PX SEND QC (RANDOM)                     | :TQ10000                   |   799 |    12M|    12   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|  11 |       LOAD AS SELECT (CURSOR DURATION MEMORY)| SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|* 12 |        HASH JOIN                             |                            |   799 |    12M|    12   (0)| 00:00:01 |       |       |  Q1,00 | PCWP |            |
|  13 |         BUFFER SORT (REUSE)                  |                            |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|  14 |          PARTITION HASH ALL                  |                            |   164 |   984 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|  15 |           INDEX FAST FULL SCAN               | CONNECTIONSXDE$            |   164 |   984 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
|  16 |         PX BLOCK ITERATOR                    |                            |       |       |            |          |       |       |  Q1,00 | PCWC |            |
|* 17 |          TABLE ACCESS FULL                   | SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|  18 |   PX COORDINATOR                             |                            |       |       |            |          |       |       |        |      |            |
|  19 |    PX SEND QC (RANDOM)                       | :TQ30000                   |   801 | 31239 |   135   (0)| 00:00:01 |       |       |  Q3,00 | P-&gt;S | QC (RAND)  |
|* 20 |     VIEW                                     |                            |   801 | 31239 |   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWP |            |
|  21 |      PX BLOCK ITERATOR                       |                            |   801 |    12M|   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWC |            |
|  22 |       TABLE ACCESS FULL                      | SYS_TEMP_0FD9D6614_11CB2D2 |   801 |    12M|   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWP |            |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("SVID"=1)
  12 - access("G2"."DVID"="G1"."SVID")
  17 - filter("G2"."INTERNAL_ITERS$"=LEVEL AND "G2"."DEPTH"&lt;=3)
  20 - filter("SVID"=1)
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" name="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734"></a><h3 id="SPGDG-GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" class="sect3"><span class="enumeration_section">4.5 </span>Pivot
               </h3>
               <div>
                  <p>The PIVOT clause lets you dynamically add columns to a table to create a new table.</p>
                  <p>The schema design (VT$ and GE$) of the property graph is narrow ("skinny") rather than wide ("fat"). This means that if a vertex or edge has multiple properties, those property keys, values, data types, and so on will be stored using multiple rows instead of multiple columns. Such a design is very flexible in the sense that you can add properties dynamically without having to worry about adding too many columns or even reaching the physical maximum limit of number of columns a table may have. However, for some applications you may prefer to have a wide table if the properties are somewhat homogeneous.</p>
                  <div class="example" id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734__PARALLELRECURSION-3744C9CA">
                     <p class="titleinexample">Example 4-17 Pivot</p>
                     <p>The following CREATE TABLE ... AS SELECT statement uses PIVOT to add four columns: ‘company’,’ occupation’,’ name’, and ‘religion’.</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE table pg_wide
as
 with G AS (select vid, k, t, v
              from connectionsVT$
           )
 select *
   from G
  pivot (
    min(v) for k in ('company', 'occupation', 'name', 'religion')
  );

Table created.
</code></pre><p>The following DESCRIBE statement shows the definition of the new table, including the four added columns. (The output is reformatted for readability.)</p><pre class="pre codeblock"><code>SQL&gt; DESCRIBE pg_wide;
 Name                                                  Null?    Type
--------------------------------------------------- -------- --------------------
 VID                                                   NOT NULL NUMBER
 T                                                              NUMBER(38)
 'company'                                                      NVARCHAR2(15000)
 'occupation'                                                   NVARCHAR2(15000)
 'name'                                                         NVARCHAR2(15000)
 'religion'                                                     NVARCHAR2(15000)
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" name="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6"></a><h3 id="SPGDG-GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" class="sect3"><span class="enumeration_section">4.6 </span>SQL-Based Property Graph Analytics
               </h3>
               <div>
                  <p>In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.</p>
                  <p>The benefits of SQL-based analytics are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Easier analysis of larger graphs that do not fit in physical memory</p>
                     </li>
                     <li>
                        <p>Cheaper analysis since no graph data is transferred outside the database</p>
                     </li>
                     <li>
                        <p>Better analysis using the current state of a property graph database</p>
                     </li>
                     <li>
                        <p>Simpler analysis by eliminating the step of synchronizing an in-memory graph with the latest updates from the graph database</p>
                     </li>
                  </ul>
                  <p>However, when a graph (or a subgraph) fits in memory, then running analytics provided by the in-memory analyst usually provides better performance than using SQL-based analytics.</p>
                  <p>Because many of the analytics implementation require using intermediate data structures, most SQL- (and PL/SQL-) based analytics APIs have parameters for working tables (wt). A typical flow has the following steps:</p>
                  <ol>
                     <li>
                        <p>Prepare the working table or tables.</p>
                     </li>
                     <li>
                        <p>Perform analytics (one or multiple calls).</p>
                     </li>
                     <li>
                        <p>Perform cleanup</p>
                     </li>
                  </ol>
                  <p>The following subtopics provide SQL-based examples of some popular types of property graph analytics.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-1A615347-46A0-4D93-8A65-B25113403DC8">Shortest Path Examples</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4">Collaborative Filtering Overview and Examples</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8" name="GUID-1A615347-46A0-4D93-8A65-B25113403DC8"></a><h4 id="SPGDG-GUID-1A615347-46A0-4D93-8A65-B25113403DC8" class="sect4"><span class="enumeration_section">4.6.1 </span>Shortest Path Examples
                  </h4>
                  <div>
                     <p>The following examples demonstrate SQL-based shortest path analytics.</p>
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__SHORTESTPATH-2BED45B2">
                        <p class="titleinexample">Example 4-18 Shortest Path Setup and Computation</p>
                        <p>Consider shortest path, for example. Internally, Oracle Database uses the bidirectional Dijkstra algorithm. The following code snippet shows an entire prepare, perform, and cleanup&nbsp; workflow.</p><pre class="pre codeblock"><code>set serveroutput on
  
DECLARE   
  wt1 varchar2(100);  -- intermediate working tables
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  -- prepare
  opg_apis.find_sp_prep('connectionsGE$', wt1);
  dbms_output.put_line('working table name    ' || wt1);

  -- compute
  opg_apis.find_sp(
     'connectionsGE$',
      1,                          -- start vertex ID
      53,                         -- destination vertex ID
      wt1,                        -- working table (for Dijkstra expansion)
      dop =&gt; 1,                   -- degree of parallelism
      stats_freq=&gt;1000,           -- frequency to collect statistics
      path_output =&gt; path,        -- shortest path (a sequence of vertices)
      weights_output =&gt; weights,  -- edge weights
      options =&gt; null
      );
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup (commented out here; see text after the example)
  -- opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>This example may produce the following output. Note that if <span class="bold"><span class="italic">no </span></span>working table name is provided, the preparation step will automatically generate a temporary table name and create it. Because the temporary working table name uses the session ID, your output will probably be different.
                        </p><pre class="oac_no_warn" dir="ltr">working table name    "CONNECTIONSGE$$TWFS12"
path    1 3    52 53
weights 4 3 1    1 1

PL/SQL procedure successfully completed.
</pre><p>If you want to know the definition of the working table or tables, then skip the cleanup phase (as shown in the preceding example that comments out the call to <code class="codeph">find_sp_cleanup</code>). After the computation is done, you can describe the working table or tables.
                        </p><pre class="pre codeblock"><code>SQL&gt; describe "CONNECTIONSGE$$TWFS12"
 Name                Null?    Type
 --------- -------- ----------------------------
 NID                            NUMBER
 D2S                            NUMBER
 P2S                            NUMBER
 D2T                            NUMBER
 P2T                            NUMBER
 F                            NUMBER(38)
 B                            NUMBER(38)
</code></pre><p>For advanced users who want to try different table creation options, such as using in-memory or advanced compression, you can pre-create the preceding working table and pass the name in.</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__CREATEWORKINGTABLEANDPERFORMANALYTI-2BED4E8B">
                        <p class="titleinexample">Example 4-19 Shortest Path: Create Working Table and Perform Analytics</p>
                        <p>The following statements show some advanced options, first creating a working table with the same column structure and basic compression enabled, then passing it to the SQL-based computation. The code optimizes the intermediate table for computations with CREATE TABLE compression and in-memory options.</p><pre class="pre codeblock"><code>create table connections<span class="bold">$MY_EXP</span>(
 NID                            NUMBER,
 D2S                            NUMBER,
 P2S                            NUMBER,
 D2T                            NUMBER,
 P2T                            NUMBER,
 F                            NUMBER(38),
 B                            NUMBER(38)
) <span class="bold">compress</span> nologging;


DECLARE
  wt1 varchar2(100) := '<span class="bold">connections$MY_EXP</span>';
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  dbms_output.put_line('working table name    ' || wt1);

  -- compute
  opg_apis.find_sp(
     'connectionsGE$',
      1,
      53,
      wt1,
      dop =&gt; 1,
      stats_freq=&gt;1000,
      path_output =&gt; path,
      weights_output =&gt; weights,
      options =&gt; null
      );
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup
  -- opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>At the end of the computation, if the working table has not been dropped or truncated, you can check the content of the working table, as follows. Note that the working table structure may vary between releases.</p><pre class="pre codeblock"><code>SQL&gt; select * from connections$MY_EXP;
       NID        D2S        P2S        D2T        P2T          F          B
---------- ---------- ---------- ---------- ---------- ---------- ----------
         1          0            1.000E+100                     1         -1
        53 1.000E+100                     0                    -1          1
        54 1.000E+100                     1         53         -1          1
        52 1.000E+100                     1         53         -1          1
         5          1          1 1.000E+100                     0         -1
        26          1          1 1.000E+100                     0         -1
         8       1000          1 1.000E+100                     0         -1
         3          1          1          2         52          0          0
        15          1          1 1.000E+100                     0         -1
        21          1          1 1.000E+100                     0         -1
        19          1          1 1.000E+100                     0         -1
       ...
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__MULTIPLECALLSTOSAMEGRAPH-2BED5961">
                        <p class="titleinexample">Example 4-20 Shortest Path: Perform Multiple Calls to Same Graph</p>
                        <p>To perform multiple calls to the same graph, only <span class="italic">a single call</span> to the preparation step is needed. The following shows an example of computing shortest path for multiple pairs of vertices in the same graph.
                        </p><pre class="pre codeblock"><code>DECLARE
  wt1 varchar2(100);  -- intermediate working tables
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  -- prepare
  opg_apis.find_sp_prep('connectionsGE$', wt1);
  dbms_output.put_line('working table name    ' || wt1);

  <span class="bold">-- find shortest path from vertex 1 to vertex 53</span>
  opg_apis.find_sp( 'connectionsGE$', 1, 53,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  <span class="bold">-- find shortest path from vertex 2 to vertex 36</span>
  opg_apis.find_sp( 'connectionsGE$', 2, 36,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  <span class="bold">-- find shortest path from vertex 30 to vertex 4
</span>  opg_apis.find_sp( 'connectionsGE$', 30, 4,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup
  opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>The example's output may be as follows: three shortest paths have been found for the multiple pairs of vertices provided.</p><pre class="oac_no_warn" dir="ltr">working table name    "CONNECTIONSGE$$TWFS12"
path    1 3    52 53
weights 4 3 1   1 1
path    2    36
weights 2 1   1
path    30 21    1 4
weights 4 3 1   1 1

PL/SQL procedure successfully completed.
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" title="In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.">SQL-Based Property Graph Analytics</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4" name="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4"></a><h4 id="SPGDG-GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4" class="sect4"><span class="enumeration_section">4.6.2 </span>Collaborative Filtering Overview and Examples
                  </h4>
                  <div>
                     <p><a href="http://recommender-systems.org/collaborative-filtering/" target="_blank">Collaborative filtering</a>, also referred to as social filtering, filters information by using the recommendations of other people. Collaborative filtering is widely used in systems that recommend purchases based on purchases by others with similar preferences.
                     </p>
                     <p>The following examples demonstrate SQL-based collaborative filtering analytics.</p>
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__SHORTESTPATH-2BED9144">
                        <p class="titleinexample">Example 4-21 <span class="bold">Collaborative Filtering Setup and Computation</span></p>
                        <p>This example shows how to use SQL-based collaborative filtering, specifically using matrix factorization to recommend telephone brands to customers. This example assumes there exists a graph called "PHONES" in the database. This example graph contains customer and item vertices, and edges with a 'rating' label linking some customer vertices to other some item vertices. The rating labels have a numeric value corresponding to the rating that a specific customer (edge OUT vertex) assigned to the specified product (edge IN vertex).</p>
                        <p>The following figure shows this graph.</p>
                        <div class="figure" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__GUID-1493488D-3D02-4A36-BD86-A7F6C8783845">
                           <p class="titleinfigure">Figure 4-1 Phones Graph for Collaborative Filtering</p><img src="img/collaborative-filtering.jpg" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows" longdesc="img_text/collaborative-filtering.html"><br><a href="img_text/collaborative-filtering.html">Description of "Figure 4-1 Phones Graph for Collaborative Filtering"</a></div>
                        <!-- class="figure" -->The following code shows an end-to-end flow to run the SQL-based collaborative filtering algorithm, which internally uses the matrix factorization algorithm.<pre class="pre codeblock"><code>set serveroutput on

DECLARE
  wt_l varchar2(32);  -- working tables
  wt_r varchar2(32);
  wt_l1 varchar2(32);
  wt_r1 varchar2(32);
  wt_i varchar2(32);
  wt_ld varchar2(32);
  wt_rd varchar2(32);
  edge_tab_name    varchar2(32) := 'phonesge$';
  edge_label       varchar2(32) := 'rating';
  rating_property  varchar2(32) := '';
  iterations       integer      := 100;
  min_error        number       := 0.001;
  k                integer      := 5;
  learning_rate    number       := 0.001;
  decrease_rate    number       := 0.95;
  regularization   number       := 0.02;
  dop              number       := 2;
  tablespace       varchar2(32) := null;
  options          varchar2(32) := null; 
BEGIN

  -- prepare
  opg_apis.cf_prep(edge_tab_name,wt_l,wt_r,wt_l1,wt_r1,wt_i,wt_ld,wt_rd);
  dbms_output.put_line('working table wt_l ' || wt_l);
  dbms_output.put_line('working table wt_r ' || wt_r);
  dbms_output.put_line('working table wt_l1 ' || wt_l1);
  dbms_output.put_line('working table wt_r1 ' || wt_r1);
  dbms_output.put_line('working table wt_i ' || wt_i);
  dbms_output.put_line('working table wt_ld ' || wt_ld);
  dbms_output.put_line('working table wt_rd ' || wt_rd);

  -- compute
  opg_apis.cf(edge_tab_name,edge_label,rating_property,iterations,
              min_error,k,learning_rate,decrease_rate,regularization,dop,
              wt_l,wt_r,wt_l1,wt_r1,wt_i,wt_ld,wt_rd,tablespace,options);
END;
/
</code></pre>The flow starts by creating the temporary working tables that are later on passed to the computation.  At the end of computation, the example may produce the following output. Note that if<span class="bold"> no</span> working table name is provided, the preparation step will automatically generate a temporary table name and create it. Because the temporary working table name uses the session ID, your output will probably be different.<pre class="oac_no_warn" dir="ltr">working table wt_l    "PHONESGE$$CFL57"
working table wt_r    "PHONESGE$$CFR57"
working table wt_l1    "PHONESGE$$CFL157"
working table wt_r1    "PHONESGE$$CFR157"
working table wt_i    "PHONESGE$$CFI57"
working table wt_ld    "PHONESGE$$CFLD57"
working table wt_rd    "PHONESGE$$CFRD57"

PL/SQL procedure successfully completed.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__COLLABORATIVEFILTERINGVALIDATINGTHE-2BEE2C60">
                        <p class="titleinexample">Example 4-22 Collaborative Filtering: Validating the Intermediate Error</p>
                        <p>At the end of every computation, you can check the current error of the algorithm with the following query as long as the data in the working tables has not been already deleted.  The following SQL query illustrates how to get the intermediate error of a current run of the collaborative filtering algorithm.</p><pre class="pre codeblock"><code>SELECT /*+ parallel(48) */ SQRT(SUM((w1-w2)*(w1-w2) + 
              &lt;regularization&gt;/2 * (err_reg_l+err_reg_r))) AS err 
  FROM &lt;wt_i&gt;;
</code></pre><p>Note that the regularization parameter and the working table name (parameter <code class="codeph">wt_i</code>) should be replaced according to the values used when running the <a href="OPG_APIS-reference.html#GUID-94F53C56-F77A-41A2-BF2A-AAB359D88170">OPG_APIS.CF</a> algorithm. In the preceding previous example, replace <code class="codeph">&lt;regularization&gt;</code> with 0.02 and <code class="codeph">&lt;wt_i&gt;</code> with "PHONESGE$$CFI149" as follows:
                        </p><pre class="pre codeblock"><code>SELECT /*+ parallel(48) */ SQRT(SUM((w1-w2)*(w1-w2) + 0.02/2 * (err_reg_l+err_reg_r))) AS err 
  FROM "PHONESGE$$CFI149";
</code></pre><p>This query may produce the following output.</p><pre class="oac_no_warn" dir="ltr">       ERR
----------
4.82163662
</pre><p>f the value of the current error is too high or if the predictions obtained from the matrix factorization results of the collaborative filtering are not yet useful, you can run more iterations of the algorithm, by reusing the working tables and the progress made so far. The following example shows how to make predictions using the SQL-based collaborative filtering.</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__COLLABORATIVEFILTERINGMAKINGPREDICT-2BEDD5F3">
                        <p class="titleinexample">Example 4-23 Collaborative Filtering: Making Predictions</p>
                        <p>The result of the collaborative filtering algorithm is stored in the tables <code class="codeph">wt_l</code> and <code class="codeph">wt_r</code>, which are the two factors of a matrix product. These matrix factors should be used when making the predictions of the collaborative filtering.
                        </p>
                        <p>In a typical flow of the algorithm, the two matrix factors can be used to make the predictions before calling the <a href="OPG_APIS-reference.html#GUID-5DCE3ADF-B40B-4483-969A-7141D37656E6">OPG_APIS.CF_CLEANUP</a> procedure, or they can be copied and persisted into other tables for later use. The following example demonstrates the latter case:
                        </p><pre class="pre codeblock"><code>DECLARE
  wt_l varchar2(32);  -- working tables
  wt_r varchar2(32);
  wt_l1 varchar2(32);
  wt_r1 varchar2(32);
  wt_i varchar2(32);
  wt_ld varchar2(32);
  wt_rd varchar2(32);
  edge_tab_name    varchar2(32) := 'phonesge$';
  edge_label       varchar2(32) := 'rating';
  rating_property  varchar2(32) := '';
  iterations       integer      := 100;
  min_error        number       := 0.001;
  k                integer      := 5;
  learning_rate    number       := 0.001;
  decrease_rate    number       := 0.95;
  regularization   number       := 0.02;
  dop              number       := 2;
  tablespace       varchar2(32) := null;
  options          varchar2(32) := null; 
BEGIN

  -- prepare
  opg_apis.cf_prep(edge_tab_name,wt_l,wt_r,wt_l1,wt_r1,wt_i,wt_ld,wt_rd);

  -- compute
  opg_apis.cf(edge_tab_name,edge_label,rating_property,iterations,
              min_error,k,learning_rate,decrease_rate,regularization,dop,
              wt_l,wt_r,wt_l1,wt_r1,wt_i,wt_ld,wt_rd,tablespace,options);
  
  -- save only these two tables for later predictions
  EXECUTE IMMEDIATE 'CREATE TABLE customer_mat AS SELECT * FROM ' || wt_l;
  EXECUTE IMMEDIATE 'CREATE TABLE item_mat AS SELECT * FROM ' || wt_r;

  -- cleanup
  opg_apis.cf_cleanup('phonesge$',wt_l,wt_r,wt_l1,wt_r1,wt_i,wt_ld,wt_rd);
END;
/
</code></pre><p>This example will produce the only the following output.</p><pre class="oac_no_warn" dir="ltr">PL/SQL procedure successfully completed.</pre><p>Now that the matrix factors are saved in the tables customer_mat and item_mat, you can use the following query to check the "error" (difference) between the real values (those values that previously existed in the graph as 'ratings') and the estimated predictions (the result of the matrix multiplication in a certain customer row and item column).</p>
                        <p>Note that the following query is customized with a join on the vertex table in order return an NVARCHAR property of the vertices (for example, the name property) instead of a numeric ID. This query will return all the predictions for every single customer vertex to every item vertex in the graph.</p><pre class="pre codeblock"><code>SELECT /*+ parallel(48) */ MIN(vertex1.v) AS customer, 
                           MIN(vertex2.v) AS item, 
                           MIN(edges.vn) AS real, 
                           SUM(l.v * r.v) AS predicted
FROM PHONESGE$ edges, 
      CUSTOMER_MAT l, 
      ITEM_MAT r, 
      PHONESVT$ vertex1,   
      PHONESVT$ vertex2
WHERE l.k = r.k
  AND l.c = edges.svid(+)
  AND r.p = edges.dvid(+)
  AND l.c = vertex1.vid
  AND r.p = vertex2.vid
GROUP BY l.c, r.p
ORDER BY l.c, r.p  -- This order by clause is optional
;
</code></pre><p>This query may produce an output similar to the following (some rows are omitted for brevity).</p><pre class="oac_no_warn" dir="ltr">CUSTOMER	ITEM		REAL	PREDICTED
------------------------------------------------
Adam		Apple 	 	5	3.67375703
Adam		Blackberry		3.66079652
Adam		Danger			2.77049596
Adam		Ericsson		4.21764858
Adam		Figo			3.10631337
Adam		Google		4 	4.42429022
Adam		Huawei		3	3.4289115
Ben		Apple	  	   	2.82127589
Ben		Blackberry	2	2.81132282
Ben		Danger		3	2.12761307
Ben		Ericsson	3   	3.2389595
Ben		Figo	  	    	2.38550534
Ben		Google		   	3.39765075
Ben		Huawei		    	2.63324582
...
Don		Apple		    	1.3777496
Don		Blackberry	1 	1.37288909
Don		Danger		1 	1.03900439
Don		Ericsson	   	1.58172236
Don		Figo		1	1.16494421
Don		Google			1.65921807
Don		Huawei		1	1.28592648
Erik		Apple		3	2.80809351
Erik		Blackberry	3	2.79818695
Erik		Danger			2.11767182
Erik		Ericsson	3 	3.2238255
Erik		Figo			2.3743591
Erik		Google		3	3.38177526
Erik		Huawei		3	2.62094201
</pre><p>If you want to check only some rows to decide whether the prediction results are ready or more iterations of the algorithm should be run, the previous query can be wrapped in an outer query. The following example will select only the first 11 results.</p><pre class="pre codeblock"><code>SELECT /*+ parallel(48) */ * FROM (
SELECT /*+ parallel(48) */ MIN(vertex1.v) AS customer, 
                           MIN(vertex2.v) AS item, 
                           MIN(edges.vn) AS real, 
                           SUM(l.v * r.v) AS predicted
FROM PHONESGE$ edges, 
     CUSTOMER_MAT l, 
     ITEM_MAT r, 
     PHONESVT$ vertex1,   
     PHONESVT$ vertex2
WHERE l.k = r.k
  AND l.c = edges.svid(+)
  AND r.p = edges.dvid(+)
  AND l.c = vertex1.vid
  AND r.p = vertex2.vid
GROUP BY l.c, r.p
ORDER BY l.c, r.p
) WHERE rownum &lt;= 11;
</code></pre><p>This query may produce an output similar to the following.</p><pre class="oac_no_warn" dir="ltr">CUSTOMER	ITEM		REAL	PREDICTED
------------------------------------------------
Adam		Apple 	 	5	3.67375703
Adam		Blackberry		3.66079652
Adam		Danger			2.77049596
Adam		Ericsson		4.21764858
Adam		Figo			3.10631337
Adam		Google		4 	4.42429022
Adam		Huawei		3	3.4289115
Ben		Apple	  	   	2.82127589
Ben		Blackberry	2	2.81132282
Ben		Danger		3	2.12761307
Ben		Ericsson	3   	3.2389595
</pre><p>To get a prediction for a specific vertex (customer, item, or both) the query can be restricted with the desired ID values. For example, to get the predicted value of vertex 1 (customer) and vertex 105 (item), you can use the following query.</p><pre class="pre codeblock"><code>SELECT /*+ parallel(48) */ MIN(vertex1.v) AS customer, 
                           MIN(vertex2.v) AS item, 
                           MIN(edges.vn) AS real, 
                           SUM(l.v * r.v) AS predicted
FROM PHONESGE$ edges, 
     CUSTOMER_MAT l, 
     ITEM_MAT r, 
     PHONESVT$ vertex1,   
     PHONESVT$ vertex2
WHERE l.k = r.k
  AND l.c = edges.svid(+)
  AND r.p = edges.dvid(+)
  AND l.c = vertex1.vid 
  AND vertex1.vid = 1 /* Remove to get all predictions for item 105 */
  AND r.p = vertex2.vid 
  AND vertex2.vid = 105 /* Remove to get all predictions for customer 1 */
                        /* Remove both lines to get all predictions */
GROUP BY l.c, r.p
ORDER BY l.c, r.p;
</code></pre><p>This query may produce an output similar to the following.</p><pre class="oac_no_warn" dir="ltr">CUSTOMER	ITEM		REAL	PREDICTED
------------------------------------------------
Adam		Ericsson		4.21764858
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" title="In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.">SQL-Based Property Graph Analytics</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" name="GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC"></a><h3 id="SPGDG-GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" class="sect3"><span class="enumeration_section">4.7 </span>Property Graph Query Language (PGQL)
               </h3>
               <div>
                  <p>PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;<span class="italic">nodes</span>&nbsp;that are connected to other nodes by&nbsp;<span class="italic">edges</span>, each of which can have key-value pairs (properties) associated with them.
                  </p>
                  <p>The language is based on the concept of&nbsp;<span class="italic">graph pattern matching</span>, which allows you to specify patterns that are matched against vertices and edges in a data graph.
                  </p>
                  <p>The Oracle Spatial and Graph property graph support provides two ways to execute Property Graph Query Language (PGQL) queries through Java APIs:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Use the <code class="codeph">oracle.pgx.api</code> Java package to query an in-memory snapshot of a graph that has been loaded into the in-memory analyst (PGX), as described in <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="The in-memory analyst feature of Oracle Spatial and Graph supports a set of analytical functions.">Using the In-Memory Analyst (PGX)</a>.
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">oracle.pg.rdbms</code> Java package to directly query graph data stored in Oracle Database, as described in <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).">Executing PGQL Queries Directly Against Oracle Database</a>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9">Topology Constraints with PGQL</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8">Constraints are Directional with PGQL</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34">Vertex and Edge Labels with PGQL</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-A218D733-6A70-4DB7-9827-27C74D446655">Regular Path Queries with PGQL</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-14A728FA-8F95-425B-A498-B8BA364B9734">Aggregation and Sorting with PGQL</a><br></li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="https://docs.oracle.com/cd/E56133_01/latest/reference/pgql-specification.html" target="_blank">PGQL Specification</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9" name="GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9"></a><h4 id="SPGDG-GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9" class="sect4"><span class="enumeration_section">4.7.1 </span>Topology Constraints with PGQL
                  </h4>
                  <div>
                     <p>Pattern matching is done using&nbsp;<span class="italic">topology constraints</span>, which describe a pattern of connections between nodes in the graph, Value constraints (similar to their SQL equivalents) let you further constrain matches by specifying properties that those connections and nodes must have.
                     </p>
                     <p>For example, assume a graph of TCP/IP connections on a computer network, and you want to detect cases where someone logged into one machine, from there into another, and from there into yet another. You would query for that pattern like this:</p><pre class="pre codeblock"><code>SELECT host1.id(), host2.id(), host3.id()
WHERE                                                               /* choose what to return */
    (host1) -[c1 WITH toPort = 22 and opened = true]-&gt; (host2)      /* topology must match this pattern */
      -[connection2 WITH toPort = 22 and opened = true]-&gt; (host3),
    connection1.bytes &gt; 300,                                        /* meaningful amount of data was exchanged */
    connection2.bytes &gt; 300,
    connection1.start &lt; connection2.start,                          /* second connection within time-frame of first */
    connection2.start + connection2.duration &lt; connection1.start + connection1.duration
GROUP BY host1.id(), host2.id(), host3.id()                         /* aggregate multiple matching connections */
ORDER BY DESC(connection1.when)                                     /* reverse sort chronologically */
</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">Property Graph Query Language (PGQL)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8" name="GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8"></a><h4 id="SPGDG-GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8" class="sect4"><span class="enumeration_section">4.7.2 </span>Constraints are Directional with PGQL
                  </h4>
                  <div>
                     <p>A topological constraint has a direction, as edges in graphs do. Thus,&nbsp;<code class="codeph">(a) &lt;-[]- (b)</code>&nbsp;specifies a case where&nbsp;<span class="italic">b has an edge pointing at a</span>, whereas&nbsp;<code class="codeph">(a) -[]-&gt; (b)</code>&nbsp;looks for an edge in the opposite direction.
                     </p>
                     <p>The following example finds common friends of April and Chris who are older than both of them.</p><pre class="pre codeblock"><code>SELECT friend.name, friend.dob
WHERE                              /* note the arrow directions below */
  (p1:person WITH name = 'April') -[:likes]-&gt; (friend) &lt;-[:likes]- (p2:person WITH name = 'Chris'),
  friend.dob &gt; p1.dob AND friend.dob &gt; p2.dob
ORDER BY friend.dob DESC
</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">Property Graph Query Language (PGQL)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34" name="GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34"></a><h4 id="SPGDG-GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34" class="sect4"><span class="enumeration_section">4.7.3 </span>Vertex and Edge Labels with PGQL
                  </h4>
                  <div>
                     <p>Labels are a way of attaching type information to edges and nodes in a graph, and can be used in constraints in graphs where not all nodes represent the same thing. For example:</p><pre class="pre codeblock"><code>SELECT p WHERE (p:person) -[e:likes]-&gt; (m:movie WITH title='Star Wars'),
  (p) -[e:likes]-&gt; (m:movie WITH title='Avatar')
</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">Property Graph Query Language (PGQL)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A218D733-6A70-4DB7-9827-27C74D446655" name="GUID-A218D733-6A70-4DB7-9827-27C74D446655"></a><h4 id="SPGDG-GUID-A218D733-6A70-4DB7-9827-27C74D446655" class="sect4"><span class="enumeration_section">4.7.4 </span>Regular Path Queries with PGQL
                  </h4>
                  <div>
                     <p>Regular path queries allow a pattern to be reused. The following example finds all of the common ancestors of Mario and Luigi.</p><pre class="pre codeblock"><code>PATH has_parent := () -[:has_father|has_mother]-&gt; ()
SELECT ancestor.name
WHERE
  (:Person WITH name = 'Mario') -/:has_parent*/-&gt; (ancestor:Person),
  (:Person WITH name = 'Luigi') -/:has_parent*/-&gt; (ancestor)
</code></pre><p>The preceding path specification also shows the use of anonymous constraints, because there is no need to define names for intermediate edges or nodes that will not be used in additional constraints or query results. Anonymous elements can have constraints, such as <code class="codeph">[:has_father|has_mother]</code>: the edge does not get a variable name (because it will not be referenced elsewhere), but it is constrained.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">Property Graph Query Language (PGQL)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-14A728FA-8F95-425B-A498-B8BA364B9734" name="GUID-14A728FA-8F95-425B-A498-B8BA364B9734"></a><h4 id="SPGDG-GUID-14A728FA-8F95-425B-A498-B8BA364B9734" class="sect4"><span class="enumeration_section">4.7.5 </span>Aggregation and Sorting with PGQL
                  </h4>
                  <div>
                     <p>Like SQL, PGQL has support for the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>GROUP BY&nbsp;to create groups of solutions</p>
                        </li>
                        <li>
                           <p>MIN,&nbsp;MAX,&nbsp;SUM,&nbsp;and&nbsp;AVG&nbsp;aggregations</p>
                        </li>
                        <li>
                           <p>ORDER BY&nbsp;to sort results</p>
                        </li>
                     </ul>
                     <p>And for many other familiar SQL constructs.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">Property Graph Query Language (PGQL)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-94F08780-EC3D-4F9B-985F-49984939E61C" name="GUID-94F08780-EC3D-4F9B-985F-49984939E61C"></a><h3 id="SPGDG-GUID-94F08780-EC3D-4F9B-985F-49984939E61C" class="sect3"><span class="enumeration_section">4.8 </span>Executing PGQL Queries Directly Against Oracle Database
               </h3>
               <div>
                  <p>This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).</p>
                  <p>Property Graph Query Language (PGQL) queries can be executed against disk-resident property graph data stored in Oracle Database. The graph data access layer (DAL) provides a Java API for executing PGQL queries. Logic in the DAL translates a submitted PGQL query into an equivalent SQL query, and the resulting SQL is executed on the database server. The DAL then wraps the SQL query results with a convenient PGQL result set API. This PGQL query execution flow is shown in the following figure.</p>
                  <div class="figure" id="GUID-94F08780-EC3D-4F9B-985F-49984939E61C__GUID-27DB13E6-7444-45A3-8D7F-C5417C9E3E20">
                     <p class="titleinfigure">Figure 4-2 Graph Data Access Layer (DAL)</p><img src="img/graph_dal.jpg" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows" longdesc="img_text/graph_dal.html"><br><a href="img_text/graph_dal.html">Description of "Figure 4-2 Graph Data Access Layer (DAL)"</a></div>
                  <!-- class="figure" -->
                  <p>The basic execution flow is:</p>
                  <ol>
                     <li>
                        <p>The PGQL query is submitted to the DAL through a Java API.</p>
                     </li>
                     <li>
                        <p>The PGQL query is translated to SQL in the DAL.</p>
                     </li>
                     <li>
                        <p>The translated SQL is submitted to Oracle Database by JDBC.</p>
                     </li>
                     <li>
                        <p>The SQL result set is wrapped as a PGQL result set and returned to the caller.</p>
                     </li>
                  </ol>
                  <p>The ability to execute PGQL queries directly against property graph data stored in Oracle Database provides several benefits.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>PGQL provides a more natural way to express graph queries than SQL manually written to query schema tables, including VT$, GE$, and GT$.</p>
                     </li>
                     <li>
                        <p>PGQL queries can be executed without the need to load a snapshot of your graph data into PGX, so there is no need to worry about staleness of frequently updated graph data.</p>
                     </li>
                     <li>
                        <p>PGQL queries can be executed against graph data that is too large to fit in memory.</p>
                     </li>
                     <li>
                        <p>The robust and scalable Oracle SQL engine can be used to execute PGQL queries.</p>
                     </li>
                     <li>
                        <p>Mature tools for management, monitoring and tuning of Oracle Database can be used to tune and monitor PGQL queries.</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL Features Supported</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA">Performance Considerations for PGQL Queries</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="You can use SQL to query property graph data in Oracle Spatial and Graph.">SQL-Based Property Graph Query and Analytics</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C" name="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C"></a><h4 id="SPGDG-GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C" class="sect4"><span class="enumeration_section">4.8.1 </span>PGQL Features Supported
                  </h4>
                  <div>
                     <p><a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL is a SQL-like query language for property graph data structures that consist of&nbsp;nodes&nbsp;that are connected to other nodes by&nbsp;edges, each of which can have key-value pairs (properties) associated with them.">PGQL</a> is a SQL-like query language for querying property graph data. It is based on the concept of graph pattern matching and allows you to specify, among other things, topology constraints, paths, filters, sorting and aggregation.
                     </p>
                     <p>The Java API for PGQL defined in the <code class="codeph">oracle.pg.rdbms</code> package supports the PGQL 1.1 specification with a few exceptions. The PGQL 1.1 specification can be found here (<a href="http://pgql-lang.org/spec/1.1/" target="_blank">http://pgql-lang.org/spec/1.1/</a>).
                     </p>
                     <p>The following features of PGQL 1.1 are not supported.</p>
                     <ul style="list-style-type: disc;" id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C__UL_OSV_DJ5_DGB">
                        <li>FROM clause &#x2013; only a single graph can be queried at one time</li>
                        <li>Undirected query edges </li>
                        <li>TIME and TIME WITH TIME ZONE data types</li>
                        <li>IS NULL and IS NOT NULL testing</li>
                     </ul>
                     <p>The following enhancements to PGQL 1.1 are supported.</p>
                     <ul style="list-style-type: disc;" id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C__UL_PSV_DJ5_DGB">
                        <li>CONTAINS Built-in Function</li>
                     </ul>
                     <p>In addition, the following features of PGQL 1.1 require special consideration.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E">Temporal Types</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-368FDAFB-9183-463B-A623-2D473F64779C">Type Casting</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-D50795B1-079B-4A0F-99C6-5157F28D941A">Missing Properties</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A">CONTAINS Built-in Function</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).">Executing PGQL Queries Directly Against Oracle Database</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E" name="GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E"></a><h5 id="SPGDG-GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E" class="sect5"><span class="enumeration_section">4.8.1.1 </span>Temporal Types
                     </h5>
                     <div>
                        <p>The temporal types DATE, TIMESTAMP and TIMESTAMP WITH TIMEZONE are supported in PGQL queries. </p>
                        <p>All of these value types are represented internally using the Oracle SQL TIMESTAMP WITH TIME ZONE type. DATE values are automatically converted to TIMESTAMP WITH TIME ZONE by assuming the earliest time in UTC+0 timezone (for example, 2000-01-01 becomes 2000-01-01 00:00:00.00+00:00). TIMESTAMP values are automatically converted to TIMESTAMP WITH TIME ZONE by assuming UTC+0 timezone (for example, 2000-01-01 12:00:00.00 becomes 2000-01-01 12:00:00.00+00:00).</p>
                        <p>Temporal constants are written in PGQL queries as follows.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>DATE 'YYYY-MM-DD'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP WITH TIMEZONE 'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM'</p>
                           </li>
                        </ul>
                        <p>Some examples are DATE '2000-01-01', TIMESTAMP '2000-01-01 14:01:45.23', TIMESTAMP WITH TIMEZONE '2000-01-01 13:00:00.00-05:00', and TIMESTAMP WITH TIMEZONE '2000-01-01 13:00:00.00+01:00'.</p>
                        <p>In addition, temporal values can be obtained by casting string values to a temporal type. The supported string formats are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>DATE 'YYYY-MM-DD'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF' and 'YYYY-MM-DD"T"HH24:MI:SS.FF'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP WITH TIMEZONE 'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM' and 'YYYY-MM-DD"T"HH24:MI:SS.FFTZH:TZM'.</p>
                           </li>
                        </ul>
                        <p>Some examples are CAST ('2005-02-04' AS DATE), CAST ('1990-01-01 12:00:00.00' AS TIMESTAMP), CAST ('1985-01-01T14:05:05.00-08:00' AS TIMESTAMP WITH TIMEZONE).</p>
                        <p>When consuming results from a <code class="codeph">ResultSet</code> object, <code class="codeph">getObject</code> returns a <code class="codeph">java.sql.Timestamp</code> object for temporal types.
                        </p>
                        <p>Bind variables can only be used for the TIMESTAMP WITH TIMEZONE temporal type in PGQL, and a <code class="codeph">setTimestamp</code> method that takes a <code class="codeph">java.sql.Timestamp</code> object as input is used to set the bind value. As a simpler alternative, you can use a string bind variable in a CAST statement to bind temporal values (for example, <code class="codeph">CAST (? AS TIMESTAMP WITH TIMEZONE)</code> followed by <code class="codeph">setString(1, "1985-01-01T14:05:05.00-08:00")</code>). See also <a href="sql-based-property-graph-query-analytics.html#GUID-E9657B9D-B648-484F-9572-7DDD7F038871">Using Bind Variables in PGQL Queries</a> for more information about bind variables.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL Features Supported</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-368FDAFB-9183-463B-A623-2D473F64779C" name="GUID-368FDAFB-9183-463B-A623-2D473F64779C"></a><h5 id="SPGDG-GUID-368FDAFB-9183-463B-A623-2D473F64779C" class="sect5"><span class="enumeration_section">4.8.1.2 </span>Type Casting
                     </h5>
                     <div>
                        <p>Type casting is supported in PGQL with a SQL-style CAST (VALUE AS DATATYPE) syntax, for example CAST('25' AS INT), CAST (10 AS STRING), CAST ('2005-02-04' AS DATE), CAST(e.weight AS STRING). Supported casting operations are summarized in the following table. Y indicates that the conversion is supported, and N indicates that it is not supported. Casting operations on invalid values (for example, CAST('xyz' AS INT)) or unsupported conversions (for example, CAST (10 AS TIMESTAMP)) return NULL instead of raising a SQL exception.</p>
                        <div class="tblformal" id="GUID-368FDAFB-9183-463B-A623-2D473F64779C__GUID-4CD1D278-C765-4AFD-988F-44F8143AE00F">
                           <p class="titleintable">Table 4-1 Type Casting Support in PGQL (From and To Types)</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Type Casting Support in PGQL (From and To Types)" summary="10&#x2013;column table representing a matrix of “to” and “from” types, where a Y in a cell indicates that casting from the specific data type to the specific daya type is supported, and an N indicates that casting is not supported." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d22162e2064">“to” type</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2067">from STRING</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2070">from INT</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2073">from LONG</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2076">from FLOAT</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2079">from DOUBLE</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2082">from BOOLEAN</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2085">from DATE</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2088">from TIMESTAMP</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2091">from TIMESTAMP WITH TIMEZONE</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2097" headers="d22162e2064 ">
                                       <p>to STRING</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2085 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2088 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2091 ">
                                       <p>Y</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2128" headers="d22162e2064 ">
                                       <p>to INT</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2085 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2088 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2091 ">
                                       <p>N</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2159" headers="d22162e2064 ">
                                       <p>to LONG</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2085 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2088 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2091 ">
                                       <p>N</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2190" headers="d22162e2064 ">
                                       <p>to FLOAT</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2085 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2088 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2091 ">
                                       <p>N</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2221" headers="d22162e2064 ">
                                       <p>to DOUBLE</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2085 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2088 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2091 ">
                                       <p>N</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2252" headers="d22162e2064 ">
                                       <p>to BOOLEAN</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2070 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2073 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2076 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2079 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2082 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2085 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2088 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2091 ">
                                       <p>N</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2283" headers="d22162e2064 ">
                                       <p>to DATE</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2070 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2073 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2076 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2079 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2082 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2085 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2088 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2091 ">
                                       <p>Y</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2314" headers="d22162e2064 ">
                                       <p>to TIMESTAMP</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2070 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2073 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2076 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2079 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2082 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2085 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2088 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2091 ">
                                       <p>Y</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2345" headers="d22162e2064 ">
                                       <p>to TIMESTAMP WITH TIMEZONE</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2067 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2070 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2073 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2076 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2079 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2082 ">
                                       <p>N</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2085 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2088 ">
                                       <p>Y</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2091 ">
                                       <p>Y</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>An example query that uses type casting is: </p><pre class="pre codeblock"><code>SELECT e.name, CAST (e.birthDate AS STRING) AS dob
WHERE (e), e.birthDate &lt; CAST ('1980-01-01' AS DATE)
</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL Features Supported</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-D50795B1-079B-4A0F-99C6-5157F28D941A" name="GUID-D50795B1-079B-4A0F-99C6-5157F28D941A"></a><h5 id="SPGDG-GUID-D50795B1-079B-4A0F-99C6-5157F28D941A" class="sect5"><span class="enumeration_section">4.8.1.3 </span>Missing Properties
                     </h5>
                     <div>
                        <p>When a vertex or edge is missing a property that is projected from a PGQL query, the result row containing that vertex or edge will be excluded from the query result rather than included with a NULL value.</p>
                        <p>For example, the following query:</p><pre class="pre codeblock"><code>SELECT v.name
MATCH (v)
</code></pre><p>Will exclude all vertices that are missing a <code class="codeph">name</code> property from the query result. 
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL Features Supported</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A" name="GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A"></a><h5 id="SPGDG-GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A" class="sect5"><span class="enumeration_section">4.8.1.4 </span>CONTAINS Built-in Function
                     </h5>
                     <div>
                        <p>A CONTAINS built-in function is supported. It is used in conjunction with an Oracle Text index on vertex and edge properties. CONTAINS returns <code class="codeph">true</code> if a value matches an Oracle Text search string and <code class="codeph">false</code> if it does not match.
                        </p>
                        <p>An example query is:</p><pre class="pre codeblock"><code>SELECT v.name
WHERE (v), CONTAINS(v.abstract, 'Oracle')
</code></pre><p>See also <a href="sql-based-property-graph-query-analytics.html#GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24">Using a Text Index with PGQL Queries</a> for more information about using full text indexes with PGQL.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL Features Supported</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-296732FE-D57B-41B5-937B-078E234422CC" name="GUID-296732FE-D57B-41B5-937B-078E234422CC"></a><h4 id="SPGDG-GUID-296732FE-D57B-41B5-937B-078E234422CC" class="sect4"><span class="enumeration_section">4.8.2 </span>Using the oracle.pg.rdbms Java Package to Execute PGQL Queries
                  </h4>
                  <div>
                     <p>Oracle Spatial and Graph property graph support provides a Java API in the <code class="codeph">oracle.pg.rdbms</code> package for executing PGQL queries against Oracle Database. This section explains how to use the Java API through a series of examples.
                     </p>
                     <div class="infoboxnote" id="GUID-296732FE-D57B-41B5-937B-078E234422CC__GUID-14C35ED2-4F82-4173-869B-5E9363E7BAB6">
                        <p class="notep1">Note:</p>
                        <p>Effective with Release 19c, the <code class="codeph">oracle.pg.rdbms.OraclePgqlResultSet</code> interface is deprecated and will be removed in a future version. Instead, use the standardized interface <code class="codeph">oracle.pgql.lang.ResultSet</code> to retrieve values from a PGQL result set.
                        </p>
                        <p>One difference between those two interfaces is that <code class="codeph">oracle.pgql.lang.ResultSet</code> does not provide APIs to retrieve vertex and edge objects. Existing code using those interfaces should be changed to project IDs rather than <code class="codeph">OracleVertex</code> and <code class="codeph">OracleEdge</code> objects. You can obtain an <code class="codeph">OracleVertex</code> or <code class="codeph">OracleEdge</code> object from the projected ID values by calling <code class="codeph">OracleVertex.getInstance()</code> or<code class="codeph"> OracleEdge.getInstance()</code>. (For an example, see <a href="sql-based-property-graph-query-analytics.html#GUID-4B12B361-A502-4B39-9267-E457C2F14D74__PGQLEXAMPLE12.JAVA-1F6E0823">Example 4-37</a>.)
                        </p>
                     </div>
                     <p>To use PGQL query capabilities, import the following classes into your Java program:</p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*;
import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;
</code></pre><p>The following <code class="codeph">test_graph</code> data set in Oracle flat file format will be used in the examples in subtopics that follow. The data set includes a vertex file (<code class="codeph">test_graph.opv</code>) and an edge file (<code class="codeph">test_graph.ope</code>) 
                     </p>
                     <p><code class="codeph">test_graph<span class="bold">.opv</span></code>:
                     </p><pre class="oac_no_warn" dir="ltr">2,fname,1,Ray,,
2,lname,1,Green,,
2,mval,5,,,1985-01-01T12:00:00.000Z
2,age,2,,41,
0,bval,6,Y,,
0,fname,1,Bill,,
0,lname,1,Brown,,
0,mval,1,y,,
0,age,2,,40,
1,bval,6,Y,,
1,fname,1,John,,
1,lname,1,Black,,
1,mval,2,,27,
1,age,2,,30,
3,bval,6,N,,
3,fname,1,Susan,,
3,lname,1,Blue,,
3,mval,6,N,,
3,age,2,,35,
</pre><p><code class="codeph">test_graph<span class="bold">.ope</span></code>:
                     </p><pre class="oac_no_warn" dir="ltr">4,0,1,knows,mval,1,Y,,
4,0,1,knows,firstMetIn,1,MI,,
4,0,1,knows,since,5,,,1990-01-01T12:00:00.000Z
16,0,1,friendOf,strength,2,,6,
7,1,0,knows,mval,5,,,2003-01-01T12:00:00.000Z
7,1,0,knows,firstMetIn,1,GA,,
7,1,0,knows,since,5,,,2000-01-01T12:00:00.000Z
17,1,0,friendOf,strength,2,,7,
9,1,3,knows,mval,6,N,,
9,1,3,knows,firstMetIn,1,SC,,
9,1,3,knows,since,5,,,2005-01-01T12:00:00.000Z
10,2,0,knows,mval,1,N,,
10,2,0,knows,firstMetIn,1,TX,,
10,2,0,knows,since,5,,,1997-01-01T12:00:00.000Z
12,2,3,knows,mval,3,,342.5,
12,2,3,knows,firstMetIn,1,TX,,
12,2,3,knows,since,5,,,2011-01-01T12:00:00.000Z
19,2,3,friendOf,strength,2,,4,
14,3,1,knows,mval,1,a,,
14,3,1,knows,firstMetIn,1,CA,,
14,3,1,knows,since,5,,,2010-01-01T12:00:00.000Z
15,3,2,knows,mval,1,z,,
15,3,2,knows,firstMetIn,1,CA,,
15,3,2,knows,since,5,,,2004-01-01T12:00:00.000Z
5,0,2,knows,mval,2,,23,
5,0,2,knows,firstMetIn,1,OH,,
5,0,2,knows,since,5,,,2002-01-01T12:00:00.000Z
6,0,3,knows,mval,3,,159.7,
6,0,3,knows,firstMetIn,1,IN,,
6,0,3,knows,since,5,,,1994-01-01T12:00:00.000Z
8,1,2,knows,mval,6,Y,,
8,1,2,knows,firstMetIn,1,FL,,
8,1,2,knows,since,5,,,1999-01-01T12:00:00.000Z
18,1,3,friendOf,strength,2,,5,
11,2,1,knows,mval,2,,1001,
11,2,1,knows,firstMetIn,1,OK,,
11,2,1,knows,since,5,,,2003-01-01T12:00:00.000Z
13,3,0,knows,mval,5,,,2001-01-01T12:00:00.000Z
13,3,0,knows,firstMetIn,1,CA,,
13,3,0,knows,since,5,,,2006-01-01T12:00:00.000Z
20,3,1,friendOf,strength,2,,3,
</pre></div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9">Basic Query Execution</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E9657B9D-B648-484F-9572-7DDD7F038871">Using Bind Variables in PGQL Queries</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24">Using a Text Index with PGQL Queries</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-7642327B-B973-4C48-90B1-1447F3D57CA5">Obtaining the SQL Translation for a PGQL Query</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">Additional Options for PGQL Translation and Execution</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-623F91CC-1686-4D95-B69F-FA7F81352A90">Querying Another User’s Property Graph</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-EECCE896-473F-46DD-8805-9BF696DF60AF">Using Query Optimizer Hints with PGQL</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).">Executing PGQL Queries Directly Against Oracle Database</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9" name="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9"></a><h5 id="SPGDG-GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9" class="sect5"><span class="enumeration_section">4.8.2.1 </span>Basic Query Execution
                     </h5>
                     <div>
                        <p>Two main Java Interfaces, <code class="codeph">OraclePgqlStatement</code> and <code class="codeph">oracle.pgql.lang.ResultSet</code>, are used for PGQL execution. This topic includes several examples of basic query execution.
                        </p>
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-E3C78120-0F0F-4530-AFAE-4ADEEAD64126">
                           <p class="titleinexample">Example 4-24 PgqlExample1.java</p>
                           <p><code class="codeph">PgqlExample1.java</code> shows an example of executing a PGQL query and iterating through the query result. <code class="codeph">OraclePgqlExecutionFactory</code> is used to obtain an <code class="codeph">OraclePgqlStatement</code> from an <code class="codeph">OraclePropertyGraph</code> object. Next, it calls the <code class="codeph">executeQuery</code> method of <code class="codeph">OraclePgqlStatement</code>, which returns an <code class="codeph">oracle.pgql.lang.ResultSet</code> object. <code class="codeph">ResultSet</code> provides an interface for consuming the query result that is very similar to the <code class="codeph">java.sql.ResultSet</code> interface.
                           </p>
                           <p><code class="codeph">oracle.pgql.lang.ResultSet</code> provides a <code class="codeph">next()</code> method for moving through the query result and provides a <code class="codeph">close()</code> method to release resources after the application is through reading the query result. In addition, <code class="codeph">ResultSet</code> provides getters for String, Integer, Long, Float, Double, Boolean, LocalDateTime, OffsetDateTime, and it provides a generic <code class="codeph">getObject()</code> method for values of any type.
                           </p>
                           <p>The <code class="codeph">ResultSet</code> and <code class="codeph">OraclePgqlStatement</code> objects should be closed after consuming the query result.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to execute a basic PGQL query against disk-resident 
 * PG data stored in Oracle Database and iterate through the result.
 */
public class PgqlExample1
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v.fname AS fname, v.lname AS lname, v.mval AS mval "+
        "MATCH (v)";
      rs = ops.executeQuery(pgql, /* query string */ 
                            ""    /* options */);

      // Consume the result set using the oracle.pgql.lang.ResultSet interface
      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
      while (rs.next()) {
        // get fname
        String fname = rs.getString(1);
        // get lname
        String lname = rs.getString(2);
        // get mval
        Object mval = rs.getObject(3);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        System.out.println("[fname = "+fname+", lname = "+lname+", mval = "+mStr+"]");
      }
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }
}
</code></pre><p><code class="codeph">PgqlExample1.java</code> gives the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">[fname = Susan, lname = Blue, mval = BOOLEAN: false]
[fname = Bill, lname = Brown, mval = STRING: y]
[fname = Ray, lname = Green, mval = DATE: 1985-01-01T04:00:00.000-08:00]
[fname = John, lname = Black, mval = INTEGER: 27]
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-D3262532-7CA1-4045-A7FC-DC20171912CA">
                           <p class="titleinexample">Example 4-25 PgqlExample2.java</p>
                           <p><code class="codeph">PgqlExample2.java</code> shows a PGQL query with a temporal filter on an edge property.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to execute a PGQL query with a temporal edge 
 * property filter against disk-resident PG data stored in Oracle Database 
 * and iterate through the result.
 */
public class PgqlExample2
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v.fname AS n1, v2.fname AS n2, e.firstMetIn AS loc "+
        "MATCH (v)-[e:knows]-&gt;(v2) "+
        "WHERE e.since &gt; TIMESTAMP '2000-01-01 00:00:00.00+00:00'";
      rs = ops.executeQuery(pgql, "");

      // Print results
      printResults(rs, 3);
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample2.java</code> gives the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">[STRING: Ray,	STRING: John,	STRING: OK]
[STRING: Bill,	STRING: Ray,	STRING: OH]
[STRING: Susan,	STRING: Bill,	STRING: CA]
[STRING: John,	STRING: Susan,	STRING: SC]
[STRING: Ray,	STRING: Susan,	STRING: TX]
[STRING: John,	STRING: Bill,	STRING: GA]
[STRING: Susan,	STRING: John,	STRING: CA]
[STRING: Susan,	STRING: Ray,	STRING: CA]
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-D87D64CE-29BD-497D-A13A-2B9C51ECDA48">
                           <p class="titleinexample">Example 4-26 PgqlExample3.java</p>
                           <p><code class="codeph">PgqlExample3.java</code> shows a PGQL query with grouping and aggregation.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to execute a PGQL query with aggregation 
 * against disk-resident PG data stored in Oracle Database and iterate 
 * through the result.
 */
public class PgqlExample3
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v.fname AS fname, COUNT(v2) AS friendCnt "+
        "MATCH (v)-[e:friendOf]-&gt;(v2) "+
        "GROUP BY v "+
        "ORDER BY friendCnt DESC";
      rs = ops.executeQuery(pgql, "");

      // Print results
      printResults(rs, 2);
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample3.java</code> gives the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">[STRING: John,	LONG: 2]
[STRING: Bill,	LONG: 1]
[STRING: Ray,	LONG: 1]
[STRING: Susan,	LONG: 1]
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__PGQLEXAMPLE4.JAVA-1EEA3A59">
                           <p class="titleinexample">Example 4-27 PgqlExample4.java</p>
                           <p><code class="codeph">PgqlExample4.java</code> shows a PGQL path query.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to execute a path query in PGQL against 
 * disk-resident PG data stored in Oracle Database and iterate 
 * through the result.
 */
public class PgqlExample4
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "PATH fof AS ()-[:friendOf|knows]-&gt;() "+
        "SELECT v2.fname AS friend "+
        "MATCH (v)-/:fof*/-&gt;(v2) "+
        "WHERE v.fname = 'John' AND v != v2";
      rs = ops.executeQuery(pgql, "");

      // Print results
      printResults(rs, 1);
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample4.java</code> gives the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">[[STRING: Susan]
[STRING: Bill]
[STRING: Ray]
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871" name="GUID-E9657B9D-B648-484F-9572-7DDD7F038871"></a><h5 id="SPGDG-GUID-E9657B9D-B648-484F-9572-7DDD7F038871" class="sect5"><span class="enumeration_section">4.8.2.2 </span>Using Bind Variables in PGQL Queries
                     </h5>
                     <div>
                        <p>Bind variables can be used in PGQL queries for better performance and increased security. Constant scalar values in PGQL queries can be replaced with bind variables. Bind variables are denoted by a '?' (question mark). Consider the following two queries that select people who are older than a constant age value.</p><pre class="pre codeblock"><code>// people older than 30
SELECT v.fname AS fname, v.lname AS lname, v.age AS age
MATCH (v)
WHERE v.age &gt; 30

// people older than 40
SELECT v.fname AS fname, v.lname AS lname, v.age AS age
MATCH (v) 
WHERE v.age &gt; 40
</code></pre><p>The SQL translations for these queries would use the constants 30 and 40 in a similar way for the age filter. The database would perform a hard parse for each of these queries. This hard parse time can often exceed the execution time for simple queries.</p>
                        <p>You could replace the constant in each query with a bind variable as follows.</p><pre class="pre codeblock"><code>SELECT v.fname AS fname, v.lname AS lname, v.age AS age
MATCH (v)
WHERE v.age &gt; ?
</code></pre><p>This will allow the SQL engine to create a generic cursor for this query, which can be reused for different age values. As a result, a hard parse is no longer required to execute this query for different age values, and the parse time for each query will be drastically reduced.</p>
                        <p>In addition, applications that use bind variables in PGQL queries are less vulnerable to injection attacks than those that use string concatenation to embed constant values in PGQL queries.</p>
                        <p>See also <span class="italic"><a href="../tgsql/improving-rwp-cursor-sharing.html#TGSQL848" target="_blank">Oracle Database SQL Tuning Guide</a></span> for more information on cursor sharing and bind variables.
                        </p>
                        <p>The <code class="codeph">OraclePgqlPreparedStatement</code> interface can be used to execute queries with bind variables as shown in <code class="codeph">PgqlExample5.java</code>. <code class="codeph">OraclePgqlPreparedStatement</code> provides several set methods for different value types that can be used to set values for query execution. 
                        </p>
                        <p>There are a few limitations with bind variables in PGQL. Bind variables can only be used for constant property values. That is, vertices and edges cannot be replaced with bind variables. Also, once a particular bind variable has been set to a type, it cannot be set to a different type. For example, if <code class="codeph">setInt(1, 30)</code> is executed for an <code class="codeph">OraclePgqlPreparedStatement</code>, you cannot call <code class="codeph">setString(1, "abc")</code> on that same <code class="codeph">OraclePgqlPreparedStatement</code>.
                        </p>
                        <div class="example" id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871__PGQLEXAMPLE1.JAVA-1EEBCB49">
                           <p class="titleinexample">Example 4-28 PgqlExample5.java</p>
                           <p><code class="codeph">PgqlExample5.java</code> shows how to use bind variables with a PGQL query.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to use bind variables with a PGQL query.
 */
public class PgqlExample5
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlPreparedStatement opps = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Query string with a bind variable (denoted by ?)
      String pgql = 
        "SELECT v.fname AS fname, v.lname AS lname, v.age AS age "+
        "MATCH (v) "+
        "WHERE v.age &gt; ?";

      // Create an OraclePgqlPreparedStatement
      opps = OraclePgqlExecutionFactory.prepareStatement(opg, pgql);

      // Set filter value to 30
      opps.setInt(1, 30);

      // execute query
      rs = opps.executeQuery("");

      // Print query results
      System.out.println("-- Values for v.age &gt; 30 ------------------");
      printResults(rs, 3);
      // close result set
      rs.close();

      // set filter value to 40
      opps.setInt(1, 40);

      // execute query
      rs = opps.executeQuery("");

      // Print query results
      System.out.println("-- Values for v.age &gt; 40 ------------------");
      printResults(rs, 3);
      // close result set
      rs.close();
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (opps != null) {
        opps.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample5.java</code> has the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">-- Values for v.age &gt; 30 ------------------
[STRING: Susan,	STRING: Blue,	INTEGER: 35]
[STRING: Bill,	STRING: Brown,	INTEGER: 40]
[STRING: Ray,	STRING: Green,	INTEGER: 41]

-- Values for v.age &gt; 40 ------------------
[STRING: Ray,	STRING: Green,	INTEGER: 41]
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871__PGQLEXAMPLE2.JAVA-1EEBD858">
                           <p class="titleinexample">Example 4-29 PgqlExample6.java</p>
                           <p><code class="codeph">PgqlExample6.java</code> shows a query with two bind variables: one String variable and one Timestamp variable.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use multiple bind variables with a PGQL query.
 */
public class PgqlExample6
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlPreparedStatement opps = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Query string with multiple bind variables
      String pgql = 
        "SELECT v1.fname AS fname1, v2.fname AS fname2 "+
        "MATCH (v1)-[e:knows]-&gt;(v2) "+
        "WHERE e.since &lt; ? AND e.firstMetIn = ?";

      // Create an OraclePgqlPreparedStatement
      opps = OraclePgqlExecutionFactory.prepareStatement(opg, pgql);

      // Set e.since &lt; 2006-01-01T12:00:00.00Z
      Timestamp t = Timestamp.valueOf(OffsetDateTime.parse("2006-01-01T12:00:01.00Z").atZoneSameInstant(ZoneOffset.UTC).toLocalDateTime());
      opps.setTimestamp(1, t);
      // Set e.firstMetIn = 'CA'
      opps.setString(2, "CA");

      // execute query
      rs = opps.executeQuery("");

      // Print query results
      System.out.println("-- Values for e.since &lt;  2006-01-01T12:00:01.00Z AND e.firstMetIn = 'CA' --");
      printResults(rs, 2);
      // close result set
      rs.close();

      // Set e.since &lt; 2000-01-01T12:00:00.00Z
      t = Timestamp.valueOf(OffsetDateTime.parse("2000-01-01T12:00:00.00Z").atZoneSameInstant(ZoneOffset.UTC).toLocalDateTime());
      opps.setTimestamp(1, t);
      // Set e.firstMetIn = 'TX'
      opps.setString(2, "TX");

      // execute query
      rs = opps.executeQuery("");

      // Print query results
      System.out.println("-- Values for e.since &lt;  2000-01-01T12:00:00.00Z AND e.firstMetIn = 'TX' --");
      printResults(rs, 2);
      // close result set
      rs.close();
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (opps != null) {
        opps.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((java.util.Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample6.java</code> gives the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">-- Values for e.since &lt;  2006-01-01T12:00:01.00Z AND e.firstMetIn = 'CA' --
[STRING: Susan,	STRING: Bill]
[STRING: Susan,	STRING: Ray]

-- Values for e.since &lt;  2000-01-01T12:00:00.00Z AND e.firstMetIn = 'TX' --
[STRING: Ray,	STRING: Bill]
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24" name="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24"></a><h5 id="SPGDG-GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24" class="sect5"><span class="enumeration_section">4.8.2.3 </span>Using a Text Index with PGQL Queries
                     </h5>
                     <div>
                        <p>PGQL queries executed against Oracle Database can use Oracle Text indexes created for vertex and edge properties. After creating a text index, you can use the CONTAINS operator to perform a full text search. CONTAINS has two arguments: a vertex or edge property, and an Oracle Text search string. Any valid Oracle Text search string can be used, including advanced features such as wildcards, stemming and soundex. </p>
                        <div class="example" id="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24__PGQLEXAMPLE5.JAVA-1EF822A7">
                           <p class="titleinexample">Example 4-30 PgqlExample7.java</p>
                           <p><code class="codeph">PgqlExample7.java</code> shows how to execute a CONTAINS query.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use an Oracle Text index with a PGQL query.
 */
public class PgqlExample7
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlPreparedStatement opps = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      // try to drop property graph first
      try {
        OraclePropertyGraphUtils.dropPropertyGraph(oracle, szGraph);
      }
      catch (SQLException ex) { /*do nothing*/; }

      // Get property graph instance
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      
      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create text index with SQL API
      CallableStatement cs = null;
      // text index on vertices
      cs = oracle.getConnection().prepareCall(
        "begin opg_apis.create_vertices_text_idx(:1,:2); end;"
      );
      cs.setString(1,szUser);
      cs.setString(2,szGraph);
      cs.execute();
      cs.close();
      // text index on edges
      cs = oracle.getConnection().prepareCall(
        "begin opg_apis.create_edges_text_idx(:1,:2); end;"
      );
      cs.setString(1,szUser);
      cs.setString(2,szGraph);
      cs.execute();
      cs.close(); 

      // Query using CONTAINS text search operator on vertex property
      // Find all vertices with an lname property value that starts with 'B'
      String pgql = 
        "SELECT v.fname AS fname, v.lname AS lname "+
        "MATCH (v) "+
        "WHERE CONTAINS(v.lname,'B%')";

      // Create an OraclePgqlStatement
      opps = OraclePgqlExecutionFactory.prepareStatement(opg, pgql);

      // execute query
      rs = opps.executeQuery("");

      // print results
      System.out.println("-- Vertex Property Query ---------------");
      printResults(rs, 2);

      // close result set and prepared statement
      rs.close();
      opps.close();

      // Query using CONTAINS text search operator on edge property
      // Find all knows edges with a firstMetIn property value that ends with 'A'
      pgql = 
        "SELECT v1.fname AS fname1, v2.fname AS fname2, e.firstMetIn AS loc "+
        "MATCH (v1)-[e:knows]-&gt;(v2) "+
        "WHERE CONTAINS(e.firstMetIn,'%A')";

      // Create an OraclePgqlStatement
      opps = OraclePgqlExecutionFactory.prepareStatement(opg, pgql);

      // execute query
      rs = opps.executeQuery("");

      // print results
      System.out.println("-- Edge Property Query -----------------");
      printResults(rs, 3);

      // close result set and statement
      rs.close();
      opps.close();
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (opps != null) {
        opps.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints an PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((java.util.Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample7.java</code> has the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">-- Vertex Property Query ---------------
[STRING: Susan,	STRING: Blue]
[STRING: Bill,	STRING: Brown]
[STRING: John,	STRING: Black]

-- Edge Property Query -----------------
[STRING: Susan,	STRING: Bill,	STRING: CA]
[STRING: John,	STRING: Bill,	STRING: GA]
[STRING: Susan,	STRING: John,	STRING: CA]
[STRING: Susan,	STRING: Ray,	STRING: CA]
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5" name="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5"></a><h5 id="SPGDG-GUID-7642327B-B973-4C48-90B1-1447F3D57CA5" class="sect5"><span class="enumeration_section">4.8.2.4 </span>Obtaining the SQL Translation for a PGQL Query
                     </h5>
                     <div>
                        <p>You can obtain the SQL translation for a PGQL query through methods in <code class="codeph">OraclePgqlStatement</code> and <code class="codeph">OraclePgqlPreparedStatement</code>. The raw SQL for a PGQL query can be useful for several reasons:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can execute the SQL directly against the database with other SQL-based tools or interfaces (for example, SQL Plus or SQL Developer).</p>
                           </li>
                           <li>
                              <p>You can customize and tune the generated SQL to optimize performance or to satisfy a particular requirement of your application.</p>
                           </li>
                           <li>
                              <p>You can build a larger SQL query that joins a PGQL subquery with other data stored in Oracle Database (such as relational tables, spatial data, and JSON data).</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5__PGQLEXAMPLE7.JAVA-1EF8E84B">
                           <p class="titleinexample">Example 4-31 PgqlExample8.java</p>
                           <p><code class="codeph">PgqlExample8.java</code> shows how to obtain the raw SQL translation for a PGQL query. The <code class="codeph">translateQuery</code> method of <code class="codeph">OraclePgqlStatement</code> returns an <code class="codeph">OraclePgqlSqlTrans</code> object that contains information about return columns from the query and the SQL translation itself.
                           </p>
                           <p>The translated SQL returns different columns depending on the type of "logical" object or value projected from the PGQL query. A vertex or edge projected in PGQL has two corresponding columns projected in the translated SQL: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>$IT : id type &#x2013; NVARCHAR(1): 'V' for vertex or 'E' for edge</p>
                              </li>
                              <li>
                                 <p>$ID : vertex or edge identifier &#x2013; NUMBER: same content as VID or EID columns in VT$ and GE$ tables</p>
                              </li>
                           </ul>
                           <p> A property value or constant scalar value projected in PGQL has four corresponding columns projected in the translated SQL: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>$T : value type &#x2013; NUMBER: same content as T column in VT$ and GE$ tables</p>
                              </li>
                              <li>
                                 <p>$V: value &#x2013; NVARCHAR2(15000):  same content as V column in VT$ and GE$ tables</p>
                              </li>
                              <li>
                                 <p>$VN: number value &#x2013; NUMBER: same content as VN column in VT$ and GE$ tables</p>
                              </li>
                              <li>
                                 <p>$VT: temporal value &#x2013; TIMESTAMP WITH TIME ZONE: same content as VT column in VT$ and GE$ tables</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;
import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to obtain the SQL translation for a PGQL query.
 */
public class PgqlExample8
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // PGQL query to be translated
      String pgql = 
        "SELECT v1, v1.fname AS fname1, e, e.since AS since "+
        "MATCH (v1)-[e:knows]-&gt;(v2)";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Get the SQL translation
      OraclePgqlSqlTrans sqlTrans = ops.translateQuery(pgql,"");

      // Get the return column descriptions
      OraclePgqlColumnDescriptor[] cols = sqlTrans.getReturnTypes();

      // Print column descriptions
      System.out.println("-- Return Columns -----------------------");
      printReturnCols(cols);

      // Print SQL translation
      System.out.println("-- SQL Translation ----------------------");
      System.out.println(sqlTrans.getSqlTranslation());
    }
    finally {
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints return columns for a SQL translation
   */
  static void printReturnCols(OraclePgqlColumnDescriptor[] cols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");

    for (int i = 0; i &lt; cols.length; i++) {

      String colName = cols[i].getColName();
      OraclePgqlColumnDescriptor.Type colType = cols[i].getColType();
      int offset = cols[i].getSqlOffset();

      String readableType = "";
      switch(colType) {
        case VERTEX:
          readableType = "VERTEX";
          break;
        case EDGE:
          readableType = "EDGE";
          break;
        case VALUE:
          readableType = "VALUE";
          break;
      }

      buff.append("colName=["+colName+"] colType=["+readableType+"] offset=["+offset+"]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample8.java</code> has the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">-- Return Columns -----------------------
colName=[v1] colType=[VERTEX] offset=[1]
colName=[fname1] colType=[VALUE] offset=[3]
colName=[e] colType=[EDGE] offset=[7]
colName=[since] colType=[VALUE] offset=[9]

-- SQL Translation ----------------------
SELECT n'V' AS "v1$IT",
T0$0.SVID AS "v1$ID",
T0$1.T AS "fname1$T",
T0$1.V AS "fname1$V",
T0$1.VN AS "fname1$VN",
T0$1.VT AS "fname1$VT",
n'E' AS "e$IT",
T0$0.EID AS "e$ID",
T0$0.T AS "since$T",
T0$0.V AS "since$V",
T0$0.VN AS "since$VN",
T0$0.VT AS "since$VT"
FROM "SCOTT".GRAPH1GE$ T0$0,
"SCOTT".GRAPH1VT$ T0$1
WHERE T0$0.K=n'since' AND
T0$1.K=n'fname' AND
T0$0.SVID=T0$1.VID AND
(T0$0.EL = n'knows' AND T0$0.EL IS NOT NULL)
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5__GUID-FB87DBB1-292F-4B0E-807E-BC6209FE4631">
                           <p class="titleinexample">Example 4-32 PgqlExample9.java</p>
                           <p>You can also obtain the SQL translation for PGQL queries with bind variables. In this case, the corresponding SQL translation will also contain bind variables. The <code class="codeph">OraclePgqlSqlTrans</code> interface has a <code class="codeph">getSqlBvList</code> method that returns an ordered List of Java Objects that should be bound to the SQL query (the first Object on the list should be set at position 1, and the second should be set at position 2, and so on). 
                           </p>
                           <p><code class="codeph">PgqlExample9.java</code> shows how to get and execute the SQL for a PGQL query with bind variables.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;
import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to obtain and execute the SQL translation for a 
 * PGQL query that uses bind variables.
 */
public class PgqlExample9
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlPreparedStatement opps = null;

    PreparedStatement ps = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v1, v1.fname AS fname1, v1.age AS age, ? as constVal "+
        "MATCH (v1) "+
        "WHERE  v1.fname = ? OR v1.age &lt; ?";

      // Create an OraclePgqlStatement
      opps = OraclePgqlExecutionFactory.prepareStatement(opg, pgql);

      // set bind values
      opps.setDouble(1, 2.05d);
      opps.setString(2, "Bill");
      opps.setInt(3, 35);

      // Get the SQL translation
      OraclePgqlSqlTrans sqlTrans = opps.translateQuery("");

      // Get the SQL String
      String sqlStr = sqlTrans.getSqlTranslation();

      // Get the return column descriptions
      OraclePgqlColumnDescriptor[] cols = sqlTrans.getReturnTypes();

      // Get the bind values
      List&lt;Object&gt; bindVals = sqlTrans.getSqlBvList();

      // Print column descriptions
      System.out.println("-- Return Columns -----------------------");
      printReturnCols(cols);

      // Print SQL translation
      System.out.println("-- SQL Translation ----------------------");
      System.out.println(sqlStr);

      // Print Bind Values
      System.out.println("\n-- Bind Values --------------------------");
      for (Object obj : bindVals) {
        System.out.println(obj.toString());
      }

      // Execute Query
      // Get PreparedStatement
      ps = oracle.getConnection().prepareStatement("SELECT COUNT(*) FROM ("+sqlStr+")");
      // Set bind values and execute the PreparedStatement
      executePs(ps, bindVals);

      // Set new bind values in the PGQL PreparedStatement 
      opps.setDouble(1, 3.02d);
      opps.setString(2, "Ray");
      opps.setInt(3, 30);

      // Print Bind Values
      bindVals = sqlTrans.getSqlBvList();
      System.out.println("\n-- Bind Values --------------------------");
      for (Object obj : bindVals) {
        System.out.println(obj.toString());
      }

      // Execute the PreparedStatement with new bind values
      executePs(ps, bindVals);
    }
    finally {
      // close the SQL statement
      if (ps != null) {
        ps.close();
      }
      // close the statement
      if (opps != null) {
        opps.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Executes a SQL PreparedStatement with the input bind values
   */
  static void executePs(PreparedStatement ps, List&lt;Object&gt; bindVals) throws Exception
  {
    ResultSet rs = null;
    try {
      // Set bind values
      for (int idx = 0; idx &lt; bindVals.size(); idx++) {
        Object o = bindVals.get(idx);
        // String
        if (o instanceof java.lang.String) {
          ps.setNString(idx + 1, (String)o);
        }
        // Int
        else if (o instanceof java.lang.Integer) {
          ps.setInt(idx + 1, ((Integer)o).intValue());
        }
        // Long
        else if (o instanceof java.lang.Long) {
          ps.setLong(idx + 1, ((Long)o).longValue());
        }
        // Float
        else if (o instanceof java.lang.Float) {
          ps.setFloat(idx + 1, ((Float)o).floatValue());
        }
        // Double
        else if (o instanceof java.lang.Double) {
          ps.setDouble(idx + 1, ((Double)o).doubleValue());
        }
       // Timestamp
       else if (o instanceof java.sql.Timestamp) {
         ps.setTimestamp(idx + 1, (Timestamp)o);
       }
       else {
         ps.setString(idx + 1, bindVals.get(idx).toString());
       }
     }

      // Execute query
      rs = ps.executeQuery();
      if (rs.next()) {
        System.out.println("\n-- Execute Query: Result has "+rs.getInt(1)+" rows --");
      }
    }
    finally {
      // close the SQL ResultSet
      if (rs != null) {
        rs.close();
      }
    }
  }

  /**
   * Prints return columns for a SQL translation
   */
  static void printReturnCols(OraclePgqlColumnDescriptor[] cols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");

    for (int i = 0; i &lt; cols.length; i++) {

      String colName = cols[i].getColName();
      OraclePgqlColumnDescriptor.Type colType = cols[i].getColType();
      int offset = cols[i].getSqlOffset();

      String readableType = "";
      switch(colType) {
        case VERTEX:
          readableType = "VERTEX";
          break;
        case EDGE:
          readableType = "EDGE";
          break;
        case VALUE:
          readableType = "VALUE";
          break;
      }

      buff.append("colName=["+colName+"] colType=["+readableType+"] offset=["+offset+"]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample9.java</code> has the following output for <code class="codeph">test_graph</code>.
                           </p><pre class="oac_no_warn" dir="ltr">&#x2013;
-- Return Columns -----------------------
colName=[v1] colType=[VERTEX] offset=[1]
colName=[fname1] colType=[VALUE] offset=[3]
colName=[age] colType=[VALUE] offset=[7]
colName=[constVal] colType=[VALUE] offset=[11]

-- SQL Translation ----------------------
SELECT n'V' AS "v1$IT",
T0$0.VID AS "v1$ID",
T0$0.T AS "fname1$T",
T0$0.V AS "fname1$V",
T0$0.VN AS "fname1$VN",
T0$0.VT AS "fname1$VT",
T0$1.T AS "age$T",
T0$1.V AS "age$V",
T0$1.VN AS "age$VN",
T0$1.VT AS "age$VT",
4 AS "constVal$T",
to_nchar(?,'TM9','NLS_Numeric_Characters=''.,''') AS "constVal$V",
? AS "constVal$VN",
to_timestamp_tz(null) AS "constVal$VT"
FROM "SCOTT".GRAPH1VT$ T0$0,
"SCOTT".GRAPH1VT$ T0$1
WHERE T0$0.K=n'fname' AND
T0$1.K=n'age' AND
T0$0.VID=T0$1.VID AND
((T0$0.T = 1 AND T0$0.V = ?) OR T0$1.VN &lt; ?)

-- Bind Values --------------------------
2.05
2.05
Bill
35

-- Execute Query: Result has 2 rows --

-- Bind Values --------------------------
3.02
3.02
Ray
30

-- Execute Query: Result has 1 rows --
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44" name="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44"></a><h5 id="SPGDG-GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44" class="sect5"><span class="enumeration_section">4.8.2.5 </span>Additional Options for PGQL Translation and Execution
                     </h5>
                     <div>
                        <p>Several options are available to influence PGQL query translation and execution. The following are the main ways to set query options:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Through explicit arguments to <code class="codeph">executeQuery</code> and <code class="codeph">translateQuery</code></p>
                           </li>
                           <li>
                              <p>Through flags in the <code class="codeph">options</code> string argument of <code class="codeph">executeQuery</code> and <code class="codeph">translateQuery</code></p>
                           </li>
                           <li>
                              <p>Through Java JVM arguments.</p>
                           </li>
                        </ul>
                        <p>The following table summarizes the available query arguments for PGQL translation and execution.</p>
                        <div class="tblformal" id="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44__GUID-ACDAC2C0-469A-470F-945B-78A010DE939F">
                           <p class="titleintable">Table 4-2 PGQL Translation and Execution Options</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PGQL Translation and Execution Options" summary="Five-column table: column 1 is Option, column 2 is Default, column 3 is Explicit Argument, column 4 is Options Flag, and column 5 is JVM argument." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d22162e3317">Option</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3320">Default</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3323">Explict Argument</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3326">Options Flag</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3329">JVM Argument</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3334" headers="d22162e3317 ">
                                       <p>Degree of parallelism</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3320 ">
                                       <p>1</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3323 ">
                                       <p>parallel</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3326 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3329 ">
                                       <p>none</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3350" headers="d22162e3317 ">
                                       <p>Timeout</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3320 ">
                                       <p>unlimited</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3323 ">
                                       <p>timeout</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3326 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3329 ">
                                       <p>none</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3366" headers="d22162e3317 ">
                                       <p>Dynamic sampling</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3320 ">
                                       <p>2</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3323 ">
                                       <p>dynamicSampling</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3326 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3329 ">
                                       <p>none</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3382" headers="d22162e3317 ">
                                       <p>Maximum number of results</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3320 ">
                                       <p>unlimited</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3323 ">
                                       <p>maxResults</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3326 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3329 ">
                                       <p>none</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3398" headers="d22162e3317 ">
                                       <p>GT$ table usage</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3320 ">
                                       <p>off</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3323 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3326 ">
                                       <p>USE_GT_TAB=T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useGtTab=true</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3414" headers="d22162e3317 ">
                                       <p>CONNECT BY usage</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3320 ">
                                       <p>off</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3323 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3326 ">
                                       <p>USE_RW=F</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useRW=false</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3430" headers="d22162e3317 ">
                                       <p>Distinct recursive WITH usage</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3320 ">
                                       <p>off</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3323 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3326 ">
                                       <p>USE_DIST_RW=T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useDistRW=true</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3446" headers="d22162e3317 ">
                                       <p>Maximum path length</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3320 ">
                                       <p>unlimited</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3323 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3326 ">
                                       <p>MAX_PATH_LEN=n</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.maxPathLen=n</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3462" headers="d22162e3317 ">
                                       <p>Set partial</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3320 ">
                                       <p>false</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3323 ">
                                       <p>none</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3326 ">
                                       <p>EDGE_SET_PARTIAL=T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.edgeSetPartial=true</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF">Query Options Controlled by Explicit Arguments</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290">Using the GT$ Skeleton Table</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-3369EA15-739E-4B44-9178-AFC79A33031C">Path Query Options</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-4B12B361-A502-4B39-9267-E457C2F14D74">Options for Partial Object Construction</a><br></li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="props_rev_3"><a id="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF" name="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF"></a><h6 id="SPGDG-GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF" class="sect6"><span class="enumeration_section">4.8.2.5.1 </span>Query Options Controlled by Explicit Arguments
                        </h6>
                        <div>
                           <p>Some query options are controlled by explicit arguments to methods in the Java API. </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">executeQuery</code> method of <code class="codeph">OraclePgqlStatement</code> has explicit arguments for timeout in seconds, degree of parallelism, query identifier (reserved for future use), optimizer dynamic sampling, and maximum number of results.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">translateQuery</code> method has explicit arguments for degree of parallelism, optimizer dynamic sampling, and maximum number of results. <code class="codeph">OraclePgqlPreparedStatement</code> also provides those same additional arguments for <code class="codeph">executeQuery</code> and <code class="codeph">translateQuery</code>.
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF__GUID-DFAD9D28-0130-430E-ACE4-6B5481407EC5">
                              <p class="titleinexample">Example 4-33 PgqlExample10.java</p>
                              <p><code class="codeph">PgqlExample10.java</code> shows PGQL query execution with additional options controlled by explicit arguments.
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to execute a PGQL query with various options.
 */
public class PgqlExample10
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v1.fname AS fname1, v2.fname AS fname2 "+
        "MATCH (v1)-[:friendOf]-&gt;(v2)";
      rs = ops.executeQuery(pgql /* query string */, 
                            100  /* timeout (sec): 0 is default and implies no timeout */,
                            2    /* parallel: 1 is default */,
                            1001 /* query id: 0 is default */,
                            6    /* dynamic sampling: 2 is default */,
                            50   /* max results: -1 is default and implies no limit */,
                            ""   /* options */);

      // Print query results
      printResults(rs, 2);
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints a PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample10.java</code> gives the following output for <code class="codeph">test_graph</code>.
                              </p><pre class="oac_no_warn" dir="ltr">[STRING: John,	STRING: Bill]
[STRING: John,	STRING: Susan]
[STRING: Ray,	STRING: Susan]
[STRING: Susan,	STRING: John]
[STRING: Bill,	STRING: John]
</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">Additional Options for PGQL Translation and Execution</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290" name="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290"></a><h6 id="SPGDG-GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290" class="sect6"><span class="enumeration_section">4.8.2.5.2 </span>Using the GT$ Skeleton Table
                        </h6>
                        <div>
                           <p>The property graph relational schema defines a GT$ skeleton table that stores a single row for each edge in the graph, no matter how many properties an edge has. This skeleton table is not populated by default, but if it is populated, PGQL query execution can take advantage of the GT$ table and avoid sorting operations on the GE$ table in many cases, which gives a significant performance improvement.</p>
                           <p>You can add <code class="codeph">"USE_GT_TAB=T"</code> to the <code class="codeph">options</code> argument of <code class="codeph">executeQuery</code> and <code class="codeph">translateQuery</code> or use <code class="codeph">-Doracle.pg.rdbms.pgql.useGtTab=true</code> in the Java command line to turn on GT$ table usage.
                           </p>
                           <div class="example" id="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290__PGQLEXAMPLE11.JAVA-1F029EA0">
                              <p class="titleinexample">Example 4-34 PgqlExample11.java</p>
                              <p><code class="codeph">PgqlExample11.java</code> shows a query that uses the GT$ skeleton table.
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;
import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use the GT$ skeleton table for faster
 * PGQL query execution.
 */
public class PgqlExample11
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();

      // populate GT$ skeleton table with distinct edges
      CallableStatement cs = null;
      cs = oracle.getConnection().prepareCall(
        "begin opg_graphop.populate_skeleton_tab(:1,:2); end;"
      );
      cs.setString(1,szGraph);
      cs.setInt(2,1);
      cs.execute();
      cs.close();

      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT id(v1), id(v2) "+
        "MATCH (v1)-[knows]-&gt;(v2)";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Get the SQL translation without GT table
      OraclePgqlSqlTrans sqlTrans = ops.translateQuery(pgql,"");

      // Print SQL translation
      System.out.println("-- SQL Translation without GT Table ----------------------");
      System.out.println(sqlTrans.getSqlTranslation());

      // Get the SQL translation with GT table
      sqlTrans = ops.translateQuery(pgql,"USE_GT_TAB=T");

      // Print SQL translation
      System.out.println("-- SQL Translation with GT Table -------------------------");
      System.out.println(sqlTrans.getSqlTranslation());

    }
    finally {
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }
}
</code></pre><p><code class="codeph">PgqlExample11.java</code> gives the following output for <code class="codeph">test_graph</code>.
                              </p><pre class="oac_no_warn" dir="ltr">-- SQL Translation <span class="bold"><span class="italic">without GT Table</span></span> ----------------------
SELECT 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v2)$T",
to_nchar(T0$0.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v2)$V",
T0$0.DVID AS "id(v2)$VN",
to_timestamp_tz(null) AS "id(v2)$VT"<span class="bold">
FROM (SELECT DISTINCT EID, SVID, DVID,EL FROM "SCOTT".GRAPH1GE$) T0$0</span>

-- SQL Translation <span class="bold"><span class="italic">with GT Table</span></span> -------------------------
SELECT 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v2)$T",
to_nchar(T0$0.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v2)$V",
T0$0.DVID AS "id(v2)$VN",
to_timestamp_tz(null) AS "id(v2)$VT"<span class="bold">
FROM "SCOTT".GRAPH1GT$ T0$0</span>
</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">Additional Options for PGQL Translation and Execution</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C" name="GUID-3369EA15-739E-4B44-9178-AFC79A33031C"></a><h6 id="SPGDG-GUID-3369EA15-739E-4B44-9178-AFC79A33031C" class="sect6"><span class="enumeration_section">4.8.2.5.3 </span>Path Query Options
                        </h6>
                        <div>
                           <p>A few options are available for executing path queries in PGQL. There are two basic evaluation methods available in Oracle SQL: CONNECT BY or recursive WITH clauses. Recursive WITH is the default evaluation method. In addition, you can further modify the recursive WITH evaluation method to include a DISTINCT modifier during the recursive step of query evaluation. Computing distinct vertices at each step helps prevent a combinatorial explosion in highly connected graphs. The DISTINCT modifier is not added by default because it requires a specific parameter setting in the database (<code class="codeph">"_recursive_with_control"=8</code>). 
                           </p>
                           <p>You can also control the maximum length of paths searched. Path length in this case is defined as the number of repetitions allowed when evaluating the * and + operators. The default maximum length is unlimited. </p>
                           <p>Path evaluation options are summarized as follows.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="bold">CONNECT BY:</span> To use CONNECT BY, specify <code class="codeph">'USE_RW=F'</code> in the <code class="codeph">options</code> argument or specify <code class="codeph">-Doracle.pg.rdbms.pgql.useRW=false</code> in the Java command line.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">Distinct Modifier in Recursive WITH:</span> To use the DISTINCT modifier in the recursive step, first set <code class="codeph">"_recursive_with_control"=8</code> in your database session, then specify <code class="codeph">'USE_DIST_RW=T</code>' in the <code class="codeph">options</code> argument or specify<code class="codeph"> -Doracle.pg.rdbms.pgql.useDistRW=true</code> in the Java command line. You will encounter ORA-32486: unsupported operation in recursive branch of recursive WITH clause if <code class="codeph">"_recursive_with_control"</code> has not been set to 8 in your session.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">Path Length Restriction:</span> To limit maximum number of repetitions when evaluating * and + to n, specify <code class="codeph">'MAX_PATH_LEN=n'</code> in the query <code class="codeph">options</code> argument or specify <code class="codeph">-Doracle.pg.rdbms.pgql.maxPathLen=n</code> in the Java command line.
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C__PGQLEXAMPLE11.JAVA-1F029478">
                              <p class="titleinexample">Example 4-35 PgqlExample12.java</p>
                              <p><code class="codeph">PgqlExample12.java</code> shows path query translations under various options.
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;
import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use various options with PGQL path queries.
 */
public class PgqlExample12
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();
      
      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Set "_recursive_with_control"=8 to enable distinct optimization
      // optimization for recursive with
      Statement stmt = oracle.getConnection().createStatement();
      stmt.executeUpdate("alter session set \"_recursive_with_control\"=8");
      stmt.close();

      // populate GT$ skeleton table with distinct edges
      CallableStatement cs = null;
      cs = oracle.getConnection().prepareCall(
        "begin opg_graphop.populate_skeleton_tab(:1,:2); end;"
      );
      cs.setString(1,szGraph);
      cs.setInt(2,1);
      cs.execute();
      cs.close();

      // Path Query to illustrate options
      String pgql = 
        "PATH fof AS ()-[:friendOf]-&gt;() "+
        "SELECT id(v1), id(v2) "+
        "MATCH (v1)-/:fof*/-&gt;(v2) "+
        "WHERE id(v1) = 2";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // get SQL translation with defaults - Non-distinct Recursive WITH
      OraclePgqlSqlTrans sqlTrans = 
        ops.translateQuery(pgql /* query string */, 
                           2    /* parallel: default is 1 */,
                           2    /* dynamic sampling: default is 2 */,
                           -1   /* max results: -1 implies no limit */,
                           " USE_GT_TAB=T " /* options */);
      System.out.println("-- Default Path Translation --------------------");
      System.out.println(sqlTrans.getSqlTranslation()+"\n");

      // get SQL translation with DISTINCT reachability optimization
      sqlTrans = 
        ops.translateQuery(pgql /* query string */, 
                           2    /* parallel: default is 1 */,
                           2    /* dynamic sampling: default is 2 */,
                           -1   /* max results: -1 implies no limit */,
                           " USE_DIST_RW=T USE_GT_TAB=T " /* options */);
      System.out.println("-- DISTINCT RW Path Translation --------------------");
      System.out.println(sqlTrans.getSqlTranslation()+"\n");

      // get SQL translation with CONNECT BY
      sqlTrans = 
        ops.translateQuery(pgql /* query string */, 
                           2    /* parallel: default is 1 */,
                           2    /* dynamic sampling: default is 2 */,
                           -1   /* max results: -1 implies no limit */,
                           " USE_RW=F USE_GT_TAB=T " /* options */);
      System.out.println("-- CONNECT BY Path Translation --------------------");
      System.out.println(sqlTrans.getSqlTranslation()+"\n");
    }
    finally {
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }
}
</code></pre><p><code class="codeph">PgqlExample12.java</code> gives the following output for <code class="codeph">test_graph</code>.
                              </p><pre class="oac_no_warn" dir="ltr">-- Default Path Translation --------------------
SELECT /*+ PARALLEL(2) */ * FROM(SELECT 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v2)$T",
to_nchar(T0$0.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v2)$V",
T0$0.DVID AS "id(v2)$VN",
to_timestamp_tz(null) AS "id(v2)$VT"
FROM (/*Path[*/SELECT DISTINCT SVID, DVID
FROM (
SELECT 2 AS SVID, 2 AS DVID
FROM SYS.DUAL
UNION ALL
SELECT SVID,DVID FROM
(WITH RW (ROOT, DVID) AS
( SELECT ROOT, DVID FROM
(SELECT SVID ROOT, DVID
FROM (SELECT T0$0.SVID AS SVID,
T0$0.DVID AS DVID
FROM "SCOTT".GRAPH1GT$ T0$0
WHERE T0$0.SVID = 2 AND
(T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL))
) UNION ALL
SELECT RW.ROOT, R.DVID
FROM (SELECT T0$0.SVID AS SVID,
T0$0.DVID AS DVID
FROM "SCOTT".GRAPH1GT$ T0$0
WHERE (T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL)) R, RW
WHERE RW.DVID = R.SVID )
CYCLE DVID SET cycle_col TO 1 DEFAULT 0
SELECT ROOT SVID, DVID FROM RW))/*]Path*/) T0$0
WHERE T0$0.SVID = 2)

-- DISTINCT RW Path Translation --------------------
SELECT /*+ PARALLEL(2) */ * FROM(SELECT 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v2)$T",
to_nchar(T0$0.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v2)$V",
T0$0.DVID AS "id(v2)$VN",
to_timestamp_tz(null) AS "id(v2)$VT"
FROM (/*Path[*/SELECT DISTINCT SVID, DVID
FROM (
SELECT 2 AS SVID, 2 AS DVID
FROM SYS.DUAL
UNION ALL
SELECT SVID,DVID FROM
(WITH RW (ROOT, DVID) AS
( SELECT ROOT, DVID FROM
(SELECT SVID ROOT, DVID
FROM (SELECT T0$0.SVID AS SVID,
T0$0.DVID AS DVID
FROM "SCOTT".GRAPH1GT$ T0$0
WHERE T0$0.SVID = 2 AND
(T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL))
) UNION ALL
SELECT DISTINCT RW.ROOT, R.DVID
FROM (SELECT T0$0.SVID AS SVID,
T0$0.DVID AS DVID
FROM "SCOTT".GRAPH1GT$ T0$0
WHERE (T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL)) R, RW
WHERE RW.DVID = R.SVID )
CYCLE DVID SET cycle_col TO 1 DEFAULT 0
SELECT ROOT SVID, DVID FROM RW))/*]Path*/) T0$0
WHERE T0$0.SVID = 2)

-- CONNECT BY Path Translation --------------------
SELECT /*+ PARALLEL(2) */ * FROM(SELECT 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v2)$T",
to_nchar(T0$0.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v2)$V",
T0$0.DVID AS "id(v2)$VN",
to_timestamp_tz(null) AS "id(v2)$VT"
FROM (/*Path[*/SELECT DISTINCT SVID, DVID
FROM (
SELECT 2 AS SVID, 2 AS DVID
FROM SYS.DUAL
UNION ALL
SELECT SVID, DVID
FROM
(SELECT CONNECT_BY_ROOT T0$0.SVID AS SVID, T0$0.DVID AS DVID
FROM(
SELECT T0$0.SVID AS SVID,
T0$0.DVID AS DVID
FROM "SCOTT".GRAPH1GT$ T0$0
WHERE (T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL)) T0$0
START WITH T0$0.SVID = 2
CONNECT BY NOCYCLE PRIOR DVID = SVID))/*]Path*/) T0$0
WHERE T0$0.SVID = 2)
</pre><p>The query plan for the first query with the default recursive WITH strategy should look similar to the following.</p><pre class="oac_no_warn" dir="ltr">-- default RW

---------------------------------------------------------------------------------------
| Id  | Operation                                         | Name                      |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                                  |                           |
|   1 |  TEMP TABLE TRANSFORMATION                        |                           |
|   2 |   LOAD AS SELECT (CURSOR DURATION MEMORY)         | SYS_TEMP_0FD9D6642_133DFF |
|   3 |    UNION ALL (RECURSIVE WITH) BREADTH FIRST       |                           |
|   4 |     PX COORDINATOR                                |                           |
|   5 |      PX SEND QC (RANDOM)                          | :TQ20000                  |
|   6 |       LOAD AS SELECT (CURSOR DURATION MEMORY)     | SYS_TEMP_0FD9D6642_133DFF |
|   7 |        PX BLOCK ITERATOR                          |                           |
|*  8 |         TABLE ACCESS FULL                         | GRAPH1GT$                 |
|   9 |     PX COORDINATOR                                |                           |
|  10 |      PX SEND QC (RANDOM)                          | :TQ10000                  |
|  11 |       LOAD AS SELECT (CURSOR DURATION MEMORY)     | SYS_TEMP_0FD9D6642_133DFF |
|  12 |        NESTED LOOPS                               |                           |
|  13 |         PX BLOCK ITERATOR                         |                           |
|* 14 |          TABLE ACCESS FULL                        | SYS_TEMP_0FD9D6642_133DFF |
|  15 |         PARTITION HASH ALL                        |                           |
|* 16 |          TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| GRAPH1GT$                 |
|* 17 |           INDEX RANGE SCAN                        | GRAPH1XSG$                |
|  18 |   PX COORDINATOR                                  |                           |
|  19 |    PX SEND QC (RANDOM)                            | :TQ30001                  |
|  20 |     VIEW                                          |                           |
|  21 |      HASH UNIQUE                                  |                           |
|  22 |       PX RECEIVE                                  |                           |
|  23 |        PX SEND HASH                               | :TQ30000                  |
|  24 |         HASH UNIQUE                               |                           |
|  25 |          VIEW                                     |                           |
|  26 |           UNION-ALL                               |                           |
|  27 |            PX SELECTOR                            |                           |
|  28 |             FAST DUAL                             |                           |
|  29 |            VIEW                                   |                           |
|* 30 |             VIEW                                  |                           |
|  31 |              PX BLOCK ITERATOR                    |                           |
|  32 |               TABLE ACCESS FULL                   | SYS_TEMP_0FD9D6642_133DFF |
---------------------------------------------------------------------------------------
</pre><p>The query plan for the second query that adds a DISTINCT modifier in the recursive step should look similar to the following.</p><pre class="oac_no_warn" dir="ltr">----------------------------------------------------------------------------------------------
| Id  | Operation                                             | Name                         |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                                      |                              |
|   1 |  TEMP TABLE TRANSFORMATION                            |                              |
|   2 |   LOAD AS SELECT (CURSOR DURATION MEMORY)             | SYS_TEMP_0FD9D663B_133DFF    |
|   3 |    UNION ALL (RECURSIVE WITH) BREADTH FIRST           |                              |
|   4 |     PX COORDINATOR                                    |                              |
|   5 |      PX SEND QC (RANDOM)                              | :TQ20000                     |
|   6 |       LOAD AS SELECT (CURSOR DURATION MEMORY)         | SYS_TEMP_0FD9D663B_133DFF    |
|   7 |        PX BLOCK ITERATOR                              |                              |
|*  8 |         TABLE ACCESS FULL                             | GRAPH1GT$                    |
|   9 |     PX COORDINATOR                                    |                              |
|  10 |      PX SEND QC (RANDOM)                              | :TQ10001                     |
|  11 |       LOAD AS SELECT (CURSOR DURATION MEMORY)         | SYS_TEMP_0FD9D663B_133DFF    |
|  12 |        SORT GROUP BY                                  |                              |
|  13 |         PX RECEIVE                                    |                              |
|  14 |          PX SEND HASH                                 | :TQ10000                     |
|  15 |           SORT GROUP BY                               |                              |
|  16 |            NESTED LOOPS                               |                              |
|  17 |             PX BLOCK ITERATOR                         |                              |
|* 18 |              TABLE ACCESS FULL                        | SYS_TEMP_0FD9D663B_133DFF    |
|  19 |             PARTITION HASH ALL                        |                              |
|* 20 |              TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| GRAPH1GT$                    |
|* 21 |               INDEX RANGE SCAN                        | GRAPH1XSG$                   |
|  22 |   PX COORDINATOR                                      |                              |
|  23 |    PX SEND QC (RANDOM)                                | :TQ30001                     |
|  24 |     VIEW                                              |                              |
|  25 |      HASH UNIQUE                                      |                              |
|  26 |       PX RECEIVE                                      |                              |
|  27 |        PX SEND HASH                                   | :TQ30000                     |
|  28 |         HASH UNIQUE                                   |                              |
|  29 |          VIEW                                         |                              |
|  30 |           UNION-ALL                                   |                              |
|  31 |            PX SELECTOR                                |                              |
|  32 |             FAST DUAL                                 |                              |
|  33 |            VIEW                                       |                              |
|* 34 |             VIEW                                      |                              |
|  35 |              PX BLOCK ITERATOR                        |                              |
|  36 |               TABLE ACCESS FULL                       | SYS_TEMP_0FD9D663B_133DFF    |
----------------------------------------------------------------------------------------------
</pre><p>The query plan for the third query that uses CONNECTY BY should look similar to the following.</p><pre class="oac_no_warn" dir="ltr">------------------------------------------------------------------
| Id  | Operation                                    | Name      |
------------------------------------------------------------------
|   0 | SELECT STATEMENT                             |           |
|   1 |  VIEW                                        |           |
|   2 |   HASH UNIQUE                                |           |
|   3 |    VIEW                                      |           |
|   4 |     UNION-ALL                                |           |
|   5 |      FAST DUAL                               |           |
|*  6 |      VIEW                                    |           |
|*  7 |       CONNECT BY NO FILTERING WITH START-WITH|           |
|   8 |        PX COORDINATOR                        |           |
|   9 |         PX SEND QC (RANDOM)                  | :TQ10000  |
|  10 |          PX BLOCK ITERATOR                   |           |
|* 11 |           TABLE ACCESS FULL                  | GRAPH1GT$ |
------------------------------------------------------------------
</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C__GUID-9AA83DA5-6785-4C18-81EF-CED895052476">
                              <p class="titleinexample">Example 4-36 PgqlExample13.java</p>
                              <p><code class="codeph">PgqlExample13.java</code> shows how to set length restrictions during path query evaluation.
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use the maximum path length option for 
 * PGQL path queries.
 */
public class PgqlExample13
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();
      
      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Path Query to illustrate options
      String pgql = 
        "PATH fof AS ()-[:friendOf]-&gt;() "+
        "SELECT v1.fname AS fname1, v2.fname AS fname2 "+
        "MATCH (v1)-/:fof*/-&gt;(v2) "+
        "WHERE v1.fname = 'Ray'";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // execute query for 1-hop
      rs = ops.executeQuery(pgql, " MAX_PATH_LEN=1 ");

      // print results
      System.out.println("-- Results for 1-hop ----------------");
      printResults(rs, 2);

      // close result set
      rs.close();

      // execute query for 2-hop
      rs = ops.executeQuery(pgql, " MAX_PATH_LEN=2 ");

      // print results
      System.out.println("-- Results for 2-hop ----------------");
      printResults(rs, 2);

      // close result set
      rs.close();

      // execute query for 3-hop
      rs = ops.executeQuery(pgql, " MAX_PATH_LEN=3 ");

      // print results
      System.out.println("-- Results for 3-hop ----------------");
      printResults(rs, 2);

      // close result set
      rs.close();

    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints a PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((java.util.Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p><code class="codeph">PgqlExample13.java</code> has the following output for <code class="codeph">test_graph</code>.
                              </p><pre class="oac_no_warn" dir="ltr">-- Results for 1-hop ----------------
[STRING: Ray,	STRING: Ray]
[STRING: Ray,	STRING: Susan]

-- Results for 2-hop ----------------
[STRING: Ray,	STRING: Susan]
[STRING: Ray,	STRING: Ray]
[STRING: Ray,	STRING: John]

-- Results for 3-hop ----------------
[STRING: Ray,	STRING: Susan]
[STRING: Ray,	STRING: Bill]
[STRING: Ray,	STRING: Ray]
[STRING: Ray,	STRING: John]
</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">Additional Options for PGQL Translation and Execution</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-4B12B361-A502-4B39-9267-E457C2F14D74" name="GUID-4B12B361-A502-4B39-9267-E457C2F14D74"></a><h6 id="SPGDG-GUID-4B12B361-A502-4B39-9267-E457C2F14D74" class="sect6"><span class="enumeration_section">4.8.2.5.4 </span>Options for Partial Object Construction
                        </h6>
                        <div>
                           <p>When reading edges from a query result, there are two possible behaviors when adding the start and end vertex to any local caches: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Add only the vertex ID, which is available from the edge itself. This option is the default, for efficiency.</p>
                              </li>
                              <li>
                                 <p>Add the vertex ID, and retrieve all properties for the start and end vertex. For this behavior, you can call <code class="codeph">setPartial(true)</code> on each <code class="codeph">OracleVertex</code> object constructed from your PGQL query result set.
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-4B12B361-A502-4B39-9267-E457C2F14D74__PGQLEXAMPLE12.JAVA-1F6E0823">
                              <p class="titleinexample">Example 4-37 PgqlExample14.java</p>
                              <p><code class="codeph">PgqlExample14.java</code> illustrates this difference in behavior. This program first executes a query to retrieve all edges, which causes the incident vertices to be added to a local cache. The second query retrieves all vertices. The program then prints each <code class="codeph">OracleVertex</code> object to show which properties have been loaded.
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows the behavior of setPartial(true) for OracleVertex objects
 * created from PGQL query results.
 */
public class PgqlExample14
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();
      
      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // Query to illustrate set partial
      String pgql = 
        "SELECT id(e), label(e) "+
        "MATCH (v1)-[e:knows]-&gt;(v2)";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // execute query for 1-hop
      rs = ops.executeQuery(pgql, " ");

      // print results
      System.out.println("-- Results for edge query -----------------");
      printResults(rs, 2);

      // close result set
      rs.close();

      // Query to retrieve vertices
      pgql =
        "SELECT id(v) "+
        "MATCH (v)";

      // Get each vertex object in result and print with toString()
      rs = ops.executeQuery(pgql, " ");

      // iterate through result
      System.out.println("-- Vertex objects retrieved from vertex query --");
      while (rs.next()) {
        Long vid = rs.getLong(1);
        OracleVertex v = OracleVertex.getInstance(opg, vid);
        System.out.println(v.toString());
      }
      // close result set
      rs.close();

      // Execute the same query but call setPartial(true) for each vertex
      rs = ops.executeQuery(pgql, " ");
      System.out.println("-- Vertex objects retrieved from vertex query with setPartial(true) --");
      while (rs.next()) {
        Long vid = rs.getLong(1);
        OracleVertex v = OracleVertex.getInstance(opg, vid);
        v.setPartial(true);
        System.out.println(v.toString());
      }
      // close result set
      rs.close();
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints a PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((java.util.Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p>The output for <code class="codeph">PgqlExample14.java</code> is:
                              </p><pre class="oac_no_warn" dir="ltr">-- Results for edge query -----------------
[LONG: 11,	STRING: knows]
[LONG: 6,	STRING: knows]
[LONG: 10,	STRING: knows]
[LONG: 5,	STRING: knows]
[LONG: 4,	STRING: knows]
[LONG: 13,	STRING: knows]
[LONG: 12,	STRING: knows]
[LONG: 9,	STRING: knows]
[LONG: 8,	STRING: knows]
[LONG: 15,	STRING: knows]
[LONG: 7,	STRING: knows]
[LONG: 14,	STRING: knows]

-- Vertex objects retrieved from vertex query --
Vertex ID 3 [NULL] {}
Vertex ID 0 [NULL] {}
Vertex ID 2 [NULL] {}
Vertex ID 1 [NULL] {}

-- Vertex objects retrieved from vertex query with setPartial(true) --
Vertex ID 3 [NULL] {bval:bol:false, fname:str:Susan, lname:str:Blue, mval:bol:false, age:int:35}
Vertex ID 0 [NULL] {bval:bol:true, fname:str:Bill, lname:str:Brown, mval:str:y, age:int:40}
Vertex ID 2 [NULL] {fname:str:Ray, lname:str:Green, mval:dat:1985-01-01 04:00:00.0, age:int:41}
Vertex ID 1 [NULL] {bval:bol:true, fname:str:John, lname:str:Black, mval:int:27, age:int:30}
</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">Additional Options for PGQL Translation and Execution</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90" name="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90"></a><h5 id="SPGDG-GUID-623F91CC-1686-4D95-B69F-FA7F81352A90" class="sect5"><span class="enumeration_section">4.8.2.6 </span>Querying Another User’s Property Graph
                     </h5>
                     <div>
                        <p>You can query another user’s property graph data if you have been granted the appropriate privileges in the database. For example, to query GRAPH1 in SCOTT’s schema you must have READ privilege on SCOTT.GRAPH1GE$ and SCOTT.GRAPH1VT$, and you must also have READ privilege on SCOTT.GRAPH1GT$ if you want to query with the <code class="codeph">USE_GT_TAB=T</code> option.
                        </p>
                        <div class="example" id="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90__PGQLEXAMPLE14.JAVA-1F6F3261">
                           <p class="titleinexample">Example 4-38 PgqlExample15.java</p>
                           <p><code class="codeph">PgqlExample15.java</code> shows how another user can query a graph in SCOTT’s schema.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;

import oracle.pgql.lang.PgqlException;
import oracle.pgql.lang.ResultSet;

import java.util.*;
import java.text.*;

/**
 * This example shows how to query a property graph located in another user's
 * schema. READ privilege on GE$, VT$ and GT$ tables for the other user's
 * property graph are required to avoid ORA-00942: table or view does not exist.
 */
public class PgqlExample15
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;
    ResultSet rs = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Get a property graph instance for Scott's graph
      opg = OraclePropertyGraph.getInstance(oracle, "SCOTT", szGraph, 1, 1, null, null);

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // Execute query to get a ResultSet object
      String pgql = 
        "SELECT v.fname AS fname, v.lname AS lname "+
        "MATCH (v)";
      rs = ops.executeQuery(pgql, "");

      // Print query results
      printResults(rs, 2);
    }
    finally {
      // close the result set
      if (rs != null) {
        rs.close();
      }
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }

  /**
   * Prints a PGQL ResultSet
   */
  static void printResults(ResultSet rs, int numCols) throws Exception
  {
    StringBuffer buff = new StringBuffer("");
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    while (rs.next()) {
      buff.append("[");
      for (int i = 1; i &lt;= numCols; i++) {
        // use generic getObject to handle all types
        Object mval = rs.getObject(i);
        String mStr = "";
        if (mval instanceof java.lang.String) {
          mStr = "STRING: "+mval.toString();
        }
        else if (mval instanceof java.lang.Integer) {
          mStr = "INTEGER: "+mval.toString();
        }
        else if (mval instanceof java.lang.Long) {
          mStr = "LONG: "+mval.toString();
        }
        else if (mval instanceof java.lang.Float) {
          mStr = "FLOAT: "+mval.toString();
        }
        else if (mval instanceof java.lang.Double) {
          mStr = "DOUBLE: "+mval.toString();
        }
        else if (mval instanceof java.sql.Timestamp) {
          mStr = "DATE: "+sdf.format((java.util.Date)mval);
        }
        else if (mval instanceof java.lang.Boolean) {
          mStr = "BOOLEAN: "+mval.toString();
        }
        if (i &gt; 1) {
          buff.append(",\t");
        }
        buff.append(mStr);
      }
      buff.append("]\n");
    }
    System.out.println(buff.toString());
  }
}
</code></pre><p>The following SQL statements create database user USER2 and grant the necessary privileges. You can also use the <code class="codeph">OraclePropertyGraph.grantAccess</code> Java API to achieve the same effect.
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; grant connect, resource, unlimited tablespace to user2 identified by user2;

Grant succeeded.

SQL&gt; grant read on scott.graph1vt$ to user2;

Grant succeeded.

SQL&gt; grant read on scott.graph1ge$ to user2;

Grant succeeded.

SQL&gt; grant read on scott.graph1gt$ to user2;

Grant succeeded.
</pre><p>The output for <code class="codeph">PgqlExample15.java</code> for the <code class="codeph">test_graph</code> data set when connected to the database as USER2 is as follows. Note that <code class="codeph">test_graph</code> should have already been loaded as GRAPH1 by user SCOTT before running <code class="codeph">PgqlExample15</code>.
                           </p><pre class="oac_no_warn" dir="ltr">[STRING: Susan,	STRING: Blue]
[STRING: Bill,	STRING: Brown]
[STRING: Ray,	STRING: Green]
[STRING: John,	STRING: Black]
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF" name="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF"></a><h5 id="SPGDG-GUID-EECCE896-473F-46DD-8805-9BF696DF60AF" class="sect5"><span class="enumeration_section">4.8.2.7 </span>Using Query Optimizer Hints with PGQL
                     </h5>
                     <div>
                        <p>The Java API allows query optimizer hints that influence the join type when executing PGQL queries. The <code class="codeph">executeQuery</code> and <code class="codeph">translateQuery</code> methods in <code class="codeph">OraclePgqlStatement</code> and <code class="codeph">OraclePgqlPreparedStatement</code> accept the following strings in the options argument to influence the query plan for the corresponding SQL query.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>ALL_EDGE_NL &#x2013; Use Nested Loop join for all joins that involve the $GE and $GT tables.</p>
                           </li>
                           <li>
                              <p>ALL_EDGE_HASH &#x2013; Use HASH join for all joins that involve the $GE and $GT tables.</p>
                           </li>
                           <li>
                              <p>ALL_VERTEX_NL &#x2013; Use Nested Loop join for all joins that involve the $VT table.</p>
                           </li>
                           <li>
                              <p>ALL_VERTEX_HASH &#x2013; Use HASH join for all joins that involve the $VT table.</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF__PGQLEXAMPLE15.JAVA-1F6FFA62">
                           <p class="titleinexample">Example 4-39 PgqlExample16.java</p>
                           <p><code class="codeph">PgqlExample16.java</code> shows how to use optimizer hints to influence the joins used for a graph traversal.
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*; 
import oracle.pg.common.*;
import java.util.*;
import java.text.*;
import java.sql.*;
import java.time.*;
import java.time.format.*;

/**
 * This example shows how to use query optimizer hints with PGQL queries.
 */
public class PgqlExample16
{

  public static void main(String[] szArgs) throws Exception
  {
    int iArgIdx=0;
    String szHost               = szArgs[iArgIdx++]; 
    String szPort               = szArgs[iArgIdx++]; 
    String szSID                = szArgs[iArgIdx++]; 
    String szUser               = szArgs[iArgIdx++]; 
    String szPassword           = szArgs[iArgIdx++];
    String szGraph              = szArgs[iArgIdx++];
    String szVertexFile         = szArgs[iArgIdx++];
    String szEdgeFile           = szArgs[iArgIdx++];

    Oracle oracle = null;
    OraclePropertyGraph opg = null;
    OraclePgqlStatement ops = null;

    try {
      // Create a connection to Oracle
      oracle = 
        new Oracle("jdbc:oracle:thin:@"+szHost+":"+szPort +":"+szSID, szUser, szPassword);

      // Create a property graph
      opg = OraclePropertyGraph.getInstance(oracle, szGraph);
      // Clear any existing data
      opg.clearRepository();
      
      // Load data
      OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance();
      opgLoader.loadData(opg, szVertexFile, szEdgeFile, 1);

      // populate GT$ skeleton table with distinct edges
      CallableStatement cs = null;
      cs = oracle.getConnection().prepareCall(
        "begin opg_graphop.populate_skeleton_tab(:1,:2); end;"
      );
      cs.setString(1,szGraph);
      cs.setInt(2,1);
      cs.execute();
      cs.close();

      // Query to illustrate join hints
      String pgql = 
        "SELECT id(v1), id(v4) "+
        "MATCH (v1)-[:friendOf]-&gt;(v2)-[:friendOf]-&gt;(v3)-[:friendOf]-&gt;(v4)";

      // Create an OraclePgqlStatement
      ops = OraclePgqlExecutionFactory.createStatement(opg);

      // get SQL translation with hash join hint
      OraclePgqlSqlTrans sqlTrans = 
        ops.translateQuery(pgql /* query string */, 
                           " USE_GT_TAB=T ALL_EDGE_HASH " /* options */);
      // print SQL translation
      System.out.println("-- Query with ALL_EDGE_HASH --------------------");
      System.out.println(sqlTrans.getSqlTranslation()+"\n");

      // get SQL translation with nested loop join hint
      sqlTrans = 
        ops.translateQuery(pgql /* query string */, 
                           " USE_GT_TAB=T ALL_EDGE_NL " /* options */);
      // print SQL translation
      System.out.println("-- Query with ALL_EDGE_NL ---------------------");
      System.out.println(sqlTrans.getSqlTranslation()+"\n");
    }
    finally {
      // close the statement
      if (ops != null) {
        ops.close();
      }
      // close the property graph
      if (opg != null) {
        opg.shutdown();
      }
      // close oracle
      if (oracle != null) {
        oracle.dispose();
      }
    }
  }
}
</code></pre><p>The output for <code class="codeph">PgqlExample16.java</code> for <code class="codeph">test_graph</code> is:
                           </p><pre class="oac_no_warn" dir="ltr">-- Query with ALL_EDGE_HASH --------------------
SELECT /*+ USE_HASH(T0$0 T0$1 T0$2) */ 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v4)$T",
to_nchar(T0$2.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v4)$V",
T0$2.DVID AS "id(v4)$VN",
to_timestamp_tz(null) AS "id(v4)$VT"
FROM "SCOTT".GRAPH1GT$ T0$0,
"SCOTT".GRAPH1GT$ T0$1,
"SCOTT".GRAPH1GT$ T0$2
WHERE T0$0.DVID=T0$1.SVID AND
T0$1.DVID=T0$2.SVID AND
(T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL) AND
(T0$1.EL = n'friendOf' AND T0$1.EL IS NOT NULL) AND
(T0$2.EL = n'friendOf' AND T0$2.EL IS NOT NULL)

-- Query with ALL_EDGE_NL ---------------------
SELECT /*+ USE_NL(T0$0 T0$1 T0$2) */ 7 AS "id(v1)$T",
to_nchar(T0$0.SVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v1)$V",
T0$0.SVID AS "id(v1)$VN",
to_timestamp_tz(null) AS "id(v1)$VT",
7 AS "id(v4)$T",
to_nchar(T0$2.DVID,'TM9','NLS_Numeric_Characters=''.,''') AS "id(v4)$V",
T0$2.DVID AS "id(v4)$VN",
to_timestamp_tz(null) AS "id(v4)$VT"
FROM "SCOTT".GRAPH1GT$ T0$0,
"SCOTT".GRAPH1GT$ T0$1,
"SCOTT".GRAPH1GT$ T0$2
WHERE T0$0.DVID=T0$1.SVID AND
T0$1.DVID=T0$2.SVID AND
(T0$0.EL = n'friendOf' AND T0$0.EL IS NOT NULL) AND
(T0$1.EL = n'friendOf' AND T0$1.EL IS NOT NULL) AND
(T0$2.EL = n'friendOf' AND T0$2.EL IS NOT NULL)
</pre><p>The query plan for the first query that uses ALL_EDGE_HASH should look similar to the following.</p><pre class="oac_no_warn" dir="ltr">------------------------------------------
| Id  | Operation            | Name      |
------------------------------------------
|   0 | SELECT STATEMENT     |           |
|*  1 |  HASH JOIN           |           |
|   2 |   PARTITION HASH ALL |           |
|*  3 |    TABLE ACCESS FULL | GRAPH1GT$ |
|*  4 |   HASH JOIN          |           |
|   5 |    PARTITION HASH ALL|           |
|*  6 |     TABLE ACCESS FULL| GRAPH1GT$ |
|   7 |    PARTITION HASH ALL|           |
|*  8 |     TABLE ACCESS FULL| GRAPH1GT$ |
------------------------------------------
</pre><p>The query plan for the second query that uses ALL_EDGE_NL should look similar to the following.</p><pre class="oac_no_warn" dir="ltr">------------------------------------------
| Id  | Operation            | Name      |
------------------------------------------
|   0 | SELECT STATEMENT     |           |
|   1 |  NESTED LOOPS        |           |
|   2 |   NESTED LOOPS       |           |
|   3 |    PARTITION HASH ALL|           |
|*  4 |     TABLE ACCESS FULL| GRAPH1GT$ |
|   5 |    PARTITION HASH ALL|           |
|*  6 |     TABLE ACCESS FULL| GRAPH1GT$ |
|   7 |   PARTITION HASH ALL |           |
|*  8 |    TABLE ACCESS FULL | GRAPH1GT$ |
------------------------------------------
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">Using the oracle.pg.rdbms Java Package to Execute PGQL Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA" name="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA"></a><h4 id="SPGDG-GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA" class="sect4"><span class="enumeration_section">4.8.3 </span>Performance Considerations for PGQL Queries
                  </h4>
                  <div>
                     <p>Many factors affect the performance of PGQL queries in Oracle Database. The following are some recommended practices for query performance.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__QUERYOPTIMIZERSTATISTICS-2194DC83">Query Optimizer Statistics</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E2BC">GT$ Skeleton Table</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EB29">Parallel Query Execution</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197EE4E">Optimizer Dynamic Sampling</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F1B6">Bind Variables</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F62C">Path Queries</a></p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__QUERYOPTIMIZERSTATISTICS-2194DC83">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GUID-87F800CE-8910-4269-88C2-DBBE572DA3EC"> Query Optimizer Statistics</p>
                        <p>Good, up-to-date query optimizer statistics are critical for query performance. Ensure that you run <a href="OPG_APIS-reference.html#GUID-7B1D9A79-CFFA-46A1-AB96-F9E9AE1497D4">OPG_APIS.ANALYZE_PG</a> after any significant updates to your property graph data.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E2BC">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E570">GT$ Skeleton Table</p>
                        <p>Without the GT$ skeleton table populated, many queries may require several sorts of the GE$ edge property table to evaluate graph traversals. Whenever possible, you should populate the GT$ skeleton table before running PGQL queries to avoid these expensive sorting operations.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EB29">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EC8A"> Parallel Query Execution</p>
                        <p>Use parallel query execution to take advantage of Oracle’s parallel SQL engine. Parallel execution often gives a significant speedup versus serial execution. Parallel execution is especially critical for path queries evaluated using the recursive WITH strategy.</p>
                        <p>See also the <a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about parallel query execution.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197EE4E">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197F03A"> Optimizer Dynamic Sampling</p>
                        <p>Due to the inherent flexibility of the graph data model, static information may not always produce optimal query plans. In such cases, dynamic sampling can be used by the query optimizer to sample data at run time for better query plans. The amount of data sampled is controlled by the dynamic sampling level used. Dynamic sampling levels range from 0 to 11. The best level to use depends on a particular dataset and workload, but levels of 2 (default), 6 or 11 often give good results.</p>
                        <p>See also <a href="../tgsql/optimizer-statistics-concepts.html#TGSQL341" target="_blank">Supplemantal Dynamic Statistics</a> in the <span class="italic">Oracle Database SQL Tuning Guide</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F1B6">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F44F"> Bind Variables</p>
                        <p>Use bind variables for constants whenever possible. The use of bind variables gives a very large reduction in query compilation time, which dramatically increases throughput for query workloads with queries that differ only in the constant values used. In addition, queries with bind variables are less vulnerable to injection attacks.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F62C">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F90B">  Path Queries</p>
                        <p>Path queries in PGQL that use the <code class="codeph">+</code> (plus sign) or <code class="codeph">*</code> (asterisk) operator to search for arbitrary length paths require special consideration because of their high computational complexity. You should use parallel execution and use the DISTINCT option for Recursive WITH (USE_DIST_RW=T) for the best performance. Also, for large, highly connected graphs, it is a good idea to use MAX_PATH_LEN=<span class="italic">n</span> to limit the number of repetitions of the recursive step to a reasonable number. A good strategy can be to start with a small repetition limit, and iteratively increase the limit to find more and more results.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="This topic explains how you can execute PGQL queries directly against the graph in Oracle Database (as opposed to in-memory).">Executing PGQL Queries Directly Against Oracle Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>