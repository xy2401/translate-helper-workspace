<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface.">
      <meta name="description" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface.">
      <title>Using SQL Statements in OCI</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96204-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="data-types.html" title="Previous" type="text/html">
      <link rel="next" href="binding-and-defining-in-oci.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNOCI">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="data-types.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="binding-and-defining-in-oci.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Using SQL Statements in OCI</li>
            </ol>
            <a id="GUID-3F20EDC9-D436-4A54-9698-4FA95988A819" name="GUID-3F20EDC9-D436-4A54-9698-4FA95988A819"></a><a id="LNOCI040"></a>
            
            <h2 id="LNOCI-GUID-3F20EDC9-D436-4A54-9698-4FA95988A819" class="sect2"><span class="enumeration_chapter">6 </span> Using SQL Statements in OCI
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface.</p>
               <p>This chapter contains these topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" title="One of the most common tasks of an OCI program is to accept and process SQL statements.">Overview of SQL Statement Processing</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" title="SQL and PL/SQL statements are prepared for execution by using the statement prepare call and any necessary bind calls.">About Preparing Statements</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" title="Most DML statements, and some queries (such as those with a WHERE clause), require a program to pass data to Oracle Database as part of a SQL or PL/SQL statement.">About Binding Placeholders in OCI</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-C71878A2-B089-4666-9898-AA56A54AD03D" title="An OCI application executes prepared statements individually using OCIStmtExecute().">About Executing Statements</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="If your OCI application is processing a query, you may need to obtain more information about the items in the select list.">About Describing Select-List Items</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" title="Query statements return data from the database to your application.">About Defining Output Variables in OCI</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" title="If an OCI application has processed a query, it is typically necessary to fetch the results with OCIStmtFetch2() after the statement has completed execution.">About Fetching Results</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" title="A cursor is a current position in a result set.">About Using Scrollable Cursors in OCI</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16338"></a><a id="LNOCI16337"></a><div class="props_rev_3"><a id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" name="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07"></a><h3 id="LNOCI-GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" class="sect3"><span class="enumeration_section">6.1 </span>Overview of SQL Statement Processing
               </h3>
               <div>
                  <p>One of the most common tasks of an OCI program is to accept and process SQL statements.</p>
                  <p>Chapter 3 “OCI Programming Basics” discussed the basic steps involved in any OCI application. This chapter presents a more detailed look at the specific tasks involved in processing SQL statements in an OCI program.</p>
                  <p>This section outlines the specific steps involved in accepting and processing SQL statements.</p>
                  <p>Once you have allocated the necessary handles and connected to an Oracle database, follow the steps illustrated in <a href="using-sql_statements-in-oci.html#GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__I448548">Figure 6-1</a>.
                  </p>
                  <div class="figure" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__I448548">
                     <p class="titleinfigure">Figure 6-1 Steps in Processing SQL Statements</p><img src="img/lnoci020.png" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows" longdesc="img_text/lnoci020.html"><br><a href="img_text/lnoci020.html">Description of "Figure 6-1 Steps in Processing SQL Statements"</a></div>
                  <!-- class="figure" -->
                  <ol>
                     <li>
                        <p>Prepare the statement. Define an application request using <code class="codeph">OCIStmtPrepare2()</code>. <code class="codeph">OCIStmtPrepare2()</code> is an enhanced version of <code class="codeph">OCIStmtPrepare()</code> that was introduced to support statement caching. Beginning with Oracle Database 12<code class="codeph">c</code> Release 2 (12.2), <code class="codeph">OCIStmtPrepare()</code> is deprecated.
                        </p>
                     </li>
                     <li>
                        <p>Bind placeholders, if necessary. For DML statements and queries with input variables, perform one or more of the following bind calls to bind the address of each input variable (or PL/SQL output variable) or array to each placeholder in the statement.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">OCIBindByPos2()</code> or <code class="codeph">OCIBindByPos()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByName()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindObject()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindDynamic()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindArrayOfStruct()</code></p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>Execute the statement by calling <code class="codeph">OCIStmtExecute()</code>. For DDL statements, no further steps are necessary.
                        </p>
                     </li>
                     <li>
                        <p>Describe the select-list items, if necessary, using<code class="codeph">OCIParamGet()</code> and <code class="codeph">OCIAttrGet()</code>. This is optional step is not required if the number of select-list items and the attributes of each item (such as its length and data type) are known at compile time.
                        </p>
                     </li>
                     <li>
                        <p>Define output variables, if necessary. For queries, perform one or more define calls to <code class="codeph">OCIDefineByPos2()</code> or <code class="codeph">OCIDefineByPos()</code>, , <code class="codeph">OCIDefineObject()</code>, <code class="codeph">OCIDefineDynamic()</code>, or <code class="codeph">OCIDefineArrayOfStruct()</code> to define an output variable for each select-list item in the SQL statement. Note that you do not use a define call to define the output variables in an anonymous PL/SQL block. You did this when you bound the data.
                        </p>
                     </li>
                     <li>
                        <p>Fetch the results of the query, if necessary, by calling <code class="codeph">OCIStmtFetch2()</code>.
                        </p>
                     </li>
                  </ol>
                  <p>After these steps have been completed, the application can free allocated handles and then detach from the server, or it may process additional statements.</p>
                  <div class="infoboxnote" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-8C43E4A5-00DA-417F-AEAC-A0925D1B1E4E">
                     <p class="notep1">Note:</p>
                     <p>OCI programs no longer require an explicit parse step. If a statement must be parsed, that step occurs upon execution, meaning that release 8.0 or later applications must issue an execute command for both DML and DDL statements.</p>
                  </div>
                  <p>The following sections describe each step in detail.</p>
                  <div class="infoboxnote" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-B29CCA9E-01EC-4666-B12F-3B98118CE6FE">
                     <p class="notep1">Note:</p>
                     <p>Some variation in the order of steps is possible. For example, it is possible to do the define step before the execute step if the data types and lengths of returned values are known at compile time.</p>
                  </div>
                  <p>Additional steps beyond those listed earlier may be required if your application must do any of the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Initiate and manage multiple transactions</p>
                     </li>
                     <li>
                        <p>Manage multiple threads of execution</p>
                     </li>
                     <li>
                        <p>Perform piecewise inserts, updates, or fetches</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-F46AE940-96E8-4121-8B87-26A230E94D09">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="performance-topics.html#GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" title="Statement caching refers to the feature that provides and manages a cache of statements for each session.">Statement Caching in OCI</a></p>
                        </li>
                        <li>
                           <p><a href="oci-programming-basics.html#GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" title="This chapter introduces concepts and procedures involved in programming with OCI.">OCI Programming Basics</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a> or <a href="deprecated-oci-functions.html#GUID-FD74B639-8B97-4A5A-BC3E-269CE59345CA" title="This function was deprecated beginning with Oracle Database 12c Release 2 (12.2).">OCIStmtPrepare()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a> or <a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a> or <a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="Sets up additional attributes that are required for a named data type (object) bind.">OCIBindObject()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="Returns a descriptor of a parameter specified by position in the describe handle or statement handle.">OCIParamGet()</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a> or <a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="Sets up additional attributes necessary for a named data type or REF define.">OCIDefineObject()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="Sets the additional attributes required if the OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos() or OCIDefineByPos2().">OCIDefineDynamic()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16340"></a><a id="LNOCI16339"></a><div class="props_rev_3"><a id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" name="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8"></a><h3 id="LNOCI-GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" class="sect3"><span class="enumeration_section">6.2 </span>About Preparing Statements
               </h3>
               <div>
                  <p>SQL and PL/SQL statements are prepared for execution by using the statement prepare call and any necessary bind calls.</p>
                  <p>In this phase, the application specifies a SQL or PL/SQL statement and binds associated placeholders in the statement to data for execution. The client-side library allocates storage to maintain the statement prepared for execution. </p>
                  <p>An application requests a SQL or PL/SQL statement to be prepared for execution using the <code class="codeph">OCIStmtPrepare2()</code> call and passes to this call a previously allocated statement handle. This is a completely local call, requiring no round-trip to the server. No association is made between the statement and a particular server at this point.
                  </p>
                  <p>Following the request call, an application can call <code class="codeph">OCIAttrGet()</code> on the statement handle, passing <code class="codeph">OCI_ATTR_STMT_TYPE</code> to the <code class="codeph">attrtype</code> parameter, to determine what type of SQL statement was prepared. The possible attribute values and corresponding statement types are listed in <a href="using-sql_statements-in-oci.html#GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__CIHEHCEJ" title="This table has 2 columns. Column 1 is the attribute value and column 2 describes its corresponding SQL statement type.">Table 6-1</a>.
                  </p>
                  <div class="tblformal" id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__CIHEHCEJ">
                     <p class="titleintable">Table 6-1 OCI_ATTR_STMT_TYPE Values and Statement Types</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="OCI_ATTR_STMT_TYPE Values and Statement Types" summary="This table has 2 columns. Column 1 is the attribute value and column 2 describes its corresponding SQL statement type." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="45%" id="d70425e967">Attribute Value</th>
                              <th align="left" valign="bottom" width="55%" id="d70425e970">Statement Type</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e975" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_SELECT</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e975 d70425e970 ">
                                 <p><code class="codeph">SELECT</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e985" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_UPDATE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e985 d70425e970 ">
                                 <p><code class="codeph">UPDATE</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e995" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DELETE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e995 d70425e970 ">
                                 <p><code class="codeph">DELETE</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1005" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_INSERT</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1005 d70425e970 ">
                                 <p><code class="codeph">INSERT</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1015" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_CREATE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1015 d70425e970 ">
                                 <p><code class="codeph">CREATE</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1025" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DROP</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1025 d70425e970 ">
                                 <p><code class="codeph">DROP</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1035" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_ALTER</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1035 d70425e970 ">
                                 <p><code class="codeph">ALTER</code> statement
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1045" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_BEGIN</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1045 d70425e970 ">
                                 <p><code class="codeph">BEGIN</code>... (PL/SQL)
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1055" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DECLARE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1055 d70425e970 ">
                                 <p><code class="codeph">DECLARE</code>... (PL/SQL)
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1065" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_CALL</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1065 d70425e970 ">
                                 <p><code class="codeph">CALL</code>... (PL/SQL)
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1075" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_MERGE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1075 d70425e970 ">
                                 <p><code class="codeph">MERGE</code>... (PL/SQL)
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>This section includes the following topic: <a href="using-sql_statements-in-oci.html#GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" title="A prepared application request can be executed on multiple servers at run time by reassociating the statement handle with the respective service context handles for the servers.">About Using Prepared Statements on Multiple Servers</a></p>
                  <div class="infoboxnotealso" id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__GUID-B0A1D3C7-C225-412D-9AEC-2987E671F870">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                        </li>
                        <li>
                           <p><a href="oci-programming-basics.html#GUID-46090C93-4BC4-4E88-AA09-3E9B716917A3" title="PL/SQL is Oracle's procedural extension to the SQL language.">About Using PL/SQL in an OCI Program</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16341"></a><div class="props_rev_3"><a id="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" name="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5"></a><h4 id="LNOCI-GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" class="sect4"><span class="enumeration_section">6.2.1 </span>About Using Prepared Statements on Multiple Servers
                  </h4>
                  <div>
                     <p>A prepared application request can be executed on multiple servers at run time by reassociating the statement handle with the respective service context handles for the servers. </p>
                     <p>All information about the current service context and statement handle association is lost when a new association is made.</p>
                     <p>For example, consider an application such as a network manager, which manages multiple servers. In many cases, it is likely that the same <code class="codeph">SELECT</code> statement must be executed against multiple servers to retrieve information for display. OCI allows the network manager application to prepare a <code class="codeph">SELECT</code> statement once and execute it against multiple servers. It must fetch all of the required rows from each server before reassociating the prepared statement with the next server. 
                     </p>
                     <div class="infoboxnote" id="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5__GUID-D891C149-5A14-49C1-8554-F2402CF925D4">
                        <p class="notep1">Note:</p>
                        <p>If a prepared statement must be reexecuted frequently on the same server, it is more efficient to prepare a new statement for another service context.</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72596"></a><a id="LNOCI16342"></a><div class="props_rev_3"><a id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" name="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70"></a><h3 id="LNOCI-GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" class="sect3"><span class="enumeration_section">6.3 </span>About Binding Placeholders in OCI
               </h3>
               <div>
                  <p>Most DML statements, and some queries (such as those with a <code class="codeph">WHERE</code> clause), require a program to pass data to Oracle Database as part of a SQL or PL/SQL statement.
                  </p>
                  <p>This data can be constant or literal, known when your program is compiled. For example, the following SQL statement, which adds an employee to a database, contains several literals, such as 'BESTRY' and 2365:</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES
    (2365, 'BESTRY', 'PROGRAMMER', 2000, 20)
</pre><p>Coding a statement like this into an application would severely limit its usefulness. You must change the statement and recompile the program each time you add a new employee to the database. To make the program more flexible, you can write the program so that a user can supply input data at run time.</p>
                  <p>When you prepare a SQL statement or PL/SQL block that contains input data to be supplied at run time, placeholders in the SQL statement or PL/SQL block mark where data must be supplied. For example, the following SQL statement contains five placeholders, indicated by the leading colons (<code class="codeph">:ename</code>), that show where input data must be supplied by the program.
                  </p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre><p>You can use placeholders for input variables in any <code class="codeph">DELETE</code>, <code class="codeph">INSERT</code>, <code class="codeph">SELECT</code>, or <code class="codeph">UPDATE</code> statement, or in a PL/SQL block, in any position in the statement where you can use an expression or a literal value. In PL/SQL, placeholders can also be used for output variables.
                  </p>
                  <p>Placeholders cannot be used to represent other Oracle objects such as tables. For example, the following is <span class="italic">not</span> a valid use of the <code class="codeph">emp</code> placeholder:
                  </p><pre class="oac_no_warn" dir="ltr">INSERT INTO :emp VALUES
    (12345, 'OERTEL', 'WRITER', 50000, 30)
</pre><p>For each placeholder in a SQL statement or PL/SQL block, you must call an OCI routine that binds the address of a variable in your program to that placeholder. When the statement executes, the database gets the data that your program placed in the input variables or bind variables and passes it to the server with the SQL statement.</p>
                  <p>Binding is used for both input and output variables in nonquery operations. In <a href="using-sql_statements-in-oci.html#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__CIHHHEFJ">Example 6-1</a>, the variables <code class="codeph">empno_out</code>, <code class="codeph">ename_out</code>, <code class="codeph">job_out</code>, <code class="codeph">sal_out</code>, and <code class="codeph">deptno_out</code> should be bound. These are outbinds (as opposed to regular inbinds).
                  </p>
                  <div class="example" id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__CIHHHEFJ">
                     <p class="titleinexample">Example 6-1 Binding Both Input and Output Variables in Nonquery Operations</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES
         (:empno, :ename, :job, :sal, :deptno)
      RETURNING
         (empno, ename, job, sal, deptno)
      INTO
         (:empno_out, :ename_out, :job_out, :sal_out, :deptno_out)
</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>This section includes the following topic: <a href="using-sql_statements-in-oci.html#GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" title="Lists and describes the rules for forming placeholders.">Rules for Placeholders</a></p>
                     <div class="infoboxnotealso" id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__GUID-4E05D7F7-1F88-4456-AFF9-1261EA92761B">
                        <p class="notep1">See Also:</p>
                        <p><a href="binding-and-defining-in-oci.html#GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" title="This chapter describes binding and defining in OCI.">Binding and Defining in OCI</a> for detailed information about implementing bind operations
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI16343"></a><div class="props_rev_3"><a id="GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" name="GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2"></a><h4 id="LNOCI-GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" class="sect4"><span class="enumeration_section">6.3.1 </span>Rules for Placeholders
                  </h4>
                  <div>
                     <p>Lists and describes the rules for forming placeholders.</p>
                     <p>The rules for forming placeholders are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The first character is a colon (":").</p>
                        </li>
                        <li>
                           <p>The colon is followed by a combination of underscore ("_"), A to Z, a to z, or 0 to 9. However, the first character following the colon cannot be an underscore.</p>
                        </li>
                        <li>
                           <p>The letters must be only from the English alphabet, and only the first 30 characters after the colon are significant. The name is case-insensitive.</p>
                        </li>
                        <li>
                           <p>The placeholder can consist of only digits after the colon. If it is only digits, the placeholder must be less than 65536. If the name starts with a digit, then only digits are allowed.</p>
                        </li>
                        <li>
                           <p>The hyphen ("-") is not allowed.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16344"></a><div class="props_rev_3"><a id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D" name="GUID-C71878A2-B089-4666-9898-AA56A54AD03D"></a><h3 id="LNOCI-GUID-C71878A2-B089-4666-9898-AA56A54AD03D" class="sect3"><span class="enumeration_section">6.4 </span>About Executing Statements
               </h3>
               <div>
                  <p>An OCI application executes prepared statements individually using <code class="codeph">OCIStmtExecute()</code>.
                  </p>
                  <p>When an OCI application executes a query, it receives from the Oracle database data that matches the query specifications. Within the database, the data is stored in Oracle-defined formats. When the results are returned, the OCI application can request that data be converted to a particular host language format, and stored in a particular output variable or buffer.</p>
                  <p>For each item in the select list of a query, the OCI application must define an output variable to receive the results of the query. The define step indicates the address of the buffer and the type of the data to be retrieved.</p>
                  <div class="infoboxnote" id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D__GUID-E82F5F0B-DD20-49FE-8E4D-8E4AACE9D0E1">
                     <p class="notep1">Note:</p>
                     <p>If output variables are defined for a <code class="codeph">SELECT</code> statement before a call to <code class="codeph">OCIStmtExecute()</code>, the number of rows specified by the <code class="codeph">iters</code> parameter are fetched directly into the defined output buffers and additional rows equivalent to the prefetch count are prefetched. If there are no additional rows, then the fetch is complete without calling <code class="codeph">OCIStmtFetch2()</code>.
                     </p>
                  </div>
                  <p><span class="bold"></span>For nonqueries, the number of times the statement is executed during array operations equals <code class="codeph">iters - rowoff</code>, where <code class="codeph">rowoff</code> is the offset in the bound array, and is also a parameter of the <code class="codeph">OCIStmtExecute()</code> call. 
                  </p>
                  <p>For example, if an array of 10 items is bound to a placeholder for an <code class="codeph">INSERT</code> statement, and <code class="codeph">iters</code> is set to 10, all 10 items are inserted in a single execute call when <code class="codeph">rowoff</code> is zero. If <code class="codeph">rowoff</code> is set to 2, only 8 items are inserted.
                  </p>
                  <div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" title="The OCIStmtExecute() call provides the ability to ensure that multiple service contexts operate on the same consistent snapshot of the database's committed data.">Execution Snapshots</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" title="You can specify a number of modes for the OCIStmtExecute() call.">Execution Modes of OCIStmtExecute()</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D__GUID-DD1BFE0C-6D36-4D60-8C8A-38A9591A5568">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" title="Query statements return data from the database to your application.">About Defining Output Variables in OCI</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16345"></a><div class="props_rev_3"><a id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" name="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF"></a><h4 id="LNOCI-GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" class="sect4"><span class="enumeration_section">6.4.1 </span>Execution Snapshots
                  </h4>
                  <div>
                     <p>The <code class="codeph">OCIStmtExecute()</code> call provides the ability to ensure that multiple service contexts operate on the same consistent snapshot of the database's committed data.
                     </p>
                     <p> This is achieved by taking the contents of the <code class="codeph">snap_out</code> parameter of one <code class="codeph">OCIStmtExecute()</code> call and passing that value as the <code class="codeph">snap_in</code> parameter of the next <code class="codeph">OCIStmtExecute()</code> call.
                     </p>
                     <div class="infoboxnote" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-5D019542-B9C5-4317-B3E3-22C4866E490D">
                        <p class="notep1">Note:</p>
                        <p>Uncommitted data in one service context is <span class="italic">not</span> visible to another context, even when both calls are using the same snapshot.
                        </p>
                     </div>
                     <p>The data type of both the <code class="codeph">snap_out</code> and <code class="codeph">snap_in</code> parameter is <code class="codeph">OCISnapshot</code>. OCISnapshot is an OCI snapshot descriptor that is allocated with the <code class="codeph">OCIDescriptorAlloc()</code> function.
                     </p>
                     <p>It is not necessary to specify a <span class="italic">snapshot</span> when calling <code class="codeph">OCIStmtExecute()</code>. The following sample code shows a basic execution in which the <code class="codeph">snapsho</code>t parameters are passed as <code class="codeph">NULL</code>.
                     </p><pre class="oac_no_warn" dir="ltr">checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
          (OCISnapshot *)NULL, (OCISnapshot *) NULL, OCI_DEFAULT));
</pre><div class="infoboxnote" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-ED0C13AA-D35C-4C64-B371-ED41963F76B8">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">checkerr()</code> function, which is user-developed, evaluates the return code from an OCI application.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-B93B608C-7050-492B-9882-B314A1F8445C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="Allocates storage to hold descriptors or LOB locators.">OCIDescriptorAlloc()</a></p>
                           </li>
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-82F35CC7-A79D-42CE-BF90-DE63FCBAAB7C" title="OCI descriptors and locators are opaque data structures that maintain data-specific information.">OCI Descriptors</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16346"></a><div class="props_rev_3"><a id="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" name="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B"></a><h4 id="LNOCI-GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" class="sect4"><span class="enumeration_section">6.4.2 </span>Execution Modes of OCIStmtExecute()
                  </h4>
                  <div>
                     <p>You can specify a number of modes for the <code class="codeph">OCIStmtExecute()</code> call.
                     </p>
                     <p>This section describes the OCIStmtExecute() call. See <code class="codeph">OCIStmtExecute()</code> for other values of the parameter <code class="codeph">mode</code>.
                     </p>
                     <div class="p">This section includes the following topics:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" title="OCI provides the ability to perform array DML operations.">Using Batch Error Mode</a></p>
                           </li>
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" title="Shows how the batch error execution mode might be used.">Example of Batch Error Mode</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B__GUID-0BB59F1B-28D3-406F-8C78-F32F8F735B52">
                        <p class="notep1">See Also:</p>
                        <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                     </div>
                  </div><a id="LNOCI16347"></a><div class="props_rev_3"><a id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" name="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D"></a><h5 id="LNOCI-GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" class="sect5"><span class="enumeration_section">6.4.2.1 </span>Using Batch Error Mode
                     </h5>
                     <div>
                        <p>OCI provides the ability to perform array DML operations.</p>
                        <div class="section">
                           <p>For example, an application can process an array of <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statements with a single statement execution. If one of the operations fails due to an error from the server, such as a unique constraint violation, the array operation terminates, and OCI returns an error. Any rows remaining in the array are ignored. The application must then reexecute the remainder of the array, and go through the whole process again if it encounters more errors, which causes additional round-trips.
                           </p>
                           <p>To facilitate processing of array DML operations, OCI provides the <span class="italic">batch error mode </span>(also called the<span class="italic"> enhanced DML array </span>feature). This mode, which is specified in the <code class="codeph">OCIStmtExecute()</code> call, simplifies DML array processing if there are one or more errors. In this mode, OCI attempts to insert, update, or delete all rows, and collects information about any errors that occurred. The application can then retrieve error information and reexecute any DML operations that failed during the first call. In this way, all DML operations in the array are attempted in the first call, and any failed operations can be reissued in a second call.
                           </p>
                           <div class="infoboxnote" id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D__GUID-9D30323B-B0AC-4A05-906E-7D038B3A6561">
                              <p class="notep1">Note:</p>
                              <p>This feature is only available to applications linked with release 8.1 or later OCI libraries running against a release 8.1 or later server. Applications must also be recoded to account for the new program logic described in this section.</p>
                           </div>
                           <p>This mode is used as follows:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>The user specifies <code class="codeph">OCI_BATCH_ERRORS</code> as the <span class="italic">mode</span> parameter of the <code class="codeph">OCIStmtExecute()</code> call.</span></li>
                           <li class="stepexpand"><span>After performing an array DML operation with <code class="codeph">OCIStmtExecute()</code>, the application can retrieve the number of errors encountered during the operation by calling <code class="codeph">OCIAttrGet()</code> on the statement handle to retrieve the <code class="codeph">OCI_ATTR_NUM_DML_ERRORS</code> attribute, as shown in the following code example.</span><div>
                                 <p>Calling OCIAttrGet() to Retrieve the Number of Errors Encountered During an Array DML Operation</p><pre class="oac_no_warn" dir="ltr">ub4   num_errs;
OCIAttrGet(stmtp, OCI_HTYPE_STMT, &amp;num_errs, 0, OCI_ATTR_NUM_DML_ERRORS,
           errhp);
</pre></div>
                           </li>
                           <li class="stepexpand"><span>The application extracts each error using <code class="codeph">OCIParamGet()</code>, along with its row information, from the error handle that was passed to the <code class="codeph">OCIStmtExecute()</code> call. To retrieve the information, the application must allocate an additional new error handle for the <code class="codeph">OCIParamGet()</code> call, populating the new error handle with batched error information. The application obtains the syntax of each error with <code class="codeph">OCIErrorGet()</code>, and the row offset into the DML array at which the error occurred, by calling <code class="codeph">OCIAttrGet()</code> on the new error handle.</span><div>
                                 <p>For example, after the <code class="codeph">num_errs</code> amount has been retrieved, the application can issue the following calls shown in the following code example.
                                 </p>
                                 <p>Retrieving Information About Each Error Following an Array DML Operation</p><pre class="oac_no_warn" dir="ltr">OCIError errhndl, errhp2;
for (i=0; i&lt;num_errs; i++)
{
   OCIParamGet(errhp, OCI_HTYPE_ERROR, errhp2, (void **)&amp;errhndl, i);
   OCIAttrGet(errhndl, OCI_HTYPE_ERROR, &amp;row_offset, 0,
       OCI_ATTR_DML_ROW_OFFSET, errhp2);
   OCIErrorGet(..., errhndl, ...);
</pre><p>Following this operation, the application can correct the bind information for the appropriate entry in the array using the diagnostic information retrieved from the batched error. Once the appropriate bind buffers are corrected or updated, the application can reexecute the associated DML statements.</p>
                                 <p>Because it cannot be determined at compile time which rows in the first execution may cause errors, the binds for the subsequent DML should be done dynamically by passing in the appropriate buffers at run time. The bind buffers used in the array binds done on the first DML operation can be reused.</p>
                                 <div class="infoboxnotealso" id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D__GUID-05BC5278-5CD5-4A9D-AC40-741044179C67">
                                    <p class="notep1">See Also:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                                       </li>
                                       <li>
                                          <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                                       </li>
                                       <li>
                                          <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="Returns a descriptor of a parameter specified by position in the describe handle or statement handle.">OCIParamGet()</a></p>
                                       </li>
                                       <li>
                                          <p><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="Returns an error message and an Oracle Database error code.">OCIErrorGet()</a></p>
                                       </li>
                                    </ul>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="LNOCI72599"></a><a id="LNOCI16348"></a><div class="props_rev_2"><a id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" name="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D"></a><h5 id="LNOCI-GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" class="sect5"><span class="enumeration_section">6.4.2.2 </span>Example of Batch Error Mode
                     </h5>
                     <div>
                        <p>Shows how the batch error execution mode might be used.</p>
                        <div class="section">
                           <p><a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">Example 6-2</a> shows an example of how the batch error execution mode might be used. In this example, assume that you have an application that inserts five rows (with two columns, of types <code class="codeph">NUMBER</code> and <code class="codeph">CHAR</code>) into a table. Furthermore, assume that only two rows (1 and 3) are successfully inserted in the initial DML operation. The user then proceeds to correct the data (wrong data was being inserted the first time) and to issue an update with the corrected data. The user uses statement handles <code class="codeph">stmtp1</code> and <code class="codeph">stmtp2</code> to issue the <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> statements, respectively.
                           </p>
                           <p>In <a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">Example 6-2</a>, <code class="codeph">OCIBindDynamic()</code> is used with a callback because the user does not know at compile time what rows may return with errors. With a callback, you can simply pass the erroneous row numbers, stored in <code class="codeph">row_off</code>, through the callback context and send only those rows that must be updated or corrected. The same bind buffers can be shared between the <code class="codeph">INSERT</code> and the <code class="codeph">UPDATE</code> statement executions.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">
                           <p class="titleinexample">Example 6-2 Using Batch Error Execution Mode</p><pre class="oac_no_warn" dir="ltr">OCIBind *bindp1[2], *bindp2[2];
ub4 num_errs, row_off[MAXROWS], number[MAXROWS] = {1,2,3,4,5};
char grade[MAXROWS] = {'A','B','C','D','E'};
OCIError *errhp2;
OCIError *errhndl[MAXROWS];
...
/* Array bind all the positions */
OCIBindByPos (stmtp1,&amp;bindp1[0],errhp,1,(void *)&amp;number[0],
     sizeof(number[0]),SQLT_INT,(void *)0, (ub2 *)0,(ub2 *)0,
            0,(ub4 *)0,OCI_DEFAULT);
OCIBindByPos (stmtp1,&amp;bindp1[1],errhp,2,(void *)&amp;grade[0],
     sizeof(grade[0]),SQLT_CHR,(void *)0, (ub2 *)0,(ub2 *)0,0,
            (ub4 *)0,OCI_DEFAULT);
/* execute the array INSERT */
OCIStmtExecute (svchp,stmtp1,errhp,5,0,0,0,OCI_BATCH_ERRORS);
/* get the number of errors. A different error handler errhp2 is used so that
 * the state of errhp is not changed */
OCIAttrGet (stmtp1, OCI_HTYPE_STMT, &amp;num_errs, 0,
            OCI_ATTR_NUM_DML_ERRORS, errhp2);
if (num_errs) {
   /* The user can do one of two things: 1) Allocate as many  */
   /* error handles as number of errors and free all handles  */
   /* at a later time; or 2) Allocate one err handle and reuse */
   /* the same handle for all the errors */
   for (i = 0; i &lt; num_errs; i++) {
      OCIHandleAlloc( (void *)envhp, (void **)&amp;errhndl[i],
      (ub4) OCI_HTYPE_ERROR, 0, (void *) 0);
      OCIParamGet(errhp, OCI_HTYPE_ERROR, errhp2, &amp;errhndl[i], i);
      OCIAttrGet (errhndl[i], OCI_HTYPE_ERROR, &amp;row_off[i], 0,
                  OCI_ATTR_DML_ROW_OFFSET, errhp2);
      /* get server diagnostics */
      OCIErrorGet (..., errhndl[i], ...);
      }
   }
/* make corrections to bind data */
OCIBindByPos (stmtp2,&amp;bindp2[0],errhp,1,(void *)0,sizeof(grade[0]),SQLT_INT,
     (void *)0, (ub2 *)0,(ub2 *)0,0,(ub4 *)0,OCI_DATA_AT_EXEC);
OCIBindByPos (stmtp2,&amp;bindp2[1],errhp,2,(void *)0,sizeof(number[0]),SQLT_DAT,
     (void *)0, (ub2 *)0,(ub2 *)0,0,(ub4 *)0,OCI_DATA_AT_EXEC);
/* register the callback for each bind handle, row_off and position
 * information can be passed to the callback function by means of context
 * pointers.
 */
OCIBindDynamic (bindp2[0],errhp,ctxp1,my_callback,0,0);
OCIBindDynamic (bindp2[1],errhp,ctxp2,my_callback,0,0);
/* execute the UPDATE statement */
OCIStmtExecute (svchp,stmtp2,errhp,num_errs,0,0,0,OCI_BATCH_ERRORS);
...
</pre><div class="infoboxnotealso" id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__GUID-81862A58-233D-4AA2-9416-7BA91BEF2EDF">
                              <p class="notep1">See Also:</p>
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16349"></a><div class="props_rev_3"><a id="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" name="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E"></a><h3 id="LNOCI-GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" class="sect3"><span class="enumeration_section">6.5 </span>About Describing Select-List Items
               </h3>
               <div>
                  <p>If your OCI application is processing a query, you may need to obtain more information about the items in the select list.</p>
                  <p>This is particularly true for dynamic queries whose contents are not known until run time. In this case, the program may need to obtain information about the data types and column lengths of the select-list items. This information is necessary to define output variables that may receive query results.</p>
                  <p>For example, consider a query where the program has no prior information about the columns in the <code class="codeph">employees</code> table:
                  </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM employees
</pre><p>There are two types of describes available: implicit and explicit. </p>
                  <p>An <span class="italic">implicit describe</span> does not require any special calls to retrieve describe information from the server, although special calls <span class="italic">are</span> necessary to access the information. An implicit describe allows an application to obtain select-list information as an attribute of the statement handle <span class="italic">after a statement has been executed</span> without making a specific describe call. It is called <span class="italic">implicit</span> because no describe call is required. The describe information comes <span class="italic">free</span> with the statement execution. 
                  </p>
                  <p>An <span class="italic">explicit describe</span> requires the application to call a particular function to bring the describe information from the server. An application may describe a select list (query) either implicitly or explicitly. Other schema elements must be described explicitly.
                  </p>
                  <p>You can describe a query explicitly before execution by specifying <code class="codeph">OCI_DESCRIBE_ONLY</code> as the mode of <code class="codeph">OCIStmtExecute()</code>, which does not execute the statement, but returns the select-list description. For performance reasons, Oracle recommends that applications use the implicit describe, which comes <span class="italic">free</span> with a standard statement execution.
                  </p>
                  <p>An explicit describe with the <code class="codeph">OCIDescribeAny()</code> call obtains information about schema objects rather than select lists.
                  </p>
                  <p>In all cases, the specific information about columns and data types is retrieved by reading handle attributes.</p>
                  <div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" title="After a SQL statement is executed, information about the select list is available as an attribute of the statement handle. No explicit describe call is needed.">Implicit Describe</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" title="You can describe a query explicitly before execution by specifying OCI_DESCRIBE_ONLY as the mode of OCIStmtExecute()">Explicit Describe of Queries</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E__GUID-D17C0F49-3D91-4601-87CC-D3CEAA8285AA">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="describing-schema-metadata.html#GUID-CED0D15A-D873-43F7-A5B2-51FC0662C250" title="Performs an explicit describe of schema objects and their subschema objects.The OCIDescribeAny() call limits information returned to the basic information and stops expanding a node if it amounts to another describe operation.What to be aware of when performing describe operations.The OCI_ATTR_TYPECODE attribute returns typecodes that represent the types supplied by the user when a new type is created using the CREATE TYPE statement.To describe type objects, it is necessary to initialize the OCI process in object mode.The column attribute OCI_ATTR_PRECISION can be returned using an implicit describe with OCIStmtExecute() and an explicit describe with OCIDescribeAny().The OCI_ATTR_LIST_ARGUMENTS attribute for type methods represents second-level arguments for the method.This section describes the attributes and handles that belong to different parameters. Lists and describes the type-specific attributes for parameters for a table or view. Lists and describes the type-specific attributes when a parameter is for a procedure or function.Lists and describes the attributes when a parameter is for a package.Lists and describes the attributes when a parameter is for a type. Lists and describes the attributes when a parameter is for an attribute of a type.Lists and dsescribes the attributes when a parameter is for a method of a type.Lists and describes the attributes when a parameter is for a collection type.Lists and describes the attributes when a parameter is for a synonym.Lists and describes the attributes when a parameter is for a sequence.Lists and describes the attributes when a parameter is for a column of a table or view.Lists and describes the attributes when a parameter is for an argument of a procedure or function.Lists and describes the attributes when the parameter is for a list of columns, arguments, and subprograms, or fields of a package record type.Lists and describes the attributes when a parameter is for a schema type.Lists and describes the attributes when a parameter is for a database type.Lists and describes the attributes when a parameter is for a rule.Lists and describes the attributes when a parameter is for a rule set.Lists and describes the attributes when a parameter is for an evaluation context.Lists and describes the attributes when a parameter is for a table alias.Lists and describes the attributes when a parameter is for a variable.Lists and describes the attributes when a parameter is for a name-value pair.Query and column information are supported with character-length semantics.If the database column was created using character-length semantics, then the implicit describe information contains the character length, the byte length, and a flag indicating how the database column was created.Explicit describes of tables have three attributes: OCI_ATTR_DATA_SIZE, OCI_ATTR_CHAR_SIZE, and OCI_ATTR_CHAR_USED.Character-length semantics depends on the release of the server or client. It is best described when both server and client are Oracle9i or later. Otherwise, compatibility issues as described result.The following examples demonstrate the use of OCIDescribeAny() for describing different types of schema objects.Illustrates the use of an explicit describe that retrieves the column data types for a table.The steps required to describe type methods (also divided into functions and procedures) are identical to those of regular PL/SQL functions and procedures.Illustrates the use of an explicit describe on a named object type.Illustrates the use of an explicit describe on a named collection type.Shows a loop that retrieves the column names and data types corresponding to a query following query execution.Illustrates the use of invisible column properties and checking each column to determine if it is an invisible column."> Describing Schema Metadata</a> for information about using <a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="Describes existing schema and subschema objects.">OCIDescribeAny()</a> to obtain metadata pertaining to schema objects
                           </p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="Describes existing schema and subschema objects.">OCIDescribeAny()</a></p>
                        </li>
                     </ul>
                     <p></p>
                  </div>
               </div><a id="LNOCI72600"></a><a id="LNOCI16350"></a><div class="props_rev_3"><a id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" name="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2"></a><h4 id="LNOCI-GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" class="sect4"><span class="enumeration_section">6.5.1 </span>Implicit Describe
                  </h4>
                  <div>
                     <p>After a SQL statement is executed, information about the select list is available as an attribute of the statement handle. No explicit describe call is needed.</p>
                     <p>To retrieve information about multiple select-list items, an application can call <code class="codeph">OCIParamGet()</code> with the <span class="italic">pos</span> parameter set to 1 the first time, and then iterate the value of <span class="italic">pos</span> and repeat the <code class="codeph">OCIParamGet()</code> call until <code class="codeph">OCI_ERROR</code> with <code class="codeph">ORA-24334</code> is returned. An application could also specify any position <span class="italic">n</span> to get a column at random.
                     </p>
                     <p>Once a parameter descriptor has been allocated for a position in the select list, the application can retrieve specific information by calling <code class="codeph">OCIAttrGet()</code> on the parameter descriptor. Information available from the parameter descriptor includes the data type and maximum size of the parameter.
                     </p>
                     <p>The sample code in <a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">Example 6-3</a><a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">Example 6-3</a> shows a loop that retrieves the column names and data types corresponding to a query following query execution. The query was associated with the statement handle by a prior call to <code class="codeph">OCIStmtPrepare2()</code>.
                     </p>
                     <p>The <code class="codeph">checkerr()</code> function in <a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">Example 6-3</a> is used for error handling. The complete listing can be found in the first sample application in <a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="Lists example programs with sample code demonstrating the allocation and use of OCI handles.">OCI Demonstration Programs</a>.
                     </p>
                     <p>The calls to <code class="codeph">OCIAttrGet()</code> and <code class="codeph">OCIParamGet()</code> are local calls that do not require a network round-trip, because all of the select-list information is cached on the client side after the statement is executed.
                     </p>
                     <div class="example" id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">
                        <p class="titleinexample">Example 6-3 Implicit Describe - Select List Is Available as an Attribute of the Statement Handle</p><pre class="oac_no_warn" dir="ltr">...
OCIParam     *mypard = (OCIParam *) 0;
ub2          dtype;
text         *col_name;
ub4          counter, col_name_len, char_semantics;
ub2          col_width;
sb4          parm_status;

text *sqlstmt = (text *)"SELECT * FROM employees WHERE employee_id = 100";

checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt), NULL, 0,
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *)0, (OCISnapshot *)0, OCI_DEFAULT));

/* Request a parameter descriptor for position 1 in the select list */
counter = 1;
parm_status = OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp,
               (void **)&amp;mypard, (ub4) counter);

/* Loop only if a descriptor was successfully retrieved for
   current position, starting at 1 */

while (parm_status == OCI_SUCCESS) {
   /* Retrieve the data type attribute */
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void*) &amp;dtype,(ub4 *) 0, (ub4) OCI_ATTR_DATA_TYPE,
           (OCIError *) errhp  ));

   /* Retrieve the column name attribute */
   col_name_len = 0;
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void**) &amp;col_name, (ub4 *) &amp;col_name_len, (ub4) OCI_ATTR_NAME,
           (OCIError *) errhp ));

   /* Retrieve the length semantics for the column */
   char_semantics = 0;
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void*) &amp;char_semantics,(ub4 *) 0, (ub4) OCI_ATTR_CHAR_USED,
           (OCIError *) errhp  ));
   col_width = 0;
   if (char_semantics)
       /* Retrieve the column width in characters */
       checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
               (void*) &amp;col_width, (ub4 *) 0, (ub4) OCI_ATTR_CHAR_SIZE,
               (OCIError *) errhp  ));
   else
       /* Retrieve the column width in bytes */
       checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
               (void*) &amp;col_width,(ub4 *) 0, (ub4) OCI_ATTR_DATA_SIZE,
               (OCIError *) errhp  ));

   /* increment counter and get next descriptor, if there is one */
   counter++;
   parm_status = OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp,
          (void **)&amp;mypard, (ub4) counter);
} /* while */
...
</pre><div class="infoboxnotealso" id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__GUID-439F6784-9B0D-4EDE-A84B-4BD86F6984E9">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="Returns a descriptor of a parameter specified by position in the describe handle or statement handle.">OCIParamGet()</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-8218D5F2-139B-4FA9-BA4A-ED0126687C0F" title="Allocates an array of descriptors.">OCIArrayDescriptorAlloc()</a></p>
                              </li>
                              <li>
                                 <p><a href="describing-schema-metadata.html#GUID-2EB52CE1-9947-472C-B8B3-24214D66EE19" title="This section describes the attributes and handles that belong to different parameters.">Parameter Attributes</a> for a list of the specific attributes of the parameter descriptor that may be read by <a href="handle-and-descriptor-functions.html#GUID-8218D5F2-139B-4FA9-BA4A-ED0126687C0F" title="Allocates an array of descriptors.">OCIArrayDescriptorAlloc()</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI72601"></a><a id="LNOCI16351"></a><div class="props_rev_3"><a id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" name="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C"></a><h4 id="LNOCI-GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" class="sect4"><span class="enumeration_section">6.5.2 </span>Explicit Describe of Queries
                  </h4>
                  <div>
                     <p>You can describe a query explicitly before execution by specifying <code class="codeph">OCI_DESCRIBE_ONLY</code> as the mode of <code class="codeph">OCIStmtExecute()</code></p>
                     <p>This does not execute the statement, but returns the select-list description.</p>
                     <div class="infoboxnote" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__GUID-9DBAC0A6-0912-4607-A80A-83A3820FD686">
                        <p class="notep1">Note:</p>
                        <p>To maximize performance, Oracle recommends that applications execute the statement in default mode and use the implicit describe that accompanies the execution.</p>
                     </div>
                     <p>The code in <a href="using-sql_statements-in-oci.html#GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__CIHCGFEE">Example 6-4</a> demonstrates the use of explicit describe in a select list to return information about columns.
                     </p>
                     <div class="example" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__CIHCGFEE">
                        <p class="titleinexample">Example 6-4 Explicit Describe - Returning the Select-List Description for Each Column</p><pre class="oac_no_warn" dir="ltr">...
int i = 0;
ub4 numcols = 0;
ub2 type = 0;
OCIParam *colhd = (OCIParam *) 0;   /* column handle */

text *sqlstmt = (text *)"SELECT * FROM employees WHERE employee_id = 100";

checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt), NULL, 0,
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

/* initialize svchp, stmthp, errhp, rowoff, iters, snap_in, snap_out */
/* set the execution mode to OCI_DESCRIBE_ONLY. Note that setting the mode to
OCI_DEFAULT does an implicit describe of the statement in addition to executing
the statement */

checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, 0, 0,
        (OCISnapshot *) 0, (OCISnapshot *) 0, OCI_DESCRIBE_ONLY));

/* Get the number of columns in the query */
checkerr(errhp, OCIAttrGet((void *)stmthp, OCI_HTYPE_STMT, (void *)&amp;numcols,
                      (ub4 *)0, OCI_ATTR_PARAM_COUNT, errhp));

/* go through the column list and retrieve the data type of each column.
Start from pos = 1 */
for (i = 1; i &lt;= numcols; i++)
{
  /* get parameter for column i */
  checkerr(errhp, OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp, (void **)&amp;colhd, i));

  /* get data-type of column i */
  type = 0;
  checkerr(errhp, OCIAttrGet((void *)colhd, OCI_DTYPE_PARAM,
          (void *)&amp;type, (ub4 *)0, OCI_ATTR_DATA_TYPE, errhp));
}
...
</pre><div class="infoboxnotealso" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__GUID-755DD05A-64EB-42FA-902E-7672D8152BBB">
                           <p class="notep1">See Also:</p>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI16352"></a><div class="props_rev_3"><a id="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" name="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296"></a><h3 id="LNOCI-GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" class="sect3"><span class="enumeration_section">6.6 </span>About Defining Output Variables in OCI
               </h3>
               <div>
                  <p>Query statements return data from the database to your application.</p>
                  <p>When processing a query, you must define an output variable or an array of output variables for each item in the select list from which to retrieve data. The define step creates an association that determines where returned results are stored, and in what format.</p>
                  <p>For example, to process the following statement you would normally define two output variables: one to receive the value returned from the <code class="codeph">name</code> column, and one to receive the value returned from the <code class="codeph">ssn</code> column:
                  </p><pre class="oac_no_warn" dir="ltr">SELECT name, ssn FROM employees
    WHERE empno = :empnum
</pre><div class="infoboxnotealso" id="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296__GUID-E3130724-AA9E-4D2B-AD0E-1A75CF1F3005">
                     <p class="notep1">See Also:</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" title="This chapter describes binding and defining in OCI.">Binding and Defining in OCI</a></p>
                  </div>
               </div>
            </div><a id="LNOCI16353"></a><div class="props_rev_3"><a id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" name="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6"></a><h3 id="LNOCI-GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" class="sect3"><span class="enumeration_section">6.7 </span>About Fetching Results
               </h3>
               <div>
                  <p>If an OCI application has processed a query, it is typically necessary to fetch the results with <code class="codeph">OCIStmtFetch2()</code> after the statement has completed execution. 
                  </p>
                  <p>The <code class="codeph">OCIStmtFetch2()</code> function supports <span class="italic">scrollable cursors</span>.
                  </p>
                  <p>Fetched data is retrieved into output variables that have been specified by define operations.</p>
                  <div class="infoboxnote" id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6__GUID-C5DC1425-6EB1-4C0D-9D59-D79DF64D5AB2">
                     <p class="notep1">Note:</p>
                     <p>If output variables are defined for a <code class="codeph">SELECT</code> statement before a call to <code class="codeph">OCIStmtExecute()</code>, the number of rows specified by the <code class="codeph">iters</code> parameter is fetched directly into the defined output buffers
                     </p>
                     <div class="p">This section includes the following topics:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-531299F8-6F55-4550-B389-1B3346045FC2" title="If LOB columns or attributes are part of a select list, they can be returned as LOB locators or actual LOB values, depending on how you define them.">About Fetching LOB Data</a></p>
                           </li>
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" title="To minimize server round-trips and optimize performance, OCI can prefetch result set rows when executing a query.">About Setting Prefetch Count</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="infoboxnotealso" id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6__GUID-9E5CCC5C-711B-4A5B-998C-ED09B56D1990">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" title="A cursor is a current position in a result set.">About Using Scrollable Cursors in OCI</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </li>
                        <li>
                           <p>These statements mentioned previously fetch data associated with the sample code in <a href="binding-and-defining-in-oci.html#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" title="A basic define is done with a position call, OCIDefineByPos() or OCIDefineByPos2().">Steps Used in OCI Defining</a>. See that example for more information.
                           </p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query statements return data from the database to your application.">Overview of Defining in OCI</a> for information about defining output variables
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16354"></a><div class="props_rev_3"><a id="GUID-531299F8-6F55-4550-B389-1B3346045FC2" name="GUID-531299F8-6F55-4550-B389-1B3346045FC2"></a><h4 id="LNOCI-GUID-531299F8-6F55-4550-B389-1B3346045FC2" class="sect4"><span class="enumeration_section">6.7.1 </span>About Fetching LOB Data
                  </h4>
                  <div>
                     <p>If LOB columns or attributes are part of a select list, they can be returned as LOB locators or actual LOB values, depending on how you define them.</p>
                     <p>If LOB locators are fetched, then the application can perform further operations on these locators through the <code class="codeph">OCILobXXX</code> functions.
                     </p>
                     <div class="infoboxnotealso" id="GUID-531299F8-6F55-4550-B389-1B3346045FC2__GUID-A4A28A80-A70B-48FC-B577-7AE99C3818D2">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" title="This chapter describes LOB and BFILE operations.">LOB and BFILE Operations</a> for more information about working with LOB locators in OCI
                              </p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-16652266-2A22-43AB-8BA3-9868CCEC9271">About Defining LOB Output Variables</a> for usage and examples of selecting LOB data without the use of locators
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16355"></a><div class="props_rev_3"><a id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" name="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02"></a><h4 id="LNOCI-GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" class="sect4"><span class="enumeration_section">6.7.2 </span>About Setting Prefetch Count
                  </h4>
                  <div>
                     <p>To minimize server round-trips and optimize performance, OCI can prefetch result set rows when executing a query.</p>
                     <p>You can customize this prefetching by setting either the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> or <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attribute of the statement handle using the <code class="codeph">OCIAttrSet()</code> function. These attributes are used as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> sets the number of rows to be prefetched. If it is not set, then the default value is 1. If the <code class="codeph">iters</code> parameter of <code class="codeph">OCIStmtExecute()</code> is 0 and prefetching is enabled, the rows are buffered during calls to <code class="codeph">OCIStmtFetch2()</code>. The prefetch value can be altered after execution and between fetches.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> sets the memory allocated for rows to be prefetched. The application then fetches as many rows as can fit into that much memory.
                           </p>
                        </li>
                     </ul>
                     <p>When both of these attributes are set, OCI prefetches rows up to the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> limit unless the <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> limit is reached, in which case OCI returns as many rows as can fit in a buffer of size <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>.
                     </p>
                     <p>By default, prefetching is turned on, and OCI fetches one extra row, except when prefetching cannot be supported for a query (see the note that follows). To turn prefetching off, set both the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> and <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attributes to zero.
                     </p>
                     <p>If both <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> and <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attributes are explicitly set, OCI uses the tighter of the two constraints to determine the number of rows to prefetch.
                     </p>
                     <p>To prefetch exclusively based on the memory constraint, set the <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attribute and be sure to disable the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> attribute by setting it to zero (to override the default setting of 1 row).
                     </p>
                     <p>To prefetch exclusively based on the number of rows constraint, set the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> attribute and disable the <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attribute by setting it to zero (if it was ever explicitly set to a non-zero value).
                     </p>
                     <p>Prefetching is possible for <code class="codeph">REF CURSOR</code>s and nested cursor columns. By default, prefetching is not turned on for <code class="codeph">REF CURSOR</code>s. To turn on prefetching for <code class="codeph">REF CURSOR</code>s, set the <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> or <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> attribute before fetching rows from the <code class="codeph">REF CURSOR</code>. When a <code class="codeph">REF CURSOR</code> is passed multiple times between an OCI application and PL/SQL and fetches on the <code class="codeph">REF CURSOR</code> are done in OCI and in PL/SQL, the rows prefetched by OCI (if enabled) cause the application to behave as if out-of-order rows are being fetched in PL/SQL. In such situations, OCI prefetch should not be enabled on <code class="codeph">REF CURSOR</code>s.
                     </p>
                     <div class="infoboxnote" id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02__GUID-BDED5EA1-B78B-429C-B938-02AD86D55370">
                        <p class="notep1">Note:</p>
                        <p>Prefetching is not in effect if <code class="codeph">LONG</code>, LOB or Opaque Type columns (such as <code class="codeph">XMLType</code>) are part of the query.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02__GUID-DA3E7081-C740-46C5-9151-959E661E08A6">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE" title="Lists and describes statement handle attributes.">Statement Handle Attributes</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16356"></a><div class="props_rev_3"><a id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" name="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2"></a><h3 id="LNOCI-GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" class="sect3"><span class="enumeration_section">6.8 </span>About Using Scrollable Cursors in OCI
               </h3>
               <div>
                  <p>A cursor is a current position in a <span class="italic">result set</span>. 
                  </p>
                  <p>Execution of a cursor puts the results of the query into a set of rows called the result set that can be fetched either sequentially or nonsequentially. In the latter case, the cursor is known as a <span class="italic">scrollable cursor.</span></p>
                  <p>A scrollable cursor supports forward and backward access into the result set from a given position, by using either absolute or relative row number offsets into the result set.</p>
                  <p>Rows are numbered starting at one. For a scrollable cursor, you can fetch previously fetched rows, the nth row in the result set, or the nth row from the current position. Client-side caching of either the partial or entire result set improves performance by limiting calls to the server.</p>
                  <p>Oracle Database does not support DML operations on scrollable cursors. A cursor cannot be made scrollable if the <code class="codeph">LONG</code> data type is part of the select list. 
                  </p>
                  <p>Moreover, fetches from a scrollable statement handle are based on the snapshot at execution time. OCI client prefetching works with OCI scrollable cursors. The size of the client prefetch cache can be controlled by the existing OCI attributes <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> and <code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>.
                  </p>
                  <div class="infoboxnote" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-54D355A4-C206-4DC4-A1F0-F3AC66052AA4">
                     <p class="notep1">Note:</p>
                     <p>Do not use scrollable cursors unless you require their functionality, because they use more server resources and can have greater response times than nonscrollable cursors.</p>
                  </div>
                  <p>The <code class="codeph">OCIStmtExecute()</code> call has an execution mode for scrollable cursors, <code class="codeph">OCI_STMT_SCROLLABLE_READONLY</code>. The default for statement handles is nonscrollable, forward sequential access only, where the mode is <code class="codeph">OCI_FETCH_NEXT</code>. You must set this execution mode each time the statement handle is executed.
                  </p>
                  <p>The statement handle attribute <code class="codeph">OCI_ATTR_CURRENT_POSITION</code> can be retrieved only by using <code class="codeph">OCIAttrGet()</code>. This attribute cannot be set by the application; it indicates the current position in the result set. 
                  </p>
                  <p>For nonscrollable cursors, <code class="codeph">OCI_ATTR_ROW_COUNT</code> is the total number of rows fetched into the user buffers with the <code class="codeph">OCIStmtFetch2()</code> calls since this statement handle was executed. Because nonscrollable cursors are forward sequential only, <code class="codeph">OCI_ATTR_ROW_COUNT</code> also represents the highest row number detected by the application.
                  </p>
                  <p>Beginning with Oracle Database Release 12.1, using the attribute <code class="codeph">OCI_ATTR_UB8_ROW_COUNT</code> is preferred to using the attribute <code class="codeph">OCI_ATTR_ROW_COUNT</code> if row count values can exceed the value of <code class="codeph">UB4MAXVAL</code> for an OCI application. 
                  </p>
                  <p>For scrollable cursors, <code class="codeph">OCI_ATTR_ROW_COUNT</code> represents the maximum (absolute) row number fetched into the user buffers. Because the application can arbitrarily position the fetches, this does not have to be the total number of rows fetched into the user's buffers since the (scrollable) statement was executed.
                  </p>
                  <p>The attribute <code class="codeph">OCI_ATTR_ROWS_FETCHED</code> on the statement handle represents the number of rows that were successfully fetched into the user's buffers in the last fetch call or execute. It works for both scrollable and nonscrollable cursors.
                  </p>
                  <p>Use the <code class="codeph">OCIStmtFetch2()</code> call, instead of the <code class="codeph">OCIStmtFetch()</code> call, which is retained for backward compatibility. You are encouraged to use <code class="codeph"></code><code class="codeph">OCIStmtFetch2()</code> for all new applications, even those not using scrollable cursors. This call also works for nonscrollable cursors, but can raise an error if any other orientation besides <code class="codeph">OCI_DEFAULT</code> or <code class="codeph">OCI_FETCH_NEXT</code> is passed.
                  </p>
                  <p>Scrollable cursors are supported for remote mapped queries. Transparent application failover (TAF) is supported for scrollable cursors.</p>
                  <div class="infoboxnote" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-6C0E8BAB-B241-4AED-A1C3-86A4822C21CA">
                     <p class="notep1">Note:</p>
                     <p>If you call <code class="codeph">OCIStmtFetch2()</code> with the <code class="codeph">nrows</code> parameter set to 0, the cursor is canceled.
                     </p>
                  </div>
                  <div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" title="Response time is improved if you use OCI client-side prefetch buffers.">About Increasing Scrollable Cursor Performance</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" title="Shows the use of a scrollable cursor.">Example of Access on a Scrollable Cursor</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-95D92C90-1E96-4BFA-AC7F-377A7AFB3A78">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" title="To minimize server round-trips and optimize performance, OCI can prefetch result set rows when executing a query.">About Setting Prefetch Count</a> 
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16357"></a><div class="props_rev_3"><a id="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" name="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89"></a><h4 id="LNOCI-GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" class="sect4"><span class="enumeration_section">6.8.1 </span>About Increasing Scrollable Cursor Performance
                  </h4>
                  <div>
                     <p>Response time is improved if you use OCI client-side prefetch buffers.</p>
                     <p>After calling <code class="codeph">OCIStmtExecute()</code> for a scrollable cursor, call <code class="codeph">OCIStmtFetch2()</code> using <code class="codeph">OCI_FETCH_LAST</code> to obtain the size of the result set. Then set <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code> to about 20% of that size, and set <code class="codeph">OCI_PREFETCH_MEMORY</code> if the result set uses a large amount of memory.
                     </p>
                     <div class="infoboxnotealso" id="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89__GUID-08630751-DF92-421D-A7EA-98E742A655F3">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72602"></a><a id="LNOCI16358"></a><div class="props_rev_3"><a id="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" name="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613"></a><h4 id="LNOCI-GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" class="sect4"><span class="enumeration_section">6.8.2 </span>Example of Access on a Scrollable Cursor
                  </h4>
                  <div>
                     <p>Shows the use of a scrollable cursor.</p>
                     <p>Assume that a result set is returned by the following SQL query, and that the table <code class="codeph">EMP</code> has 14 rows:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT empno, ename FROM emp
</pre><p>One use of scrollable cursors is shown in <a href="using-sql_statements-in-oci.html#GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613__CIHBFFEB">Example 6-5</a>. 
                     </p>
                     <div class="example" id="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613__CIHBFFEB">
                        <p class="titleinexample">Example 6-5 Access on a Scrollable Cursor</p><pre class="oac_no_warn" dir="ltr">...
/* execute the scrollable cursor in the scrollable mode */
OCIStmtExecute(svchp, stmthp, errhp, (ub4)0, (ub4)0, (CONST OCISnapshot *)NULL,
               (OCISnapshot *) NULL, OCI_STMT_SCROLLABLE_READONLY ); 
                                  
/* Fetches rows with absolute row numbers 6, 7, 8. After this call,
 OCI_ATTR_CURRENT_POSITION = 8, OCI_ATTR_ROW_COUNT = 8 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_ABSOLUTE, (sb4) 6, OCI_DEFAULT);
                               
/* Fetches rows with absolute row numbers 6, 7, 8. After this call,
 OCI_ATTR_CURRENT_POSITION = 8, OCI_ATTR_ROW_COUNT = 8 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_RELATIVE, (sb4) -2, OCI_DEFAULT);
                               
/* Fetches rows with absolute row numbers 14. After this call,
 OCI_ATTR_CURRENT_POSITION = 14, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 1, 
                               OCI_FETCH_LAST, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row number 1. After this call,
 OCI_ATTR_CURRENT_POSITION = 1, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 1, 
                               OCI_FETCH_FIRST, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row numbers 2, 3, 4. After this call,
 OCI_ATTR_CURRENT_POSITION = 4, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_NEXT, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row numbers 3,4,5,6,7. After this call,
 OCI_ATTR_CURRENT_POSITION = 7, OCI_ATTR_ROW_COUNT = 14. It is assumed 
the user's define memory is allocated. */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 5, 
                               OCI_FETCH_PRIOR, (sb4) 0, OCI_DEFAULT);
...
}
checkprint (errhp, status)
{
 ub4 rows_fetched;
/* This checks for any OCI errors before printing the results of the fetch call
   in the define buffers */
 checkerr (errhp, status);
 checkerr(errhp, OCIAttrGet((CONST void *) stmthp, OCI_HTYPE_STMT,
         (void *) &amp;rows_fetched, (uint *) 0, OCI_ATTR_ROWS_FETCHED, errhp));
}
...
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>