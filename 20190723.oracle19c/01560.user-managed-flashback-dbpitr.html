<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Performing User-Managed Database Flashback and Recovery</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Backup and Recovery User's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Backup and Recovery User's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-backup-and-recovery-users-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T05:20:45-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2003, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96241-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="user-managed-database-backups.html" title="Previous" type="text/html">
      <link rel="next" href="user-managed-recovery-advanced.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Backup and Recovery User's Guide">
    <meta name="dcterms.isVersionOf" content="BRADV">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="user-managed-database-backups.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="user-managed-recovery-advanced.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Backup and Recovery User's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-user-managed-backup-recovery.html" property="item" typeof="WebPage"><span property="name"> Performing User-Managed Backup and Recovery</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Performing User-Managed Database Flashback and Recovery</li>
            </ol>
            <a id="GUID-704F6AB0-04C4-4345-913B-B316DD06D05E" name="GUID-704F6AB0-04C4-4345-913B-B316DD06D05E"></a><a id="BRADV017"></a>
            
            <h2 id="BRADV-GUID-704F6AB0-04C4-4345-913B-B316DD06D05E" class="sect2"><span class="enumeration_chapter">30 </span>Performing User-Managed Database Flashback and Recovery
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d140508e69" class="indexterm-anchor"></a><a id="d140508e73" class="indexterm-anchor"></a>This chapter describes how to restore and recover a database and use the flashback features of Oracle Database in a user-managed backup and recovery strategy. A user-managed backup and recovery strategy means a method that does not depend on RMAN.
               </p>
               <p>This chapter contains the following topics:<a id="d140508e80" class="indexterm-anchor"></a><a id="d140508e84" class="indexterm-anchor"></a></p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" title="The SQL*Plus FLASHBACK DATABASE command performs the same function as the RMAN FLASHBACK DATABASE command: it returns the database to a prior state.">Performing Flashback Database with SQL*Plus</a></p>
                  </li>
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-4F81CE72-B1B3-4444-B7E9-7DC97C65836B" title="No additional setup is required to perform recovery when the archived redo log files are present in the default location.To perform media recovery when archived redo log files are stored in a nondefault location, you must specify the location of archived redo log files.">Overview of User-Managed Media Recovery</a></p>
                  </li>
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-66D07694-533F-4E3A-BA83-DD461B68DB56" title="Typically, you perform complete recovery of the database when a media failure has made one or more data files inaccessible. During complete database recovery, you use all available redo to recover the database to the current SCN.">Performing Complete Database Recovery</a></p>
                  </li>
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" title="Incomplete recovery is also known as database point-in-time recovery.">Performing Incomplete Database Recovery</a></p>
                  </li>
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A">Recovering a Database in NOARCHIVELOG Mode</a></p>
                  </li>
                  <li>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-36D3AEB2-CAB5-491D-8AAC-7E08ABC842A6">Troubleshooting Media Recovery</a></p>
                  </li>
               </ul>
            </div>
            <div class="sect2"><a id="GUID-2E5F3F62-17ED-472A-ABBD-FAAF107C6852" name="GUID-2E5F3F62-17ED-472A-ABBD-FAAF107C6852"></a><h3 id="BRADV-GUID-2E5F3F62-17ED-472A-ABBD-FAAF107C6852" class="sect3"><span class="enumeration_section">30.1 </span>Performing Flashback Database with SQL*Plus
               </h3>
               <div>
                  <p>You can use SQL*Plus to perform flashback database operations on non-CDBs, multitenant container databases (CDBs), and pluggable databases (PDBs). Oracle Flashback Database returns your entire database or an entire PDB to a previous state without requiring you to restore files from backup.</p>
                  <p>Flashback Database requires you to create a fast recovery area for your database and enable the collection of flashback logs. The requirements and preparations for flashback database are the same whether you use RMAN or SQL*Plus. </p>
                  <div class="infoboxnotealso" id="GUID-2E5F3F62-17ED-472A-ABBD-FAAF107C6852__GUID-0D3F9DCD-F111-407A-817E-494F481DB11B">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="rman-performing-flashback-dbpitr.html#GUID-5463669A-DC89-4FF4-ACCE-136A72DF687B" title="This overview describes the purpose and basic concepts of Oracle Flashback Technology and database point-in-time recovery.Certain situations are suited for using point-in-time recovery or flashback features to return the database or database object to its state at a previous point in time.Database point-in-time recovery (DBPITR) and Flashback features enable you to recover your database to a prior point in time.DBPITR works at the physical level to return the data files to their state at a target time in the past.RMAN provides support for point-in-time recovery for one or more PDBs. To recover PDBs, you must connect to the root as a user with SYSDBA or SYSBACKUP privilege. After recovery, old backups of the PDB remain valid and can be used if a media failure occurs.The flashback features of the Oracle Database are more efficient than media recovery in most circumstances in which they are available. You can use them to investigate past states of the database.Oracle Flashback Database is the most efficient alternative to DBPITR.Logical flashback features are used to recover tables and their contents to a past time.You can perform a Flashback Database operation for a whole multitenant container database (CDB) or for a particular pluggable database (PDB). A multitenant container database (CDB) can use shared undo or local undo. The technique used by RMAN to perform flashback database operations depends on the type of undo configuration for the CDB.RMAN provides methods to manage redo corruption to data blocks in a PDB.Flashback Table uses information in the undo tablespace rather than restored backups to retrieve the table. When a Flashback Table operation occurs, new rows are deleted and old rows are reinserted. The rest of your database remains available while the flashback of the table is being performed.To perform a Flashback Table operation, the table must be eligible to be flashed back and the user performing the operation must have the required privileges.To use the Flashback Table feature on one or more tables, use the FLASHBACK TABLE SQL statement with a target time or SCN.By default, the database disables triggers on the affected table before performing a FLASHBACK TABLE operation. After the operation, the database returns the triggers to the state they were in before the operation (enabled or disabled). You can retrieve objects from the recycle bin with the FLASHBACK TABLE ... TO BEFORE DROP statement.Flashback Drop reverses the effects of a DROP TABLE operation. Flashback Drop is faster than other recovery mechanisms that can be used in this situation, such as point-in-time recovery, and does not lead to downtime or loss of recent transactions.Prerequisites must be met before you perform a Flashback Drop operation.Use the FLASHBACK TABLE ... TO BEFORE DROP statement to recover objects from the recycle bin. You can specify either the name of the table in the recycle bin or the original table name.You can create, and then drop, several objects with the same original name. All dropped objects are stored in the recycle bin.Flashback Database reverses unwanted changes by returning your database to its state at a previous point in time.Flashback Database works by undoing changes to the data files that exist at the moment that you run the command. Prerequisites must be met to perform a Flashback Database operation.A Flashback Database operation uses the FLASHBACK DATABASE command to rewind the database to a past point in time.You can perform a flashback database operation for a whole multitenant container database (CDB) using the FLASHBACK DATABASE command.You can perform a flashback database operation for a single pluggable database (PDB) in a multitenant container database (CDB) using the FLASHBACK DATABASE command.Data dictionary views contain information that is used to monitor flashback database.RMAN DBPITR restores the database from backups before the target time for recovery, then uses incremental backups and redo to roll the database forward to the target time. You can recover to an SCN, time, log sequence number, or restore point. Oracle recommends that you create restore points at important times to make point-in-time recovery more manageable if it ever becomes necessary.Certain prerequisites must be met to perform database point-in-time recovery (DBPITR).Use the RESTORE and RECOVER commands to perform DBPITR.Use the RECOVER command to perform point-in-time recovery (PITR) of container databases (CDBs) and pluggable databases (PDBs). PITR of PDBs can only be performed using RMAN.Use the RESTORE and RECOVER commands to perform point-in-time recovery for a whole CDB.When you recover one or more PDBs to a specified point-in-time, the remaining PDBs in the CDB are not affected and they can be open and operational. Use the RESTORE and RECOVER commands to perform point-in-time recovery of an application PDB.Performing point-in-time recovery of sparse databases is similar to performing point-in-time recovery of normal databases. This section describes variations of the basic Flashback Database and DBPITR scenarios.Flashback Database can be used to undo an OPEN RESETLOGS operation.Flashback Database across OPEN RESETLOGS may be used to perform multiple functions in a Data Guard environment.You can use Flashback Database to rewind a database to an abandoned database incarnation.To perform DPITR to an noncurrent database incarnation, you must explicitly execute the RESET DATABASE to reset the database to the incarnation that was current at the target SCN. You must also restore a control file from the database incarnation containing the target SCN."> Performing Flashback and Database Point-in-Time Recovery</a> for details about how the Flashback Database feature works, requirements for using Flashback Database, and how to enable the collection of flashback logs required for Flashback Database
                           </p>
                        </li>
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" title="The SQL*Plus FLASHBACK DATABASE command performs the same function as the RMAN FLASHBACK DATABASE command: it returns the database to a prior state.">Performing Flashback Database of non-CDBs with SQL*Plus</a></p>
                        </li>
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-AFD27980-CCDC-4062-905A-7571DC0C0C4C" title="Use the SQL*Plus FLASHBACK DATABASE command to return a whole multitenant container database (CDB) to a prior state. The SQL*Plus FLASHBACK DATABASE command performs the same function as the RMAN FLASHBACK DATABASE command.">Performing Flashback Database of CDBs with SQL*Plus</a></p>
                        </li>
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44" title="Use the SQL*Plus FLASHBACK DATABASE command to return a specific pluggable database (PDB) to a prior state. The remaining PDBs in the multitenant container database (CDB) are not impacted by the flashback operation on a single PDB.">Performing Flashback Database of PDBs with SQL*Plus</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="BRADV99982"></a><div class="props_rev_3"><a id="GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" name="GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413"></a><h4 id="BRADV-GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" class="sect4"><span class="enumeration_section">30.1.1 </span>Performing Flashback Database of non-CDBs with SQL*Plus
                  </h4>
                  <div>
                     <p>The SQL*Plus <code class="codeph">FLASHBACK DATABASE</code> command performs the same function as the RMAN <code class="codeph">FLASHBACK DATABASE</code> command: it returns the database to a prior state.
                     </p>
                     <div class="p">The prerequisites for performing a flashback database operation are described in <a href="using-flasback-database-restore-points.html#GUID-AE2AD6A0-507A-4E40-A8FF-76AFC88EC56D" title="To ensure successful operation of Flashback Database and guaranteed restore points, you must first set some key database options.">Prerequisites for Flashback Database and Restore Points</a>.
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><span class="bold">To perform a flashback of a non-CDB using SQL*Plus:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Query the target database to determine the range of possible flashback SCNs. The following SQL*Plus queries show you the latest and earliest SCN in the flashback window:</span><div><pre class="oac_no_warn" dir="ltr">SELECT CURRENT_SCN FROM V$DATABASE;

SELECT OLDEST_FLASHBACK_SCN, OLDEST_FLASHBACK_TIME 
FROM   V$FLASHBACK_DATABASE_LOG;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Use other flashback features if necessary to identify the SCN or time of the unwanted changes to your database.</span></li>
                        <li class="stepexpand"><span>Ensure that the target database is mounted.</span><div>
                              <p>The following commands start the database in <code class="codeph">MOUNT</code> mode.
                              </p><pre class="oac_no_warn" dir="ltr">SHUTDOWN IMMEDIATE;
STARTUP MOUNT;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Start SQL*Plus with administrator privileges. </span></li>
                        <li class="stepexpand"><span>Run the <code class="codeph">FLASHBACK DATABASE</code> statement to return the database to a prior <code class="codeph">TIMESTAMP</code> or <code class="codeph">SCN</code>. For example:</span><div><pre class="oac_no_warn" dir="ltr">FLASHBACK DATABASE TO SCN 46963;
FLASHBACK DATABASE TO TIMESTAMP '2013-11-05 14:00:00';
FLASHBACK DATABASE 
  TO TIMESTAMP to_timestamp('2013-11-11 16:00:00', 'YYYY-MM-DD HH24:MI:SS');
</pre></div>
                        </li>
                        <li class="stepexpand"><span>When the operation completes, open the database read-only and perform queries to verify that you have recovered the data you need. </span><div>
                              <p>If your chosen target time was not far enough in the past, then use another <code class="codeph">FLASHBACK DATABASE</code> statement. Otherwise, you can use <code class="codeph">RECOVER DATABASE</code> to return the database to the present time and then try another <code class="codeph">FLASHBACK DATABASE</code> statement.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>When satisfied with the results, open the database with the <code class="codeph">RESETLOGS</code> option. </span><div>
                              <p>If appropriate, you can also use Data Pump Export to save lost data, use <code class="codeph">RECOVER DATABASE</code> to return the database to the present, and reimport the lost object.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413__GUID-831BABF2-87FD-41FD-97FB-D90ABD44AE8E">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../adfns/flashback.html#ADFNS1008" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> to learn how to use related flashback features such as Oracle Flashback Query and Oracle Flashback Transaction Query
                                 </p>
                              </li>
                              <li>
                                 <p><a href="rman-performing-flashback-dbpitr.html#GUID-5463669A-DC89-4FF4-ACCE-136A72DF687B" title="This overview describes the purpose and basic concepts of Oracle Flashback Technology and database point-in-time recovery.Certain situations are suited for using point-in-time recovery or flashback features to return the database or database object to its state at a previous point in time.Database point-in-time recovery (DBPITR) and Flashback features enable you to recover your database to a prior point in time.DBPITR works at the physical level to return the data files to their state at a target time in the past.RMAN provides support for point-in-time recovery for one or more PDBs. To recover PDBs, you must connect to the root as a user with SYSDBA or SYSBACKUP privilege. After recovery, old backups of the PDB remain valid and can be used if a media failure occurs.The flashback features of the Oracle Database are more efficient than media recovery in most circumstances in which they are available. You can use them to investigate past states of the database.Oracle Flashback Database is the most efficient alternative to DBPITR.Logical flashback features are used to recover tables and their contents to a past time.You can perform a Flashback Database operation for a whole multitenant container database (CDB) or for a particular pluggable database (PDB). A multitenant container database (CDB) can use shared undo or local undo. The technique used by RMAN to perform flashback database operations depends on the type of undo configuration for the CDB.RMAN provides methods to manage redo corruption to data blocks in a PDB.Flashback Table uses information in the undo tablespace rather than restored backups to retrieve the table. When a Flashback Table operation occurs, new rows are deleted and old rows are reinserted. The rest of your database remains available while the flashback of the table is being performed.To perform a Flashback Table operation, the table must be eligible to be flashed back and the user performing the operation must have the required privileges.To use the Flashback Table feature on one or more tables, use the FLASHBACK TABLE SQL statement with a target time or SCN.By default, the database disables triggers on the affected table before performing a FLASHBACK TABLE operation. After the operation, the database returns the triggers to the state they were in before the operation (enabled or disabled). You can retrieve objects from the recycle bin with the FLASHBACK TABLE ... TO BEFORE DROP statement.Flashback Drop reverses the effects of a DROP TABLE operation. Flashback Drop is faster than other recovery mechanisms that can be used in this situation, such as point-in-time recovery, and does not lead to downtime or loss of recent transactions.Prerequisites must be met before you perform a Flashback Drop operation.Use the FLASHBACK TABLE ... TO BEFORE DROP statement to recover objects from the recycle bin. You can specify either the name of the table in the recycle bin or the original table name.You can create, and then drop, several objects with the same original name. All dropped objects are stored in the recycle bin.Flashback Database reverses unwanted changes by returning your database to its state at a previous point in time.Flashback Database works by undoing changes to the data files that exist at the moment that you run the command. Prerequisites must be met to perform a Flashback Database operation.A Flashback Database operation uses the FLASHBACK DATABASE command to rewind the database to a past point in time.You can perform a flashback database operation for a whole multitenant container database (CDB) using the FLASHBACK DATABASE command.You can perform a flashback database operation for a single pluggable database (PDB) in a multitenant container database (CDB) using the FLASHBACK DATABASE command.Data dictionary views contain information that is used to monitor flashback database.RMAN DBPITR restores the database from backups before the target time for recovery, then uses incremental backups and redo to roll the database forward to the target time. You can recover to an SCN, time, log sequence number, or restore point. Oracle recommends that you create restore points at important times to make point-in-time recovery more manageable if it ever becomes necessary.Certain prerequisites must be met to perform database point-in-time recovery (DBPITR).Use the RESTORE and RECOVER commands to perform DBPITR.Use the RECOVER command to perform point-in-time recovery (PITR) of container databases (CDBs) and pluggable databases (PDBs). PITR of PDBs can only be performed using RMAN.Use the RESTORE and RECOVER commands to perform point-in-time recovery for a whole CDB.When you recover one or more PDBs to a specified point-in-time, the remaining PDBs in the CDB are not affected and they can be open and operational. Use the RESTORE and RECOVER commands to perform point-in-time recovery of an application PDB.Performing point-in-time recovery of sparse databases is similar to performing point-in-time recovery of normal databases. This section describes variations of the basic Flashback Database and DBPITR scenarios.Flashback Database can be used to undo an OPEN RESETLOGS operation.Flashback Database across OPEN RESETLOGS may be used to perform multiple functions in a Data Guard environment.You can use Flashback Database to rewind a database to an abandoned database incarnation.To perform DPITR to an noncurrent database incarnation, you must explicitly execute the RESET DATABASE to reset the database to the incarnation that was current at the target SCN. You must also restore a control file from the database incarnation containing the target SCN."> Performing Flashback and Database Point-in-Time Recovery</a> for details about how the Flashback Database feature works, requirements for using Flashback Database, and how to enable the collection of flashback logs required for Flashback Database
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AFD27980-CCDC-4062-905A-7571DC0C0C4C" name="GUID-AFD27980-CCDC-4062-905A-7571DC0C0C4C"></a><h4 id="BRADV-GUID-AFD27980-CCDC-4062-905A-7571DC0C0C4C" class="sect4"><span class="enumeration_section">30.1.2 </span>Performing Flashback Database of CDBs with SQL*Plus
                  </h4>
                  <div>
                     <p>Use the SQL*Plus <code class="codeph">FLASHBACK</code> <code class="codeph">DATABASE</code> command to return a whole multitenant container database (CDB) to a prior state. The SQL*Plus <code class="codeph">FLASHBACK DATABASE</code> command performs the same function as the RMAN <code class="codeph">FLASHBACK DATABASE</code> command.
                     </p>
                     <div class="p">The prerequisites for performing a flashback database operation are described in <a href="using-flasback-database-restore-points.html#GUID-AE2AD6A0-507A-4E40-A8FF-76AFC88EC56D" title="To ensure successful operation of Flashback Database and guaranteed restore points, you must first set some key database options.">Prerequisites for Flashback Database and Restore Points</a>.
                     </div>
                     <!-- class="section" -->
                     <div class="section"><span class="bold">To perform a flashback of the whole CDB using SQL*Plus:</span></div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Connect SQL*Plus to the root as a common user with the <code class="codeph">SYSDBA</code> privilege.</span></li>
                        <li class="stepexpand"><span>Perform Steps 1 through 3 described in <a href="user-managed-flashback-dbpitr.html#GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" title="The SQL*Plus FLASHBACK DATABASE command performs the same function as the RMAN FLASHBACK DATABASE command: it returns the database to a prior state.">Performing Flashback Database of non-CDBs with SQL*Plus</a>.</span></li>
                        <li class="stepexpand"><span>Run the <code class="codeph">FLASHBACK DATABASE</code> command to return the CDB to a prior timestamp, SCN, or restore point.</span><div>
                              <p>The following are some examples of flashback operations of CDBs:</p><pre class="pre codeblock"><code>FLASHBACK DATABASE TO RESTORE POINT cdb_grp;
FLASHBACK DATABASE TO SCN 34468;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>Perform Steps 5 and 6 described in <a href="user-managed-flashback-dbpitr.html#GUID-56FD20D8-0BC2-45F2-BD98-683210ABD413" title="The SQL*Plus FLASHBACK DATABASE command performs the same function as the RMAN FLASHBACK DATABASE command: it returns the database to a prior state.">Performing Flashback Database of non-CDBs with SQL*Plus</a>.</span></li>
                        <li class="stepexpand"><span>Since the pluggable databases (PDBs) are not automatically opened when the CDB is opened, open the PDBs.</span><div>
                              <p>The following command, when connected to the root, opens all the PDBs:</p><pre class="pre codeblock"><code>ALTER PLUGGABLE DATABASE ALL OPEN;</code></pre></div>
                           <div>
                              <p>If you want to open only some PDBs, then you can open each PDB separately. The following command, when connected to the root, opens the PDB <code class="codeph">my_pdb</code>.
                              </p><pre class="pre codeblock"><code>ALTER PLUGGABLE DATABASE my_pdb OPEN;</code></pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-AFD27980-CCDC-4062-905A-7571DC0C0C4C__GUID-3CD2A715-2C08-46F9-9192-D031DB85E85F">
                           <p class="notep1">See Also:</p>
                           <p><a href="rman-performing-flashback-dbpitr.html#GUID-5463669A-DC89-4FF4-ACCE-136A72DF687B" title="This overview describes the purpose and basic concepts of Oracle Flashback Technology and database point-in-time recovery.Certain situations are suited for using point-in-time recovery or flashback features to return the database or database object to its state at a previous point in time.Database point-in-time recovery (DBPITR) and Flashback features enable you to recover your database to a prior point in time.DBPITR works at the physical level to return the data files to their state at a target time in the past.RMAN provides support for point-in-time recovery for one or more PDBs. To recover PDBs, you must connect to the root as a user with SYSDBA or SYSBACKUP privilege. After recovery, old backups of the PDB remain valid and can be used if a media failure occurs.The flashback features of the Oracle Database are more efficient than media recovery in most circumstances in which they are available. You can use them to investigate past states of the database.Oracle Flashback Database is the most efficient alternative to DBPITR.Logical flashback features are used to recover tables and their contents to a past time.You can perform a Flashback Database operation for a whole multitenant container database (CDB) or for a particular pluggable database (PDB). A multitenant container database (CDB) can use shared undo or local undo. The technique used by RMAN to perform flashback database operations depends on the type of undo configuration for the CDB.RMAN provides methods to manage redo corruption to data blocks in a PDB.Flashback Table uses information in the undo tablespace rather than restored backups to retrieve the table. When a Flashback Table operation occurs, new rows are deleted and old rows are reinserted. The rest of your database remains available while the flashback of the table is being performed.To perform a Flashback Table operation, the table must be eligible to be flashed back and the user performing the operation must have the required privileges.To use the Flashback Table feature on one or more tables, use the FLASHBACK TABLE SQL statement with a target time or SCN.By default, the database disables triggers on the affected table before performing a FLASHBACK TABLE operation. After the operation, the database returns the triggers to the state they were in before the operation (enabled or disabled). You can retrieve objects from the recycle bin with the FLASHBACK TABLE ... TO BEFORE DROP statement.Flashback Drop reverses the effects of a DROP TABLE operation. Flashback Drop is faster than other recovery mechanisms that can be used in this situation, such as point-in-time recovery, and does not lead to downtime or loss of recent transactions.Prerequisites must be met before you perform a Flashback Drop operation.Use the FLASHBACK TABLE ... TO BEFORE DROP statement to recover objects from the recycle bin. You can specify either the name of the table in the recycle bin or the original table name.You can create, and then drop, several objects with the same original name. All dropped objects are stored in the recycle bin.Flashback Database reverses unwanted changes by returning your database to its state at a previous point in time.Flashback Database works by undoing changes to the data files that exist at the moment that you run the command. Prerequisites must be met to perform a Flashback Database operation.A Flashback Database operation uses the FLASHBACK DATABASE command to rewind the database to a past point in time.You can perform a flashback database operation for a whole multitenant container database (CDB) using the FLASHBACK DATABASE command.You can perform a flashback database operation for a single pluggable database (PDB) in a multitenant container database (CDB) using the FLASHBACK DATABASE command.Data dictionary views contain information that is used to monitor flashback database.RMAN DBPITR restores the database from backups before the target time for recovery, then uses incremental backups and redo to roll the database forward to the target time. You can recover to an SCN, time, log sequence number, or restore point. Oracle recommends that you create restore points at important times to make point-in-time recovery more manageable if it ever becomes necessary.Certain prerequisites must be met to perform database point-in-time recovery (DBPITR).Use the RESTORE and RECOVER commands to perform DBPITR.Use the RECOVER command to perform point-in-time recovery (PITR) of container databases (CDBs) and pluggable databases (PDBs). PITR of PDBs can only be performed using RMAN.Use the RESTORE and RECOVER commands to perform point-in-time recovery for a whole CDB.When you recover one or more PDBs to a specified point-in-time, the remaining PDBs in the CDB are not affected and they can be open and operational. Use the RESTORE and RECOVER commands to perform point-in-time recovery of an application PDB.Performing point-in-time recovery of sparse databases is similar to performing point-in-time recovery of normal databases. This section describes variations of the basic Flashback Database and DBPITR scenarios.Flashback Database can be used to undo an OPEN RESETLOGS operation.Flashback Database across OPEN RESETLOGS may be used to perform multiple functions in a Data Guard environment.You can use Flashback Database to rewind a database to an abandoned database incarnation.To perform DPITR to an noncurrent database incarnation, you must explicitly execute the RESET DATABASE to reset the database to the incarnation that was current at the target SCN. You must also restore a control file from the database incarnation containing the target SCN."> Performing Flashback and Database Point-in-Time Recovery</a> for details about how the Flashback Database feature works, requirements for using Flashback Database, and how to enable the collection of flashback logs required for Flashback Database
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44" name="GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44"></a><h4 id="BRADV-GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44" class="sect4"><span class="enumeration_section">30.1.3 </span>Performing Flashback Database of PDBs with SQL*Plus
                  </h4>
                  <div>
                     <p>Use the SQL*Plus <code class="codeph">FLASHBACK</code> <code class="codeph">DATABASE</code> command to return a specific pluggable database (PDB) to a prior state. The remaining PDBs in the multitenant container database (CDB) are not impacted by the flashback operation on a single PDB.
                     </p>
                     <div class="section">The SQL*Plus <code class="codeph">FLASHBACK DATABASE</code> command performs the same function as the RMAN <code class="codeph">FLASHBACK DATABASE</code> command.
                     </div>
                     <!-- class="section" -->
                     <div class="p">The prerequistes for performing a flashback database operation are described in <a href="using-flasback-database-restore-points.html#GUID-AE2AD6A0-507A-4E40-A8FF-76AFC88EC56D" title="To ensure successful operation of Flashback Database and guaranteed restore points, you must first set some key database options.">Prerequisites for Flashback Database and Restore Points</a>.
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><span class="bold">To perform a flashback of a PDB using SQL*Plus:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Connect SQL*PLus to the root as a common user with the <code class="codeph">SYSDBA</code> privilege.</span></li>
                        <li class="stepexpand"><span>Ensure that the CDB is open.</span><div>
                              <p>The following command, when connected to the root, displays the mode in which the CDB is open.</p><pre class="pre codeblock"><code>SELECT open_mode from V$DATABASE;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>Determine the desired SCN, restore point, or point in time for the <code class="codeph">FLASHBACK DATABASE</code> command.</span><div>Query the <code class="codeph">V$RESTORE_POINT</code> view to obtain the list of PDB restore points. <code class="codeph">V$FLASHBACK_DATABASE_LOG</code> displays the oldest SCN to which a flashback operation can be performed.
                           </div>
                        </li>
                        <li class="stepexpand"><span>Ensure that the PDB for which the Flashback Database operation must be performed is closed. Other PDBs can be open and operational.</span><div>
                              <p>When connected to the root, the following <code class="codeph">ALTER PLUGGABLE DATABASE</code> command closes the PDB <code class="codeph">my_pdb</code>.
                              </p><pre class="pre codeblock"><code>ALTER PLUGGABLE DATABASE my_pdb CLOSE;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>Perform a Flashback Database operation on the specified PDB to the desired point in time.</span><div>
                              <p>The following are some examples of flashback database operations on PDBs.</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>For a PDB that uses local undo:</p><pre class="pre codeblock"><code>FLASHBACK PLUGGABLE DATABASE my_pdb TO SCN 24368;
FLASHBACK PLUGGABLE DATABASE my_pdb TO RESTORE POINT guar_rp;</code></pre></li>
                                 <li>
                                    <p>For a PDB that uses shared undo, you can only use SQL*Plus to perform a flashback operation if you are flashing back the PDB to a clean PDB restore point. For example: </p><pre class="pre codeblock"><code>FLASHBACK PLUGGABLE DATABASE my_pdb TO RESTORE POINT before_appl_changes;
</code></pre></li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Open the PDB with <code class="codeph">RESETLOGS</code>.</span><div>
                              <p>The following command opens the PDB named <code class="codeph">my_pdb</code> with <code class="codeph">RESETLOGS</code>:
                              </p><pre class="pre codeblock"><code>ALTER PLUGGABLE DATABASE my_pdb OPEN RESETLOGS;</code></pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p></p>
                        <div class="infoboxnote" id="GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44__GUID-FF365CC5-6DB2-4DD0-A5E7-4591B556C383">
                           <p class="notep1">Note:</p>
                           <p>Flashback operations on a proxy PDB are not supported.</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-1FF9318A-39BF-4DCE-AF7D-570376608D44__GUID-226E014E-8AF9-4FF4-AC55-57A6AD789758">
                           <p class="notep1">See Also:</p>
                           <p><a href="rman-performing-flashback-dbpitr.html#GUID-5463669A-DC89-4FF4-ACCE-136A72DF687B" title="This overview describes the purpose and basic concepts of Oracle Flashback Technology and database point-in-time recovery.Certain situations are suited for using point-in-time recovery or flashback features to return the database or database object to its state at a previous point in time.Database point-in-time recovery (DBPITR) and Flashback features enable you to recover your database to a prior point in time.DBPITR works at the physical level to return the data files to their state at a target time in the past.RMAN provides support for point-in-time recovery for one or more PDBs. To recover PDBs, you must connect to the root as a user with SYSDBA or SYSBACKUP privilege. After recovery, old backups of the PDB remain valid and can be used if a media failure occurs.The flashback features of the Oracle Database are more efficient than media recovery in most circumstances in which they are available. You can use them to investigate past states of the database.Oracle Flashback Database is the most efficient alternative to DBPITR.Logical flashback features are used to recover tables and their contents to a past time.You can perform a Flashback Database operation for a whole multitenant container database (CDB) or for a particular pluggable database (PDB). A multitenant container database (CDB) can use shared undo or local undo. The technique used by RMAN to perform flashback database operations depends on the type of undo configuration for the CDB.RMAN provides methods to manage redo corruption to data blocks in a PDB.Flashback Table uses information in the undo tablespace rather than restored backups to retrieve the table. When a Flashback Table operation occurs, new rows are deleted and old rows are reinserted. The rest of your database remains available while the flashback of the table is being performed.To perform a Flashback Table operation, the table must be eligible to be flashed back and the user performing the operation must have the required privileges.To use the Flashback Table feature on one or more tables, use the FLASHBACK TABLE SQL statement with a target time or SCN.By default, the database disables triggers on the affected table before performing a FLASHBACK TABLE operation. After the operation, the database returns the triggers to the state they were in before the operation (enabled or disabled). You can retrieve objects from the recycle bin with the FLASHBACK TABLE ... TO BEFORE DROP statement.Flashback Drop reverses the effects of a DROP TABLE operation. Flashback Drop is faster than other recovery mechanisms that can be used in this situation, such as point-in-time recovery, and does not lead to downtime or loss of recent transactions.Prerequisites must be met before you perform a Flashback Drop operation.Use the FLASHBACK TABLE ... TO BEFORE DROP statement to recover objects from the recycle bin. You can specify either the name of the table in the recycle bin or the original table name.You can create, and then drop, several objects with the same original name. All dropped objects are stored in the recycle bin.Flashback Database reverses unwanted changes by returning your database to its state at a previous point in time.Flashback Database works by undoing changes to the data files that exist at the moment that you run the command. Prerequisites must be met to perform a Flashback Database operation.A Flashback Database operation uses the FLASHBACK DATABASE command to rewind the database to a past point in time.You can perform a flashback database operation for a whole multitenant container database (CDB) using the FLASHBACK DATABASE command.You can perform a flashback database operation for a single pluggable database (PDB) in a multitenant container database (CDB) using the FLASHBACK DATABASE command.Data dictionary views contain information that is used to monitor flashback database.RMAN DBPITR restores the database from backups before the target time for recovery, then uses incremental backups and redo to roll the database forward to the target time. You can recover to an SCN, time, log sequence number, or restore point. Oracle recommends that you create restore points at important times to make point-in-time recovery more manageable if it ever becomes necessary.Certain prerequisites must be met to perform database point-in-time recovery (DBPITR).Use the RESTORE and RECOVER commands to perform DBPITR.Use the RECOVER command to perform point-in-time recovery (PITR) of container databases (CDBs) and pluggable databases (PDBs). PITR of PDBs can only be performed using RMAN.Use the RESTORE and RECOVER commands to perform point-in-time recovery for a whole CDB.When you recover one or more PDBs to a specified point-in-time, the remaining PDBs in the CDB are not affected and they can be open and operational. Use the RESTORE and RECOVER commands to perform point-in-time recovery of an application PDB.Performing point-in-time recovery of sparse databases is similar to performing point-in-time recovery of normal databases. This section describes variations of the basic Flashback Database and DBPITR scenarios.Flashback Database can be used to undo an OPEN RESETLOGS operation.Flashback Database across OPEN RESETLOGS may be used to perform multiple functions in a Data Guard environment.You can use Flashback Database to rewind a database to an abandoned database incarnation.To perform DPITR to an noncurrent database incarnation, you must explicitly execute the RESET DATABASE to reset the database to the incarnation that was current at the target SCN. You must also restore a control file from the database incarnation containing the target SCN."> Performing Flashback and Database Point-in-Time Recovery</a> for details about how the Flashback Database feature works, requirements for using Flashback Database, and how to enable the collection of flashback logs required for Flashback Database
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="BRADV215"></a><div class="props_rev_3"><a id="GUID-4F81CE72-B1B3-4444-B7E9-7DC97C65836B" name="GUID-4F81CE72-B1B3-4444-B7E9-7DC97C65836B"></a><h3 id="BRADV-GUID-4F81CE72-B1B3-4444-B7E9-7DC97C65836B" class="sect3"><span class="enumeration_section">30.2 </span>Overview of User-Managed Media Recovery
               </h3>
               <div>
                  <p>This section provides an overview of recovery with SQL*Plus. This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833">About User-Managed Restore and Recovery</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-54B59888-8683-4CD9-B144-B0BB68887572">Automatic Recovery with the RECOVER Command</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-E7F2B57F-3731-4BC1-9E4D-AC4A99A1C2D2" title="No additional setup is required to perform recovery when the archived redo log files are present in the default location.">Recovery When Archived Logs Are in the Default Location</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-F66C6B19-0960-4231-92C1-400C625F66D7" title="To perform media recovery when archived redo log files are stored in a nondefault location, you must specify the location of archived redo log files.">Recovery When Archived Logs Are in a Nondefault Location</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B">Recovery Using Storage Snapshot Optimization</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-8EC901EA-2281-49EF-89ED-D0595E46DFCB">Recovery Cancellation</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-9174945F-96FA-477F-AEC2-046A3FE5ACAA">Parallel Media Recovery</a></p>
                     </li>
                  </ul>
               </div><a id="BRADV502"></a><a id="BRADV210"></a><div class="props_rev_3"><a id="GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833" name="GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833"></a><h4 id="BRADV-GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833" class="sect4"><span class="enumeration_section">30.2.1 </span>About User-Managed Restore and Recovery
                  </h4>
                  <div>
                     <p>Typically, you restore a file when a media failure or user error has damaged or deleted one or more data files. <a id="d140508e1245" class="indexterm-anchor"></a><a id="d140508e1247" class="indexterm-anchor"></a><a id="d140508e1251" class="indexterm-anchor"></a>In a user-managed restore operation, you use an operating system utility to restore a backup of the file. 
                     </p>
                     <p><a id="d140508e1257" class="indexterm-anchor"></a><a id="d140508e1263" class="indexterm-anchor"></a><a id="d140508e1267" class="indexterm-anchor"></a><a id="d140508e1273" class="indexterm-anchor"></a><a id="d140508e1277" class="indexterm-anchor"></a>If a media failure affects data files, then the recovery procedure depends on:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The archiving mode of the database: <code class="codeph">ARCHIVELOG</code> or <code class="codeph">NOARCHIVELOG</code></p>
                        </li>
                        <li>
                           <p>The type of media failure</p>
                        </li>
                        <li>
                           <p>The files affected by the media failure (data files, control files, archived redo logs, and the server parameter file are all candidates for restore operations)</p>
                        </li>
                     </ul>
                     <p>If either a permanent or temporary media failure affects any data files of a database operating in <code class="codeph">NOARCHIVELOG</code> mode, then the database automatically shuts down. If the media failure is temporary, then correct the underlying problem and restart the database. Usually, crash recovery recovers all committed transactions from the online redo log. If the media failure is permanent, then recover the database as described in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A">Recovering a Database in NOARCHIVELOG Mode</a>"</span>.
                     </p>
                     <p><a href="user-managed-flashback-dbpitr.html#GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833__CHDFCFGE" title="user-managed restore techniques">Table 30-1</a> explains the implications for media recovery when you lose files in a database that runs in <code class="codeph">ARCHIVELOG</code> mode.
                     </p>
                     <div class="tblformalwide" id="GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833__CHDFCFGE">
                        <p class="titleintable">Table 30-1 User-Managed Restore Operations</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="User-Managed Restore Operations" summary="user-managed restore techniques" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d140508e1326">If You Lose...</th>
                                 <th align="left" valign="bottom" width="71%" id="d140508e1329">Then...</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1334" headers="d140508e1326 ">
                                    <p>Data files in the <code class="codeph">SYSTEM</code> tablespace or data files with active undo segments
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1334 d140508e1329 ">
                                    <p>The database automatically shuts down. If the hardware problem is temporary, then fix it and restart the database. Usually, crash recovery recovers lost transactions. If the hardware problem is permanent, then restore the data files from backups and recover the database as described in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1352" headers="d140508e1326 ">
                                    <p>Data files not in the <code class="codeph">SYSTEM</code> tablespace or data files that do not contain active rollback or undo segments
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1352 d140508e1329 ">
                                    <p>Affected data files are taken offline, but the database stays open. If the unaffected portions of the database must remain available, then do not shut down the database. Take tablespaces containing problem data files offline using the temporary option, then recover them as described in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-56EBDCEE-0C55-4556-A732-82EF42834D58" title="You can perform complete recovery of non-SYSTEM data files in a database while the database is open.">Performing Open Database Recovery</a>"</span>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1373" headers="d140508e1326 ">
                                    <p>All copies of the current control file</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1373 d140508e1329 ">
                                    <p>You must restore a backup control file and then open the database with the <code class="codeph">RESETLOGS</code> option.
                                    </p>
                                    <p>If you do not have a backup, then you can attempt to re-create the control file. If possible, use the script included in the <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">BACKUP</code> <code class="codeph">CONTROLFILE</code> <code class="codeph">TO</code> <code class="codeph">TRACE</code> output. Additional work may be required to match the control file structure with the current database structure.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1404" headers="d140508e1326 ">
                                    <p>One copy of a multiplexed control file</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1404 d140508e1329 ">
                                    <p><a id="d140508e1409" class="indexterm-anchor"></a><a id="d140508e1413" class="indexterm-anchor"></a>Copy an intact multiplexed control file into the location of the damaged or missing control file and open the database. If you cannot copy the control file to its original location, then edit the initialization parameter file to reflect a new location or remove the damaged control file. Then, open the database.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1417" headers="d140508e1326 ">
                                    <p>One or more archived logs required for media recovery</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1417 d140508e1329 ">
                                    <p>You must restore backups of these archived logs for recovery to proceed. You can restore either to the default or nondefault location. If you do not have backups, then you must perform incomplete recovery up to an SCN before the first missing redo log and open <code class="codeph">RESETLOGS</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e1427" headers="d140508e1326 ">
                                    <p>The server parameter file (SPFILE)</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e1427 d140508e1329 ">
                                    <p>If you have a backup of the server parameter file, then restore it. Alternatively, if you have a backup of the client-side initialization parameter file, then you can restore a backup of this file, start the instance, and then re-create the server parameter file.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-D71F3FF3-84E5-4D81-9307-E2AD5CB51833__GUID-488FC76D-AC7E-4277-8077-565B9EB146D6">
                        <p class="notep1">Note:</p>
                        <p>Restore and recovery of Oracle Managed Files is no different from restore and recovery of user-named files.</p>
                     </div>
                     <p><a id="d140508e1437" class="indexterm-anchor"></a><a id="d140508e1441" class="indexterm-anchor"></a><a id="d140508e1445" class="indexterm-anchor"></a><a id="d140508e1449" class="indexterm-anchor"></a><a id="d140508e1453" class="indexterm-anchor"></a>To <a id="d140508e1458" class="indexterm-anchor"></a>perform media recovery, Oracle recommends that you use the <code class="codeph">RECOVER</code> statement in SQL*Plus. You can also use the SQL statement <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">RECOVER</code>, but the <code class="codeph">RECOVER</code> statement is often simpler. To start any type of media recovery, you must adhere to the following restrictions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You must have administrator privileges. </p>
                        </li>
                        <li>
                           <p>All recovery sessions must be compatible.</p>
                        </li>
                        <li>
                           <p>One session cannot start complete media recovery while another performs incomplete media recovery.</p>
                        </li>
                        <li>
                           <p>You cannot start media recovery if you are connected to the database through a shared server process.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="BRADV90025"></a><div class="props_rev_3"><a id="GUID-54B59888-8683-4CD9-B144-B0BB68887572" name="GUID-54B59888-8683-4CD9-B144-B0BB68887572"></a><h4 id="BRADV-GUID-54B59888-8683-4CD9-B144-B0BB68887572" class="sect4"><span class="enumeration_section">30.2.2 </span>Automatic Recovery with the RECOVER Command
                  </h4>
                  <div>
                     <div class="section">
                        <p>When using SQL*Plus to perform media recovery, the easiest strategy is to perform automatic recovery with the SQL*Plus <code class="codeph">RECOVER</code> command. Automatic recovery initiates recovery without manually prompting SQL*Plus to apply each individual archived redo log.
                        </p>
                        <p><a id="d140508e1567" class="indexterm-anchor"></a><a id="d140508e1571" class="indexterm-anchor"></a><a id="d140508e1575" class="indexterm-anchor"></a><a id="d140508e1579" class="indexterm-anchor"></a>When using SQL*Plus, you have the following options for automating the application of the default file names of archived redo logs needed during recovery:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Issuing <code class="codeph">SET</code> <code class="codeph">AUTORECOVERY</code> <code class="codeph">ON</code> before issuing the <code class="codeph">RECOVER</code> command. If you perform recovery with <code class="codeph">SET</code> <code class="codeph">AUTORECOVERY</code> <code class="codeph">OFF</code>, which is the default, then you must enter file names manually or accept the suggested file name by pressing Enter.
                              </p>
                           </li>
                           <li>
                              <p>Specifying the <code class="codeph">AUTOMATIC</code> keyword as an option of the <code class="codeph">RECOVER</code> command.
                              </p>
                           </li>
                        </ul>
                        <p>In either case, no interaction is required when you issue the <code class="codeph">RECOVER</code> command if the necessary files are in the correct locations with the correct names. When the database successfully applies a redo log file, the following message is returned:
                        </p><pre class="oac_no_warn" dir="ltr">Log applied.
</pre><p>You are then prompted for the next redo log in the sequence. If the most recently applied log is the last required log, then recovery is terminated.</p>
                        <p>The file names used for automatic recovery are derived from the concatenated values of <code class="codeph">LOG_ARCHIVE_FORMAT</code> <a id="d140508e1634" class="indexterm-anchor"></a>with <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span>, where <span class="italic"><code class="codeph">n</code></span> is the highest value among all enabled, local destinations. For example, assume that the following initialization parameter settings are in effect in the database instance:
                        </p><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_1 = "LOCATION=/arc_dest/loc1/" 
LOG_ARCHIVE_DEST_2 = "LOCATION=/arc_dest/loc2/"
LOG_ARCHIVE_DEST_STATE_1 = DEFER 
LOG_ARCHIVE_DEST_STATE_2 = ENABLE 
LOG_ARCHIVE_FORMAT = arch_%t_%s_%r.arc
</pre><p>In this example, SQL*Plus automatically suggests the file name <code class="codeph">/arc_dest/loc2/arch_%t_%s_%r.arc</code> (where <code class="codeph">%t</code> is the thread, <code class="codeph">%s</code> is the sequence and <code class="codeph">%r</code> is the resetlogs ID).
                        </p>
                        <div class="infoboxnotealso" id="GUID-54B59888-8683-4CD9-B144-B0BB68887572__GUID-6CE0F846-E4E6-44D9-B4A2-FEC51EDADA6C">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="user-managed-flashback-dbpitr.html#GUID-D32B0E81-6341-4790-BFAD-E78A63B8E8B9">Automatic Recovery with SET AUTORECOVERY</a></p>
                              </li>
                              <li>
                                 <p><a href="user-managed-flashback-dbpitr.html#GUID-68DDE32D-C6A7-43EF-A2BC-9F6287474996">Automatic Recovery with the AUTOMATIC Option of the RECOVER Command</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="BRADV90026"></a><div class="props_rev_3"><a id="GUID-D32B0E81-6341-4790-BFAD-E78A63B8E8B9" name="GUID-D32B0E81-6341-4790-BFAD-E78A63B8E8B9"></a><h5 id="BRADV-GUID-D32B0E81-6341-4790-BFAD-E78A63B8E8B9" class="sect5"><span class="enumeration_section">30.2.2.1 </span>Automatic Recovery with SET AUTORECOVERY
                     </h5>
                     <div>
                        <p>After restoring data file backups, you can run the <code class="codeph">SET</code> <code class="codeph">AUTORECOVERY</code> <code class="codeph">ON</code> command to enable automatic recovery. For example, you could enter the following commands in SQL*Plus to perform automatic recovery and open the database:
                        </p><pre class="oac_no_warn" dir="ltr">STARTUP MOUNT
SET AUTORECOVERY ON
RECOVER DATABASE
ALTER DATABASE OPEN;</pre><div class="infoboxnote" id="GUID-D32B0E81-6341-4790-BFAD-E78A63B8E8B9__GUID-294F1C5C-561C-47DA-B43B-BE127A6A629B">
                           <p class="notep1">Note:</p>
                           <p>After issuing the SQL*Plus <code class="codeph">RECOVER</code> command, you can view all files that have been considered for recovery in the <code class="codeph">V$RECOVERY_FILE_STATUS</code> view. You can access status information for each file in the <code class="codeph">V$RECOVERY_STATUS</code> view. These views are not accessible after you terminate the recovery session. 
                           </p>
                        </div>
                     </div>
                  </div><a id="BRADV90027"></a><div class="props_rev_3"><a id="GUID-68DDE32D-C6A7-43EF-A2BC-9F6287474996" name="GUID-68DDE32D-C6A7-43EF-A2BC-9F6287474996"></a><h5 id="BRADV-GUID-68DDE32D-C6A7-43EF-A2BC-9F6287474996" class="sect5"><span class="enumeration_section">30.2.2.2 </span>Automatic Recovery with the AUTOMATIC Option of the RECOVER Command
                     </h5>
                     <div>
                        <p>Besides using <code class="codeph">SET</code> <code class="codeph">AUTORECOVERY</code> to turn on automatic recovery, you can also simply specify the <code class="codeph">AUTOMATIC</code> keyword in the <code class="codeph">RECOVER</code> command. For example, you could enter the following commands in SQL*Plus to perform automatic recovery and open the database:
                        </p><pre class="oac_no_warn" dir="ltr">STARTUP MOUNT
RECOVER AUTOMATIC DATABASE
ALTER DATABASE OPEN;
</pre><p><a id="d140508e1857" class="indexterm-anchor"></a><a id="d140508e1861" class="indexterm-anchor"></a><a id="d140508e1865" class="indexterm-anchor"></a>If you use an Oracle Real Application Clusters configuration, and if you are performing incomplete recovery or using a backup control file, then the database can only compute the name of the first archived redo log file from the <span class="italic">first</span> redo thread. You may have to manually apply the first log file from the other redo threads. After the first log file in a given thread has been supplied, the database can suggest the names of the subsequent logs in this thread.
                        </p>
                     </div>
                  </div>
               </div><a id="BRADV90028"></a><div class="props_rev_3"><a id="GUID-E7F2B57F-3731-4BC1-9E4D-AC4A99A1C2D2" name="GUID-E7F2B57F-3731-4BC1-9E4D-AC4A99A1C2D2"></a><h4 id="BRADV-GUID-E7F2B57F-3731-4BC1-9E4D-AC4A99A1C2D2" class="sect4"><span class="enumeration_section">30.2.3 </span>Recovery When Archived Logs Are in the Default Location
                  </h4>
                  <div>
                     <p>No additional setup is required to perform recovery when the archived redo log files are present in the default location.</p>
                     <p>During recovery, as a log is needed, the database suggests the file name. If you run nonautomatic media recovery with SQL*Plus, then the output is displayed in the format shown by this example:</p><pre class="oac_no_warn" dir="ltr">ORA-00279: change 53577 generated at 11/26/02 19:20:58 needed for thread 1
ORA-00289: suggestion : /oracle/oradata/trgt/arch/arcr_1_802.arc
ORA-00280: change 53577 for thread 1 is in sequence #802
Specify log: [&lt;RET&gt; for suggested | AUTO | FROM logsource | CANCEL ]
</pre><p>Similar messages are returned when you use an <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">...</code> <code class="codeph">RECOVER</code> statement. However, no prompt is displayed.<span class="bold"></span></p>
                     <p>The database constructs suggested archived log file names by concatenating the current values of the initialization parameters <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> (where <span class="italic"><code class="codeph">n</code></span> is the highest value among all enabled, local destinations) and <code class="codeph">LOG_ARCHIVE_FORMAT</code> and using log history data from the control file. The following are possible settings:
                     </p><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_1 = 'LOCATION = /oracle/oradata/trgt/arch/'
LOG_ARCHIVE_FORMAT = arcr_%t_%s.arc

SELECT NAME FROM V$ARCHIVED_LOG;

NAME
----------------------------------------
/oracle/oradata/trgt/arch/arcr_1_467.arc
/oracle/oradata/trgt/arch/arcr_1_468.arc
/oracle/oradata/trgt/arch/arcr_1_469.arc
</pre><p>Thus, if all the required archived log files are present at the <code class="codeph">LOG_ARCHIVE_DEST_1</code> destination, and if the value for <code class="codeph">LOG_ARCHIVE_FORMAT</code> is never altered, then the database can suggest and apply log files to complete media recovery automatically.
                     </p>
                  </div>
               </div><a id="BRADV90029"></a><div class="props_rev_3"><a id="GUID-F66C6B19-0960-4231-92C1-400C625F66D7" name="GUID-F66C6B19-0960-4231-92C1-400C625F66D7"></a><h4 id="BRADV-GUID-F66C6B19-0960-4231-92C1-400C625F66D7" class="sect4"><span class="enumeration_section">30.2.4 </span>Recovery When Archived Logs Are in a Nondefault Location
                  </h4>
                  <div>
                     <p>To perform media recovery when archived redo log files are stored in a nondefault location, you must specify the location of archived redo log files.</p>
                     <p>You have the following mutually exclusive options when performing media recovery when archived logs are not in their default location:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Edit the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> parameter that specifies the location of the archived redo logs, then recover as usual.
                           </p>
                           <p>This task is described in <a href="user-managed-flashback-dbpitr.html#GUID-4822CA38-EC09-474B-8F72-AB6599EC17D1">Resetting the Archived Log Destination</a>.
                           </p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">SET</code> statement in SQL*Plus to specify the nondefault log location before recovery, or the <code class="codeph">LOGFILE </code>parameter of the <code class="codeph">RECOVER</code> command.
                           </p>
                           <p>This task is described in <a href="user-managed-flashback-dbpitr.html#GUID-28E902A1-D069-43BD-8730-8F85FD746FA9">Overriding the Archived Log Destination</a>.
                           </p>
                        </li>
                     </ul>
                  </div><a id="BRADV90030"></a><div class="props_rev_3"><a id="GUID-4822CA38-EC09-474B-8F72-AB6599EC17D1" name="GUID-4822CA38-EC09-474B-8F72-AB6599EC17D1"></a><h5 id="BRADV-GUID-4822CA38-EC09-474B-8F72-AB6599EC17D1" class="sect5"><span class="enumeration_section">30.2.4.1 </span>Resetting the Archived Log Destination
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d140508e2198" class="indexterm-anchor"></a><a id="d140508e2202" class="indexterm-anchor"></a>You can edit the initialization parameter file or issue <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> statements to change the default location of the archived redo logs.
                           </p>
                           <p><span class="bold">To change the default archived log location before recovery:</span></p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Use an operating system utility to restore the archived logs to a nondefault location. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">% cp /backup/arch/* /tmp/
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Change the value for the archive log parameter to the nondefault location. You can issue <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> statements while the instance is started, or edit the initialization parameter file and then start the database instance. For example, while the instance is shut down edit the parameter file as follows:</span><div><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_1 = 'LOCATION=/tmp/'
LOG_ARCHIVE_FORMAT = arcr_%t_%s.arc
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Using SQL*Plus, start a new instance by specifying the edited initialization parameter file, and then mount the database. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">STARTUP MOUNT
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Begin media recovery as usual. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="BRADV90031"></a><div class="props_rev_3"><a id="GUID-28E902A1-D069-43BD-8730-8F85FD746FA9" name="GUID-28E902A1-D069-43BD-8730-8F85FD746FA9"></a><h5 id="BRADV-GUID-28E902A1-D069-43BD-8730-8F85FD746FA9" class="sect5"><span class="enumeration_section">30.2.4.2 </span>Overriding the Archived Log Destination
                     </h5>
                     <div>
                        <div class="section">
                           <p>In some cases, you may want to override the current setting for the archiving destination parameter as a source for archived log files. </p>
                           <p><span class="bold">To recover archived logs in a nondefault location with SET LOGSOURCE:</span></p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span><a id="d140508e2327" class="indexterm-anchor"></a><a id="d140508e2331" class="indexterm-anchor"></a>Using an operating system utility, copy the archived redo logs to an alternative location. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">% cp $ORACLE_HOME/oradata/trgt/arch/* /tmp
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Specify the alternative location within SQL*Plus for the recovery operation. Use the<a id="d140508e2342" class="indexterm-anchor"></a><a id="d140508e2346" class="indexterm-anchor"></a><a id="d140508e2350" class="indexterm-anchor"></a><a id="d140508e2354" class="indexterm-anchor"></a><a id="d140508e2358" class="indexterm-anchor"></a><a id="d140508e2362" class="indexterm-anchor"></a> <code class="codeph">LOGSOURCE</code> parameter of the <code class="codeph">SET</code> statement. For example, start SQL*Plus and run:</span><div><pre class="oac_no_warn" dir="ltr">SET LOGSOURCE "/tmp"
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Recover the offline tablespace. For example, to recover the offline tablespace <code class="codeph">users</code> do the following:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC TABLESPACE users
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Alternatively, you can avoid running <code class="codeph">SET</code> <code class="codeph">LOGSOURCE</code> and simply run:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC TABLESPACE users FROM "/tmp"</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-28E902A1-D069-43BD-8730-8F85FD746FA9__GUID-D2F9FB73-7228-45F6-8DFA-FF48D73A9C84">
                              <p class="notep1">Note:</p>
                              <p>Overriding the redo log source does not affect the archive redo log destination for online redo log groups being archived.</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="BRADV816"></a><a id="BRADV817"></a><a id="BRADV727"></a><div class="props_rev_3"><a id="GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B" name="GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B"></a><h4 id="BRADV-GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B" class="sect4"><span class="enumeration_section">30.2.5 </span>Recovery Using Storage Snapshot Optimization
                  </h4>
                  <div>
                     <p>Storage Snapshot Optimization enables you to use third-party snapshots of the database, taken when the database is not in backup mode, to recover the database either to the current time or to a specified point in time after the snapshot was created. If the database was not placed in backup mode when the storage snapshot was created, then you can perform recovery using this snapshot only if the snapshot conforms to Oracle requirements. See <span class="q">"<a href="user-managed-database-backups.html#GUID-A1112F2C-D0ED-4C2F-BA24-A614F99F0FCA">Making Backups with Third-Party Snapshot Technologies</a>"</span>. If these conditions are met, then you can take the same basic recovery steps as any other backup method, using either RMAN or SQL*Plus.
                     </p>
                     <p>If the storage snapshot does not conform to the requirements for using Storage Snapshot Optimization, then you create a snapshot by placing the data files in backup mode. To perform recovery using such snapshots, use the procedure described in <a href="user-managed-flashback-dbpitr.html#GUID-66D07694-533F-4E3A-BA83-DD461B68DB56" title="Typically, you perform complete recovery of the database when a media failure has made one or more data files inaccessible. During complete database recovery, you use all available redo to recover the database to the current SCN.">Performing Complete Database Recovery Using SQL*Plus</a> or <a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" title="Incomplete recovery is also known as database point-in-time recovery.">Performing Incomplete Database Recovery</a>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B__GUID-69C30CCB-1A10-4F37-AEEE-E08BC0FFAD25">Specifying the Time for Snapshot Recovery</p>
                     </div>
                     <!-- class="section" -->
                     <p>If a storage snapshot was created when the database was not in backup mode, you must specify the <code class="codeph">SNAPSHOT TIME</code> option while using this snapshot to recover the database. The <code class="codeph">SNAPSHOT TIME</code> option can be used in both the RMAN or SQL*Plus <code class="codeph">RECOVER</code> command. The time specified using the <code class="codeph">SNAPSHOT TIME</code> option must be a time that is immediately after the snapshot is complete. If you specify an incorrect time, then the database may be corrupt in a way that is not repairable.
                     </p>
                     <p>Because the time clocks in the storage array, where the snapshot takes place, and the machine hosting the Oracle Database may not be perfectly synchronized, it is recommended that you add a few seconds to the time that you specify in the <code class="codeph">SNAPSHOT TIME</code> option. This helps you avoid any possibility of leaving the files in an inconsistent state by recovering to a point before the snapshot was taken.
                     </p>
                     <p>All times specified in the <code class="codeph">RECOVER</code> command, including in the <code class="codeph">SNAPSHOT TIME</code> clause, are assumed to be in the time zone of the Oracle Database host. However, the time clocks in the storage array may be in a different time zone from the Oracle Database host. If the storage array reports its snapshot times in a different time zone, then you must take that difference into account when specifying the time in the <code class="codeph">SNAPSHOT TIME</code> option.
                     </p>
                     <div class="infoboxnote" id="GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B__GUID-0A3A9BAE-5721-40FC-A70E-49FE4C358B3B">
                        <p class="notep1">Note:</p>
                        <p>The recovery point, specified by the <code class="codeph">UNTIL</code> option, cannot be earlier than the specified <code class="codeph">SNAPSHOT TIME</code>.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-5A3BB8EE-291F-41C6-976C-1F304069FF0B__GUID-061FF938-0246-445E-A5DC-8A614546A9CD">Examples: Recovery Using Storage Snapshots</p>
                     </div>
                     <!-- class="section" -->
                     <p>The examples in this section use the <code class="codeph">RECOVER DATABASE</code> command to perform recovery using snapshots. You can use the <code class="codeph">RECOVER DATABASE</code> command from RMAN or SQL*Plus. However, the <code class="codeph">UNTIL CANCEL</code> clause is valid only in SQL*Plus.
                     </p>
                     <p><span class="bold">To completely recover a database:</span></p><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE;
</pre><p><span class="bold">To recover a database using a particular snapshot:</span></p>
                     <p>This example recovers uses a snapshot taken on August 15 at 2:00 P.M. to recover the database. The <code class="codeph">UNTIL TIME</code> clause can specify any time after the snapshot. 
                     </p><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL TIME '10/15/2012 15:00:00' SNAPSHOT TIME '10/15/2012 14:00:00';
</pre><p><span class="bold">To perform a partial recovery using archived redo log files:</span></p>
                     <p>This example uses the log files from a snapshot taken on August 15 at 2:00 P.M. </p><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL CANCEL SNAPSHOT TIME '10/15/2012 14:00:00';
</pre></div>
               </div><a id="BRADV99983"></a><div class="props_rev_3"><a id="GUID-8EC901EA-2281-49EF-89ED-D0595E46DFCB" name="GUID-8EC901EA-2281-49EF-89ED-D0595E46DFCB"></a><h4 id="BRADV-GUID-8EC901EA-2281-49EF-89ED-D0595E46DFCB" class="sect4"><span class="enumeration_section">30.2.6 </span>Recovery Cancellation During User-Managed Recovery
                  </h4>
                  <div>
                     <p>If you start media recovery and must then interrupt it, then either enter <code class="codeph">CANCEL</code> when prompted for a redo log file, or use your operating system's interrupt signal if you must terminate when recovering an individual data file, or when automated recovery is in progress. After recovery is canceled, you can resume it later with the <code class="codeph">RECOVER</code> command. Recovery resumes where it left off when it was canceled.
                     </p>
                  </div>
               </div><a id="BRADV221"></a><div class="props_rev_3"><a id="GUID-9174945F-96FA-477F-AEC2-046A3FE5ACAA" name="GUID-9174945F-96FA-477F-AEC2-046A3FE5ACAA"></a><h4 id="BRADV-GUID-9174945F-96FA-477F-AEC2-046A3FE5ACAA" class="sect4"><span class="enumeration_section">30.2.7 </span>Parallel Media Recovery
                  </h4>
                  <div>
                     <p>By default, Oracle Database uses <strong class="term">parallel media recovery</strong> to improve performance of the roll forward phase of media recovery. In parallel recovery of media, the database uses a "division of labor" approach to allocate different processes to different data blocks while rolling forward, thereby making the procedure more efficient. The number of processes used is derived from the <code class="codeph">CPU_COUNT</code> initialization parameter, which by default equals the number of CPUs on the system. For example, if parallel recovery is performed on a system where <code class="codeph">CPU_COUNT</code> is <code class="codeph">4</code>, and only one data file is recovered, then four spawned processes read blocks from the archive logs and apply redo.
                     </p>
                     <p>Typically, media recovery is limited by data block reads and writes. Parallel recovery attempts to use all of the available I/O bandwidth of the system to improve performance. Unless there is a system I/O bottleneck or poor asynchronous I/O support, parallel recovery is likely to improve performance of recovery.</p>
                     <p>To override the default behavior of performing parallel recovery, use the SQL*Plus <code class="codeph">RECOVER</code> command with the <code class="codeph">NOPARALLEL</code> option, or <code class="codeph">RECOVER</code> <code class="codeph">PARALLEL</code> <code class="codeph">0</code>. The <code class="codeph">RECOVERY_PARALLELISM</code> initialization parameter controls instance or crash recovery <span class="italic">only</span>. Media recovery is not affected by the value used for <code class="codeph">RECOVERY_PARALLELISM</code>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-9174945F-96FA-477F-AEC2-046A3FE5ACAA__GUID-C7FA49CA-87BA-4185-BB69-8CDCB3BCC937">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqpug/RECOVER.html#SQPUG053" target="_blank"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for more information about the SQL*Plus <code class="codeph">RECOVER</code> <code class="codeph">...</code> <code class="codeph">PARALLEL</code> and <code class="codeph">NOPARALLEL</code> commands
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="BRADV216"></a><div class="props_rev_3"><a id="GUID-66D07694-533F-4E3A-BA83-DD461B68DB56" name="GUID-66D07694-533F-4E3A-BA83-DD461B68DB56"></a><h3 id="BRADV-GUID-66D07694-533F-4E3A-BA83-DD461B68DB56" class="sect3"><span class="enumeration_section">30.3 </span>Performing Complete Database Recovery Using SQL*Plus
               </h3>
               <div>
                  <p>Typically, you perform complete recovery of the database when a media failure has made one or more data files inaccessible. During complete database recovery, you use all available redo to recover the database to the current SCN. </p>
                  <p>The <code class="codeph">V$RECOVER_FILE</code> view indicates which files need recovery. Depending on the circumstances, you can either recover the whole database or recover individual tablespaces or data files. Because you do not have to open the database with the <code class="codeph">RESETLOGS</code> option after complete recovery, you have the option of recovering some data files at one time and the remaining data files later.
                  </p>
                  <p>The topics in this section describe the steps necessary to complete media recovery operations.</p>
                  <div class="infoboxnotealso" id="GUID-66D07694-533F-4E3A-BA83-DD461B68DB56__GUID-D22FF53C-5B88-4327-A38F-A2CBB2E3D0C4">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a></p>
                        </li>
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-56EBDCEE-0C55-4556-A732-82EF42834D58" title="You can perform complete recovery of non-SYSTEM data files in a database while the database is open.">Performing Open Database Recovery</a></p>
                        </li>
                        <li>
                           <p><a href="user-managed-flashback-dbpitr.html#GUID-68CD62A9-F56E-4617-A010-F632708AECC3" title="Oracle Database performs crash and instance recovery for the entire multitenant container database (CDB). You cannot recover individual pluggable databases (PDBs).">Performing Crash and Instance Recovery of CDBs</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="BRADV90032"></a><div class="props_rev_3"><a id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" name="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8"></a><h4 id="BRADV-GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" class="sect4"><span class="enumeration_section">30.3.1 </span>Performing Closed Database Recovery
                  </h4>
                  <div>
                     <p>When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.</p>
                     <div class="p">
                        <p>This procedure assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The current control file is available. </p>
                           </li>
                           <li>
                              <p>You have backups of all needed data files. </p>
                           </li>
                           <li>
                              <p>All necessary archived redo logs are available. </p>
                           </li>
                        </ul>
                        <p><span class="bold">To restore and recover damaged or missing data files:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDJEDGI"><span>If the database is open, query <code class="codeph">V$RECOVER_FILE</code> to determine which data files must be recovered and why they must be recovered.</span><div>
                              <p>If you are planning to perform complete recovery rather than point-in-time recovery, then you can recover only those data files that require recovery, rather than the whole database. For point-in-time recovery, you must restore and recover all data files, unless you perform RMAN TSPITR. You can also use Flashback Database, but this procedure affects all data files and returns the entire database to a past time.</p>
                              <p>You can query the <code class="codeph">V$RECOVER_FILE</code> view to list data files requiring recovery by data file number with their status and error information. 
                              </p><pre class="oac_no_warn" dir="ltr">SELECT FILE#, ERROR, ONLINE_STATUS, CHANGE#, TIME 
FROM V$RECOVER_FILE;
</pre><div class="infoboxnote" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__GUID-D54004A0-C25F-4F3B-AAB8-50F6A1F0927B">
                                 <p class="notep1">Note:</p>
                                 <p>You cannot use <code class="codeph">V$RECOVER_FILE</code> with a control file restored from backup or a control file that was re-created after the time of the media failure affecting the data files. A restored or re-created control file does not contain the information needed to update <code class="codeph">V$RECOVER_FILE</code> accurately.
                                 </p>
                              </div>
                              <p>You can also perform useful joins by using the data file number and the <code class="codeph">V$DATAFILE</code> and <code class="codeph">V$TABLESPACE</code> views to get the data file and tablespace names. 
                              </p>
                              <p>The <code class="codeph">ERROR</code> column identifies the problem for each file requiring recovery.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Query the <code class="codeph">V$ARCHIVED_LOG</code> and <code class="codeph">V$RECOVERY_LOG</code> views to determine which archived redo log files are needed.</span><div>
                              <p><code class="codeph">V$ARCHIVED_LOG</code> lists file names for all archived redo logs, whereas <code class="codeph">V$RECOVERY_LOG</code> lists only the archived redo logs that the database needs to perform media recovery. The latter view also includes the probable names of the files based on the naming convention specified by using the <code class="codeph">LOG_ARCHIVE_FORMAT</code> parameter.
                              </p>
                              <div class="infoboxnote" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__GUID-F41AA6CB-E67A-4DAB-93CF-0E88F00C0F66">
                                 <p class="notep1">Note:</p>
                                 <p><code class="codeph">V$RECOVERY_LOG</code> is only populated when media recovery is required for a data file. Thus, this view is not useful for a planned recovery, such as recovery from a user error.
                                 </p>
                                 <p>If a data file requires recovery, but no backup of the data file exists, then you need all redo generated starting from the time when the data file was added to the database.</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDGADJF"><span>If all archived logs are available in the default location, then skip to the Step 4. </span><div>
                              <p>If some archived logs must be restored, and if sufficient space is available, then restore the required archived redo log files to the location specified by <code class="codeph">LOG_ARCHIVE_DEST_1</code>. The database locates the correct log automatically when required during media recovery. For example, you might enter a command such as the following on Linux or UNIX:
                              </p><pre class="oac_no_warn" dir="ltr">% cp /disk2/arch/* $ORACLE_HOME/oradata/trgt/arch
</pre><p>If sufficient space is not available, then restore some or all of the required archived redo log files to an alternative location.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>If the database is open, then shut it down. For example:</span><div><pre class="oac_no_warn" dir="ltr">SHUTDOWN IMMEDIATE
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Inspect the media to determine the source of the problem.</span><div>
                              <p>If the hardware problem that caused the media failure was temporary, and if the data was undamaged (for example, a disk or controller power failure occurred), then no media recovery is required: start the database and resume normal operations.</p>
                              <p>If you cannot repair the problem, then proceed to the Step 6.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>If the files are permanently damaged, then identify the most recent backups for the damaged files. Restore <span class="italic">only</span> the data files damaged by the media failure: do not restore undamaged data files or any online redo log files.</span><div>
                              <p>For example, if <span class="italic"><code class="codeph">ORACLE_HOME/</code></span><code class="codeph">oradata/trgt/users01.dbf</code> is the only damaged file, then you may find that <code class="codeph">/backup/users01_10_24_02.dbf</code> is the most recent backup of this file. If you do not have a backup of a specific data file, then you may be able to create an empty replacement file that can be recovered.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Use an operating system utility to restore the data files to their default location or to a new location. For example, a Linux or UNIX user restoring <code class="codeph">users01.dbf </code>to its default location might enter:</span><div><pre class="oac_no_warn" dir="ltr">% cp /backup/users01_10_24_06.dbf $ORACLE_HOME/oradata/trgt/users01.dbf
</pre><p>Use the following guidelines when determining where to restore data file backups:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the hardware problem is repaired and you can restore the data files to their default locations, then restore the data files to their default locations and begin media recovery.</p>
                                 </li>
                                 <li>
                                    <p>If the hardware problem persists and you cannot restore data files to their original locations, then restore the data files to an alternative storage device. Indicate the new location of these files in the control file with the <code class="codeph">ALTER DATABASE RENAME FILE</code> statement. See<a href="../admin/managing-data-files-and-temp-files.html#ADMIN11430" target="_blank"><span class="italic"> Oracle Database Administrator's Guide</span></a>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If you are restoring a data file to a raw disk or partition, then the technique is basically the same as when you are restoring to a file on a file system. Be aware of the naming conventions for files on raw devices (which differ depending on the operating system), and use an operating system utility that supports raw devices.</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDGACIB"><span>Connect to the database with administrator privileges. Then start a new instance and mount, but do not open, the database. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">STARTUP MOUNT
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If you restored one or more damaged data files to alternative locations, then update the control file of the database to reflect the new data file names. For example, to change the file name of the data file in tablespace <code class="codeph">users</code> you might enter:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE RENAME FILE '?/oradata/trgt/users01.dbf' TO
                           '/disk2/users01.dbf';
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Obtain the data file names and statuses of all data files by checking the list of data files that normally accompanies the current control file or by querying the <code class="codeph">V$DATAFILE</code> view. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">SELECT NAME,STATUS FROM V$DATAFILE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Ensure that all data files requiring recovery are online. The only exceptions are data files in an offline tablespace that was taken offline normally or data files in a read-only tablespace. For example, to guarantee that a data file named <code class="codeph">/oracle/dbs/tbs_10.f</code> is online, enter the following:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE DATAFILE '/oracle/dbs/tbs_10.f' ONLINE;
</pre><p>If a specified data file is already online, then the database ignores the statement. If you prefer, create a script to bring all data files online simultaneously, as in the following example:</p><pre class="oac_no_warn" dir="ltr">SPOOL onlineall.sql
SELECT 'ALTER DATABASE DATAFILE '''||name||''' ONLINE;' FROM V$DATAFILE;
SPOOL OFF

SQL&gt; @onlineall
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If you restored archived redo logs to an alternative location, then you can specify the location before media recovery with the <code class="codeph">LOGSOURCE</code> parameter of the <code class="codeph">SET</code> command in SQL*Plus. For example, if the logs are staged in <code class="codeph">/tmp</code>, you can enter the following command:</span><div><pre class="oac_no_warn" dir="ltr">SET LOGSOURCE /tmp
</pre><p>Alternatively, you can skip Step 12 and use the <code class="codeph">FROM</code> parameter on the <code class="codeph">RECOVER</code> command as in Step 13. For example, if the logs are staged in <code class="codeph">/tmp</code>, you can enter the following command:
                              </p><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC FROM '/tmp' DATABASE</pre><div class="infoboxnote" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__GUID-8FD49360-138F-473B-B3BF-F2FCE5BEA7D1">
                                 <p class="notep1">Note:</p>
                                 <p>Overriding the redo log source does not affect the archive redo log destination for online redo log groups being archived.</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Issue a statement to recover the database, tablespace, or data file. For example, enter one of the following <code class="codeph">RECOVER</code> commands:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC DATABASE   # whole database
RECOVER AUTOMATIC TABLESPACE users   # specific tablespace
RECOVER AUTOMATIC DATAFILE '?/oradata/trgt/users01.dbf'; # specific data file
</pre><p>If you choose not to automate the application of archived redo logs, then you must accept or reject each prompted log. If you automate recovery, then the database applies the logs automatically. Recovery continues until all required archived and online redo logs have been applied to the restored data files. The database notifies you when media recovery is complete:</p><pre class="oac_no_warn" dir="ltr">Media recovery complete.
</pre><p>If no archived redo logs are required for complete media recovery, then the database applies all necessary online redo log files and terminates recovery.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>After recovery terminates, open the database for use:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE OPEN;</pre></div>
                        </li>
                        <li class="stepexpand"><span>After archived logs are applied, and after making sure that a copy of each archived log group still exists in offline storage, delete the restored copy of the archived redo log file to free disk space. For example:</span><div><pre class="oac_no_warn" dir="ltr">% rm /tmp/*.arc</pre><div class="infoboxnotealso" id="GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__GUID-063E585B-A45E-4110-9DEB-1784C04A1231">
                                 <p class="notep1">See Also:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-3913B513-ECF0-469A-A50A-A5A573C85DC0">Recovering After the Loss of All Current Control Files</a>"</span> and <span class="q">"<a href="user-managed-recovery-advanced.html#GUID-9152B9A8-308A-4871-B835-53AF7593E65D">Re-Creating a Control File</a>"</span> for information about restoring or re-creating the control file
                                       </p>
                                    </li>
                                    <li>
                                       <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-E0032019-E245-4EBD-B275-1343AA175239">Re-Creating Data Files When Backups Are Unavailable</a>"</span> for information about performing recovery when data file backups are missing
                                       </p>
                                    </li>
                                    <li>
                                       <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" title="Incomplete recovery is also known as database point-in-time recovery.">Performing Incomplete Database Recovery</a>"</span> for information about performing database point-in-time recovery when you are missing redo required to completely recover the database
                                       </p>
                                    </li>
                                    <li>
                                       <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F81CE72-B1B3-4444-B7E9-7DC97C65836B" title="No additional setup is required to perform recovery when the archived redo log files are present in the default location.To perform media recovery when archived redo log files are stored in a nondefault location, you must specify the location of archived redo log files.">Overview of User-Managed Media Recovery</a>"</span> for an overview of log application during media recovery
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="BRADV619"></a><a id="BRADV90033"></a><div class="props_rev_3"><a id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58" name="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58"></a><h4 id="BRADV-GUID-56EBDCEE-0C55-4556-A732-82EF42834D58" class="sect4"><span class="enumeration_section">30.3.2 </span>Performing Open Database Recovery
                  </h4>
                  <div>
                     <p>You can perform complete recovery of non-<code class="codeph">SYSTEM</code> data files in a database while the database is open.
                     </p>
                     <div class="p">
                        <p>This procedure assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The current control file is available. </p>
                           </li>
                           <li>
                              <p>You have backups of all needed data files. </p>
                           </li>
                           <li>
                              <p>All necessary archived redo logs are available. </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>It is possible for a media failure to occur while the database remains open, leaving the undamaged data files online and available for use. Damaged data files—but not the tablespaces that contain them—are automatically taken offline if the database writer cannot write to them. If the database writer cannot open a data file, an error is still returned. Queries that cannot read damaged files return errors, but the data files are not taken offline because of the failed queries. For example, you may run a SQL query and see output such as:</p><pre class="oac_no_warn" dir="ltr">ERROR at line 1:
ORA-01116: error in opening database file 3
ORA-01110: data file 11: '/oracle/oradata/trgt/cwmlite02.dbf'
ORA-27041: unable to open file
SVR4 Error: 2: No such file or directory
Additional information: 3
</pre><div class="infoboxnote" id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58__GUID-D611AACE-C851-43D2-95CC-CB472DD71FC2">
                           <p class="notep1">Note:</p>
                           <p>You cannot use the procedure in this section to perform complete media recovery on the <code class="codeph">SYSTEM</code> tablespace while the database is open. If the media failure damages data files of the <code class="codeph">SYSTEM</code> tablespace, then the database automatically shuts down.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58__GUID-987CE271-C1E8-4E26-A472-6AA1FA7CBA5C">To restore data files in an open database:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Follow Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDJEDGI">1</a> through Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDGADJF">3</a> in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span>.</span></li>
                        <li class="stepexpand"><span>If the database is open, then take all tablespaces containing damaged data files offline. For example, if the tablespaces <code class="codeph">USERS</code> and <code class="codeph">TOOLS</code> contain damaged data files, then execute the following SQL statements:</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLESPACE users OFFLINE TEMPORARY;
ALTER TABLESPACE tools OFFLINE TEMPORARY;
</pre><p>If you specify <code class="codeph">TEMPORARY</code>, then Oracle Database creates a <a href="glossary.html#GUID-5FE755DB-A906-465A-A3E4-D067A77DA15C"><span class="xrefglossterm">checkpoint</span></a> for all online data files in the tablespace. Files that are offline when you issue this statement may require media recovery before you bring the tablespace back online. If you specify <code class="codeph">IMMEDIATE</code>, then you must perform media recovery on the tablespace before bringing it back online.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Inspect the media to determine the source of the problem.</span><div>
                              <p>You can use the DBVERIFY utility to run an integrity check on offline data files. </p>
                              <p>If the hardware problem that caused the media failure was temporary, and if the data was undamaged, then no media recovery is required. You can bring the offline tablespaces online and resume normal operations. If you cannot repair the problem, or if DBVERIFY reports corrupt blocks, then proceed to the Step 4.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>If files are permanently damaged, then use operating system commands to restore the most recent backup files of <span class="italic">only</span><span class="italic"><span class="bold"> </span></span>the data files damaged by the media failure. For example, to restore <code class="codeph">users01.dbf</code> you might use the <code class="codeph">cp</code> command on Linux or UNIX as follows:</span><div><pre class="oac_no_warn" dir="ltr">% cp /disk2/backup/users01.dbf $ORACLE_HOME/oradata/trgt/users01.dbf
</pre><p>If the hardware problem is fixed and the data files can be restored to their original locations, then do so. Otherwise, restore the data files to an alternative storage device. Do not restore undamaged data files, online redo logs, or control files. </p>
                              <div class="infoboxnote" id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58__GUID-54F2A92B-7E04-4D37-AAA0-268350F6C597">
                                 <p class="notep1">Note:</p>
                                 <p>In some circumstances, if you do not have a backup of a specific data file, you can use the <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">CREATE</code> <code class="codeph">DATAFILE</code> statement to create an empty replacement file that is recoverable.
                                 </p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>If you restored one or more damaged data files to alternative locations, then update the control file of the database to reflect the new data file names. For example, to change the file name of the data file in tablespace <code class="codeph">users</code> you might enter:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE RENAME FILE '?/oradata/trgt/users01.dbf' TO
                           '/disk2/users01.dbf';
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If you restored archived redo logs to an alternative location, then you can specify the location before media recovery with the <code class="codeph">LOGSOURCE</code> parameter of the <code class="codeph">SET</code> command in SQL*Plus. For example, if the logs are staged in <code class="codeph">/tmp</code>, you can enter the following command:</span><div><pre class="oac_no_warn" dir="ltr">SET LOGSOURCE /tmp
</pre><p>Alternatively, you can skip Step 6 and use the <code class="codeph">FROM</code> parameter on the <code class="codeph">RECOVER</code> command as in Step 7. For example, if the logs are staged in <code class="codeph">/tmp</code>, you can enter the following command:
                              </p><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC FROM '/tmp' TABLESPACE users, tools;</pre><div class="infoboxnote" id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58__GUID-14E8DBEA-A529-49CF-84D9-D5C59D46298F">
                                 <p class="notep1">Note:</p>
                                 <p>Overriding the redo log source does not affect the archive redo log destination for online redo log groups being archived.</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Connect to the database with administrator privileges, and start offline tablespace recovery of all damaged data files in one or more offline tablespaces using one step. For example, recover <code class="codeph">users</code> and <code class="codeph">tools</code> as follows:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER AUTOMATIC TABLESPACE users, tools;
</pre><p>The database begins the roll forward phase of media recovery by applying the necessary archived and online redo logs to reconstruct the restored data files. Unless the application of files is automated with the <code class="codeph">RECOVER</code> <code class="codeph">AUTOMATIC</code> or <code class="codeph">SET</code> <code class="codeph">AUTORECOVERY</code> <code class="codeph">ON</code> commands, the database prompts for each required redo log file.
                              </p>
                              <p>Recovery continues until all required archived logs have been applied to the data files. The online redo logs are then automatically applied to the restored data files to complete media recovery. If no archived redo logs are required for complete media recovery, then the database does not prompt for any. Instead, all necessary online redo logs are applied, and media recovery is complete.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>When the damaged tablespaces are recovered up to the moment that media failure occurred, bring the offline tablespaces online. For example, to bring tablespaces <code class="codeph">USERS</code> and <code class="codeph">TOOLS</code> online, issue the following statements:</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLESPACE users ONLINE;
ALTER TABLESPACE tools ONLINE;</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-56EBDCEE-0C55-4556-A732-82EF42834D58__GUID-46C12003-8B1A-43A5-AEDA-032EC4C3D979">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-data-files-and-temp-files.html#ADMIN012" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn about creating data files and <a href="../sqlrf/ALTER-DATABASE.html#SQLRF00802" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">RENAME</code> <code class="codeph">FILE</code></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-database-backups.html#GUID-F8F10F74-107C-4D8F-86A8-18140FE8484D">Running the DBVERIFY Utility</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-3913B513-ECF0-469A-A50A-A5A573C85DC0">Recovering After the Loss of All Current Control Files</a>"</span> and <span class="q">"<a href="user-managed-recovery-advanced.html#GUID-9152B9A8-308A-4871-B835-53AF7593E65D">Re-Creating a Control File</a>"</span> for information about restoring or re-creating the control file
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-E0032019-E245-4EBD-B275-1343AA175239">Re-Creating Data Files When Backups Are Unavailable</a>"</span> for information about performing recovery when data file backups are missing
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" title="Incomplete recovery is also known as database point-in-time recovery.">Performing Incomplete Database Recovery</a>"</span> for information about performing database point-in-time recovery when you are missing redo required to completely recover the database
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV656"></a><a id="BRADV655"></a><div class="props_rev_3"><a id="GUID-68CD62A9-F56E-4617-A010-F632708AECC3" name="GUID-68CD62A9-F56E-4617-A010-F632708AECC3"></a><h4 id="BRADV-GUID-68CD62A9-F56E-4617-A010-F632708AECC3" class="sect4"><span class="enumeration_section">30.3.3 </span>Performing Crash and Instance Recovery of CDBs
                  </h4>
                  <div>
                     <p>Oracle Database performs crash and instance recovery for the entire multitenant container database (CDB). You cannot recover individual pluggable databases (PDBs).</p>
                     <div class="p">
                        <p>This procedure assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The current control file is available. </p>
                           </li>
                           <li>
                              <p>You have backups of all needed data files. </p>
                           </li>
                           <li>
                              <p>All necessary archived redo logs are available. </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-68CD62A9-F56E-4617-A010-F632708AECC3__GUID-227D4D2B-6106-4CE3-8625-C1A37A34484F">To perform crash and instance recovery for a CDB:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Open a SQL client such as SQL*Plus.</span></li>
                        <li class="stepexpand"><span>Connect to the <a href="glossary.html#GUID-EA3DB8F4-F68E-4FC5-A599-32A4886FFF8A"><span class="xrefglossterm">root</span></a> as a common user with the <code class="codeph">ALTER PLUGGABLE DATABASE</code> system privilege.</span></li>
                        <li class="stepexpand"><span>Follow the procedures in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span>.</span><div>
                              <p>If you do not want to recover a particular PDB, take its files offline.</p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-68CD62A9-F56E-4617-A010-F632708AECC3__GUID-F691FCE9-6291-4B8F-AC44-A02F091D089D">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-3913B513-ECF0-469A-A50A-A5A573C85DC0">Recovering After the Loss of All Current Control Files</a>"</span> and <span class="q">"<a href="user-managed-recovery-advanced.html#GUID-9152B9A8-308A-4871-B835-53AF7593E65D">Re-Creating a Control File</a>"</span> for information about restoring or re-creating the control file
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-E0032019-E245-4EBD-B275-1343AA175239">Re-Creating Data Files When Backups Are Unavailable</a>"</span> for information about performing recovery when data file backups are missing
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" title="Incomplete recovery is also known as database point-in-time recovery.">Performing Incomplete Database Recovery</a>"</span> for information about performing database point-in-time recovery when you are missing redo required to completely recover the database
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="BRADV503"></a><a id="BRADV217"></a><div class="props_rev_3"><a id="GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" name="GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3"></a><h3 id="BRADV-GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3" class="sect3"><span class="enumeration_section">30.4 </span>Performing Incomplete Database Recovery
               </h3>
               <div>
                  <p>Incomplete recovery is also known as database point-in-time recovery.</p>
                  <p>Typically, you perform <a href="glossary.html#GUID-FCC8BB91-79B6-4AF1-974A-43E75CD161E3"><span class="xrefglossterm">database point-in-time recovery (DBPITR)</span></a> in the following situations:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You want to recover the database to an SCN before a user or administrative error.</p>
                     </li>
                     <li>
                        <p>The database contains corrupt blocks.</p>
                     </li>
                     <li>
                        <p>Complete database recovery failed because all necessary archived redo logs were not available.</p>
                     </li>
                     <li>
                        <p>You are creating a test database or a reporting database from production database backups.</p>
                     </li>
                  </ul>
                  <p>If the database is operating in <code class="codeph">ARCHIVELOG</code> mode, and if the only copy of an archived redo log file is damaged, then the damaged file does not affect the present operation of the database. <a href="user-managed-flashback-dbpitr.html#GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3__CHDEHHEI" title="Loss of archived redo logs">Table 30-2</a> describes situations that can arise depending on when the redo log was written and when you backed up the data file.
                  </p>
                  <div class="tblformal" id="GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3__CHDEHHEI">
                     <p class="titleintable">Table 30-2 Loss of Archived Redo Logs</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Loss of Archived Redo Logs" summary="Loss of archived redo logs" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d140508e4095">If You Backed Up...</th>
                              <th align="left" valign="bottom" width="69%" id="d140508e4098">Then...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d140508e4103" headers="d140508e4095 ">
                                 <p>All data files after the filled online redo log group (which is now archived) was written</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d140508e4103 d140508e4098 ">
                                 <p>The archived version of the filled online redo log group is not required for complete media recovery.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d140508e4110" headers="d140508e4095 ">
                                 <p>A specific data file before the filled online redo log group was written</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d140508e4110 d140508e4098 ">
                                 <p>If the corresponding data file is damaged by a permanent media failure, then use the most recent backup of the damaged data file and perform tablespace point-in-time recovery of the damaged data file, up to the damaged archived redo log file. </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3__GUID-4804C30C-7E21-4CB9-B233-1A000BD7E8C9">
                     <p class="notep1">Caution:</p>
                     <p>If you know that an archived redo log group has been damaged, then immediately back up all data files so that you have a whole database backup that does not require the damaged archived redo log.</p>
                  </div>
                  <p>The technique for DBPITR is very similar to the technique for performing closed database recovery, except that you terminate DBPITR by specifying a particular time or SCN or entering <code class="codeph">CANCEL</code>. Cancel-based recovery prompts you with the suggested file names of archived redo logs. Recovery stops when you specify <code class="codeph">CANCEL</code> instead of a file name or when all redo has been applied to the data files. Cancel-based recovery is the best technique to control which archived log terminates recovery.
                  </p>
                  <div class="infoboxnotealso" id="GUID-2BF2BE5E-3D1B-4F0C-9F10-25D5342F6DB3__GUID-A1E280B7-336C-443A-9CD3-F11643322D1A">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-110AD275-650D-4A87-9790-B785D4618C9B" title="In cancel-based recovery, recovery proceeds by prompting you with the suggested file names of archived redo log files. Recovery stops when you specify CANCEL instead of a file name or when all redo has been applied to the data files.">Performing Cancel-Based Incomplete Recovery</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD" title="You can specify an SCN or time for the end point of incomplete recovery.">Performing Time-Based or Change-Based Incomplete Recovery</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="BRADV620"></a><a id="BRADV504"></a><a id="BRADV90034"></a><div class="props_rev_3"><a id="GUID-110AD275-650D-4A87-9790-B785D4618C9B" name="GUID-110AD275-650D-4A87-9790-B785D4618C9B"></a><h4 id="BRADV-GUID-110AD275-650D-4A87-9790-B785D4618C9B" class="sect4"><span class="enumeration_section">30.4.1 </span>Performing Cancel-Based Incomplete Recovery
                  </h4>
                  <div>
                     <p>In cancel-based recovery, recovery proceeds by prompting you with the suggested file names of archived redo log files. Recovery stops when you specify <code class="codeph">CANCEL</code> instead of a file name or when all redo has been applied to the data files.
                     </p>
                     <div class="p">
                        <p>This procedure assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The current control file is available.</p>
                           </li>
                           <li>
                              <p>You have backups of all needed data files. </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__GUID-9A3715AC-4514-466C-B27D-57ED09280A15">To perform cancel-based recovery:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Follow Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDJEDGI">1</a> through Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDGACIB">8</a> in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span>.</span></li>
                        <li class="stepexpand"><span>Begin cancel-based recovery by issuing the following command in SQL*Plus:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL CANCEL</pre><div class="infoboxnote" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__GUID-B7D0B118-DBFA-495F-8DD5-09EE2AA7C0E1">
                                 <p class="notep1">Note:</p>
                                 <p>If you fail to specify the <code class="codeph">UNTIL</code> clause on the <code class="codeph">RECOVER</code> command, then the database assumes a complete recovery and does not open until all redo is applied.
                                 </p>
                              </div>
                              <p>The database applies the necessary redo log files to reconstruct the restored data files. The database supplies the name it expects to find from <code class="codeph">LOG_ARCHIVE_DEST_1</code> and requests you to stop or proceed with applying the log file. If the control file is a backup, then you must supply the names of the online redo logs if you want to apply the changes in these logs.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Continue applying redo log files until the last log has been applied to the restored data files, then cancel recovery by executing the following command:</span><div><pre class="oac_no_warn" dir="ltr">CANCEL
</pre><p>The database indicates whether recovery is successful. If you cancel before all the data files have been recovered to a consistent SCN and then try to open the database, then you get an <code class="codeph">ORA-1113</code> error if more recovery is necessary. You can query <code class="codeph">V$RECOVER_FILE</code> to determine whether more recovery is needed, or if a backup of a data file was not restored before starting incomplete recovery.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDGJGGF"><span>Open the database with the <code class="codeph">RESETLOGS</code> option. You must always reset the logs after incomplete recovery or recovery with a backup control file. For example:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE OPEN RESETLOGS;
</pre><p>If you attempt to use <code class="codeph">OPEN</code> <code class="codeph">RESETLOGS</code> when you should not, or if you neglect to reset the log when you should, then the database returns an error and does not open the database. Correct the problem and try again.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDDFBBJ"><span>After opening the database with the <code class="codeph">RESETLOGS</code> option, check the alert log.</span><div>
                              <div class="infoboxnote" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__GUID-5D2B534E-DDE5-4B0B-85E7-80025C92A590">
                                 <p class="notep1">Note:</p>
                                 <p>    The easiest way to locate trace files and the alert log is to run the following SQL query: <code class="codeph">SELECT NAME, VALUE FROM V$DIAG_INFO</code>.
                                 </p>
                              </div>
                              <p>When you open with the <code class="codeph">RESETLOGS</code> option, the database returns different messages depending on whether recovery was complete or incomplete. If the recovery was complete, then the following message appears in the alert log:
                              </p><pre class="oac_no_warn" dir="ltr">RESETLOGS after complete recovery through change <span class="italic">scn</span>
</pre><p>If the recovery was incomplete, then this message is reported in the alert log, where <span class="italic"><code class="codeph">scn</code></span> refers to the end point of incomplete recovery:
                              </p><pre class="oac_no_warn" dir="ltr">RESETLOGS after incomplete recovery UNTIL CHANGE <span class="italic">scn</span>
</pre><p>Also check the alert log to determine whether the database detected inconsistencies between the data dictionary and the control file. <a href="user-managed-flashback-dbpitr.html#GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDIBHDI" title="Describes inconsistencies in datafile records">Table 30-3</a> describes two possible scenarios.
                              </p>
                              <div class="tblformal" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDIBHDI">
                                 <p class="titleintable">Table 30-3 Inconsistencies Between Data Dictionary and Control File</p>
                                 <table cellpadding="4" cellspacing="0" class="Formal" title="Inconsistencies Between Data Dictionary and Control File" summary="Describes inconsistencies in datafile records" width="90%" frame="hsides" border="1" rules="rows">
                                    <thead>
                                       <tr align="left" valign="top">
                                          <th align="left" valign="bottom" width="25%" id="d140508e4370">Data File Listed in Control File</th>
                                          <th align="left" valign="bottom" width="25%" id="d140508e4373">Data File Listed in the Data Dictionary</th>
                                          <th align="left" valign="bottom" width="50%" id="d140508e4376">Result</th>
                                       </tr>
                                    </thead>
                                    <tbody>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="25%" id="d140508e4381" headers="d140508e4370 ">
                                             <p>Yes</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d140508e4381 d140508e4373 ">
                                             <p>No</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d140508e4381 d140508e4376 ">
                                             <p>References to the unlisted data file are removed from the control file. A message in the alert log indicates what was found.</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="25%" id="d140508e4391" headers="d140508e4370 ">
                                             <p>No</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d140508e4391 d140508e4373 ">
                                             <p>Yes</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d140508e4391 d140508e4376 ">
                                             <p>The database creates a placeholder entry in the control file under <code class="codeph">MISSING</code><code class="codeph">nnnnn</code> (where <code class="codeph">nnnnn</code> is the file number in decimal). <code class="codeph">MISSING</code><code class="codeph">nnnnn</code> is flagged in the control file as offline and requiring media recovery. You can make the data file corresponding to <code class="codeph">MISSING</code><code class="codeph">nnnnn</code> accessible by using <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">RENAME</code> <code class="codeph">FILE</code> for <code class="codeph">MISSING</code><code class="codeph">nnnnn</code> so that it points to the data file. If you do not have a backup of this data file, then drop the tablespace.
                                             </p>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </div>
                              <!-- class="inftblhruleinformal" -->
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-110AD275-650D-4A87-9790-B785D4618C9B__GUID-FC85452D-F65B-4E4D-BCAE-BA99A2EDEED5">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B">About User-Managed Media Recovery Problems</a>"</span> for descriptions of situations that can cause <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">OPEN</code> <code class="codeph">RESETLOGS</code> to fail
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-3913B513-ECF0-469A-A50A-A5A573C85DC0">Recovering After the Loss of All Current Control Files</a>"</span> for information about restoring or re-creating the control file
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-E0032019-E245-4EBD-B275-1343AA175239">Re-Creating Data Files When Backups Are Unavailable</a>"</span> for information about performing recovery when data file backups are missing
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV621"></a><a id="BRADV90035"></a><div class="props_rev_3"><a id="GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD" name="GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD"></a><h4 id="BRADV-GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD" class="sect4"><span class="enumeration_section">30.4.2 </span>Performing Time-Based or Change-Based Incomplete Recovery
                  </h4>
                  <div>
                     <p>You can specify an SCN or time for the end point of incomplete recovery.</p>
                     <div class="p">
                        <p>If your database is affected by seasonal time changes (for example, daylight savings time), then you may experience a problem if a time appears twice in the redo log and you want to recover to the second, or later time. To handle time changes, perform cancel-based or change-based recovery.</p>
                        <p>This procedure assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The current control file is available.</p>
                           </li>
                           <li>
                              <p>You have backups of all needed data files. </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD__GUID-22A12690-60EB-4700-8071-076AC61384B9">To perform change-based or time-based recovery:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Follows Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDJEDGI">1</a> through Step <a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8__CHDGACIB">8</a> in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-4F83FD6F-01A3-4680-AD41-EF391EEBB0D8" title="When performing complete recovery while the database is not open, you can recover either all damaged data files in one operation or perform individual recovery of each damaged data file in separate operations.">Performing Closed Database Recovery</a>"</span>.</span></li>
                        <li class="stepexpand"><span>Issue the <code class="codeph">RECOVER</code> <code class="codeph">DATABASE</code> <code class="codeph">UNTIL</code> statement to begin recovery. If recovering to an SCN, then specify as a decimal number without quotation marks. For example, to recover through SCN 10034 issue:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL CHANGE 10034;
</pre><p>If recovering to a time, then the time is always specified using the following format, delimited by single quotation marks: <code class="codeph">'YYYY-MM-DD:HH24:MI:SS'</code>. The following statement recovers the database up to a specified time:
                              </p><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL TIME '2000-12-31:12:47:30'
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Apply the necessary redo log files to recover the restored data files. The database automatically terminates the recovery when it reaches the correct time, and returns a message indicating whether recovery is successful.</span><div>
                              <div class="infoboxnote" id="GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD__GUID-5F45CA17-E938-4C93-8509-F5D96A81B9DE">
                                 <p class="notep1">Note:</p>
                                 <p>Unless recovery is automated, the database supplies the name from <code class="codeph">LOG_ARCHIVE_DEST_1</code> and asks you to stop or proceed with after each log. If the control file is a backup, then after the archived logs are applied you must supply the names of the online logs.
                                 </p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Follow Steps <a href="user-managed-flashback-dbpitr.html#GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDGJGGF">4</a> and <a href="user-managed-flashback-dbpitr.html#GUID-110AD275-650D-4A87-9790-B785D4618C9B__CHDDFBBJ">5</a> in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-110AD275-650D-4A87-9790-B785D4618C9B" title="In cancel-based recovery, recovery proceeds by prompting you with the suggested file names of archived redo log files. Recovery stops when you specify CANCEL instead of a file name or when all redo has been applied to the data files.">Performing Cancel-Based Incomplete Recovery</a>"</span>.</span></li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-CEC8AD66-CB59-4065-A972-DFB77A93C0AD__GUID-4664AD39-E435-4AD4-A82F-38CA22DF6CCC">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-3913B513-ECF0-469A-A50A-A5A573C85DC0">Recovering After the Loss of All Current Control Files</a>"</span> for information about restoring or re-creating the control file
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="user-managed-recovery-advanced.html#GUID-E0032019-E245-4EBD-B275-1343AA175239">Re-Creating Data Files When Backups Are Unavailable</a>"</span> for information about performing recovery when data file backups are missing
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="BRADV622"></a><a id="BRADV219"></a><div class="props_rev_3"><a id="GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A" name="GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A"></a><h3 id="BRADV-GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A" class="sect3"><span class="enumeration_section">30.5 </span>Recovering a Database in NOARCHIVELOG Mode
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d140508e4771" class="indexterm-anchor"></a><a id="d140508e4777" class="indexterm-anchor"></a><a id="d140508e4781" class="indexterm-anchor"></a><a id="d140508e4785" class="indexterm-anchor"></a><a id="d140508e4789" class="indexterm-anchor"></a><a id="d140508e4793" class="indexterm-anchor"></a>If a media failure damages data files in a <code class="codeph">NOARCHIVELOG</code> database, then the only option for recovery is usually to restore a consistent whole database backup. If you are using logical backups created by Oracle Data Pump Export to supplement regular physical backups, then you can also attempt to restore the database by importing an exported backup of the database into a re-created database or a database restored from an old backup.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A__GUID-140ED71E-0DCB-4E87-B998-76AA7E852855">To restore and recover the most recent whole database backup: </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>I<a id="d140508e4808" class="indexterm-anchor"></a><a id="d140508e4812" class="indexterm-anchor"></a>f the database is open, then shut down the database. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">SHUTDOWN IMMEDIATE
</pre></div>
                     </li>
                     <li class="stepexpand"><span>If possible, correct the media problem so that the backup database files can be restored to their original locations.</span></li>
                     <li class="stepexpand"><span>Restore the most recent whole database backup with operating system commands. Restore all of the data files and control files of the whole database backup, not just the damaged files. If the hardware problem has not been corrected and some or all of the database files must be restored to alternative locations, then restore the whole database backup to a new location. The following example restores a whole database backup to its default location:</span><div><pre class="oac_no_warn" dir="ltr">% cp /backup/*.dbf $ORACLE_HOME/oradata/trgt/ 
</pre></div>
                     </li>
                     <li class="stepexpand"><span>If necessary, edit the restored initialization parameter file to indicate the new location of the control files. For example:</span><div><pre class="oac_no_warn" dir="ltr">CONTROL_FILES = "/new_disk/oradata/trgt/control01.dbf"
</pre></div>
                     </li>
                     <li class="stepexpand"><span>Start an instance using the restored and edited parameter file and mount, but do not open, the database. For example:</span><div><pre class="oac_no_warn" dir="ltr">STARTUP MOUNT
</pre></div>
                     </li>
                     <li class="stepexpand"><span>If the restored data file names are different (such as when you restore to a different file system or directory, on the same node or a different node), then update the control file to reflect the new data file locations. For example, to rename data file <code class="codeph">1</code> you might enter:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE RENAME FILE '?/oradata/trgt/system01.dbf' TO
                           '/new_disk/oradata/system01.dbf';
</pre></div>
                     </li>
                     <li class="stepexpand"><span>If the online redo logs were located on a damaged disk, and the hardware problem is not corrected, then specify a new location for each affected online log. For example, enter:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE RENAME FILE '?/oradata/trgt/redo01.log' TO
                           '/new_disk/oradata/redo_01.log';
ALTER DATABASE RENAME FILE '?/oradata/trgt/redo02.log' TO
                           '/new_disk/oradata/redo_02.log';
</pre></div>
                     </li>
                     <li class="stepexpand"><span>Because online redo logs are never backed up, you cannot restore them with the data files and control files. To enable the database to reset the online redo logs, you must first mimic incomplete recovery:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE UNTIL CANCEL
CANCEL
</pre></div>
                     </li>
                     <li class="stepexpand"><span><a id="d140508e4864" class="indexterm-anchor"></a><a id="d140508e4868" class="indexterm-anchor"></a>Open the database in <code class="codeph">RESETLOGS</code> mode. This command clears the online redo logs and resets the log sequence to 1:</span><div><pre class="oac_no_warn" dir="ltr">ALTER DATABASE OPEN RESETLOGS;
</pre><p>If you restore a <code class="codeph">NOARCHIVELOG</code> database backup and then reset the log, the action discards all changes to the database made from the time the backup was taken to the time of the failure.
                           </p>
                        </div>
                     </li>
                  </ol>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-3A4C59D7-C91D-4A4E-A803-5C02FE58858A__GUID-31400F96-8322-4DE8-B416-BD6CE14D8CFE">
                        <p class="notep1">See Also:</p>
                        <p><a href="../admin/managing-data-files-and-temp-files.html#ADMIN012" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about renaming and relocating data files, and <a href="../sqlrf/ALTER-DATABASE.html#SQLRF00802" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">RENAME</code> <code class="codeph">FILE</code></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="BRADV90036"></a><div class="props_rev_3"><a id="GUID-36D3AEB2-CAB5-491D-8AAC-7E08ABC842A6" name="GUID-36D3AEB2-CAB5-491D-8AAC-7E08ABC842A6"></a><h3 id="BRADV-GUID-36D3AEB2-CAB5-491D-8AAC-7E08ABC842A6" class="sect3"><span class="enumeration_section">30.6 </span>Troubleshooting Media Recovery
               </h3>
               <div>
                  <p>This section describes how to troubleshoot user-managed media recovery, that is, media recovery performed without using Recovery Manager (RMAN). This section includes the following topics:<a id="d140508e4981" class="indexterm-anchor"></a><a id="d140508e4985" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B">About User-Managed Media Recovery Problems</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-5A3274A9-D725-46D6-A0CC-2560D6AA6102">Investigating the Media Recovery Problem: Phase 1</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41">Trying to Fix the Recovery Problem Without Corrupting Blocks: Phase 2</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A">Deciding Whether to Allow Recovery to Mark as Corrupt Blocks: Phase 3</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE">Allowing Recovery to Corrupt Blocks: Phase 4</a></p>
                     </li>
                     <li>
                        <p><a href="user-managed-flashback-dbpitr.html#GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684">Performing Trial Recovery</a></p>
                     </li>
                  </ul>
               </div><a id="BRADV505"></a><a id="BRADV241"></a><div class="props_rev_3"><a id="GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B" name="GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B"></a><h4 id="BRADV-GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B" class="sect4"><span class="enumeration_section">30.6.1 </span>About User-Managed Media Recovery Problems
                  </h4>
                  <div>
                     <p><a id="d140508e5092" class="indexterm-anchor"></a><a id="d140508e5096" class="indexterm-anchor"></a><a id="d140508e5100" class="indexterm-anchor"></a><a id="d140508e5104" class="indexterm-anchor"></a><a href="user-managed-flashback-dbpitr.html#GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B__CIHBAIGH" title="This table describes possible problems encountered in media recovery.">Table 30-4</a> describes potential problems that can occur during media recovery.
                     </p>
                     <div class="tblformalwide" id="GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B__CIHBAIGH">
                        <p class="titleintable">Table 30-4 Media Recovery Problems </p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Media Recovery Problems " summary="This table describes possible problems encountered in media recovery." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d140508e5123">Problem </th>
                                 <th align="left" valign="bottom" width="71%" id="d140508e5126">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5131" headers="d140508e5123 ">
                                    <p>Missing or misnamed archived log</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5131 d140508e5126 ">
                                    <p>Recovery stops because the database cannot find the archived log recorded in the control file.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5138" headers="d140508e5123 ">
                                    <p>When you attempt to open the database, error <code class="codeph">ORA-1113</code> indicates that a data file needs media recovery.
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5138 d140508e5126 ">
                                    <p>This error commonly occurs because:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>You are performing incomplete recovery but failed to restore all needed data file backups.</p>
                                       </li>
                                       <li>
                                          <p>Incomplete recovery stopped before data files reached a consistent SCN.</p>
                                       </li>
                                       <li>
                                          <p>You are recovering data files from an online backup, but not enough redo was applied to make the data files consistent.</p>
                                       </li>
                                       <li>
                                          <p>You are performing recovery with a backup control file, and did not specify the location of a needed online redo log.</p>
                                       </li>
                                       <li>
                                          <p>A data file is undergoing media recovery when you attempt to open the database.</p>
                                       </li>
                                       <li>
                                          <p>Data files needing recovery were not brought online before you execute the <code class="codeph">RECOVER</code> <code class="codeph">DATABASE</code> command, and so were not recovered.
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5173" headers="d140508e5123 ">
                                    <p><a id="d140508e5175" class="indexterm-anchor"></a>Redo record problems
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5173 d140508e5126 ">
                                    <p>Two possible cases are as follows: </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Recovery stops because of failed consistency checks, a problem called <a id="d140508e5187" class="indexterm-anchor"></a><a id="d140508e5191" class="indexterm-anchor"></a><strong class="term">stuck recovery</strong>. Stuck recovery can occur when an underlying operating system or storage system loses a write issued by the database during normal operation.
                                          </p>
                                       </li>
                                       <li>
                                          <p>The database signals an internal error when applying the redo. This problem can be caused by an Oracle Database bug. If <a href="glossary.html#GUID-36837841-FB21-45C7-A99A-FFC35D04FB0B"><span class="xrefglossterm">checksum</span></a> verification is not being used, then the errors can also be caused by corruptions to the redo or data blocks.
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5204" headers="d140508e5123 ">
                                    <p><a id="d140508e5206" class="indexterm-anchor"></a>Corrupted archived logs
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5204 d140508e5126 ">
                                    <p>Logs may be corrupted while they are stored on or copied between storage systems. If <code class="codeph">DB_BLOCK_CHECKSUM</code> is enabled, then the database usually signals a checksum error. If checksum checking is disabled, then log corruption may appear as a problem with redo.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5218" headers="d140508e5123 ">
                                    <p><a id="d140508e5220" class="indexterm-anchor"></a><a id="d140508e5224" class="indexterm-anchor"></a><a id="d140508e5228" class="indexterm-anchor"></a>Archived logs with incompatible parallel redo format
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5218 d140508e5126 ">
                                    <p>If you enable the parallel redo feature, then the database generates redo logs in a new format. Prior releases of Oracle are unable to apply parallel redo logs. However, releases before Oracle9<span class="italic">i</span> Database Release 2 (9.2) can detect the parallel redo format and indicate the inconsistency with the following error message: <code class="codeph">External</code> <code class="codeph">error</code> <code class="codeph">00303,</code> <code class="codeph">00000,</code> <code class="codeph">"cannot</code> <code class="codeph">process</code> <code class="codeph">Parallel</code> <code class="codeph">Redo"</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5265" headers="d140508e5123 ">
                                    <p><a id="d140508e5267" class="indexterm-anchor"></a><a id="d140508e5269" class="indexterm-anchor"></a>Corrupted data blocks
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5265 d140508e5126 ">
                                    <p>A data file backup may have contained a corrupted data block, or the data block may become corrupted either during recovery or when it is copied to the backup. If <code class="codeph">DB_BLOCK_CHECKSUM</code> is enabled, then the database computes a checksum for each block during normal operations and stores it in the block before writing it to disk. When the database reads the block from disk later, it recomputes the checksum and compares it to the stored value. If they do not match, then the database signals a checksum error. If checksum checking is disabled, then the problem may also appear as a redo corruption.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d140508e5279" headers="d140508e5123 ">
                                    <p>Random problems</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d140508e5279 d140508e5126 ">
                                    <p>Memory corruptions and other transient problems can occur during recovery.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a id="d140508e5286" class="indexterm-anchor"></a><a id="d140508e5290" class="indexterm-anchor"></a><a id="d140508e5294" class="indexterm-anchor"></a>The symptoms of media recovery problems are usually external or internal errors signaled during recovery. For example, an external error indicates that a redo block or a data block has failed checksum verification checks. Internal errors can be caused by either bugs in the database or errors arising from the underlying operating system and hardware.
                     </p>
                     <p>If media recovery encounters a problem while recovering a database backup, then whether it is a stuck recovery problem or a problem during redo application, the database always stops and leaves the data files undergoing recovery in a consistent state, that is, at a consistent SCN preceding the failure. You can then do one of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Open the database read-only to investigate the problem.</p>
                        </li>
                        <li>
                           <p>Open the database with the <code class="codeph">RESETLOGS</code> option, if the requirements for opening <code class="codeph">RESETLOGS</code> have been met. The <code class="codeph">RESETLOGS</code> restrictions apply to opening the <a href="glossary.html#GUID-009B3F56-8C1E-4CF6-AF0F-A9D2C2E4B9C2"><span class="xrefglossterm">physical standby database</span></a> as well, because a standby database is updated by a form of media recovery.
                           </p>
                        </li>
                     </ul>
                     <p>In general, opening the database read-only or opening with the <code class="codeph">RESETLOGS</code> option requires all online data files to be recovered to the same SCN. If this requirement is not met, then the database may signal <code class="codeph">ORA-1113</code> or other errors when you attempt to open it. Some common causes of <code class="codeph">ORA-1113</code> are described in <a href="user-managed-flashback-dbpitr.html#GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B__CIHBAIGH" title="This table describes possible problems encountered in media recovery.">Table 30-4</a>.
                     </p>
                     <p><a id="d140508e5338" class="indexterm-anchor"></a>The basic methodology for responding to media recovery problems occurs in the following phases:
                     </p>
                     <ol>
                        <li>
                           <p>Try to identify the cause of the problem. Run a trial recovery if needed.</p>
                        </li>
                        <li>
                           <p>If the problem is related to missing redo logs or if you suspect that there is a redo log, memory, or data block corruption, then try to resolve the problem using the methods described in <a href="user-managed-flashback-dbpitr.html#GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__g1007463" title="This table describes causes for a media recovery problem, and causes for and responses to each.">Table 30-5</a>.
                           </p>
                        </li>
                        <li>
                           <p>If you cannot resolve the problem using the methods described in <a href="user-managed-flashback-dbpitr.html#GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__g1007463" title="This table describes causes for a media recovery problem, and causes for and responses to each.">Table 30-5</a>, then do one of the following:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Open the database with the <code class="codeph">RESETLOGS</code> option if you are recovering a whole database backup. If you have performed serial media recovery, then the database contains all the changes up to but not including the changes at the SCN where the corruption occurred. No changes from this SCN onward are in the recovered part of the database. If you have restored online backups, then opening <code class="codeph">RESETLOGS</code> succeeds only if you have recovered through all the <code class="codeph">ALTER</code> <code class="codeph">...</code> <code class="codeph">END</code> <code class="codeph">BACKUP</code> operations in the redo stream.
                                 </p>
                              </li>
                              <li>
                                 <p>Proceed with recovery by allowing media recovery to corrupt <a id="d140508e5389" class="indexterm-anchor"></a>data blocks. After media recovery completes, try performing <a href="glossary.html#GUID-923A509A-1C36-4EA4-91C8-6E4F372722C0"><span class="xrefglossterm">block media recovery</span></a> using RMAN.
                                 </p>
                              </li>
                              <li>
                                 <p>Call Oracle Support Services as a last resort.</p>
                                 <div class="infoboxnotealso" id="GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B__GUID-55B81938-5EC4-41AE-8894-D09273B5ED10">
                                    <p class="notep1">See Also:</p>
                                    <p><span class="q">"<a href="rman-recovery-advanced.html#GUID-195E30B2-6077-446D-A255-089D3341268A" title="Disaster recovery includes the restoration and recovery of the target database after the loss of the entire target database, the recovery catalog database, all current control files, all online redo log files, and all parameter files.">Performing Disaster Recovery</a>"</span> to<span class="italic"> </span>learn about block media recovery
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </li>
                     </ol>
                  </div>
               </div><a id="BRADV242"></a><div class="props_rev_3"><a id="GUID-5A3274A9-D725-46D6-A0CC-2560D6AA6102" name="GUID-5A3274A9-D725-46D6-A0CC-2560D6AA6102"></a><h4 id="BRADV-GUID-5A3274A9-D725-46D6-A0CC-2560D6AA6102" class="sect4"><span class="enumeration_section">30.6.2 </span>Investigating the Media Recovery Problem: Phase 1
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d140508e5484" class="indexterm-anchor"></a><a id="d140508e5490" class="indexterm-anchor"></a>If media recovery encounters a problem, then obtain as much information as possible after recovery halts. You do not want to waste time fixing the wrong problem, which may make matters worse.
                        </p>
                        <p>The goal of this initial investigation is to determine whether the problem is caused by incorrect setup, corrupted redo logs, corrupted data blocks, memory corruption, or other problems. If you see a <a href="glossary.html#GUID-36837841-FB21-45C7-A99A-FFC35D04FB0B"><span class="xrefglossterm">checksum</span></a> error on a data block, then the data block is corrupted. If you see a checksum error on a redo log block, then the redo log is corrupted.
                        </p>
                        <p>Sometimes the cause of a recovery problem can be difficult to determine. Nevertheless, the methods in this section enable you to quickly recover a database even when you do not completely understand the cause of the problem.</p>
                        <p>To investigate media recovery problems:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>Examine the <code class="codeph">alert.log</code> to see whether the error messages give general information about the nature of the problem. For example, does the <code class="codeph">alert_</code><span class="italic"><code class="codeph">SID</code></span><code class="codeph">.log</code> indicate any checksum failures? Does the <code class="codeph">alert_</code><span class="italic"><code class="codeph">SID</code></span><code class="codeph">.log</code> indicate that media recovery may have to corrupt data blocks to continue? </span></li>
                        <li><span>Check the trace file generated by the Oracle Database during recovery. It may contain additional error information.</span></li>
                     </ol>
                  </div>
               </div><a id="BRADV506"></a><a id="BRADV24383"></a><div class="props_rev_3"><a id="GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41" name="GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41"></a><h4 id="BRADV-GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41" class="sect4"><span class="enumeration_section">30.6.3 </span>Trying to Fix the Recovery Problem Without Corrupting Blocks: Phase 2
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d140508e5605" class="indexterm-anchor"></a><a id="d140508e5611" class="indexterm-anchor"></a>Depending on the type of media recovery problem you suspect, you have different solutions at your disposal. You can try one or a combination of the techniques described in <a href="user-managed-flashback-dbpitr.html#GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__g1007463" title="This table describes causes for a media recovery problem, and causes for and responses to each.">Table 30-5</a>. These solutions are common repair techniques and fairly safe for resolving most media recovery issues.
                        </p>
                        <div class="tblformalwide" id="GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__g1007463">
                           <p class="titleintable">Table 30-5 Media Recovery Solutions</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Media Recovery Solutions" summary="This table describes causes for a media recovery problem, and causes for and responses to each." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="29%" id="d140508e5631">If You Suspect...</th>
                                    <th align="left" valign="bottom" width="71%" id="d140508e5634">Then...</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5639" headers="d140508e5631 ">
                                       <p>Missing or misnamed archived redo logs</p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5639 d140508e5634 ">
                                       <p>Determine whether you entered the correct file name. If you did, then check whether the log is missing from the operating system. If it is missing, and if you have a backup, then restore the backup and apply the log. If you do not have a backup, then if possible perform incomplete recovery up to the point of the missing log.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5646" headers="d140508e5631 ">
                                       <p><code class="codeph">ORA-1113</code> for <code class="codeph">ALTER DATABASE OPEN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5646 d140508e5634 ">
                                       <p>Review the causes of this error in <a href="user-managed-flashback-dbpitr.html#GUID-739E7EDD-3142-41C0-AC4B-80E7F000D39B__CIHBAIGH" title="This table describes possible problems encountered in media recovery.">Table 30-4</a>. Ensure that all read/write data files requiring recovery are online. 
                                       </p>
                                       <p>If you use a backup control file for recovery, then the control file and data files must be at a consistent SCN for the database to be opened. If you do not have the necessary redo, then you must re-create the control file.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5664" headers="d140508e5631 ">
                                       <p>Corrupt archived logs</p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5664 d140508e5634 ">
                                       <p>The log is corrupted if the checksum verification on the log redo block fails. If <code class="codeph">DB_BLOCK_CHECKSUM</code> was not enabled either during the recovery session or when the database generated the redo, then recovery problems may be caused by corrupted logs. If the log is corrupt and an alternate copy of the corrupt log is available, then try to apply it and see whether this tactic fixes the problem.
                                       </p>
                                       <p>The <code class="codeph">DB_BLOCK_CHECKSUM</code> initialization parameter determines whether checksums are computed for redo log and data blocks.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5679" headers="d140508e5631 ">
                                       <p>Archived logs with incompatible parallel redo format</p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5679 d140508e5634 ">
                                       <p>If you run an Oracle Database release before Oracle9<span class="italic">i</span> Database Release 2, and if you attempt to apply redo logs created with the parallel redo format, then you must do the following steps:
                                       </p>
                                       <ol>
                                          <li>
                                             <p>Upgrade the database to a later release.</p>
                                          </li>
                                          <li>
                                             <p>Perform media recovery.</p>
                                          </li>
                                          <li>
                                             <p>Shut down the database consistently and back up the database.</p>
                                          </li>
                                          <li>
                                             <p>Downgrade the database to the original release.</p>
                                          </li>
                                       </ol>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5702" headers="d140508e5631 ">
                                       <p>Memory corruption or transient problems</p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5702 d140508e5634 ">
                                       <p>You may be able to fix the problem by shutting down the database and restarting recovery. The database should be left in a consistent state if the second attempt also fails.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d140508e5709" headers="d140508e5631 ">
                                       <p>Corrupt data blocks</p>
                                    </td>
                                    <td align="left" valign="top" width="71%" headers="d140508e5709 d140508e5634 ">
                                       <p>Restore and recover the data file again with user-managed methods, or restore and recover individual data blocks with the RMAN <code class="codeph">RECOVER ... BLOCK</code> command. This technique may fix the problem.
                                       </p>
                                       <p>A data block is corrupted if the checksum verification on the block fails. If <code class="codeph">DB_BLOCK_CHECKING</code> is disabled, then a corrupted data block problem may appear as a redo problem. If you must proceed with media recovery, then you may want to allow media recovery to mark the block as corrupt for now, continue recovery, and then use RMAN to perform block media recovery later.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>If you cannot fix the problem with the methods described in <a href="user-managed-flashback-dbpitr.html#GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__g1007463" title="This table describes causes for a media recovery problem, and causes for and responses to each.">Table 30-5</a>, then there may be no easy way to fix the problem without losing data. You have these options:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Open the database with the <code class="codeph">RESETLOGS</code> option (for whole database recovery).
                              </p>
                              <p>This solution discards all changes after the point where the redo problem occurred, but guarantees a logically consistent database.</p>
                           </li>
                           <li>
                              <p>Allow media recovery to corrupt one or more data blocks and then proceed. </p>
                              <p>This option only succeeds if the alert log indicates that recovery can continue if it is allowed to corrupt a data block, which is the case for most recovery problems. This option is best if you must bring up the database quickly and recover all changes. If you are considering this option, then proceed to <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A">Deciding Whether to Allow Recovery to Mark as Corrupt Blocks: Phase 3</a>"</span>.
                              </p>
                              <div class="infoboxnotealso" id="GUID-54CE55B1-BAC2-4D35-877C-9C07CAAAAF41__GUID-DC32CB10-2A48-46F2-9B7D-092DE14D4D6B">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="rman-block-media-recovery.html#GUID-1E226393-17D0-4AB0-A05D-91210255D8FF" title="Block media recovery recovers provides lower mean time to recover (MTTR) by recovering corrupt data blocks.Use block media recovery to recover one or more corrupt data blocks within a data file. Usually, the database marks a block as media corrupt and then writes it to disk when the corruption is first encountered. No subsequent read of the block is successful until the block is recovered. You can perform block recovery only on blocks that are marked corrupt or that fail a corruption check.Block recovery behavior depends on whether the data block corruption was discovered on the primary database or the physical standby database.The V$DATABASE_BLOCK_CORRUPTION view displays blocks marked corrupt by database components such as RMAN, ANALYZE, and SQL queries.Block media recovery only requires an unbroken set of redo changes for the blocks being recovered. This is unlike data file recovery that requires an unbroken series of redo changes from the beginning of recovery to the end.Certain prerequisites must be met before you perform block media recovery by using the RECOVER ... BLOCK command.Use the RECOVER...BLOCK command to recover individual corrupt blocks in a data file.You identify the blocks that require recovery and then use any available backup to restore and recover these blocks.You can use the Data Recovery Advisor to diagnose and repair failures caused by data block corruptions. In this example, corrupt data blocks were discovered when the VALIDATE DATABASE command.RMAN can automatically recover all blocks listed in the V$DATABASE_BLOCK_CORRUPTION view."> Performing Block Media Recovery </a>"</span>to learn how to perform block media recovery with the <code class="codeph">RECOVER ... BLOCK</code> command
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV507"></a><a id="BRADV99984"></a><div class="props_rev_3"><a id="GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A" name="GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A"></a><h4 id="BRADV-GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A" class="sect4"><span class="enumeration_section">30.6.4 </span>Deciding Whether to Allow Recovery to Mark as Corrupt Blocks: Phase 3
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d140508e5855" class="indexterm-anchor"></a><a id="d140508e5861" class="indexterm-anchor"></a>When media recovery encounters a problem, the alert log may indicate that recovery can continue if it is allowed to mark as corrupt the data block causing the problem. The alert log contains information about the block: its block type, block address, the tablespace it belongs to, and so forth. For blocks containing user data, the alert log may also report the data object number. 
                        </p>
                        <p>In this case, the database can proceed with recovery if it is allowed to mark the problem block as corrupt. Nevertheless, this response is not always advisable. For example, if the block is an important block in the <code class="codeph">SYSTEM</code> tablespace, marking the block as corrupt can eventually prevent you from opening the recovered database. Another consideration is whether the recovery problem is isolated. If this problem is followed immediately by many other problems in the redo stream, then you may want to open the database with the <code class="codeph">RESETLOGS</code> option. 
                        </p>
                        <p>For a block containing user data, you can usually query the database to discover which object or table owns this block. If the database is not open, then you can open the database read-only, even if you are recovering a whole database backup. The following example cancels recovery and opens the database read-only:</p><pre class="oac_no_warn" dir="ltr">CANCEL
ALTER DATABASE OPEN READ ONLY;
</pre><p>Assume that the data object number reported in the <code class="codeph">alert_</code><span class="italic"><code class="codeph">SID</code></span><code class="codeph">.log</code> is <code class="codeph">8031</code>. You can determine the owner, object name, and object type by issuing this query:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OWNER, OBJECT_NAME, SUBOBJECT_NAME, OBJECT_TYPE
FROM DBA_OBJECTS
WHERE DATA_OBJECT_ID = 8031;
</pre><p>To determine whether a recovery problem is isolated, you can run a diagnostic <strong class="term">trial recovery</strong>, which scans the redo stream for problems but does not actually make any changes to the recovered database. If a trial recovery discovers any recovery problems, then it reports them in the <code class="codeph">alert_</code><span class="italic"><code class="codeph">SID</code></span><code class="codeph">.log</code>. You can use the <code class="codeph">RECOVER</code> <code class="codeph">...</code> <code class="codeph">TEST</code> statement to invoke trial recovery, as described in <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD">Executing the RECOVER... TEST Statement</a>"</span>. 
                        </p>
                        <p>After you have done these investigations, you can follow the guidelines in <a href="user-managed-flashback-dbpitr.html#GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A__g1007496" title="This table provides guidelines for allowing media recovery to permit corruption.">Table 30-6</a> to decide whether to allow recovery to permit corrupt blocks.
                        </p>
                        <div class="tblformal" id="GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A__g1007496">
                           <p class="titleintable">Table 30-6 Guidelines for Allowing Recovery to Permit Corrupt Blocks </p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Guidelines for Allowing Recovery to Permit Corrupt Blocks " summary="This table provides guidelines for allowing media recovery to permit corruption." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d140508e5941">If the Problem Is...</th>
                                    <th align="left" valign="bottom" width="20%" id="d140508e5944">and the Block Is...</th>
                                    <th align="left" valign="bottom" width="60%" id="d140508e5947">Then...</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d140508e5952" headers="d140508e5941 ">
                                       <p>Not isolated</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d140508e5952 d140508e5944 ">&nbsp;</td>
                                    <td align="left" valign="top" width="60%" headers="d140508e5952 d140508e5947 ">
                                       <p>You can open the database with the <code class="codeph">RESETLOGS</code> option. This response is important for stuck recovery problems, because stuck recovery can be caused by the operating system or a storage system losing writes. If an operating system or storage system suddenly fails, then it can cause stuck recovery problems on several blocks.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d140508e5963" headers="d140508e5941 ">
                                       <p>Isolated</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d140508e5963 d140508e5944 ">
                                       <p>In the <code class="codeph">SYSTEM</code> tablespace
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="60%" headers="d140508e5963 d140508e5947 ">
                                       <p>Do not corrupt the block, because it may eventually prevent you from opening the database. However, sometimes data in the <code class="codeph">SYSTEM</code> tablespace is unimportant. If you must corrupt a <code class="codeph">SYSTEM</code> block and recover all changes, then contact Oracle Support Services.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d140508e5982" headers="d140508e5941 ">
                                       <p>Isolated</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d140508e5982 d140508e5944 ">
                                       <p>Index data</p>
                                    </td>
                                    <td align="left" valign="top" width="60%" headers="d140508e5982 d140508e5947 ">
                                       <p>Consider corrupting index blocks because the index can be rebuilt later after the database has been recovered.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d140508e5992" headers="d140508e5941 ">
                                       <p>Isolated</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d140508e5992 d140508e5944 ">
                                       <p>User data</p>
                                    </td>
                                    <td align="left" valign="top" width="60%" headers="d140508e5992 d140508e5947 ">
                                       <p>Decide based on the importance of the data. If you continue with data file recovery and corrupt a block, then you lose data in the block. However, you can use RMAN to perform block media recovery later, after data file recovery completes. If you open <code class="codeph">RESETLOGS</code>, then the database is consistent but loses any changes made after the point where recovery was stopped.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d140508e6005" headers="d140508e5941 ">
                                       <p>Isolated</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d140508e6005 d140508e5944 ">
                                       <p>Rollback or undo data</p>
                                    </td>
                                    <td align="left" valign="top" width="60%" headers="d140508e6005 d140508e5947 ">
                                       <p>If all of the transactions are committed, then consider corrupting the rollback or undo block. The database is not harmed if the transactions that generated the undo are never rolled back. However, if those transactions are rolled back, then corrupting the undo block can cause problems. If you are unsure, then contact Oracle Support Services.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-0017FED3-FCC3-47D3-97A3-A0DF7C8C6F7A__GUID-4414DFB9-5286-4D96-98B1-759F19764112">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684">Performing Trial Recovery</a>"</span> to learn how to perform trial recovery, and <span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE">Allowing Recovery to Corrupt Blocks: Phase 4</a>"</span> if you decide to allow recovery to permit corrupt blocks
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV244"></a><div class="props_rev_3"><a id="GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE" name="GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE"></a><h4 id="BRADV-GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE" class="sect4"><span class="enumeration_section">30.6.5 </span>Allowing Recovery to Corrupt Blocks: Phase 4
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d140508e6098" class="indexterm-anchor"></a>If you decide to allow recovery to proceed despite block corruptions, then run the <code class="codeph">RECOVER</code> command with the <code class="codeph">ALLOW</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">CORRUPTION</code> clause, where <span class="italic"><code class="codeph">n</code></span> is the number of allowable corrupt blocks. 
                        </p>
                        <p><span class="bold">To allow recovery to corrupt blocks:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Ensure that all normal recovery preconditions are met. For example, if the database is open, then take tablespaces offline before attempting recovery. </span></li>
                        <li class="stepexpand"><span>Run the <code class="codeph">RECOVER</code> command as in the following example:</span><div><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE ALLOW 5 CORRUPTION</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="BRADV245"></a><div class="props_rev_3"><a id="GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684" name="GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684"></a><h4 id="BRADV-GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684" class="sect4"><span class="enumeration_section">30.6.6 </span>Performing Trial Recovery
                  </h4>
                  <div>
                     <p><a id="d140508e6206" class="indexterm-anchor"></a><a id="d140508e6210" class="indexterm-anchor"></a><a id="d140508e6214" class="indexterm-anchor"></a><a id="d140508e6218" class="indexterm-anchor"></a><a id="d140508e6220" class="indexterm-anchor"></a>When problems such as stuck recovery occur, you have a difficult choice. If the block is relatively unimportant, and if the problem is isolated, then it is better to corrupt the block. But if the problem is not isolated, then it may be better to open the database with the <code class="codeph">RESETLOGS</code> option.
                     </p>
                     <p>Because of this situation, Oracle Database supports <a href="glossary.html#GUID-20FF4FE0-3ABD-4773-A857-6CF062C7D028"><span class="xrefglossterm">trial recovery</span></a>. A trial recovery applies redo in a way similar to normal media recovery, but it never writes its changes to disk and it always rolls back its changes. Trial recovery occurs only in memory.
                     </p>
                     <div class="p">This section contains the following topics:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="user-managed-flashback-dbpitr.html#GUID-5880EC19-0967-47FD-96BA-CBEAB83CAA69">How Trial Recovery Works</a></p>
                           </li>
                        </ul>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="user-managed-flashback-dbpitr.html#GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD">Executing the RECOVER... TEST Statement</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-DB9A54B9-F404-4D8A-894C-D17A1DF8A684__GUID-223767C7-B14F-4458-8B88-8707171E1B85">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="user-managed-flashback-dbpitr.html#GUID-89B0F402-06E7-4030-A4E8-A9E16E7592EE">Allowing Recovery to Corrupt Blocks: Phase 4</a>"</span></p>
                     </div>
                  </div><a id="BRADV90037"></a><div class="props_rev_3"><a id="GUID-5880EC19-0967-47FD-96BA-CBEAB83CAA69" name="GUID-5880EC19-0967-47FD-96BA-CBEAB83CAA69"></a><h5 id="BRADV-GUID-5880EC19-0967-47FD-96BA-CBEAB83CAA69" class="sect5"><span class="enumeration_section">30.6.6.1 </span>How Trial Recovery Works
                     </h5>
                     <div>
                        <p><a id="d140508e6327" class="indexterm-anchor"></a><a id="d140508e6331" class="indexterm-anchor"></a><a id="d140508e6333" class="indexterm-anchor"></a>By default, if a trial recovery encounters a stuck recovery or similar problem, then it always marks the data block as corrupt in memory when this action can allow recovery to proceed. The database writes errors generated during trial recovery to alert files. These errors are clearly marked as test run errors. 
                        </p>
                        <p>Like normal media recovery, trial recovery can prompt you for archived log file names and ask you to apply them. Trial recovery ends when:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The database runs out of the maximum number of buffers in memory that trial recovery is permitted to use</p>
                           </li>
                           <li>
                              <p>An unrecoverable error is signaled, that is, an error that cannot be resolved by corrupting a data block</p>
                           </li>
                           <li>
                              <p>You cancel or interrupt the recovery session</p>
                           </li>
                           <li>
                              <p>The next redo record in the redo stream changes the control file</p>
                           </li>
                           <li>
                              <p>All requested redo has been applied</p>
                           </li>
                        </ul>
                        <p>When trial recovery ends, the database removes all effects of the test run from the system—except the possible error messages in the alert files. If the instance fails during trial recovery, then the database removes all effects of trial recovery from the system, because trial recovery never writes changes to disk.</p>
                        <p>Trial recovery lets you foresee what problems might occur if you were to continue with normal recovery. For problems caused by ongoing memory corruption, trial recovery and normal recovery can encounter different errors.</p>
                     </div>
                  </div><a id="BRADV90038"></a><div class="props_rev_3"><a id="GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD" name="GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD"></a><h5 id="BRADV-GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD" class="sect5"><span class="enumeration_section">30.6.6.2 </span>Executing the RECOVER... TEST Statement
                     </h5>
                     <div>
                        <div class="section">
                           <p>You can use the <code class="codeph">TEST</code> option for any <code class="codeph">RECOVER</code> command. For example, you can start SQL*Plus and then issue any of the following commands:
                           </p><pre class="oac_no_warn" dir="ltr">RECOVER DATABASE TEST
RECOVER DATABASE USING BACKUP CONTROLFILE UNTIL CANCEL TEST
RECOVER TABLESPACE users TEST
RECOVER DATABASE UNTIL CANCEL TEST
</pre><p>By default, trial recovery always attempts to corrupt blocks in memory if this action allows trial recovery to proceed. Trial recovery by default can corrupt an unlimited number of data blocks. You can specify the <code class="codeph">ALLOW</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">CORRUPTION</code> clause on the <code class="codeph">RECOVER</code> <code class="codeph">...</code> <code class="codeph">TEST</code> statement to limit the number of data blocks that trial recovery can corrupt in memory.
                           </p>
                           <p>A trial recovery command is usable in any scenario in which a normal recovery command is usable. Nevertheless, you only need to run trial recovery when recovery runs into problems.</p>
                           <div class="infoboxnotealso" id="GUID-6338386C-B03A-4124-8F4E-8949F14A3FFD__GUID-CC05D2A4-23C5-4790-B6B7-760798152BB9">
                              <p class="notep1">See Also:</p>
                              <p><a href="user-managed-flashback-dbpitr.html#GUID-5880EC19-0967-47FD-96BA-CBEAB83CAA69">How Trial Recovery Works</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>