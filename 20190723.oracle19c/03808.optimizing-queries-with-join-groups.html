<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">
      <meta name="description" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">
      <title>Optimizing Joins with Join Groups</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database In-Memory Guide">
      <meta property="og:description" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database In-Memory Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00">
      <meta name="dcterms.title" content="Database In-Memory Guide">
      <meta name="dcterms.dateCopyrighted" content="2016, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96137-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="optimizing-in-memory-expressions.html" title="Previous" type="text/html">
      <link rel="next" href="optimizing-in-memory-aggregation.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="optimizing-in-memory-expressions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="optimizing-in-memory-aggregation.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database In-Memory Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-optimizations-for-in-memory-queries.html" property="item" typeof="WebPage"><span property="name">Optimizing In-Memory Queries</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Optimizing Joins with Join Groups</li>
            </ol>
            <a id="GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" name="GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797"></a>
            
            <h2 id="INMEM-GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" class="sect2"><span class="enumeration_chapter">8 </span>Optimizing Joins with Join Groups
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>A <strong class="term">join group</strong> is a user-created dictionary object that lists one or more columns that can be meaningfully joined. 
               </p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355">About In-Memory Joins</a><br>Joins are an integral part of data warehousing workloads. The IM column store enhances the performance of joins when the tables being joined are stored in memory.
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55">About Join Groups</a><br>When the IM column store is enabled, the database can use join groups to optimize joins of tables populated in the IM column store.
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B">Purpose of Join Groups</a><br>In certain queries, join groups eliminate the performance overhead of decompressing and hashing column values.
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1">How Join Groups Work</a><br>In a join group, the database compresses all columns in the join group using the same common dictionary.
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64">When a Hash Join Uses Common Dictionary Encodings</a><br>Joins on columns in a join group typically see a performance benefit.
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74">Creating Join Groups</a><br>Define join groups using the <code class="codeph">CREATE INMEMORY JOIN GROUP</code> statement. 
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1">Monitoring Join Group Usage</a><br>To determine whether queries are using the join group, you can use either a graphical SQL Monitor report (recommended) or a SQL query that uses the <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> function.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="advanced-optimizations-for-in-memory-queries.html#GUID-33034151-7BD7-4186-B336-C693FBB27634" title="This Part explains how to optimize queries using In-Memory Expressions, join groups, and In-Memory aggregation. It also explains how the IM column store repopulates modified data.">Optimizing In-Memory Queries</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355" name="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355"></a><h3 id="INMEM-GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355" class="sect3"><span class="enumeration_section">8.1 </span>About In-Memory Joins
               </h3>
               <div>
                  <p>Joins are an integral part of data warehousing workloads. The IM column store enhances the performance of joins when the tables being joined are stored in memory.</p>
                  <p>Because of faster scan and join processing, complex multitable joins and simple joins that use Bloom filters benefit from the IM column store. In a data warehousing environment, the most frequently-used joins involved a fact table and one or more dimension tables.</p>
                  <p>The following joins run faster when the tables are populated in the IM column store:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Joins that are amenable to using Bloom filters</p>
                     </li>
                     <li>
                        <p>Joins of multiple small dimension tables with one fact table</p>
                     </li>
                     <li>
                        <p>Joins between two tables that have a primary key-foreign key relationship</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55" name="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55"></a><h3 id="INMEM-GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55" class="sect3"><span class="enumeration_section">8.2 </span>About Join Groups
               </h3>
               <div>
                  <p>When the IM column store is enabled, the database can use join groups to optimize joins of tables populated in the IM column store.</p>
                  <p>A join group is a set of columns on which a set of tables is frequently joined. The column set contains one or more columns, with a maximum of 255 columns. The table set includes one or more internal tables. External tables are not supported.</p>
                  <p>The columns in the join group can be in the same or different tables. For example, if the <code class="codeph">sales</code> and <code class="codeph">times</code> tables frequently join on the <code class="codeph">time_id</code> column, then you might create a join group for <code class="codeph">(times(time_id), sales(time_id))</code>. If the <code class="codeph">employees</code> table often joins to itself on the <code class="codeph">employee_id</code> column, then a join group could be <code class="codeph">(employees(employee_id))</code>.
                  </p>
                  <div class="infoboxnote" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-A998E38C-24D3-4007-A36F-4F8A9E30BF3D">
                     <p class="notep1">Note:</p>
                     <p>The same column cannot be a member of multiple join groups.</p>
                  </div>
                  <p>When you create a join group, the database invalidates the current In-Memory contents of the tables referenced in the join group. Subsequent <a href="glossary.html#GUID-9168517C-C8A2-4433-946A-037631B840E2"><span class="xrefglossterm">repopulation</span></a> causes the database to re-encode the IMCUs of the tables with the <a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">common dictionary</span></a>. For this reason, Oracle recommends that you first create the join group, and then populate the tables.
                  </p>
                  <p>Create join groups using the <code class="codeph">CREATE INMEMORY JOIN GROUP</code> statement. To add columns to or drop columns from a join group, use an <code class="codeph">ALTER INMEMORY JOIN GROUP</code> statement. Drop a join group using the <code class="codeph">DROP INMEMORY JOIN GROUP</code> statement.
                  </p>
                  <div class="infoboxnote" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-1126C22A-11D9-4682-96EB-3EC4AF8CB094">
                     <p class="notep1">Note:</p>
                     <p>In <span>Oracle Active Data Guard</span>, a standby database ignores join group definitions. A standby database does not use common dictionaries, and executes queries as if join groups did not exist.
                     </p>
                  </div>
                  <div class="example" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-B3380351-7EC3-44A4-B197-53787C717631">
                     <p class="titleinexample">Example 8-1 Creating a Join Group</p>
                     <p>This example creates a join group named <code class="codeph">deptid_jg</code> that includes the <code class="codeph">department_id</code> column in the <code class="codeph">hr.employees</code> and <code class="codeph">hr.departments</code> tables.
                     </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP deptid_jg (hr.employees(department_id),hr.departments(department_id));</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B" name="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B"></a><h3 id="INMEM-GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B" class="sect3"><span class="enumeration_section">8.3 </span>Purpose of Join Groups
               </h3>
               <div>
                  <p>In certain queries, join groups eliminate the performance overhead of decompressing and hashing column values.</p>
                  <p>Without join groups, if the optimizer uses a hash join but cannot use a Bloom filter, or if the Bloom filter does not filter rows effectively, then the database must decompress IMCUs and use an expensive hash join. To illustrate the problem, assume a star schema has a <code class="codeph">sales</code> fact table and a <code class="codeph">vehicles</code> dimension table. The following query joins these tables, but does not filter the output, which means that the database cannot use a Bloom filter:
                  </p><pre class="pre codeblock"><code>SELECT v.year, v.name, s.sales_price
FROM   vehicles v, sales s
WHERE  v.name = s.name;</code></pre><p>The following figure illustrates how the database joins the two data sets.</p>
                  <div class="figure" id="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B__GUID-F6A22D09-F119-45D9-BBDE-1E9E34631E75">
                     <p class="titleinfigure">Figure 8-1 Hash Join without Join Group</p><img src="img/inmem_3v_004.png" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/inmem_3v_004.html"><br><a href="img_text/inmem_3v_004.html">Description of "Figure 8-1 Hash Join without Join Group"</a></div>
                  <!-- class="figure" -->
                  <p>The database performs a hash join as follows:</p>
                  <ol>
                     <li>
                        <p>Scans the <code class="codeph">vehicles</code> table, decompresses the rows that satisfy the predicate (in this case, all rows satisfy the predicate because no filters exist), and sends the rows to the hash join
                        </p>
                     </li>
                     <li>
                        <p>Builds a hash table in the PGA based on the decompressed rows</p>
                     </li>
                     <li>
                        <p>Scans the <code class="codeph">sales</code> table and applies any filters (in this case, the query does not specify filters)
                        </p>
                     </li>
                     <li>
                        <p>Processes matching rows from the IMCUs and then sends the rows to the join</p>
                        <p>When the hash join can consume row sets from the probe side (in this case, the <code class="codeph">sales</code> table), the row sets sent by the table scan are in compressed form. Depending on whether the local dictionary or join group is leveraged to find matching rows from the build side, the hash join either decompresses the rows or leaves them uncompressed.
                        </p>
                     </li>
                     <li>
                        <p>Probes the hash table using the join column, which in this case is the vehicle name</p>
                     </li>
                  </ol>
                  <p>If a join group exists on the <code class="codeph">v.name</code> and <code class="codeph">s.name</code> columns, then the database can make the preceding steps more efficient, eliminating the decompression and filtering overhead. The benefits of join groups are:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The database operates on compressed data.</p>
                     </li>
                     <li>
                        <p>The database avoids hashing on the join key and probing the hash table, which requires comparing the join keys of the probe rows and hashed rows.</p>
                        <p>When a join group exists, the database stores codes for each join column value in a <a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">common dictionary</span></a>. The database builds a join group array using dictionary codes. Every array element points to a build-side row stored in the hash area (typically, PGA memory). During the probe, each probe row has a code associated with the join key. The database uses this code to search the array to determine whether a pointer exists in the array element. If a pointer exists, then there is a match; otherwise, there is no match.
                        </p>
                     </li>
                     <li>
                        <p>The dictionary codes are dense and have a fixed length, which makes them space efficient.</p>
                     </li>
                     <li>
                        <p>Optimizing a query with a join group is sometimes possible when it is not possible to use a Bloom filter.</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" name="GUID-7972FD49-0418-4196-9069-A4F44D16A9F1"></a><h3 id="INMEM-GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" class="sect3"><span class="enumeration_section">8.4 </span>How Join Groups Work
               </h3>
               <div>
                  <p>In a join group, the database compresses all columns in the join group using the same common dictionary.</p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793">How a Join Group Uses a Common Dictionary</a><br>A <strong class="term">common dictionary</strong> is a table-level, instance-specific set of dictionary codes.
                     </li>
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63">How a Join Group Optimizes Scans</a><br>The key optimization is joining on common dictionary codes instead of column values, thereby avoiding the use of a hash table for the join.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-88A573DD-99D3-48D7-8310-B46F70184793" name="GUID-88A573DD-99D3-48D7-8310-B46F70184793"></a><h4 id="INMEM-GUID-88A573DD-99D3-48D7-8310-B46F70184793" class="sect4"><span class="enumeration_section">8.4.1 </span>How a Join Group Uses a Common Dictionary
                  </h4>
                  <div>
                     <p>A <strong class="term">common dictionary</strong> is a table-level, instance-specific set of dictionary codes.
                     </p>
                     <p>The database automatically creates a common dictionary in the IM column store when a join group is defined on the underlying columns. The common dictionary enables the join columns to share the same dictionary codes.</p>
                     <p>A common dictionary provides the following benefits:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Encodes the values in the local dictionaries with codes from the common dictionary, which provides compression and increases the cache efficiency of the IMCU</p>
                        </li>
                        <li>
                           <p>Enables joins to use dictionary codes to construct and probe the data structures used during hash joins</p>
                        </li>
                        <li>
                           <p>Enables the optimizer to obtain statistics such as cardinality, distribution of column values, and so on</p>
                        </li>
                     </ul>
                     <p>The following figure illustrates a common dictionary that corresponds to a join group created on the <code class="codeph">sales.name</code> and <code class="codeph">vehicles.name</code> columns. 
                     </p>
                     <div class="figure" id="GUID-88A573DD-99D3-48D7-8310-B46F70184793__GUID-EDFD9FE8-3916-46BF-9F9D-227869F4B166">
                        <p class="titleinfigure">Figure 8-2 Common Dictionary for a Join Group</p><img src="img/inmem_pb_001a.png" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" longdesc="img_text/inmem_pb_001a.html"><br><a href="img_text/inmem_pb_001a.html">Description of "Figure 8-2 Common Dictionary for a Join Group"</a></div>
                     <!-- class="figure" -->
                     <p>When the database uses a common dictionary, the local dictionary for each CU does not store the original values: <code class="codeph">AUDI</code>, <code class="codeph">BMW</code>, <code class="codeph">CADILLAC</code>, <code class="codeph">FORD</code>, and so on. Instead, the local dictionary stores <span class="italic">references</span> to the values stored in the common dictionary. For example, the <span class="italic">local</span> dictionary might store the value <code class="codeph">101</code> for <code class="codeph">Audi</code> and <code class="codeph">220</code> for <code class="codeph">BMW</code>. The <span class="italic">common</span> dictionary might store the value <code class="codeph">0</code> for <code class="codeph">Audi</code> and <code class="codeph">1</code> for <code class="codeph">BMW</code>. The <code class="codeph">101</code> (AUDI) in the local dictionary is a pointer to the <code class="codeph">0</code> (AUDI) in the common dictionary.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" title="In a join group, the database compresses all columns in the join group using the same common dictionary.">How Join Groups Work</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63" name="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63"></a><h4 id="INMEM-GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63" class="sect4"><span class="enumeration_section">8.4.2 </span>How a Join Group Optimizes Scans
                  </h4>
                  <div>
                     <p>The key optimization is joining on common dictionary codes instead of column values, thereby avoiding the use of a hash table for the join.</p>
                     <p>Consider the following query, which uses a join group to join <code class="codeph">vehicles</code> and <code class="codeph">sales</code> on the <code class="codeph">name</code> column:
                     </p><pre class="pre codeblock"><code>SELECT v.year, v.name, s.sales_price
FROM   vehicles v, sales s
WHERE  v.name = s.name
AND    v.name IN ('Audi', 'BMW', 'Porsche', 'VW');</code></pre><p>The following figure illustrates how the join benefits from the common dictionary created on the join group.</p>
                     <div class="figure" id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63__GUID-F6A22D09-F119-45D9-BBDE-1E9E34631E75">
                        <p class="titleinfigure">Figure 8-3 Hash Join with Join Group</p><img src="img/inmem_3v_005.png" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" longdesc="img_text/inmem_3v_005.html"><br><a href="img_text/inmem_3v_005.html">Description of "Figure 8-3 Hash Join with Join Group"</a></div>
                     <!-- class="figure" -->
                     <div class="figure" id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63__GUID-62904BC2-650D-4E6C-A559-4182D2B7E5DE"></div>
                     <!-- class="figure" -->
                     <p>As illustrated in the preceding diagram, the database performs a hash join on the compressed data as follows:</p>
                     <ol>
                        <li>
                           <p>Scans the <code class="codeph">vehicles</code> table, and sends the dictionary codes (not the original column values) to the hash join: <code class="codeph">0</code> (Audi), <code class="codeph">1</code> (BMW), <code class="codeph">2</code> (Cadillac), and so on
                           </p>
                        </li>
                        <li>
                           <p>Builds an array of distinct common dictionary codes in the PGA</p>
                        </li>
                        <li>
                           <p>Scans the <code class="codeph">sales</code> table and applies any filters (in this case, the filter is for German cars only)
                           </p>
                        </li>
                        <li>
                           <p>Sends matching rows to the join in compressed format</p>
                        </li>
                        <li>
                           <p>Looks up corresponding values in the array rather than probing a hash table, thus avoiding the need to compute a hash function on the join key columns</p>
                        </li>
                     </ol>
                     <p>In this example, the <code class="codeph">vehicles</code> table has only seven rows. The <code class="codeph">vehicles.name</code> column has the following values:
                     </p><pre class="pre codeblock"><code>Audi
BMW
Cadillac
Ford
Porsche
Tesla
VW</code></pre><p>The common dictionary assigns a dictionary code to each distinct value. Conceptually, the common dictionary looks as follows:</p><pre class="pre codeblock"><code>Audi     0
BMW      1
Cadillac 2
Ford     3
Porsche  4
Tesla    5
VW       6
</code></pre><p>The database scans <code class="codeph">vehicles.name</code>, starting at the first dictionary code in the first IMCU and ending at the last code in the last IMCU. It stores a <code class="codeph">1</code> for every row that matches the filter (German cars only), and <code class="codeph">0</code> for every row that does not match the filter. Conceptually, the array might look as follows:
                     </p><pre class="pre codeblock"><code>array[0]: 1
array[1]: 1
array[2]: 0
array[3]: 0
array[4]: 1
array[5]: 0
array[6]: 1</code></pre><p>The database now scans the <code class="codeph">sales</code> fact table. To simplify the example, assume that the <code class="codeph">sales</code> table only has 6 rows. The database scans the rows as follows (the common dictionary code for each value is shown in parentheses):
                     </p><pre class="pre codeblock"><code>Cadillac (2)
Cadillac (2)
BMW      (1)
Ford     (3)
Audi     (0)
Tesla    (5)</code></pre><p>The database then proceeds through the <code class="codeph">vehicles.name</code> array, looking for matches. If a row matches, then the database sends the matching row with its associated common dictionary code, and retrieves the corresponding column value from the <code class="codeph">vehicles.name</code> and <code class="codeph">sales.name</code> IMCUs:
                     </p><pre class="pre codeblock"><code>2  -&gt; array[2] is 0, so no join
2  -&gt; array[2] is 0, so no join
1  -&gt; array[1] is 1, so join
3  -&gt; array[3] is 0, so no join
0  -&gt; array[0] is 1, so join
5  -&gt; array[5] is 0, so no join</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" title="In a join group, the database compresses all columns in the join group using the same common dictionary.">How Join Groups Work</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" name="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64"></a><h3 id="INMEM-GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" class="sect3"><span class="enumeration_section">8.5 </span>When a Hash Join Uses Common Dictionary Encodings
               </h3>
               <div>
                  <p>Joins on columns in a join group typically see a performance benefit.</p>
                  <p>At join group creation, the database does the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Caches the hash of the dictionary values for the join key columns</p>
                     </li>
                     <li>
                        <p>Caches the binary representation of the <code class="codeph">NUMBER</code> data for the join key columns
                        </p>
                     </li>
                     <li>
                        <p>Encodes columns with the same common dictionary</p>
                     </li>
                  </ul>
                  <p>A join on columns in a join group <span class="italic">always</span> uses the first two optimizations to improve performance. For example, if the optimizer chooses a hash join, then the query uses the cached hash values to probe the bloom filter. If the query uses an IM aggregation join, then the query uses the cached binary number to index into the key vector.
                  </p>
                  <p>A hash join may or may not use dictionary encodings. When dictionary encodings are present in at least one column of the hash join, the query can leverage the encodings in the following ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Join group-aware hash join</p>
                        <p>Both columns in the hash join carry common dictionary encoding data during runtime. The execution plan must show either a parallel hash join plan without any distribution involved from <span class="italic">both</span> sides of the hash join, or a serial hash join plan.
                        </p>
                     </li>
                     <li>
                        <p>Encoding-aware hash join</p>
                        <p>One fact table column in the hash join carries dictionary encoding data during runtime. The execution plan must show either a parallel hash join without any distribution from the right side of the hash join, or a serial hash join plan. In some cases, if the common dictionary has good compression ratio, and if a parallel hash join plan cannot leverage a join group-aware hash join (for example, in a parallel broadcast-none plan), then the query can use an encoding-aware hash join for the common dictionary.</p>
                     </li>
                  </ul>
                  <p>In a SQL Monitor report, the following fields show dictionary usage: <code class="codeph">Columnar Encodings Observed</code>, and <code class="codeph">Columnar Encodings Leveraged</code>. The statistics are cumulative. In a parallel hash join, the fields summarize statistics collected from all slave processes involved in executing a row source. In the context of the local dictionary in an IMCU, the statistics show the number of encoding IDs observed from the right child row source and the number of encodings leveraged by the join. If a hash join on a single process leverages the common dictionary, then <code class="codeph">Columnar Encodings Leveraged</code> shows the number of encodings leveraged in the join.<code class="codeph"></code></p>
                  <p>The following table indicates the possible values for <code class="codeph">Columnar Encodings Observed</code> and <code class="codeph">Columnar Encodings Leveraged</code>, and what the combinations mean.
                  </p>
                  <div class="tblformal" id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64__GUID-33F19E11-C1EB-4FB3-8E8C-35C2A70FA52D">
                     <p class="titleintable">Table 8-1 Join Group Usage in a SQL Monitor Report</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Join Group Usage in a SQL Monitor Report" summary="This table describes when a hash join uses dictionary encodings" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" id="d24838e1395">Columnar Encodings Observed</th>
                              <th align="left" valign="bottom" id="d24838e1397">Columnar Encodings Leveraged</th>
                              <th align="left" valign="bottom" id="d24838e1399">Encoding-Aware Hash Join Used?</th>
                              <th align="left" valign="bottom" id="d24838e1401">Join Group-Aware Hash Join Used?</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1405" headers="d24838e1395 ">
                                 <p>Not present</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1397 ">
                                 <p>Not present</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1399 ">
                                 <p>No</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1401 ">
                                 <p>No</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1418" headers="d24838e1395 ">
                                 <p>Positive value</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1397 ">
                                 <p>Not present</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1399 ">
                                 <p>No</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1401 ">
                                 <p>No</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1431" headers="d24838e1395 ">
                                 <p>Positive value</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1397 ">
                                 <p>Positive value</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1399 ">
                                 <p>Yes</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1401 ">
                                 <p>No</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1444" headers="d24838e1395 ">
                                 <p>Not present</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1397 ">
                                 <p>Positive value</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1399 ">
                                 <p>No</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1401 ">
                                 <p>Yes</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>For example, if the report shows that the <code class="codeph">Columnar Encodings Leveraged</code> field is <code class="codeph">4</code> (for example, because the parallel degree is 4) but the <code class="codeph">Columnar Encodings Observed</code> field is absent, then the query leveraged the join group for the hash join. If the <code class="codeph">Columnar Encodings Observed</code> field is <code class="codeph">4</code> but the <code class="codeph">Columnar Encodings Leveraged</code> field is absent, then dictionary encodings existed, but the query did not use them.
                  </p>
                  <p>Various factors can prevent a query from engaging an encoding-aware hash join. Factors include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The compression ratio of the common dictionary is suboptimal.</p>
                     </li>
                     <li>
                        <p>The query observes too many row sets passed from the table scan without a common dictionary.</p>
                     </li>
                     <li>
                        <p>The build-side row length is too large.</p>
                     </li>
                     <li>
                        <p>The build-side rows cannot fit into PGA memory.</p>
                     </li>
                     <li>
                        <p>The build side has duplicate join keys.</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64__GUID-7FFF20F7-9A99-40A3-968F-284A2B25FBEC">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="To determine whether queries are using the join group, you can use either a graphical SQL Monitor report (recommended) or a SQL query that uses the DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML function.">Monitoring Join Group Usage</a>"</span></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74" name="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74"></a><h3 id="INMEM-GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74" class="sect3"><span class="enumeration_section">8.6 </span>Creating Join Groups
               </h3>
               <div>
                  <p>Define join groups using the <code class="codeph">CREATE INMEMORY JOIN GROUP</code> statement. 
                  </p>
                  <div class="section">
                     <p>Candidates for join groups are columns that are frequently paired in a join predicate. Typical examples include a column joining a fact and dimension table, or a column joining a table to itself.</p>
                     <p>The <code class="codeph">CREATE INMEMORY JOIN GROUP</code> statement immediately defines a join group, which means that its metadata is visible in the data dictionary. The database does not immediately construct the common dictionary. Rather, the database builds the common dictionary the next time that a table referenced in the join group is populated or repopulated in the IM column store.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-FD391BEF-F6C8-4F48-8C1F-CC77A158B6EE">Guidelines</p>
                     <p>Creating, modifying, or dropping a join group typically invalidates all the underlying tables referenced in the join group. Thus, Oracle recommends that you create join groups <span class="italic">before</span> initially populating the tables.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-F9BF7619-09C1-4475-9F73-83AA019B4083">To create a join group:</p>
                     <ol>
                        <li>
                           <p>In SQL*Plus or SQL Developer, log in to the database as a user with the necessary privileges.</p>
                        </li>
                        <li>
                           <p>Create a join group by using a statement in the following form:</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP <span class="italic">join_group_name</span> ( <span class="italic">table1</span>(<span class="italic">col1</span>), <span class="italic">table2</span>(<span class="italic">col2</span>) );</code></pre><p>For example, the following statement creates a join group named <code class="codeph">sales_products_jg</code>:
                           </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP sales_products_jg (sales(prod_id), products(prod_id));</code></pre></li>
                        <li>
                           <p>Optionally, view the join group definition by querying the data dictionary (sample output included):</p><pre class="pre codeblock"><code>COL JOINGROUP_NAME FORMAT a18
COL TABLE_NAME FORMAT a8
COL COLUMN_NAME FORMAT a7

SELECT JOINGROUP_NAME, TABLE_NAME, COLUMN_NAME, GD_ADDRESS 
FROM   DBA_JOINGROUPS;

JOINGROUP_NAME     TABLE_NA COLUMN_ GD_ADDRESS
------------------ -------- ------- ----------------
SALES_PRODUCTS_JG  SALES    PROD_ID 00000000A142AE50
SALES_PRODUCTS_JG  PRODUCTS PROD_ID 00000000A142AE50</code></pre></li>
                        <li>
                           <p>Populate the tables referenced in the join group, or repopulate them if they are currently populated.</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-433C0743-8571-4517-AB19-5F33402BCDAA">
                     <p class="titleinexample">Example 8-2 Optimizing a Query Using a Join Group</p>
                     <p>In this example,  you log in to the database as <code class="codeph">SYSTEM</code>, and then create a join group on the <code class="codeph">prod_id</code> column of <code class="codeph">sales</code> and <code class="codeph">products</code>, which are not yet populated in the IM column store:
                     </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP 
  sh.sales_products_jg (sh.sales(prod_id), sh.products(prod_id));
</code></pre><p>You enable the <code class="codeph">sh.sales</code> and <code class="codeph">sh.products</code> tables for population in the IM column store:
                     </p><pre class="pre codeblock"><code>ALTER TABLE sh.sales INMEMORY;
ALTER TABLE sh.products INMEMORY;</code></pre><p>The following query indicates the tables are not yet populated in the IM column store (sample output included):</p><pre class="pre codeblock"><code>COL OWNER FORMAT a3
COL NAME FORMAT a10
COL STATUS FORMAT a20

SELECT OWNER, SEGMENT_NAME NAME,
       POPULATE_STATUS STATUS
FROM   V$IM_SEGMENTS;

no rows selected</code></pre><p>Query both tables to populate them in the IM column store:</p><pre class="pre codeblock"><code>SELECT /*+ FULL(s) NO_PARALLEL(s) */ COUNT(*) FROM sh.sales s;
SELECT /*+ FULL(p) NO_PARALLEL(p) */ COUNT(*) FROM sh.products p;
</code></pre><p>The following query indicates the tables are now populated in the IM column store (sample output included):</p><pre class="pre codeblock"><code>COL OWNER FORMAT a3
COL NAME FORMAT a10
COL PARTITION FORMAT a13
COL STATUS FORMAT a20

SELECT OWNER, SEGMENT_NAME NAME, PARTITION_NAME PARTITION,
       POPULATE_STATUS STATUS, BYTES_NOT_POPULATED
FROM   V$IM_SEGMENTS;

OWN NAME       PARTITION     STATUS               BYTES_NOT_POPULATED
--- ---------- ------------- -------------------- -------------------
SH  SALES      SALES_Q3_1998 COMPLETED            0
SH  SALES      SALES_Q4_2001 COMPLETED            0
SH  SALES      SALES_Q4_1999 COMPLETED            0
SH  PRODUCTS                 COMPLETED            0
SH  SALES      SALES_Q1_2001 COMPLETED            0
SH  SALES      SALES_Q1_1999 COMPLETED            0
SH  SALES      SALES_Q2_2000 COMPLETED            0
SH  SALES      SALES_Q2_1998 COMPLETED            0
SH  SALES      SALES_Q3_2001 COMPLETED            0
SH  SALES      SALES_Q3_1999 COMPLETED            0
SH  SALES      SALES_Q4_2000 COMPLETED            0
SH  SALES      SALES_Q4_1998 COMPLETED            0
SH  SALES      SALES_Q1_2000 COMPLETED            0
SH  SALES      SALES_Q1_1998 COMPLETED            0
SH  SALES      SALES_Q2_2001 COMPLETED            0
SH  SALES      SALES_Q2_1999 COMPLETED            0
SH  SALES      SALES_Q3_2000 COMPLETED            0
</code></pre><p>Query <code class="codeph">DBA_JOINGROUPS</code> to get information about the join group (sample output included):
                     </p><pre class="pre codeblock"><code>COL JOINGROUP_NAME FORMAT a18
COL TABLE_NAME FORMAT a8
COL COLUMN_NAME FORMAT a7

SELECT JOINGROUP_NAME, TABLE_NAME, COLUMN_NAME, GD_ADDRESS 
FROM   DBA_JOINGROUPS;

JOINGROUP_NAME     TABLE_NA COLUMN_ GD_ADDRESS
------------------ -------- ------- ----------------
SALES_PRODUCTS_JG  SALES    PROD_ID 00000000A142AE50
SALES_PRODUCTS_JG  PRODUCTS PROD_ID 00000000A142AE50
</code></pre><p>The preceding output shows that the join group <code class="codeph">sales_products_jg</code> joins on the same common dictionary address.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-7612DCEE-ACBA-4551-8203-B86FFE6734BF">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../sqlrf/CREATE-INMEMORY-JOIN-GROUP.html#SQLRF-GUID-87CA7034-4F80-4D46-8EE1-5CC865C2D676" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">CREATE INMEMORY JOIN GROUP</code> statement
                           </p>
                        </li>
                        <li>
                           <p><a href="../refrn/DBA_JOINGROUPS.html#GUID-285814BC-3BE0-47DA-8832-779229D5A93A" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">DBA_JOINGROUPS</code> view
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" name="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1"></a><h3 id="INMEM-GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" class="sect3"><span class="enumeration_section">8.7 </span>Monitoring Join Group Usage
               </h3>
               <div>
                  <p>To determine whether queries are using the join group, you can use either a graphical SQL Monitor report (recommended) or a SQL query that uses the <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> function.
                  </p>
                  <div class="section">
                     <p><span class="q">"<a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="Joins on columns in a join group typically see a performance benefit.">When a Hash Join Uses Common Dictionary Encodings</a>"</span> explains how to interpret the SQL Monitor output.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1__GUID-6F09B066-9BAC-4AAA-92CB-4B7D7D240221">Prerequisites</p>
                     <p>To monitor join groups, you must meet the following prerequisites:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A join group must exist.</p>
                        </li>
                        <li>
                           <p>The columns referenced by the join group must have been populated <span class="italic">after</span> join group creation.
                           </p>
                        </li>
                        <li>
                           <p>You must execute a join query that could potentially use the join group.</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1__GUID-6D62F80B-334C-4684-99D9-028A3CD859BD">To monitor join group usage:</p>
                     <ol>
                        <li>
                           <p>Log in to the database as a user with the necessary privileges.</p>
                        </li>
                        <li>
                           <p>Create a SQL*Plus variable to store the SQL ID as follows:</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2(13)</code></pre></li>
                        <li>
                           <p>Execute a query that joins on the columns in the join group.</p>
                        </li>
                        <li>
                           <p>Use either following techniques:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Graphical SQL Monitor Report</p>
                                 <p>SQL Monitor reports are available in Enterprise Manager. In SQL*Plus, you can use <code class="codeph">DBMS_SQL_MONITOR.REPORT_SQL_MONITOR</code> to generate a SQL Monitor report as follows:
                                 </p><pre class="pre codeblock"><code>SET TRIMSPOOL ON
SET TRIM ON
SET PAGES 0
SET LINESIZE 1000
SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SPOOL /tmp/long_sql.htm
SELECT DBMS_SQL_MONITOR.REPORT_SQL_MONITOR(
         sql_id       =&gt; :<span class="bold">b_sqlid</span>, 
         report_level =&gt; 'ALL', 
         TYPE         =&gt; 'active') 
FROM   DUAL;
SPOOL OFF</code></pre><p>Access the report in a browser, and then click the binoculars icon on the hash join to view the join group statistics.</p>
                              </li>
                              <li>
                                 <p>Command-Line Query</p>
                                 <p>Use the <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> function in a query, as shown in the following example:
                                 </p><pre class="pre codeblock"><code>SELECT
  encoding_hj.rowsource_id row_source_id,
    CASE
      WHEN encoding_hj.encodings_observed IS NULL     
      AND encoding_hj.encodings_leveraged IS NOT NULL 
      THEN
        'join group was leveraged on ' || encoding_hj.encodings_leveraged || ' processes'
      ELSE
        'join group was NOT leveraged'
    END columnar_encoding_usage_info
FROM
  (SELECT DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML(session_id=&gt;-1,sql_id=&gt;:<span class="bold">b_sqlid</span>).
          EXTRACT(q'#//operation[@name='HASH JOIN' and @parent_id]#') xmldata
   FROM   DUAL) hj_operation_data,
  XMLTABLE('/operation'
    PASSING hj_operation_data.xmldata
    COLUMNS
     "ROWSOURCE_ID"        NUMBER PATH '@id',
     "ENCODINGS_LEVERAGED" NUMBER PATH 'rwsstats/stat[@id="9"]',
     "ENCODINGS_OBSERVED"  NUMBER PATH 'rwsstats/stat[@id="10"]') encoding_hj;</code></pre></li>
                           </ul>
                        </li>
                     </ol>
                     <p>The following sections demonstrate both techniques for obtaining join group usage information:</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC">Monitoring Join Groups Using a SQL Monitor Report: Example</a><br>Your goal is to use a graphical SQL Monitor report to determine whether a query leveraged a join group.
                     </li>
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1">Monitoring Join Groups from the Command Line: Example</a><br>Your goal is to use command-line tools to determine whether a query leveraged a join group.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined.">Optimizing Joins with Join Groups</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC" name="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC"></a><h4 id="INMEM-GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC" class="sect4"><span class="enumeration_section">8.7.1 </span>Monitoring Join Groups Using a SQL Monitor Report: Example
                  </h4>
                  <div>
                     <p>Your goal is to use a graphical SQL Monitor report to determine whether a query leveraged a join group.</p>
                     <div class="section">
                        <p>In this example, you create a join group on the <code class="codeph">prod_id</code> columns of <code class="codeph">sh.products</code> and <code class="codeph">sh.sales</code> tables, and then join these tables on this column. You grant the <code class="codeph">sh</code> account administrative privileges. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__MONITORINGAJOINGROUP-4943C700">
                        <p class="titleinexample">Example 8-3 Monitoring a Join Group Using a SQL Monitor Report</p>
                        <ol>
                           <li>
                              <p>In SQL*Plus, log in to the database as user <code class="codeph">sh</code>.
                              </p>
                           </li>
                           <li>
                              <p>Create a SQL*Plus variable to store the SQL ID as follows:</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2(13)</code></pre></li>
                           <li>
                              <p>Apply the <code class="codeph">INMEMORY</code> attribute to the <code class="codeph">sh.products</code> and <code class="codeph">sh.sales</code> tables as follows:
                              </p><pre class="pre codeblock"><code>ALTER TABLE sales NO INMEMORY;
ALTER TABLE products NO INMEMORY;

ALTER TABLE sales INMEMORY MEMCOMPRESS FOR QUERY;
ALTER TABLE products INMEMORY MEMCOMPRESS FOR QUERY;
</code></pre></li>
                           <li>
                              <p>Create a join group on <code class="codeph">prod_id</code>:
                              </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP jgrp_products_sales (products(prod_id), sales(prod_id)); </code></pre></li>
                           <li>
                              <p>Scan the tables to populate them in the IM column store:</p><pre class="pre codeblock"><code>SELECT /*+ FULL(s) */ COUNT(*) FROM sales s;
SELECT /*+ FULL(p) */ COUNT(*) FROM products p;</code></pre></li>
                           <li>
                              <p>Execute a query that joins on the <code class="codeph">prod_id</code> column, and then aggregates product sales:
                              </p><pre class="pre codeblock"><code>SELECT /*+ USE_HASH(sales) LEADING(products sales) MONITOR */ products.prod_id, 
       products.prod_category_id, SUM(sales.amount_sold) 
FROM   products, sales 
WHERE  products.prod_id = sales.prod_id 
GROUP BY products.prod_category_id, products.prod_id;</code></pre></li>
                           <li>
                              <p>Generate an HTML-based SQL Monitor report by using <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR</code>.
                              </p>
                              <p>For example, create a SQL script with the following contents, and run it in SQL*Plus:</p><pre class="pre codeblock"><code>SET TRIMSPOOL ON
SET TRIM ON
SET PAGES 0
SET LINESIZE 1000
SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SPOOL /tmp/jg_report.htm
SELECT DBMS_SQL_MONITOR.REPORT_SQL_MONITOR(
         sql_id       =&gt; :b_sqlid, 
         report_level =&gt; 'ALL', 
         TYPE         =&gt; 'active') 
FROM   DUAL;
SPOOL OFF</code></pre></li>
                           <li>
                              <p>Open the HTML report in a browser.</p>
                              <p>The following sample report shows the execution plan for the join. The binoculars in the hash join open a window that shows additional statistics.</p>
                              <div class="figure" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-288CAD91-6046-4B7C-AAAE-D3ED916DA306">
                                 <p class="titleinfigure">Figure 8-4 Monitored SQL Execution Details Page</p><img src="img/sql_monitor_jg.png" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows" longdesc="img_text/sql_monitor_jg.html"><br><a href="img_text/sql_monitor_jg.html">Description of "Figure 8-4 Monitored SQL Execution Details Page"</a></div>
                              <!-- class="figure" -->
                           </li>
                           <li>
                              <p>Click the binoculars icon to open a window that shows join group statistics.</p>
                              <p>The following sample window shows the statistics:</p>
                              <div class="figure" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-8613B645-AD08-40AC-A381-67982FA82335"><img src="img/other_plan_line_stats.png" alt="Description of other_plan_line_stats.png follows" title="Description of other_plan_line_stats.png follows" longdesc="img_text/other_plan_line_stats.html"><br><a href="img_text/other_plan_line_stats.html">Description of the illustration other_plan_line_stats.png</a></div>
                              <!-- class="figure" -->
                              <p>Because <code class="codeph">Columnar Encodings Leveraged</code> is a positive value and <code class="codeph">Columnar Encodings Observed</code> is not present, the join group was leveraged.
                              </p>
                           </li>
                           <li>
                              <p>Optionally, clean up after the example:</p><pre class="pre codeblock"><code>DROP INMEMORY JOIN GROUP jgrp_products_sales;
ALTER TABLE sales NO INMEMORY;
ALTER TABLE products NO INMEMORY;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-D82CCE85-3ABB-4DE9-A617-6CC4E6A592F1">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="Joins on columns in a join group typically see a performance benefit.">When a Hash Join Uses Common Dictionary Encodings</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#GUID-DA3BD815-42EE-4CF4-8C59-9C40332D66C5" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn about the <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> function
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/V-SESSION.html#GUID-28E2DC75-E157-4C0A-94AB-117C205789B9" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">V$SESSION</code> view
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="To determine whether queries are using the join group, you can use either a graphical SQL Monitor report (recommended) or a SQL query that uses the DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML function.">Monitoring Join Group Usage</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1" name="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1"></a><h4 id="INMEM-GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1" class="sect4"><span class="enumeration_section">8.7.2 </span>Monitoring Join Groups from the Command Line: Example
                  </h4>
                  <div>
                     <p>Your goal is to use command-line tools to determine whether a query leveraged a join group.</p>
                     <div class="section">
                        <p>In this example, you create a join group on the <code class="codeph">prod_id</code> columns of <code class="codeph">sh.products</code> and <code class="codeph">sh.sales</code> tables, and then join these tables on this column. You grant the <code class="codeph">sh</code> account administrative privileges. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1__MONITORINGAJOINGROUP-4943C700">
                        <p class="titleinexample">Example 8-4 Monitoring a Join Group from the Command Line</p>
                        <ol>
                           <li>
                              <p>Log in to the database as <code class="codeph">sh</code>.
                              </p>
                           </li>
                           <li>
                              <p>Create a SQL*Plus variable to store the SQL ID as follows:</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2(13)</code></pre></li>
                           <li>
                              <p>Apply the <code class="codeph">INMEMORY</code> attribute to the <code class="codeph">sh.products</code> and <code class="codeph">sh.sales</code> tables as follows:
                              </p><pre class="pre codeblock"><code>ALTER TABLE sales NO INMEMORY;
ALTER TABLE products NO INMEMORY;

ALTER TABLE sales INMEMORY MEMCOMPRESS FOR QUERY;
ALTER TABLE products INMEMORY MEMCOMPRESS FOR QUERY;
</code></pre></li>
                           <li>
                              <p>Create a join group on <code class="codeph">prod_id</code>:
                              </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP jgrp_products_sales (products(prod_id), sales(prod_id)); </code></pre></li>
                           <li>
                              <p>Scan the tables to populate them in the IM column store:</p><pre class="pre codeblock"><code>SELECT /*+ FULL(s) */ COUNT(*) FROM sales s;
SELECT /*+ FULL(p) */ COUNT(*) FROM products p;</code></pre></li>
                           <li>
                              <p>Execute a query that joins on the <code class="codeph">prod_id</code> column, and then aggregates product sales:
                              </p><pre class="pre codeblock"><code>SELECT /*+ USE_HASH(sales) LEADING(products sales) MONITOR */ products.prod_id, 
       products.prod_category_id, SUM(sales.amount_sold) 
FROM   products, sales 
WHERE  products.prod_id = sales.prod_id 
GROUP BY products.prod_category_id, products.prod_id;</code></pre></li>
                           <li>
                              <p>Obtain the SQL ID of the preceding aggregation query:</p><pre class="pre codeblock"><code>BEGIN
  SELECT PREV_SQL_ID 
    INTO :b_sqlid
  FROM   V$SESSION 
  WHERE  SID=USERENV('SID');
END;
</code></pre></li>
                           <li>
                              <p>Use <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> to determine whether the database used the join group.
                              </p>
                              <p>For example, execute the following query:</p><pre class="pre codeblock"><code>COL row_source_id FORMAT 999
COL columnar_encoding_usage_info FORMAT A40

SELECT
  encoding_hj.rowsource_id row_source_id,
    CASE
      WHEN encoding_hj.encodings_observed IS NULL     
      AND encoding_hj.encodings_leveraged IS NOT NULL 
      THEN
        'join group was leveraged on ' || encoding_hj.encodings_leveraged || ' processes'
      ELSE
        'join group was NOT leveraged'
    END columnar_encoding_usage_info
FROM
  (SELECT DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML(session_id=&gt;-1,sql_id=&gt;:b_sqlid).
          EXTRACT(q'#//operation[@name='HASH JOIN' and @parent_id]#') xmldata
   FROM   DUAL
  ) hj_operation_data,
  XMLTABLE('/operation'
    PASSING hj_operation_data.xmldata
    COLUMNS
     "ROWSOURCE_ID"       NUMBER PATH '@id',
     "ENCODINGS_LEVERAGED" NUMBER PATH 'rwsstats/stat[@id="9"]',
     "ENCODINGS_OBSERVED"  NUMBER PATH 'rwsstats/stat[@id="10"]'
     ) encoding_hj;</code></pre><p>The following sample output shows that the join group was leveraged in the query:</p><pre class="pre codeblock"><code>ROW_SOURCE_ID COLUMNAR_ENCODING_USAGE_INFO
------------- ----------------------------------------
            2 join group was leveraged on 1 processes</code></pre></li>
                           <li>
                              <p>Optionally, clean up after the example:</p><pre class="pre codeblock"><code>DROP INMEMORY JOIN GROUP jgrp_products_sales;
ALTER TABLE sales NO INMEMORY;
ALTER TABLE products NO INMEMORY;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1__GUID-D82CCE85-3ABB-4DE9-A617-6CC4E6A592F1">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="Joins on columns in a join group typically see a performance benefit.">When a Hash Join Uses Common Dictionary Encodings</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#GUID-DA3BD815-42EE-4CF4-8C59-9C40332D66C5" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn about the <code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code> function
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-28E2DC75-E157-4C0A-94AB-117C205789B9" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">V$SESSION</code> view
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="To determine whether queries are using the join group, you can use either a graphical SQL Monitor report (recommended) or a SQL query that uses the DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML function.">Monitoring Join Group Usage</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>