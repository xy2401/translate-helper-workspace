<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Datatypes and Host Variables</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="database-concepts.html" title="Previous" type="text/html">
      <link rel="next" href="advanced-topics.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="database-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="advanced-topics.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name"> Introduction and Concepts </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Datatypes and Host Variables</li>
            </ol>
            <a id="GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC" name="GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC"></a><a id="LNPCC3154"></a>
            
            <h2 id="LNPCC-GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC" class="sect2"><span class="enumeration_chapter">4 </span> Datatypes and Host Variables
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter provides the basic information you need to write a Pro*C/C++ program. This chapter contains the following topics: </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED">Oracle Datatypes </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-EAD2DF4C-63FF-4B67-9673-490128B98D85">Host Variables </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-1A9B5679-B15F-4869-8B7A-598BABEA3873">Indicator Variables   </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-33AC6FC8-EA9D-4C7F-ADAC-D01A0DF4E281">VARCHAR Variables </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-8561AF60-861B-4EA6-8ECF-EF460FDD3A76">Cursor Variables </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-4AF4D5FD-C41E-4597-BC33-6CF0266A5E84">CONTEXT Variables</a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367">Universal ROWIDs</a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-755B5F00-C7D7-4F3F-87FD-2AF5E5703D36">Host Structures </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8">Pointer Variables </a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3">Globalization Support</a></p>
                  </li>
                  <li>
                     <p><a href="datatypes-and-host-variables.html#GUID-B7DF37DC-3027-47E3-8F51-1910BAEF7E52">NCHAR Variables</a></p>
                  </li>
               </ul>
               <p>This chapter also includes several complete demonstration programs that you can study. These programs illustrate the techniques described. They are available on-line in your <code class="codeph">demo</code> directory, so you can compile and run them, and modify them for your own uses.
               </p>
            </div><a id="LNPCC3155"></a><div class="props_rev_3"><a id="GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED" name="GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED"></a><h3 id="LNPCC-GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED" class="sect3"><span class="enumeration_section">4.1 </span>Oracle Datatypes 
               </h3>
               <div>
                  <p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores column values in database tables, as well as the formats used to represent pseudocolumn values such as NULL, SYSDATE, USER, and so on. External datatypes specify the formats used to store values in input and output host variables. 
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="../sqlrf/Data-Types.html#SQLRF-GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6" target="_blank"><span class="italic">Oracle Built-in Data Types</span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3157"></a><a id="LNPCC3156"></a><div class="props_rev_3"><a id="GUID-76259B54-2C1C-4673-81F5-E02F636D26F1" name="GUID-76259B54-2C1C-4673-81F5-E02F636D26F1"></a><h4 id="LNPCC-GUID-76259B54-2C1C-4673-81F5-E02F636D26F1" class="sect4"><span class="enumeration_section">4.1.1 </span>Internal Datatypes
                  </h4>
                  <div>
                     <div class="section">
                        <p>For values stored in database columns, Oracle uses the internal datatypes shown in <a href="datatypes-and-host-variables.html#GUID-76259B54-2C1C-4673-81F5-E02F636D26F1__G39946" title="Oracle Internal Types">Table 4-1</a></p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-76259B54-2C1C-4673-81F5-E02F636D26F1__G39946">
                        <p class="titleintable">Table 4-1 Oracle Internal Datatypes</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Internal Datatypes" summary="Oracle Internal Types" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d16109e130">Name</th>
                                 <th align="left" valign="bottom" width="77%" id="d16109e133">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e138" headers="d16109e130 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e138 d16109e133 ">
                                    <p>Variable-length character string, &lt;= 4000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e145" headers="d16109e130 ">
                                    <p>NVARCHAR2 or NCHAR VARYING</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e145 d16109e133 ">
                                    <p>Variable-length single-byte or National Character string,&lt;= 4000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e152" headers="d16109e130 ">
                                    <p>NUMBER</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e152 d16109e133 ">
                                    <p>Numeric value having precision and scale, represented in a base-100 format.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e159" headers="d16109e130 ">
                                    <p>LONG</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e159 d16109e133 ">
                                    <p>Variable-length character string &lt;=2**31-1 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e166" headers="d16109e130 ">
                                    <p>BINARY_FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e166 d16109e133 ">
                                    <p>32-bit floating point number, 4 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e173" headers="d16109e130 ">
                                    <p>BINARY_DOUBLE</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e173 d16109e133 ">
                                    <p>64-bit floating point number, 8 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e180" headers="d16109e130 ">
                                    <p>TIMESTAMP</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e180 d16109e133 ">
                                    <p>Year, month, and day values of date, as well as hour, minute, and second values of time, 7 or 11 bytes. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e187" headers="d16109e130 ">
                                    <p>DATE</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e187 d16109e133 ">
                                    <p>Fixed-length date + time value, 7 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e194" headers="d16109e130 ">
                                    <p>INTERVAL YEAR</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e194 d16109e133 ">
                                    <p>Stores a period of time in years and months,  5 bytes. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e201" headers="d16109e130 ">
                                    <p>INTERVAL DAY</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e201 d16109e133 ">
                                    <p>Stores a period of time in days, hours, minutes, and seconds, 11 bytes. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e208" headers="d16109e130 ">
                                    <p>RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e208 d16109e133 ">
                                    <p>Variable-length binary data, &lt;=2000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e216" headers="d16109e130 ">
                                    <p>LONG RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e216 d16109e133 ">
                                    <p>Variable-length binary data, &lt;=2**31-1 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e223" headers="d16109e130 ">
                                    <p>ROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e223 d16109e133 ">
                                    <p>Binary value.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e230" headers="d16109e130 ">
                                    <p>UROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e230 d16109e133 ">
                                    <p>Binary value, &lt;=4000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e237" headers="d16109e130 ">
                                    <p>CHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e237 d16109e133 ">
                                    <p>Fixed-length character string, &lt;=2000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e244" headers="d16109e130 ">
                                    <p>NCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e244 d16109e133 ">
                                    <p>Fixed-length single-byte or National Character string, &lt;= 2000 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e251" headers="d16109e130 ">
                                    <p>CLOB</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e251 d16109e133 ">
                                    <p>Character data, &lt;= 4 Gbytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e258" headers="d16109e130 ">
                                    <p>NCLOB</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e258 d16109e133 ">
                                    <p>National Character Set data, &lt;= 4 Gbytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e265" headers="d16109e130 ">
                                    <p>BLOB</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e265 d16109e133 ">
                                    <p>Binary data, &lt;= 4 Gbytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d16109e272" headers="d16109e130 ">
                                    <p>BFILE</p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d16109e272 d16109e133 ">
                                    <p>External file binary data, &lt;= 4 Gbytes.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>These internal datatypes can be quite different from C datatypes. For example, C has no datatype that is equivalent to the Oracle NUMBER datatype. However, NUMBERs can be converted between C datatypes such as <span class="bold">float</span> and<span class="bold"> double</span>, with some restrictions. For example, the Oracle NUMBER datatype allows up to 38 decimal digits of precision, while no current C implementations can represent <span class="bold">double</span> with that degree of precision. 
                        </p>
                        <p>The Oracle NUMBER datatype represents values exactly (within the precision limits), while floating-point formats cannot represent values such as 10.0 exactly.</p>
                        <p>Use the LOB datatypes to store unstructured data (text, graphic images, video clips, or sound waveforms). BFILE data is stored in an operating system file outside the database. LOB types store <span class="italic">locators</span> that specify the location of the data. 
                        </p>
                        <p>NCHAR and NVARCHAR2 are used to store multibyte character data.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">LOBs</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3159"></a><a id="LNPCC3158"></a><div class="props_rev_3"><a id="GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952" name="GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952"></a><h4 id="LNPCC-GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952" class="sect4"><span class="enumeration_section">4.1.2 </span>External Datatypes
                  </h4>
                  <div>
                     <p>As shown in <a href="datatypes-and-host-variables.html#GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952__g39803" title="Oracle External Datatypes">Table 4-2</a>, the external datatypes include all the internal datatypes plus several datatypes that closely match C constructs. For example, the STRING external datatype refers to a C null-terminated string.
                     </p>
                     <div class="tblformal" id="GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952__g39803">
                        <p class="titleintable">Table 4-2  Oracle External Datatypes</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title=" Oracle External Datatypes" summary="Oracle External Datatypes" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="24%" id="d16109e336">Name</th>
                                 <th align="left" valign="bottom" width="76%" id="d16109e339">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e344" headers="d16109e336 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e344 d16109e339 ">
                                    <p>Variable-length character string, &lt;= 65535 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e351" headers="d16109e336 ">
                                    <p>NUMBER</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e351 d16109e339 ">
                                    <p>Decimal number, represented using a base-100 format.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e358" headers="d16109e336 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e358 d16109e339 ">
                                    <p>Signed integer.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e365" headers="d16109e336 ">
                                    <p>FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e365 d16109e339 ">
                                    <p>Real number.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e372" headers="d16109e336 ">
                                    <p>STRING</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e372 d16109e339 ">
                                    <p>Null-terminated variable length character string.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e379" headers="d16109e336 ">
                                    <p>VARNUM</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e379 d16109e339 ">
                                    <p>Decimal number, like NUMBER, but includes representation length component.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e386" headers="d16109e336 ">
                                    <p>LONG</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e386 d16109e339 ">
                                    <p>Fixed-length character string, up to 2**31-1 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e393" headers="d16109e336 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e393 d16109e339 ">
                                    <p>Variable-length character string, &lt;= 65533 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e400" headers="d16109e336 ">
                                    <p>ROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e400 d16109e339 ">
                                    <p>Binary value, external length is system dependent.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e407" headers="d16109e336 ">
                                    <p>DATE</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e407 d16109e339 ">
                                    <p>Fixed-length date/time value, 7 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e414" headers="d16109e336 ">
                                    <p>VARRAW</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e414 d16109e339 ">
                                    <p>Variable-length binary data, &lt;= 65533 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e422" headers="d16109e336 ">
                                    <p>RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e422 d16109e339 ">
                                    <p>Fixed-length binary data, &lt;= 65535 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e429" headers="d16109e336 ">
                                    <p>LONG RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e429 d16109e339 ">
                                    <p>Fixed-length binary data, &lt;= 2**31-1 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e436" headers="d16109e336 ">
                                    <p>UNSIGNED</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e436 d16109e339 ">
                                    <p>Unsigned integer.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e443" headers="d16109e336 ">
                                    <p>LONG VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e443 d16109e339 ">
                                    <p>Variable-length character string, &lt;=â€ƒ2**31-5 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e450" headers="d16109e336 ">
                                    <p>LONG VARRAW</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e450 d16109e339 ">
                                    <p>Variable-length binary data, &lt;= 2**31-5 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e457" headers="d16109e336 ">
                                    <p>CHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e457 d16109e339 ">
                                    <p>Fixed-length character string, &lt;= 65535 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e464" headers="d16109e336 ">
                                    <p>CHARZ</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e464 d16109e339 ">
                                    <p>Fixed-length, null-terminated character string, &lt;= 65534 bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e471" headers="d16109e336 ">
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="76%" headers="d16109e471 d16109e339 ">
                                    <p>Used in TYPE or VAR statements to force CHAR to default to CHAR, instead of VARCHAR2 or CHARZ.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Brief descriptions of the Oracle datatypes follow. </p>
                  </div><a id="LNPCC3160"></a><div class="props_rev_3"><a id="GUID-DD134B61-14E1-44E9-A8B1-F23AC2C9317A" name="GUID-DD134B61-14E1-44E9-A8B1-F23AC2C9317A"></a><h5 id="LNPCC-GUID-DD134B61-14E1-44E9-A8B1-F23AC2C9317A" class="sect5"><span class="enumeration_section">4.1.2.1 </span>VARCHAR2 
                     </h5>
                     <div>
                        <p>You use the VARCHAR2 datatype to store variable-length character strings. The maximum length of a VARCHAR2 value is 64K bytes.</p>
                        <p>You specify the maximum length of a VARCHAR2(<span class="italic">n</span>) value in bytes, not characters. So, if a VARCHAR2(<span class="italic">n</span>) variable stores multibyte characters, its maximum length can be less than <span class="italic">n</span> characters.
                        </p>
                        <p>When you precompile using the option CHAR_MAP=VARCHAR2, Oracle assigns the VARCHAR2 datatype to all host variables that you declare as <span class="bold">char[n] </span>or<span class="bold"> char.</span></p>
                     </div><a id="LNPCC3161"></a><div class="props_rev_3"><a id="GUID-657E810C-A55E-4888-81A2-1DB9DCF0C226" name="GUID-657E810C-A55E-4888-81A2-1DB9DCF0C226"></a><h6 id="LNPCC-GUID-657E810C-A55E-4888-81A2-1DB9DCF0C226" class="sect6"><span class="enumeration_section">4.1.2.1.1 </span>On Input
                        </h6>
                        <div>
                           <p>Oracle reads the number of bytes specified for the input host variable, strips any trailing blanks, then stores the input value in the target database column. Be careful. An uninitialized host variable can contain NULLs. So, always blank-pad a character input host variable to its declared length, and do not null-terminate it.</p>
                           <p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value contains nothing but blanks, Oracle treats it like a NULL. </p>
                           <p>Oracle can convert a character value to a NUMBER column value if the character value represents a valid number. Otherwise, Oracle generates an error. </p>
                        </div>
                     </div><a id="LNPCC3162"></a><div class="props_rev_3"><a id="GUID-FE3989DC-3E1B-42A2-B7ED-0C7FB4A6A08B" name="GUID-FE3989DC-3E1B-42A2-B7ED-0C7FB4A6A08B"></a><h6 id="LNPCC-GUID-FE3989DC-3E1B-42A2-B7ED-0C7FB4A6A08B" class="sect6"><span class="enumeration_section">4.1.2.1.2 </span>On Output
                        </h6>
                        <div>
                           <p>Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary. It then assigns the output value to the target host variable. If a NULL is returned, Oracle fills the host variable with blanks. </p>
                           <p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If there is an indicator variable associated with the host variable, Oracle sets it to the original length of the output value. </p>
                           <p>Oracle can convert NUMBER column values to character values. The length of the character host variable determines precision. If the host variable is too short for the number, scientific notation is used. For example, if you SELECT the column value 123456789 into a character host variable of length 6, Oracle returns the value '1.2E08'. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3163"></a><div class="props_rev_3"><a id="GUID-859E1818-94F2-4179-A7AC-D515BA1D1218" name="GUID-859E1818-94F2-4179-A7AC-D515BA1D1218"></a><h5 id="LNPCC-GUID-859E1818-94F2-4179-A7AC-D515BA1D1218" class="sect5"><span class="enumeration_section">4.1.2.2 </span>NUMBER   
                     </h5>
                     <div>
                        <p>You use the NUMBER datatype to store fixed or floating-point numbers. You can specify precision and scale. The maximum precision of a NUMBER value is 38. The magnitude range is 1.0E-130 to 9.99...9E125 (38 nines followed by 88 zeroes). Scale can range from -84 to 127. </p>
                        <p>NUMBER values are stored in a variable-length format, starting with an exponent byte and followed by 19 mantissa bytes. The high-order bit of the exponent byte is a sign bit, which is set for positive numbers. The low-order 7 bits represent the magnitude.</p>
                        <p>The mantissa forms a 38-digit number with each byte representing 2 of the digits in a base-100 format. The sign of the mantissa is specified by the value of the first (left-most) byte. If greater than 101 then the mantissa is negative and the first digit of the mantissa is equal to the left-most byte minus 101. </p>
                        <p>On output, the host variable contains the number as represented internally by Oracle. To accommodate the largest possible number, the output host variable must be 22 bytes long. Only the bytes used to represent the number are returned. Oracle does not blank-pad or null-terminate the output value. If you need to know the length of the returned value, use the VARNUM datatype instead. </p>
                        <p>There is seldom a need to use this external datatype.</p>
                     </div>
                  </div><a id="LNPCC3164"></a><div class="props_rev_3"><a id="GUID-40B0390D-0066-4D4B-9847-65D862BB5B15" name="GUID-40B0390D-0066-4D4B-9847-65D862BB5B15"></a><h5 id="LNPCC-GUID-40B0390D-0066-4D4B-9847-65D862BB5B15" class="sect5"><span class="enumeration_section">4.1.2.3 </span>INTEGER   
                     </h5>
                     <div>
                        <p>You use the INTEGER datatype to store numbers that have no fractional part. An integer is a signed, 2-byte, 4-byte or 8-byte binary number. The order of the bytes in a word is system dependent. You must specify a length for input and output host variables. On output, if the column value is a real number, Oracle truncates any fractional part. <a id="d16109e585" class="indexterm-anchor"></a></p>
                     </div>
                  </div><a id="LNPCC3165"></a><div class="props_rev_3"><a id="GUID-71A1F0DE-5798-4117-A517-376BF86B8A5C" name="GUID-71A1F0DE-5798-4117-A517-376BF86B8A5C"></a><h5 id="LNPCC-GUID-71A1F0DE-5798-4117-A517-376BF86B8A5C" class="sect5"><span class="enumeration_section">4.1.2.4 </span>FLOAT   
                     </h5>
                     <div>
                        <p>You use the FLOAT datatype to store numbers that have a fractional part or that exceed the capacity of the INTEGER datatype. The number is represented using the floating-point format of your computer and typically requires 4 or 8 bytes of storage. You must specify a length for input and output host variables. </p>
                        <p>Oracle can represent numbers with greater precision than most floating-point implementations because the internal format of Oracle numbers is decimal. This can cause a loss of precision when fetching into a FLOAT variable.</p>
                     </div>
                  </div><a id="LNPCC3166"></a><div class="props_rev_3"><a id="GUID-E49A1D74-564B-4B28-9556-51BCD426A987" name="GUID-E49A1D74-564B-4B28-9556-51BCD426A987"></a><h5 id="LNPCC-GUID-E49A1D74-564B-4B28-9556-51BCD426A987" class="sect5"><span class="enumeration_section">4.1.2.5 </span>STRING   
                     </h5>
                     <div>
                        <p>The STRING datatype is like the VARCHAR2 datatype, except that a STRING value is always null-terminated. When you precompile using the option CHAR_MAP=STRING, Oracle assigns the STRING datatype to all host variables that you declare as char[n] or char.</p>
                     </div><a id="LNPCC3167"></a><div class="props_rev_3"><a id="GUID-0CA5325F-84DF-4F4E-85D3-A23B0D917708" name="GUID-0CA5325F-84DF-4F4E-85D3-A23B0D917708"></a><h6 id="LNPCC-GUID-0CA5325F-84DF-4F4E-85D3-A23B0D917708" class="sect6"><span class="enumeration_section">4.1.2.5.1 </span>On Input
                        </h6>
                        <div>
                           <p>Oracle uses the specified length to limit the scan for the null terminator. If a null terminator is not found, Oracle generates an error. If you do not specify a length, Oracle assumes the maximum length of 2000 bytes. The minimum length of a STRING value is 2 bytes. If the first character is a null terminator and the specified length is 2, Oracle inserts a null unless the column is defined as NOT NULL. If the column is defined as NOT NULL, an error occurs. An all-blank value is stored intact.</p>
                        </div>
                     </div><a id="LNPCC3168"></a><div class="props_rev_3"><a id="GUID-41AA31E3-6BCA-4717-97BE-8074606FB2A5" name="GUID-41AA31E3-6BCA-4717-97BE-8074606FB2A5"></a><h6 id="LNPCC-GUID-41AA31E3-6BCA-4717-97BE-8074606FB2A5" class="sect6"><span class="enumeration_section">4.1.2.5.2 </span>On Output
                        </h6>
                        <div>
                           <p>Oracle appends a null byte to the last character returned. If the string length exceeds the specified length, Oracle truncates the output value and appends a null byte. If a NULL is SELECTed, Oracle returns a null byte in the first character position. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness. <a id="d16109e649" class="indexterm-anchor"></a></p>
                        </div>
                     </div>
                  </div><a id="LNPCC3169"></a><div class="props_rev_3"><a id="GUID-A702DB5D-10E3-4C5C-93B4-085442538ACE" name="GUID-A702DB5D-10E3-4C5C-93B4-085442538ACE"></a><h5 id="LNPCC-GUID-A702DB5D-10E3-4C5C-93B4-085442538ACE" class="sect5"><span class="enumeration_section">4.1.2.6 </span>VARNUM
                     </h5>
                     <div>
                        <p>The VARNUM datatype is like the NUMBER datatype, except that the first byte of a VARNUM variable stores the length of the representation. </p>
                        <p>On input, you must set the first byte of the host variable to the length of the value. On output, the host variable contains the length followed by the number as represented internally by Oracle. To accommodate the largest possible number, the host variable must be 22 bytes long. After SELECTing a column value into a VARNUM host variable, you can check the first byte to get the length of the value. </p>
                        <p>Normally, there is little reason to use this datatype. </p>
                     </div>
                  </div><a id="LNPCC3170"></a><div class="props_rev_3"><a id="GUID-96F50F96-98C2-47EC-9C78-AD569D66C6B7" name="GUID-96F50F96-98C2-47EC-9C78-AD569D66C6B7"></a><h5 id="LNPCC-GUID-96F50F96-98C2-47EC-9C78-AD569D66C6B7" class="sect5"><span class="enumeration_section">4.1.2.7 </span>LONG   
                     </h5>
                     <div>
                        <p>You use the LONG datatype to store fixed-length character strings. </p>
                        <p>The LONG datatype is like the VARCHAR2 datatype, except that the maximum length of a LONG value is 2147483647 bytes or two gigabytes. </p>
                     </div>
                  </div><a id="LNPCC3171"></a><div class="props_rev_3"><a id="GUID-E92CE61C-DE5A-4887-9EED-2D99C0774CF5" name="GUID-E92CE61C-DE5A-4887-9EED-2D99C0774CF5"></a><h5 id="LNPCC-GUID-E92CE61C-DE5A-4887-9EED-2D99C0774CF5" class="sect5"><span class="enumeration_section">4.1.2.8 </span>VARCHAR   
                     </h5>
                     <div>
                        <p>You use the VARCHAR datatype to store variable-length character strings. VARCHAR variables have a 2-byte length field followed by a &lt;=65533-byte string field. However, for VARCHAR array elements, the maximum length of the string field is 65530 bytes. When you specify the length of a VARCHAR variable, be sure to include 2 bytes for the length field. For longer strings, use the LONG VARCHAR datatype. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
                     </div>
                  </div><a id="LNPCC3172"></a><div class="props_rev_3"><a id="GUID-8F51D5B4-AD62-4468-A789-20C161BAC894" name="GUID-8F51D5B4-AD62-4468-A789-20C161BAC894"></a><h5 id="LNPCC-GUID-8F51D5B4-AD62-4468-A789-20C161BAC894" class="sect5"><span class="enumeration_section">4.1.2.9 </span>ROWID
                     </h5>
                     <div>
                        <p>Rows in Index-Organized tables do not have permanent physical addresses. The logical ROWID is accessed using the same syntax as the physical ROWID. For this reason, the physical ROWID includes a <span class="italic">data object number</span> (schema objects in the same segment).
                        </p>
                        <p><a id="d16109e731" class="indexterm-anchor"></a><a id="d16109e733" class="indexterm-anchor"></a>To support both logical and physical ROWIDs (as well as ROWIDs of non-Oracle tables) the <span class="italic">universal ROWID</span> was defined. 
                        </p>
                        <p>You can use character host variables to store rowids in a readable format. When you SELECT or FETCH a rowid into a character host variable, Oracle converts the binary value to an 18-byte character string and returns it in the format </p><pre class="oac_no_warn" dir="ltr">BBBBBBBB.RRRR.FFFF 
</pre><p>where BBBBBBBB is the block in the database file, RRRR is the row in the block (the first row is 0), and FFFF is the database file. These numbers are hexadecimal. For example, the rowid </p><pre class="oac_no_warn" dir="ltr">0000000E.000A.0007 
points to the 11th row in the 15th block in the 7th database file. </pre><p>Typically, you FETCH a rowid into a character host variable, then compare the host variable to the ROWID pseudocolumn in the WHERE clause of an UPDATE or DELETE statement. That way, you can identify the latest row fetched by a cursor. </p>
                        <div class="infoboxnote" id="GUID-8F51D5B4-AD62-4468-A789-20C161BAC894__GUID-A9019DAC-A6CB-49A3-8A81-83EDBB0C751B">
                           <p class="notep1">Note:</p>
                           <p>If you need full portability or your application communicates with a non-Oracle database using Oracle Open Gateway technology, specify a maximum length of 256 (not 18) bytes when declaring the host variable. Though you can assume nothing about the host variable's contents, the host variable will behave normally in SQL statements.<a id="d16109e754" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="datatypes-and-host-variables.html#GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367">Universal ROWIDs</a></li>
                              <li><a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">About Mimicking CURRENT OF</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC3174"></a><a id="LNPCC3173"></a><div class="props_rev_3"><a id="GUID-76807ADC-86A6-4DED-9CB7-0A9C6D693AA8" name="GUID-76807ADC-86A6-4DED-9CB7-0A9C6D693AA8"></a><h5 id="LNPCC-GUID-76807ADC-86A6-4DED-9CB7-0A9C6D693AA8" class="sect5"><span class="enumeration_section">4.1.2.10 </span>DATE 
                     </h5>
                     <div>
                        <p>You use the DATE datatype to store dates and times in 7-byte, fixed-length fields. As <a href="datatypes-and-host-variables.html#GUID-76807ADC-86A6-4DED-9CB7-0A9C6D693AA8__BEHEDBHA" title="Date Format">Table 4-3</a> shows, the century, year, month, day, hour (in 24-hour format), minute, and second are stored in that order from left to right.
                        </p>
                        <div class="tblformal" id="GUID-76807ADC-86A6-4DED-9CB7-0A9C6D693AA8__BEHEDBHA">
                           <p class="titleintable">Table 4-3 DATE Format</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DATE Format" summary="Date Format" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="26%" id="d16109e813">Date Datatype</th>
                                    <th align="left" valign="bottom" width="13%" id="d16109e816">Century</th>
                                    <th align="left" valign="bottom" width="10%" id="d16109e819">Year</th>
                                    <th align="left" valign="bottom" width="10%" id="d16109e822">Month</th>
                                    <th align="left" valign="bottom" width="8%" id="d16109e825">Day</th>
                                    <th align="left" valign="bottom" width="8%" id="d16109e828">Hour</th>
                                    <th align="left" valign="bottom" width="11%" id="d16109e831">Minutes</th>
                                    <th align="left" valign="bottom" width="15%" id="d16109e834">Second</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d16109e839" headers="d16109e813 ">
                                       <p><span class="bold">Byte</span></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d16109e839 d16109e816 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e839 d16109e819 ">
                                       <p>2</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e839 d16109e822 ">
                                       <p>3</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e839 d16109e825 ">
                                       <p>4</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e839 d16109e828 ">
                                       <p>5</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d16109e839 d16109e831 ">
                                       <p>6</p>
                                    </td>
                                    <td align="left" valign="top" width="15%" headers="d16109e839 d16109e834 ">
                                       <p>7</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d16109e865" headers="d16109e813 ">
                                       <p><span class="bold">Meaning</span></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d16109e865 d16109e816 ">
                                       <p>Century</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e865 d16109e819 ">
                                       <p>Year</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e865 d16109e822 ">
                                       <p>Month</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e865 d16109e825 ">
                                       <p>Day</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e865 d16109e828 ">
                                       <p>Hour</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d16109e865 d16109e831 ">
                                       <p>Minute</p>
                                    </td>
                                    <td align="left" valign="top" width="15%" headers="d16109e865 d16109e834 ">
                                       <p>Second</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d16109e891" headers="d16109e813 ">
                                       <p><span class="bold">Example</span></p>
                                       <p><span class="bold">17-OCT-1994 at 1:23:12 PM</span></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d16109e891 d16109e816 ">
                                       <p>119</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e891 d16109e819 ">
                                       <p>194</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d16109e891 d16109e822 ">
                                       <p>10</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e891 d16109e825 ">
                                       <p>17</p>
                                    </td>
                                    <td align="left" valign="top" width="8%" headers="d16109e891 d16109e828 ">
                                       <p>14</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d16109e891 d16109e831 ">
                                       <p>24</p>
                                    </td>
                                    <td align="left" valign="top" width="15%" headers="d16109e891 d16109e834 ">
                                       <p>13</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The century and year bytes are in excess-100 notation. The hour, minute, and second are in excess-1 notation. Dates before the Common Era (B.C.E.) are less than 100. The epoch is January 1, 4712 B.C.E. For this date, the century byte is 53 and the year byte is 88. The hour byte ranges from 1 to 24. The minute and second bytes range from 1 to 60. The time defaults to midnight (1, 1, 1). </p>
                        <p>Normally, there is little reason to use the DATE datatype. </p>
                     </div>
                  </div><a id="LNPCC3175"></a><div class="props_rev_3"><a id="GUID-B36B8E5E-DF6B-457F-8FA7-B1BEAA30EA51" name="GUID-B36B8E5E-DF6B-457F-8FA7-B1BEAA30EA51"></a><h5 id="LNPCC-GUID-B36B8E5E-DF6B-457F-8FA7-B1BEAA30EA51" class="sect5"><span class="enumeration_section">4.1.2.11 </span>RAW 
                     </h5>
                     <div>
                        <p>You use the RAW datatype to store binary data or byte strings. The maximum length of a RAW value is 65535 bytes. </p>
                        <p>RAW data is like CHARACTER data, except that Oracle assumes nothing about the meaning of RAW data and does no character set conversions when you transmit RAW data from one system to another. </p>
                     </div>
                  </div><a id="LNPCC3176"></a><div class="props_rev_3"><a id="GUID-2B2B52E3-3F93-4C01-9FF3-8E105F500934" name="GUID-2B2B52E3-3F93-4C01-9FF3-8E105F500934"></a><h5 id="LNPCC-GUID-2B2B52E3-3F93-4C01-9FF3-8E105F500934" class="sect5"><span class="enumeration_section">4.1.2.12 </span>VARRAW 
                     </h5>
                     <div>
                        <p>You use the VARRAW datatype to store variable-length binary data or byte strings. The VARRAW datatype is like the RAW datatype, except that VARRAW variables have a 2-byte length field followed by a data field &lt;=  65533 bytes in length. For longer strings, use the LONG VARRAW datatype. </p>
                        <p>When you specify the length of a VARRAW variable, be sure to include 2 bytes for the length field. The first two bytes of the variable must be interpretable as an integer. </p>
                        <p>To get the length of a VARRAW variable, simply refer to its length field. </p>
                     </div>
                  </div><a id="LNPCC3177"></a><div class="props_rev_3"><a id="GUID-ABC1DB4D-CBBC-42E0-AAF3-1116AF9B749E" name="GUID-ABC1DB4D-CBBC-42E0-AAF3-1116AF9B749E"></a><h5 id="LNPCC-GUID-ABC1DB4D-CBBC-42E0-AAF3-1116AF9B749E" class="sect5"><span class="enumeration_section">4.1.2.13 </span>LONG RAW 
                     </h5>
                     <div>
                        <p>You use the LONG RAW datatype to store binary data or byte strings. The maximum length of a LONG RAW value is 2147483647 bytes or two gigabytes. </p>
                        <p>LONG RAW data is like LONG data, except that Oracle assumes nothing about the meaning of LONG RAW data and does no character set conversions when you transmit LONG RAW data from one system to another. </p>
                     </div>
                  </div><a id="LNPCC3178"></a><div class="props_rev_3"><a id="GUID-E40A88A2-435B-4232-A89E-DE575075B209" name="GUID-E40A88A2-435B-4232-A89E-DE575075B209"></a><h5 id="LNPCC-GUID-E40A88A2-435B-4232-A89E-DE575075B209" class="sect5"><span class="enumeration_section">4.1.2.14 </span>UNSIGNED 
                     </h5>
                     <div>
                        <p>You use the UNSIGNED datatype to store unsigned integers. An unsigned integer is a binary number of 2 or 4 bytes. The order of the bytes in a word is system dependent. You must specify a length for input and output host variables. On output, if the column value is a floating-point number, Oracle truncates the fractional part. </p>
                     </div>
                  </div><a id="LNPCC3179"></a><div class="props_rev_3"><a id="GUID-C938DF5F-CCE5-4AD2-B5B0-D2ABE670888D" name="GUID-C938DF5F-CCE5-4AD2-B5B0-D2ABE670888D"></a><h5 id="LNPCC-GUID-C938DF5F-CCE5-4AD2-B5B0-D2ABE670888D" class="sect5"><span class="enumeration_section">4.1.2.15 </span>LONG VARCHAR   
                     </h5>
                     <div>
                        <p>You use the LONG VARCHAR datatype to store variable-length character strings. LONG VARCHAR variables have a 4-byte length field followed by a string field. The maximum length of the string field is 2147483643 (2**31 - 5) bytes. When you specify the length of a LONG VARCHAR for use in a VAR or TYPE statement, do not include the 4 length bytes.</p>
                     </div>
                  </div><a id="LNPCC3180"></a><div class="props_rev_3"><a id="GUID-CD95A1F3-0B46-423D-8F4D-1CD40869727C" name="GUID-CD95A1F3-0B46-423D-8F4D-1CD40869727C"></a><h5 id="LNPCC-GUID-CD95A1F3-0B46-423D-8F4D-1CD40869727C" class="sect5"><span class="enumeration_section">4.1.2.16 </span>LONG VARRAW   
                     </h5>
                     <div>
                        <p>You use the LONG VARRAW datatype to store variable-length binary data or byte strings. LONG VARRAW variables have a 4-byte length field followed by a data field. The maximum length of the data field is 2147483643 bytes. When you specify the length of a LONG VARRAW for use in a VAR or TYPE statement, do not include the 4 length bytes.</p>
                     </div>
                  </div><a id="LNPCC3181"></a><div class="props_rev_3"><a id="GUID-B1C81959-27EC-416A-91B0-9EBA116FE419" name="GUID-B1C81959-27EC-416A-91B0-9EBA116FE419"></a><h5 id="LNPCC-GUID-B1C81959-27EC-416A-91B0-9EBA116FE419" class="sect5"><span class="enumeration_section">4.1.2.17 </span>CHAR   
                     </h5>
                     <div>
                        <p>You use the CHAR datatype to store fixed-length character strings. The maximum length of a CHAR value is 65535 bytes. </p>
                     </div><a id="LNPCC3182"></a><div class="props_rev_3"><a id="GUID-187910E6-DC22-4351-A443-6B71E7D65597" name="GUID-187910E6-DC22-4351-A443-6B71E7D65597"></a><h6 id="LNPCC-GUID-187910E6-DC22-4351-A443-6B71E7D65597" class="sect6"><span class="enumeration_section">4.1.2.17.1 </span>On Input
                        </h6>
                        <div>
                           <p>Oracle reads the number of bytes specified for the input host variable, does <span class="italic">not</span> strip trailing blanks, then stores the input value in the target database column.
                           </p>
                           <p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all-blank, Oracle treats it like a character value. </p>
                        </div>
                     </div><a id="LNPCC3183"></a><div class="props_rev_3"><a id="GUID-6C494EEF-38CF-481E-BAA9-5C5DB78F6B18" name="GUID-6C494EEF-38CF-481E-BAA9-5C5DB78F6B18"></a><h6 id="LNPCC-GUID-6C494EEF-38CF-481E-BAA9-5C5DB78F6B18" class="sect6"><span class="enumeration_section">4.1.2.17.2 </span>On Output 
                        </h6>
                        <div>
                           <p>Oracle returns the number of bytes specified for the output host variable, doing blank-padding if necessary, then assigns the output value to the target host variable. If a NULL is returned, Oracle fills the host variable with blanks.</p>
                           <p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3184"></a><div class="props_rev_3"><a id="GUID-BE81B381-7513-4F86-ACCF-84583A307251" name="GUID-BE81B381-7513-4F86-ACCF-84583A307251"></a><h5 id="LNPCC-GUID-BE81B381-7513-4F86-ACCF-84583A307251" class="sect5"><span class="enumeration_section">4.1.2.18 </span>CHARZ   
                     </h5>
                     <div>
                        <p>When DBMS=V7 or V8, Oracle, by default, assigns the CHARZ datatype to all character host variables in a Pro*C/C++ program. The CHARZ datatype indicates fixed-length, null-terminated character strings. The maximum length of a CHARZ value is 65534 bytes. </p>
                     </div><a id="LNPCC3185"></a><div class="props_rev_3"><a id="GUID-6B94828F-09E4-493D-98F6-0CCD266F8C8C" name="GUID-6B94828F-09E4-493D-98F6-0CCD266F8C8C"></a><h6 id="LNPCC-GUID-6B94828F-09E4-493D-98F6-0CCD266F8C8C" class="sect6"><span class="enumeration_section">4.1.2.18.1 </span>On Input
                        </h6>
                        <div>
                           <p> The CHARZ and STRING datatypes work the same way. You must null-terminate the input value. The null terminator serves only to delimit the string; it does not become part of the stored data. </p>
                        </div>
                     </div><a id="LNPCC3186"></a><div class="props_rev_3"><a id="GUID-5DA05C87-CA00-4CEB-BB8E-6E8135AFEF79" name="GUID-5DA05C87-CA00-4CEB-BB8E-6E8135AFEF79"></a><h6 id="LNPCC-GUID-5DA05C87-CA00-4CEB-BB8E-6E8135AFEF79" class="sect6"><span class="enumeration_section">4.1.2.18.2 </span>On Output 
                        </h6>
                        <div>
                           <p>CHARZ host variables are blank-padded if necessary, then null-terminated. The output value is always null-terminated, even if data must be truncated. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3187"></a><div class="props_rev_3"><a id="GUID-83BF2B6F-071F-4DAC-847A-EC59EEAB6D10" name="GUID-83BF2B6F-071F-4DAC-847A-EC59EEAB6D10"></a><h5 id="LNPCC-GUID-83BF2B6F-071F-4DAC-847A-EC59EEAB6D10" class="sect5"><span class="enumeration_section">4.1.2.19 </span>CHARF 
                     </h5>
                     <div>
                        <p>The CHARF datatype is used in EXEC SQL TYPE and EXEC SQL VAR statements. When you precompile with the DBMS option set to V7 or V8, specifying the external datatype CHAR in a TYPE or VAR statement equivalences the C type or variable to the fixed-length, null-terminated datatype CHARZ.</p>
                        <p>However, you might not want either of these type equivalences, but rather an equivalence to the fixed-length external type CHAR. If you use the external type CHARF, the C type or variable is <span class="italic">always</span> equivalenced to the fixed-length ANSI datatype CHAR, regardless of the DBMS value. CHARF never allows the C type to be equivalenced to VARCHAR2 or CHARZ. Alternatively, when you set the option CHAR_MAP=CHARF, all host variables declared as char[n] or char are equivalenced to a CHAR string. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3188"></a><div class="props_rev_3"><a id="GUID-9DE44332-0853-465E-A222-4AA4973E2319" name="GUID-9DE44332-0853-465E-A222-4AA4973E2319"></a><h4 id="LNPCC-GUID-9DE44332-0853-465E-A222-4AA4973E2319" class="sect4"><span class="enumeration_section">4.1.3 </span>Additional External Datatypes
                  </h4>
                  <div>
                     <p>This section describes additional external datatypes.</p>
                  </div><a id="LNPCC3189"></a><div class="props_rev_3"><a id="GUID-1AB4EFA3-4BF1-4215-8374-CBACD380E4F8" name="GUID-1AB4EFA3-4BF1-4215-8374-CBACD380E4F8"></a><h5 id="LNPCC-GUID-1AB4EFA3-4BF1-4215-8374-CBACD380E4F8" class="sect5"><span class="enumeration_section">4.1.3.1 </span>Datetime and Interval Datatypes
                     </h5>
                     <div>
                        <p>The datetime and interval datatypes are briefly summarized here.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="../sqlrf/index.html" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCC3190"></a><div class="props_rev_3"><a id="GUID-FA7894BF-E8FA-4A71-B016-5A80476E0CA8" name="GUID-FA7894BF-E8FA-4A71-B016-5A80476E0CA8"></a><h5 id="LNPCC-GUID-FA7894BF-E8FA-4A71-B016-5A80476E0CA8" class="sect5"><span class="enumeration_section">4.1.3.2 </span>ANSI DATE
                     </h5>
                     <div>
                        <p><a id="d16109e1166" class="indexterm-anchor"></a><a id="d16109e1170" class="indexterm-anchor"></a>The <code class="codeph">ANSI</code> <code class="codeph">DATE</code> is based on the <code class="codeph">DATE</code>, but contains no time portion. (Therefore, it also has no time zone.) <code class="codeph">ANSI</code> <code class="codeph">DATE</code> follows the <code class="codeph">ANSI</code> specification for the <code class="codeph">DATE</code> datatype. When assigning an <code class="codeph">ANSI</code> <code class="codeph">DATE</code> to a <code class="codeph">DATE</code> or a timestamp datatype, the time portion of the Oracle <code class="codeph">DATE</code> and the timestamp are set to zero. When assigning a <code class="codeph">DATE</code> or a timestamp to an <code class="codeph">ANSI</code> <code class="codeph">DATE</code>, the time portion is ignored.
                        </p>
                        <p>You are encouraged to instead use the <code class="codeph">TIMESTAMP</code> datatype which contains both date and time.
                        </p>
                     </div>
                  </div><a id="LNPCC3191"></a><div class="props_rev_3"><a id="GUID-2FB5CBC5-C109-4FAD-9A0B-1957D7ED5E0E" name="GUID-2FB5CBC5-C109-4FAD-9A0B-1957D7ED5E0E"></a><h5 id="LNPCC-GUID-2FB5CBC5-C109-4FAD-9A0B-1957D7ED5E0E" class="sect5"><span class="enumeration_section">4.1.3.3 </span>TIMESTAMP
                     </h5>
                     <div>
                        <p>The <code class="codeph">TIMESTAMP</code> datatype is an extension of the <code class="codeph">DATE</code> datatype. It stores the year, month, and day of the <code class="codeph">DATE</code> datatype, plus the hour, minute, and second values. It has no time zone. The <code class="codeph">TIMESTAMP</code> datatype has the form:
                        </p><pre class="oac_no_warn" dir="ltr">TIMESTAMP(fractional_seconds_precision) 
</pre><p>where <span class="italic"><code class="codeph">fractional_seconds_precision</code></span> (which is optional) specifies the number of digits in the fractional part of the <code class="codeph">SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.
                        </p>
                     </div>
                  </div><a id="LNPCC3192"></a><div class="props_rev_3"><a id="GUID-F917AB1C-8FE5-496C-A3FB-FCF51C15323B" name="GUID-F917AB1C-8FE5-496C-A3FB-FCF51C15323B"></a><h5 id="LNPCC-GUID-F917AB1C-8FE5-496C-A3FB-FCF51C15323B" class="sect5"><span class="enumeration_section">4.1.3.4 </span>TIMESTAMP WITH TIME ZONE
                     </h5>
                     <div>
                        <p><code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">TIME</code> <code class="codeph">ZONE</code> (<code class="codeph">TSTZ</code>) is a variant of <code class="codeph">TIMESTAMP</code> that includes an explicit time zone displacement in its value. The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Timeâ€”formerly Greenwich Mean Time). The <code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">TIME</code> ZONE datatype has the form:
                        </p><pre class="oac_no_warn" dir="ltr">TIMESTAMP(fractional_seconds_precision) WITH TIME ZONE
</pre><p>where <span class="italic"><code class="codeph">fractional_seconds_precision</code></span> optionally specifies the number of digits in the fractional part of the <code class="codeph">SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.
                        </p>
                        <p>Two <code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">TIME</code> <code class="codeph">ZONE</code> values are considered identical if they represent the same instant in UTC, regardless of the <code class="codeph">TIME</code> <code class="codeph">ZONE</code> offsets stored in the data. 
                        </p>
                     </div>
                  </div><a id="LNPCC3193"></a><div class="props_rev_3"><a id="GUID-D433E4DE-88C3-4DB4-A5C2-855573715C29" name="GUID-D433E4DE-88C3-4DB4-A5C2-855573715C29"></a><h5 id="LNPCC-GUID-D433E4DE-88C3-4DB4-A5C2-855573715C29" class="sect5"><span class="enumeration_section">4.1.3.5 </span>TIMESTAMP WITH LOCAL TIME ZONE
                     </h5>
                     <div>
                        <p><code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">LOCAL</code> <code class="codeph">TIME</code> <code class="codeph">ZONE</code> (<code class="codeph">TSLTZ</code>) is another variant of <code class="codeph">TIMESTAMP</code> that includes a time zone displacement in its value. Storage is in the same format as for <code class="codeph">TIMESTAMP</code>. This type differs from <code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">TIME</code> <code class="codeph">ZONE</code> in that data stored in the database is normalized to the database time zone, and the time zone displacement is not stored as part of the column data. When users retrieve the data, Oracle returns it in the users' local session time zone.
                        </p>
                        <p>The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Timeâ€”formerly Greenwich Mean Time). The <code class="codeph">TIMESTAMP</code> <code class="codeph">WITH</code> <code class="codeph">LOCAL</code> <code class="codeph">TIME</code> ZONE datatype has the form:
                        </p><pre class="oac_no_warn" dir="ltr">TIMESTAMP(fractional_seconds_precision) WITH LOCAL TIME ZONE
</pre><p>where <span class="italic"><code class="codeph">fractional_seconds_precision</code></span> optionally specifies the number of digits in the fractional part of the <code class="codeph">SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6. 
                        </p>
                     </div>
                  </div><a id="LNPCC3194"></a><div class="props_rev_3"><a id="GUID-CA6918C1-D3A1-4114-8717-341D18F85B44" name="GUID-CA6918C1-D3A1-4114-8717-341D18F85B44"></a><h5 id="LNPCC-GUID-CA6918C1-D3A1-4114-8717-341D18F85B44" class="sect5"><span class="enumeration_section">4.1.3.6 </span>INTERVAL YEAR TO MONTH
                     </h5>
                     <div>
                        <p><code class="codeph">INTERVAL</code> <code class="codeph">YEAR</code> <code class="codeph">TO</code> <code class="codeph">MONTH</code> stores a period of time using the <code class="codeph">YEAR</code> and <code class="codeph">MONTH</code> datetime fields. The <code class="codeph">INTERVAL</code> <code class="codeph">YEAR</code> <code class="codeph">TO</code> <code class="codeph">MONTH</code> datatype has the form:
                        </p><pre class="oac_no_warn" dir="ltr">INTERVAL YEAR(year_precision) TO MONTH
</pre><p>where the optional <span class="italic"><code class="codeph">year_precision</code></span> is the number of digits in the <code class="codeph">YEAR</code> datetime field. The default value of <span class="italic"><code class="codeph">year_precision</code></span> is 2. 
                        </p>
                     </div>
                  </div><a id="LNPCC3195"></a><div class="props_rev_3"><a id="GUID-B9A01770-93E5-4F29-8161-31F365521614" name="GUID-B9A01770-93E5-4F29-8161-31F365521614"></a><h5 id="LNPCC-GUID-B9A01770-93E5-4F29-8161-31F365521614" class="sect5"><span class="enumeration_section">4.1.3.7 </span>INTERVAL DAY TO SECOND
                     </h5>
                     <div>
                        <p><code class="codeph">INTERVAL</code> <code class="codeph">DAY</code> <code class="codeph">TO</code> <code class="codeph">SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds. The <code class="codeph">INTERVAL</code> <code class="codeph">DAY</code> <code class="codeph">TO</code> <code class="codeph">SECOND</code> datatype has the form:
                        </p><pre class="oac_no_warn" dir="ltr">INTERVAL DAY (day_precision) TO SECOND(fractional_seconds_precision)
</pre><p>where:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">day_precision</code></span> is the number of digits in the <code class="codeph">DAY</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 2.
                              </p>
                           </li>
                        </ul>
                        <p><span class="italic"><code class="codeph">fractional_seconds_precision</code></span> is the number of digits in the fractional part of the <code class="codeph">SECOND</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 6.
                        </p>
                     </div>
                  </div><a id="LNPCC3196"></a><div class="props_rev_3"><a id="GUID-C654B5B8-9E11-46FB-B33E-DA79C0A42EF6" name="GUID-C654B5B8-9E11-46FB-B33E-DA79C0A42EF6"></a><h5 id="LNPCC-GUID-C654B5B8-9E11-46FB-B33E-DA79C0A42EF6" class="sect5"><span class="enumeration_section">4.1.3.8 </span>Avoiding Unexpected Results Using Datetime
                     </h5>
                     <div>
                        <div class="infoboxnote" id="GUID-C654B5B8-9E11-46FB-B33E-DA79C0A42EF6__GUID-024211DA-A943-4854-A5A0-41804A170BED">
                           <p class="notep1">Note:</p>
                           <p>To avoid unexpected results in your DML operations on datetime data, you can verify the database and session time zones by querying the built-in SQL functions <code class="codeph">DBTIMEZONE</code> and <code class="codeph">SESSIONTIMEZONE</code>. If the time zones have not been set manually, Oracle uses the operating system time zone by default. If the operating system time zone is not a valid Oracle time zone, Oracle uses UTC as the default value.
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3197"></a><div class="props_rev_3"><a id="GUID-EAD2DF4C-63FF-4B67-9673-490128B98D85" name="GUID-EAD2DF4C-63FF-4B67-9673-490128B98D85"></a><h3 id="LNPCC-GUID-EAD2DF4C-63FF-4B67-9673-490128B98D85" class="sect3"><span class="enumeration_section">4.2 </span>Host Variables 
               </h3>
               <div>
                  <p>Host variables are the key to communication between your host program and Oracle. Typically, a precompiler program inputs data from a host variable to Oracle, and Oracle outputs data to a host variable in the program. Oracle stores input data in database columns, and stores output data in program host variables. </p>
                  <p>A host variable can be any arbitrary C expression that resolves to a scalar type. But, a host variable must also be an <span class="italic">lvalue</span>. Host arrays of most host variables are also supported. 
                  </p>
               </div><a id="LNPCC3199"></a><a id="LNPCC3200"></a><a id="LNPCC3198"></a><div class="props_rev_3"><a id="GUID-843D717B-B10E-4D4B-AAC5-7B4755379604" name="GUID-843D717B-B10E-4D4B-AAC5-7B4755379604"></a><h4 id="LNPCC-GUID-843D717B-B10E-4D4B-AAC5-7B4755379604" class="sect4"><span class="enumeration_section">4.2.1 </span>Host Variable Declaration 
                  </h4>
                  <div>
                     <p>You declare a host variable according to the rules of the C programming language, specifying a C datatype supported by the Oracle program interface. The C datatype must be compatible with that of the source or target database column.</p>
                     <p><a id="d16109e1609" class="indexterm-anchor"></a>If MODE=ORACLE, you do not have to declare host variables in a special Declare Section. However, if you do not use a Declare Section, the FIPS flagger warns you about this, as the Declare Section is part of the ANSI SQL Standard.<a id="d16109e1614" class="indexterm-anchor"></a> If CODE=CPP (you are compiling C++ code) or PARSE=NONE or PARSE=PARTIAL, then you must have a Declare Section.
                     </p>
                     <p> <a href="datatypes-and-host-variables.html#GUID-843D717B-B10E-4D4B-AAC5-7B4755379604__g39867" title="C Datatypes for Host Variables">Table 4-4</a> shows the C datatypes and the pseudotypes that you can use when declaring host variables. Only these datatypes can be used for host variables. 
                     </p>
                     <div class="tblformal" id="GUID-843D717B-B10E-4D4B-AAC5-7B4755379604__g39867">
                        <p class="titleintable">Table 4-4  C Datatypes for Host Variables</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title=" C Datatypes for Host Variables" summary="C Datatypes for Host Variables" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="45%" id="d16109e1636">C Datatype or Pseudotype</th>
                                 <th align="left" valign="bottom" width="55%" id="d16109e1639">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1644" headers="d16109e1636 ">
                                    <p>char</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1644 d16109e1639 ">
                                    <p>single character</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1651" headers="d16109e1636 ">
                                    <p>char[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1651 d16109e1639 ">
                                    <p>n-character array (string)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1658" headers="d16109e1636 ">
                                    <p>int</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1658 d16109e1639 ">
                                    <p>integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1665" headers="d16109e1636 ">
                                    <p>short</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1665 d16109e1639 ">
                                    <p>small integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1672" headers="d16109e1636 ">
                                    <p>long</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1672 d16109e1639 ">
                                    <p>large integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1679" headers="d16109e1636 ">
                                    <p>long long</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1679 d16109e1639 ">
                                    <p>very large (8-byte) integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1686" headers="d16109e1636 ">
                                    <p>float</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1686 d16109e1639 ">
                                    <p>floating-point number (usually single precision)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1693" headers="d16109e1636 ">
                                    <p>double</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1693 d16109e1639 ">
                                    <p>floating-point number (always double precision)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d16109e1700" headers="d16109e1636 ">
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d16109e1700 d16109e1639 ">
                                    <p>variable-length string</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="datatypes-and-host-variables.html#GUID-843D717B-B10E-4D4B-AAC5-7B4755379604__g39898" title="C to Oracle Datatype Compatibility">Table 4-5</a> shows the compatible Oracle internal datatypes.
                     </p>
                     <div class="tblformal" id="GUID-843D717B-B10E-4D4B-AAC5-7B4755379604__g39898">
                        <p class="titleintable">Table 4-5  C to Oracle Datatype Compatibility</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title=" C to Oracle Datatype Compatibility" summary="C to Oracle Datatype Compatibility" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="24%" id="d16109e1723">Internal Type</th>
                                 <th align="left" valign="bottom" width="25%" id="d16109e1726">C Type</th>
                                 <th align="left" valign="bottom" width="51%" id="d16109e1729">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1734" headers="d16109e1723 ">
                                    <p>VARCHAR2(Y)</p>
                                    <p>(Note 1)</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1734 d16109e1726 ">
                                    <p>char</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1734 d16109e1729 ">
                                    <p>single character</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1746" headers="d16109e1723 ">
                                    <p>CHAR(X)</p>
                                    <p>(Note 1)</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1746 d16109e1726 ">
                                    <p>char[n]</p>
                                    <p>VARCHAR[n]</p>
                                    <p>int</p>
                                    <p>short</p>
                                    <p>long</p>
                                    <p>long long</p>
                                    <p>float</p>
                                    <p>double</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1746 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                    <p>integer</p>
                                    <p>small integer</p>
                                    <p>large integer</p>
                                    <p>very large (8-byte) integer</p>
                                    <p>floating-point number</p>
                                    <p>double-precision floating-point</p>
                                    <p>number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1788" headers="d16109e1723 ">
                                    <p>NUMBER</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1788 d16109e1726 ">
                                    <p>int</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1788 d16109e1729 ">
                                    <p>integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1798" headers="d16109e1723 ">
                                    <p>NUMBER(P,S)</p>
                                    <p>(Note 2)</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1798 d16109e1726 ">
                                    <p>short</p>
                                    <p>int</p>
                                    <p>long</p>
                                    <p>float</p>
                                    <p>double</p>
                                    <p></p>
                                    <p>char</p>
                                    <p>char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1798 d16109e1729 ">
                                    <p>small integer</p>
                                    <p>integer</p>
                                    <p>large integer</p>
                                    <p>floating-point number</p>
                                    <p>double-precision floating-point</p>
                                    <p>number</p>
                                    <p>single character</p>
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1841" headers="d16109e1723 ">
                                    <p>DATE</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1841 d16109e1726 ">
                                    <p>char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1841 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1855" headers="d16109e1723 ">
                                    <p>LONG</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1855 d16109e1726 ">
                                    <p>char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1855 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1869" headers="d16109e1723 ">
                                    <p>RAW(X)</p>
                                    <p>(Note 1)</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1869 d16109e1726 ">
                                    <p>unsigned char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1869 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1885" headers="d16109e1723 ">
                                    <p>LONG RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1885 d16109e1726 ">
                                    <p>unsigned char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1885 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1899" headers="d16109e1723 ">
                                    <p>ROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1899 d16109e1726 ">
                                    <p>unsigned char[n]</p>
                                    <p>VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1899 d16109e1729 ">
                                    <p>n-byte character array</p>
                                    <p>n-byte variable-length character array</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d16109e1913" headers="d16109e1723 ">
                                    <p>Notes:</p>
                                    <p>1. X ranges from 1 to 2000. 1 is the default value. Y ranges from 1 to 4000.</p>
                                    <p>2. P ranges from 1 to 38. S ranges from -84 to 127.</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d16109e1913 d16109e1726 ">
                                    <p></p>
                                 </td>
                                 <td align="left" valign="top" width="51%" headers="d16109e1913 d16109e1729 ">
                                    <p></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>One-dimensional arrays of simple C types can also serve as host variables. For char[n] and VARCHAR[n], <span class="italic">n</span> specifies the maximum string length, <span class="italic">not</span> the number of strings in the array. Two-dimensional arrays are allowed only for char[m][n] and VARCHAR[m][n], where <span class="italic">m</span> specifies the number of strings in the array and <span class="italic">n</span> specifies the maximum string length. 
                     </p>
                     <p>Pointers to simple C types are supported. Pointers to char[n] and VARCHAR[n] variables should be declared as pointer to char or VARCHAR (with no length specification). Arrays of pointers, however, are not supported. </p>
                  </div><a id="LNPCC3201"></a><div class="props_rev_3"><a id="GUID-2FB5F07A-CBB2-4FEA-B665-8A2B5B98FB50" name="GUID-2FB5F07A-CBB2-4FEA-B665-8A2B5B98FB50"></a><h5 id="LNPCC-GUID-2FB5F07A-CBB2-4FEA-B665-8A2B5B98FB50" class="sect5"><span class="enumeration_section">4.2.1.1 </span>Storage-Class Specifiers 
                     </h5>
                     <div>
                        <p>Pro*C/C++ lets you use the <span class="bold">auto</span>,<span class="bold"> extern</span>, and <span class="bold">static</span> storage-class specifiers when you declare host variables. However, you cannot use the <span class="bold">register</span> storage-class specifier to store host variables, since the precompiler takes the address of host variables by placing an ampersand (&amp;) before them. Following the rules of C, you can use the <span class="bold">auto</span> storage class specifier only within a block.
                        </p>
                        <p>To comply with the ANSI C standard, the Pro*C/C++ Precompiler provides the ability to declare an <span class="bold">extern char[n]</span> host variable with or without a maximum length, as the following examples shows: 
                        </p><pre class="oac_no_warn" dir="ltr">extern char  protocol[15]; 
extern char  msg[]; 
</pre><p>However, you should always specify the maximum length. In the last example, if <span class="italic">msg</span> is an output host variable declared in one precompilation unit but defined in another, the precompiler has no way of knowing its maximum length. If you have not allocated enough storage for <span class="italic">msg</span> in the second precompilation unit, you might corrupt memory. (Usually, "enough" is the number of bytes in the longest column value that might be SELECTed or FETCHed into the host variable, plus one byte for a possible null terminator.) 
                        </p>
                        <p>If you neglect to specify the maximum length for an <span class="bold">extern char[ ]</span> host variable, the precompiler issues a warning message. The precompiler also assumes that the host variable will store a CHARACTER column value, which cannot exceed 255 characters in length. So, if you want to SELECT or FETCH a VARCHAR2 or a LONG column value of length greater than 255 characters into the host variable, you <span class="italic">must</span> specify a maximum length.
                        </p>
                     </div>
                  </div><a id="LNPCC3202"></a><div class="props_rev_3"><a id="GUID-0BDF63F9-5284-434E-A8B3-9FAD1360FF40" name="GUID-0BDF63F9-5284-434E-A8B3-9FAD1360FF40"></a><h5 id="LNPCC-GUID-0BDF63F9-5284-434E-A8B3-9FAD1360FF40" class="sect5"><span class="enumeration_section">4.2.1.2 </span>Type Qualifiers 
                     </h5>
                     <div>
                        <p>You can also use the <span class="bold">const</span> and <span class="bold">volatile</span> type qualifiers when you declare host variables. 
                        </p>
                        <p>A <span class="bold">const</span> host variable must have a constant value, that is, your program cannot change its initial value. A <span class="bold">volatile</span> host variable can have its value changed in ways unknown to your program (for example, by a device attached to the system). 
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3203"></a><div class="props_rev_3"><a id="GUID-60C0F646-92C0-4AB1-9E88-3B2677C3CF8B" name="GUID-60C0F646-92C0-4AB1-9E88-3B2677C3CF8B"></a><h4 id="LNPCC-GUID-60C0F646-92C0-4AB1-9E88-3B2677C3CF8B" class="sect4"><span class="enumeration_section">4.2.2 </span>Host Variable Referencing 
                  </h4>
                  <div>
                     <p>You use host variables in SQL data manipulation statements. A host variable must be prefixed with a colon (:) in SQL statements but must not be prefixed with a colon in C statements, as the following example shows:<a id="d16109e2025" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">char    buf[15];
int     emp_number; 
float   salary; 
... 
gets(buf); 
emp_number = atoi(buf); 

EXEC SQL SELECT sal INTO :salary FROM emp 
â€ƒ   WHERE empno = :emp_number; 
</pre><p>Though it might be confusing, you can give a host variable the same name as an Oracle table or column, as this example shows: </p><pre class="oac_no_warn" dir="ltr">int     empno; 
char    ename[10]; 
float   sal; 
... 
EXEC SQL SELECT ename, sal INTO :ename, :sal FROM emp 
â€ƒ   WHERE empno = :empno; 
</pre></div><a id="LNPCC3204"></a><div class="props_rev_3"><a id="GUID-79D8C3A4-FF8F-4EFD-9590-08FA749F36BF" name="GUID-79D8C3A4-FF8F-4EFD-9590-08FA749F36BF"></a><h5 id="LNPCC-GUID-79D8C3A4-FF8F-4EFD-9590-08FA749F36BF" class="sect5"><span class="enumeration_section">4.2.2.1 </span>Restrictions 
                     </h5>
                     <div>
                        <p>A host variable name is a C identifier, hence it must be declared and referenced in the same upper/lower case format. It cannot substitute for a column, table, or other Oracle object in a SQL statement, and must not be an Oracle reserved word. </p>
                        <p>A host variable must resolve to an address in the program. For this reason, function calls and numeric expressions cannot serve as host variables. The following code is<span class="italic"> invalid</span>: 
                        </p><pre class="oac_no_warn" dir="ltr">#define MAX_EMP_NUM    9000 
... 
int get_dept(); 
... 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (:MAX_EMP_NUM + 10, 'CHEN', :get_dept()); <a id="d16109e2053" class="indexterm-anchor"></a><a id="d16109e2057" class="indexterm-anchor"></a><a id="d16109e2061" class="indexterm-anchor"></a></pre></div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="reserved-words-keywords-namespaces.html#GUID-F3AE31F8-2209-491E-A0FD-44F75C06C79C">Reserved Words, Keywords, and Namespaces</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="LNPCC3205"></a><div class="props_rev_3"><a id="GUID-1A9B5679-B15F-4869-8B7A-598BABEA3873" name="GUID-1A9B5679-B15F-4869-8B7A-598BABEA3873"></a><h3 id="LNPCC-GUID-1A9B5679-B15F-4869-8B7A-598BABEA3873" class="sect3"><span class="enumeration_section">4.3 </span>Indicator Variables   
               </h3>
               <div>
                  <p>You can associate every host variable with an optional indicator variable. An indicator variable must be defined as a 2-byte integer and, in SQL statements, must be prefixed with a colon and immediately follow its host variable (unless you use the keyword INDICATOR). If you are using Declare Sections, you must also declare indicator variables inside the Declare Sections.</p>
                  <p>This applies to relational columns, not object types.</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3206"></a><div class="props_rev_3"><a id="GUID-2CDA9483-5AE4-4B42-A9DE-8B0001FC97F3" name="GUID-2CDA9483-5AE4-4B42-A9DE-8B0001FC97F3"></a><h4 id="LNPCC-GUID-2CDA9483-5AE4-4B42-A9DE-8B0001FC97F3" class="sect4"><span class="enumeration_section">4.3.1 </span>The INDICATOR Keyword 
                  </h4>
                  <div>
                     <p>To improve readability, you can precede any indicator variable with the optional keyword INDICATOR. You must still prefix the indicator variable with a colon. The correct syntax is:</p><pre class="oac_no_warn" dir="ltr">:host_variable INDICATOR :indicator_variable 
</pre><p>which is equivalent to </p><pre class="oac_no_warn" dir="ltr">:host_variable:indicator_variable 
</pre><p>You can use both forms of expression in your host program. </p>
                     <p>Possible indicator values, and their meanings, are:</p>
                     <div class="tblformal" id="GUID-2CDA9483-5AE4-4B42-A9DE-8B0001FC97F3__GUID-9D61D74D-C9BC-424C-9476-AFA9E2502DE7">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Indicator Values" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d16109e2140">Indicator Values</th>
                                 <th align="left" valign="bottom" width="71%" id="d16109e2143">Meanings</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2148" headers="d16109e2140 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2148 d16109e2143 ">
                                    <p>The operation was successful</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2155" headers="d16109e2140 ">
                                    <p>-1</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2155 d16109e2143 ">
                                    <p>A NULL was returned, inserted, or updated.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2162" headers="d16109e2140 ">
                                    <p>-2</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2162 d16109e2143 ">
                                    <p>Output to a character host variable from a "long" type was truncated, but the original column length cannot be determined.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2169" headers="d16109e2140 ">
                                    <p>&gt;0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2169 d16109e2143 ">
                                    <p>The result of a SELECT or FETCH into a character host variable was truncated. In this case, if the host variable is a multibyte character variable, the indicator value is the original column length in characters. If the host variable is not a multibye character variable, then the indicator length is the original column length in bytes.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3207"></a><div class="props_rev_3"><a id="GUID-E2F77858-8524-4356-AE8B-6172E97F351A" name="GUID-E2F77858-8524-4356-AE8B-6172E97F351A"></a><h4 id="LNPCC-GUID-E2F77858-8524-4356-AE8B-6172E97F351A" class="sect4"><span class="enumeration_section">4.3.2 </span>Example of INDICATOR Variable Usage
                  </h4>
                  <div>
                     <p>Typically, you use indicator variables to assign NULLs to input host variables and detect NULLs or truncated values in output host variables. In the example later, you declare three host variables and one indicator variable, then use a SELECT statement to search the database for an employee number matching the value of host variable <span class="italic">emp_number</span>. When a matching row is found, Oracle sets output host variables <span class="italic">salary</span> and <span class="italic">commission</span> to the values of columns SAL and COMM in that row and stores a return code in indicator variable <span class="italic">ind_comm</span>. The next statements use <span class="italic">ind_comm</span> to select a course of action. 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; 
    int    emp_number; 
    float  salary, commission; 
    short comm_ind;  /* indicator variable  */
EXEC SQL END DECLARE SECTION;
    char temp[16];
    float  pay;      /* not used in a SQL statement */
...
printf("Employee number? "); 
gets(temp);
emp_number = atof(temp);
EXEC SQL SELECT SAL, COMM 
    INTO :salary, :commission:ind_comm 
    FROM EMP 
    WHERE EMPNO = :emp_number; 
if(ind_comm == -1)    /* commission is null */
    pay = salary; 
else
    pay = salary + commission; 
</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C">Indicator Variables</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3208"></a><div class="props_rev_3"><a id="GUID-7A86836F-2447-4C4C-ADDE-464384503EAF" name="GUID-7A86836F-2447-4C4C-ADDE-464384503EAF"></a><h4 id="LNPCC-GUID-7A86836F-2447-4C4C-ADDE-464384503EAF" class="sect4"><span class="enumeration_section">4.3.3 </span>INDICATOR Variable Guidelines
                  </h4>
                  <div>
                     <p>The following guidelines apply to declaring and referencing indicator variables. An indicator variable must</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Be declared explicitly (in the Declare Section if present) as a 2-byte integer.</p>
                        </li>
                        <li>
                           <p>Be prefixed with a colon (:) in SQL statements.</p>
                        </li>
                        <li>
                           <p>Immediately follow its host variable in SQL statements and PL/SQL blocks (unless preceded by the keyword INDICATOR).</p>
                        </li>
                     </ul>
                     <p>An indicator variable must <span class="italic">not</span>:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Be prefixed with a colon in host language statements. </p>
                        </li>
                        <li>
                           <p>Follow its host variable in host language statements. </p>
                        </li>
                        <li>
                           <p>Be an Oracle reserved word.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3209"></a><div class="props_rev_3"><a id="GUID-3D8018F2-E6F5-4222-BB9B-21729561FA61" name="GUID-3D8018F2-E6F5-4222-BB9B-21729561FA61"></a><h4 id="LNPCC-GUID-3D8018F2-E6F5-4222-BB9B-21729561FA61" class="sect4"><span class="enumeration_section">4.3.4 </span>Oracle Restrictions
                  </h4>
                  <div>
                     <p>When DBMS=V7 or V8, if you SELECT or FETCH a NULL into a host variable that has no indicator, Oracle issues the following error message:</p><pre class="oac_no_warn" dir="ltr">ORA-01405: fetched column value is NULL
</pre><p>When precompiling with MODE=ORACLE and DBMS=V7 or V8 specified, you can specify UNSAFE_NULL=YES to disable the ORA-01405 message. </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-738C5830-5089-4218-8C37-2CED2004C4BA">UNSAFE_NULL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3210"></a><div class="props_rev_3"><a id="GUID-33AC6FC8-EA9D-4C7F-ADAC-D01A0DF4E281" name="GUID-33AC6FC8-EA9D-4C7F-ADAC-D01A0DF4E281"></a><h3 id="LNPCC-GUID-33AC6FC8-EA9D-4C7F-ADAC-D01A0DF4E281" class="sect3"><span class="enumeration_section">4.4 </span>VARCHAR Variables 
               </h3>
               <div>
                  <p>You can use the VARCHAR pseudotype to declare variable-length character strings. When your program deals with strings that are output from, or input to, VARCHAR2 or LONG columns, you might find it more convenient to use VARCHAR host variables instead of standard C strings. The datatype name VARCHAR can be uppercase or lowercase, but it <span class="italic">cannot</span> be mixed case. In this Guide, uppercase is used to emphasize that VARCHAR is not a native C datatype. 
                  </p>
               </div><a id="LNPCC3211"></a><div class="props_rev_3"><a id="GUID-2CFEFD3E-61E4-4B86-92E7-35DCFAFFFA9D" name="GUID-2CFEFD3E-61E4-4B86-92E7-35DCFAFFFA9D"></a><h4 id="LNPCC-GUID-2CFEFD3E-61E4-4B86-92E7-35DCFAFFFA9D" class="sect4"><span class="enumeration_section">4.4.1 </span>VARCHAR Variable Declaration 
                  </h4>
                  <div>
                     <p>Think of a VARCHAR as an extended C type or pre-declared <span class="bold">struct</span>. For example, the precompiler expands the VARCHAR declaration<a id="d16109e2307" class="indexterm-anchor"></a><a id="d16109e2311" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">VARCHAR   username[20];
 </pre><p>into the following <span class="bold">struct</span> with array and length members: 
                     </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
â€ƒ   unsigned short  len; 
â€ƒ   unsigned char   arr[20]; 
} username; 
</pre><p>The advantage of using VARCHAR variables is that you can explicitly reference the length member of the VARCHAR structure after a SELECT or FETCH. Oracle puts the length of the selected character string in the length member. You can then use this member to do things such as adding the null ('\0') terminator<a id="d16109e2327" class="indexterm-anchor"></a>.
                     </p><pre class="oac_no_warn" dir="ltr">username.arr[username.len] = '\0'; 
</pre><p>or using the length in a <span class="italic">strncpy</span> or<span class="italic"> printf</span> statement; for example:
                     </p><pre class="oac_no_warn" dir="ltr">printf("Username is %.*s\n", username.len, username.arr);
</pre><p>You specify the maximum length of a VARCHAR variable in its declaration. The length must lie in the range 1.65533. For example, the following declaration is <span class="italic">invalid</span> because no length is specified:<a id="d16109e2349" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">VARCHAR   null_string[];    /* invalid */
</pre><p>The length specification holds the current length of the value stored in the array member.<a id="d16109e2358" class="indexterm-anchor"></a> 
                     </p>
                     <p>You can declare multiple VARCHARs on a single line; for example: </p><pre class="oac_no_warn" dir="ltr">VARCHAR emp_name[ENAME_LEN], dept_loc[DEPT_NAME_LEN];
</pre><p>The length specifier for a VARCHAR can be a <span class="bold">#define</span>d macro, or any complex expression that can be resolved to an integer at precompile time. 
                     </p>
                     <p>You can also declare pointers to VARCHAR datatypes. </p>
                     <div class="infoboxnote" id="GUID-2CFEFD3E-61E4-4B86-92E7-35DCFAFFFA9D__GUID-03A53C55-4D57-4382-94BB-8E873616F46E">
                        <p class="notep1">Note:</p>
                        <p>Do not attempt to use a typedef statement such as:</p><pre class="oac_no_warn" dir="ltr">typedef VARCHAR buf[64]; </pre><p>This causes errors during C compilation.</p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="advanced-topics.html#GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498">VARCHAR Variables and Pointers</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3212"></a><div class="props_rev_3"><a id="GUID-F2750CBE-D4BC-443C-9BB9-D3FA6D509556" name="GUID-F2750CBE-D4BC-443C-9BB9-D3FA6D509556"></a><h4 id="LNPCC-GUID-F2750CBE-D4BC-443C-9BB9-D3FA6D509556" class="sect4"><span class="enumeration_section">4.4.2 </span>VARCHAR Variable Referencing 
                  </h4>
                  <div>
                     <p>In SQL statements, you reference VARCHAR variables using the <span class="bold">struct</span> name prefixed with a colon, as the following example shows: 
                     </p><pre class="oac_no_warn" dir="ltr">... 
int       part_number; 
VARCHAR   part_desc[40]; 
... 
main() 
{ 
    ... 
    EXEC SQL SELECT pdesc INTO :part_desc 
        FROM parts 
        WHERE pnum = :part_number; 
    ... 
</pre><p>After the query is executed, <span class="italic">part_desc.len</span> holds the actual length of the character string retrieved from the database and stored in <span class="italic">part_desc.arr</span>. 
                     </p>
                     <p>In C statements, you reference VARCHAR variables using the component names, as the next example shows: </p><pre class="oac_no_warn" dir="ltr">printf("\n\nEnter part description: "); 
gets(part_desc.arr); 
/* You must set the length of the string
   before using the VARCHAR in an INSERT or UPDATE */
part_desc.len = strlen(part_desc.arr); </pre></div>
               </div><a id="LNPCC3213"></a><div class="props_rev_3"><a id="GUID-3D1C54A4-C722-4EC5-B4A3-83DDF91298DF" name="GUID-3D1C54A4-C722-4EC5-B4A3-83DDF91298DF"></a><h4 id="LNPCC-GUID-3D1C54A4-C722-4EC5-B4A3-83DDF91298DF" class="sect4"><span class="enumeration_section">4.4.3 </span>Return NULLs to a VARCHAR Variable 
                  </h4>
                  <div>
                     <p>Oracle automatically sets the length component of a VARCHAR output host variable. If you SELECT or FETCH a NULL into a VARCHAR, the server does not change the length or array members.</p>
                     <div class="infoboxnote" id="GUID-3D1C54A4-C722-4EC5-B4A3-83DDF91298DF__GUID-907C4BBB-1891-43D4-94D2-DD0508C05EED">
                        <p class="notep1">Note:</p>
                        <p>If you select a NULL into a VARCHAR host variable, and there is no associated indicator variable, an ORA-01405 error occurs at run time. Avoid this by coding indicator variables with all host variables. (As a temporary fix, use the UNSAFE_NULL=YES precompiler option. </p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-D85972A8-FA08-4BBC-B543-3F0BADBA0236">DBMS</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3214"></a><div class="props_rev_3"><a id="GUID-4F66D7A3-C2EF-4E95-A57B-ED0BFF2BDA5A" name="GUID-4F66D7A3-C2EF-4E95-A57B-ED0BFF2BDA5A"></a><h4 id="LNPCC-GUID-4F66D7A3-C2EF-4E95-A57B-ED0BFF2BDA5A" class="sect4"><span class="enumeration_section">4.4.4 </span>Insert NULLs Using VARCHAR Variables
                  </h4>
                  <div>
                     <p>If you set the length of a VARCHAR variable to zero before performing an UPDATE or INSERT statement, the column value is set to NULL. If the column has a NOT NULL constraint, Oracle returns an error.</p>
                  </div>
               </div><a id="LNPCC3215"></a><div class="props_rev_3"><a id="GUID-8A6E6A06-4166-4C06-AF30-3F875AD143F6" name="GUID-8A6E6A06-4166-4C06-AF30-3F875AD143F6"></a><h4 id="LNPCC-GUID-8A6E6A06-4166-4C06-AF30-3F875AD143F6" class="sect4"><span class="enumeration_section">4.4.5 </span>Pass VARCHAR Variables to a Function 
                  </h4>
                  <div>
                     <p>VARCHARs are structures, and most C compilers permit passing of structures to a function by value, and returning structures by copy out from functions. However, in Pro*C/C++ you must pass VARCHARs to functions by reference. The following example shows the correct way to pass a VARCHAR variable to a function: <a id="d16109e2465" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">VARCHAR emp_name[20]; 
... 
emp_name.len = 20; 
SELECT ename INTO :emp_name FROM emp 
WHERE empno = 7499; 
... 
print_employee_name(&amp;emp_name); /* pass by pointer */ 
... 
 
print_employee_name(name) 
VARCHAR *name; 
{ 
    ... 
    printf("name is %.*s\n", name-&gt;len, name-&gt;arr); 
    ... 
}</pre></div>
               </div><a id="LNPCC3216"></a><div class="props_rev_3"><a id="GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5" name="GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5"></a><h4 id="LNPCC-GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5" class="sect4"><span class="enumeration_section">4.4.6 </span>Find the Length of the VARCHAR Array Component 
                  </h4>
                  <div>
                     <p>When the precompiler processes a VARCHAR declaration, the actual length of the array element in the generated structure can be longer than that declared. For example, on a Sun Solaris system, the Pro*C/C++ declaration </p><pre class="oac_no_warn" dir="ltr">VARCHAR my_varchar[12];
 </pre><p>is expanded by the precompiler to</p><pre class="oac_no_warn" dir="ltr">struct my_varchar
{
    unsigned short len;
    unsigned char  arr[12];
};
</pre><p>However, the precompiler or the C compiler on this system pads the length of the array component to 14 bytes. This alignment requirement pads the total length of the structure to 16 bytes: 14 for the padded array and 2 bytes for the length. </p>
                     <p>The <code class="codeph">SQLVarcharGetLength()</code> (replaces the non-threaded <code class="codeph">sqlvcp()</code>) functionâ€”part of the SQLLIB runtime libraryâ€”returns the actual (possibly padded) length of the array member. <a id="d16109e2499" class="indexterm-anchor"></a><a id="d16109e2503" class="indexterm-anchor"></a></p>
                     <p>You pass the <code class="codeph">SQLVarcharGetLength()</code> function the length of the data for a VARCHAR host variable or a VARCHAR pointer host variable, and <code class="codeph">SQLVarcharGetLength()</code> returns the total length of the array component of the VARCHAR. The total length includes any padding that might be added by your C compiler. 
                     </p>
                     <p>The syntax of <code class="codeph">SQLVarcharGetLength()</code> is 
                     </p><pre class="oac_no_warn" dir="ltr">SQLVarcharGetLength (dvoid *context, unsigned long *datlen, unsigned long *totlen); 
</pre><p>For single-threaded applications, use <code class="codeph">sqlvcp()</code>. Put the length of the VARCHAR in the <code class="codeph">datlen</code> parameter before calling <code class="codeph">sqlvcp()</code>. When the function returns, the <code class="codeph">totlen</code> parameter contains the total length of the array element. Both parameters are pointers to unsigned long integers, so must be passed by reference. 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">New Names for SQLLIB Public Functions</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3217"></a><div class="props_rev_3"><a id="GUID-FA7D1173-C17F-4740-8E96-CB087D29394F" name="GUID-FA7D1173-C17F-4740-8E96-CB087D29394F"></a><h4 id="LNPCC-GUID-FA7D1173-C17F-4740-8E96-CB087D29394F" class="sect4"><span class="enumeration_section">4.4.7 </span>Example Program: Using sqlvcp()
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following example program shows how you can use the function in a Pro*C/C++ application. The example also uses the <code class="codeph">sqlgls()</code> function. The example declares a VARCHAR pointer, then uses the <code class="codeph">sqlvcp() </code>function to determine the size required for the VARCHAR buffer. The program FETCHes employee names from the EMP table and prints them. Finally, the example uses the <code class="codeph">sqlgls()</code> function to print out the SQL statement and its function code and length attributes. This program is available on-line as <code class="codeph">sqlvcp.pc</code> in your <code class="codeph">demo</code> directory.<a id="d16109e2573" class="indexterm-anchor"></a><a id="d16109e2577" class="indexterm-anchor"></a><a id="d16109e2583" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">/*
 *  The sqlvcp.pc program demonstrates how you can use the
 *  sqlvcp() function to determine the actual size of a
 *  VARCHAR struct. The size is then used as an offset to
 *  increment a pointer that steps through an array of
 *  VARCHARs.
 *
 *  This program also demonstrates the use of the sqlgls()
 *  function, to get the text of the last SQL statement executed.
 *  sqlgls() is described in the "Error Handling" chapter of
 *  The Programmer's Guide to the Oracle Pro*C/C++ Precompiler.
 */

#include &lt;stdio.h&gt; 
#include &lt;sqlca.h&gt;
#include &lt;sqlcpr.h&gt;

/*  Fake a VARCHAR pointer type. */ 

struct my_vc_ptr 
{ 
    unsigned short len; 
    unsigned char arr[32767]; 
}; 

/* Define a type for the VARCHAR pointer */
typedef struct my_vc_ptr my_vc_ptr; 
my_vc_ptr *vc_ptr; 


EXEC SQL BEGIN DECLARE SECTION; 
VARCHAR *names;  
int      limit;    /* for use in FETCH FOR clause  */ 
char    *username = "scott/tiger"; 
EXEC SQL END DECLARE SECTION; 
void sql_error(); 
extern void sqlvcp(), sqlgls(); 

main() 
{ 
    unsigned int vcplen, function_code, padlen, buflen; 
    int i; 
    char stmt_buf[120]; 

    EXEC SQL WHENEVER SQLERROR DO sql_error(); 

    EXEC SQL CONNECT :username; 
    printf("\nConnected.\n"); 
     
/*  Find number of rows in table. */ 
    EXEC SQL SELECT COUNT(*) INTO :limit FROM emp; 
     
     
/*  Declare a cursor for the FETCH statement. */ 
    EXEC SQL DECLARE emp_name_cursor CURSOR FOR 
    SELECT ename FROM emp; 
    EXEC SQL FOR :limit OPEN emp_name_cursor; 
     
/*  Set the desired DATA length for the VARCHAR. */ 
    vcplen = 10; 
     
/*  Use SQLVCP to help find the length to malloc. */ 
    sqlvcp(&amp;vcplen, &amp;padlen); 
    printf("Actual array length of VARCHAR is %ld\n", padlen); 
     
/*  Allocate the names buffer for names. 
    Set the limit variable for the FOR clause. */ 
    names = (VARCHAR *) malloc((sizeof (short) + 
    (int) padlen) * limit); 
    if (names == 0) 
    { 
        printf("Memory allocation error.\n"); 
        exit(1); 
    }
/*  Set the maximum lengths before the FETCH. 
 *  Note the "trick" to get an effective VARCHAR *.
 */ 
    for (vc_ptr = (my_vc_ptr *) names, i = 0; i &lt; limit; i++) 
    { 
        vc_ptr-&gt;len = (short) padlen; 
        vc_ptr = (my_vc_ptr *)((char *) vc_ptr + 
        padlen + sizeof (short)); 
    } 
/*  Execute the FETCH. */ 
    EXEC SQL FOR :limit FETCH emp_name_cursor INTO :names; 
     
/*  Print the results. */ 
    printf("Employee names--\n"); 
    
    for (vc_ptr = (my_vc_ptr *) names, i = 0; i &lt; limit; i++) 
    { 
        printf
         ("%.*s\t(%d)\n", vc_ptr-&gt;len, vc_ptr-&gt;arr, vc_ptr-&gt;len); 
        vc_ptr = (my_vc_ptr *)((char *) vc_ptr + 
                  padlen + sizeof (short)); 
    } 
     
/*  Get statistics about the most recent 
 *  SQL statement using SQLGLS. Note that 
 *  the most recent statement in this example 
 *  is not a FETCH, but rather "SELECT ENAME FROM EMP" 
 *  (the cursor).
 */ 
    buflen = (long) sizeof (stmt_buf); 
    
/*  The returned value should be 1, indicating no error. */ 
    sqlgls(stmt_buf, &amp;buflen, &amp;function_code);
    if (buflen != 0)
    { 
        /* Print out the SQL statement. */ 
        printf("The SQL statement was--\n%.*s\n", buflen, stmt_buf); 
     
        /* Print the returned length. */ 
        printf("The statement length is %ld\n", buflen); 
     
        /* Print the attributes. */ 
        printf("The function code is %ld\n", function_code); 
    
        EXEC SQL COMMIT RELEASE; 
        exit(0); 
    }
    else 
    { 
        printf("The SQLGLS function returned an error.\n"); 
        EXEC SQL ROLLBACK RELEASE; 
        exit(1); 
    } 
} 

void
sql_error() 
{ 
    char err_msg[512]; 
    int buf_len, msg_len;

     
    EXEC SQL WHENEVER SQLERROR CONTINUE; 
 
    buf_len = sizeof (err_msg); 
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len); 
    printf("%.*s\n", msg_len, err_msg); 
 
    EXEC SQL ROLLBACK RELEASE; 
    exit(1); 
} </pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">Handling Runtime Errors</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3218"></a><div class="props_rev_3"><a id="GUID-8561AF60-861B-4EA6-8ECF-EF460FDD3A76" name="GUID-8561AF60-861B-4EA6-8ECF-EF460FDD3A76"></a><h3 id="LNPCC-GUID-8561AF60-861B-4EA6-8ECF-EF460FDD3A76" class="sect3"><span class="enumeration_section">4.5 </span>Cursor Variables 
               </h3>
               <div>
                  <p>You can use <span class="italic">cursor variables</span> in your Pro*C/C++ program for queries. A cursor variable is a handle for a cursor that must be defined and opened on the Oracle server using PL/SQL. See <a href="../lnpls/static-sql.html#LNPLS-GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" target="_blank">Cursor Variables</a> for complete information about cursor variables. 
                  </p>
                  <p>The advantages of cursor variables are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Ease of maintenance</p>
                        <p>Queries are centralized, in the stored procedure that opens the cursor variable. If you need to change the cursor, you only need to make the change in one place: the stored procedure. There is no need to change each application.</p>
                     </li>
                     <li>
                        <p>Convenient security</p>
                        <p>The user of the application is the username used when the Pro*C/C++ application connects to the server. The user must have <span class="italic">execute</span> permission on the stored procedure that opens the cursor but not <span class="italic">read</span> permission on the tables used in the query. This capability can be used to limit access to the columns in the table, and access to other stored procedures.
                        </p>
                     </li>
                  </ul>
               </div><a id="LNPCC3219"></a><div class="props_rev_3"><a id="GUID-00ADF01B-452D-4FEC-8D21-8C7074E5623D" name="GUID-00ADF01B-452D-4FEC-8D21-8C7074E5623D"></a><h4 id="LNPCC-GUID-00ADF01B-452D-4FEC-8D21-8C7074E5623D" class="sect4"><span class="enumeration_section">4.5.1 </span>Declare a Cursor Variable
                  </h4>
                  <div>
                     <p>You declare a cursor variable in your Pro*C/C++ program using the Pro*C/C++ pseudotype SQL_CURSOR. For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
    sql_cursor     emp_cursor;             /* a cursor variable */
    SQL_CURSOR     dept_cursor;      /* another cursor variable */
    sql_cursor     *ecp;      /* a pointer to a cursor variable */
    ...
EXEC SQL END DECLARE SECTION;
ecp = &amp;emp_cursor;             /* assign a value to the pointer */
</pre><p>You can declare a cursor variable using the type specification SQL_CURSOR, in all upper case, or sql_cursor, in all lower case; you cannot use mixed case.</p>
                     <p>A cursor variable is just like any other host variable in the Pro*C/C++ program. It has scope, following the scope rules of C. You can pass it as a parameter to other functions, even functions external to the source file in which you declared it. You can also define functions that return cursor variables, or pointers to cursor variables. <a id="d16109e2668" class="indexterm-anchor"></a></p>
                     <div class="infoboxnote" id="GUID-00ADF01B-452D-4FEC-8D21-8C7074E5623D__GUID-92B34AEC-F630-42D8-AB58-224815116671">
                        <p class="notep1">Note:</p>
                        <p>A SQL_CURSOR is implemented as a C <span class="bold">struct</span> in the code that Pro*C/C++ generates. So you can always pass it by pointer to another function, or return a pointer to a cursor variable from a function. But you can only pass it or return it by value if your C compiler supports these operations. <a id="d16109e2678" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div><a id="LNPCC3220"></a><div class="props_rev_3"><a id="GUID-BA294213-D113-435B-BBBD-D3BAE7B597F8" name="GUID-BA294213-D113-435B-BBBD-D3BAE7B597F8"></a><h4 id="LNPCC-GUID-BA294213-D113-435B-BBBD-D3BAE7B597F8" class="sect4"><span class="enumeration_section">4.5.2 </span>Allocate a Cursor Variable
                  </h4>
                  <div>
                     <p>Before you can use a cursor variable, either to open it or to FETCH it, you must allocate the cursor. You do this using the new precompiler command ALLOCATE. For example, to allocate the SQL_CURSOR <span class="italic">emp_cursor</span> that was declared in the example earlier, you write the statement:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE :emp_cursor;
</pre><p>Allocating a cursor does <span class="italic">not</span> require a call to the server, either at precompile time or at runtime. If the ALLOCATE statement contains an error (for example, an undeclared host variable), Pro*C/C++ issues a precompile-time error. Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, you can free a cursor variable in a program loop. Memory allocated for cursor variables is <span class="italic">not</span> freed when the cursor is closed, but only when an explicit CLOSE is executed, or the connection is closed:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE :emp_cursor;
</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-A8B88F34-495A-4111-A303-2B4D79AB06A1">Closing and Freeing a Cursor Variable</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3221"></a><div class="props_rev_3"><a id="GUID-81CFBC10-B559-4155-A073-EEF2DE24661E" name="GUID-81CFBC10-B559-4155-A073-EEF2DE24661E"></a><h4 id="LNPCC-GUID-81CFBC10-B559-4155-A073-EEF2DE24661E" class="sect4"><span class="enumeration_section">4.5.3 </span>Open a Cursor Variable
                  </h4>
                  <div>
                     <p><a id="d16109e2751" class="indexterm-anchor"></a>You must open a cursor variable on the Oracle database server. You cannot use the embedded SQL OPEN command to open a cursor variable. You can open a cursor variable either by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement). Or, you can open and define a cursor variable using an anonymous PL/SQL block in your Pro*C/C++ program.
                     </p>
                     <p>For example, consider the following PL/SQL package, stored in the database:</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE demo_cur_pkg AS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE cur_type IS REF CURSOR RETURN EmpName;
    PROCEDURE open_emp_cur (
               curs     IN OUT cur_type,
               dept_num IN     NUMBER);
END;

CREATE PACKAGE BODY demo_cur_pkg AS
    CREATE PROCEDURE open_emp_cur (
               curs     IN OUT cur_type,
               dept_num IN     NUMBER) IS
    BEGIN
        OPEN curs FOR
            SELECT ename FROM emp
                WHERE deptno = dept_num
                ORDER BY ename ASC;
    END;
END;
</pre><p>After this package has been stored, you can open the cursor <span class="italic">curs </span>by calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*C/C++ program, and FETCH from the cursor in the program. For example:
                     </p><pre class="oac_no_warn" dir="ltr">...
sql_cursor    emp_cursor;
char          emp_name[11];
...
EXEC SQL ALLOCATE :emp_cursor;  /* allocate the cursor variable */
...
/* Open the cursor on the server side. */
EXEC SQL EXECUTE
    begin
        demo_cur_pkg.open_emp_cur(:emp_cursor, :dept_num);
    end;
;
EXEC SQL WHENEVER NOT FOUND DO break;
for (;;)
{
    EXEC SQL FETCH :emp_cursor INTO :emp_name;
    printf("%s\n", emp_name);
}
...
</pre><p>To open a cursor using a PL/SQL anonymous block in your Pro*C/C++ program, you define the cursor in the anonymous block. For example: <a id="d16109e2772" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">sql_cursor emp_cursor;
int dept_num = 10;
...
EXEC SQL EXECUTE
    BEGIN
        OPEN :emp_cursor FOR SELECT ename FROM emp
             WHERE deptno = :dept_num;
    END;
END-EXEC;
...
</pre><p>The earlier examples show how to use PL/SQL to open a cursor variable. You can also open a cursor variable using embedded SQL with the CURSOR clause:</p><pre class="oac_no_warn" dir="ltr">...
sql_cursor emp_cursor;
...
EXEC ORACLE OPTION(select_error=no);
EXEC SQL
    SELECT CURSOR(SELECT ename FROM emp WHERE deptno = :dept_num)
    INTO :emp_cursor FROM DUAL;
EXEC ORACLE OPTION(select_error=yes);
</pre><p>In the statement earlier, the emp_cursor cursor variable is bound to the first column of the outermost select. The first column is itself a query, but it is represented in the form compatible with a sql_cursor host variable since the CURSOR(...) conversion clause is used.</p>
                     <p>Before using queries which involve the CURSOR clause, you must set the SELECT_ERROR option to NO. This will prevent the cancellation of the parent cursor and allow the program to run without errors.</p>
                  </div><a id="LNPCC3222"></a><div class="props_rev_3"><a id="GUID-AE4B3349-E944-43DC-832E-7A5DC59ECF07" name="GUID-AE4B3349-E944-43DC-832E-7A5DC59ECF07"></a><h5 id="LNPCC-GUID-AE4B3349-E944-43DC-832E-7A5DC59ECF07" class="sect5"><span class="enumeration_section">4.5.3.1 </span>Opening in a Standalone Stored Procedure
                     </h5>
                     <div>
                        <p>In the example earlier, a reference cursor was defined inside a package, and the cursor was opened in a procedure in that package. But it is not always necessary to define a reference cursor inside the package that contains the procedures that open the cursor.</p>
                        <p>If you need to open a cursor inside a standalone stored procedure, you can define the cursor in a separate package, and then reference that package in the standalone stored procedure that opens the cursor. Here is an example:</p><pre class="oac_no_warn" dir="ltr">PACKAGE dummy IS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE emp_cursor_type IS REF CURSOR RETURN EmpName;
END;
-- and then define a standalone procedure:
PROCEDURE open_emp_curs (
      emp_cursor IN OUT dummy.emp_cursor_type;
      dept_num   IN     NUMBER) IS
    BEGIN
        OPEN emp_cursor FOR
            SELECT ename FROM emp WHERE deptno = dept_num;
    END;
END;</pre></div>
                  </div><a id="LNPCC3223"></a><div class="props_rev_3"><a id="GUID-FD78DAD2-7034-4CA8-8D36-3FB6A358DCA5" name="GUID-FD78DAD2-7034-4CA8-8D36-3FB6A358DCA5"></a><h5 id="LNPCC-GUID-FD78DAD2-7034-4CA8-8D36-3FB6A358DCA5" class="sect5"><span class="enumeration_section">4.5.3.2 </span>Return Types
                     </h5>
                     <div>
                        <p>When you define a reference cursor in a PL/SQL stored procedure, you must declare the type that the cursor returns.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="../lnpls/cursor-variable-declaration.html#LNPLS-GUID-CE884B31-07F0-46AA-8067-EBAF73821F3D" target="_blank"><span class="italic">Cursor Variable Declaration</span></a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCC3224"></a><div class="props_rev_3"><a id="GUID-A8B88F34-495A-4111-A303-2B4D79AB06A1" name="GUID-A8B88F34-495A-4111-A303-2B4D79AB06A1"></a><h4 id="LNPCC-GUID-A8B88F34-495A-4111-A303-2B4D79AB06A1" class="sect4"><span class="enumeration_section">4.5.4 </span>Closing and Freeing a Cursor Variable
                  </h4>
                  <div>
                     <p>Use the CLOSE command to close a cursor variable. For example, to close the <span class="italic">emp_cursor</span> cursor variable that was OPENed in the examples earlier, use the embedded SQL statement:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE :emp_cursor;
</pre><p>The cursor variable is a host variable, and so you must precede it with a colon. </p>
                     <p>You can reuse ALLOCATEd cursor variables. You can open, FETCH, and CLOSE as many times as needed for your application. However, if you disconnect from the server, then reconnect, you must re-ALLOCATE cursor variables.</p>
                     <p>Cursors are deallocated by the FREE embedded SQL statement. For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FREE :emp_cursor;
</pre><p>If the cursor is still open, it is closed and the memory allocated for it is released.</p>
                  </div>
               </div><a id="LNPCC3225"></a><div class="props_rev_3"><a id="GUID-86514859-8929-47EA-AE78-9D8831BB5838" name="GUID-86514859-8929-47EA-AE78-9D8831BB5838"></a><h4 id="LNPCC-GUID-86514859-8929-47EA-AE78-9D8831BB5838" class="sect4"><span class="enumeration_section">4.5.5 </span>Cursor Variables with the OCI (Release 7 Only)
                  </h4>
                  <div>
                     <p>You can share a Pro*C/C++ cursor variable with an OCI function. To do so, you must use the SQLLIB conversion functions,<code class="codeph"> SQLCDAFromResultSetCursor() </code>(formerly known as <code class="codeph">sqlcdat()</code>) and SQLCDAToResultSetCursor (formerly known as <code class="codeph">sqlcurt()</code>). These functions convert between OCI cursor data areas and Pro*C/C++ cursor variables.
                     </p>
                     <p>The <code class="codeph">SQLCDAFromResultSetCursor()</code> function translates an allocated cursor variable to an OCI cursor data area. The syntax is:
                     </p><pre class="oac_no_warn" dir="ltr">void SQLCDAFromResultSetCursor(dvoid *context, Cda_Def *cda, void *cur, 
   sword *retval);
</pre><p>where the parameters are:</p>
                     <div class="tblformal" id="GUID-86514859-8929-47EA-AE78-9D8831BB5838__GUID-94490E65-3290-4912-87DA-D25AFEC7AE98">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Parameters" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d16109e2883">Parameters</th>
                                 <th align="left" valign="bottom" width="71%" id="d16109e2886">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2891" headers="d16109e2883 ">
                                    <p>context</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2891 d16109e2886 ">
                                    <p>A pointer to the SQLLIB runtime context.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2898" headers="d16109e2883 ">
                                    <p>cda</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2898 d16109e2886 ">
                                    <p>A pointer to the destination OCI cursor data area.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2905" headers="d16109e2883 ">
                                    <p>cur</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2905 d16109e2886 ">
                                    <p>A pointer to the source Pro*C/C++ cursor variable.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2912" headers="d16109e2883 ">
                                    <p>retval</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2912 d16109e2886 ">
                                    <p>0 if no error, otherwise a SQLLIB (SQL) error number.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-86514859-8929-47EA-AE78-9D8831BB5838__GUID-28E23E82-0DF1-4CC5-9C93-C17CFADC1199">
                        <p class="notep1">Note:</p>
                        <p>In the case of an error, the <span class="italic">V2</span> and <span class="italic">rc</span> return code fields in the CDA also receive the error codes. The <span class="italic">rows processed count</span> field in the CDA is not set.
                        </p>
                        <p>For non-threaded or default context applications, pass the defined constant SQL_SINGLE_RCTX as the context.</p>
                     </div>
                     <p>The <code class="codeph">SQLCDAToResultSetCursor()</code> function translates an OCI cursor data area to a Pro*C/C++ cursor variable. The syntax is:
                     </p><pre class="oac_no_warn" dir="ltr">void SQLCDAToResultSetCursor(dvoid *context, void *cur, Cda_Def *cda, 
   int *retval);
</pre><p>where the parameters are:</p>
                     <div class="tblformal" id="GUID-86514859-8929-47EA-AE78-9D8831BB5838__GUID-439B354A-03E6-4F63-9E1C-B758DDDCC36F">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Parameters" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d16109e2949">Parameters</th>
                                 <th align="left" valign="bottom" width="71%" id="d16109e2952">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2957" headers="d16109e2949 ">
                                    <p>context</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2957 d16109e2952 ">
                                    <p>A pointer to the SQLLIB runtime context.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2964" headers="d16109e2949 ">
                                    <p>cur</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2964 d16109e2952 ">
                                    <p>A pointer to the destination Pro*C/C++ cursor variable.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2971" headers="d16109e2949 ">
                                    <p>cda</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2971 d16109e2952 ">
                                    <p>A pointer to the source OCI cursor data area.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d16109e2978" headers="d16109e2949 ">
                                    <p>retval</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d16109e2978 d16109e2952 ">
                                    <p>0 if no error, otherwise an error code.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-86514859-8929-47EA-AE78-9D8831BB5838__GUID-6D68A2C9-2B98-4BEA-9482-899E9185D588">
                        <p class="notep1">Note:</p>
                        <p>The SQLCA structure is not updated by this routine. The SQLCA components are only set after a database operation is performed using the translated cursor.</p>
                        <p>For non-threaded applications, pass the defined constant SQL_SINGLE_RCTX as the context.</p>
                     </div>
                     <p>ANSI and K&amp;R prototypes for these functions are provided in the <code class="codeph">sql2oci.h</code> header file. Memory for both <span class="italic">cda</span> and <span class="italic">cur</span> must be allocated prior to calling these functions.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">New Names for SQLLIB Public Functions</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3226"></a><div class="props_rev_3"><a id="GUID-CBE61601-7021-436E-BC49-D68D38E7D5D0" name="GUID-CBE61601-7021-436E-BC49-D68D38E7D5D0"></a><h4 id="LNPCC-GUID-CBE61601-7021-436E-BC49-D68D38E7D5D0" class="sect4"><span class="enumeration_section">4.5.6 </span>Restrictions (Cursor Variables)
                  </h4>
                  <div>
                     <p>The following restrictions apply to the use of cursor variables:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If you use the same cursor variable in Pro*C/C++ and OCI V7, then you must use either SQLLDAGetCurrent() or SQLLDAGetName() immediately after connecting.</p>
                        </li>
                        <li>
                           <p>You cannot translate a cursor variable to an OCI release 8 equivalent.</p>
                        </li>
                        <li>
                           <p>You cannot use cursor variables with dynamic SQL. <a id="d16109e3038" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>You can only use cursor variables with the ALLOCATE, FETCH, FREE, and CLOSE commands</p>
                        </li>
                        <li>
                           <p>The DECLARE CURSOR command does not apply to cursor variables. </p>
                        </li>
                        <li>
                           <p>You cannot FETCH from a CLOSEd cursor variable.</p>
                        </li>
                        <li>
                           <p>You cannot FETCH from a non-ALLOCATEd cursor variable.</p>
                        </li>
                        <li>
                           <p>If you precompile with MODE=ANSI, it is an error to close a cursor variable that is already closed.</p>
                        </li>
                        <li>
                           <p>You cannot use the AT clause with the ALLOCATE command, nor with the FETCH and CLOSE commands if they reference a cursor variable.</p>
                        </li>
                        <li>
                           <p>Cursor variables cannot be stored in columns in the database.</p>
                        </li>
                        <li>
                           <p>A cursor variable itself cannot be declared in a package specification. Only the <span class="italic">type</span> of the cursor variable can be declared in the package specification.
                           </p>
                        </li>
                        <li>
                           <p>A cursor variable cannot be a component of a PL/SQL record.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3227"></a><div class="props_rev_3"><a id="GUID-9F02336D-0AC6-420B-9E7E-8434F4B40543" name="GUID-9F02336D-0AC6-420B-9E7E-8434F4B40543"></a><h4 id="LNPCC-GUID-9F02336D-0AC6-420B-9E7E-8434F4B40543" class="sect4"><span class="enumeration_section">4.5.7 </span>Example: cv_demo.sql and sample11.pc
                  </h4>
                  <div>
                     <p>The following example programsâ€”a PL/SQL script and a Pro*C/C++ programâ€”demonstrate how you can use cursor variables. These sources are available on-line in your <code class="codeph">demo</code> directory. Also see another version of the same application,<code class="codeph"> cv_demo.pc</code>, in the demo directory.
                     </p>
                  </div><a id="LNPCC3228"></a><div class="props_rev_3"><a id="GUID-6813FCBB-18DB-45BE-BCE9-3420E9054FD1" name="GUID-6813FCBB-18DB-45BE-BCE9-3420E9054FD1"></a><h5 id="LNPCC-GUID-6813FCBB-18DB-45BE-BCE9-3420E9054FD1" class="sect5"><span class="enumeration_section">4.5.7.1 </span>cv_demo.sql
                     </h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">-- PL/SQL source for a package that declares and
-- opens a ref cursor
CONNECT SCOTT/TIGER;
CREATE OR REPLACE PACKAGE emp_demo_pkg as
   TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
     PROCEDURE open_cur(curs IN OUT emp_cur_type, dno IN NUMBER);
END emp_demo_pkg;
 
 
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS
    PROCEDURE open_cur(curs IN OUT emp_cur_type, dno IN NUMBER) IS
    BEGIN 
        OPEN curs FOR SELECT *
            FROM emp WHERE deptno = dno
            ORDER BY ename ASC;
    END;
END emp_demo_pkg;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3229"></a><div class="props_rev_3"><a id="GUID-28822FC2-51AD-4E0C-8096-BFDB132E9B43" name="GUID-28822FC2-51AD-4E0C-8096-BFDB132E9B43"></a><h5 id="LNPCC-GUID-28822FC2-51AD-4E0C-8096-BFDB132E9B43" class="sect5"><span class="enumeration_section">4.5.7.2 </span>sample11.pc
                     </h5>
                     <div><pre class="oac_no_warn" dir="ltr">/*
 *  Fetch from the EMP table, using a cursor variable.
 *  The cursor is opened in the stored PL/SQL procedure
 *  open_cur, in the EMP_DEMO_PKG package.
 *
 *  This package is available on-line in the file
 *  sample11.sql, in the demo directory.
 *
 */
 
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
 
/* Error handling function. */
void sql_error(msg)
    char *msg;
{
    size_t clen, fc;
    char cbuf[128];
 
    clen = sizeof (cbuf);
    sqlgls((char *)cbuf, (size_t *)&amp;clen, (size_t *)&amp;fc);
 
    printf("\n%s\n", msg);
    printf("Statement is--\n%s\n", cbuf);
    printf("Function code is %ld\n\n", fc);
 
    sqlglm((char *)cbuf, (size_t *) &amp;clen, (size_t *) &amp;clen);
    printf ("\n%.*s\n", clen, cbuf);
  
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_FAILURE);
}

void main()
{
    char temp[32];
 
    EXEC SQL BEGIN DECLARE SECTION;
        char *uid = "scott/tiger";
        SQL_CURSOR emp_cursor;
        int dept_num;
        struct
        {
            int   emp_num;
            char  emp_name[11];
            char  job[10];
            int   manager;
            char  hire_date[10];
            float salary;
            float commission;
            int   dept_num;
        } emp_info;
    
        struct
        {
            short emp_num_ind;
            short emp_name_ind;
            short job_ind;
            short manager_ind;
            short hire_date_ind;
            short salary_ind;
            short commission_ind;
            short dept_num_ind;
        } emp_info_ind;
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR do sql_error("Oracle error");
    
/* Connect to Oracle. */
    EXEC SQL CONNECT :uid;
 
/* Allocate the cursor variable. */
    EXEC SQL ALLOCATE :emp_cursor;
 
/* Exit the inner for (;;) loop when NO DATA FOUND. */
    EXEC SQL WHENEVER NOT FOUND DO break;
 
    for (;;)
    {
        printf("\nEnter department number  (0 to exit): ");
        gets(temp);
        dept_num = atoi(temp);
        if (dept_num &lt;= 0)
            break;
 
        EXEC SQL EXECUTE
            begin
                emp_demo_pkg.open_cur(:emp_cursor, :dept_num);
            end;
        END-EXEC;
 
        printf("\nFor department %d--\n", dept_num);
        printf("ENAME           SAL     COMM\n");
        printf("-----           ---     ----\n");
 
/* Fetch each row in the EMP table into the data struct.
   Note the use of a parallel indicator struct. */
        for (;;)
        {
             EXEC SQL FETCH :emp_cursor 
                 INTO :emp_info INDICATOR :emp_info_ind;
 
             printf("%s ", emp_info.emp_name);
             printf("%8.2f ", emp_info.salary);
             if (emp_info_ind.commission_ind != 0)
                 printf("    NULL\n");
             else
                 printf("%8.2f\n", emp_info.commission);
        }
 
    }
 
/* Close the cursor. */
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :emp_cursor;

/* Disconnect from Oracle. */
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_SUCCESS);

}</pre></div>
                  </div>
               </div>
            </div><a id="LNPCC3231"></a><a id="LNPCC3230"></a><div class="props_rev_3"><a id="GUID-4AF4D5FD-C41E-4597-BC33-6CF0266A5E84" name="GUID-4AF4D5FD-C41E-4597-BC33-6CF0266A5E84"></a><h3 id="LNPCC-GUID-4AF4D5FD-C41E-4597-BC33-6CF0266A5E84" class="sect3"><span class="enumeration_section">4.6 </span>CONTEXT Variables
               </h3>
               <div>
                  <p>A <span class="italic">runtime context</span>, usually simply called a context, is a handle to a an area in client memory which contains zero or more connections, zero or more cursors, their inline options (such as MODE, HOLD_CURSOR, RELEASE_CURSOR, SELECT_ERROR, and so on.) and other additional state information. 
                  </p>
                  <p>To define a context host variable use pseudo-type<span class="italic"> sql_context</span>. For example:
                  </p><pre class="oac_no_warn" dir="ltr">sql_context my_context ;
</pre><p>Use the CONTEXT ALLOCATE precompiler directive to allocate and initialize memory for a context:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT ALLOCATE :<span class="italic">context</span> ;
</pre><p>where <code class="codeph">context</code> is a host variable that is a handle to the context. For example:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT ALLOCATE :my_context ;
</pre><p>Use the CONTEXT USE precompiler directive to define which context is to be used by the embedded SQL statements (such as CONNECT, INSERT, DECLARE CURSOR, and so on.) from that point on in the source file, not in the flow of program logic. That context is used until another CONTEXT USE statement is encountered. The syntax is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT USE {:<span class="italic">context</span> | DEFAULT} ;
</pre><p>The keyword DEFAULT specifies that the default (also known as global) context is to be used in all the embedded SQL statements that are executed subsequently, until another CONTEXT USE directive is encountered. A simple example is: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT USE :my_context ;
</pre><p>If the context variable <code class="codeph">my_context</code> has not been defined and allocated already, an error is returned.
                  </p>
                  <p>The CONTEXT FREE statement frees the memory used by the context after it is no longer needed:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT FREE :<span class="italic">context</span> ;
</pre><p>An example is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONTEXT FREE :my_context ;
</pre><p>The following example demonstrates the use of a default context in the same application as a user-defined context:</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4AF4D5FD-C41E-4597-BC33-6CF0266A5E84__GUID-D27DCC80-75D5-4C78-8BEF-0D8F7828FED6">CONTEXT USE Example</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt;
#include &lt;ociextp.h&gt;
main()
{
   sql_context ctx1;
   char *usr1 = "scott/tiger";
   char *usr2 = "system/manager";

   /* Establish connection to SCOTT in global runtime context */
   EXEC SQL CONNECT :usr1;

   /* Establish connection to SYSTEM in runtime context ctx1 */
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT USE :ctx1;
   EXEC SQL CONNECT :usr2; 

   /* Insert into the emp table from schema SCOTT */
   EXEC SQL CONTEXT USE DEFAULT;
   EXEC SQL INSERT INTO emp (empno, ename) VALUES (1234, 'WALKER');
   ...
}</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC3232"></a><div class="props_rev_3"><a id="GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367" name="GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367"></a><h3 id="LNPCC-GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367" class="sect3"><span class="enumeration_section">4.7 </span>Universal ROWIDs
               </h3>
               <div>
                  <p>There are two kinds of table organization used in the database server: <span class="italic">heap tables</span> and i<span class="italic">ndex-organized tables</span>.
                  </p>
                  <p>Heap tables are the default. The physical row address (ROWID) is a permanent property that is used to identify a row in a heap table. The external character format of the physical ROWID is an 18-byte character string in base-64 encoding.</p>
                  <p>An index-organized table does not have physical row addresses as permanent identifiers. A <span class="italic">logical </span>ROWID is defined for these tables. When you use a SELECT ROWID ... statement from an index-organized table the ROWID is an opaque structure that contains the primary key of the table, control information, and an optional physical "guess". You can use this ROWID in a SQL statement containing a clause such as "WHERE ROWID =  ..." to retrieve values from the table.
                  </p>
                  <p>Universal ROWID can be used for both physical ROWID and logical ROWID. You can use universal ROWIDs to access data in heap tables, or index-organized tables, since the table organization can change with no effect on applications. The column datatype used for ROWID is UROWID(<span class="italic">length</span>), where <code class="codeph">length</code> is optional.
                  </p>
                  <p>Use the universal ROWID in all new applications.</p>
                  <p>Use a universal ROWID variable this way:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Declare it as type pointer to OCIRowid.</p>
                     </li>
                     <li>
                        <p>Allocate memory for the universal ROWID variable.</p>
                     </li>
                     <li>
                        <p>Use the universal ROWID as a host bind variable.</p>
                     </li>
                     <li>
                        <p>Free the memory when finished.</p>
                     </li>
                  </ul>
                  <p>For example:</p><pre class="oac_no_warn" dir="ltr">OCIRowid *my_urowid ;
...
EXEC SQL ALLOCATE :my_urowid ;
/* Bind my_urowid as type SQLT_RDD -- no implicit conversion */
EXEC SQL SELECT rowid INTO :my_urowid FROM my_table WHERE ... ;
...
EXEC SQL UPDATE my_table SET ... WHERE rowid = :my_urowid ;
EXEC SQL FREE my_urpwid ;
...
</pre><p>You also have the option of using a character host variable of width between 19 (18 bytes plus the null-terminator) and 4001 as the host bind variable for universal ROWID. Character-based universal ROWIDs are supported for heap tables only for backward compatibility. Because universal ROWID can be variable length, there can be truncation.</p>
                  <p>Use the character variable this way:</p><pre class="oac_no_warn" dir="ltr">/* n is based on table characteristics  */
int n=4001 ;
char my_urowid_char[n] ;
...
EXEC SQL ALLOCATE :my_urowid_char ;
/* Bind my_urowid_char as SQLT_STR  */
EXEC SQL SELECT rowid INTO :my_urowid_char FROM my_table WHERE ... ;
EXEC ORACLE OPTION(CHAR_MAP=STRING);
EXEC SQL UPDATE my_table SET ... WHERE rowid = :my_urowid_char ;
EXEC SQL FREE :my_urowid_char ;
...</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="embedded-SQL.html#GUID-1A65920B-74ED-41FB-B120-C46A8EA86018">Positioned Update</a></li>
                        <li><a href="../cncpt/logical-storage-structures.html#CNCPT-GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D" target="_blank"><span class="italic">Logical Storage Structures</span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3233"></a><div class="props_rev_3"><a id="GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910" name="GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910"></a><h4 id="LNPCC-GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910" class="sect4"><span class="enumeration_section">4.7.1 </span>SQLRowidGet()
                  </h4>
                  <div>
                     <p>A SQLLIB function, SQLRowidGet(), provides the ability to retrieve a pointer to the universal ROWID of the last row inserted, updated, or selected. The function prototype and its arguments are:</p><pre class="oac_no_warn" dir="ltr">void SQLRowidGet (dvoid *rctx, OCIRowid **urid) ;
</pre><p>rctx (IN) </p>
                     <p>is a pointer to a runtime context. For the default context or a non-threaded case, pass SQL_SINGLE_RCTX.</p>
                     <p>urid (OUT)</p>
                     <p>is a pointer to a universal ROWID pointer. When a normal execution finishes, this will point to a valid ROWID. In case of an error, NULL is returned.</p>
                     <div class="infoboxnote" id="GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910__GUID-EDEF2AC1-3BA8-411F-8A1F-1BB7C54A48AA">
                        <p class="notep1">Note:</p>
                        <p>The universal ROWID pointer must<span class="bold"> </span>have been previously allocated to call SQLRowidGet(). Use FREE afterward on the universal ROWID.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3234"></a><div class="props_rev_3"><a id="GUID-755B5F00-C7D7-4F3F-87FD-2AF5E5703D36" name="GUID-755B5F00-C7D7-4F3F-87FD-2AF5E5703D36"></a><h3 id="LNPCC-GUID-755B5F00-C7D7-4F3F-87FD-2AF5E5703D36" class="sect3"><span class="enumeration_section">4.8 </span>Host Structures 
               </h3>
               <div>
                  <p>You can use a C structure to contain host variables. You reference a structure containing host variables in the INTO clause of a SELECT or a FETCH statement, and in the VALUES list of an INSERT statement. Every component of the host structure must be a legal Pro*C/C++ host variable, as defined in <a href="datatypes-and-host-variables.html#GUID-843D717B-B10E-4D4B-AAC5-7B4755379604__g39867" title="C Datatypes for Host Variables">Table 4-4</a>.
                  </p>
                  <p>When a structure is used as a host variable, only the name of the structure is used in the SQL statement. However, each of the members of the structure sends data to Oracle, or receives data from Oracle on a query. The following example shows a host structure that is used to add an employee to the EMP table: </p><pre class="oac_no_warn" dir="ltr">typedef struct 
{ 
    char  emp_name[11]; /* one greater than column length */ 
    int   emp_number; 
    int   dept_number; 
    float salary; 
} emp_record; 
... 
/* define a new structure of type "emp_record" */ 
emp_record new_employee; 
 
strcpy(new_employee.emp_name, "CHEN"); 
new_employee.emp_number = 9876; 
new_employee.dept_number = 20; 
new_employee.salary = 4250.00; 
 
EXEC SQL INSERT INTO emp (ename, empno, deptno, sal) 
    VALUES (:new_employee); 
</pre><p>The order that the members are declared in the structure must match the order that the associated columns occur in the SQL statement, or in the database table if the column list in the INSERT statement is omitted. </p>
                  <p>For example, the following use of a host structure is <span class="italic">invalid</span>, and causes a runtime error: 
                  </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    int empno; 
    float salary;          /* struct components in wrong order */
    char emp_name[10]; 
} emp_record; 
 
... 
SELECT empno, ename, sal 
   INTO :emp_record FROM emp; 
</pre><p>The example is wrong because the components of the structure are not declared in the same order as the associated columns in the select list. The correct form of the SELECT statement is: </p><pre class="oac_no_warn" dir="ltr">SELECT empno, sal, ename   /* reverse order of sal and ename */
    INTO :emp_record FROM emp;</pre></div><a id="LNPCC3235"></a><div class="props_rev_3"><a id="GUID-DFA577FA-20C1-408E-A7F0-C15D34A45D47" name="GUID-DFA577FA-20C1-408E-A7F0-C15D34A45D47"></a><h4 id="LNPCC-GUID-DFA577FA-20C1-408E-A7F0-C15D34A45D47" class="sect4"><span class="enumeration_section">4.8.1 </span>Host Structures and Arrays 
                  </h4>
                  <div>
                     <p>An <span class="italic">array</span> is a collection of related data items, called <span class="italic">elements</span>, associated with a single variable name. When declared as a host variable, the array is called a <span class="italic">host array</span>. Likewise, an indicator variable declared as an array is called an <span class="italic">indicator array</span>. An indicator array can be associated with any host array.<a id="d16109e3380" class="indexterm-anchor"></a> 
                     </p>
                     <p>Host arrays can increase performance by letting you manipulate an entire collection of data items with a single SQL statement. With few exceptions, you can use host arrays wherever scalar host variables are allowed. Also, you can associate an indicator array with any host array. </p>
                     <p>You can use host arrays as components of host structures. In the following example, a structure containing arrays is used to INSERT three new entries into the EMP table: </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    char emp_name[3][10]; 
    int emp_number[3]; 
    int dept_number[3]; 
} emp_rec; 
... 
strcpy(emp_rec.emp_name[0], "ANQUETIL"); 
strcpy(emp_rec.emp_name[1], "MERCKX"); 
strcpy(emp_rec.emp_name[2], "HINAULT"); 
emp_rec.emp_number[0] = 1964; emp_rec.dept_number[0] = 5; 
emp_rec.emp_number[1] = 1974; emp_rec.dept_number[1] = 5; 
emp_rec.emp_number[2] = 1985; emp_rec.dept_number[2] = 5; 
 
EXEC SQL INSERT INTO emp (ename, empno, deptno) 
    VALUES (:emp_rec); 
...</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2">Host Arrays</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3236"></a><div class="props_rev_3"><a id="GUID-D10478D8-E5CA-4042-9888-5E61F13A487C" name="GUID-D10478D8-E5CA-4042-9888-5E61F13A487C"></a><h4 id="LNPCC-GUID-D10478D8-E5CA-4042-9888-5E61F13A487C" class="sect4"><span class="enumeration_section">4.8.2 </span>PL/SQL Records
                  </h4>
                  <div>
                     <p>You cannot bind a C <span class="bold">struct</span> to a PL/SQL record. <a id="d16109e3414" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3237"></a><div class="props_rev_3"><a id="GUID-DC40E72F-3A0F-49D0-8672-46D3645E1AFF" name="GUID-DC40E72F-3A0F-49D0-8672-46D3645E1AFF"></a><h4 id="LNPCC-GUID-DC40E72F-3A0F-49D0-8672-46D3645E1AFF" class="sect4"><span class="enumeration_section">4.8.3 </span>Nested Structures and Unions    
                  </h4>
                  <div>
                     <p> <a id="d16109e3438" class="indexterm-anchor"></a>You cannot nest host structures. The following example is <span class="italic">invalid</span>:<a id="d16109e3446" class="indexterm-anchor"></a><a id="d16109e3450" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    int emp_number; 
    struct 
    { 
        float salary; 
        float commission; 
    } sal_info;            /* INVALID */ 
    int dept_number; 
} emp_record; 
... 
EXEC SQL SELECT empno, sal, comm, deptno 
    INTO :emp_record 
    FROM emp; 
</pre><p>Also, you cannot use a C <span class="bold">union</span> as a host structure, nor can you nest a <span class="bold">union</span> in a structure that is to be used as a host structure. 
                     </p>
                  </div>
               </div><a id="LNPCC3238"></a><div class="props_rev_3"><a id="GUID-345907F5-DB09-4008-B7CA-3F3CA0FB7502" name="GUID-345907F5-DB09-4008-B7CA-3F3CA0FB7502"></a><h4 id="LNPCC-GUID-345907F5-DB09-4008-B7CA-3F3CA0FB7502" class="sect4"><span class="enumeration_section">4.8.4 </span>Host Indicator Structures 
                  </h4>
                  <div>
                     <p>When you need to use indicator variables, but your host variables are contained in a host structure, you set up a second structure that contains an indicator variable for each host variable in the host structure.</p>
                     <p>For example, suppose you declare a host structure<span class="italic"> student_record</span> as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    char s_name[32]; 
    int s_id; 
    char grad_date[9]; 
} student_record; 
</pre><p>If you want to use the host structure in a query such as </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT student_name, student_idno, graduation_date 
    INTO :student_record 
    FROM college_enrollment 
    WHERE student_idno = 7200; 
</pre><p>and you need to know if the graduation date can be NULL, then you must declare a separate host indicator structure. You declare this as </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    short s_name_ind;  /* indicator variables must be shorts */ 
    short s_id_ind; 
    short grad_date_ind; 
} student_record_ind; 
</pre><p>Reference the indicator structure in the SQL statement in the same way that you reference a host indicator variable: </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT student_name, student_idno, graduation_date 
    INTO :student_record INDICATOR :student_record_ind 
    FROM college_enrollment 
    WHERE student_idno = 7200;
 </pre><p>When the query completes, the NULL/NOT NULL status of each selected component is available in the host indicator structure. </p>
                     <div class="infoboxnote" id="GUID-345907F5-DB09-4008-B7CA-3F3CA0FB7502__GUID-6914528D-5113-4EF0-AE2B-A303ECA60729">
                        <p class="notep1">Note:</p>
                        <p>This Guide conventionally names indicator variables and indicator structures by appending <span class="italic">_ind</span> to the host variable or structure name. However, the names of indicator variables are completely arbitrary. You can adopt a different convention, or use no convention at all. <a id="d16109e3509" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div><a id="LNPCC3239"></a><div class="props_rev_3"><a id="GUID-8B48C0C8-3FE0-42CD-A4BB-1CDD360E5E6B" name="GUID-8B48C0C8-3FE0-42CD-A4BB-1CDD360E5E6B"></a><h4 id="LNPCC-GUID-8B48C0C8-3FE0-42CD-A4BB-1CDD360E5E6B" class="sect4"><span class="enumeration_section">4.8.5 </span>Example Program: Cursor and a Host Structure 
                  </h4>
                  <div>
                     <div class="section">
                        <p>The demonstration program in this section shows a query that uses an explicit cursor, selecting data into a host structure. This program is available in the file <code class="codeph">sample2.pc</code> in your <code class="codeph">demo</code> directory. 
                        </p><pre class="oac_no_warn" dir="ltr">/*
 *  sample2.pc
 *
 *  This program connects to ORACLE, declares and opens a cursor, 
 *  fetches the names, salaries, and commissions of all
 *  salespeople, displays the results, then closes the cursor. 
 */ 

#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;

#define UNAME_LEN      20 
#define PWD_LEN        40 
 
/*
 * Use the precompiler typedef'ing capability to create
 * null-terminated strings for the authentication host
 * variables. (This isn't really necessary--plain char *'s
 * does work as well. This is just for illustration.)
 */
typedef char asciiz[PWD_LEN]; 

EXEC SQL TYPE asciiz IS STRING(PWD_LEN) REFERENCE; 
asciiz     username; 
asciiz     password; 

struct emp_info 
{ 
    asciiz     emp_name; 
    float      salary; 
    float      commission; 
}; 


/* Declare function to handle unrecoverable errors. */ 
void sql_error(); 


main() 
{ 
    struct emp_info *emp_rec_ptr; 

/* Allocate memory for emp_info struct. */ 
    if ((emp_rec_ptr = 
        (struct emp_info *) malloc(sizeof(struct emp_info))) == 0)
    { 
        fprintf(stderr, "Memory allocation error.\n"); 
        exit(1); 
    } 
 
/* Connect to ORACLE. */ 
    strcpy(username, "SCOTT"); 
    strcpy(password, "TIGER"); 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error--");
 
    EXEC SQL CONNECT :username IDENTIFIED BY :password; 
    printf("\nConnected to ORACLE as user: %s\n", username); 
 
/* Declare the cursor. All static SQL explicit cursors
 * contain SELECT commands. 'salespeople' is a SQL identifier,
 * not a (C) host variable.
 */
    EXEC SQL DECLARE salespeople CURSOR FOR 
        SELECT ENAME, SAL, COMM 
            FROM EMP 
            WHERE JOB LIKE 'SALES%'; 
 
/* Open the cursor. */
    EXEC SQL OPEN salespeople; 
 
/* Get ready to print results. */
    printf("\n\nThe company's salespeople are--\n\n");
    printf("Salesperson   Salary   Commission\n"); 
    printf("-----------   ------   ----------\n"); 
 
/* Loop, fetching all salesperson's statistics.
 * Cause the program to break the loop when no more
 * data can be retrieved on the cursor.
 */
    EXEC SQL WHENEVER NOT FOUND DO break; 

    for (;;) 
    { 
        EXEC SQL FETCH salespeople INTO :emp_rec_ptr; 
        printf("%-11s%9.2f%13.2f\n", emp_rec_ptr-&gt;emp_name, 
                emp_rec_ptr-&gt;salary, emp_rec_ptr-&gt;commission); 
    } 
 
/* Close the cursor. */
    EXEC SQL CLOSE salespeople; 
 
    printf("\nArrivederci.\n\n");

    EXEC SQL COMMIT WORK RELEASE; 
    exit(0); 
} 



void 
sql_error(msg) 
char *msg;
{ 
    char err_msg[512];
    int buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf("\n%s\n", msg);

/* Call sqlglm() to get the complete text of the
 * error message.
 */
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len);
    printf("%.*s\n", msg_len, err_msg);

    EXEC SQL ROLLBACK RELEASE;
    exit(1);
} </pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC3240"></a><div class="props_rev_3"><a id="GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8" name="GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8"></a><h3 id="LNPCC-GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8" class="sect3"><span class="enumeration_section">4.9 </span>Pointer Variables 
               </h3>
               <div>
                  <p>C supports <span class="italic">pointers</span>, which "point" to other variables. A pointer holds the address (storage location) of a variable, not its value.<a id="d16109e3554" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCC3241"></a><div class="props_rev_3"><a id="GUID-B78A2FF2-F5B9-42E8-B83D-1E87C0DF40D1" name="GUID-B78A2FF2-F5B9-42E8-B83D-1E87C0DF40D1"></a><h4 id="LNPCC-GUID-B78A2FF2-F5B9-42E8-B83D-1E87C0DF40D1" class="sect4"><span class="enumeration_section">4.9.1 </span>Pointer Variable Declaration 
                  </h4>
                  <div>
                     <p>You define pointers as host variables following the normal C practice, as the next example shows:<a id="d16109e3570" class="indexterm-anchor"></a><a id="d16109e3574" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int   *int_ptr; 
char  *char_ptr;</pre></div>
               </div><a id="LNPCC3242"></a><div class="props_rev_3"><a id="GUID-555A6C7C-6E35-4778-B5CE-2E970B112BCF" name="GUID-555A6C7C-6E35-4778-B5CE-2E970B112BCF"></a><h4 id="LNPCC-GUID-555A6C7C-6E35-4778-B5CE-2E970B112BCF" class="sect4"><span class="enumeration_section">4.9.2 </span>Pointer Variable Referencing 
                  </h4>
                  <div>
                     <p>In SQL statements, prefix pointers with a colon, as shown in the following example:<a id="d16109e3592" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT intcol INTO :int_ptr FROM ... 
</pre><p>Except for pointers to character strings, the size of the referenced value is given by the size of the base type specified in the declaration. For pointers to character strings, the referenced value is assumed to be a NULL-terminated string. Its size is determined at run time by calling the <code class="codeph">strlen() </code>function. <a id="d16109e3604" class="indexterm-anchor"></a> 
                     </p>
                     <p>You can use pointers to reference the members of a <span class="bold">struct</span>. First, declare a pointer host variable, then set the pointer to the address of the desired member, as shown in the example later. The datatypes of the <span class="bold">struct</span> member and the pointer variable must be the same. Most compilers will warn you of a mismatch.<a id="d16109e3617" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">struct 
{ 
    int  i; 
    char c; 
} structvar; 
int   *i_ptr; 
char  *c_ptr; 
... 
main() 
{ 
    i_ptr = &amp;structvar.i; 
    c_ptr = &amp;structvar.c; 
/* Use i_ptr and c_ptr in SQL statements. */ 
... 
</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3">Globalization Support</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3243"></a><div class="props_rev_3"><a id="GUID-AE9924EA-0731-4AC9-BED0-2C52E8A2A808" name="GUID-AE9924EA-0731-4AC9-BED0-2C52E8A2A808"></a><h4 id="LNPCC-GUID-AE9924EA-0731-4AC9-BED0-2C52E8A2A808" class="sect4"><span class="enumeration_section">4.9.3 </span>Structure Pointers   
                  </h4>
                  <div>
                     <p>You can use a pointer to a structure as a host variable. The following example</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Declares a structure </p>
                        </li>
                        <li>
                           <p>Declares a pointer to the structure </p>
                        </li>
                        <li>
                           <p>Allocates memory for the structure </p>
                        </li>
                        <li>
                           <p>Uses the struct pointer as a host variable in a query </p>
                        </li>
                        <li>
                           <p>Dereferences the struct components to print the results </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">struct EMP_REC 
{ 
    int emp_number; 
    float salary; 
}; 
char *name = "HINAULT"; 
... 
struct EMP_REC *sal_rec; 
sal_rec = (struct EMP_REC *) malloc(sizeof (struct EMP_REC)); 
... 
EXEC SQL SELECT empno, sal INTO :sal_rec 
    FROM emp 
    WHERE ename = :name; 

printf("Employee number and salary for %s: ", name); 
printf("%d, %g\n", sal_rec-&gt;emp_number, sal_rec-&gt;salary);
</pre><p>In the SQL statement, pointers to host structures are referred to in exactly the same way as a host structure. The "address of" notation (<span class="bold">&amp;</span>) is not required; in fact, it is an error to use it. 
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3245"></a><a id="LNPCC3244"></a><div class="props_rev_3"><a id="GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3" name="GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3"></a><h3 id="LNPCC-GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3" class="sect3"><span class="enumeration_section">4.10 </span>Globalization Support
               </h3>
               <div>
                  <p>Although the widely-used 7- or 8-bit ASCII and EBCDIC character sets are adequate to represent the Roman alphabet, some Asian languages, such as Japanese, contain thousands of characters. These languages can require at least 16 bits (two bytes) to represent each character. How does Oracle deal with such dissimilar languages? </p>
                  <p>Oracle provides Globalization Support, which lets you process single-byte and multibyte character data and convert between character sets. It also lets your applications run in different language environments. With Globalization Support, number and date formats adapt automatically to the language conventions specified for a user session. Thus, Globalization Support allows users around the world to interact with Oracle in their native languages. </p>
                  <p>You control the operation of language-dependent features by specifying various Globalization Support or NLS parameters. Default values for these parameters can be set in the Oracle initialization file. The following table shows what each Globalization Support parameter specifies.<a id="d16109e3690" class="indexterm-anchor"></a><a id="d16109e3692" class="indexterm-anchor"></a><a id="d16109e3694" class="indexterm-anchor"></a><a id="d16109e3698" class="indexterm-anchor"></a><a id="d16109e3702" class="indexterm-anchor"></a><a id="d16109e3706" class="indexterm-anchor"></a><a id="d16109e3710" class="indexterm-anchor"></a><a id="d16109e3714" class="indexterm-anchor"></a><a id="d16109e3718" class="indexterm-anchor"></a></p>
                  <div class="tblformal" id="GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3__GUID-083D0116-F87C-4BE3-8229-D13E9AE3679D">
                     <p class="titleintable">Table 4-6 <span class="bold" id="GUID-2CCB3206-DE6F-4C67-B44E-83BB14C09BF3__I22631"> Globalization Support Parameters</span></p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title=" Globalization Support Parameters" summary="Globalization Suport Parameters" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="47%" id="d16109e3733">Globalization Support Parameter</th>
                              <th align="left" valign="bottom" width="53%" id="d16109e3736">Specifies</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3741" headers="d16109e3733 ">
                                 <p>NLS_LANGUAGE</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3741 d16109e3736 ">
                                 <p>language-dependent conventions</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3748" headers="d16109e3733 ">
                                 <p>NLS_TERRITORY</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3748 d16109e3736 ">
                                 <p>territory-dependent conventions</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3755" headers="d16109e3733 ">
                                 <p>NLS_DATE_FORMAT</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3755 d16109e3736 ">
                                 <p>date format</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3762" headers="d16109e3733 ">
                                 <p>NLS_DATE_LANGUAGE</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3762 d16109e3736 ">
                                 <p>language for day and month names</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3769" headers="d16109e3733 ">
                                 <p>NLS_NUMERIC_CHARACTERS</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3769 d16109e3736 ">
                                 <p>decimal character and group separator</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3776" headers="d16109e3733 ">
                                 <p>NLS_CURRENCY</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3776 d16109e3736 ">
                                 <p>local currency symbol</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3783" headers="d16109e3733 ">
                                 <p>NLS_ISO_CURRENCY</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3783 d16109e3736 ">
                                 <p>ISO currency symbol</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d16109e3790" headers="d16109e3733 ">
                                 <p>NLS_SORT</p>
                              </td>
                              <td align="left" valign="top" width="53%" headers="d16109e3790 d16109e3736 ">
                                 <p>sort sequence</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>The main parameters are NLS_LANGUAGE and NLS_TERRITORY. NLS_LANGUAGE specifies the default values for language-dependent features, which include:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Language for server messages </p>
                     </li>
                     <li>
                        <p>Language for day and month names </p>
                     </li>
                     <li>
                        <p>Sort sequence </p>
                     </li>
                  </ul>
                  <p>NLS_TERRITORY specifies the default values for territory-dependent features, which include </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Date format </p>
                     </li>
                     <li>
                        <p>Decimal character </p>
                     </li>
                     <li>
                        <p>Group separator </p>
                     </li>
                     <li>
                        <p>Local currency symbol </p>
                     </li>
                     <li>
                        <p>ISO currency symbol </p>
                     </li>
                  </ul>
                  <p>You can control the operation of language-dependent Globalization Support features for a user session by specifying the parameter NLS_LANG as follows: <a id="d16109e3828" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">NLS_LANG = &lt;language&gt;_&lt;territory&gt;.&lt;character set&gt; 
</pre><p>where <span class="italic">language</span> specifies the value of NLS_LANGUAGE for the user session, <span class="italic">territory</span> specifies the value of NLS_TERRITORY, and <span class="italic">character set</span> specifies the encoding scheme used for the terminal. An <span class="italic">encoding scheme</span> (usually called a character set or code page) is a range of numeric codes that corresponds to the set of characters a terminal can display. It also includes codes that control communication with the terminal.<a id="d16109e3848" class="indexterm-anchor"></a><a id="d16109e3850" class="indexterm-anchor"></a><a id="d16109e3853" class="indexterm-anchor"></a> 
                  </p>
                  <p>You define NLS_LANG as an environment variable (or the equivalent on your system). For example, on UNIX using the C shell, you might define NLS_LANG as follows: </p><pre class="oac_no_warn" dir="ltr">setenv NLS_LANG French_France.WE8ISO8859P1 
</pre><p>During an Oracle database session you can change the values of Globalization Support parameters. Use the ALTER SESSION statement as follows: </p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET &lt;globalization support_parameter&gt; = &lt;value&gt;
</pre><p>Pro*C/C++ fully supports all the Globalization Support features that allow your applications to process foreign language data stored in an Oracle database. For example, you can declare foreign language character variables and pass them to string functions such as INSTRB, LENGTHB, and SUBSTRB. These functions have the same syntax as the INSTR, LENGTH, and SUBSTR functions, respectively, but operate on a byte-by-byte basis rather than a character-by-character basis.<a id="d16109e3869" class="indexterm-anchor"></a> 
                  </p>
                  <p>You can use the functions NLS_INITCAP, NLS_LOWER, and NLS_UPPER to handle special instances of case conversion. And, you can use the function NLSSORT to specify WHERE-clause comparisons based on linguistic rather than binary ordering. You can even pass globalization support parameters to the TO_CHAR, TO_DATE, and TO_NUMBER functions. </p>
               </div>
            </div><a id="LNPCC3246"></a><div class="props_rev_3"><a id="GUID-B7DF37DC-3027-47E3-8F51-1910BAEF7E52" name="GUID-B7DF37DC-3027-47E3-8F51-1910BAEF7E52"></a><h3 id="LNPCC-GUID-B7DF37DC-3027-47E3-8F51-1910BAEF7E52" class="sect3"><span class="enumeration_section">4.11 </span>NCHAR Variables
               </h3>
               <div>
                  <p>Three internal database datatypes can store National Character Set data. They are <span class="italic">NCHAR, NCLOB,</span> and <span class="italic">NVARCHAR2</span> (also known as <span class="italic">NCHAR VARYING)</span>. You use these datatypes only in relational columns. 
                  </p>
               </div><a id="LNPCC3247"></a><div class="props_rev_3"><a id="GUID-4E8D9C89-C151-4714-8BC6-74C8CF6786B1" name="GUID-4E8D9C89-C151-4714-8BC6-74C8CF6786B1"></a><h4 id="LNPCC-GUID-4E8D9C89-C151-4714-8BC6-74C8CF6786B1" class="sect4"><span class="enumeration_section">4.11.1 </span>CHARACTER SET [IS] NCHAR_CS
                  </h4>
                  <div>
                     <p>To specify which host variables hold National Character Set data, insert the clause "<span class="italic">CHARACTER SET [IS] NCHAR_CS"</span> in character variable declarations. Then you are able to store National Character Set data in those variables. You can omit the token <span class="italic">IS</span>. NCHAR_CS is the name of the National Character Set. 
                     </p>
                     <p>For example:</p><pre class="oac_no_warn" dir="ltr">char character set is nchar_cs *str = <span class="bold">"&lt;</span>Japanese_string&gt;<span class="bold">";</span>
</pre><p>In this example,<span class="italic"> &lt;Japanese_string&gt;</span> consists of Unicode characters that are in the National Character Set <span class="italic">AL16UTF16</span>, as defined by the variable NLS_NCHAR. 
                     </p>
                     <p>You can accomplish the same thing by entering NLS_CHAR=str on the command line, and coding in your application:</p><pre class="oac_no_warn" dir="ltr">char *str = "&lt;Japanese_string&gt;"
</pre><p>Pro*C/C++ treats variables declared this way as of the character set specified by the environment variable <span class="italic">NLS_NCHAR</span>. The variable size of an NCHAR variable is specified as a byte count, the same way that ordinary C variables are.
                     </p>
                     <p>To select data into str, use the following simple query:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL
   SELECT ENAME INTO :str FROM EMP WHERE DEPT = n'&lt;Japanese_string1&gt;';
</pre><p>Or, you can use <span class="italic">str </span>in the following SELECT:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL 
   SELECT DEPT INTO :dept FROM DEPT_TAB WHERE ENAME = :str;</pre></div>
               </div><a id="LNPCC3248"></a><div class="props_rev_3"><a id="GUID-5B6EBB19-E0F0-4625-874B-75D034B8C339" name="GUID-5B6EBB19-E0F0-4625-874B-75D034B8C339"></a><h4 id="LNPCC-GUID-5B6EBB19-E0F0-4625-874B-75D034B8C339" class="sect4"><span class="enumeration_section">4.11.2 </span>Environment Variable NLS_NCHAR
                  </h4>
                  <div>
                     <p>Pro*C/C++ supports National Character Sets with database support when NLS_LOCAL=NO. When NLS_LOCAL=NO, and the new environmental variable NLS_NCHAR is set to a valid National Character Set, the database server supports NCHAR.</p>
                     <p>NLS_NCHAR specifies the character set used for National Character Set data (NCHAR, NVARCHAR2, NCLOB). If it is not specified, the character set defined or indirectly defined by NLS_LANG will be used.</p>
                     <p>NLS_NCHAR must have a valid National Character Set specification (not a language name, that is set by NLS_LANG) at both precompile-time and runtime. SQLLIB performs a runtime check when the first SQL statement is executed. If the precompile-time and runtime character sets are different, SQLLIB will return an error code.</p>
                  </div>
               </div><a id="LNPCC3249"></a><div class="props_rev_3"><a id="GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D" name="GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D"></a><h4 id="LNPCC-GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D" class="sect4"><span class="enumeration_section">4.11.3 </span>CONVBUFSZ Clause in VAR
                  </h4>
                  <div>
                     <p>You can override the default assignments by equivalencing host variables to Oracle external datatypes, using the EXEC SQL VAR statement, This is called <span class="italic">host variable equivalencing</span>.
                     </p>
                     <p>The EXEC SQL VAR statement can have an optional clause: <code class="codeph">CONVBUFSZ (&lt;size&gt;)</code>. You specify the size, <code class="codeph">&lt;size&gt;</code>, in bytes, of the buffer in the Oracle runtime library used to perform conversion of the specified host variable between character sets.
                     </p>
                     <p>The new syntax is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL VAR <span class="italic">host_variable</span> IS <span class="italic">datatype</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)] ;</pre><dl>
                        <dt class="dlterm"><a name="GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D__GUID-9B86DB8C-70C0-4E56-AB52-686F355CA52E">
                              <!-- --></a></dt>
                        <dd>
                           <p>or</p><pre class="oac_no_warn" dir="ltr">EXEC SQL VAR <span class="italic">host_variable</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)];
</pre><p>where <span class="italic">datatype</span> is:
                           </p><pre class="oac_no_warn" dir="ltr"><span class="italic">type_name</span> [ ( { <span class="italic">length</span> | <span class="italic">precision</span>, <span class="italic">scale</span> } ) ]</pre></dd>
                     </dl>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-E8C91676-9AED-4D25-99F2-C3A38E4D0129">VAR (Oracle Embedded SQL Directive)</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3250"></a><div class="props_rev_3"><a id="GUID-F17FDFF0-782B-4BF7-B473-1BE6B53260F9" name="GUID-F17FDFF0-782B-4BF7-B473-1BE6B53260F9"></a><h4 id="LNPCC-GUID-F17FDFF0-782B-4BF7-B473-1BE6B53260F9" class="sect4"><span class="enumeration_section">4.11.4 </span>Character Strings in Embedded SQL 
                  </h4>
                  <div>
                     <p>A multibyte character string in an embedded SQL statement consists of a character literal that identifies the string as multibyte, immediately followed by the string. The string is enclosed in the usual single quotes.</p>
                     <p>For example, an embedded SQL statement such as</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT empno INTO :emp_num FROM emp
    WHERE ename = N'&lt;Japanese_string&gt;';
</pre><p>contains a multibyte character string (&lt;Japanese_string&gt; could actually be Kanji), since the N character literal preceding the string identifies it as a multibyte string. Since Oracle is case-insensitive, you can use "n" or "N" in the example.</p>
                  </div>
               </div><a id="LNPCC3251"></a><div class="props_rev_3"><a id="GUID-581B1EC3-3579-4453-BDB3-F53F9C7FE6DD" name="GUID-581B1EC3-3579-4453-BDB3-F53F9C7FE6DD"></a><h4 id="LNPCC-GUID-581B1EC3-3579-4453-BDB3-F53F9C7FE6DD" class="sect4"><span class="enumeration_section">4.11.5 </span>Strings Restrictions
                  </h4>
                  <div>
                     <p>You cannot use datatype equivalencing (the TYPE or VAR commands) with multibyte character strings.</p>
                     <p>Dynamic SQL method 4 is not available for multibyte character string host variables in Pro*C/C++.</p>
                  </div>
               </div><a id="LNPCC3252"></a><div class="props_rev_3"><a id="GUID-1AEEED85-BEF4-408C-91C5-C1331A124F7D" name="GUID-1AEEED85-BEF4-408C-91C5-C1331A124F7D"></a><h4 id="LNPCC-GUID-1AEEED85-BEF4-408C-91C5-C1331A124F7D" class="sect4"><span class="enumeration_section">4.11.6 </span>Indicator Variables 
                  </h4>
                  <div>
                     <p>You can use indicator variables with host character variables that are multibyte characters (as specified using the NLS_CHAR option).</p>
                     <p></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>