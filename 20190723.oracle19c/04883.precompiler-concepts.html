<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Precompiler Concepts</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96466-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="introduction.html" title="Previous" type="text/html">
      <link rel="next" href="database-concepts.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="database-concepts.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name"> Introduction and Concepts </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Precompiler Concepts</li>
            </ol>
            <a id="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" name="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D"></a><a id="LNPCB002"></a>
            
            <h2 id="LNPCB-GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" class="sect2"><span class="enumeration_chapter">2 </span> Precompiler Concepts
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter explains how embedded SQL programs do their work. It presents definitions of important words, explanations of basic concepts, and key rules. </p>
               <p>Topics covered are:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8">Key Concepts of Embedded SQL Programming </a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3">Programming Guidelines</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C01E658A-1EAE-4497-82DB-347217694E78">The Declare Section</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-A0BFB23E-4234-409F-906A-3185E866F7BC">Nested Programs</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0">Conditional Precompilations</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153">Separate Precompilations </a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC">Compiling and Linking </a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA">Sample DEPT and EMP Tables</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D">Sample EMP Program: SAMPLE1.PCO </a></p>
                  </li>
               </ul>
            </div><a id="LNPCB126"></a><div class="props_rev_3"><a id="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" name="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8"></a><h3 id="LNPCB-GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" class="sect3"><span class="enumeration_section">2.1 </span>Key Concepts of Embedded SQL Programming 
               </h3>
               <div>
                  <p>This section lays the conceptual foundation on which later chapters build. <a id="d7799e94" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB128"></a><a id="LNPCB127"></a><div class="props_rev_3"><a id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869" name="GUID-E7AE6605-2B20-49C4-90C6-173567C42869"></a><h4 id="LNPCB-GUID-E7AE6605-2B20-49C4-90C6-173567C42869" class="sect4"><span class="enumeration_section">2.1.1 </span>Steps in Developing an Embedded SQL Application 
                  </h4>
                  <div>
                     <p>Precompiling results in a source file that can be compiled normally. Although precompiling adds a step to the traditional development process, that step is well worth taking because it lets you write very flexible applications. </p>
                     <p><a href="precompiler-concepts.html#GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">Figure 2-1</a> walks you through the embedded SQL application development process:
                     </p>
                     <div class="figure" id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">
                        <p class="titleinfigure">Figure 2-1  Application Development Process</p><img src="img/pco81050.gif" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" longdesc="img_text/pco81050.html"><br><a href="img_text/pco81050.html">Description of "Figure 2-1  Application Development Process"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPCB129"></a><div class="props_rev_3"><a id="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" name="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013"></a><h4 id="LNPCB-GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" class="sect4"><span class="enumeration_section">2.1.2 </span>Embedded SQL Statements
                  </h4>
                  <div>
                     <p>The term <span class="italic">embedded SQL</span> refers to SQL statements placed within an application program. Because the application program houses the SQL statements, it is called a <span class="italic">host program</span>, and the language in which it is written is called the <span class="italic">host language</span>. For example, with Pro*COBOL you can embed SQL statements in a COBOL host program.<a id="d7799e168" class="indexterm-anchor"></a><a id="d7799e170" class="indexterm-anchor"></a> 
                     </p>
                     <p>To manipulate and query Oracle data, you use the INSERT, UPDATE, DELETE, and SELECT statements. INSERT adds rows of data to database tables, UPDATE modifies rows, DELETE removes unwanted rows, and SELECT retrieves rows that meet your search criteria.</p>
                     <p>Only SQL statements—not SQL*Plus statements—are valid in an application program. (SQL*Plus has additional statements for setting environment parameters, editing, and report formatting.)</p>
                  </div><a id="LNPCB131"></a><a id="LNPCB130"></a><div class="props_rev_3"><a id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" name="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331"></a><h5 id="LNPCB-GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" class="sect5"><span class="enumeration_section">2.1.2.1 </span>Executable versus Declarative Statements
                     </h5>
                     <div>
                        <p>Embedded SQL includes all the interactive SQL statements plus others that allow you to transfer data between Oracle and a host program. There are two types of embedded SQL statements: <span class="italic">executable statements</span> and <span class="italic">directives</span>.
                        </p>
                        <p>Executable SQL statements generate calls to the database. They include almost all queries, Data Manipulation Language (DML), data definition language (DDL), and  Data Control Language (DCL) statements.</p>
                        <p><span class="italic">Directives</span>, on the other hand, do not result in calls to SQLLIB and do not operate on Oracle data. 
                        </p>
                        <p><a id="d7799e215" class="indexterm-anchor"></a><a id="d7799e219" class="indexterm-anchor"></a>You use directives to declare Oracle objects, communications areas, and SQL variables. They can be placed wherever COBOL declarations can be placed.<a id="d7799e224" class="indexterm-anchor"></a> 
                        </p>
                        <p><a href="precompiler-concepts.html#GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502" title="This table lists directives and their purposes">Table 2-1</a> groups some examples of embedded SQL statements (not a complete list.)
                        </p>
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502">
                           <p class="titleintable">Table 2-1 Embedded SQL Statements — Directives</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Embedded SQL Statements — Directives" summary="This table lists directives and their purposes" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d7799e243">STATEMENT</th>
                                    <th align="left" valign="bottom" width="69%" id="d7799e247">PURPOSE</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e253" headers="d7799e243 ">
                                       <p>ARRAYLEN*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e253 d7799e247 ">
                                       <p>To use host tables with PL/SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e260" headers="d7799e243 ">
                                       <p>BEGIN DECLARE SECTION*</p>
                                       <p>END DECLARE SECTION*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e260 d7799e247 ">
                                       <p>To declare host variables</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e269" headers="d7799e243 ">
                                       <p>DECLARE*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e269 d7799e247 ">
                                       <p>To name Oracle objects</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e276" headers="d7799e243 ">
                                       <p>INCLUDE*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e276 d7799e247 ">
                                       <p>To copy in files</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e283" headers="d7799e243 ">
                                       <p>VAR*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e283 d7799e247 ">
                                       <p>To equivalence variables</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e290" headers="d7799e243 ">
                                       <p>WHENEVER*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e290 d7799e247 ">
                                       <p>To handle runtime errors</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__EMBEDDEDSQLSTATEMENTSEXECUTABLESQL-040CB223">
                           <p class="titleintable">Table 2-2 Embedded SQL Statements — Executable SQL</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Embedded SQL Statements — Executable SQL" summary="This table lists executable SQL statements and their purposes" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d7799e306">STATEMENT</th>
                                    <th align="left" valign="bottom" width="20%" id="d7799e309">PURPOSE</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e314" headers="d7799e306 ">
                                       <p>ALLOCATE*</p>
                                       <p>ALTER</p>
                                       <p>CONNECT*</p>
                                       <p>CREATE</p>
                                       <p>DROP</p>
                                       <p>GRANT</p>
                                       <p>NOAUDIT</p>
                                       <p>RENAME</p>
                                       <p>REVOKE</p>
                                       <p>TRUNCATE</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e314 d7799e309 ">
                                       <p>To define and control Oracle data</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e339" headers="d7799e306 ">
                                       <p>CLOSE*</p>
                                       <p>DELETE</p>
                                       <p>EXPLAIN PLAN</p>
                                       <p>FETCH*</p>
                                       <p>INSERT</p>
                                       <p>LOCK TABLE</p>
                                       <p>OPEN*</p>
                                       <p>SELECT</p>
                                       <p>UPDATE</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e339 d7799e309 ">
                                       <p>To query and manipulate Oracle data</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e362" headers="d7799e306 ">
                                       <p>COMMIT</p>
                                       <p>ROLLBACK</p>
                                       <p>SAVEPOINT</p>
                                       <p>SET TRANSACTION</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e362 d7799e309 ">
                                       <p>To process transactions</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e375" headers="d7799e306 ">
                                       <p>DESCRIBE*</p>
                                       <p>EXECUTE*</p>
                                       <p>PREPARE*</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e375 d7799e309 ">
                                       <p>To use dynamic SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e386" headers="d7799e306 ">
                                       <p>ALTER SESSION</p>
                                       <p>SET ROLE</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e386 d7799e309 ">
                                       <p>To control sessions</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>* Has no interactive counterpart</p>
                        <div class="infoboxnotealso" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__GUID-285354C6-E895-4238-A0CC-563F33B25C43">
                           <p class="notep1">See Also:</p><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-F5251483-48EC-4B39-8E14-68F65480B16B">Embedded SQL Statements and Precompiler Directives</a> contains a presentation of the most important statements and directives.
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB135"></a><div class="props_rev_3"><a id="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" name="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE"></a><h4 id="LNPCB-GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" class="sect4"><span class="enumeration_section">2.1.3 </span>Embedded SQL Syntax 
                  </h4>
                  <div>
                     <p>In your application program, you can freely intermix SQL statements with host-language statements and use host-language variables in SQL statements. The only special requirement for building SQL statements into your host program is that you begin them with the words EXEC SQL and end them with the token END-EXEC. Pro*COBOL translates all executable EXEC SQL statements into calls to the runtime library SQLLIB.<a id="d7799e426" class="indexterm-anchor"></a><a id="d7799e430" class="indexterm-anchor"></a><a id="d7799e434" class="indexterm-anchor"></a><a id="d7799e436" class="indexterm-anchor"></a> 
                     </p>
                     <p>Most embedded SQL statements differ from their interactive counterparts only through the addition of a new clause or the use of program variables. Compare the following interactive and embedded ROLLBACK statements:<a id="d7799e441" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">ROLLBACK WORK;           -- interactive

* embedded
     EXEC SQL
         ROLLBACK WORK
     END-EXEC.
</pre><p>A period or any other terminator can follow a SQL statement. Either of the following is allowed:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL ... END-EXEC,
     EXEC SQL ... END-EXEC.</pre></div>
               </div><a id="LNPCB136"></a><div class="props_rev_3"><a id="GUID-D0456446-014D-4569-AD48-BCCB0E54169A" name="GUID-D0456446-014D-4569-AD48-BCCB0E54169A"></a><h4 id="LNPCB-GUID-D0456446-014D-4569-AD48-BCCB0E54169A" class="sect4"><span class="enumeration_section">2.1.4 </span>Static Versus Dynamic SQL Statements 
                  </h4>
                  <div>
                     <p>Most application programs are designed to process <span class="italic">static</span> SQL<span class="italic"> </span>statements and fixed transactions. In this case, you know the makeup of each SQL statement and transaction before run time. That is, you know which SQL commands will be issued, which database tables might be changed, which columns will be updated, and so on.<a id="d7799e482" class="indexterm-anchor"></a><a id="d7799e486" class="indexterm-anchor"></a> 
                     </p>
                     <p>However, some applications are required to accept and process any valid SQL statement at run time. In this case you might not know until run time all the SQL commands, database tables, and columns involved. </p>
                     <p><span class="italic">Dynamic </span>SQL is an advanced programming technique that lets your program accept or build SQL statements at run time and take explicit control over datatype conversion.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC">Embedded SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-C325218F-3DFF-4551-A5EB-483ADB24E324">Oracle Dynamic SQL</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-D6E9ACBE-EFF4-42F6-A855-B510004F4164">ANSI Dynamic SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle Dynamic SQL: Method 4</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB137"></a><div class="props_rev_3"><a id="GUID-743ED7AF-E1FB-4570-9309-448E462C511A" name="GUID-743ED7AF-E1FB-4570-9309-448E462C511A"></a><h4 id="LNPCB-GUID-743ED7AF-E1FB-4570-9309-448E462C511A" class="sect4"><span class="enumeration_section">2.1.5 </span>Embedded PL/SQL Blocks 
                  </h4>
                  <div>
                     <p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement, so you can place a PL/SQL block anywhere in an application program that you can place a SQL statement. To embed PL/SQL in your host program, you simply declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC.<a id="d7799e538" class="indexterm-anchor"></a></p>
                     <p>From embedded PL/SQL blocks, you can manipulate Oracle data flexibly and safely because PL/SQL supports all SQL data manipulation and transaction processing commands.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-PLSQL.html#GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F">Embedded PL/SQL</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB138"></a><div class="props_rev_3"><a id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" name="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A"></a><h4 id="LNPCB-GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" class="sect4"><span class="enumeration_section">2.1.6 </span>Host Variables and Indicator Variables 
                  </h4>
                  <div>
                     <p>A <span class="italic">host variable</span> is a scalar or table variable or group item declared in the COBOL language and shared with Oracle, meaning that both your program and Oracle can reference its value. Host variables are the key to communication between Oracle and your program. <a id="d7799e579" class="indexterm-anchor"></a></p>
                     <p>You use <span class="italic">input</span> host variables to pass data to the database. You use <span class="italic">output</span> host variables to pass data and status information from the database to your program.<a id="d7799e591" class="indexterm-anchor"></a></p>
                     <p>Host variables can be used anywhere an expression can be used. In SQL statements, host variables must be prefixed with a colon ':' to set them apart from database schema names.<a id="d7799e597" class="indexterm-anchor"></a><a id="d7799e601" class="indexterm-anchor"></a> 
                     </p>
                     <p>You can associate any host variable with an optional indicator variable. An <span class="italic">indicator variable</span> is an integer variable that indicates the value or condition of its host variable. A <span class="italic">NULL</span> is a missing, an unknown, or an inapplicable value. You use indicator variables to assign NULLs to input host variables and to detect NULLs in output variables or truncated values in output character host variables. <a id="d7799e614" class="indexterm-anchor"></a></p>
                     <p>A host variable must <span class="italic">not</span> be: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>prefixed with a colon in COBOL statements </p>
                        </li>
                        <li>
                           <p>used in data definition (DDL) statements such as ALTER and CREATE</p>
                        </li>
                     </ul>
                     <p>In SQL statements, an indicator variable must be prefixed with a colon and appended to its associated host variable (to improve readability, you can precede the indicator variable with the optional keyword INDICATOR).</p>
                     <p>Every program variable used in a SQL statement must be declared according to the rules of the COBOL language. Normal rules of scope apply. COBOL variable names can be any length, but only the first 30 characters are significant for Pro*COBOL<a id="d7799e634" class="indexterm-anchor"></a><a id="d7799e638" class="indexterm-anchor"></a><a id="d7799e642" class="indexterm-anchor"></a><a id="d7799e646" class="indexterm-anchor"></a><a id="d7799e650" class="indexterm-anchor"></a><a id="d7799e654" class="indexterm-anchor"></a>. Any valid COBOL identifier can be used as a host variable identifier, including those beginning with digits.
                     </p>
                     <p>The external datatype of a host variable and the internal datatype of its source or target database column need not be the same, but they must be compatible. </p>
                     <div class="infoboxnotealso" id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A__GUID-6EAF10E2-2520-4604-B436-CA97C82FDCD5">
                        <p class="notep1">See Also:</p><a href="datatypes-and-host-variables.html#GUID-E35BBCF1-FA1C-4DA4-A522-C17CF57E910F">Datatype Conversion</a> for list of compatible datatypes between which Oracle converts automatically when necessary.
                     </div>
                  </div>
               </div><a id="LNPCB139"></a><div class="props_rev_3"><a id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" name="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE"></a><h4 id="LNPCB-GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" class="sect4"><span class="enumeration_section">2.1.7 </span>Oracle Datatypes 
                  </h4>
                  <div>
                     <p>Typically, a host program inputs data to the database, and the database outputs data to the program. Oracle inserts input data into database tables and selects output data into program host variables. To store a data item, Oracle must know its <span class="italic">datatype</span>, which specifies a storage format and valid range of values.
                     </p>
                     <p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudo-columns, which return specific data items but are not actual columns in a table.<a id="d7799e701" class="indexterm-anchor"></a><a id="d7799e705" class="indexterm-anchor"></a></p>
                     <p>External datatypes specify how data is stored in host variables. When your host program inputs data to Oracle, it does any conversion between the external datatype of the input host variable and the internal datatype of the database column. When Oracle outputs data to your host program, if necessary, Oracle converts between the internal datatype of the database column and the external datatype of the output host variable.<a id="d7799e711" class="indexterm-anchor"></a></p>
                     <div class="infoboxnote" id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE__GUID-BE943CDB-1BE9-4883-9364-B297DC64000B">
                        <p class="notep1">Note:</p>
                        <p>You can override default datatype conversions by using dynamic SQL Method 4 or datatype equivalencing. For information about datatype equivalencing, see <span class="q">"<a href="datatypes-and-host-variables.html#GUID-646C583F-AFD5-4F6D-8627-8BB344F8B721">Explicit Control Over DATE String Format</a>"</span>.
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB140"></a><div class="props_rev_3"><a id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" name="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1"></a><h4 id="LNPCB-GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" class="sect4"><span class="enumeration_section">2.1.8 </span>Tables
                  </h4>
                  <div>
                     <p>Pro*COBOL lets you define table host variables (called <span class="italic">host tables</span>) and operate on them with a single SQL statement. Using the SELECT, FETCH, DELETE, INSERT, and UPDATE statements, you can query and manipulate large volumes of data with ease.<a id="d7799e750" class="indexterm-anchor"></a></p>
                     <div class="infoboxnotealso" id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1__GUID-37FC9185-3F74-4734-8ECD-ABD81F1842B8">
                        <p class="notep1">See Also:</p><a href="host-tables.html#GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6">Host Tables</a> for a complete discussion of host tables.
                     </div>
                  </div>
               </div><a id="LNPCB141"></a><div class="props_rev_3"><a id="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" name="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303"></a><h4 id="LNPCB-GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" class="sect4"><span class="enumeration_section">2.1.9 </span>Errors and Warnings 
                  </h4>
                  <div>
                     <div class="section">
                        <p>When you execute an embedded SQL statement, it either succeeds or fails, and might result in an error or warning. You need a way to handle these results. Pro*COBOL provides the following error handling mechanisms:<a id="d7799e785" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SQLCODE status variable</p>
                           </li>
                           <li>
                              <p>SQLSTATE status variable</p>
                           </li>
                           <li>
                              <p>SQL Communications Area (SQLCA) </p>
                           </li>
                           <li>
                              <p>WHENEVER statement </p>
                           </li>
                           <li>
                              <p>Oracle Communications Area (ORACA)</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB142"></a><div class="props_rev_3"><a id="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" name="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5"></a><h5 id="LNPCB-GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" class="sect5"><span class="enumeration_section">2.1.9.1 </span>SQLCODE/SQLSTATE Status Variables
                     </h5>
                     <div>
                        <p>After executing a SQL statement, the Oracle Server returns a status code to a variable named SQLCODE or SQLSTATE. The status code indicates whether the SQL statement executed successfully or caused an error or warning condition.</p>
                     </div>
                  </div><a id="LNPCB144"></a><a id="LNPCB143"></a><div class="props_rev_3"><a id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" name="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B"></a><h5 id="LNPCB-GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" class="sect5"><span class="enumeration_section">2.1.9.2 </span>SQLCA Status Variable
                     </h5>
                     <div>
                        <p>The SQLCA is a data structure that defines program variables used by Oracle to pass runtime status information to the program. With the SQLCA, you can take different actions based on feedback from Oracle about work just attempted. For example, you can check to see if a DELETE statement succeeded and, if so, how many rows were deleted.<a id="d7799e854" class="indexterm-anchor"></a> 
                        </p>
                        <p>The SQLCA provides for diagnostic checking and event handling. At runtime, the SQLCA holds status information passed to your program by Oracle. After executing a SQL statement, Oracle sets SQLCA variables to indicate the outcome, as illustrated in <a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">Figure 2-2</a>. 
                        </p>
                        <div class="figure" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">
                           <p class="titleinfigure">Figure 2-2  Updating the SQLCA</p><img src="img/pco81051.gif" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" longdesc="img_text/pco81051.html"><br><a href="img_text/pco81051.html">Description of "Figure 2-2  Updating the SQLCA"</a></div>
                        <!-- class="figure" -->
                        <p>You can check to see if an INSERT, UPDATE, or DELETE statement succeeded and if it did, how many rows were affected. Or, if the statement failed, you can get more information about what happened.<a id="d7799e870" class="indexterm-anchor"></a><a id="d7799e872" class="indexterm-anchor"></a></p>
                        <p>When MODE={ANSI13 | ORACLE}, you must declare the SQLCA by hard-coding it or by copying it into your program with the INCLUDE statement.</p>
                        <div class="infoboxnotealso" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__GUID-A3BC2422-6F60-44C4-9604-CB4F1A1D1F61">
                           <p class="notep1">See Also:</p><span class="q">"<a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">Using the SQL Communications Area</a>"</span> for more information about how to declare and use the SQLCA.
                        </div>
                     </div>
                  </div><a id="LNPCB145"></a><div class="props_rev_3"><a id="GUID-603301A3-66B3-43DE-A23E-1F5F82024371" name="GUID-603301A3-66B3-43DE-A23E-1F5F82024371"></a><h5 id="LNPCB-GUID-603301A3-66B3-43DE-A23E-1F5F82024371" class="sect5"><span class="enumeration_section">2.1.9.3 </span>WHENEVER Statement
                     </h5>
                     <div>
                        <p>With the WHENEVER statement, you can specify actions to be taken automatically when Oracle detects an error or warning condition. These actions include continuing with the next statement, calling a subprogram, branching to a labeled statement, performing a paragraph, or stopping.<a id="d7799e909" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div><a id="LNPCB146"></a><div class="props_rev_3"><a id="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" name="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982"></a><h5 id="LNPCB-GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" class="sect5"><span class="enumeration_section">2.1.9.4 </span>ORACA
                     </h5>
                     <div>
                        <div class="section">
                           <p>When more information is needed about runtime errors than the SQLCA provides, you can use the ORACA. The ORACA is a data structure that handles Oracle communication. It contains cursor statistics, information about the current SQL statement, option settings, and system statistics. </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB147"></a><div class="props_rev_3"><a id="GUID-7A159038-7A6F-4C11-8F21-31B702004524" name="GUID-7A159038-7A6F-4C11-8F21-31B702004524"></a><h5 id="LNPCB-GUID-7A159038-7A6F-4C11-8F21-31B702004524" class="sect5"><span class="enumeration_section">2.1.9.5 </span>Precompiler Options and Error Handling
                     </h5>
                     <div>
                        <div class="section">
                           <p>Oracle returns the success or failure of SQL statements in status variables, SQLSTATE and SQLCODE. With precompiler option MODE=ORACLE, you use SQLCODE, declared by including SQLCA. With MODE=ANSI, either SQLSTATE or SQLCODE must be declared, but SQLCA is not necessary.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="error-handling-and-diagnostics.html#GUID-AE77299F-16B6-4896-817B-ACC5F7B68A2E">Error Handling and Diagnostics</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB148"></a><div class="props_rev_3"><a id="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" name="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7"></a><h4 id="LNPCB-GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" class="sect4"><span class="enumeration_section">2.1.10 </span>SQL99 Syntax Support
                  </h4>
                  <div>
                     <p>The SQL standard enables the portability of SQL applications across all conforming software products. Oracle features are compliant with the ANSI/ISO SQL99 standard, including ANSI compliant joins. Pro*Cobol supports all SQL99 features that are supported by Oracle database, which means that the SQL99 syntax for the SELECT, INSERT, DELETE, and UPDATE statements and the body of the cursor in a DECLARE CURSOR statement are supported.</p>
                  </div>
               </div>
            </div><a id="LNPCB149"></a><div class="props_rev_3"><a id="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" name="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3"></a><h3 id="LNPCB-GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" class="sect3"><span class="enumeration_section">2.2 </span>Programming Guidelines
               </h3>
               <div>
                  <div class="section">
                     <p>This section deals with embedded SQL syntax, coding conventions, and Pro*COBOL-specific features and restrictions. Topics are arranged alphabetically for quick reference.<a id="d7799e1018" class="indexterm-anchor"></a><a id="d7799e1020" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB150"></a><div class="props_rev_3"><a id="GUID-97346464-5A87-4195-8EDF-AA1734B48C74" name="GUID-97346464-5A87-4195-8EDF-AA1734B48C74"></a><h4 id="LNPCB-GUID-97346464-5A87-4195-8EDF-AA1734B48C74" class="sect4"><span class="enumeration_section">2.2.1 </span>Abbreviations
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use the standard COBOL abbreviations, such as PIC for PICTURE IS and COMP for USAGE IS COMPUTATIONAL.<a id="d7799e1048" class="indexterm-anchor"></a><a id="d7799e1050" class="indexterm-anchor"></a><a id="d7799e1054" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB151"></a><div class="props_rev_3"><a id="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" name="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8"></a><h4 id="LNPCB-GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" class="sect4"><span class="enumeration_section">2.2.2 </span>Case-Insensitivity
                  </h4>
                  <div>
                     <div class="section">
                        <p>Pro*COBOL precompiler options and values as well as all EXEC SQL statements, inline commands, and COBOL statements are case-insensitive. The precompiler accepts both upper- and lower-case tokens.<a id="d7799e1084" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB152"></a><div class="props_rev_3"><a id="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" name="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9"></a><h4 id="LNPCB-GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" class="sect4"><span class="enumeration_section">2.2.3 </span>COBOL Versions Supported
                  </h4>
                  <div>
                     <div class="section">
                        <p>­­<a id="d7799e1116" class="indexterm-anchor"></a>Pro*COBOL supports the standard implementation of COBOL for your operating system (usually COBOL-85 or COBOL-74). Some platforms may support both COBOL implementations. For more information, see your Oracle system-specific documentation.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB153"></a><div class="props_rev_3"><a id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" name="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1"></a><h4 id="LNPCB-GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" class="sect4"><span class="enumeration_section">2.2.4 </span>Coding Areas
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d7799e1143" class="indexterm-anchor"></a><a id="d7799e1147" class="indexterm-anchor"></a><a id="d7799e1151" class="indexterm-anchor"></a><a id="d7799e1155" class="indexterm-anchor"></a>The precompiler option FORMAT, specifies the format of your source code. If you specify FORMAT=ANSI (the default), you are conforming as much as possible to the ANSI standard. In this format, columns 1 through 6 can contain an optional sequence number, and column 7 (indicator area) can indicate comments or continuation lines. 
                        </p>
                        <p>Division headers, section headers, paragraph names, FD and 01 statements begin in columns 8 through 11 (area A). Other statements, including EXEC SQL and EXEC ORACLE statements, must be placed in area B (columns 12 through 72). These guidelines for source code format can be overridden by your compiler's rules.</p>
                        <p>If you specify FORMAT=TERMINAL, COBOL statements can begin in column 1 (the left-most column), or column 1 can be the indicator area. This format is also subject to the rules of your compiler.</p>
                        <p>You can specify FORMAT=VARIABLE to allow Flexible B Area Length. </p>
                        <p>Consult your COBOL compiler documentation for your own platform to determine the actual acceptable formats for COBOL statements.</p>
                        <div class="infoboxnote" id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1__GUID-01FF5274-B5BE-47D2-B222-32614BCBE3A9">
                           <p class="notep1">Note:</p>
                           <p>In this manual, COBOL code examples use the FORMAT=TERMINAL setting. The online sample programs in the demo directory use FORMAT=ANSI.<a id="d7799e1171" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB154"></a><div class="props_rev_3"><a id="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" name="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87"></a><h4 id="LNPCB-GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" class="sect4"><span class="enumeration_section">2.2.5 </span>Commas
                  </h4>
                  <div>
                     <div class="section">
                        <p>In SQL, you must use commas to separate list items, as the following example shows: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SELECT ENAME, JOB, SAL
         INTO :EMP-NAME, :JOB-TITLE, :SALARY
         FROM EMP
         WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre><p>In COBOL, you can use commas or blanks to separate list items. For example, the following two statements are equivalent:</p><pre class="oac_no_warn" dir="ltr">     ADD AMT1, AMT2, AMT3 TO TOTAL-AMT. 
     ADD AMT1 AMT2 AMT3 TO TOTAL-AMT.  </pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB155"></a><div class="props_rev_3"><a id="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" name="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60"></a><h4 id="LNPCB-GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" class="sect4"><span class="enumeration_section">2.2.6 </span>Comments
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can place COBOL comment lines within SQL statements. COBOL comment lines start with an asterisk (*) in the indicator area. </p>
                        <p>You can also place ANSI SQL-style comments starting with "- - " within SQL statements at the end of a line (but not after the last line of the SQL statement).</p>
                        <p>COBOL comments continue for the rest of the line after these two characters: "*&gt;".</p>
                        <p>You can place C-style comments (/* ... */) in SQL statements. </p>
                        <p>The following example shows all four styles of comments:<a id="d7799e1247" class="indexterm-anchor"></a><a id="d7799e1251" class="indexterm-anchor"></a><a id="d7799e1255" class="indexterm-anchor"></a><a id="d7799e1259" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     MOVE 12 TO DEPT-NUMBER. *&gt; This is the software development group.
     EXEC SQL SELECT ENAME, SAL 
*    assign column values to output host variables 
         INTO :EMP-NAME, :SALARY    -- output host variables 
     /*  column values assigned to output host variables */ 
         FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER 
     END-EXEC.    -- illegal Comment
</pre><p>You cannot nest comments or place them on the last line of a SQL statement after the terminator END-EXEC. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB156"></a><div class="props_rev_3"><a id="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" name="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA"></a><h4 id="LNPCB-GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" class="sect4"><span class="enumeration_section">2.2.7 </span>Continuation Lines
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can continue SQL statements from one line to the next, according to the rules of COBOL, as this example shows:<a id="d7799e1296" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SELECT ENAME, SAL INTO :EMP-NAME, :SALARY FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER 
     END-EXEC. 
</pre><p>No continuation indicator is needed. </p>
                        <p>To continue a string literal from one line to the next, code the literal through column 72. On the next line, code a hyphen (-) in column 7, a quote in column 12 or beyond, and then the rest of the literal. An example follows:<a id="d7799e1306" class="indexterm-anchor"></a><a id="d7799e1310" class="indexterm-anchor"></a><a id="d7799e1314" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> WORKING STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         ... 
 01  UPDATE-STATEMENT  PIC X(80) VALUE "UPDATE EMP SET BON 
-               "US = 500 WHERE DEPTNO = 20". 
     EXEC SQL END DECLARE SECTION END-EXEC.  </pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB157"></a><div class="props_rev_3"><a id="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" name="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E"></a><h4 id="LNPCB-GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" class="sect4"><span class="enumeration_section">2.2.8 </span>Copy Statements
                  </h4>
                  <div>
                     <div class="section">
                        <p>Copy statements are not parsed by Pro*COBOL. Therefore, files included with the COPY command should not contain definitions of Host variables or contain embedded SQL statements. Instead, use the INCLUDE precompiler statement which is documented in <span class="q">"<a href="precompiler-concepts.html#GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473">Using the INCLUDE Statement</a>"</span>. Be careful when using INCLUDE and also using DECLARE_SECTION=YES. Group items should be either placed all inside or all outside of a Declare Section.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB158"></a><div class="props_rev_3"><a id="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" name="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2"></a><h4 id="LNPCB-GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" class="sect4"><span class="enumeration_section">2.2.9 </span>Decimal-Point is Comma
                  </h4>
                  <div>
                     <div class="section">
                        <p>Pro*COBOL supports the DECIMAL-POINT IS COMMA clause in the ENVIRONMENT DIVISION. If the DECIMAL-POINT IS COMMA clause appears in the source file, then the comma will be allowed as the symbol beginning the decimal part of any numeric literals in the VALUE clauses.</p>
                        <p>        For example, the following is allowed:</p><pre class="oac_no_warn" dir="ltr">            IDENTIFICATION DIVISION.
            PROGRAM-ID.  FOO
            ENVIRONMENT DIVISION.
            CONFIGURATION   SECTION.
            SPECIAL-NAMES.
                DECIMAL-POINT IS COMMA.                *&gt;  &lt;-- **
            DATA DIVISION.
            WORKING-STORAGE SECTION.
        ...
            01  WDATA1          PIC      S9V999 VALUE  +,567. *&gt;  &lt;--- **
            01  WDATA2          PIC      S9V999 VALUE  -,234. *&gt;  &lt;--- **
        ...</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB159"></a><div class="props_rev_3"><a id="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" name="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC"></a><h4 id="LNPCB-GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" class="sect4"><span class="enumeration_section">2.2.10 </span>Delimiters
                  </h4>
                  <div>
                     <div class="section">
                        <p>The LITDELIM option specifies the delimiters for COBOL string constants and literals. If you specify LITDELIM=APOST, Pro*COBOL uses apostrophes when generating COBOL code. If you specify LITDELIM=QUOTE (default), quotation marks are used, as in <a id="d7799e1405" class="indexterm-anchor"></a><a id="d7799e1409" class="indexterm-anchor"></a><a id="d7799e1411" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     CALL "SQLROL" USING SQL-TMP0. 
</pre><p>In SQL statements, you must use quotation marks to delimit identifiers containing special or lowercase characters, as in </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CREATE TABLE "Emp2" END-EXEC.
 </pre><p>However, you must use apostrophes to delimit string constants, as in </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SELECT ENAME FROM EMP WHERE JOB = 'CLERK' END-EXEC.
 </pre><p>Regardless of which delimiter is used in the Pro*COBOL source file, Pro*COBOL generates the delimiter specified by the LITDELIM value.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB160"></a><div class="props_rev_3"><a id="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" name="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368"></a><h4 id="LNPCB-GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" class="sect4"><span class="enumeration_section">2.2.11 </span>Division Headers that are Optional
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following division headers are optional:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>IDENTIFICATION DIVISION</p>
                           </li>
                           <li>
                              <p>ENVIRONMENT DIVISION</p>
                           </li>
                           <li>
                              <p>DATA DIVISION</p>
                           </li>
                        </ul>
                        <p>Note that the PROCEDURE DIVISION header is not optional. The following source can be precompiled:</p><pre class="oac_no_warn" dir="ltr">*IDENTIFICATION DIVISION header is optional
 PROGRAM-ID.     HELLO.
*ENVIRONMENT DIVISION header is optional
 CONFIGURATION SECTION.
*DATA DIVISION header is optional
 WORKING-STORAGE SECTION.
 PROCEDURE       DIVISION.
     DISPLAY "Hello World!".
     STOP RUN.</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB161"></a><div class="props_rev_3"><a id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" name="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765"></a><h4 id="LNPCB-GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" class="sect4"><span class="enumeration_section">2.2.12 </span>Embedded SQL Syntax
                  </h4>
                  <div>
                     <div class="section">
                        <p>To use a SQL statement in your Pro*COBOL program, precede the SQL statement with the EXEC SQL clause, and end the statement with the END-EXEC keyword.<a id="d7799e1496" class="indexterm-anchor"></a><a id="d7799e1500" class="indexterm-anchor"></a><a id="d7799e1504" class="indexterm-anchor"></a><a id="d7799e1508" class="indexterm-anchor"></a> 
                        </p>
                        <div class="infoboxnotealso" id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765__GUID-C6D923C0-7F18-4E98-8676-D31D4F149D45">
                           <p class="notep1">See Also:</p><a href="../sqlrf/index.html" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span>.</a> for more information about Embedded SQL syntax.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB162"></a><div class="props_rev_3"><a id="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" name="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D"></a><h4 id="LNPCB-GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" class="sect4"><span class="enumeration_section">2.2.13 </span>Figurative Constants
                  </h4>
                  <div>
                     <div class="section">
                        <p>Figurative constants, such as HIGH-VALUE, ZERO, and SPACE, cannot be used in SQL statements. For example, the following is <span class="italic">invalid</span>:<a id="d7799e1546" class="indexterm-anchor"></a><a id="d7799e1550" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL DELETE FROM EMP WHERE COMM = ZERO END-EXEC.
 </pre><p>Instead, use the following:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL DELETE FROM EMP WHERE COMM = 0 END-EXEC. </pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB163"></a><div class="props_rev_3"><a id="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" name="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4"></a><h4 id="LNPCB-GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" class="sect4"><span class="enumeration_section">2.2.14 </span>File Length
                  </h4>
                  <div>
                     <div class="section">
                        <p>Pro*COBOL cannot process arbitrarily long source files. Some of the variables used internally limit the size of the generated file. There is no absolute limit to the number of lines allowed, but the following aspects of the source file are contributing factors to the file-size constraint:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Complexity of the embedded SQL statements (for example, the number of bind and define variables)</p>
                           </li>
                           <li>
                              <p>Whether a database name is used (for example, connecting to a database with an AT clause)</p>
                           </li>
                           <li>
                              <p>Number of embedded SQL statements</p>
                           </li>
                        </ul>
                        <p>To prevent problems related to this limitation, use multiple program units to sufficiently reduce the size of the source files.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB164"></a><div class="props_rev_3"><a id="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" name="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432"></a><h4 id="LNPCB-GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" class="sect4"><span class="enumeration_section">2.2.15 </span>FILLER is Allowed
                  </h4>
                  <div>
                     <div class="section">
                        <p>The word FILLER is allowed in host variable declarations. The word FILLER is used to specify an elementary item of a group that cannot be referred to explicitly. The following declaration is valid:</p><pre class="oac_no_warn" dir="ltr"> 01  STOCK. 
     05  DIVIDEND     PIC X(5).
     05  FILLER       PIC X.
     05  PRICE        PIC X(6).</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB165"></a><div class="props_rev_3"><a id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" name="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865"></a><h4 id="LNPCB-GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" class="sect4"><span class="enumeration_section">2.2.16 </span>Host Variable Names
                  </h4>
                  <div>
                     <div class="section">
                        <p>Any valid standard COBOL identifier can be used as a host variable. Variable names can be any length, but only the first 30 characters are significant. The maximum number of significant characters recognized by COBOL compilers is 30. <a id="d7799e1654" class="indexterm-anchor"></a><a id="d7799e1658" class="indexterm-anchor"></a><a id="d7799e1662" class="indexterm-anchor"></a></p>
                        <p>For portability, you may wish to restrict the length of host variable names to 18 or fewer characters (the length mandated by the SQL standard).</p>
                        <div class="infoboxnotealso" id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865__GUID-D5B758B4-E645-4A95-8259-92CE85A1BF2E">
                           <p class="notep1">See Also:</p><a href="reserved-words-keywords-and-namespaces.html#GUID-A408EC88-567F-4D54-8359-ABCFF421CDD7"> Reserved Words_ Keywords_ and Namespaces </a> for a list of words that have restrictions on their use in applications.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB166"></a><div class="props_rev_3"><a id="GUID-167590B9-9985-4779-AFCF-B29D24D858BC" name="GUID-167590B9-9985-4779-AFCF-B29D24D858BC"></a><h4 id="LNPCB-GUID-167590B9-9985-4779-AFCF-B29D24D858BC" class="sect4"><span class="enumeration_section">2.2.17 </span>Hyphenated Names
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use hyphenated host-variable names in static SQL statements but <span class="italic">not</span> in dynamic SQL. For example, the following usage is <span class="italic">invalid</span>:<a id="d7799e1706" class="indexterm-anchor"></a><a id="d7799e1710" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     MOVE "DELETE FROM EMP WHERE EMPNO = :EMP-NUMBER" TO SQLSTMT. 
     EXEC SQL PREPARE STMT1 FROM SQLSTMT END-EXEC. </pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB167"></a><div class="props_rev_3"><a id="GUID-0B6A0DF7-A963-480F-B112-913658099FC7" name="GUID-0B6A0DF7-A963-480F-B112-913658099FC7"></a><h4 id="LNPCB-GUID-0B6A0DF7-A963-480F-B112-913658099FC7" class="sect4"><span class="enumeration_section">2.2.18 </span>Level Numbers
                  </h4>
                  <div>
                     <div class="section">
                        <p>When declaring host variables, you can use level numbers 01 through 49, and 77. Pro*COBOL does not allow variables containing the VARYING clause or pseudo-type variables (these datatypes are prefixed with "SQL- ") to be declared level 49 or 77.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB168"></a><div class="props_rev_3"><a id="GUID-5F903960-5E5F-4739-8564-303E130B7518" name="GUID-5F903960-5E5F-4739-8564-303E130B7518"></a><h4 id="LNPCB-GUID-5F903960-5E5F-4739-8564-303E130B7518" class="sect4"><span class="enumeration_section">2.2.19 </span>MAXLITERAL Default
                  </h4>
                  <div>
                     <div class="section">
                        <p>With the MAXLITERAL option, you can specify the maximum length of string literals generated by Pro*COBOL, so that compiler limits are not exceeded. For Pro*COBOL, the default value is 256, but you might have to specify a lower value. On IBM-proprietary S370 operating systems it is 120. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB169"></a><div class="props_rev_3"><a id="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" name="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784"></a><h4 id="LNPCB-GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" class="sect4"><span class="enumeration_section">2.2.20 </span>Multibyte Datatypes
                  </h4>
                  <div>
                     <div class="section">
                        <p>ANSI standard National Character Set datatypes are supported for handling multibyte character data. The PIC N or PIC G clause, if supported by your compiler, defines variables that store fixed-length NCHAR strings. You can store variable-length, multibyte National Character Set strings using COBOL group items consisting of a length field and a string field.<a id="d7799e1792" class="indexterm-anchor"></a></p>
                        <p>The environmental variable NLS_NCHAR is available to specify a client-side Globalization Support National Character Set. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-B7D9C340-75B1-4B84-B44E-F4CB1748262E">VARCHAR Variables</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB170"></a><div class="props_rev_3"><a id="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" name="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED"></a><h4 id="LNPCB-GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" class="sect4"><span class="enumeration_section">2.2.21 </span>NULLs in SQL
                  </h4>
                  <div>
                     <div class="section">
                        <p>In SQL, a NULL represents a missing, unknown, or inapplicable column value; it equates neither to zero nor to a blank. Use the NVL function to convert NULLs to non-NULL values, use the IS [NOT] NULL comparison operator to search for NULLs, and use indicator variables to insert and test for NULLs.<a id="d7799e1835" class="indexterm-anchor"></a><a id="d7799e1839" class="indexterm-anchor"></a><a id="d7799e1843" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB171"></a><div class="props_rev_3"><a id="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" name="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965"></a><h4 id="LNPCB-GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" class="sect4"><span class="enumeration_section">2.2.22 </span>Paragraph and Section Names
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can associate standard COBOL paragraph and section names with SQL statements, as shown in the following example: <a id="d7799e1872" class="indexterm-anchor"></a><a id="d7799e1876" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> LOAD-DATA. 
     EXEC SQL 
         INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
             VALUES (:EMP-NUMBER, :EMP-NAME, :DEPT-NUMBER) 
     END-EXEC. 
</pre><p>Also, you can reference paragraph and section names in a WHENEVER ... DO or WHENEVER ... GOTO statement, as the next example shows: </p><pre class="oac_no_warn" dir="ltr"> PROCEDURE DIVISION. 
 MAIN. 
     EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC. 
     ... 
 SQL-ERROR SECTION. 
     ... </pre><p>You must begin all paragraph names in area A.<a id="d7799e1888" class="indexterm-anchor"></a><a id="d7799e1892" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB172"></a><div class="props_rev_3"><a id="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" name="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D"></a><h4 id="LNPCB-GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" class="sect4"><span class="enumeration_section">2.2.23 </span>REDEFINES Clause
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use the COBOL REDEFINES clause to redefine group or elementary items. For example, the following declarations are valid:<a id="d7799e1922" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  REC-ID   PIC X(4). 
 01  REC-NUM  REDEFINES  REC-ID  PIC S9(4) COMP. 
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre><p>And:<a id="d7799e1930" class="indexterm-anchor"></a><a id="d7799e1934" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
  01  STOCK. 
       05  DIVIDEND     PIC X(5). 
       05  PRICE        PIC X(6). 
   01  BOND  REDEFINES  STOCK. 
       05  COUPON-RATE  PIC X(4). 
       05  PRICE        PIC X(7). 
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre><p>Pro*COBOL issues no warning or error if a single INTO clause uses items from both a group item host variable and from its re-definition.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB174"></a><a id="LNPCB173"></a><div class="props_rev_3"><a id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37" name="GUID-63C7C12C-A978-448C-89F7-809A89B96F37"></a><h4 id="LNPCB-GUID-63C7C12C-A978-448C-89F7-809A89B96F37" class="sect4"><span class="enumeration_section">2.2.24 </span>Relational Operators
                  </h4>
                  <div>
                     <div class="section">
                        <p>COBOL relational operators differ from their SQL equivalents, as shown in <a href="precompiler-concepts.html#GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966">Relational Operators</a>. Furthermore, COBOL enables the use of words instead of symbols, whereas SQL does not.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__GUID-B2BDCFB5-8771-4650-91BA-F541ED830079">
                        <p class="titleintable">Table 2-3 <span class="italic" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966"><span class="bold">Relational Operators</span></span></p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Relational Operators" summary="q" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d7799e1984">SQL Operators</th>
                                 <th align="left" valign="bottom" width="69%" id="d7799e1987">COBOL Operators</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1992" headers="d7799e1984 ">
                                    <p>=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1992 d7799e1987 ">
                                    <p>=, EQUAL TO</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1999" headers="d7799e1984 ">
                                    <p>&lt; &gt;, !=, ^=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1999 d7799e1987 ">
                                    <p>NOT=, NOT EQUAL TO</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2006" headers="d7799e1984 ">
                                    <p>&gt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2006 d7799e1987 ">
                                    <p>&gt;, GREATER THAN</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2013" headers="d7799e1984 ">
                                    <p>&lt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2013 d7799e1987 ">
                                    <p>&lt;, LESS THAN</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2020" headers="d7799e1984 ">
                                    <p>&gt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2020 d7799e1987 ">
                                    <p>&gt;=, GREATER THAN OR EQUAL TO</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2027" headers="d7799e1984 ">
                                    <p>&lt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2027 d7799e1987 ">
                                    <p>&lt;=, LESS THAN OR EQUAL TO</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCB175"></a><div class="props_rev_3"><a id="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" name="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235"></a><h4 id="LNPCB-GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" class="sect4"><span class="enumeration_section">2.2.25 </span>Sentence Terminator
                  </h4>
                  <div>
                     <div class="section">
                        <p>A COBOL <span class="italic">sentence</span> includes one or more COBOL or SQL statements, or both of them, and ends with a period. In conditional sentences, only the last statement must end with a period, as the following example shows.<a id="d7799e2071" class="indexterm-anchor"></a><a id="d7799e2075" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     IF EMP-NUMBER = ZERO 
         MOVE FALSE TO VALID-DATA 
         PERFORM GET-EMP-NUM UNTIL VALID-DATA = TRUE 
     ELSE 
         EXEC SQL DELETE FROM EMP 
             WHERE EMPNO = :EMP-NUMBER 
         END-EXEC
         ADD 1 TO DELETE-TOTAL.
     END-IF. 
</pre><p>SQL statements may be ended by a comma, a period, or another COBOL statement.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB176"></a><div class="props_rev_3"><a id="GUID-C01E658A-1EAE-4497-82DB-347217694E78" name="GUID-C01E658A-1EAE-4497-82DB-347217694E78"></a><h3 id="LNPCB-GUID-C01E658A-1EAE-4497-82DB-347217694E78" class="sect3"><span class="enumeration_section">2.3 </span>The Declare Section
               </h3>
               <div>
                  <p>Passing data between the database server and your application program requires host variables and error handling. This section shows you how to meet these requirements.</p>
               </div><a id="LNPCB177"></a><div class="props_rev_3"><a id="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" name="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161"></a><h4 id="LNPCB-GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" class="sect4"><span class="enumeration_section">2.3.1 </span>Contents of a Declare Section
                  </h4>
                  <div>
                     <div class="section">
                        <p>A Declare Section begins with the statement<a id="d7799e2132" class="indexterm-anchor"></a><a id="d7799e2136" class="indexterm-anchor"></a><a id="d7799e2140" class="indexterm-anchor"></a>:
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
</pre><p>and ends with the statement:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL END DECLARE SECTION END-EXEC.
</pre><p>Between these two statements only the following are allowed:<a id="d7799e2153" class="indexterm-anchor"></a><a id="d7799e2157" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Host-variable and indicator-variable declarations </p>
                           </li>
                           <li>
                              <p>Non-host COBOL variables</p>
                           </li>
                           <li>
                              <p>EXEC SQL DECLARE statements</p>
                           </li>
                           <li>
                              <p>EXEC SQL INCLUDE statements </p>
                           </li>
                           <li>
                              <p>EXEC SQL VAR statements </p>
                           </li>
                           <li>
                              <p>EXEC ORACLE statements</p>
                           </li>
                           <li>
                              <p>COBOL comments</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB178"></a><div class="props_rev_3"><a id="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" name="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB"></a><h5 id="LNPCB-GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" class="sect5"><span class="enumeration_section">2.3.1.1 </span>An Example
                     </h5>
                     <div>
                        <div class="section">
                           <p>In the following example, you declare four host variables for use later in your program.  <a id="d7799e2208" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION.
   ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         ...
 01  EMP-NUMBER     PIC 9(4)  COMP VALUE ZERO.
 01  EMP-NAME       PIC X(10) VARYING.
 01  SALARY         PIC S9(5)V99 COMP-3 VALUE ZERO.
 01  COMMISSION     PIC S9(5)V99 COMP-3 VALUE ZERO.
     EXEC SQL END DECLARE SECTION END-EXEC.</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB179"></a><div class="props_rev_3"><a id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" name="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE"></a><h4 id="LNPCB-GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" class="sect4"><span class="enumeration_section">2.3.2 </span>Precompiler Option DECLARE_SECTION
                  </h4>
                  <div>
                     <div class="section">
                        <p>The Declare Section is optional. For backward compatibility with releases prior to 8.0, for which it was required, Pro*COBOL provides a command-line precompiler option for explicit control over whether only declarations in the Declare Section are allowed as host variables. This option is:</p>
                        <p>DECLARE_SECTION={YES | NO} (default is NO)</p>
                        <p>You must use the DECLARE_SECTION option on the command line or in a configuration file. </p>
                        <p>When MODE=ORACLE and DECLARE_SECTION=YES, only variables declared inside the Declare Section are allowed as host variables. When MODE=ANSI then DECLARE_SECTION is implicitly set to YES.</p>
                        <p>If DECLARE_SECTION is set to YES, then you must declare all program variables used in SQL statements inside the Declare Section. If DECLARE_SECTION is set to NO, then it is optional to use a Declare Section. In this case, declarations of host variables and indicator variables can be made either inside or outside a Declare Section. This optional behavior is a change from Release 8.0 and earlier releases.</p>
                        <p>Multiple Declare Sections are allowed for each precompiled unit. Furthermore, a host program can contain several independently precompiled units.<a id="d7799e2256" class="indexterm-anchor"></a></p>
                        <div class="infoboxnotealso" id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE__GUID-5688F9A4-25D3-4F3F-B4FD-7FAD330A0259">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="precompiler-options.html#GUID-B8F5D2F9-D077-4CC0-B8A5-0B4CB1D6425D">Macro and Micro Options</a>"</span> for more information about macro and micro options.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="precompiler-options.html#GUID-A4AB5DC2-8F05-47BD-8299-3A50DE9C6A5E">DECLARE_SECTION</a>"</span> for more details of the option.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB180"></a><div class="props_rev_3"><a id="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" name="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473"></a><h4 id="LNPCB-GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" class="sect4"><span class="enumeration_section">2.3.3 </span>Using the INCLUDE Statement
                  </h4>
                  <div>
                     <p>The INCLUDE statement lets you copy files into your host program, as the following example shows: </p><pre class="oac_no_warn" dir="ltr">*    Copy in the SQL Communications Area (SQLCA) 
     EXEC SQL INCLUDE SQLCA END-EXEC. 
*    Copy in the Oracle Communications Area (ORACA) 
     EXEC SQL INCLUDE ORACA END-EXEC. 
</pre><p>You can INCLUDE any file. When you precompile your Pro*COBOL program, each EXEC SQL INCLUDE statement is replaced by a copy of the file named in the statement.<a id="d7799e2305" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB181"></a><div class="props_rev_3"><a id="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" name="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D"></a><h5 id="LNPCB-GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" class="sect5"><span class="enumeration_section">2.3.3.1 </span>Filename Extensions
                     </h5>
                     <div>
                        <div class="section">
                           <p>If your system uses file extensions but you do not specify one, Pro*COBOL assumes the default extension for source files (usually COB). For more information, see your Oracle system-specific documentation.<a id="d7799e2334" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB182"></a><div class="props_rev_3"><a id="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" name="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12"></a><h5 id="LNPCB-GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" class="sect5"><span class="enumeration_section">2.3.3.2 </span>Search Paths
                     </h5>
                     <div>
                        <p>If your system uses directories, you can set a search path for included files using the INCLUDE option, as follows:</p><pre class="oac_no_warn" dir="ltr">INCLUDE=<span class="italic">path</span> 
</pre><p>where <span class="italic">path</span> defaults to the current directory.
                        </p>
                        <p>Pro*COBOL first searches the current directory, then the directory specified by the INCLUDE option, and finally the directory for standard INCLUDE files. You need not specify a path for standard files such as the SQLCA and ORACA. However, a path is required for nonstandard files unless they are stored in the current directory.<a id="d7799e2375" class="indexterm-anchor"></a></p>
                        <p>You can also specify multiple paths on the command line, as follows: </p><pre class="oac_no_warn" dir="ltr">... INCLUDE=&lt;path1&gt; INCLUDE=&lt;path2&gt; ... 
</pre><p>When multiple paths are specified, Pro*COBOL searches the current directory first, then the <span class="italic">path1</span> directory, then the <span class="italic">path2</span> directory, and so on. The directory containing standard INCLUDE files is searched last. The path syntax is system specific. For more information, see your Oracle system-specific documentation.
                        </p>
                        <p>Remember that Pro*COBOL searches for a file in the current directory first even if you specify a search path. If the file you want to INCLUDE is in another directory, make sure no file with the same name is in the current directory or any other directory that precedes it in the search path. If your operating system is case sensitive, be sure to specify the same upper/lowercase filename under which the file is stored.<a id="d7799e2393" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB183"></a><div class="props_rev_3"><a id="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" name="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC"></a><h3 id="LNPCB-GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" class="sect3"><span class="enumeration_section">2.4 </span>Nested Programs
               </h3>
               <div>
                  <p>Nesting programs in COBOL means that you place one program inside another. The contained programs may reference some of the resources of the programs that contain them. The names within the higher-level program and the nested program can be the same, and describe different data items without conflict, because the names are known only within the programs. However, names described in the Configuration Section of the higher-level program can be referenced in the nested program.</p>
                  <p>Some compilers do not support the GLOBAL clause. Pro*COBOL supports nested programs by generating code that contains GLOBAL clauses. To avoid generating GLOBAL clauses unconditionally, specify the precompiler option NESTED=NO. NESTED (=YES or NO) defaults to YES and can be used in configuration files, or on the command line, but not inline (EXEC ORACLE statement). </p>
                  <p>The higher-level program can contain several nested programs. Likewise, nested programs can have programs nested within them. You must place the nested program directly before the END PROGRAM header of the program in which it is nested.</p>
                  <p>You can call a nested program only by a program in which it is either directly or indirectly nested. If you want a nested program to be called by any program, even one on a different branch of the nested tree structure, you code the COMMON clause in the PROGRAM-ID paragraph of the nested program. You can code COMMON only for nested programs:</p><pre class="oac_no_warn" dir="ltr"> PROGRAM-ID.  &lt;nested-program-name&gt; COMMON.
</pre><p>You can code the GLOBAL phrase for File Definitions and level 01 data items (any subordinate items automatically become global). This enables them to be referenced in all subprograms directly or indirectly contained within them. You code GLOBAL on the higher-level program. If the nested program defines the same name as one declared GLOBAL in a higher-level program, COBOL uses the declaration within the nested program. If the data item contains a REDEFINES clause, GLOBAL must follow it.</p><pre class="oac_no_warn" dir="ltr"> FD file-name GLOBAL ...
 01 data-name1 GLOBAL ...
 01 data-name2 REDEFINES data-name3 GLOBAL ...</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-8FA5E1B2-2B76-4BBF-BA9B-CF31814BB2D0">NESTED</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB184"></a><div class="props_rev_3"><a id="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" name="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB"></a><h4 id="LNPCB-GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" class="sect4"><span class="enumeration_section">2.4.1 </span>Support for Nested Programs
                  </h4>
                  <div>
                     <p>Pro*COBOL enables you to store nested programs with embedded SQL within a single source file. All 01 level items, which are marked as global in a containing program and are valid host variables at the containing program level, are usable as valid host variables in any programs directly or indirectly contained by the containing program. Consider the following example:</p><pre class="oac_no_warn" dir="ltr"> IDENTIFICATION DIVISION.
 PROGRAM-ID. MAINPROG.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.

     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01 REC1  GLOBAL.
           05    VAR1   PIC X(10).
           05    VAR2   PIC X(10).
 01 VAR1  PIC X(10) GLOBAL.
     EXEC SQL END DECLARE SECTION END-EXEC.

 PROCEDURE DIVISION.
     ...
     &lt;main program statements&gt;
     ...
 IDENTIFICATION DIVISION.
    PROGRAM-ID. NESTEDPROG.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.

 01 VAR1   PIC S9(4).

 PROCEDURE DIVISION.
     ...
     EXEC SQL SELECT X, Y INTO :REC1 FROM ... END-EXEC.

     EXEC SQL SELECT X INTO :VAR1 FROM ... END-EXEC.

     EXEC SQL SELECT X INTO :REC1.VAR1 FROM ... END-EXEC.
     ...
 END PROGRAM NESTEDPROG.
 END PROGRAM MAINPROG.
</pre><p>The main program declares the host variable REC1 as global, and thus the nested program can use REC1 in the first select statement without having to declare it. Since VAR1 is declared as a global variable and also as a local variable in the nested program, the second select statement will use the VAR1 declared as S9(4), overriding the global declaration. In the third select statement, the global VAR1 of REC1 declared as PIC X(10) is used. </p>
                     <p>The previous paragraph describes the results when DECLARE_SECTION=NO is used. When DECLARE_SECTION=YES, Pro*COBOL will not recognize host variables <span class="italic">unless</span> they are declared inside a Declare Section. If the preceding program is precompiled with DECLARE_SECTION=YES, then the second select statement would result in an ambiguous host variable error. The first and third select statements would function the same. 
                     </p>
                     <p>Note: Recursive nested programs are not supported</p>
                  </div><a id="LNPCB185"></a><div class="props_rev_3"><a id="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" name="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88"></a><h5 id="LNPCB-GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" class="sect5"><span class="enumeration_section">2.4.1.1 </span>Declaring the SQLCA
                     </h5>
                     <div>
                        <p>For information on declaring the SQLCA for nested programs, the included SQLCA definition provided will be declared as global, so the declaration of SQLCA is only required in the higher-level program. The SQLCA can change each time a new SQL statement is executed. The SQLCA provided can always be modified to remove the global specification if you want to declare additional SQLCA areas in the nested programs. This also applies to SQLDA and ORACA.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B">SQLCA Status Variable</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCB186"></a><div class="props_rev_3"><a id="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" name="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33"></a><h5 id="LNPCB-GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" class="sect5"><span class="enumeration_section">2.4.1.2 </span>Nested Program Example
                     </h5>
                     <div>
                        <p>See SAMPLE13.PCO in the demo directory<a id="d7799e2532" class="indexterm-anchor"></a>.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB187"></a><div class="props_rev_3"><a id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" name="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0"></a><h3 id="LNPCB-GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" class="sect3"><span class="enumeration_section">2.5 </span>Conditional Precompilations
               </h3>
               <div>
                  <p>Conditional precompilation includes (or excludes) sections of code in your host program based on certain conditions. For example, you might want to include one section of code when precompiling under UNIX and another section when precompiling under VMS. Conditional precompilation lets you write programs that can run in different environments.<a id="d7799e2561" class="indexterm-anchor"></a><a id="d7799e2565" class="indexterm-anchor"></a></p>
                  <p>Conditional sections of code are marked by statements that define the environment and actions to take. You can code host-language statements as well as EXEC SQL statements in these sections. The following statements let you exercise conditional control over precompilation:<a id="d7799e2569" class="indexterm-anchor"></a><a id="d7799e2571" class="indexterm-anchor"></a><a id="d7799e2573" class="indexterm-anchor"></a><a id="d7799e2575" class="indexterm-anchor"></a><a id="d7799e2577" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">*   -- define a symbol
     EXEC ORACLE DEFINE symbol END-EXEC.
*    -- if symbol is defined
     EXEC ORACLE IFDEF symbol  END-EXEC.
*   -- if symbol is not defined
     EXEC ORACLE IFNDEF symbol END-EXEC.
*            -- otherwise  
     EXEC ORACLE ELSE END-EXEC.
*           -- end this control block 
     EXEC ORACLE ENDIF END-EXEC.
</pre><p>A conditional statement must be terminated with<code class="codeph"> END-EXEC</code>.
                  </p>
                  <div class="infoboxnote" id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0__GUID-7BCA471F-CE66-466A-BB6B-5B253873EC90">
                     <p class="notep1">Note:</p>
                     <p>The conditional compilation feature of your compiler may not be supported by Pro*COBOL.</p>
                  </div>
               </div><a id="LNPCB188"></a><div class="props_rev_3"><a id="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" name="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9"></a><h4 id="LNPCB-GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" class="sect4"><span class="enumeration_section">2.5.1 </span>An Example
                  </h4>
                  <div>
                     <div class="section">
                        <p>In the following example, the SELECT statement is precompiled only when the symbol <span class="italic">SITE2</span> is defined:<a id="d7799e2617" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC ORACLE IFDEF SITE2 END-EXEC.
     EXEC SQL SELECT DNAME 
        INTO :DEPT-NAME 
        FROM DEPT 
        WHERE DEPTNO = :DEPT-NUMBER
     EXEC ORACLE ENDIF END-EXEC.
</pre><p>Blocks of conditions can be nested as shown in the following example: </p><pre class="oac_no_warn" dir="ltr">     EXEC ORACLE IFDEF OUTER END-EXEC. 
     EXEC ORACLE IFDEF INNER END-EXEC. 
     ... 
     EXEC ORACLE ENDIF END-EXEC. 
     EXEC ORACLE ENDIF END-EXEC. 
</pre><p>You can "Comment out" host-language or embedded SQL code by placing it between IFDEF and ENDIF and <span class="italic">not</span> defining the symbol.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB189"></a><div class="props_rev_3"><a id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" name="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5"></a><h4 id="LNPCB-GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" class="sect4"><span class="enumeration_section">2.5.2 </span>Defining Symbols
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can define a symbol in two ways. Either include the statement<a id="d7799e2657" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC ORACLE DEFINE symbol END-EXEC.
</pre><p>in your host program or define the symbol on the command line using the syntax </p><pre class="oac_no_warn" dir="ltr">... INAME=filename ... DEFINE=symbol 
</pre><p>where <span class="italic">symbol</span> is not case-sensitive. 
                        </p>
                        <p>Some port-specific symbols are predefined for you when Pro*COBOL is installed on your system. For example, predefined operating system symbols include CMS, MVS, UNIX, and VMS. </p>
                        <div class="infoboxnote" id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5__GUID-A1F9FCF9-D2D5-4031-B1F1-71AF37E85CA6">
                           <p class="notep1">Note:</p>
                           <p>A DEFINE SYMBOL name beginning with a number, or that includes a dash, causes an unrecoverable error during precompilation. You can use underscores, and you can use numbers other than at the beginning of a DEFINE SYMBOL name.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB190"></a><div class="props_rev_3"><a id="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" name="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153"></a><h3 id="LNPCB-GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" class="sect3"><span class="enumeration_section">2.6 </span>Separate Precompilations 
               </h3>
               <div>
                  <p>You can precompile several COBOL program modules separately and then link them into one executable program. This supports modular programming, which is required when the functional components of a program are written and debugged by different programmers. The individual program modules need not be written in the same language.<a id="d7799e2702" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB191"></a><div class="props_rev_3"><a id="GUID-1812416E-8E90-45F4-A219-13175B8E66E5" name="GUID-1812416E-8E90-45F4-A219-13175B8E66E5"></a><h4 id="LNPCB-GUID-1812416E-8E90-45F4-A219-13175B8E66E5" class="sect4"><span class="enumeration_section">2.6.1 </span>Guidelines
                  </h4>
                  <div>
                     <p>The following guidelines will help you avoid some common problems.<a id="d7799e2730" class="indexterm-anchor"></a><a id="d7799e2734" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB192"></a><div class="props_rev_3"><a id="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" name="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6"></a><h5 id="LNPCB-GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" class="sect5"><span class="enumeration_section">2.6.1.1 </span>Referencing Cursors
                     </h5>
                     <div>
                        <p>Cursor names are SQL identifiers, whose scope is the precompilation unit. Hence, cursor operations cannot span precompilation units (files). That is, you cannot declare a cursor in one file and open or fetch from it in another file, so when doing a separate precompilation, make sure all definitions and references to a given cursor are in one file.<a id="d7799e2762" class="indexterm-anchor"></a><a id="d7799e2766" class="indexterm-anchor"></a></p>
                     </div>
                  </div><a id="LNPCB193"></a><div class="props_rev_3"><a id="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" name="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B"></a><h5 id="LNPCB-GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" class="sect5"><span class="enumeration_section">2.6.1.2 </span>Specifying MAXOPENCURSORS
                     </h5>
                     <div>
                        <div class="section">
                           <p>When you precompile the program module that connects to Oracle, specify a value for MAXOPENCURSORS that is high enough for any of the program modules. If you use it for another program module, MAXOPENCURSORS is ignored. Only the value in effect for the connect is used at run time.<a id="d7799e2795" class="indexterm-anchor"></a><a id="d7799e2799" class="indexterm-anchor"></a></p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB194"></a><div class="props_rev_3"><a id="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" name="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D"></a><h5 id="LNPCB-GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" class="sect5"><span class="enumeration_section">2.6.1.3 </span>Using a Single SQLCA
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d7799e2828" class="indexterm-anchor"></a><a id="d7799e2832" class="indexterm-anchor"></a>If you want to use just one memory area for the SQLCA, the process for doing so depends on which version of Pro*COBOL you are using.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div><a id="LNPCB195"></a><div class="props_rev_3"><a id="GUID-F85437B3-C029-4711-8999-33530662242D" name="GUID-F85437B3-C029-4711-8999-33530662242D"></a><h6 id="LNPCB-GUID-F85437B3-C029-4711-8999-33530662242D" class="sect6"><span class="enumeration_section">2.6.1.3.1 </span>Version 1.8 and Lower
                        </h6>
                        <div>
                           <div class="section">
                              <p>You must declare the SQLCA globally. You can do this by modifying the SQLCA.COB file, changing the line</p><pre class="oac_no_warn" dir="ltr"> 01  SQLCA.
</pre><p>to</p><pre class="oac_no_warn" dir="ltr"> 01  SQLCA EXTERNAL.
</pre><p>Alternatively, you can include a hard-coded definition for SQLCA, copied from SQLCA.cob and make the aforementioned change. Note that you still have to include a definition of SQLCA in each precompiled unit.</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="LNPCB196"></a><div class="props_rev_3"><a id="GUID-AC037535-1828-4372-9148-EFE2FBBA1501" name="GUID-AC037535-1828-4372-9148-EFE2FBBA1501"></a><h6 id="LNPCB-GUID-AC037535-1828-4372-9148-EFE2FBBA1501" class="sect6"><span class="enumeration_section">2.6.1.3.2 </span>Version 2 and Later
                        </h6>
                        <div>
                           <div class="section">
                              <p>In later versions of Pro*COBOL, the SQLCA is not copied from the file system.  It is generated by the precompiler.  If you need to share the SQLCA structure in these versions, instead of this statement:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INCLUDE SQLCA END-EXEC
</pre><p>you should use the following code:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INCLUDE SQLCA.ANX END-EXEC
</pre><p>This causes the precompiler to generate the SQLCA structure with the EXTERNAL keyword added automatically.</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNPCB197"></a><div class="props_rev_3"><a id="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" name="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462"></a><h5 id="LNPCB-GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" class="sect5"><span class="enumeration_section">2.6.1.4 </span>Using a Single DATE_FORMAT
                     </h5>
                     <div>
                        <p>You must use the same format string for DATE in each program module.</p>
                     </div>
                  </div>
               </div><a id="LNPCB198"></a><div class="props_rev_3"><a id="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" name="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9"></a><h4 id="LNPCB-GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" class="sect4"><span class="enumeration_section">2.6.2 </span>Restrictions
                  </h4>
                  <div>
                     <p>All references to an explicit cursor must be in the same program file. You cannot perform operations on a cursor that was declared in a different module. See Chapter 4 for more information about cursors.<a id="d7799e2951" class="indexterm-anchor"></a></p>
                     <p>Also, any program file that contains SQL statements must have a SQLCA that is in the scope of the local SQL statements.</p>
                  </div>
               </div>
            </div><a id="LNPCB199"></a><div class="props_rev_3"><a id="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" name="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC"></a><h3 id="LNPCB-GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" class="sect3"><span class="enumeration_section">2.7 </span>Compiling and Linking 
               </h3>
               <div>
                  <p>To get an executable program, you must compile the source file(s) produced by Pro*COBOL, then link the resulting object module with any modules needed from SQLLIB and system-specific Oracle libraries.<a id="d7799e2981" class="indexterm-anchor"></a><a id="d7799e2983" class="indexterm-anchor"></a> 
                  </p>
                  <p>The linker resolves symbolic references in the object modules. If these references conflict, the link fails. Such conflicts can happen when you try to link third party software into a precompiled program. Not all third-party software is compatible with Oracle, so you might have problems. Check with Oracle Support Services to see if the software is supported.</p>
                  <p>Compiling and linking are system-dependent. For example, on some systems, you must turn off compiler optimization when compiling a host language program. For instructions, see your system-specific Oracle manual.</p>
               </div>
            </div><a id="LNPCB200"></a><div class="props_rev_3"><a id="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" name="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA"></a><h3 id="LNPCB-GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" class="sect3"><span class="enumeration_section">2.8 </span>Sample DEPT and EMP Tables
               </h3>
               <div>
                  <p>Most of the complete program examples in this guide use two sample database tables: DEPT and EMP. If they do not exist in your demo directory, create them before running the sample programs. Their definitions follow: <a id="d7799e3014" class="indexterm-anchor"></a><a id="d7799e3018" class="indexterm-anchor"></a><a id="d7799e3022" class="indexterm-anchor"></a><a id="d7799e3024" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CREATE TABLE DEPT (DEPTNO NUMBER(2), DNAME VARCHAR2(14), LOC VARCHAR2(13));

CREATE TABLE EMP (EMPNO NUMBER(4) primary key, ENAME VARCHAR2(10), JOB VARCHAR2(9), MGR NUMBER(4), HIREDATE DATE, SAL NUMBER(7,2), COMM NUMBER(7,2), DEPTNO NUMBER(2));</pre></div><a id="LNPCB201"></a><div class="props_rev_3"><a id="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" name="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2"></a><h4 id="LNPCB-GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" class="sect4"><span class="enumeration_section">2.8.1 </span>Sample DEPT and EMP Data
                  </h4>
                  <div>
                     <p>Respectively, the DEPT and EMP tables contain the following rows of data:</p><pre class="oac_no_warn" dir="ltr">DEPTNO  DNAME      LOC
------- ---------- ---------
10      ACCOUNTING NEW YORK
20      RESEARCH   DALLAS
30      SALES      CHICAGO
40      OPERATIONS BOSTON

EMPNO ENAME   JOB          MGR  HIREDATE    SAL   COMM  DEPTNO
----- ------- --------- ------ --------- ------ ------ -------
 7369 SMITH   CLERK       7902 17-DEC-80    800             20
 7499 ALLEN   SALESMAN    7698 20-FEB-81   1600    300      30
 7521 WARD    SALESMAN    7698 22-FEB-81   1250    500      30
 7566 JONES   MANAGER     7839 02-APR-81   2975             20
 7654 MARTIN  SALESMAN    7698 28-SEP-81   1250   1400      30
 7698 BLAKE   MANAGER     7839 01-MAY-81   2850             30
 7782 CLARK   MANAGER     7839 09-JUN-81   2450             10
 7788 SCOTT   ANALYST     7566 19-APR-87   3000             20
 7839 KING    PRESIDENT        17-NOV-81   5000             10
 7844 TURNER  SALESMAN    7698 08-SEP-81   1500             30
 7876 ADAMS   CLERK       7788 23-MAY-87   1100             20
 7900 JAMES   CLERK       7698 03-DEC-81    950             30
 7902 FORD    ANALYST     7566 03-DEC-81   3000             20
 7934 MILLER  CLERK       7782 23-JAN-82   1300             10</pre></div>
               </div>
            </div><a id="LNPCB202"></a><div class="props_rev_3"><a id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" name="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D"></a><h3 id="LNPCB-GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" class="sect3"><span class="enumeration_section">2.9 </span>Sample EMP Program: SAMPLE1.PCO 
               </h3>
               <div>
                  <p>A good way to get acquainted with embedded SQL is to look at a program example. This program is SAMPLE1.PCO in the<code class="codeph"> demo </code>directory.
                  </p>
                  <p>The program logs on to the database, prompts the user for an employee number, queries the database table EMP for the employee's name, salary, and commission. The selected results are stored in host variables EMP-NAME, SALARY, and COMMISSION. The program uses the host indicator variable, COMM-IND to detect NULL values in column COMMISSION.</p>
                  <p>The paragraph DISPLAY-INFO then displays the result. </p>
                  <p>Bug 	7225844 - Following para - substituted EMP-NAME for EMP-NUMBER</p>
                  <p>The COBOL variables USERNAME, PASSWD, and EMP-NAME are declared using the VARYING clause, which enables you to use a variable-length string external Oracle datatype called VARCHAR.</p>
                  <p>The SQLCA Communications Area is included to handle errors. If an error occurs, paragraph SQL-ERROR is performed.</p>
                  <p>The BEGIN DECLARE SECTION and END DECLARE SECTION statements used are optional, unless you set the precompiler option DECLARE_SECTION to YES, or option MODE to ANSI.</p>
                  <p>The WHENEVER statement is used to handle errors.</p>
                  <p>The program ends when the user enters a zero employee number<a id="d7799e3104" class="indexterm-anchor"></a>.
                  </p>
                  <div class="infoboxnote" id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D__GUID-C2DFA7D5-EA8F-4EAF-912C-7AE2EA4AA981">
                     <p class="notep1">Note:</p>
                     <p>For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.
                     </p>
                  </div><pre class="oac_no_warn" dir="ltr">* This program logs on to ORACLE, prompts the user for an employee number, 
* queries the database for the employee's name, salary, and commission, then
* displays the result. The program terminates when the user enters a 0.              *
       ID DIVISION.

       PROGRAM-ID. QUERY.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMP-REC-VARS.
           05  EMP-NAME      PIC X(10) VARYING.
           05  EMP-NUMBER    PIC S9(4) COMP VALUE ZERO.
           05  SALARY        PIC S9(5)V99 COMP-3 VALUE ZERO.
           05  COMMISSION    PIC S9(5)V99 COMP-3 VALUE ZERO.
           05  COMM-IND      PIC S9(4) COMP VALUE ZERO.
           EXEC SQL END DECLARE SECTION END-EXEC.

           EXEC SQL INCLUDE SQLCA END-EXEC.

       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-SALARY      PIC Z(4)9.99.
           05  D-COMMISSION  PIC Z(4)9.99.
           05  D-EMP-NUMBER  PIC 9(4).

       01 D-TOTAL-QUERIED   PIC 9(4) VALUE ZERO.
        
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR
              DO PERFORM SQL-ERROR END-EXEC.

           PERFORM LOGON.

       QUERY-LOOP.
           DISPLAY " ".
           DISPLAY "ENTER EMP NUMBER (0 TO QUIT): "
               WITH NO ADVANCING.

           ACCEPT D-EMP-NUMBER.

           MOVE D-EMP-NUMBER TO EMP-NUMBER.
           IF (EMP-NUMBER = 0)
               PERFORM SIGN-OFF.
           MOVE SPACES TO EMP-NAME-ARR.
           EXEC SQL WHENEVER NOT FOUND GOTO NO-EMP END-EXEC.
           EXEC SQL SELECT ENAME, SAL, NVL(COMM, 0)
               INTO :EMP-NAME, :SALARY, :COMMISSION:COMM-IND
               FROM EMP
               WHERE EMPNO = :EMP-NUMBER
           END-EXEC.
           PERFORM DISPLAY-INFO.
           ADD 1 TO D-TOTAL-QUERIED.
           GO TO QUERY-LOOP.

       NO-EMP.
           DISPLAY "NOT A VALID EMPLOYEE NUMBER - TRY AGAIN.".
           GO TO QUERY-LOOP.

       LOGON.
           MOVE "SCOTT" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "TIGER" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY " ".
           DISPLAY "CONNECTED TO ORACLE AS USER: ", USERNAME-ARR.
        
       DISPLAY-INFO.
           DISPLAY " ".
           DISPLAY "EMPLOYEE    SALARY    COMMISSION".
           DISPLAY "--------    ------    ----------". 
           MOVE EMP-NAME-ARR TO D-EMP-NAME.
           MOVE SALARY TO D-SALARY.
           IF COMM-IND = -1
               DISPLAY D-EMP-NAME, D-SALARY, "          NULL"
           ELSE
               MOVE COMMISSION TO D-COMMISSION
               DISPLAY D-EMP-NAME, D-SALARY, "      ", D-COMMISSION
           END-IF.

       SIGN-OFF.
           DISPLAY " ".
           DISPLAY "TOTAL NUMBER QUERIED WAS ",
               D-TOTAL-QUERIED, ".".
           DISPLAY " ".
           DISPLAY "HAVE A GOOD DAY.".
           DISPLAY " ".
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">Using the SQL Communications Area</a></li>
                        <li><a href="precompiler-options.html#GUID-976DED3A-3840-48A5-B5A8-35FB91BF2A0D">MODE</a></li>
                        <li><a href="error-handling-and-diagnostics.html#GUID-A947AF06-314B-46B3-9940-A3002EC04039">WHENEVER Directive</a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>