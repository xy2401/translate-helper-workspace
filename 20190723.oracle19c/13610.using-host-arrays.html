<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Using Host Arrays</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="error-handling-diagnostics.html" title="Previous" type="text/html">
      <link rel="next" href="using-dynamic-SQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="error-handling-diagnostics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-dynamic-SQL.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Using Host Arrays</li>
            </ol>
            <a id="GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F" name="GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F"></a>
            
            <h2 id="ZZPRE-GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F" class="sect2"><span class="enumeration_chapter">9 </span> Using Host Arrays
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the following:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="using-host-arrays.html#GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142">What Is a Host Array?</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-D2BB8D23-4C72-450E-952A-07DCD0058832">Why Use Arrays?</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8">Declaring Host Arrays</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0">About Using Arrays in SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33">About Selecting into Arrays</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E">About Using Indicator Arrays</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802">About Using the FOR Clause</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566">About Using the WHERE Clause</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">About Mimicking the CURRENT OF Clause</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33">About Using SQLERRD(3)</a></p>
                  </li>
               </ul>
               <p>This chapter looks at using arrays to simplify coding and improve program performance. You learn how to manipulate Oracle data using arrays, how to operate on all the elements of an array with a single SQL statement, and how to limit the number of array elements processed. The following questions are answered:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>What is a host array?</p>
                  </li>
                  <li>
                     <p>Why use arrays?</p>
                  </li>
                  <li>
                     <p>How are host arrays declared?</p>
                  </li>
                  <li>
                     <p>How are arrays used in SQL statements?</p>
                  </li>
               </ul>
            </div><a id="ZZPRE842"></a><div class="props_rev_3"><a id="GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142" name="GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142"></a><h3 id="ZZPRE-GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142" class="sect3"><span class="enumeration_section">9.1 </span>What Is a Host Array?
               </h3>
               <div>
                  <p><a id="d70073e94" class="indexterm-anchor"></a>An <span class="italic">array</span> is a collection of related data items, called <span class="italic">elements</span>, associated with a single variable name. When declared as a host variable, the array is called a<a id="d70073e103" class="indexterm-anchor"></a> <span class="italic">host array</span>. Likewise, an indicator variable declared as an array is called an <a id="d70073e109" class="indexterm-anchor"></a><span class="italic">indicator array</span>. An indicator array can be associated with any host array.
                  </p>
               </div>
            </div><a id="ZZPRE843"></a><div class="props_rev_3"><a id="GUID-D2BB8D23-4C72-450E-952A-07DCD0058832" name="GUID-D2BB8D23-4C72-450E-952A-07DCD0058832"></a><h3 id="ZZPRE-GUID-D2BB8D23-4C72-450E-952A-07DCD0058832" class="sect3"><span class="enumeration_section">9.2 </span>Why Use Arrays?
               </h3>
               <div>
                  <p>Arrays can ease programming and offer improved performance. When writing an application, you are usually faced with the problem of storing and manipulating large collections of data. Arrays simplify the task of naming and referencing the individual items in each collection.</p>
                  <p><a id="d70073e138" class="indexterm-anchor"></a>Using arrays can boost the performance of your application. Arrays let you manipulate an entire collection of data items with a single SQL statement. Thus, Oracle communication overhead is reduced markedly, especially in a networked environment. For example, suppose you want to insert information about 300 employees into the EMP table. Without arrays, your program must do 300 individual <code class="codeph">INSERTs</code>--one for each employee. With arrays, only one <code class="codeph">INSERT</code> need be done.
                  </p>
               </div>
            </div><a id="ZZPRE844"></a><div class="props_rev_3"><a id="GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8" name="GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8"></a><h3 id="ZZPRE-GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8" class="sect3"><span class="enumeration_section">9.3 </span>Declaring Host Arrays
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d70073e178" class="indexterm-anchor"></a><a id="d70073e180" class="indexterm-anchor"></a>You declare host arrays in the Declare Section like simple host variables. You also <span class="italic">dimension</span> (set the size of) host arrays in the Declare Section. In the following example, you declare three host arrays and dimension them with <a id="d70073e188" class="indexterm-anchor"></a>50 elements:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_name (50) CHARACTER(20);
 emp_number (50) INTEGER;
 salary (50) REAL;
EXEC SQL END DECLARE SECTION;
</pre></div>
                  <!-- class="section" -->
               </div><a id="ZZPRE845"></a><div class="props_rev_3"><a id="GUID-75644851-65D0-4D71-AA86-B3F143CD3F53" name="GUID-75644851-65D0-4D71-AA86-B3F143CD3F53"></a><h4 id="ZZPRE-GUID-75644851-65D0-4D71-AA86-B3F143CD3F53" class="sect4"><span class="enumeration_section">9.3.1 </span>Dimensioning Arrays
                  </h4>
                  <div>
                     <p><a id="d70073e216" class="indexterm-anchor"></a>The maximum dimension of a host array is 32,767 elements. If you use a host array that exceeds the maximum, you get a "parameter out of range" run-time error. If you use multiple host arrays in a single SQL statement, their dimensions should be the same. Otherwise, an "array size mismatch" warning message is issued at precompile time. If you ignore this warning, the precompiler uses the <span class="italic">smallest</span> dimension for the SQL operation.
                     </p>
                  </div>
               </div><a id="ZZPRE846"></a><div class="props_rev_3"><a id="GUID-8340AE22-CA85-4300-B685-49ED17ABB891" name="GUID-8340AE22-CA85-4300-B685-49ED17ABB891"></a><h4 id="ZZPRE-GUID-8340AE22-CA85-4300-B685-49ED17ABB891" class="sect4"><span class="enumeration_section">9.3.2 </span>Restrictions
                  </h4>
                  <div>
                     <p><a id="d70073e245" class="indexterm-anchor"></a>You cannot declare host arrays of pointers. Also, host arrays that might be <a id="d70073e250" class="indexterm-anchor"></a>referenced in a SQL statement are limited to one dimension. So, the two-dimensional array declared in the following example is <span class="italic">invalid</span>:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 hi_lo_scores (25, 25) INTEGER; -- not allowed
EXEC SQL END DECLARE SECTION;
</pre></div>
               </div>
            </div><a id="ZZPRE847"></a><div class="props_rev_3"><a id="GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0" name="GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0"></a><h3 id="ZZPRE-GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0" class="sect3"><span class="enumeration_section">9.4 </span>About Using Arrays in SQL Statements
               </h3>
               <div>
                  <p>The Oracle Precompilers allow the use of host arrays in data manipulation statements. You can use host arrays as input variables in the <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> statements and as output variables in the <code class="codeph">INTO</code> clause of <code class="codeph">SELECT</code> and <code class="codeph">FETCH</code> statements.
                  </p>
                  <p><a id="d70073e302" class="indexterm-anchor"></a>Note that when <code class="codeph">MODE=ANSI14</code>, array operations are <span class="italic">not</span> allowed. In other words, you can reference host arrays in a SQL statement only when <code class="codeph">MODE</code>={<code class="codeph">ANSI|ANSI13|ORACLE}</code>.
                  </p>
                  <p>The syntax used for host arrays and simple host variables is nearly the same. One difference is the optional FOR clause, which lets you control array processing. Also, there are restrictions on mixing host arrays and simple host variables in a SQL statement.</p>
                  <p>The following sections illustrate the use of host arrays in data manipulation statements.</p>
               </div>
            </div><a id="ZZPRE848"></a><div class="props_rev_3"><a id="GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33" name="GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33"></a><h3 id="ZZPRE-GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33" class="sect3"><span class="enumeration_section">9.5 </span>About Selecting into Arrays
               </h3>
               <div>
                  <p><a id="d70073e344" class="indexterm-anchor"></a>You can <a id="d70073e349" class="indexterm-anchor"></a>use host arrays as output variables in the <code class="codeph">SELECT</code> statement. If you know the maximum number of rows the select will return, simply dimension the host arrays with that number of elements. In the following example, you select directly into three host arrays. Knowing the select will return no more than 50 rows, you dimension the arrays with 50 elements:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_name (50) CHARACTER(20);
 emp_number (50) INTEGER;
 salary (50) REAL;
EXEC SQL END DECLARE SECTION;
EXEC SQL SELECT ENAME, EMPNO, SAL
 INTO :emp_name, :emp_number, :salary
 FROM EMP
 WHERE SAL &gt; 1000;
</pre><p>In this example, the <code class="codeph">SELECT</code> statement returns up to 50 rows. If there are fewer than 50 eligible rows or you want to retrieve only 50 rows, this method will suffice. However, if there are more than 50 eligible rows, you cannot retrieve all of them this way. If you reexecute the <code class="codeph">SELECT</code> statement, it just returns the first 50 rows again, even if more are eligible. You must either dimension a larger array or declare a cursor for use with the <code class="codeph">FETCH</code> statement.
                  </p>
                  <p>If a <code class="codeph">SELECT INTO</code> statement returns more rows than the number of elements you dimensioned, Oracle issues the error message
                  </p><pre class="oac_no_warn" dir="ltr">SQL-02112: SELECT...INTO returns too many rows
</pre><p>unless you specify <code class="codeph">SELECT_ERROR</code>=<code class="codeph">NO</code>. For more information about the option <code class="codeph">SELECT_ERROR</code>, refer to <span class="q">"<a href="running-Oracle-precompilers.html#GUID-A15025BA-F60A-4144-BD81-A4394E02C8B9">SELECT_ERROR</a>"</span></p>
               </div><a id="ZZPRE849"></a><div class="props_rev_3"><a id="GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8" name="GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8"></a><h4 id="ZZPRE-GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8" class="sect4"><span class="enumeration_section">9.5.1 </span>Batch Fetches
                  </h4>
                  <div>
                     <p><a id="d70073e417" class="indexterm-anchor"></a>If you do not know the maximum number of rows a select will return, you can declare <a id="d70073e420" class="indexterm-anchor"></a>and open a cursor_name fetch from it in "batches." Batch fetches within a loop let you retrieve a large number of rows with ease. Each fetch returns the next batch of rows from the current active set. In the following example, you fetch in 20-row batches:
                     </p><pre class="oac_no_warn" dir="ltr"><a id="d70073e424" class="indexterm-anchor"></a>EXEC SQL BEGIN DECLARE SECTION;
 emp_number (20) INTEGER;
 salary (20) REAL;
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT EMPNO, SAL FROM EMP;
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND DO <span class="bold">...</span>
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_number, :salary;
 -- process batch of rows
ENDLOOP;
</pre></div>
               </div><a id="ZZPRE850"></a><div class="props_rev_3"><a id="GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7" name="GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7"></a><h4 id="ZZPRE-GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7" class="sect4"><span class="enumeration_section">9.5.2 </span>Number of Rows Fetched
                  </h4>
                  <div>
                     <p>Each fetch returns, at most, the number of rows in the array dimension. Fewer rows are returned in the following cases:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The end of the active set is reached. The "no data found" Oracle warning code is returned to SQLCODE in the SQLCA. For example, this happens if you fetch into an array of dimension 100 but only 20 rows are returned.</p>
                        </li>
                        <li>
                           <p>Fewer than a full batch of rows remain to be fetched. For example, this happens if you fetch 70 rows into an array of dimension 20 because after the third fetch, only 10 rows remain to be fetched.</p>
                        </li>
                        <li>
                           <p>An error is detected while processing a row. The fetch fails and the applicable Oracle error code is returned to SQLCODE.</p>
                        </li>
                     </ul>
                     <p>The cumulative number of rows returned can be found in the third element of SQLERRD in the SQLCA, called <a id="d70073e472" class="indexterm-anchor"></a>SQLERRD(3) in this guide. This applies to each open cursor. In the following example, notice how the status of each cursor is maintained separately:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor1;
EXEC SQL OPEN cursor2;
EXEC SQL FETCH cursor1 INTO :array_of_20;
 -- now running total in SQLERRD(3) is 20
EXEC SQL FETCH cursor2 INTO :array_of_30;
 -- now running total in SQLERRD(3) is 30, not 50
EXEC SQL FETCH cursor1 INTO :array_of_20;
 -- now running total in SQLERRD(3) is 40 (20 + 20)
EXEC SQL FETCH cursor2 INTO :array_of_30;
 -- now running total in SQLERRD(3) is 60 (30 + 30)
</pre></div>
               </div><a id="ZZPRE852"></a><a id="ZZPRE851"></a><div class="props_rev_3"><a id="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D" name="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D"></a><h4 id="ZZPRE-GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D" class="sect4"><span class="enumeration_section">9.5.3 </span>Restrictions
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d70073e503" class="indexterm-anchor"></a>Using host arrays in the <code class="codeph">WHERE</code> clause of a <code class="codeph">SELECT</code> statement is allowed only in a subquery. (For example, refer to <span class="q">"<a href="using-host-arrays.html#GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566">About Using the WHERE Clause</a>"</span>.) Also, you cannot mix simple host variables with host arrays in the INTO clause of a <code class="codeph">SELECT</code> or <code class="codeph">FETCH</code> statement; if any of the host variables is an array, all must be arrays.  <a href="using-host-arrays.html#GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D__BGBJFAID" title="host arrays valid for select statement">Table 9-1</a> shows which uses of host arrays are valid in a <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D__BGBJFAID">
                        <p class="titleintable">Table 9-1 Valid Host Arrays for SELECT INTO</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Valid Host Arrays for SELECT INTO" summary="host arrays valid for select statement" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d70073e548">INTO Clause</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e551">WHERE Clause</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e554">Valid?</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e559" headers="d70073e548 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e559 d70073e551 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e559 d70073e554 ">
                                    <p>no</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e569" headers="d70073e548 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e569 d70073e551 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e569 d70073e554 ">
                                    <p>yes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e579" headers="d70073e548 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e579 d70073e551 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e579 d70073e554 ">
                                    <p>yes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e589" headers="d70073e548 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e589 d70073e551 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e589 d70073e554 ">
                                    <p>no</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ZZPRE853"></a><div class="props_rev_3"><a id="GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4" name="GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4"></a><h4 id="ZZPRE-GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4" class="sect4"><span class="enumeration_section">9.5.4 </span>About Fetching Nulls
                  </h4>
                  <div>
                     <p>If you select or fetch a null into a host array that lacks an indicator array, Oracle stops processing, sets SQLERRD(3) to the number of rows processed, and issues the following error message:</p><pre class="oac_no_warn" dir="ltr">ORA-01405: fetched column value is NULL
</pre><p>To learn how to find nulls and truncated values, refer to <span class="q">"<a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">About Using Indicator Variables</a>"</span>.
                     </p>
                  </div>
               </div><a id="ZZPRE854"></a><div class="props_rev_3"><a id="GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C" name="GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C"></a><h4 id="ZZPRE-GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C" class="sect4"><span class="enumeration_section">9.5.5 </span>About Fetching Truncated Values
                  </h4>
                  <div>
                     <p>When DBMS=V7, if you select or fetch a truncated column value into a host array that lacks an indicator array, Oracle stops processing, sets SQLERRD(3) to the number of rows processed, and issues the following error message:</p><pre class="oac_no_warn" dir="ltr">ORA-01406: fetched column value was truncated
</pre><p>You can check SQLERRD(3) for the number of rows processed before the truncation occurred. The rows-processed count includes the row that caused the truncation error.</p>
                     <p>When MODE=ANSI, truncation is not considered an error, so Oracle continues processing.</p>
                     <p>Again, when doing array selects and fetches, always use indicator arrays. That way, if Oracle assigns one or more truncated column values to an output host array, you can find the original lengths of the column values in the associated indicator array.</p>
                  </div>
               </div><a id="ZZPRE856"></a><a id="ZZPRE855"></a><div class="props_rev_3"><a id="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9" name="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9"></a><h4 id="ZZPRE-GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9" class="sect4"><span class="enumeration_section">9.5.6 </span>About Inserting with Arrays
                  </h4>
                  <div>
                     <p><a id="d70073e688" class="indexterm-anchor"></a>You can use host arrays as input variables in an <code class="codeph">INSERT</code> statement. Just make sure your program populates the arrays with data before executing the <code class="codeph">INSERT</code> statement. If some elements in the arrays are irrelevant, you can use the <code class="codeph">FOR</code> clause to control the number of rows inserted. Refer to <a href="using-host-arrays.html#GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802">About Using the FOR Clause</a>.
                     </p>
                     <p>An example of inserting with host arrays follows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_name (50) CHARACTER(20);
 emp_number (50) INTEGER;
 salary (50) REAL;
EXEC SQL END DECLARE SECTION;
-- populate the host arrays
EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
 VALUES (:emp_name, :emp_number, :salary);
</pre><p>The cumulative number of rows inserted can be found in SQLERRD(3).</p>
                     <p>Although functionally equivalent to the following statement, the <code class="codeph">INSERT</code> statement in the last example is much more efficient because it issues only one call to Oracle:
                     </p><pre class="oac_no_warn" dir="ltr">FOR i = 1 TO array_dimension
 EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
 VALUES (:emp_name[i], :emp_number[i], :salary[i]);
ENDFOR;
</pre><p>In this imaginary example (imaginary because host variables <span class="italic">cannot</span> be subscripted in a SQL statement), you use a FOR loop to access all array elements in sequential order.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9__GUID-65B4D956-3B25-4C25-A91B-C79BDE6CF9A8">Restrictions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>You cannot use an array of pointers in the VALUES clause of an <code class="codeph">INSERT</code> statement; all array elements must be data items. Also, mixing simple host variables with host arrays in the VALUES clause of an <code class="codeph">INSERT</code> statement is <span class="italic">not</span> allowed; if any of the host variables is an array, all must be arrays.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE858"></a><a id="ZZPRE857"></a><div class="props_rev_3"><a id="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D" name="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D"></a><h4 id="ZZPRE-GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D" class="sect4"><span class="enumeration_section">9.5.7 </span>About Updating with Arrays
                  </h4>
                  <div>
                     <p><a id="d70073e767" class="indexterm-anchor"></a>You <a id="d70073e772" class="indexterm-anchor"></a>can also use host arrays as input variables in an <code class="codeph">UPDATE</code> statement, as the following example shows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_number (50) INTEGER;
 salary (50) REAL;
EXEC SQL END DECLARE SECTION;
-- populate the host arrays
EXEC SQL UPDATE EMP SET SAL = :salary WHERE EMPNO = :emp_number;
</pre><p>The cumulative number of rows updated can be found in SQLERRD(3). The number does <span class="italic">not</span> include rows processed by an update cascade.
                     </p>
                     <p>If some elements in the arrays are irrelevant, you can use the FOR clause to limit the number of rows updated.</p>
                     <p>The last example showed a typical update using a unique key (<span class="italic">emp_number</span>). Each array element qualified just one row for updating. In the following example, each array element qualifies multiple rows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 job_title (10) CHARACTER(10);
 commission (50) REAL;
EXEC SQL END DECLARE SECTION;
-- populate the host arrays
EXEC SQL UPDATE EMP SET COMM = :commission WHERE JOB = :job_title;
</pre><p><span class="bold">Restrictions:</span> Mixing simple host variables with host arrays in the <code class="codeph">SET</code> or <code class="codeph">WHERE</code> clause of an <code class="codeph">UPDATE</code> statement is <span class="italic">not</span> allowed. If any of the host variables is an array, all must be arrays. Furthermore, if you use a host array in the SET clause, you <span class="italic">must</span> use one in the <code class="codeph">WHERE</code> clause. However, their dimensions and datatypes need not match.
                     </p>
                     <p>You cannot use host arrays with the <code class="codeph">CURRENT</code> OF clause in an UPDATE statement. For an alternative, refer to <a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">About Mimicking the CURRENT OF Clause</a>.
                     </p>
                     <p><a href="using-host-arrays.html#GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D__BGBCJHCH" title="arrays valid in an update statement">Table 9-2</a> shows which uses of host arrays are valid in an <code class="codeph">UPDATE</code> statement:
                     </p>
                     <div class="tblformal" id="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D__BGBCJHCH">
                        <p class="titleintable">Table 9-2 Valid Host Arrays for UPDATE</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Valid Host Arrays for UPDATE" summary="arrays valid in an update statement" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d70073e848">SET Clause</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e851">WHERE Clause</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e854">Valid?</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e859" headers="d70073e848 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e859 d70073e851 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e859 d70073e854 ">
                                    <p>yes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e869" headers="d70073e848 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e869 d70073e851 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e869 d70073e854 ">
                                    <p>yes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e879" headers="d70073e848 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e879 d70073e851 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e879 d70073e854 ">
                                    <p>no</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e889" headers="d70073e848 ">
                                    <p>scalar</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e889 d70073e851 ">
                                    <p>array</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e889 d70073e854 ">
                                    <p>no</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ZZPRE859"></a><div class="props_rev_3"><a id="GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852" name="GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852"></a><h4 id="ZZPRE-GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852" class="sect4"><span class="enumeration_section">9.5.8 </span>About Deleting with Arrays
                  </h4>
                  <div>
                     <p><a id="d70073e919" class="indexterm-anchor"></a>You can also use host arrays as input variables in a <code class="codeph">DELETE</code> statement. It is like executing the <code class="codeph">DELETE</code> statement repeatedly using successive elements of the host array in the <code class="codeph">WHERE</code> clause. Thus, each execution might delete zero, one, or more rows from the table. An example of deleting with host arrays follows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 emp_number (50) INTEGER;
 EXEC SQL END DECLARE SECTION;
-- populate the host array
EXEC SQL DELETE FROM EMP WHERE EMPNO = :emp_number;
</pre><p>The cumulative number of rows deleted can be found in SQLERRD(3). That number does <span class="italic">not</span> include rows processed by a delete cascade.
                     </p>
                     <p>The last example showed a typical delete using a unique key (<span class="italic">emp_number</span>). Each array element qualified just one row for deletion. In the following example, each array element qualifies multiple rows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 job_title (10) CHARACTER(10);
EXEC SQL END DECLARE SECTION;
-- populate the host array
EXEC SQL DELETE FROM EMP WHERE JOB = :job_title;
</pre></div>
               </div><a id="ZZPRE860"></a><div class="props_rev_3"><a id="GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394" name="GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394"></a><h4 id="ZZPRE-GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394" class="sect4"><span class="enumeration_section">9.5.9 </span>Restrictions
                  </h4>
                  <div>
                     <p>Mixing simple host variables with host arrays in the <code class="codeph">WHERE</code> clause of a <code class="codeph">DELETE</code> statement is <span class="italic">not</span> allowed; if any of the host variables is an array, all must be arrays. Also, you cannot use host arrays with the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause in a <code class="codeph">DELETE</code> statement. For an alternative, refer to <span class="q">"<a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">About Mimicking the CURRENT OF Clause</a>"</span>.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE861"></a><div class="props_rev_3"><a id="GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E" name="GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E"></a><h3 id="ZZPRE-GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E" class="sect3"><span class="enumeration_section">9.6 </span>About Using Indicator Arrays
               </h3>
               <div>
                  <p>You use indicator arrays to assign nulls to input host arrays and to detect null or truncated values in output host arrays. The following example shows how to insert with indicator arrays:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_number (50) INTEGER;
 dept_number (50) INTEGER;
 commission (50) REAL;
 ind_comm (50) SMALLINT; -- indicator array
EXEC SQL END DECLARE SECTION;
-- populate the host arrays
-- populate the indicator array; to insert a null into
-- the COMM column, assign -1 to the appropriate element in
-- the indicator array
EXEC SQL INSERT INTO EMP (EMPNO, DEPTNO, COMM)
 VALUES (:emp_number, :dept_number, :commission:ind_comm);
</pre><p>The dimension of the indicator array cannot be smaller than the dimension of the host array.</p>
               </div>
            </div><a id="ZZPRE862"></a><div class="props_rev_3"><a id="GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802" name="GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802"></a><h3 id="ZZPRE-GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802" class="sect3"><span class="enumeration_section">9.7 </span>About Using the FOR Clause
               </h3>
               <div>
                  <p>You can use the optional FOR clause to set the number of array elements processed by any of the following SQL statements:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DELETE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">EXECUTE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">FETCH</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">INSERT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OPEN</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                  </ul>
                  <p><a id="d70073e1069" class="indexterm-anchor"></a>The <code class="codeph">FOR</code> clause is especially useful in <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, and <code class="codeph">DELETE</code> statements. With these statements, you might not want to use the entire array. The <code class="codeph">FOR</code> clause lets you limit the elements used to just the number you need, as the following <a id="d70073e1088" class="indexterm-anchor"></a>example shows:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_name (100) CHARACTER(20);
 salary (100) REAL;
 rows_to_insert INTEGER;
EXEC SQL END DECLARE SECTION;
-- populate the host arrays
set rows_to_insert = 25; -- set FOR-clause variable
EXEC SQL FOR :rows_to_insert -- will process only 25 rows
 INSERT INTO EMP (ENAME, SAL)
 VALUES (:emp_name, :salary);
</pre><p>The <code class="codeph">FOR</code> clause must use an integer host variable to count array elements. For example, the following statement is illegal:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR 25 -- illegal
 INSERT INTO EMP (ENAME, EMPNO, SAL)
 VALUES (:emp_name, :emp_number, :salary);
</pre><p><a id="d70073e1103" class="indexterm-anchor"></a>The <code class="codeph">FOR</code>-clause variable specifies the number of array elements to be processed. Make sure the number does not exceed the smallest array dimension. Also, the number must be positive. If it is negative or zero, no rows are processed.
                  </p>
               </div><a id="ZZPRE863"></a><div class="props_rev_3"><a id="GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77" name="GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77"></a><h4 id="ZZPRE-GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77" class="sect4"><span class="enumeration_section">9.7.1 </span>Restrictions
                  </h4>
                  <div>
                     <p><a id="d70073e1132" class="indexterm-anchor"></a>Two restrictions keep <code class="codeph">FOR</code> clause semantics clear.: You cannot use the FOR clause in a <code class="codeph">SELECT</code> statement or with the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause.
                     </p>
                  </div>
               </div><a id="ZZPRE864"></a><div class="props_rev_3"><a id="GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B" name="GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B"></a><h4 id="ZZPRE-GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B" class="sect4"><span class="enumeration_section">9.7.2 </span>In a SELECT Statement
                  </h4>
                  <div>
                     <p>If you use the <code class="codeph">FOR</code> clause in a <code class="codeph">SELECT</code> statement, you get the following error message:
                     </p><pre class="oac_no_warn" dir="ltr">PCC-E-0056: FOR clause not allowed on SELECT statement at ...
</pre><p>The <code class="codeph">FOR</code> clause is not allowed in <code class="codeph">SELECT</code> statements because its meaning is unclear. Does it mean "execute this <code class="codeph">SELECT</code> statement <span class="italic">n</span> times"? Or, does it mean "execute this <code class="codeph">SELECT</code> statement once, but return <span class="italic">n</span> rows"? The problem in the former case is that each execution might return multiple rows. In the latter case, it is better to declare a cursor and use the <code class="codeph">FOR</code> clause in a <code class="codeph">FETCH</code> statement, as follows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR :limit FETCH emp_cursor INTO ...</pre></div>
               </div><a id="ZZPRE865"></a><div class="props_rev_3"><a id="GUID-EA2ABB98-5595-42E0-B111-75AABABE5085" name="GUID-EA2ABB98-5595-42E0-B111-75AABABE5085"></a><h4 id="ZZPRE-GUID-EA2ABB98-5595-42E0-B111-75AABABE5085" class="sect4"><span class="enumeration_section">9.7.3 </span>With the CURRENT OF Clause
                  </h4>
                  <div>
                     <p>You can use the <code class="codeph">CURRENT OF</code> clause in an <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code> statement to refer to the latest row returned by a <code class="codeph">FETCH</code> statement, as the following example shows:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT ENAME, SAL FROM EMP WHERE EMPNO = :emp_number;
...
EXEC SQL OPEN emp_cursor;
...
EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
...
EXEC SQL UPDATE EMP SET SAL = :new_salary
 WHERE CURRENT OF emp_cursor;
</pre><p>However, you cannot use the FOR clause with the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause. The following statements are invalid because the only logical value of <span class="italic">limit</span> is 1 (you can only update or delete the current row once):
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR :limit UPDATE EMP SET SAL = :new_salary
 WHERE CURRENT OF emp_cursor;
...
EXEC SQL FOR :limit DELETE FROM EMP
 WHERE CURRENT OF emp_cursor;
</pre></div>
               </div>
            </div><a id="ZZPRE866"></a><div class="props_rev_3"><a id="GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566" name="GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566"></a><h3 id="ZZPRE-GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566" class="sect3"><span class="enumeration_section">9.8 </span>About Using the WHERE Clause
               </h3>
               <div>
                  <p><a id="d70073e1285" class="indexterm-anchor"></a>Oracle treats a SQL statement containing host arrays of dimension <span class="italic">n</span> like the same SQL statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables (the individual array elements). The precompiler issues the following error message only when such treatment is ambiguous:
                  </p><pre class="oac_no_warn" dir="ltr">PCC-S-0055: Array &lt;name&gt; not allowed as bind variable at ...
</pre><p>For example, assuming the declarations</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 mgr_number (50) INTEGER;
 job_title (50) CHARACTER(20);
EXEC SQL END DECLARE SECTION;
</pre><p>it would be ambiguous if the statement</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT MGR INTO :mgr_number FROM EMP
 WHERE JOB = :job_title;
</pre><p>were treated like the imaginary statement</p><pre class="oac_no_warn" dir="ltr">FOR i = 1 TO 50
 SELECT MGR INTO :mgr_number[i] FROM EMP
 WHERE JOB = :job_title[i];
ENDFOR;
</pre><p>because multiple rows might meet the <code class="codeph">WHERE</code>-clause search condition, but only one output variable is available to receive data. Therefore, an error message is issued.
                  </p>
                  <p>However, it would not be ambiguous if the statement</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP SET MGR = :mgr_number
 WHERE EMPNO IN (SELECT EMPNO FROM EMP WHERE JOB = :job_title);
</pre><p>were treated like the imaginary statement</p><pre class="oac_no_warn" dir="ltr">FOR i = 1 TO 50
 UPDATE EMP SET MGR = :mgr_number[i]
 WHERE EMPNO IN
 (SELECT EMPNO FROM EMP WHERE JOB = :job_title[i]);
ENDFOR;
</pre><p>because there is a <span class="italic">mgr_number</span> in the <code class="codeph">SET</code> clause for each row matching <span class="italic">job_title</span> in the <code class="codeph">WHERE</code> clause, even if each <span class="italic">job_title</span> matches multiple rows. All rows matching each <span class="italic">job_title</span> can be <code class="codeph">SET</code> to the same <span class="italic">mgr_number</span>. So, no error message is issued.
                  </p>
               </div>
            </div><a id="ZZPRE867"></a><div class="props_rev_3"><a id="GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E" name="GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E"></a><h3 id="ZZPRE-GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E" class="sect3"><span class="enumeration_section">9.9 </span>About Mimicking the CURRENT OF Clause
               </h3>
               <div>
                  <p><a id="d70073e1376" class="indexterm-anchor"></a>You use the <code class="codeph">CURRENT OF</code> <span class="italic">cursor</span> clause in a <code class="codeph">DELETE</code> or <code class="codeph">UPDATE</code> statement to refer to the latest row fetched from the cursor. However, you cannot use <code class="codeph">CURRENT OF</code> with host arrays. Instead, select the <code class="codeph">ROWID</code> of each row, then use that value to identify the current row during the update or delete. An example follows:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_name (25) CHARACTER(20);
 job_title (25) CHARACTER(15);
 old_title (25) CHARACTER(15);
 row_id (25) CHARACTER(18);
EXEC SQL END DECLARE SECTION;
...
EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT ENAME, JOB, ROWID FROM EMP;
...
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND GOTO <span class="bold">...</span>
...
LOOP
 EXEC SQL FETCH emp_cursor
 INTO :emp_name, :job_title, :row_id;
 ...
 EXEC SQL DELETE FROM EMP
 WHERE JOB = :old_title AND ROWID = :row_id;
 EXEC SQL COMMIT WORK;
ENDLOOP;
</pre><p>However, the fetched rows are <span class="italic">not</span> locked because no <code class="codeph">FOR UPDATE OF</code> clause is used. So, you might get inconsistent results if another user changes a row after you read it but before you delete it.
                  </p>
                  <p></p>
               </div>
            </div><a id="ZZPRE868"></a><div class="props_rev_3"><a id="GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33" name="GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33"></a><h3 id="ZZPRE-GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33" class="sect3"><span class="enumeration_section">9.10 </span>About Using SQLERRD(3)
               </h3>
               <div>
                  <p><a id="d70073e1447" class="indexterm-anchor"></a>For<a id="d70073e1452" class="indexterm-anchor"></a> <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, and <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statements, SQLERRD(3) records the number of rows processed. For <a id="d70073e1473" class="indexterm-anchor"></a><code class="codeph">FETCH</code> statements, it records the cumulative sum of rows processed.
                  </p>
                  <p>When using host arrays with <code class="codeph">FETCH</code>, to find the number of rows returned by the most recent iteration, subtract the current value of SQLERRD(3) from its previous value (stored in another variable). In the following example, you determine the number of rows returned by the most recent fetch:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 emp_number (100) INTEGER;
 emp_name (100) CHARACTER(20);
EXEC SQL END DECLARE SECTION;
...
 rows_to fetch INTEGER;
 rows_before INTEGER;
 rows_this_time INTEGER;
...
EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT EMPNO, ENAME
 FROM EMP
 WHERE DEPTNO = 30;
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND CONTINUE;
...
-- initialize loop variables
set rows_to_fetch = 20; -- number of rows in each "batch"
set rows_before = 0; -- previous value of sqlerrd(3)
set rows_this_time = 20;
WHILE rows_this_time = rows_to_fetch
 LOOP
 EXEC SQL FOR :rows_to_fetch
 FETCH emp_cursor
 INTO :emp_number, :emp_name;
 set rows_this_time = sqlca.sqlerrd(3) - rows_before;
 set rows_before = sqlca.sqlerrd(3);
 ENDLOOP;
ENDWHILE;
</pre><p>SQLERRD(3) is also useful when an error occurs during an array operation. Processing stops at the row that caused the error, so SQLERRD(3) gives the number of rows processed successfully.</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>