<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle Database provides several optimizations for joining row sets.">
      <meta name="description" content="Oracle Database provides several optimizations for joining row sets.">
      <title>Joins</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQL Tuning Guide">
      <meta property="og:description" content="Oracle Database provides several optimizations for joining row sets.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQL Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00">
      <meta name="dcterms.title" content="SQL Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2013, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96095-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="optimizer-access-paths.html" title="Previous" type="text/html">
      <link rel="next" href="optimizer-statistics.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="optimizer-access-paths.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="optimizer-statistics.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="sql-operators.html" property="item" typeof="WebPage"><span property="name">SQL Operators: Access Paths and Joins</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Joins</li>
            </ol>
            <a id="GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" name="GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A"></a><a id="TGSQL242"></a>
            
            <h2 id="TGSQL-GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" class="sect2"><span class="enumeration_chapter">9 </span>Joins
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Database provides several optimizations for joining row sets.</p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81">About Joins</a><br>A <strong class="term">join</strong> combines the output from exactly two row sources, such as tables or views, and returns one row source. The returned row source is the data set.
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D">Join Methods</a><br>A join method is the mechanism for joining two row sources.
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9">Join Types</a><br>A join type is determined by the type of join condition. 
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1">Join Optimizations</a><br>Join optimizations enable joins to be more efficient.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="sql-operators.html#GUID-37BA8AC8-B8F5-402E-8398-552AFDACED8E" title="A row source is a set of rows returned by a step in the execution plan. A SQL operator acts on a row source.">SQL Operators: Access Paths and Joins</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL95231"></a><div class="props_rev_3"><a id="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" name="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81"></a><h3 id="TGSQL-GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" class="sect3"><span class="enumeration_section">9.1 </span>About Joins
               </h3>
               <div>
                  <p>A <strong class="term">join</strong> combines the output from exactly two row sources, such as tables or views, and returns one row source. The returned row source is the data set.
                  </p>
                  <p>A join is characterized by multiple tables in the <code class="codeph">WHERE</code> (non-ANSI) or <code class="codeph">FROM ... JOIN</code> (ANSI) clause of a SQL statement. Whenever multiple tables exist in the <code class="codeph">FROM</code> clause, Oracle Database performs a join.
                  </p>
                  <p>A <a href="glossary.html#GUID-F2A09892-D404-46BD-82B1-3DB0BC286FE2"><span class="xrefglossterm">join condition</span></a> compares two row sources using an expression. The join condition defines the relationship between the tables. If the statement does not specify a join condition, then the database performs a Cartesian join, matching every row in one table with every row in the other table.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C">Join Trees</a><br>Typically, a join tree is represented as an upside-down tree structure.
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B">How the Optimizer Executes Join Statements</a><br>The database joins pairs of row sources. When multiple tables exist in the <code class="codeph">FROM</code> clause, the optimizer must determine which join operation is most efficient for each pair. 
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-8621DCD7-6F70-4720-8049-BA630B58F26C">How the Optimizer Chooses Execution Plans for Joins</a><br>When determining the join order and method, the optimizer goal is to reduce the number of rows early so it performs less work throughout the execution of the SQL statement.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81__GUID-C7FD3549-3901-4564-AA97-5D665CFB40B8">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="The database uses a Cartesian join when one or more of the tables does not have any join conditions to any other tables in the statement.">Cartesian Joins</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF30046" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for a concise discussion of joins in Oracle SQL
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle Database provides several optimizations for joining row sets.">Joins</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95346"></a><a id="TGSQL95347"></a><a id="TGSQL95348"></a><a id="TGSQL95349"></a><a id="TGSQL95345"></a><div class="props_rev_3"><a id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C" name="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C"></a><h4 id="TGSQL-GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C" class="sect4"><span class="enumeration_section">9.1.1 </span>Join Trees
                  </h4>
                  <div>
                     <p>Typically, a join tree is represented as an upside-down tree structure.</p>
                     <p>As shown in the following graphic, <code class="codeph">table1</code> is the left table, and <code class="codeph">table2</code> is the right table. The optimizer processes the join from left to right. For example, if this graphic depicted a nested loops join, then <code class="codeph">table1</code> is the outer loop, and <code class="codeph">table2</code> is the inner loop.
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABEFJII">
                        <p class="titleinfigure">Figure 9-1 Join Tree</p><img src="img/tgsql_vm_086.png" alt="Description of Figure 9-1 follows" title="Description of Figure 9-1 follows" longdesc="img_text/tgsql_vm_086.html"><br><a href="img_text/tgsql_vm_086.html">Description of "Figure 9-1 Join Tree"</a></div>
                     <!-- class="figure" -->
                     <p>The input of a join can be the result set from a previous join. If the right child of every internal node of a join tree is a table, then the tree is a <a href="glossary.html#GUID-5697281B-74F7-4AF2-A73F-3CC1A96EA947"><span class="xrefglossterm">left deep join tree</span></a>, as shown in the following example. Most join trees are left deep joins.
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABFJDCH">
                        <p class="titleinfigure">Figure 9-2 Left Deep Join Tree</p><img src="img/tgsql_vm_087.png" alt="Description of Figure 9-2 follows" title="Description of Figure 9-2 follows" longdesc="img_text/tgsql_vm_087.html"><br><a href="img_text/tgsql_vm_087.html">Description of "Figure 9-2 Left Deep Join Tree"</a></div>
                     <!-- class="figure" -->
                     <p>If the left child of every internal node of a join tree is a table, then the tree is called a <a href="glossary.html#GUID-E01EE140-6652-4697-B257-C07148045B25"><span class="xrefglossterm">right deep join tree</span></a>, as shown in the following diagram. 
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABHFGHB">
                        <p class="titleinfigure">Figure 9-3 Right Deep Join Tree</p><img src="img/tgsql_vm_088.png" alt="Description of Figure 9-3 follows" title="Description of Figure 9-3 follows" longdesc="img_text/tgsql_vm_088.html"><br><a href="img_text/tgsql_vm_088.html">Description of "Figure 9-3 Right Deep Join Tree"</a></div>
                     <!-- class="figure" -->
                     <p>If the left or the right child of an internal node of a join tree can be a join node, then the tree is called a <a href="glossary.html#GUID-4E921FAD-0F1B-47E7-A1A4-EAAAD5E043AB"><span class="xrefglossterm">bushy join tree</span></a>. In the following example, <code class="codeph">table4</code> is a right child of a join node, <code class="codeph">table1</code> is the left child of a join node, and <code class="codeph">table2</code> is the left child of a join node.
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABCEGEI">
                        <p class="titleinfigure">Figure 9-4 Bushy Join Tree</p><img src="img/tgsql_vm_089.png" alt="Description of Figure 9-4 follows" title="Description of Figure 9-4 follows" longdesc="img_text/tgsql_vm_089.html"><br><a href="img_text/tgsql_vm_089.html">Description of "Figure 9-4 Bushy Join Tree"</a></div>
                     <!-- class="figure" -->
                     <p>In yet another variation, both inputs of a join are the results of a previous join.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="A join combines the output from exactly two row sources, such as tables or views, and returns one row source. The returned row source is the data set.">About Joins</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94679"></a><div class="props_rev_3"><a id="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B" name="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B"></a><h4 id="TGSQL-GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B" class="sect4"><span class="enumeration_section">9.1.2 </span>How the Optimizer Executes Join Statements
                  </h4>
                  <div>
                     <p>The database joins pairs of row sources. When multiple tables exist in the <code class="codeph">FROM</code> clause, the optimizer must determine which join operation is most efficient for each pair. 
                     </p>
                     <p>The optimizer must make the interrelated decisions shown in the following table.</p>
                     <div class="tblformal" id="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B__GUID-26201563-907F-4948-9AC3-BAFAAB89292C">
                        <p class="titleintable">Table 9-1 Join Operations</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Join Operations" summary="This table describes operations that the optimizer uses to join tables." frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d49855e667">Operation</th>
                                 <th align="left" valign="bottom" width="20%" id="d49855e669">Explanation</th>
                                 <th align="left" valign="bottom" width="20%" id="d49855e671">To Learn More</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e675" headers="d49855e667 ">
                                    <p>Access paths </p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e675 d49855e669 ">
                                    <p>As for simple statements, the optimizer must choose an <a href="glossary.html#GUID-22DF198C-4310-4307-BF29-DCE765725BD4"><span class="xrefglossterm">access path</span></a> to retrieve data from each table in the join statement. For example, the optimizer might choose between a full table scan or an index scan..
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e675 d49855e671 ">
                                    <p><span class="q">"<a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e696" headers="d49855e667 ">
                                    <p>Join methods</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e696 d49855e669 ">
                                    <p>To join each pair of row sources, Oracle Database must decide how to do it. The "how" is the join method. The possible join methods are nested loop, sort merge, and hash joins. A Cartesian join requires one of the preceding join methods. Each join method has specific situations in which it is more suitable than the others.</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e696 d49855e671 "> 
                                    <p><span class="q">"<a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="A join method is the mechanism for joining two row sources.">Join Methods</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e712" headers="d49855e667 ">
                                    <p>Join types</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e712 d49855e669 ">
                                    <p>The join condition determines the join type. For example, an inner join retrieves only rows that match the join condition. An outer join retrieves rows that do not match the join condition.</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e712 d49855e671 "><span class="q">"<a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a>"</span></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e726" headers="d49855e667 ">
                                    <p>Join order</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e726 d49855e669 ">
                                    <p>To execute a statement that joins more than two tables, Oracle Database joins two tables and then joins the resulting row source to the next table. This process continues until all tables are joined into the result. For example, the database joins two tables, and then joins the result to a third table, and then joins this result to a fourth table, and so on.</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e726 d49855e671 ">N/A</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="A join combines the output from exactly two row sources, such as tables or views, and returns one row source. The returned row source is the data set.">About Joins</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94680"></a><div class="props_rev_3"><a id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C" name="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C"></a><h4 id="TGSQL-GUID-8621DCD7-6F70-4720-8049-BA630B58F26C" class="sect4"><span class="enumeration_section">9.1.3 </span>How the Optimizer Chooses Execution Plans for Joins
                  </h4>
                  <div>
                     <p>When determining the join order and method, the optimizer goal is to reduce the number of rows early so it performs less work throughout the execution of the SQL statement.</p>
                     <p>The optimizer generates a set of execution plans, according to possible join orders, join methods, and available access paths. The optimizer then estimates the cost of each plan and chooses the one with the lowest cost. When choosing an execution plan, the optimizer considers the following factors: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The optimizer first determines whether joining two or more tables results in a row source containing at most one row.</p>
                           <p>The optimizer recognizes such situations based on <code class="codeph">UNIQUE</code> and <code class="codeph">PRIMARY KEY</code> constraints on the tables. If such a situation exists, then the optimizer places these tables first in the join order. The optimizer then optimizes the join of the remaining set of tables. 
                           </p>
                        </li>
                        <li>
                           <p>For join statements with <a href="glossary.html#GUID-733FE231-0E7E-41AD-B5E0-ACA84B92FC6F"><span class="xrefglossterm">outer join</span></a> conditions, the table with the outer join operator typically comes after the other table in the condition in the join order. 
                           </p>
                           <p>In general, the optimizer does not consider join orders that violate this guideline, although the optimizer overrides this ordering condition in certain circumstances. Similarly, when a subquery has been converted into an <a href="glossary.html#GUID-4EF44AED-32FD-4FF4-9ECB-24F0011A667E"><span class="xrefglossterm">antijoin</span></a> or <a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">semijoin</span></a>, the tables from the subquery must come after those tables in the outer query block to which they were connected or correlated. However, hash antijoins and semijoins are able to override this ordering condition in certain circumstances.
                           </p>
                        </li>
                     </ul>
                     <p>The optimizer estimates the cost of a query plan by computing the estimated I/Os and CPU. These I/Os have specific costs associated with them: one cost for a single block I/O, and another cost for multiblock I/Os. Also, different functions and expressions have CPU costs associated with them. The optimizer determines the total cost of a query plan using these metrics. These metrics may be influenced by many initialization parameter and session settings at compile time, such as the <code class="codeph">DB_FILE_MULTI_BLOCK_READ_COUNT</code> setting, system statistics, and so on.
                     </p>
                     <p>For example, the optimizer estimates costs in the following ways: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The cost of a <a href="glossary.html#GUID-51D8DCA1-3607-46E0-AD38-388EC50273D0"><span class="xrefglossterm">nested loops join</span></a> depends on the cost of reading each selected row of the <a href="glossary.html#GUID-5BAB6F1F-5D4C-4EDA-8F59-D97A75D4254C"><span class="xrefglossterm">outer table</span></a> and each of its matching rows of the <a href="glossary.html#GUID-95EF749F-18E4-47A5-9B8F-AD39A722FAB4"><span class="xrefglossterm">inner table</span></a> into memory. The optimizer estimates these costs using statistics in the data dictionary. 
                           </p>
                        </li>
                        <li>
                           <p>The cost of a <a href="glossary.html#GUID-2A7F42FE-2859-4B9C-83AD-EFF8FFB4AB92"><span class="xrefglossterm">sort merge join</span></a> depends largely on the cost of reading all the sources into memory and sorting them.
                           </p>
                        </li>
                        <li>
                           <p>The cost of a <a href="glossary.html#GUID-FF45796B-8A90-45C6-8A40-0B308B72AF7C"><span class="xrefglossterm">hash join</span></a> largely depends on the cost of building a hash table on one of the input sides to the join and using the rows from the other side of the join to probe it.
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-DEB39775-CCE8-40FF-ADB4-77984F7B0B33">
                        <p class="titleinexample">Example 9-1 Estimating Costs for Join Order and Method</p>
                        <p>Conceptually, the optimizer constructs a matrix of join orders and methods and the cost associated with each. For example, the optimizer must determine how best to join the <code class="codeph">date_dim</code> and <code class="codeph">lineorder</code> tables in a query. The following table shows the possible variations of methods and orders, and the cost for each. In this example, a nested loops join in the order <code class="codeph">date_dim</code>, <code class="codeph">lineorder</code> has the lowest cost.
                        </p>
                        <div class="tblformal" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-A80577B8-94A1-45C0-8378-8FE440FBE1BD">
                           <p class="titleintable">Table 9-2 Sample Costs for Join of date_dim and lineorder Tables</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Sample Costs for Join of date_dim and lineorder Tables" summary="Join methods and orders" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e980">Join Method</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e982">Cost of date_dim, lineorder</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e984">Cost of lineorder, date_dim</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e988" headers="d49855e980 ">Nested Loops</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e988 d49855e982 ">39,480</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e988 d49855e984 ">6,187,540</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e995" headers="d49855e980 ">Hash Join</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e995 d49855e982 ">187,528</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e995 d49855e984 ">194,909</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e1002" headers="d49855e980 ">Sort Merge</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e1002 d49855e982 ">217,129</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e1002 d49855e984 ">217,129</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-4C2292DA-1C6A-43EF-8CCE-45E0612529DE">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="optimizer-statistics-concepts.html#GUID-AEE74FB8-98BD-416B-8EA0-32CD605DF64E" title="The optimizer cost model relies on statistics collected about the objects involved in a query, and the database and host where the query runs.">Introduction to Optimizer Statistics</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-8758EF88-1CC6-41BD-8581-246702414D1D" title="Optimizer defaults are adequate for most operations, but not all.">Influencing the Optimizer</a>"</span> for more information about optimizer hints
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=REFRN10037" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="A join combines the output from exactly two row sources, such as tables or views, and returns one row source. The returned row source is the data set.">About Joins</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL95333"></a><a id="TGSQL95232"></a><div class="props_rev_3"><a id="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" name="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D"></a><h3 id="TGSQL-GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" class="sect3"><span class="enumeration_section">9.2 </span>Join Methods
               </h3>
               <div>
                  <p>A join method is the mechanism for joining two row sources.</p>
                  <p>Depending on the statistics, the optimizer chooses the method with the lowest estimated cost. As shown in <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D__BABHDGDJ">Figure 9-5</a>, each join method has two children: the driving (also called <span class="italic">outer</span>) row source and the driven-to (also called <span class="italic">inner</span>) row source. 
                  </p>
                  <div class="figure" id="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D__BABHDGDJ">
                     <p class="titleinfigure">Figure 9-5 Join Method</p><img src="img/tgsql_vm_080.png" alt="Description of Figure 9-5 follows" title="Description of Figure 9-5 follows" longdesc="img_text/tgsql_vm_080.html"><br><a href="img_text/tgsql_vm_080.html">Description of "Figure 9-5 Join Method"</a></div>
                  <!-- class="figure" -->
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53">Nested Loops Joins</a><br>Nested loops join an outer data set to an inner data set. 
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB">Hash Joins</a><br>The database uses a <strong class="term">hash join</strong> to join larger data sets.
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F">Sort Merge Joins</a><br>A sort merge join is a variation on a nested loops join.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle Database provides several optimizations for joining row sets.">Joins</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL244"></a><div class="props_rev_3"><a id="GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" name="GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53"></a><h4 id="TGSQL-GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" class="sect4"><span class="enumeration_section">9.2.1 </span>Nested Loops Joins
                  </h4>
                  <div>
                     <p>Nested loops join an outer data set to an inner data set. </p>
                     <p>For each row in the outer data set that matches the single-table predicates, the database retrieves all rows in the inner data set that satisfy the join predicate. If an index is available, then the database can use it to access the inner data set by rowid.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653">When the Optimizer Considers Nested Loops Joins</a><br>Nested loops joins are useful when the database joins small subsets of data,  the database joins large sets of data with the optimizer mode set to <code class="codeph">FIRST_ROWS</code>, or the join condition is an efficient method of accessing the inner table.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3">How Nested Loops Joins Work</a><br>Conceptually, nested loops are equivalent to two nested <code class="codeph">for</code> loops.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49">Nested Nested Loops</a><br>The outer loop of a nested loop can itself be a row source generated by a different nested loop. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D83585A7-4ADB-48C9-958E-693374BF7A31">Current Implementation for Nested Loops Joins</a><br><span>Oracle Database 11g</span> introduced a new implementation for nested loops that reduces overall latency for physical I/O.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04">Original Implementation for Nested Loops Joins</a><br>In the current release, both the new and original implementation of nested loops are possible.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7">Nested Loops Controls</a><br>For some SQL statements, the data is small enough for the optimizer to prefer full table scans and hash joins. However, you can add the <code class="codeph">USE_NL</code> hint to instruct the optimizer to join each specified table to another row source with a nested loops join, using the specified table as the inner table.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="A join method is the mechanism for joining two row sources.">Join Methods</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94684"></a><div class="props_rev_3"><a id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653" name="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653"></a><h5 id="TGSQL-GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653" class="sect5"><span class="enumeration_section">9.2.1.1 </span>When the Optimizer Considers Nested Loops Joins
                     </h5>
                     <div>
                        <p>Nested loops joins are useful when the database joins small subsets of data,  the database joins large sets of data with the optimizer mode set to <code class="codeph">FIRST_ROWS</code>, or the join condition is an efficient method of accessing the inner table.
                        </p>
                        <div class="infoboxnote" id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653__GUID-A099DD62-0329-4A98-BAA6-962FCB87EB36">
                           <p class="notep1">Note:</p>
                           <p>The number of rows expected from the join is what drives the optimizer decision, not the size of the underlying tables. For example, a query might join two tables of a billion rows each, but because of the filters the optimizer expects data sets of 5 rows each.</p>
                        </div>
                        <p>In general, nested loops joins work best on small tables with indexes on the join conditions. If a row source has only one row, as with an equality lookup on a primary key value (for example, <code class="codeph">WHERE employee_id=101</code>), then the join is a simple lookup. The optimizer always tries to put the smallest row source first, making it the driving table.
                        </p>
                        <p>Various factors enter into the optimizer decision to use nested loops. For example, the database may read several rows from the outer row source in a batch. Based on the number of rows retrieved, the optimizer may choose either a nested loop or a hash join to the inner row source. For example, if a query joins <code class="codeph">departments</code> to driving table <code class="codeph">employees</code>, and if the predicate specifies a value in <code class="codeph">employees.last_name</code>, then the database might read enough entries in the index on <code class="codeph">last_name</code> to determine whether an internal threshold is passed. If the threshold is not passed, then the optimizer picks a nested loop join to <code class="codeph">departments</code>, and if the threshold is passed, then the database performs a hash join, which means reading the rest of <code class="codeph">employees</code>, hashing it into memory, and then joining to <code class="codeph">departments</code>.
                        </p>
                        <p>If the access path for the inner loop is not dependent on the outer loop, then the result can be a Cartesian product: for every iteration of the outer loop, the inner loop produces the same set of rows. To avoid this problem, use other join methods to join two independent row sources.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653__GUID-CCDCEB37-F4A2-41E6-88B7-347542DCB940">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-C1C85DEA-3583-40FE-B5BB-6AC8F76FFE34__BBAIEADC" title="This two-column table describes initialization parameters that control optimizer behavior. Column 1 is the parameter. Column 2 describes that parameter.">Table 19-2</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="An adaptive query plan enables the optimizer to make a plan decision for a statement during execution.">Adaptive Query Plans</a>"</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95233"></a><div class="props_rev_3"><a id="GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3" name="GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3"></a><h5 id="TGSQL-GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3" class="sect5"><span class="enumeration_section">9.2.1.2 </span>How Nested Loops Joins Work
                     </h5>
                     <div>
                        <p>Conceptually, nested loops are equivalent to two nested <code class="codeph">for</code> loops.
                        </p>
                        <p> For example, if a query joins <code class="codeph">employees</code> and <code class="codeph">departments</code>, then a nested loop in pseudocode might be:
                        </p><pre class="pre codeblock"><code>FOR erow IN (select * from employees where X=Y) LOOP
  FOR drow IN (select * from departments where erow is matched) LOOP
    output values from erow and drow
  END LOOP
END LOOP
</code></pre><p>The inner loop is executed for every row of the outer loop. The <code class="codeph">employees</code> table is the "outer" data set because it is in the exterior <code class="codeph">for</code> loop. The outer table is sometimes called a driving table. The <code class="codeph">departments</code> table is the "inner" data set because it is in the interior <code class="codeph">for</code> loop.
                        </p>
                        <p>A nested loops join involves the following basic steps:</p>
                        <ol>
                           <li>
                              <p>The optimizer determines the driving row source and designates it as the outer loop.</p>
                              <p>The outer loop produces a set of rows for driving the join condition. The row source can be a table accessed using an index scan, a full table scan, or any other operation that generates rows. </p>
                              <p>The number of iterations of the inner loop depends on the number of rows retrieved in the outer loop. For example, if 10 rows are retrieved from the outer table, then the database must perform 10 lookups in the inner table. If 10,000,000 rows are retrieved from the outer table, then the database must perform 10,000,000 lookups in the inner table.</p>
                           </li>
                           <li>
                              <p>The optimizer designates the other row source as the inner loop.</p>
                              <p>The outer loop appears before the inner loop in the execution plan, as follows:</p><pre class="pre codeblock"><code>NESTED LOOPS 
  <span class="italic">outer_loop</span>
  <span class="italic">inner_loop</span> 
</code></pre></li>
                           <li>
                              <p>For every fetch request from the client, the basic process is as follows:</p>
                              <ol type="a">
                                 <li>
                                    <p>Fetch a row from the outer row source</p>
                                 </li>
                                 <li>
                                    <p>Probe the inner row source to find rows that match the predicate criteria</p>
                                 </li>
                                 <li>
                                    <p>Repeat the preceding steps until all rows are obtained by the fetch request</p>
                                 </li>
                              </ol>
                              <p>Sometimes the database sorts rowids to obtain a more efficient buffer access pattern.</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95235"></a><a id="TGSQL95234"></a><div class="props_rev_3"><a id="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49" name="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49"></a><h5 id="TGSQL-GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49" class="sect5"><span class="enumeration_section">9.2.1.3 </span>Nested Nested Loops
                     </h5>
                     <div>
                        <p>The outer loop of a nested loop can itself be a row source generated by a different nested loop. </p>
                        <p>The database can nest two or more outer loops to join as many tables as needed. Each loop is a data access method. The following template shows how the database iterates through three nested loops:</p><pre class="pre codeblock"><code>SELECT STATEMENT
  NESTED LOOPS 3
    NESTED LOOPS 2          - Row source becomes OUTER LOOP 3.1
      NESTED LOOPS 1        - Row source becomes OUTER LOOP 2.1
        OUTER LOOP 1.1
        INNER LOOP 1.2  
      INNER LOOP 2.2
    INNER LOOP 3.2
</code></pre><p>The database orders the loops as follows:</p>
                        <ol>
                           <li>
                              <p>The database iterates through <code class="codeph">NESTED LOOPS 1</code>:
                              </p><pre class="pre codeblock"><code>NESTED LOOPS 1 
  OUTER LOOP 1.1
  INNER LOOP 1.2
</code></pre><p>The output of <code class="codeph">NESTED LOOP 1</code> is a row source.
                              </p>
                           </li>
                           <li>
                              <p>The database iterates through <code class="codeph">NESTED LOOPS 2</code>, using the row source generated by <code class="codeph">NESTED LOOPS 1</code> as its outer loop:
                              </p><pre class="pre codeblock"><code>NESTED LOOPS 2       
  OUTER LOOP 2.1         - Row source generated by NESTED LOOPS 1
  INNER LOOP 2.2 
</code></pre><p>The output of <code class="codeph">NESTED LOOPS 2</code> is another row source.
                              </p>
                           </li>
                           <li>
                              <p>The database iterates through <code class="codeph">NESTED LOOPS 3</code>, using the row source generated by <code class="codeph">NESTED LOOPS 2</code> as its outer loop:
                              </p><pre class="pre codeblock"><code>NESTED LOOPS 3      
  OUTER LOOP 3.1         - Row source generated by NESTED LOOPS 2
  INNER LOOP 3.2</code></pre></li>
                        </ol>
                        <div class="example" id="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49__GUID-6BFCCF64-A370-435C-922D-AB5238017267">
                           <p class="titleinexample">Example 9-2 Nested Nested Loops Join</p>
                           <p>Suppose you join the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables as follows:
                           </p><pre class="pre codeblock"><code>SELECT /*+ ORDERED USE_NL(d) */ e.last_name, e.first_name, d.department_name
FROM   employees e, departments d
WHERE  e.department_id=d.department_id
AND    e.last_name like 'A%';
</code></pre><p>The plan reveals that the optimizer chose two nested loops (Step 1 and Step 2) to access the data:</p><pre class="pre codeblock"><code>SQL_ID  ahuavfcv4tnz4, child number 0
-------------------------------------
SELECT /*+ ORDERED USE_NL(d) */ e.last_name, d.department_name FROM
employees e, departments d WHERE  e.department_id=d.department_id AND
 e.last_name like 'A%'
 
Plan hash value: 1667998133
 
----------------------------------------------------------------------------------
|Id| Operation                             |Name      |Rows|Bytes|Cost(%CPU)|Time|
----------------------------------------------------------------------------------
| 0| SELECT STATEMENT                      |             |  |   |5 (100)|        |
| 1|  NESTED LOOPS                         |             |  |   |       |        |
| 2|   NESTED LOOPS                        |             | 3|102|5   (0)|00:00:01|
| 3|    TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES   | 3| 54|2   (0)|00:00:01|
|*4|     INDEX RANGE SCAN                  | EMP_NAME_IX | 3|   |1   (0)|00:00:01|
|*5|    INDEX UNIQUE SCAN                  | DEPT_ID_PK  | 1|   |0   (0)|        |
| 6|   TABLE ACCESS BY INDEX ROWID         | DEPARTMENTS | 1| 16|1   (0)|00:00:01|
----------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("E"."LAST_NAME" LIKE 'A%')
       filter("E"."LAST_NAME" LIKE 'A%')
   5 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>In this example, the basic process is as follows:</p>
                           <ol>
                              <li>
                                 <p>The database begins iterating through the inner nested loop (Step 2) as follows:</p>
                                 <ol type="a">
                                    <li>
                                       <p>The database searches the <code class="codeph">emp_name_ix</code> for the rowids for all last names that begins with <code class="codeph">A</code> (Step 4). 
                                       </p>
                                       <p>For example:</p><pre class="pre codeblock"><code>Abel,employees_rowid
Ande,employees_rowid
Atkinson,employees_rowid
Austin,employees_rowid
</code></pre></li>
                                    <li>
                                       <p>Using the rowids from the previous step, the database retrieves a batch of rows from the <code class="codeph">employees</code> table (Step 3). For example:
                                       </p><pre class="pre codeblock"><code>Abel,Ellen,80
Abel,John,50
</code></pre><p>These rows become the outer row source for the innermost nested loop. </p>
                                       <p>The batch step is typically part of adaptive execution plans. To determine whether a nested loop is better than a hash join, the optimizer needs to determine many rows come back from the row source. If too many rows are returned, then the optimizer switches to a different join method.</p>
                                    </li>
                                    <li>
                                       <p>For each row in the outer row source, the database scans the <code class="codeph">dept_id_pk</code> index to obtain the rowid in <code class="codeph">departments</code> of the matching department ID (Step 5), and joins it to the <code class="codeph">employees</code> rows. For example:
                                       </p><pre class="pre codeblock"><code>Abel,Ellen,80,departments_rowid
Ande,Sundar,80,departments_rowid
Atkinson,Mozhe,50,departments_rowid
Austin,David,60,departments_rowid
</code></pre><p>These rows become the outer row source for the outer nested loop (Step 1).</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>The database iterates through the outer nested loop as follows:</p>
                                 <ol type="a">
                                    <li>
                                       <p>The database reads the first row in outer row source.</p>
                                       <p>For example:</p><pre class="pre codeblock"><code>Abel,Ellen,80,departments_rowid
</code></pre></li>
                                    <li>
                                       <p>The database uses the <code class="codeph">departments</code> rowid to retrieve the corresponding row from <code class="codeph">departments</code> (Step 6), and then joins the result to obtain the requested values (Step 1).
                                       </p>
                                       <p>For example:</p><pre class="pre codeblock"><code>Abel,Ellen,80,Sales
</code></pre></li>
                                    <li>
                                       <p>The database reads the next row in the outer row source, uses the <code class="codeph">departments</code> rowid to retrieve the corresponding row from <code class="codeph">departments</code> (Step 6), and iterates through the loop until all rows are retrieved.
                                       </p>
                                       <p>The result set has the following form:</p><pre class="pre codeblock"><code>Abel,Ellen,80,Sales
Ande,Sundar,80,Sales
Atkinson,Mozhe,50,Shipping
Austin,David,60,IT</code></pre></li>
                                 </ol>
                              </li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94683"></a><div class="props_rev_3"><a id="GUID-D83585A7-4ADB-48C9-958E-693374BF7A31" name="GUID-D83585A7-4ADB-48C9-958E-693374BF7A31"></a><h5 id="TGSQL-GUID-D83585A7-4ADB-48C9-958E-693374BF7A31" class="sect5"><span class="enumeration_section">9.2.1.4 </span>Current Implementation for Nested Loops Joins
                     </h5>
                     <div>
                        <p><span>Oracle Database 11g</span> introduced a new implementation for nested loops that reduces overall latency for physical I/O.
                        </p>
                        <p>When an index or a table block is not in the buffer cache and is needed to process the join, a physical I/O is required. The database can batch multiple physical I/O requests and process them using a vector I/O (array) instead of one at a time. The database sends an array of rowids to the operating system, which performs the read.</p>
                        <p>As part of the new implementation, two <code class="codeph">NESTED LOOPS</code> join row sources might appear in the execution plan where only one would have appeared in prior releases. In such cases, Oracle Database allocates one <code class="codeph">NESTED LOOPS</code> join row source to join the values from the table on the outer side of the join with the index on the inner side. A second row source is allocated to join the result of the first join, which includes the rowids stored in the index, with the table on the inner side of the join.
                        </p>
                        <p>Consider the query in <span class="q">"<a href="joins.html#GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" title="In the current release, both the new and original implementation of nested loops are possible.">Original Implementation for Nested Loops Joins</a>"</span>. In the current implementation, the execution plan for this query might be as follows:
                        </p><pre class="pre codeblock"><code>-------------------------------------------------------------------------------------
| Id | Operation                    | Name              |Rows|Bytes|Cost%CPU| Time  |
-------------------------------------------------------------------------------------
|  0 | SELECT STATEMENT             |                   | 19 | 722 |  3 (0)|00:00:01|
|  1 |  NESTED LOOPS                |                   |    |     |       |        |
|  2 |   NESTED LOOPS               |                   | 19 | 722 |  3 (0)|00:00:01|
|* 3 |    TABLE ACCESS FULL         | DEPARTMENTS       |  2 |  32 |  2 (0)|00:00:01|
|* 4 |    INDEX RANGE SCAN          | EMP_DEPARTMENT_IX | 10 |     |  0 (0)|00:00:01|
|  5 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES         | 10 | 220 |  1 (0)|00:00:01|
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("D"."DEPARTMENT_NAME"='Marketing' OR "D"."DEPARTMENT_NAME"='Sales')
   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>In this case, rows from the <code class="codeph">hr.departments</code> table form the outer row source (Step 3) of the inner nested loop (Step 2). The index <code class="codeph">emp_department_ix</code> is the inner row source (Step 4) of the inner nested loop. The results of the inner nested loop form the outer row source (Row 2) of the outer nested loop (Row 1). The <code class="codeph">hr.employees</code> table is the outer row source (Row 5) of the outer nested loop.
                        </p>
                        <p>For each fetch request, the basic process is as follows:</p>
                        <ol>
                           <li>
                              <p>The database iterates through the inner nested loop (Step 2) to obtain the rows requested in the fetch:</p>
                              <ol type="a">
                                 <li>
                                    <p>The database reads the first row of <code class="codeph">departments</code> to obtain the department IDs for departments named <code class="codeph">Marketing</code> or <code class="codeph">Sales</code> (Step 3). For example:
                                    </p><pre class="pre codeblock"><code>Marketing,20
</code></pre><p>This row set is the outer loop. The database caches the data in the PGA.</p>
                                 </li>
                                 <li>
                                    <p>The database scans <code class="codeph">emp_department_ix</code>, which is an index on the <code class="codeph">employees</code> table, to find <code class="codeph">employees</code> rowids that correspond to this department ID (Step 4), and then joins the result (Step 2). 
                                    </p>
                                    <p>The result set has the following form:</p><pre class="pre codeblock"><code>Marketing,20,employees_rowid
Marketing,20,employees_rowid
Marketing,20,employees_rowid
</code></pre></li>
                                 <li>
                                    <p>The database reads the next row of <code class="codeph">departments</code>, scans <code class="codeph">emp_department_ix</code> to find <code class="codeph">employees</code> rowids that correspond to this department ID, and then iterates through the loop until the client request is satisfied. 
                                    </p>
                                    <p>In this example, the database only iterates through the outer loop twice because only two rows from <code class="codeph">departments</code> satisfy the predicate filter. Conceptually, the result set has the following form:
                                    </p><pre class="pre codeblock"><code>Marketing,20,employees_rowid
Marketing,20,employees_rowid
Marketing,20,employees_rowid
.
.
.
Sales,80,employees_rowid
Sales,80,employees_rowid
Sales,80,employees_rowid
.
.
.
</code></pre><p>These rows become the outer row source for the outer nested loop (Step 1). This row set is cached in the PGA.</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>The database organizes the rowids obtained in the previous step so that it can more efficiently access them in the cache. </p>
                           </li>
                           <li>
                              <p>The database begins iterating through the outer nested loop as follows: </p>
                              <ol type="a">
                                 <li>
                                    <p>The database retrieves the first row from the row set obtained in the previous step, as in the following example:</p><pre class="pre codeblock"><code>Marketing,20,employees_rowid
</code></pre></li>
                                 <li>
                                    <p>Using the rowid, the database retrieves a row from <code class="codeph">employees</code> to obtain the requested values (Step 1), as in the following example:
                                    </p><pre class="pre codeblock"><code>Michael,Hartstein,13000,Marketing
</code></pre></li>
                                 <li>
                                    <p>The database retrieves the next row from the row set, uses the rowid to probe <code class="codeph">employees</code> for the matching row, and iterates through the loop until all rows are retrieved.
                                    </p>
                                    <p>The result set has the following form:</p><pre class="pre codeblock"><code>Michael,Hartstein,13000,Marketing
Pat,Fay,6000,Marketing
John,Russell,14000,Sales
Karen,Partners,13500,Sales
Alberto,Errazuriz,12000,Sales
.
.
.
</code></pre></li>
                              </ol>
                           </li>
                        </ol>
                        <p>In some cases, a second join row source is not allocated, and the execution plan looks the same as it did before <span>Oracle Database 11g</span>. The following list describes such cases:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>All of the columns needed from the inner side of the join are present in the index, and there is no table access required. In this case, Oracle Database allocates only one join row source.</p>
                           </li>
                           <li>
                              <p>The order of the rows returned might be different from the order returned in releases earlier than <span>Oracle Database 12c</span>. Thus, when Oracle Database tries to preserve a specific ordering of the rows, for example to eliminate the need for an <code class="codeph">ORDER BY</code> sort, Oracle Database might use the original implementation for nested loops joins.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">OPTIMIZER_FEATURES_ENABLE</code> initialization parameter is set to a release before <span>Oracle Database 11g</span>. In this case, Oracle Database uses the original implementation for nested loops joins.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94681"></a><div class="props_rev_3"><a id="GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" name="GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04"></a><h5 id="TGSQL-GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" class="sect5"><span class="enumeration_section">9.2.1.5 </span>Original Implementation for Nested Loops Joins
                     </h5>
                     <div>
                        <p>In the current release, both the new and original implementation of nested loops are possible.</p>
                        <p>For an example of the original implementation, consider the following join of the <code class="codeph">hr.employees</code> and <code class="codeph">hr.departments</code> tables:
                        </p><pre class="pre codeblock"><code>SELECT e.first_name, e.last_name, e.salary, d.department_name
FROM   hr.employees e, hr.departments d
WHERE  d.department_name IN ('Marketing', 'Sales')
AND    e.department_id = d.department_id;
</code></pre><p>In releases before Oracle Database 11<span class="italic">g</span>, the execution plan for this query might appear as follows:
                        </p><pre class="pre codeblock"><code>------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name              | Rows  | Bytes | Cost (%CPU)| Time    |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                   |    19 |   722 |     3  (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |    10 |   220 |     1  (0)| 00:00:01 |
|   2 |   NESTED LOOPS              |                   |    19 |   722 |     3  (0)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL        | DEPARTMENTS       |     2 |    32 |     2  (0)| 00:00:01 |
|*  4 |    INDEX RANGE SCAN         | EMP_DEPARTMENT_IX |    10 |       |     0  (0)| 00:00:01 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("D"."DEPARTMENT_NAME"='Marketing' OR "D"."DEPARTMENT_NAME"='Sales')
   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>For each fetch request, the basic process is as follows:</p>
                        <ol>
                           <li>
                              <p>The database iterates through the loop to obtain the rows requested in the fetch:</p>
                              <ol type="a">
                                 <li>
                                    <p>The database reads the first row of <code class="codeph">departments</code> to obtain the department IDs for departments named <code class="codeph">Marketing</code> or <code class="codeph">Sales</code> (Step 3). For example:
                                    </p><pre class="oac_no_warn" dir="ltr">Marketing,20
</pre><p>This row set is the outer loop. The database caches the row in the PGA.</p>
                                 </li>
                                 <li>
                                    <p>The database scans <code class="codeph">emp_department_ix</code>, which is an index on the <code class="codeph">employees.department_id</code> column, to find <code class="codeph">employees</code> rowids that correspond to this department ID (Step 4), and then joins the result (Step 2). 
                                    </p>
                                    <p>Conceptually, the result set has the following form:</p><pre class="pre codeblock"><code>Marketing,20,<span class="italic">employees_rowid</span>
Marketing,20,<span class="italic">employees_rowid</span>
Marketing,20,<span class="italic">employees_rowid</span>
</code></pre></li>
                                 <li>
                                    <p>The database reads the next row of <code class="codeph">departments</code>, scans <code class="codeph">emp_department_ix</code> to find <code class="codeph">employees</code> rowids that correspond to this department ID, and iterates through the loop until the client request is satisfied. 
                                    </p>
                                    <p>In this example, the database only iterates through the outer loop twice because only two rows from <code class="codeph">departments</code> satisfy the predicate filter. Conceptually, the result set has the following form:
                                    </p><pre class="pre codeblock"><code>Marketing,20,<span class="italic">employees_rowid</span>
Marketing,20,<span class="italic">employees_rowid</span>
Marketing,20,<span class="italic">employees_rowid</span>
.
.
.
Sales,80,<span class="italic">employees_rowid</span>
Sales,80,<span class="italic">employees_rowid</span>
Sales,80,<span class="italic">employees_rowid</span>
.
.
.
</code></pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>Depending on the circumstances, the database may organize the cached rowids obtained in the previous step so that it can more efficiently access them. </p>
                           </li>
                           <li>
                              <p>For each <code class="codeph">employees</code> rowid in the result set generated by the nested loop, the database retrieves a row from <code class="codeph">employees</code> to obtain the requested values (Step 1). 
                              </p>
                              <p>Thus, the basic process is to read a rowid and retrieve the matching <code class="codeph">employees</code> row, read the next rowid and retrieve the matching <code class="codeph">employees</code> row, and so on. Conceptually, the result set has the following form:
                              </p><pre class="pre codeblock"><code>Michael,Hartstein,13000,Marketing
Pat,Fay,6000,Marketing
John,Russell,14000,Sales
Karen,Partners,13500,Sales
Alberto,Errazuriz,12000,Sales
.
.
.</code></pre></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95236"></a><a id="TGSQL94685"></a><div class="props_rev_3"><a id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7" name="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7"></a><h5 id="TGSQL-GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7" class="sect5"><span class="enumeration_section">9.2.1.6 </span>Nested Loops Controls
                     </h5>
                     <div>
                        <p>For some SQL statements, the data is small enough for the optimizer to prefer full table scans and hash joins. However, you can add the <code class="codeph">USE_NL</code> hint to instruct the optimizer to join each specified table to another row source with a nested loops join, using the specified table as the inner table.
                        </p>
                        <p>The related hint <code class="codeph">USE_NL_WITH_INDEX(<span class="codeinlineitalic">table index</span>)</code> hint instructs the optimizer to join the specified table to another row source with a nested loops join using the specified table as the inner table. The index is optional. If no index is specified, then the nested loops join uses an index with at least one join predicate as the index key.
                        </p>
                        <div class="example" id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7__GUID-E222ED08-1F53-4217-9D1B-0BCC3D224D13">
                           <p class="titleinexample">Example 9-3 Nested Loops Hint</p>
                           <p>Assume that the optimizer chooses a hash join for the following query:</p><pre class="pre codeblock"><code>SELECT e.last_name, d.department_name
FROM   employees e, departments d
WHERE  e.department_id=d.department_id;
</code></pre><p>The plan looks as follows:</p><pre class="pre codeblock"><code>------------------------------------------------------------------------------
|Id | Operation          | Name        | Rows  | Bytes |Cost(%CPU)| Time     |
------------------------------------------------------------------------------
| 0 | SELECT STATEMENT   |             |       |       |   5 (100)|          |
|*1 |  HASH JOIN         |             |   106 |  2862 |   5  (20)| 00:00:01 |
| 2 |   TABLE ACCESS FULL| DEPARTMENTS |    27 |   432 |   2   (0)| 00:00:01 |
| 3 |   TABLE ACCESS FULL| EMPLOYEES   |   107 |  1177 |   2   (0)| 00:00:01 |
------------------------------------------------------------------------------
</code></pre><p>To force a nested loops join using <code class="codeph">departments</code> as the inner table, add the <code class="codeph">USE_NL</code> hint as in the following query:
                           </p><pre class="pre codeblock"><code>SELECT /*+ ORDERED USE_NL(d) */ e.last_name, d.department_name
FROM   employees e, departments d
WHERE  e.department_id=d.department_id;
</code></pre><p>The plan looks as follows:</p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id | Operation          | Name        | Rows  | Bytes |Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|  0 | SELECT STATEMENT   |             |       |       |   34 (100)|          |
|  1 |  NESTED LOOPS      |             |   106 |  2862 |   34   (3)| 00:00:01 |
|  2 |   TABLE ACCESS FULL| EMPLOYEES   |   107 |  1177 |    2   (0)| 00:00:01 |
|* 3 |   TABLE ACCESS FULL| DEPARTMENTS |     1 |    16 |    0   (0)|          |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>The database obtains the result set as follows:</p>
                           <ol>
                              <li>
                                 <p>In the nested loop, the database reads <code class="codeph">employees</code> to obtain the last name and department ID for an employee (Step 2). For example:
                                 </p><pre class="pre codeblock"><code>De Haan,90
</code></pre></li>
                              <li>
                                 <p>For the row obtained in the previous step, the database scans <code class="codeph">departments</code> to find the department name that matches the <code class="codeph">employees</code> department ID (Step 3), and joins the result (Step 1). For example:
                                 </p><pre class="pre codeblock"><code>De Haan,Executive
</code></pre></li>
                              <li>
                                 <p>The database retrieves the next row in <code class="codeph">employees</code>, retrieves the matching row from <code class="codeph">departments</code>, and then repeats this process until all rows are retrieved. 
                                 </p>
                                 <p>The result set has the following form:</p><pre class="pre codeblock"><code>De Haan,Executive
Kochnar,Executive
Baer,Public Relations
King,Executive
.
.
.</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7__GUID-C588B1FC-8F6A-4DAC-BA80-55D695AD82C1">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-5976D09A-257A-49F3-94E0-247B1247270A" title="In some cases, you can specify join order hints in a SQL statement so that it does not access rows that have no effect on the result.">Guidelines for Join Order Hints</a>"</span> to learn more about the <code class="codeph">USE_NL</code> hint
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50701" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code class="codeph">USE_NL</code> hint
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="Nested loops join an outer data set to an inner data set.">Nested Loops Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL245"></a><div class="props_rev_3"><a id="GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" name="GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB"></a><h4 id="TGSQL-GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" class="sect4"><span class="enumeration_section">9.2.2 </span>Hash Joins
                  </h4>
                  <div>
                     <p>The database uses a <strong class="term">hash join</strong> to join larger data sets.
                     </p>
                     <p>The optimizer uses the smaller of two data sets to build a hash table on the join key in memory, using a deterministic hash function to specify the location in the hash table in which to store each row. The database then scans the larger data set, probing the hash table to find the rows that meet the join condition.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62">When the Optimizer Considers Hash Joins</a><br>In general, the optimizer considers a hash join when a relatively large amount of data must be joined (or a large percentage of a small table must be joined), and the join is an equijoin.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7">How Hash Joins Work</a><br>A hashing algorithm takes a set of inputs and applies a deterministic hash function to generate a hash value between 1 and <span class="italic">n</span>, where <span class="italic">n</span> is the size of the hash table.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277">How Hash Joins Work When the Hash Table Does Not Fit in the PGA</a><br>The database must use a different technique when the hash table does not fit entirely in the PGA. In this case, the database uses a temporary space to hold portions (called partitions) of the hash table, and sometimes portions of the larger table that probes the hash table.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131">Hash Join Controls</a><br>The <code class="codeph">USE_HASH</code> hint instructs the optimizer to use a hash join when joining two tables together. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="A join method is the mechanism for joining two row sources.">Join Methods</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94687"></a><div class="props_rev_3"><a id="GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62" name="GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62"></a><h5 id="TGSQL-GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62" class="sect5"><span class="enumeration_section">9.2.2.1 </span>When the Optimizer Considers Hash Joins
                     </h5>
                     <div>
                        <p>In general, the optimizer considers a hash join when a relatively large amount of data must be joined (or a large percentage of a small table must be joined), and the join is an equijoin.</p>
                        <p>A hash join is most cost effective when the smaller data set fits in memory. In this case, the cost is limited to a single read pass over the two data sets.</p>
                        <p>Because the hash table is in the PGA, Oracle Database can access rows without latching them. This technique reduces logical I/O by avoiding the necessity of repeatedly latching and reading blocks in the database buffer cache.</p>
                        <p>If the data sets do not fit in memory, then the database partitions the row sources, and the join proceeds partition by partition. This can use a lot of sort area memory, and I/O to the temporary tablespace. This method can still be the most cost effective, especially when the database uses parallel query servers.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="The database uses a hash join to join larger data sets.">Hash Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95237"></a><div class="props_rev_3"><a id="GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" name="GUID-5A801568-F4E2-45C5-940B-55D23761BFD7"></a><h5 id="TGSQL-GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" class="sect5"><span class="enumeration_section">9.2.2.2 </span>How Hash Joins Work
                     </h5>
                     <div>
                        <p>A hashing algorithm takes a set of inputs and applies a deterministic hash function to generate a hash value between 1 and <span class="italic">n</span>, where <span class="italic">n</span> is the size of the hash table.
                        </p>
                        <p>In a hash join, the input values are the join keys. The output values are indexes (slots) in an array, which is the hash table.</p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="joins.html#GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91">Hash Tables</a><br>To illustrate a hash table, assume that the database hashes <code class="codeph">hr.departments</code> in a join of <code class="codeph">departments</code> and <code class="codeph">employees</code>. The join key column is <code class="codeph">department_id</code>. 
                           </li>
                           <li class="ulchildlink"><a href="joins.html#GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C">Hash Join: Basic Steps</a><br>The optimizer uses the smaller data source to build a hash table on the join key in memory, and then scans the larger table to find the joined rows.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="The database uses a hash join to join larger data sets.">Hash Joins</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL95295"></a><div class="props_rev_3"><a id="GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91" name="GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91"></a><h6 id="TGSQL-GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91" class="sect6"><span class="enumeration_section">9.2.2.2.1 </span>Hash Tables
                        </h6>
                        <div>
                           <p>To illustrate a hash table, assume that the database hashes <code class="codeph">hr.departments</code> in a join of <code class="codeph">departments</code> and <code class="codeph">employees</code>. The join key column is <code class="codeph">department_id</code>. 
                           </p>
                           <p>The first 5 rows of <code class="codeph">departments</code> are as follows:
                           </p><pre class="pre codeblock"><code>SQL&gt; select * from departments where rownum &lt; 6;
 
DEPARTMENT_ID DEPARTMENT_NAME                MANAGER_ID LOCATION_ID
------------- ------------------------------ ---------- -----------
           10 Administration                        200        1700
           20 Marketing                             201        1800
           30 Purchasing                            114        1700
           40 Human Resources                       203        2400
           50 Shipping                              121        1500
</code></pre><p>The database applies the hash function to each <code class="codeph">department_id</code> in the table, generating a hash value for each. For this illustration, the hash table has 5 slots (it could have more or less). Because <span class="italic">n</span> is <code class="codeph">5</code>, the possible hash values range from <code class="codeph">1</code> to <code class="codeph">5</code>. The hash functions might generate the following values for the department IDs:
                           </p><pre class="pre codeblock"><code>f(10) = 4
f(20) = 1
f(30) = 4
f(40) = 2
f(50) = 5
</code></pre><p>Note that the hash function happens to generate the same hash value of <code class="codeph">4</code> for departments <code class="codeph">10</code> and <code class="codeph">30</code>. This is known as a <a href="glossary.html#GUID-1391B1A0-90E0-4E77-87F3-3703B434F194"><span class="xrefglossterm">hash collision</span></a>. In this case, the database puts the records for departments <code class="codeph">10</code> and <code class="codeph">30</code> in the same slot, using a linked list. Conceptually, the hash table looks as follows:
                           </p><pre class="pre codeblock"><code>1    20,Marketing,201,1800
2    40,Human Resources,203,2400
3
4    10,Administration,200,1700 -&gt; 30,Purchasing,114,1700
5    50,Shipping,121,1500</code></pre></div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" title="A hashing algorithm takes a set of inputs and applies a deterministic hash function to generate a hash value between 1 and n, where n is the size of the hash table.">How Hash Joins Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94688"></a><a id="TGSQL95296"></a><div class="props_rev_3"><a id="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C" name="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C"></a><h6 id="TGSQL-GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C" class="sect6"><span class="enumeration_section">9.2.2.2.2 </span>Hash Join: Basic Steps
                        </h6>
                        <div>
                           <p>The optimizer uses the smaller data source to build a hash table on the join key in memory, and then scans the larger table to find the joined rows.</p>
                           <p>The basic steps are as follows:</p>
                           <ol>
                              <li>
                                 <p>The database performs a full scan of the smaller data set, called the <span class="bold">build table</span>, and then applies a hash function to the join key in each row to build a hash table in the PGA.
                                 </p>
                                 <p>In pseudocode, the algorithm might look as follows:</p><pre class="pre codeblock"><code>FOR small_table_row IN (SELECT * FROM small_table)
LOOP
  slot_number := HASH(small_table_row.join_key);
  INSERT_HASH_TABLE(slot_number,small_table_row);
END LOOP;
</code></pre></li>
                              <li>
                                 <p>The database probes the second data set, called the <span class="bold">probe table</span>, using whichever access mechanism has the lowest cost.
                                 </p>
                                 <p>Typically, the database performs a full scan of both the smaller and larger data set. The algorithm in pseudocode might look as follows:</p><pre class="pre codeblock"><code>FOR large_table_row IN (SELECT * FROM large_table)
LOOP
   slot_number := HASH(large_table_row.join_key);
   small_table_row = LOOKUP_HASH_TABLE(slot_number,large_table_row.join_key);
   IF small_table_row FOUND
   THEN
      output small_table_row + large_table_row;
   END IF;
END LOOP;
</code></pre><p>For each row retrieved from the larger data set, the database does the following:</p>
                                 <ol type="a">
                                    <li>
                                       <p>Applies the same hash function to the join column or columns to calculate the number of the relevant slot in the hash table.</p>
                                       <p>For example, to probe the hash table for department ID <code class="codeph">30</code>, the database applies the hash function to <code class="codeph">30</code>, which generates the hash value <code class="codeph">4</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>Probes the hash table to determine whether rows exists in the slot. </p>
                                       <p>If no rows exist, then the database processes the next row in the larger data set. If rows exist, then the database proceeds to the next step.</p>
                                    </li>
                                    <li>
                                       <p>Checks the join column or columns for a match. If a match occurs, then the database either reports the rows or passes them to the next step in the plan, and then processes the next row in the larger data set.</p>
                                       <p>If multiple rows exist in the hash table slot, the database walks through the linked list of rows, checking each one. For example, if department <code class="codeph">30</code> hashes to slot <code class="codeph">4</code>, then the database checks each row until it finds <code class="codeph">30</code>.
                                       </p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                           <div class="example" id="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C__GUID-E62BDD95-89A0-43A4-91C6-526CA259F83A">
                              <p class="titleinexample">Example 9-4 Hash Joins</p>
                              <p>An application queries the <code class="codeph">oe.orders</code> and <code class="codeph">oe.order_items</code> tables, joining on the <code class="codeph">order_id</code> column.
                              </p><pre class="pre codeblock"><code>SELECT o.customer_id, l.unit_price * l.quantity
FROM   orders o, order_items l
WHERE  l.order_id = o.order_id;
</code></pre><p>The execution plan is as follows:</p><pre class="pre codeblock"><code>--------------------------------------------------------------------------
| Id  | Operation            |  Name        | Rows  | Bytes | Cost (%CPU)|
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |              |   665 | 13300 |     8  (25)|
|*  1 |  HASH JOIN           |              |   665 | 13300 |     8  (25)|
|   2 |   TABLE ACCESS FULL  | ORDERS       |   105 |   840 |     4  (25)|
|   3 |   TABLE ACCESS FULL  | ORDER_ITEMS  |   665 |  7980 |     4  (25)|
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("L"."ORDER_ID"="O"."ORDER_ID")
</code></pre><p>Because the <code class="codeph">orders</code> table is small relative to the <code class="codeph">order_items</code> table, which is 6 times larger, the database hashes <code class="codeph">orders</code>. In a hash join, the data set for the build table always appears first in the list of operations (Step 2). In Step 3, the database performs a full scan of the larger <code class="codeph">order_items</code> later, probing the hash table for each row.
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" title="A hashing algorithm takes a set of inputs and applies a deterministic hash function to generate a hash value between 1 and n, where n is the size of the hash table.">How Hash Joins Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="TGSQL95238"></a><div class="props_rev_3"><a id="GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277" name="GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277"></a><h5 id="TGSQL-GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277" class="sect5"><span class="enumeration_section">9.2.2.3 </span>How Hash Joins Work When the Hash Table Does Not Fit in the PGA
                     </h5>
                     <div>
                        <p>The database must use a different technique when the hash table does not fit entirely in the PGA. In this case, the database uses a temporary space to hold portions (called partitions) of the hash table, and sometimes portions of the larger table that probes the hash table.</p>
                        <p>The basic process is as follows:</p>
                        <ol>
                           <li>
                              <p>The database performs a full scan of the smaller data set, and then builds an array of hash buckets in both the PGA and on disk.</p>
                              <p>When the PGA hash area fills up, the database finds the largest partition within the hash table and writes it to temporary space on disk. The database stores any new row that belongs to this on-disk partition on disk, and all other rows in the PGA. Thus, part of the hash table is in memory and part of it on disk.</p>
                           </li>
                           <li>
                              <p>The database takes a first pass at reading the other data set.</p>
                              <p>For each row, the database does the following:</p>
                              <ol type="a">
                                 <li>
                                    <p>Applies the same hash function to the join column or columns to calculate the number of the relevant hash bucket.</p>
                                 </li>
                                 <li>
                                    <p>Probes the hash table to determine whether rows exist in the bucket <span class="italic">in memory</span>.
                                    </p>
                                    <p>If the hashed value points to a row in memory, then the database completes the join and returns the row. If the value points to a hash partition on disk, however, then the database stores this row in the temporary tablespace, using the same partitioning scheme used for the original data set.</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>The database reads each on-disk temporary partition one by one</p>
                           </li>
                           <li>
                              <p>The database joins each partition row to the row in the corresponding on-disk temporary partition.</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="The database uses a hash join to join larger data sets.">Hash Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94689"></a><div class="props_rev_3"><a id="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131" name="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131"></a><h5 id="TGSQL-GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131" class="sect5"><span class="enumeration_section">9.2.2.4 </span>Hash Join Controls
                     </h5>
                     <div>
                        <p>The <code class="codeph">USE_HASH</code> hint instructs the optimizer to use a hash join when joining two tables together. 
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131__GUID-EDCF636C-965A-4CDC-895A-F364D8AEC8FD">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-5976D09A-257A-49F3-94E0-247B1247270A" title="In some cases, you can specify join order hints in a SQL statement so that it does not access rows that have no effect on the result.">Guidelines for Join Order Hints</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF-GUID-FA1147B3-BCAA-41F9-B6A2-8DEDABF1C021" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about <code class="codeph">USE_HASH</code></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="The database uses a hash join to join larger data sets.">Hash Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94690"></a><div class="props_rev_3"><a id="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" name="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F"></a><h4 id="TGSQL-GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" class="sect4"><span class="enumeration_section">9.2.3 </span>Sort Merge Joins
                  </h4>
                  <div>
                     <p>A sort merge join is a variation on a nested loops join.</p>
                     <p>If the two data sets in the join are not already sorted, then the database sorts them. These are the <code class="codeph">SORT JOIN</code> operations. For each row in the first data set, the database probes the second data set for matching rows and joins them, basing its start position on the match made in the previous iteration. This is the <code class="codeph">MERGE JOIN</code> operation.
                     </p>
                     <div class="figure" id="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F__GUID-CD346B70-7D5C-47E9-AD77-13203BBEDD12">
                        <p class="titleinfigure">Figure 9-6 Sort Merge Join</p><img src="img/tgsql_vm_081.png" alt="Description of Figure 9-6 follows" title="Description of Figure 9-6 follows" longdesc="img_text/tgsql_vm_081.html"><br><a href="img_text/tgsql_vm_081.html">Description of "Figure 9-6 Sort Merge Join"</a></div>
                     <!-- class="figure" -->
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-3F935776-FE28-4350-9FA4-E6B47489156E">When the Optimizer Considers Sort Merge Joins</a><br>A hash join requires one hash table and one probe of this table, whereas a sort merge join requires two sorts. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227">How Sort Merge Joins Work</a><br>As in a nested loops join, a sort merge join reads two data sets, but sorts them when they are not already sorted. For each row in the first data set, the database finds a starting row in the second data set, and then reads the second data set until it finds a nonmatching row. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F">Sort Merge Join Controls</a><br>The <code class="codeph">USE_MERGE</code> hint instructs the optimizer to use a sort merge join. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="A join method is the mechanism for joining two row sources.">Join Methods</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94691"></a><div class="props_rev_3"><a id="GUID-3F935776-FE28-4350-9FA4-E6B47489156E" name="GUID-3F935776-FE28-4350-9FA4-E6B47489156E"></a><h5 id="TGSQL-GUID-3F935776-FE28-4350-9FA4-E6B47489156E" class="sect5"><span class="enumeration_section">9.2.3.1 </span>When the Optimizer Considers Sort Merge Joins
                     </h5>
                     <div>
                        <p>A hash join requires one hash table and one probe of this table, whereas a sort merge join requires two sorts. </p>
                        <p>The optimizer may choose a sort merge join over a hash join for joining large amounts of data when any of the following conditions is true:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The join condition between two tables is not an equijoin, that is, uses an inequality condition such as <code class="codeph">&lt;</code>, <code class="codeph">&lt;=</code>, <code class="codeph">&gt;</code>, or <code class="codeph">&gt;=</code>. 
                              </p>
                              <p>In contrast to sort merges, hash joins require an equality condition.</p>
                           </li>
                           <li>
                              <p>Because of sorts required by other operations, the optimizer finds it cheaper to use a sort merge. </p>
                              <p>If an index exists, then the database can avoid sorting the first data set. However, the database always sorts the second data set, regardless of indexes.</p>
                           </li>
                        </ul>
                        <p>A sort merge has the same advantage over a nested loops join as the hash join: the database accesses rows in the PGA rather than the SGA, reducing logical I/O by avoiding the necessity of repeatedly latching and reading blocks in the database buffer cache. In general, hash joins perform better than sort merge joins because sorting is expensive. However, sort merge joins offer the following advantages over a hash join:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>After the initial sort, the merge phase is optimized, resulting in faster generation of output rows.</p>
                           </li>
                           <li>
                              <p>A sort merge can be more cost-effective than a hash join when the hash table does not fit completely in memory.</p>
                              <p>A hash join with insufficient memory requires both the hash table and the other data set to be copied to disk. In this case, the database may have to read from disk multiple times. In a sort merge, if memory cannot hold the two data sets, then the database writes them both to disk, but reads each data set no more than once.</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="A sort merge join is a variation on a nested loops join.">Sort Merge Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95310"></a><a id="TGSQL95311"></a><a id="TGSQL95309"></a><div class="props_rev_3"><a id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227" name="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227"></a><h5 id="TGSQL-GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227" class="sect5"><span class="enumeration_section">9.2.3.2 </span>How Sort Merge Joins Work
                     </h5>
                     <div>
                        <p>As in a nested loops join, a sort merge join reads two data sets, but sorts them when they are not already sorted. For each row in the first data set, the database finds a starting row in the second data set, and then reads the second data set until it finds a nonmatching row. </p>
                        <p>In pseudocode, the high-level algorithm for sort merge might look as follows:</p><pre class="pre codeblock"><code>READ data_set_1 SORT BY JOIN KEY TO temp_ds1
READ data_set_2 SORT BY JOIN KEY TO temp_ds2
 
READ ds1_row FROM temp_ds1
READ ds2_row FROM temp_ds2

WHILE NOT eof ON temp_ds1,temp_ds2
LOOP
    IF ( temp_ds1.key = temp_ds2.key ) OUTPUT JOIN ds1_row,ds2_row
    ELSIF ( temp_ds1.key &lt;= temp_ds2.key ) READ ds1_row FROM temp_ds1
    ELSIF ( temp_ds1.key =&gt; temp_ds2.key ) READ ds2_row FROM temp_ds2
END LOOP
</code></pre><p>For example, the following table shows sorted values in two data sets: <code class="codeph">temp_ds1</code> and <code class="codeph">temp_ds2</code>.
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-9E542AC2-F6E6-4779-A47F-4C4335E341C9">
                           <p class="titleintable">Table 9-3 Sorted Data Sets</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Sorted Data Sets" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4345">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4347">temp_ds2</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4351" headers="d49855e4345 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4351 d49855e4347 ">20</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4356" headers="d49855e4345 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4356 d49855e4347 ">20</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4361" headers="d49855e4345 ">30</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4361 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4366" headers="d49855e4345 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4366 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4371" headers="d49855e4345 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4371 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4376" headers="d49855e4345 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4376 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4381" headers="d49855e4345 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4381 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4386" headers="d49855e4345 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4386 d49855e4347 ">60</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4391" headers="d49855e4345 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4391 d49855e4347 ">70</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4396" headers="d49855e4345 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4396 d49855e4347 ">70</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>As shown in the following table, the database begins by reading <code class="codeph">10</code> in <code class="codeph">temp_ds1</code>, and then reads the first value in <code class="codeph">temp_ds2</code>. Because <code class="codeph">20</code> in <code class="codeph">temp_ds2</code> is higher than <code class="codeph">10</code> in <code class="codeph">temp_ds1</code>, the database stops reading <code class="codeph">temp_ds2</code>.
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-F04E9A1A-AF41-48D2-ADB8-69F07269D163">
                           <p class="titleintable">Table 9-4 Start at 10 in temp_ds1</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Start at 10 in temp_ds1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 10 in temp_ds1, and at 20 in temp_ds2." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4438">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4440">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4442">Action</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4446" headers="d49855e4438 ">10 [start here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4446 d49855e4440 ">20 [start here] [stop here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4446 d49855e4442 ">20 in temp_ds2 is higher than 10 in temp_ds1. Stop. Start again with next row in temp_ds1.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4453" headers="d49855e4438 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4453 d49855e4440 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4453 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4459" headers="d49855e4438 ">30</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4459 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4459 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4465" headers="d49855e4438 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4465 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4465 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4471" headers="d49855e4438 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4471 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4471 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4477" headers="d49855e4438 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4477 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4477 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4483" headers="d49855e4438 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4483 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4483 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4489" headers="d49855e4438 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4489 d49855e4440 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4489 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4495" headers="d49855e4438 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4495 d49855e4440 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4495 d49855e4442 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4501" headers="d49855e4438 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4501 d49855e4440 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4501 d49855e4442 ">&nbsp;</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The database proceeds to the next value in <code class="codeph">temp_ds1</code>, which is <code class="codeph">20</code>. The database proceeds through <code class="codeph">temp_ds2</code> as shown in the following table.
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-123424C4-04EA-495B-9F26-3A11D9F706BD">
                           <p class="titleintable">Table 9-5 Start at 20 in temp_ds1</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Start at 20 in temp_ds1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 20 in temp_ds1, and at 20 in temp_ds2." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4528">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4530">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4532">Action</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4536" headers="d49855e4528 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4536 d49855e4530 ">20 [start here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4536 d49855e4532 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4543" headers="d49855e4528 ">20 [start here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4543 d49855e4530 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4543 d49855e4532 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4550" headers="d49855e4528 ">30</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4550 d49855e4530 ">40 [stop here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4550 d49855e4532 ">40 in temp_ds2 is higher than 20 in temp_ds1. Stop. Start again with next row in temp_ds1.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4557" headers="d49855e4528 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4557 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4557 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4563" headers="d49855e4528 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4563 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4563 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4569" headers="d49855e4528 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4569 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4569 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4575" headers="d49855e4528 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4575 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4575 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4581" headers="d49855e4528 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4581 d49855e4530 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4581 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4587" headers="d49855e4528 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4587 d49855e4530 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4587 d49855e4532 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4593" headers="d49855e4528 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4593 d49855e4530 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4593 d49855e4532 ">&nbsp;</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The database proceeds to the next row in <code class="codeph">temp_ds1</code>, which is <code class="codeph">30</code>. The database starts at the number of its last match, which was <code class="codeph">20</code>, and then proceeds through <code class="codeph">temp_ds2</code> looking for a match, as shown in the following table.
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-3FC1DA9C-FE2F-44BA-AEA3-26BC5C8F7685">
                           <p class="titleintable">Table 9-6 Start at 30 in temp_ds1</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Start at 30 in temp_ds1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 30 in temp_ds1, and at 20 in temp_ds2." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4623">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4625">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4627">Action</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4631" headers="d49855e4623 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4631 d49855e4625 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4631 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4637" headers="d49855e4623 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4637 d49855e4625 ">20 [start at last match]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4637 d49855e4627 ">20 in temp_ds2 is lower than 30 in temp_ds1. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4644" headers="d49855e4623 ">30 [start here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4644 d49855e4625 ">40 [stop here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4644 d49855e4627 ">40 in temp_ds2 is higher than 30 in temp_ds1. Stop. Start again with next row in temp_ds1.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4651" headers="d49855e4623 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4651 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4651 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4657" headers="d49855e4623 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4657 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4657 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4663" headers="d49855e4623 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4663 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4663 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4669" headers="d49855e4623 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4669 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4669 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4675" headers="d49855e4623 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4675 d49855e4625 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4675 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4681" headers="d49855e4623 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4681 d49855e4625 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4681 d49855e4627 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4687" headers="d49855e4623 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4687 d49855e4625 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4687 d49855e4627 ">&nbsp;</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The database proceeds to the next row in <code class="codeph">temp_ds1</code>, which is <code class="codeph">40</code>. As shown in the following table, the database starts at the number of its last match in <code class="codeph">temp_ds2</code>, which was <code class="codeph">20</code>, and then proceeds through <code class="codeph">temp_ds2</code> looking for a match.
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-332A4FD0-3DF9-4A69-8B95-28E59AFE13A2">
                           <p class="titleintable">Table 9-7 Start at 40 in temp_ds1</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Start at 40 in temp_ds1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 40 in temp_ds1, and at 20 in temp_ds2." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4721">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4723">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4725">Action</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4729" headers="d49855e4721 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4729 d49855e4723 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4729 d49855e4725 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4735" headers="d49855e4721 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4735 d49855e4723 ">20 [start at last match]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4735 d49855e4725 ">20 in temp_ds2 is lower than 40 in temp_ds1. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4742" headers="d49855e4721 ">30</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4742 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4742 d49855e4725 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4749" headers="d49855e4721 ">40 [start here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4749 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4749 d49855e4725 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4756" headers="d49855e4721 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4756 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4756 d49855e4725 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4763" headers="d49855e4721 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4763 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4763 d49855e4725 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4770" headers="d49855e4721 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4770 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4770 d49855e4725 ">Match. Proceed to next value in temp_ds2.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4777" headers="d49855e4721 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4777 d49855e4723 ">60 [stop here]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4777 d49855e4725 ">60 in temp_ds2 is higher than 40 in temp_ds1. Stop. Start again with next row in temp_ds1.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4784" headers="d49855e4721 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4784 d49855e4723 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4784 d49855e4725 ">&nbsp;</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4790" headers="d49855e4721 ">.</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4790 d49855e4723 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4790 d49855e4725 ">&nbsp;</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The database continues in this way until it has matched the final <code class="codeph">70</code> in <code class="codeph">temp_ds2</code>. This scenario demonstrates that the database, as it reads through <code class="codeph">temp_ds1</code>, does not need to read every row in <code class="codeph">temp_ds2</code>. This is an advantage over a nested loops join.
                        </p>
                        <div class="example" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-1CDCD0C9-4355-4238-91DB-F84D0720076C">
                           <p class="titleinexample">Example 9-5 Sort Merge Join Using Index</p>
                           <p>The following query joins the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, ordering the rows on <code class="codeph">department_id</code> as follows:
                           </p><pre class="pre codeblock"><code>SELECT e.employee_id, e.last_name, e.first_name, e.department_id, 
       d.department_name
FROM   employees e, departments d
WHERE  e.department_id = d.department_id
ORDER BY department_id;
</code></pre><p>A query of <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> shows that the plan uses a sort merge join:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
|Id| Operation                    | Name        |Rows|Bytes |Cost (%CPU)| Time |
--------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |             |    |      | 5(100)|          |
| 1|  MERGE JOIN                  |             |106 | 4028 | 5 (20)| 00:00:01 |
| 2|   TABLE ACCESS BY INDEX ROWID| DEPARTMENTS | 27 |  432 | 2  (0)| 00:00:01 |
| 3|    INDEX FULL SCAN           | DEPT_ID_PK  | 27 |      | 1  (0)| 00:00:01 |
|*4|   SORT JOIN                  |             |107 | 2354 | 3 (34)| 00:00:01 |
| 5|    TABLE ACCESS FULL         | EMPLOYEES   |107 | 2354 | 2  (0)| 00:00:01 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>The two data sets are the <code class="codeph">departments</code> table and the <code class="codeph">employees</code> table. Because an index orders the <code class="codeph">departments</code> table by <code class="codeph">department_id</code>, the database can read this index and avoid a sort (Step 3). The database only needs to sort the <code class="codeph">employees</code> table (Step 4), which is the most CPU-intensive operation.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-712E8248-5334-4494-857A-0431E1DCABD6">
                           <p class="titleinexample">Example 9-6 Sort Merge Join Without an Index</p>
                           <p>You join the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, ordering the rows on <code class="codeph">department_id</code> as follows. In this example, you specify <code class="codeph">NO_INDEX</code> and <code class="codeph">USE_MERGE</code> to force the optimizer to choose a sort merge:
                           </p><pre class="pre codeblock"><code>SELECT /*+ USE_MERGE(d e) NO_INDEX(d) */ e.employee_id, e.last_name, e.first_name, 
       e.department_id, d.department_name
FROM   employees e, departments d
WHERE  e.department_id = d.department_id
ORDER BY department_id;
</code></pre><p>A query of <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> shows that the plan uses a sort merge join:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation           | Name        | Rows  | Bytes | Cost (%CPU)| Time    |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT    |             |       |       |     6 (100)|         |
| 1 |  MERGE JOIN         |             |   106 |  9540 |     6  (34)| 00:00:01|
| 2 |   SORT JOIN         |             |    27 |   567 |     3  (34)| 00:00:01|
| 3 |    TABLE ACCESS FULL| DEPARTMENTS |    27 |   567 |     2   (0)| 00:00:01|
|*4 |   SORT JOIN         |             |   107 |  7383 |     3  (34)| 00:00:01|
| 5 |    TABLE ACCESS FULL| EMPLOYEES   |   107 |  7383 |     2   (0)| 00:00:01|
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>Because the <code class="codeph">departments.department_id</code> index is ignored, the optimizer performs a sort, which increases the combined cost of Step 2 and Step 3 by 67% (from <code class="codeph">3</code> to <code class="codeph">5</code>).
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="A sort merge join is a variation on a nested loops join.">Sort Merge Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94692"></a><div class="props_rev_3"><a id="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F" name="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F"></a><h5 id="TGSQL-GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F" class="sect5"><span class="enumeration_section">9.2.3.3 </span>Sort Merge Join Controls
                     </h5>
                     <div>
                        <p>The <code class="codeph">USE_MERGE</code> hint instructs the optimizer to use a sort merge join. 
                        </p>
                        <p>In some situations it may make sense to override the optimizer with the <code class="codeph">USE_MERGE</code> hint. For example, the optimizer can choose a full scan on a table and avoid a sort operation in a query. However, there is an increased cost because a large table is accessed through an index and single block reads, as opposed to faster access through a full table scan.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F__GUID-EE214692-A01D-4BB9-B837-719BF382F8DC">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50702" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">USE_MERGE</code> hint
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="A sort merge join is a variation on a nested loops join.">Sort Merge Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL95239"></a><div class="props_rev_3"><a id="GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" name="GUID-8E7760A6-48D6-4794-BF2F-290349C019B9"></a><h3 id="TGSQL-GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" class="sect3"><span class="enumeration_section">9.3 </span>Join Types
               </h3>
               <div>
                  <p>A join type is determined by the type of join condition. </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51">Inner Joins</a><br>An <strong class="term">inner join</strong> (sometimes called a <span class="italic">simple join</span>) is a join that returns only rows that satisfy the join condition. Inner joins are either equijoins or nonequijoins.
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355">Outer Joins</a><br>An <strong class="term">outer join</strong> returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847">Semijoins</a><br>A <strong class="term">semijoin</strong> is a join between two data sets that returns a row from the first set when a matching row exists in the subquery data set.
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693">Antijoins</a><br>An <strong class="term">antijoin</strong> is a join between two data sets that returns a row from the first set when a matching row does not exist in the subquery data set. 
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC">Cartesian Joins</a><br>The database uses a <strong class="term">Cartesian join</strong> when one or more of the tables does not have any join conditions to any other tables in the statement. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle Database provides several optimizations for joining row sets.">Joins</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95240"></a><div class="props_rev_3"><a id="GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" name="GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51"></a><h4 id="TGSQL-GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" class="sect4"><span class="enumeration_section">9.3.1 </span>Inner Joins
                  </h4>
                  <div>
                     <p>An <strong class="term">inner join</strong> (sometimes called a <span class="italic">simple join</span>) is a join that returns only rows that satisfy the join condition. Inner joins are either equijoins or nonequijoins.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F">Equijoins</a><br>An <span class="bold">equijoin</span> is an inner join whose join condition contains an equality operator.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C9653D35-455F-44C9-91F4-82B18478B43A">Nonequijoins</a><br>A <span class="bold">nonequijoin</span> is an inner join whose join condition contains an operator that is not an equality operator.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-24F34188-110F-4245-9DE7-43954092AFE0">Band Joins</a><br>A <strong class="term">band join</strong> is a special type of nonequijoin in which key values in one data set must fall within the specified range (band) of the second data set. The same table can serve as both the first and second data sets.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95313"></a><div class="props_rev_3"><a id="GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F" name="GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F"></a><h5 id="TGSQL-GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F" class="sect5"><span class="enumeration_section">9.3.1.1 </span>Equijoins
                     </h5>
                     <div>
                        <p>An <span class="bold">equijoin</span> is an inner join whose join condition contains an equality operator.
                        </p>
                        <p>The following example is an equijoin because the join condition contains only an equality operator:</p><pre class="pre codeblock"><code>SELECT e.employee_id, e.last_name, d.department_name
FROM   employees e, departments d
WHERE  e.department_id=d.department_id;
</code></pre><p>In the preceding query, the join condition is <code class="codeph">e.department_id=d.department_id</code>. If a row in the <code class="codeph">employees</code> table has a department ID that matches the value in a row in the <code class="codeph">departments</code> table, then the database returns the joined result; otherwise, the database does not return a result.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="An inner join (sometimes called a simple join) is a join that returns only rows that satisfy the join condition. Inner joins are either equijoins or nonequijoins.">Inner Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95314"></a><div class="props_rev_3"><a id="GUID-C9653D35-455F-44C9-91F4-82B18478B43A" name="GUID-C9653D35-455F-44C9-91F4-82B18478B43A"></a><h5 id="TGSQL-GUID-C9653D35-455F-44C9-91F4-82B18478B43A" class="sect5"><span class="enumeration_section">9.3.1.2 </span>Nonequijoins
                     </h5>
                     <div>
                        <p>A <span class="bold">nonequijoin</span> is an inner join whose join condition contains an operator that is not an equality operator.
                        </p>
                        <p> The following query lists all employees whose hire date occurred when employee 176 (who is listed in <code class="codeph">job_history</code> because he changed jobs in 2007) was working at the company:
                        </p><pre class="pre codeblock"><code>SELECT e.employee_id, e.first_name, e.last_name, e.hire_date
FROM   employees e, job_history h
WHERE  h.employee_id = 176
AND    e.hire_date BETWEEN h.start_date AND h.end_date;
</code></pre><p>In the preceding example, the condition joining <code class="codeph">employees</code> and <code class="codeph">job_history</code> does not contain an equality operator, so it is a nonequijoin. Nonequijoins are relatively rare.
                        </p>
                        <p>Note that a hash join requires at least a partial equijoin. The following SQL script contains an equality join condition (<code class="codeph">e1.empno = e2.empno</code>) and a nonequality condition:
                        </p><pre class="pre codeblock"><code>SET AUTOTRACE TRACEONLY EXPLAIN
SELECT *
FROM   scott.emp e1 JOIN scott.emp e2
ON     ( e1.empno = e2.empno
AND      e1.hiredate BETWEEN e2.hiredate-1 AND e2.hiredate+1 )
</code></pre><p>The optimizer chooses a hash join for the preceding query, as shown in the following plan:</p><pre class="pre codeblock"><code>Execution Plan
----------------------------------------------------------
Plan hash value: 3638257876
 
---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |     1 |   174 |     5  (20)| 00:00:01 |
|*  1 |  HASH JOIN         |      |     1 |   174 |     5  (20)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| EMP  |    14 |  1218 |     2   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| EMP  |    14 |  1218 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("E1"."EMPNO"="E2"."EMPNO")
       filter("E1"."HIREDATE"&gt;=INTERNAL_FUNCTION("E2"."HIREDATE")-1 AND
              "E1"."HIREDATE"&lt;=INTERNAL_FUNCTION("E2"."HIREDATE")+1)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="An inner join (sometimes called a simple join) is a join that returns only rows that satisfy the join condition. Inner joins are either equijoins or nonequijoins.">Inner Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-24F34188-110F-4245-9DE7-43954092AFE0" name="GUID-24F34188-110F-4245-9DE7-43954092AFE0"></a><h5 id="TGSQL-GUID-24F34188-110F-4245-9DE7-43954092AFE0" class="sect5"><span class="enumeration_section">9.3.1.3 </span>Band Joins
                     </h5>
                     <div>
                        <p>A <strong class="term">band join</strong> is a special type of nonequijoin in which key values in one data set must fall within the specified range (band) of the second data set. The same table can serve as both the first and second data sets.
                        </p>
                        <p>Starting in <span>Oracle Database 12c</span> Release 2 (12.2), the database evaluates band joins more efficiently. The optimization avoids the unnecessary scanning of rows that fall outside the defined bands.
                        </p>
                        <p>The optimizer uses a cost estimate to choose the join method (hash, nested loops, or sort merge) and the parallel data distribution method. In most cases, optimized performance is comparable to an equijoin.</p>
                        <p>This following examples query employees whose salaries are between $100 less and $100 more than the salary of each employee. Thus, the band has a width of $200. The examples assume that it is permissible to compare the salary of every employee with itself. The following query includes partial sample output:</p><pre class="pre codeblock"><code>SELECT  e1.last_name || 
        ' has salary between 100 less and 100 more than ' || 
        e2.last_name AS "SALARY COMPARISON"
FROM    employees e1, 
        employees e2
WHERE   e1.salary 
BETWEEN e2.salary - 100 
AND     e2.salary + 100;

SALARY COMPARISON
-------------------------------------------------------------
King has salary between 100 less and 100 more than King
Kochhar has salary between 100 less and 100 more than Kochhar
Kochhar has salary between 100 less and 100 more than De Haan
De Haan has salary between 100 less and 100 more than Kochhar
De Haan has salary between 100 less and 100 more than De Haan
Russell has salary between 100 less and 100 more than Russell
Partners has salary between 100 less and 100 more than Partners
...</code></pre><div class="example" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-829E275E-74C8-4440-80C2-5BA320FC05FA">
                           <p class="titleinexample">Example 9-7 Query Without Band Join Optimization</p>
                           <p>Without the band join optimization, the database uses the following query plan:</p><pre class="pre codeblock"><code>------------------------------------------
PLAN_TABLE_OUTPUT
------------------------------------------
------------------------------------------
| Id  | Operation            | Name      |
------------------------------------------
|   0 | SELECT STATEMENT     |           |
|   1 |  MERGE JOIN          |           |
|   2 |   SORT JOIN          |           |
|   3 |    TABLE ACCESS FULL | EMPLOYEES |
|*  4 |   FILTER             |           |
|*  5 |    SORT JOIN         |           |
|   6 |     TABLE ACCESS FULL| EMPLOYEES |
------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   4 - filter("E1"."SAL"&lt;="E2"."SAL"+100)
   5 - access(INTERNAL_FUNCTION("E1"."SAL")&gt;="E2"."SAL"-100)
       filter(INTERNAL_FUNCTION("E1"."SAL")&gt;="E2"."SAL"-100)
</code></pre><p>In this plan, Step 2 sorts the <code class="codeph">e1</code> row source, and Step 5 sorts the <code class="codeph">e2</code> row source. The sorted row sources are illustrated in the following table.
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-645755EC-92B6-496B-A6AD-BAEAEC610B5B">
                              <p class="titleintable">Table 9-8 Sorted row Sources</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Sorted row Sources" summary="This 2 column table shows two sorted row sources." frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e5804">e1 Sorted (Step 2 of Plan)</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5806">e2 Sorted (Step 5 of Plan)</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5810" headers="d49855e5804 ">24000 (King)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5810 d49855e5806 ">24000 (King)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5815" headers="d49855e5804 ">17000 (Kochhar)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5815 d49855e5806 ">17000 (Kochhar)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5820" headers="d49855e5804 ">17000 (De Haan)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5820 d49855e5806 ">17000 (De Haan)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5825" headers="d49855e5804 ">14000 (Russell)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5825 d49855e5806 ">14000 (Russell)</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5830" headers="d49855e5804 ">13500 (Partners)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5830 d49855e5806 ">13500 (Partners)</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>The join begins by iterating through the sorted input (<code class="codeph">e1</code>), which is the left branch of the join, corresponding to Step 2 of the plan. The original query contains two predicates:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">e1.sal &gt;= e2.sal&#x2013;100</code>, which is the Step 5 filter
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">e1.sal &gt;= e2.sal+100</code>, which is the Step 4 filter
                                 </p>
                              </li>
                           </ul>
                           <p>For each iteration of the sorted row source <code class="codeph">e1</code>, the database iterates through row source <code class="codeph">e2</code>, checking every row against Step 5 filter <code class="codeph">e1.sal &gt;= e2.sal&#x2013;100</code>. If the row passes the Step 5 filter, then the database sends it to the Step 4 filter, and then proceeds to test the next row in <code class="codeph">e2</code> against the Step 5 filter. However, if a row fails the Step 5 filter, then the scan of <code class="codeph">e2</code> stops, and the database proceeds through the next iteration of <code class="codeph">e1</code>.
                           </p>
                           <p>The following table shows the first iteration of <code class="codeph">e1</code>, which begins with <code class="codeph">24000 (King)</code> in data set <code class="codeph">e1</code>. The database determines that the first row in <code class="codeph">e2</code>, which is <code class="codeph">24000 (King)</code>, passes the Step 5 filter. The database then sends the row to the Step 4 filter, <code class="codeph">e1.sal &lt;= w2.sal+100</code>, which also passes. The database sends this row to the <code class="codeph">MERGE</code> row source. Next, the database checks <code class="codeph">17000 (Kochhar)</code> against the Step 5 filter, which also passes. However, the row fails the Step 4 filter, and is discarded. The database proceeds to test <code class="codeph">17000 (De Haan)</code> against the Step 5 filter.
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-D8F05E91-0510-47D4-9CA1-6BFF08BAB63A">
                              <p class="titleintable">Table 9-9 First Iteration of e1: Separate SORT JOIN and FILTER</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="First Iteration of e1: Separate SORT JOIN and FILTER" summary="This 3 column table shows the how the database tests the predicates." frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e5912">Scan e2</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5914">Step 5 Filter (e1.sal &gt;= e2.sal&#x2013;100)</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5916">Step 4 Filter (e1.sal &lt;= e2.sal+100)</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5920" headers="d49855e5912 ">24000 (King)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5920 d49855e5914 ">Pass because 24000 &gt;= 23900. Send to Step 4 filter.</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5920 d49855e5916 ">Pass because 24000 &lt;= 24100. Return row for merging.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5927" headers="d49855e5912 ">17000 (Kochhar)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5927 d49855e5914 ">Pass because 24000 &gt;= 16900. Send to Step 4 filter.</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5927 d49855e5916 ">Fail because 24000 &lt;=17100 is false. Discard row. Scan next row in e2.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5934" headers="d49855e5912 ">17000 (De Haan)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5934 d49855e5914 ">Pass because 24000 &gt;= 16900. Send to Step 4 filter.</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5934 d49855e5916 ">Fail because 24000 &lt;=17100 is false. Discard row. Scan next row in e2.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5941" headers="d49855e5912 ">14000 (Russell)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5941 d49855e5914 ">Pass because 24000 &gt;= 13900. Send to Step 4 filter.</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5941 d49855e5916 ">Fail because 24000 &lt;=14100 is false. Discard row. Scan next row in e2.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5948" headers="d49855e5912 ">13500 (Partners)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5948 d49855e5914 ">Pass because 24000 &gt;= 13400. Send to Step 4 filter.</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5948 d49855e5916 ">Fail because 24000 &lt;=13600 is false. Discard row. Scan next row in e2.</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>As shown in the preceding table, every <code class="codeph">e2</code> row necessarily passes the Step 5 filter because the <code class="codeph">e2</code> salaries are sorted in descending order. Thus, the Step 5 filter always sends the row to the Step 4 filter. Because the <code class="codeph">e2</code> salaries are sorted in descending order, the Step 4 filter necessarily fails every row starting with <code class="codeph">17000 (Kochhar)</code>. The inefficiency occurs because the database tests every subsequent row in <code class="codeph">e2</code> against the Step 5 filter, which necessarily passes, and then against the Step 4 filter, which necessarily fails.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-842FE436-2DFC-41E7-B0E0-FD92374A44E7">
                           <p class="titleinexample">Example 9-8 Query With Band Join Optimization</p>
                           <p>Starting in <span>Oracle Database 12c</span> Release 2 (12.2), the database optimizes the band join by using the following plan, which does not have a separate <code class="codeph">FILTER</code> operation:
                           </p><pre class="pre codeblock"><code>------------------------------------------
PLAN_TABLE_OUTPUT
------------------------------------------
| Id  | Operation            | Name      |
------------------------------------------
|   0 | SELECT STATEMENT     |           |
|   1 |  MERGE JOIN          |           |
|   2 |   SORT JOIN          |           |
|   3 |    TABLE ACCESS FULL | EMPLOYEES |
|*  4 |   SORT JOIN          |           |
|   5 |    TABLE ACCESS FULL | EMPLOYEES |
------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   4 - access(INTERNAL_FUNCTION("E1"."SALARY")&gt;="E2"."SALARY"-100)
       filter(("E1"."SALARY"&lt;="E2"."SALARY"+100 AND
	      INTERNAL_FUNCTION("E1"."SALARY")&gt;="E2"."SALARY"-100))
</code></pre><p>The difference is that Step 4 uses Boolean <code class="codeph">AND</code> logic for the two predicates to create a <span class="italic">single</span> filter. Instead of checking a row against one filter, and then sending it to a different row source for checking against a second filter, the database performs one check against one filter. If the check fails, then processing stops.
                           </p>
                           <p>In this example, the query begins the first iteration of <code class="codeph">e1</code>, which begins with <code class="codeph">24000 (King)</code>. The following figure represents the range. <code class="codeph">e2</code> values below 23900 and above 24100 fall outside the range.
                           </p>
                           <div class="figure" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-87B05029-908E-40C2-A398-E60C92FF5FE1">
                              <p class="titleinfigure">Figure 9-7 Band Join</p><img src="img/tgsql_vm_097.png" alt="Description of Figure 9-7 follows" title="Description of Figure 9-7 follows" longdesc="img_text/tgsql_vm_097.html"><br><a href="img_text/tgsql_vm_097.html">Description of "Figure 9-7 Band Join"</a></div>
                           <!-- class="figure" -->
                           <p>The following table shows that the database tests the first row of <code class="codeph">e2</code>, which is <code class="codeph">24000 (King)</code>, against the Step 4 filter. The row passes the test, so the database sends the row to be merged. The next row in <code class="codeph">e2</code> is <code class="codeph">17000 (Kochhar)</code>. This row falls outside of the range (band) and thus does not satisfy the filter predicate, so the database stops testing <code class="codeph">e2</code> rows in this iteration. The database stops testing because the descending sort of <code class="codeph">e2</code> ensures that all subsequent rows in <code class="codeph">e2</code> fail the filter test. Thus, the database can proceed to the second iteration of <code class="codeph">e1</code>.
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-FFB9F10C-AB03-4AB5-8B2E-DD725B842FE0">
                              <p class="titleintable">Table 9-10 First Iteration of e1: Single SORT JOIN</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="First Iteration of e1: Single SORT JOIN" summary="This 2 column table describes the processing a row source using a sort merge join." frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e6045">Scan e2</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e6047">Filter 4 (e1.sal &gt;= e2.sal &#x2013; 100) AND (e1.sal &lt;= e2.sal + 100)</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6051" headers="d49855e6045 ">24000 (King)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6051 d49855e6047 ">
                                          <p>Passes test because it is true that <code class="codeph">(24000 &gt;= 23900) AND (24000 &lt;= 24100)</code>. 
                                          </p>
                                          <p>Send row to <code class="codeph">MERGE</code>. Test next row.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6065" headers="d49855e6045 ">17000 (Kochhar)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6065 d49855e6047 ">
                                          <p>Fails test because it is false that <code class="codeph">(24000 &gt;= 16900) AND (24000 &lt;= 17100)</code>.
                                          </p>
                                          <p>Stop scanning <code class="codeph">e2</code>. Begin next iteration of <code class="codeph">e1</code>.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6082" headers="d49855e6045 ">17000 (De Haan)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6082 d49855e6047 ">n/a</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6087" headers="d49855e6045 ">14000 (Russell)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6087 d49855e6047 ">n/a</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6092" headers="d49855e6045 ">13500 (Partners)</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6092 d49855e6047 ">n/a</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>In this way, the band join optimization eliminates unnecessary processing. Instead of scanning every row in <code class="codeph">e2</code> as in the unoptimized case, the database scans only the minimum two rows.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="An inner join (sometimes called a simple join) is a join that returns only rows that satisfy the join condition. Inner joins are either equijoins or nonequijoins.">Inner Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94989"></a><div class="props_rev_3"><a id="GUID-2174C4BA-C852-4050-9269-353A3B40B355" name="GUID-2174C4BA-C852-4050-9269-353A3B40B355"></a><h4 id="TGSQL-GUID-2174C4BA-C852-4050-9269-353A3B40B355" class="sect4"><span class="enumeration_section">9.3.2 </span>Outer Joins
                  </h4>
                  <div>
                     <p>An <strong class="term">outer join</strong> returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.
                     </p>
                     <p>In ANSI syntax, the <code class="codeph">OUTER JOIN</code> clause specifies an outer join. In the <code class="codeph">FROM</code> clause, the <a href="glossary.html#GUID-3171DB52-9306-4B3F-A30C-052CDD5EBB60"><span class="xrefglossterm">left table</span></a> appears to the left of the <code class="codeph">OUTER JOIN</code> keywords, and the <a href="glossary.html#GUID-462FD89A-89C8-4C2F-8376-EEADD7460082"><span class="xrefglossterm">right table</span></a> appears to the right of these keywords. The left table is also called the <span class="italic">outer table</span>, and the right table is also called the <span class="italic">inner table</span>. For example, in the following statement the <code class="codeph">employees</code> table is the left or outer table:
                     </p><pre class="pre codeblock"><code>SELECT employee_id, last_name, first_name
FROM   employees LEFT OUTER JOIN departments
ON     (employees.department_id=departments.departments_id);
</code></pre><p>Outer joins require the outer-joined table to be the driving table. In the preceding example, <code class="codeph">employees</code> is the driving table, and <code class="codeph">departments</code> is the driven-to table.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E">Nested Loops Outer Joins</a><br>The database uses this operation to loop through an outer join between two tables. The outer join returns the outer (preserved) table rows, even when no corresponding rows are in the inner (optional) table.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-278E01B5-9498-40EC-B0BD-CC415C18E078">Hash Join Outer Joins</a><br>The optimizer uses hash joins for processing an outer join when either the data volume is large enough to make a hash join efficient, or it is impossible to drive from the outer table to the inner table.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD">Sort Merge Outer Joins</a><br>When an outer join cannot drive from the outer (preserved) table to the inner (optional) table, it cannot use a hash join or nested loops joins.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0">Full Outer Joins</a><br>A <strong class="term">full outer join</strong> is a combination of the left and right outer joins.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD">Multiple Tables on the Left of an Outer Join</a><br>In <span>Oracle Database 12c</span>, multiple tables may exist on the left side of an outer-joined table.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94990"></a><div class="props_rev_3"><a id="GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E" name="GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E"></a><h5 id="TGSQL-GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E" class="sect5"><span class="enumeration_section">9.3.2.1 </span>Nested Loops Outer Joins
                     </h5>
                     <div>
                        <p>The database uses this operation to loop through an outer join between two tables. The outer join returns the outer (preserved) table rows, even when no corresponding rows are in the inner (optional) table.</p>
                        <p>In a standard nested loop, the optimizer chooses the order of tableswhich is the driving table and which the driven tablebased on the cost. However, in a nested loop outer join, the join condition determines the order of tables. The database uses the outer, row-preserved table to drive to the inner table.</p>
                        <p>The optimizer uses nested loops joins to process an outer join in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It is possible to drive from the outer table to the inner table.</p>
                           </li>
                           <li>
                              <p>Data volume is low enough to make the nested loop method efficient.</p>
                           </li>
                        </ul>
                        <p>For an example of a nested loop outer join, you can add the <code class="codeph">USE_NL</code> hint to <a href="joins.html#GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABCIBBJ">Example 9-9</a> to instruct the optimizer to use a nested loop. For example:
                        </p><pre class="pre codeblock"><code>SELECT /*+ USE_NL(c o) */ cust_last_name,
       SUM(NVL2(o.customer_id,0,1)) "Count"
FROM   customers c, orders o
WHERE  c.credit_limit &gt; 1000
AND    c.customer_id = o.customer_id(+)
GROUP BY cust_last_name;</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="An outer join returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.">Outer Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94992"></a><a id="TGSQL94993"></a><a id="TGSQL94991"></a><div class="props_rev_3"><a id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078" name="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078"></a><h5 id="TGSQL-GUID-278E01B5-9498-40EC-B0BD-CC415C18E078" class="sect5"><span class="enumeration_section">9.3.2.2 </span>Hash Join Outer Joins
                     </h5>
                     <div>
                        <p>The optimizer uses hash joins for processing an outer join when either the data volume is large enough to make a hash join efficient, or it is impossible to drive from the outer table to the inner table.</p>
                        <p>The cost determines the order of tables. The outer table, including preserved rows, may be used to build the hash table, or it may be used to probe the hash table.</p>
                        <div class="example" id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABCIBBJ">
                           <p class="titleinexample">Example 9-9 Hash Join Outer Joins</p>
                           <p>This example shows a typical hash join outer join query, and its execution plan. In this example, all the customers with credit limits greater than 1000 are queried. An outer join is needed so that the query captures customers who have no orders. </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The outer table is <code class="codeph">customers</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The inner table is <code class="codeph">orders</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The join preserves the <code class="codeph">customers</code> rows, including those rows without a corresponding row in <code class="codeph">orders</code>.
                                 </p>
                              </li>
                           </ul>
                           <p>You could use a <code class="codeph">NOT EXISTS</code> subquery to return the rows. However, because you are querying all the rows in the table, the hash join performs better (unless the <code class="codeph">NOT EXISTS</code> subquery is not nested).
                           </p><pre class="pre codeblock"><code>SELECT cust_last_name, SUM(NVL2(o.customer_id,0,1)) "Count"
FROM   customers c, orders o
WHERE  c.credit_limit &gt; 1000
AND    c.customer_id = o.customer_id(+)
GROUP BY cust_last_name;

--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
|  0 | SELECT STATEMENT    |           |       |       |     7 (100)|          |
|  1 |  HASH GROUP BY      |           |   168 |  3192 |     7  (29)| 00:00:01 |
|* 2 |   <span class="bold">HASH JOIN OUTER</span>   |           |   318 |  6042 |     6  (17)| 00:00:01 |
|* 3 |    TABLE ACCESS FULL| CUSTOMERS |   260 |  3900 |     3   (0)| 00:00:01 |
|* 4 |    TABLE ACCESS FULL| ORDERS    |   105 |   420 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("C"."CUSTOMER_ID"="O"."CUSTOMER_ID")
 
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------
   3 - filter("C"."CREDIT_LIMIT"&gt;1000)
   4 - filter("O"."CUSTOMER_ID"&gt;0)</code></pre><p>The query looks for customers which satisfy various conditions. An outer join returns <code class="codeph">NULL</code> for the inner table columns along with the outer (preserved) table rows when it does not find any corresponding rows in the inner table. This operation finds all the <code class="codeph">customers</code> rows that do not have any <code class="codeph">orders</code> rows.
                           </p>
                           <p>In this case, the outer join condition is the following:</p><pre class="pre codeblock"><code>customers.customer_id = orders.customer_id(+)
</code></pre><p>The components of this condition represent the following:</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABIDIAB">
                           <p class="titleinexample">Example 9-10 Outer Join to a Multitable View</p>
                           <p>In this example, the outer join is to a multitable view. The optimizer cannot drive into the view like in a normal join or push the predicates, so it builds the entire row set of the view.</p><pre class="pre codeblock"><code>SELECT c.cust_last_name, sum(revenue)
FROM   customers c, v_orders o
WHERE  c.credit_limit &gt; 2000
AND    o.customer_id(+) = c.customer_id
GROUP BY c.cust_last_name;

----------------------------------------------------------------------------
| Id  | Operation              |  Name        | Rows  | Bytes | Cost (%CPU)|
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |              |   144 |  4608 |    16  (32)|
|   1 |  HASH GROUP BY         |              |   144 |  4608 |    16  (32)|
|*  2 |   HASH JOIN OUTER      |              |   663 | 21216 |    15  (27)|
|*  3 |    TABLE ACCESS FULL   | CUSTOMERS    |   195 |  2925 |     6  (17)|
|   4 |    VIEW                | V_ORDERS     |   665 | 11305 |            |
|   5 |     HASH GROUP BY      |              |   665 | 15960 |     9  (34)|
|*  6 |      HASH JOIN         |              |   665 | 15960 |     8  (25)|
|*  7 |       TABLE ACCESS FULL| ORDERS       |   105 |   840 |     4  (25)|
|   8 |       TABLE ACCESS FULL| ORDER_ITEMS  |   665 | 10640 |     4  (25)|
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O"."CUSTOMER_ID"(+)="C"."CUSTOMER_ID")
   3 - filter("C"."CREDIT_LIMIT"&gt;2000)
   6 - access("O"."ORDER_ID"="L"."ORDER_ID")
   7 - filter("O"."CUSTOMER_ID"&gt;0)
</code></pre><p>The view definition is as follows:</p><pre class="pre codeblock"><code>CREATE OR REPLACE view v_orders AS
SELECT l.product_id, SUM(l.quantity*unit_price) revenue, 
       o.order_id, o.customer_id
FROM   orders o, order_items l
WHERE  o.order_id = l.order_id
GROUP BY l.product_id, o.order_id, o.customer_id;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="An outer join returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.">Outer Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94994"></a><div class="props_rev_3"><a id="GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD" name="GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD"></a><h5 id="TGSQL-GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD" class="sect5"><span class="enumeration_section">9.3.2.3 </span>Sort Merge Outer Joins
                     </h5>
                     <div>
                        <p>When an outer join cannot drive from the outer (preserved) table to the inner (optional) table, it cannot use a hash join or nested loops joins.</p>
                        <p>In this case, it uses the sort merge outer join.</p>
                        <p>The optimizer uses sort merge for an outer join in the following cases:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A nested loops join is inefficient. A nested loops join can be inefficient because of data volumes.</p>
                           </li>
                           <li>
                              <p>The optimizer finds it is cheaper to use a sort merge over a hash join because of sorts required by other operations.</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="An outer join returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.">Outer Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94996"></a><a id="TGSQL94997"></a><a id="TGSQL94995"></a><div class="props_rev_3"><a id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0" name="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0"></a><h5 id="TGSQL-GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0" class="sect5"><span class="enumeration_section">9.3.2.4 </span>Full Outer Joins
                     </h5>
                     <div>
                        <p>A <strong class="term">full outer join</strong> is a combination of the left and right outer joins.
                        </p>
                        <p>In addition to the inner join, rows from both tables that have not been returned in the result of the inner join are preserved and extended with nulls. In other words, full outer joins join tables together, yet show rows with no corresponding rows in the joined tables.</p>
                        <div class="example" id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABCHEAG">
                           <p class="titleinexample">Example 9-11 Full Outer Join</p>
                           <p>The following query retrieves all departments and all employees in each department, but also includes: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Any employees without departments </p>
                              </li>
                              <li>
                                 <p>Any departments without employees</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>SELECT d.department_id, e.employee_id
FROM   employees e FULL OUTER JOIN departments d
ON     e.department_id = d.department_id
ORDER BY d.department_id;
</code></pre><p>The statement produces the following output: </p><pre class="pre codeblock"><code>DEPARTMENT_ID EMPLOYEE_ID
------------- -----------
           10         200
           20         201
           20         202
           30         114
           30         115
           30         116
...
          270
          280
                      178
                      207

125 rows selected.
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABIJCIF">
                           <p class="titleinexample">Example 9-12 Execution Plan for a Full Outer Join</p>
                           <p>Starting with Oracle Database 11<span class="italic">g</span>, Oracle Database automatically uses a native execution method based on a hash join for executing full outer joins whenever possible. When the database uses the new method to execute a full outer join, the execution plan for the query contains <code class="codeph">HASH JOIN FULL OUTER</code>. The query in <a href="joins.html#GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABCHEAG">Example 9-11</a> uses the following execution plan:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation               | Name       |Rows |Bytes |Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT        |            | 122 | 4758 |   6  (34)| 00:0 0:01 |
| 1 |  SORT ORDER BY          |            | 122 | 4758 |   6  (34)| 00:0 0:01 |
| 2 |   VIEW                  | VW_FOJ_0   | 122 | 4758 |   5  (20)| 00:0 0:01 |
|*3 |    <span class="bold">HASH JOIN FULL OUTER</span> |            | 122 | 1342 |   5  (20)| 00:0 0:01 |
| 4 |     INDEX FAST FULL SCAN| DEPT_ID_PK |  27 |  108 |   2   (0)| 00:0 0:01 |
| 5 |     TABLE ACCESS FULL   | EMPLOYEES  | 107 |  749 |   2   (0)| 00:0 0:01 |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p><code class="codeph">HASH JOIN FULL OUTER</code> is included in the preceding plan (Step 3), indicating that the query uses the hash full outer join execution method. Typically, when the full outer join condition between two tables is an equijoin, the hash full outer join execution method is possible, and Oracle Database uses it automatically.
                           </p>
                           <p>To instruct the optimizer to consider using the hash full outer join execution method, apply the <code class="codeph">NATIVE_FULL_OUTER_JOIN</code> hint. To instruct the optimizer not to consider using the hash full outer join execution method, apply the <code class="codeph">NO_NATIVE_FULL_OUTER_JOIN</code> hint. The <code class="codeph">NO_NATIVE_FULL_OUTER_JOIN</code> hint instructs the optimizer to exclude the native execution method when joining each specified table. Instead, the full outer join is executed as a union of left outer join and an antijoin.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="An outer join returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.">Outer Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95113"></a><div class="props_rev_3"><a id="GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD" name="GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD"></a><h5 id="TGSQL-GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD" class="sect5"><span class="enumeration_section">9.3.2.5 </span>Multiple Tables on the Left of an Outer Join
                     </h5>
                     <div>
                        <p>In <span>Oracle Database 12c</span>, multiple tables may exist on the left side of an outer-joined table.
                        </p>
                        <p>This enhancement enables Oracle Database to merge a view that contains multiple tables and appears on the left of the outer join. In releases before <span>Oracle Database 12c</span>, a query such as the following was invalid, and would trigger an <code class="codeph">ORA-01417</code> error message:
                        </p><pre class="pre codeblock"><code>SELECT t1.d, t3.c
FROM   t1, t2, t3
WHERE  t1.z = t2.z 
AND    t1.x = t3.x (+) 
AND    t2.y = t3.y (+);
</code></pre><p>Starting in <span>Oracle Database 12c</span>, the preceding query is valid.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="An outer join returns all rows that satisfy the join condition and also rows from one table for which no rows from the other table satisfy the condition. Thus, the result set of an outer join is the superset of an inner join.">Outer Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95241"></a><div class="props_rev_3"><a id="GUID-816CED08-10A7-4B39-9790-E68996782847" name="GUID-816CED08-10A7-4B39-9790-E68996782847"></a><h4 id="TGSQL-GUID-816CED08-10A7-4B39-9790-E68996782847" class="sect4"><span class="enumeration_section">9.3.3 </span>Semijoins
                  </h4>
                  <div>
                     <p>A <strong class="term">semijoin</strong> is a join between two data sets that returns a row from the first set when a matching row exists in the subquery data set.
                     </p>
                     <p>The database stops processing the second data set at the first match. Thus, optimization does not duplicate rows from the first data set when multiple rows in the second data set satisfy the subquery criteria.</p>
                     <div class="infoboxnote" id="GUID-816CED08-10A7-4B39-9790-E68996782847__GUID-BC796732-679A-4CC9-AFD2-750CCFE5F68E">
                        <p class="notep1">Note:</p>
                        <p>Semijoins and antijoins are considered join types even though the SQL constructs that cause them are subqueries. They are internal algorithms that the optimizer uses to flatten subquery constructs so that they can be resolved in a join-like way.</p>
                     </div>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B">When the Optimizer Considers Semijoins</a><br>A semijoin avoids returning a huge number of rows when a query only needs to determine whether a match exists.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-B3DE9781-0579-44D1-A7B5-3132504590E2">How Semijoins Work</a><br>The semijoin optimization is implemented differently depending on what type of join is used. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95315"></a><div class="props_rev_3"><a id="GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B" name="GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B"></a><h5 id="TGSQL-GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B" class="sect5"><span class="enumeration_section">9.3.3.1 </span>When the Optimizer Considers Semijoins
                     </h5>
                     <div>
                        <p>A semijoin avoids returning a huge number of rows when a query only needs to determine whether a match exists.</p>
                        <p>With large data sets, this optimization can result in significant time savings over a nested loops join that must loop through every record returned by the inner query for every row in the outer query. The optimizer can apply the semijoin optimization to nested loops joins, hash joins, and sort merge joins.</p>
                        <p>The optimizer may choose a semijoin in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The statement uses either an <code class="codeph">IN</code> or <code class="codeph">EXISTS</code> clause.
                              </p>
                           </li>
                           <li>
                              <p>The statement contains a subquery in the <code class="codeph">IN</code> or <code class="codeph">EXISTS</code> clause. 
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">IN</code> or <code class="codeph">EXISTS</code> clause is not contained inside an <code class="codeph">OR</code> branch.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847" title="A semijoin is a join between two data sets that returns a row from the first set when a matching row exists in the subquery data set.">Semijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95317"></a><a id="TGSQL95318"></a><a id="TGSQL95316"></a><div class="props_rev_3"><a id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2" name="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2"></a><h5 id="TGSQL-GUID-B3DE9781-0579-44D1-A7B5-3132504590E2" class="sect5"><span class="enumeration_section">9.3.3.2 </span>How Semijoins Work
                     </h5>
                     <div>
                        <p>The semijoin optimization is implemented differently depending on what type of join is used. </p>
                        <p>The following pseudocode shows a semijoin for a nested loops join:</p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP
  match := false;
  FOR ds2_row IN ds2_subquery LOOP
    IF (ds1_row matches ds2_row) THEN
      match := true;
      EXIT -- stop processing second data set when a match is found
    END IF
  END LOOP
  IF (match = true) THEN 
    RETURN ds1_row
  END IF
END LOOP
</code></pre><p>In the preceding pseudocode, <code class="codeph">ds1</code> is the first data set, and <code class="codeph">ds2_subquery</code> is the subquery data set. The code obtains the first row from the first data set, and then loops through the subquery data set looking for a match. The code exits the inner loop as soon as it finds a match, and then begins processing the next row in the first data set.
                        </p>
                        <div class="example" id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__BABGCCDA">
                           <p class="titleinexample">Example 9-13 Semijoin Using WHERE EXISTS</p>
                           <p>The following query uses a <code class="codeph">WHERE EXISTS</code> clause to list only the departments that contain employees:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name 
FROM   departments
WHERE EXISTS (SELECT 1
              FROM   employees 
              WHERE  employees.department_id = departments.department_id)
</code></pre><p>The execution plan reveals a <code class="codeph">NESTED LOOPS SEMI</code> operation in Step 1:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation          | Name              |Rows|Bytes|Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT   |                   |    |     |    2 (100)|          |
| 1 |  <span class="bold">NESTED LOOPS SEMI</span> |                   | 11 | 209 |    2   (0)| 00:00:01 |
| 2 |   TABLE ACCESS FULL| DEPARTMENTS       | 27 | 432 |    2   (0)| 00:00:01 |
|*3 |   INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 | 132 |    0   (0)|          |
--------------------------------------------------------------------------------
</code></pre><p>For each row in <code class="codeph">departments</code>, which forms the outer loop, the database obtains the department ID, and then probes the <code class="codeph">employees.department_id</code> index for matching entries. Conceptually, the index looks as follows:
                           </p><pre class="pre codeblock"><code>10,rowid
10,rowid
10,rowid
10,rowid
30,rowid
30,rowid
30,rowid
...
</code></pre><p>If the first entry in the <code class="codeph">departments</code> table is department <code class="codeph">30</code>, then the database performs a range scan of the index until it finds the first <code class="codeph">30</code> entry, at which point it stops reading the index and returns the matching row from <code class="codeph">departments</code>. If the next row in the outer loop is department <code class="codeph">20</code>, then the database scans the index for a <code class="codeph">20</code> entry, and not finding any matches, performs the next iteration of the outer loop. The database proceeds in this way until all matching rows are returned.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__GUID-44A64557-19FF-4B01-89BD-0CC6FFAA927C">
                           <p class="titleinexample">Example 9-14 Semijoin Using IN</p>
                           <p>The following query uses a <code class="codeph">IN</code> clause to list only the departments that contain employees:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name
FROM   departments
WHERE  department_id IN 
       (SELECT department_id 
        FROM   employees); 
</code></pre><p>The execution plan reveals a <code class="codeph">NESTED LOOPS SEMI</code> operation in Step 1:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation          | Name              |Rows|Bytes|Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT   |                   |    |     |    2 (100)|          |
| 1 |  <span class="bold">NESTED LOOPS SEMI</span> |                   | 11 | 209 |    2   (0)| 00:00:01 |
| 2 |   TABLE ACCESS FULL| DEPARTMENTS       | 27 | 432 |    2   (0)| 00:00:01 |
|*3 |   INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 | 132 |    0   (0)|          |
--------------------------------------------------------------------------------
</code></pre><p>The plan is identical to the plan in <a href="joins.html#GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__BABGCCDA">Example 9-13</a>.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847" title="A semijoin is a join between two data sets that returns a row from the first set when a matching row exists in the subquery data set.">Semijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95320"></a><div class="props_rev_3"><a id="GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" name="GUID-084D65F8-0517-4B85-960F-F1CDEE69C693"></a><h4 id="TGSQL-GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" class="sect4"><span class="enumeration_section">9.3.4 </span>Antijoins
                  </h4>
                  <div>
                     <p>An <strong class="term">antijoin</strong> is a join between two data sets that returns a row from the first set when a matching row does not exist in the subquery data set. 
                     </p>
                     <p>Like a semijoin, an antijoin stops processing the subquery data set when the first match is found. Unlike a semijoin, the antijoin only returns a row when no match is found.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876">When the Optimizer Considers Antijoins</a><br>An antijoin avoids unnecessary processing when a query only needs to return a row when a match does not exist. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3">How Antijoins Work</a><br>The antijoin optimization is implemented differently depending on what type of join is used. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8">How Antijoins Handle Nulls</a><br>For semijoins, <code class="codeph">IN</code> and <code class="codeph">EXISTS</code> are functionally equivalent. However, <code class="codeph">NOT IN</code> and <code class="codeph">NOT EXISTS</code> are not functionally equivalent because of nulls.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95321"></a><div class="props_rev_3"><a id="GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876" name="GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876"></a><h5 id="TGSQL-GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876" class="sect5"><span class="enumeration_section">9.3.4.1 </span>When the Optimizer Considers Antijoins
                     </h5>
                     <div>
                        <p>An antijoin avoids unnecessary processing when a query only needs to return a row when a match does not exist. </p>
                        <p>With large data sets, this optimization can result in significant time savings over a nested loops join. The latter join must loop through every record returned by the inner query for every row in the outer query. The optimizer can apply the antijoin optimization to nested loops joins, hash joins, and sort merge joins.</p>
                        <p>The optimizer may choose an antijoin in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The statement uses either the <code class="codeph">NOT IN</code> or <code class="codeph">NOT EXISTS</code> clause.
                              </p>
                           </li>
                           <li>
                              <p>The statement has a subquery in the <code class="codeph">NOT IN</code> or <code class="codeph">NOT EXISTS</code> clause. 
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">NOT IN</code> or <code class="codeph">NOT EXISTS</code> clause is not contained inside an <code class="codeph">OR</code> branch.
                              </p>
                           </li>
                           <li>
                              <p>The statement performs an outer join and applies an <code class="codeph">IS NULL</code> condition to a join column, as in the following example:
                              </p><pre class="pre codeblock"><code>SET AUTOTRACE TRACEONLY EXPLAIN
SELECT emp.*
FROM   emp, dept
WHERE  emp.deptno = dept.deptno(+)
AND    dept.deptno IS NULL

Execution Plan
----------------------------------------------------------
Plan hash value: 1543991079
 
---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |    14 |  1400 |     5  (20)| 00:00:01 |
|*  1 |  HASH JOIN ANTI    |      |    14 |  1400 |     5  (20)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| EMP  |    14 |  1218 |     2   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("EMP"."DEPTNO"="DEPT"."DEPTNO")
 
Note
-----
   - dynamic statistics used: dynamic sampling (level=2)</code></pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="An antijoin is a join between two data sets that returns a row from the first set when a matching row does not exist in the subquery data set.">Antijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95323"></a><a id="TGSQL95322"></a><div class="props_rev_3"><a id="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3" name="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3"></a><h5 id="TGSQL-GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3" class="sect5"><span class="enumeration_section">9.3.4.2 </span>How Antijoins Work
                     </h5>
                     <div>
                        <p>The antijoin optimization is implemented differently depending on what type of join is used. </p>
                        <p>The following pseudocode shows an antijoin for a nested loops join:</p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP
  match := true;
  FOR ds2_row IN ds2 LOOP
    IF (ds1_row matches ds2_row) THEN
      match := false;
      EXIT -- stop processing second data set when a match is found
    END IF
  END LOOP
  IF (match = true) THEN 
    RETURN ds1_row
  END IF
END LOOP
</code></pre><p>In the preceding pseudocode, <code class="codeph">ds1</code> is the first data set, and <code class="codeph">ds2</code> is the second data set. The code obtains the first row from the first data set, and then loops through the second data set looking for a match. The code exits the inner loop as soon as it finds a match, and begins processing the next row in the first data set.
                        </p>
                        <div class="example" id="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3__GUID-303A36E3-2961-4385-9A5A-4A3B85482BDA">
                           <p class="titleinexample">Example 9-15 Semijoin Using WHERE EXISTS</p>
                           <p>The following query uses a <code class="codeph">WHERE EXISTS</code> clause to list only the departments that contain employees:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name 
FROM   departments
WHERE EXISTS (SELECT 1
              FROM   employees 
              WHERE  employees.department_id = departments.department_id)
</code></pre><p>The execution plan reveals a <code class="codeph">NESTED LOOPS SEMI</code> operation in Step 1:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation          | Name              |Rows|Bytes |Cost(%CPU)| Time     |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT   |                   |    |      |   2 (100)|          |
| 1 |  <span class="bold">NESTED LOOPS SEMI</span> |                   | 11 |  209 |   2   (0)| 00:00:01 |
| 2 |   TABLE ACCESS FULL| DEPARTMENTS       | 27 |  432 |   2   (0)| 00:00:01 |
|*3 |   INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 |  132 |   0   (0)|          |
--------------------------------------------------------------------------------
</code></pre><p>For each row in <code class="codeph">departments</code>, which forms the outer loop, the database obtains the department ID, and then probes the <code class="codeph">employees.department_id</code> index for matching entries. Conceptually, the index looks as follows:
                           </p><pre class="pre codeblock"><code>10,rowid
10,rowid
10,rowid
10,rowid
30,rowid
30,rowid
30,rowid
...
</code></pre><p>If the first record in the <code class="codeph">departments</code> table is department <code class="codeph">30</code>, then the database performs a range scan of the index until it finds the first <code class="codeph">30</code> entry, at which point it stops reading the index and returns the matching row from <code class="codeph">departments</code>. If the next row in the outer loop is department <code class="codeph">20</code>, then the database scans the index for a <code class="codeph">20</code> entry, and not finding any matches, performs the next iteration of the outer loop. The database proceeds in this way until all matching rows are returned.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="An antijoin is a join between two data sets that returns a row from the first set when a matching row does not exist in the subquery data set.">Antijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95325"></a><a id="TGSQL95326"></a><a id="TGSQL95324"></a><div class="props_rev_3"><a id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8" name="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8"></a><h5 id="TGSQL-GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8" class="sect5"><span class="enumeration_section">9.3.4.3 </span>How Antijoins Handle Nulls
                     </h5>
                     <div>
                        <p>For semijoins, <code class="codeph">IN</code> and <code class="codeph">EXISTS</code> are functionally equivalent. However, <code class="codeph">NOT IN</code> and <code class="codeph">NOT EXISTS</code> are not functionally equivalent because of nulls.
                        </p>
                        <p>If a null value is returned to a <code class="codeph">NOT IN</code> operator, then the statement returns no records. To see why, consider the following <code class="codeph">WHERE</code> clause:
                        </p><pre class="pre codeblock"><code>WHERE department_id NOT IN (null, 10, 20)
</code></pre><p>The database tests the preceding expression as follows:</p><pre class="pre codeblock"><code>WHERE (department_id != null) 
AND   (department_id != 10) 
AND   (department_id != 20)
</code></pre><p>For the entire expression to be <code class="codeph">true</code>, each individual condition must be <code class="codeph">true</code>. However, a null value cannot be compared to another value, so the <code class="codeph">department_id !=null</code> condition cannot be <code class="codeph">true</code>, and thus the whole expression is always <code class="codeph">false</code>. The following techniques enable a statement to return records even when nulls are returned to the <code class="codeph">NOT IN</code> operator:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Apply an <code class="codeph">NVL</code> function to the columns returned by the subquery.
                              </p>
                           </li>
                           <li>
                              <p>Add an <code class="codeph">IS NOT NULL</code> predicate to the subquery.
                              </p>
                           </li>
                           <li>
                              <p>Implement <code class="codeph">NOT NULL</code> constraints.
                              </p>
                           </li>
                        </ul>
                        <p>In contrast to <code class="codeph">NOT IN</code>, the <code class="codeph">NOT EXISTS</code> clause only considers predicates that return the existence of a match, and ignores any row that does not match or could not be determined because of nulls. If at least one row in the subquery matches the row from the outer query, then <code class="codeph">NOT EXISTS</code> returns <code class="codeph">false</code>. If no tuples match, then <code class="codeph">NOT EXISTS </code>returns <code class="codeph">true</code>. The presence of nulls in the subquery does not affect the search for matching records.
                        </p>
                        <p>In releases earlier than <span>Oracle Database 11g</span>, the optimizer could not use an antijoin optimization when nulls could be returned by a subquery. However, starting in <span>Oracle Database 11g</span>, the <code class="codeph">ANTI NA</code> (and <code class="codeph">ANTI SNA</code>) optimizations described in the following sections enable the optimizer to use an antijoin even when nulls are possible.
                        </p>
                        <div class="example" id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8__GUID-1069AEBC-187C-41B2-AC0C-A4793780B755">
                           <p class="titleinexample">Example 9-16 Antijoin Using NOT IN</p>
                           <p>Suppose that a user issues the following query with a <code class="codeph">NOT IN</code> clause to list the departments that contain no employees:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name
FROM   departments
WHERE  department_id NOT IN 
       (SELECT department_id 
        FROM   employees);
</code></pre><p>The preceding query returns no rows even though several departments contain no employees. This result, which was not intended by the user, occurs because the <code class="codeph">employees.department_id</code> column is nullable.
                           </p>
                           <p>The execution plan reveals a <code class="codeph">NESTED LOOPS ANTI SNA</code> operation in Step 2:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation              | Name              |Rows|Bytes|Cost (%CPU)| Time |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT       |                   |    |     | 4(100)|          |
|*1 |  FILTER                |                   |    |     |       |          |
| 2 |   <span class="bold">NESTED LOOPS ANTI SNA</span>|                   | 17 | 323 | 4 (50)| 00:00:01 |
| 3 |    TABLE ACCESS FULL   | DEPARTMENTS       | 27 | 432 | 2  (0)| 00:00:01 |
|*4 |    INDEX RANGE SCAN    | EMP_DEPARTMENT_IX | 41 | 123 | 0  (0)|          |
|*5 |   TABLE ACCESS FULL    | EMPLOYEES         |  1 |   3 | 2  (0)| 00:00:01 |
--------------------------------------------------------------------------------
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter( IS NULL)
   4 - access("DEPARTMENT_ID"="DEPARTMENT_ID")
   5 - filter("DEPARTMENT_ID" IS NULL)
</code></pre><p>The <code class="codeph">ANTI SNA</code> stands for "single null-aware antijoin." <code class="codeph">ANTI NA</code> stands for "null-aware antijoin." The null-aware operation enables the optimizer to use the antijoin optimization even on a nullable column. In releases earlier than <span>Oracle Database 11g</span>, the database could not perform antijoins on <code class="codeph">NOT IN</code> queries when nulls were possible.
                           </p>
                           <p>Suppose that the user rewrites the query by applying an <code class="codeph">IS NOT NULL</code> condition to the subquery:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name
FROM   departments
WHERE  department_id NOT IN 
       (SELECT department_id 
        FROM   employees
        WHERE  department_id IS NOT NULL);
</code></pre><p>The preceding query returns 16 rows, which is the expected result. Step 1 in the plan shows a standard <code class="codeph">NESTED LOOPS ANTI</code> join instead of an <code class="codeph">ANTI NA</code> or <code class="codeph">ANTI SNA</code> join because the subquery cannot returns nulls:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
|Id| Operation          | Name              | Rows| Bytes | Cost (%CPU)| Time  |
--------------------------------------------------------------------------------
| 0| SELECT STATEMENT   |                   |     |       |  2 (100)|          |
| 1|  <span class="bold">NESTED LOOPS ANTI</span> |                   |  17 |   323 |  2   (0)| 00:00:01 |
| 2|   TABLE ACCESS FULL| DEPARTMENTS       |  27 |   432 |  2   (0)| 00:00:01 |
|*3|   INDEX RANGE SCAN | EMP_DEPARTMENT_IX |  41 |   123 |  0   (0)|          <span class="italic">|
--------------------------------------------------------------------------------
</span> 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("DEPARTMENT_ID"="DEPARTMENT_ID")
       filter("DEPARTMENT_ID" IS NOT NULL)</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8__GUID-7F2A4EB0-C2CE-43D4-ADF4-CBFDA8BFB351">
                           <p class="titleinexample">Example 9-17 Antijoin Using NOT EXISTS</p>
                           <p>Suppose that a user issues the following query with a <code class="codeph">NOT EXISTS</code> clause to list the departments that contain no employees:
                           </p><pre class="pre codeblock"><code>SELECT department_id, department_name
FROM   departments d
WHERE  NOT EXISTS
       (SELECT null
        FROM   employees e
        WHERE  e.department_id = d.department_id)
</code></pre><p>The preceding query avoids the null problem for <code class="codeph">NOT IN</code> clauses. Thus, even though <code class="codeph">employees.department_id</code> column is nullable, the statement returns the desired result.
                           </p>
                           <p>Step 1 of the execution plan reveals a <code class="codeph">NESTED LOOPS ANTI</code> operation, not the <code class="codeph">ANTI NA</code> variant, which was necessary for <code class="codeph">NOT IN</code> when nulls were possible:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation          | Name              | Rows  | Bytes | Cost (%CPU)|Time|
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT   |                   |       |       | 2 (100)|        |
| 1 |  NESTED LOOPS ANTI |                   |    17 |   323 | 2   (0)|00:00:01|
| 2 |   TABLE ACCESS FULL| DEPARTMENTS       |    27 |   432 | 2   (0)|00:00:01|
|*3 |   INDEX RANGE SCAN | EMP_DEPARTMENT_IX |    41 |   123 | 0   (0)|        |
--------------------------------------------------------------------------------
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="An antijoin is a join between two data sets that returns a row from the first set when a matching row does not exist in the subquery data set.">Antijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94986"></a><div class="props_rev_3"><a id="GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" name="GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC"></a><h4 id="TGSQL-GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" class="sect4"><span class="enumeration_section">9.3.5 </span>Cartesian Joins
                  </h4>
                  <div>
                     <p>The database uses a <strong class="term">Cartesian join</strong> when one or more of the tables does not have any join conditions to any other tables in the statement. 
                     </p>
                     <p>The optimizer joins every row from one data source with every row from the other data source, creating the Cartesian product of the two sets. Therefore, the total number of rows resulting from the join is calculated using the following formula, where <code class="codeph">rs1</code> is the number of rows in first row set and <code class="codeph">rs2</code> is the number of rows in the second row set:
                     </p><pre class="pre codeblock"><code>rs1 X rs2 = total rows in result set</code></pre><p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-11E7100E-1316-4963-83C5-A85940BE9BB6">When the Optimizer Considers Cartesian Joins</a><br>The optimizer uses a Cartesian join for two row sources only in specific circumstances.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67">How Cartesian Joins Work</a><br>A Cartesian join uses nested <code class="codeph">FOR</code> loops.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-10F781A7-4372-4042-AACA-6F67580789E8">Cartesian Join Controls</a><br>The <code class="codeph">ORDERED</code> hint instructs the optimizer to join tables in the order in which they appear in the <code class="codeph">FROM</code> clause. By forcing a join between two row sources that have no direct connection, the optimizer must perform a Cartesian join.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="A join type is determined by the type of join condition.">Join Types</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94987"></a><div class="props_rev_3"><a id="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6" name="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6"></a><h5 id="TGSQL-GUID-11E7100E-1316-4963-83C5-A85940BE9BB6" class="sect5"><span class="enumeration_section">9.3.5.1 </span>When the Optimizer Considers Cartesian Joins
                     </h5>
                     <div>
                        <p>The optimizer uses a Cartesian join for two row sources only in specific circumstances.</p>
                        <p>Typically, the situation is one of the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>No join condition exists.</p>
                              <p>In some cases, the optimizer could pick up a common <a href="glossary.html#GUID-73A2A2BA-68CB-4036-BB5C-3CBB5D799286"><span class="xrefglossterm">filter condition</span></a> between the two tables as a possible join condition.
                              </p>
                              <div class="infoboxnote" id="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6__GUID-40D78C19-08DE-4B54-B787-4288929C179D">
                                 <p class="notep1">Note:</p>
                                 <p>If a Cartesian join appears in a query plan, it could be caused by an inadvertently omitted join condition. In general, if a query joins <span class="italic">n</span> tables, then <span class="italic">n</span>-1 join conditions are required to avoid a Cartesian join.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>A Cartesian join is an efficient method. </p>
                              <p>For example, the optimizer may decide to generate a Cartesian product of two very small tables that are both joined to the same large table.</p>
                           </li>
                           <li>
                              <p>The <code class="codeph">ORDERED</code> hint specifies a table before its join table is specified.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="The database uses a Cartesian join when one or more of the tables does not have any join conditions to any other tables in the statement.">Cartesian Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95334"></a><a id="TGSQL95312"></a><div class="props_rev_3"><a id="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67" name="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67"></a><h5 id="TGSQL-GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67" class="sect5"><span class="enumeration_section">9.3.5.2 </span>How Cartesian Joins Work
                     </h5>
                     <div>
                        <p>A Cartesian join uses nested <code class="codeph">FOR</code> loops.
                        </p>
                        <p>At a high level, the algorithm for a Cartesian join looks as follows, where <code class="codeph">ds1</code> is typically the smaller data set, and <code class="codeph">ds2</code> is the larger data set:
                        </p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP
  FOR ds2_row IN ds2 LOOP
    output ds1_row and ds2_row
  END LOOP
END LOOP</code></pre><div class="example" id="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67__GUID-54BCE493-6E47-4A9B-A816-6C5CB2A6A36D">
                           <p class="titleinexample">Example 9-18 Cartesian Join</p>
                           <p>In this example, a user intends to perform an inner join of the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables, but accidentally leaves off the join condition:
                           </p><pre class="pre codeblock"><code>SELECT e.last_name, d.department_name
FROM   employees e, departments d
</code></pre><p>The execution plan is as follows:</p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation              | Name        | Rows  | Bytes |Cost (%CPU)| Time  |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT       |             |       |       |11 (100)|          |
| 1 |  MERGE JOIN CARTESIAN  |             |  2889 | 57780 |11   (0)| 00:00:01 |
| 2 |   TABLE ACCESS FULL    | DEPARTMENTS |    27 |   324 | 2   (0)| 00:00:01 |
| 3 |   BUFFER SORT          |             |   107 |   856 | 9   (0)| 00:00:01 |
| 4 |    INDEX FAST FULL SCAN| EMP_NAME_IX |   107 |   856 | 0   (0)|          |
--------------------------------------------------------------------------------
</code></pre><p>In Step 1 of the preceding plan, the <code class="codeph">CARTESIAN</code> keyword indicates the presence of a Cartesian join. The number of rows (2889) is the product of 27 and 107. 
                           </p>
                           <p>In Step 3, the <code class="codeph">BUFFER SORT</code> operation indicates that the database is copying the data blocks obtained by the scan of <code class="codeph">emp_name_ix</code> from the SGA to the PGA. This strategy avoids multiple scans of the same blocks in the database buffer cache, which would generate many logical reads and permit resource contention. 
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="The database uses a Cartesian join when one or more of the tables does not have any join conditions to any other tables in the statement.">Cartesian Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95335"></a><a id="TGSQL94988"></a><div class="props_rev_3"><a id="GUID-10F781A7-4372-4042-AACA-6F67580789E8" name="GUID-10F781A7-4372-4042-AACA-6F67580789E8"></a><h5 id="TGSQL-GUID-10F781A7-4372-4042-AACA-6F67580789E8" class="sect5"><span class="enumeration_section">9.3.5.3 </span>Cartesian Join Controls
                     </h5>
                     <div>
                        <p>The <code class="codeph">ORDERED</code> hint instructs the optimizer to join tables in the order in which they appear in the <code class="codeph">FROM</code> clause. By forcing a join between two row sources that have no direct connection, the optimizer must perform a Cartesian join.
                        </p>
                        <div class="example" id="GUID-10F781A7-4372-4042-AACA-6F67580789E8__GUID-AB86E0AE-4B94-422B-A3F0-AAC889EBE7B2">
                           <p class="titleinexample">Example 9-19 ORDERED Hint</p>
                           <p>In the following example, the <code class="codeph">ORDERED</code> hint instructs the optimizer to join <code class="codeph">employees</code> and <code class="codeph">locations</code>, but no join condition connects these two row sources:
                           </p><pre class="pre codeblock"><code>SELECT /*+ORDERED*/ e.last_name, d.department_name, l.country_id, l.state_province
FROM   employees e, locations l, departments d
WHERE  e.department_id = d.department_id
AND    d.location_id = l.location_id
</code></pre><p>The following execution plan shows a Cartesian product (Step 3) between <code class="codeph">locations</code> (Step 6) and <code class="codeph">employees</code> (Step 4), which is then joined to the <code class="codeph">departments</code> table (Step 2):
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id| Operation             | Name        | Rows  | Bytes |Cost (%CPU)|Time    |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT      |             |       |       | 37 (100)|          |
|*1 |  HASH JOIN            |             |   106 |  4664 | 37   (6)| 00:00:01 |
| 2 |   TABLE ACCESS FULL   | DEPARTMENTS |    27 |   513 |  2   (0)| 00:00:01 |
| 3 |   <span class="bold">MERGE JOIN CARTESIAN</span>|             |  2461 | 61525 | 34   (3)| 00:00:01 |
| 4 |    TABLE ACCESS FULL  | EMPLOYEES   |   107 |  1177 |  2   (0)| 00:00:01 |
| 5 |    BUFFER SORT        |             |    23 |   322 | 32   (4)| 00:00:01 |
| 6 |     TABLE ACCESS FULL | LOCATIONS   |    23 |   322 |  0   (0)|          |
--------------------------------------------------------------------------------</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-10F781A7-4372-4042-AACA-6F67580789E8__GUID-B23F120A-6C94-4F5F-8C71-825480526BC0">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50601" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">ORDERED</code> hint
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="The database uses a Cartesian join when one or more of the tables does not have any join conditions to any other tables in the statement.">Cartesian Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL95297"></a><div class="props_rev_3"><a id="GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" name="GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1"></a><h3 id="TGSQL-GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" class="sect3"><span class="enumeration_section">9.4 </span>Join Optimizations
               </h3>
               <div>
                  <p>Join optimizations enable joins to be more efficient.</p>
                  <p>This section describes common join optimizations:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3">Bloom Filters</a><br>A <strong class="term">Bloom filter</strong>, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set. 
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7">Partition-Wise Joins</a><br>A <strong class="term">partition-wise join</strong> is an optimization that divides a large join of two tables, one of which must be partitioned on the join key, into several smaller joins. 
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650">In-Memory Join Groups</a><br>A <span class="bold">join group</span> is a user-created object that lists two or more columns that can be meaningfully joined.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle Database provides several optimizations for joining row sets.">Joins</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95298"></a><div class="props_rev_3"><a id="GUID-C9E0663B-822E-4733-8016-E56A73D903F3" name="GUID-C9E0663B-822E-4733-8016-E56A73D903F3"></a><h4 id="TGSQL-GUID-C9E0663B-822E-4733-8016-E56A73D903F3" class="sect4"><span class="enumeration_section">9.4.1 </span>Bloom Filters
                  </h4>
                  <div>
                     <p>A <strong class="term">Bloom filter</strong>, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set. 
                     </p>
                     <p>A Bloom filter correctly indicates when an element is not in a set, but can incorrectly indicate when an element is in a set. Thus, false negatives are impossible but false positives are possible.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5">Purpose of Bloom Filters</a><br>A Bloom filter tests one set of values to determine whether they are members another set.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D158E3CF-1B10-4391-A1C6-639216623A35">How Bloom Filters Work</a><br>A Bloom filter uses an array of bits to indicate inclusion in a set. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C">Bloom Filter Controls</a><br>The optimizer automatically determines whether to use Bloom filters.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-BB21BC10-031D-4E43-9774-92764BF84FA4">Bloom Filter Metadata</a><br><code class="codeph">V$</code> views contain metadata about Bloom filters.
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077">Bloom Filters: Scenario</a><br>In this example, a parallel query joins the <code class="codeph">sales</code> fact table to the <code class="codeph">products</code> and <code class="codeph">times</code> dimension tables, and filters on fiscal week <code class="codeph">18</code>.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="Join optimizations enable joins to be more efficient.">Join Optimizations</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95299"></a><div class="props_rev_3"><a id="GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5" name="GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5"></a><h5 id="TGSQL-GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5" class="sect5"><span class="enumeration_section">9.4.1.1 </span>Purpose of Bloom Filters
                     </h5>
                     <div>
                        <p>A Bloom filter tests one set of values to determine whether they are members another set.</p>
                        <p>For example, one set is (10,20,30,40) and the second set is (10,30,60,70). A Bloom filter can determine that 60 and 70 are <span class="italic">guaranteed</span> to be excluded from the first set, and that 10 and 30 are <span class="italic">probably</span> members. Bloom filters are especially useful when the amount of memory needed to store the filter is small relative to the amount of data in the data set, and when most data is expected to fail the membership test.
                        </p>
                        <p>Oracle Database uses Bloom filters to various specific goals, including the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Reduce the amount of data transferred to slave processes in a parallel query, especially when the database discards most rows because they do not fulfill a join condition</p>
                           </li>
                           <li>
                              <p>Eliminate unneeded partitions when building a partition access list in a join, known as <span class="italic">partition pruning</span></p>
                           </li>
                           <li>
                              <p>Test whether data exists in the server result cache, thereby avoiding a disk read</p>
                           </li>
                           <li>
                              <p>Filter members in Exadata cells, especially when joining a large fact table and small dimension tables in a star schema</p>
                           </li>
                        </ul>
                        <p>Bloom filters can occur in both parallel and serial processing.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="A Bloom filter, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set.">Bloom Filters</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95300"></a><div class="props_rev_3"><a id="GUID-D158E3CF-1B10-4391-A1C6-639216623A35" name="GUID-D158E3CF-1B10-4391-A1C6-639216623A35"></a><h5 id="TGSQL-GUID-D158E3CF-1B10-4391-A1C6-639216623A35" class="sect5"><span class="enumeration_section">9.4.1.2 </span>How Bloom Filters Work
                     </h5>
                     <div>
                        <p>A Bloom filter uses an array of bits to indicate inclusion in a set. </p>
                        <p>For example, 8 elements (an arbitrary number used for this example) in an array are initially set to <code class="codeph">0</code>:
                        </p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8
 0  0  0  0  0  0  0  0
</code></pre><p>This array represents a set. To represent an input value <span class="italic">i</span> in this array, three separate hash functions (three is arbitrary) are applied to <span class="italic">i</span>, each generating a hash value between <code class="codeph">1</code> and <code class="codeph">8</code>:
                        </p><pre class="pre codeblock"><code>f1(i) = h1
f2(i) = h2
f3(i) = h3
</code></pre><p>For example, to store the value <code class="codeph">17</code> in this array, the hash functions set <span class="italic">i</span> to <code class="codeph">17</code>, and then return the following hash values:
                        </p><pre class="pre codeblock"><code>f1(17) = 5
f2(17) = 3
f3(17) = 5
</code></pre><p>In the preceding example, two of the hash functions happened to return the same value of <code class="codeph">5</code>, known as a <span class="italic">hash collision</span>. Because the distinct hash values are <code class="codeph">5</code> and <code class="codeph">3</code>, the 5th and 3rd elements in the array are set to <code class="codeph">1</code>:
                        </p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8
 0  0  1  0  1  0  0  0
</code></pre><p>Testing the membership of <code class="codeph">17</code> in the set reverses the process. To test whether the set <span class="italic">excludes</span> the value <code class="codeph">17</code>, element <code class="codeph">3</code> or element <code class="codeph">5</code> must contain a <code class="codeph">0</code>. If a <code class="codeph">0</code> is present in either element, then the set cannot contain <code class="codeph">17</code>. No false negatives are possible.
                        </p>
                        <p>To test whether the set <span class="italic">includes</span> <code class="codeph">17</code>, both element <code class="codeph">3</code> and element <code class="codeph">5</code> must contain <code class="codeph">1</code> values. However, if the test indicates a <code class="codeph">1</code> for both elements, then it is still possible for the set <span class="italic">not</span> to include <code class="codeph">17</code>. False positives are possible. For example, the following array might represent the value <code class="codeph">22</code>, which also has a <code class="codeph">1</code> for both element <code class="codeph">3</code> and element <code class="codeph">5</code>:
                        </p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8
 1  0  1  0  1  0  0  0</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="A Bloom filter, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set.">Bloom Filters</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95301"></a><div class="props_rev_3"><a id="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C" name="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C"></a><h5 id="TGSQL-GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C" class="sect5"><span class="enumeration_section">9.4.1.3 </span>Bloom Filter Controls
                     </h5>
                     <div>
                        <p>The optimizer automatically determines whether to use Bloom filters.</p>
                        <p>To override optimizer decisions, use the hints <code class="codeph">PX_JOIN_FILTER</code> and <code class="codeph">NO_PX_JOIN_FILTER</code>.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C__GUID-B517338B-E99B-4E61-9BF3-64F800185636">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/Comments.html#SQLRF50585" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the bloom filter hints
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="A Bloom filter, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set.">Bloom Filters</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95302"></a><div class="props_rev_3"><a id="GUID-BB21BC10-031D-4E43-9774-92764BF84FA4" name="GUID-BB21BC10-031D-4E43-9774-92764BF84FA4"></a><h5 id="TGSQL-GUID-BB21BC10-031D-4E43-9774-92764BF84FA4" class="sect5"><span class="enumeration_section">9.4.1.4 </span>Bloom Filter Metadata
                     </h5>
                     <div>
                        <p><code class="codeph">V$</code> views contain metadata about Bloom filters.
                        </p>
                        <p>You can query the following views:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">V$SQL_JOIN_FILTER</code></p>
                              <p>This view shows the number of rows filtered out (<code class="codeph">FILTERED</code> column) and tested (<code class="codeph">PROBED</code> column) by an active Bloom filter.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">V$PQ_TQSTAT </code></p>
                              <p>This view displays the number of rows processed through each parallel execution server at each stage of the execution tree. You can use it to monitor how much Bloom filters have reduced data transfer among parallel processes.</p>
                           </li>
                        </ul>
                        <p>In an execution plan, a Bloom filter is indicated by keywords <code class="codeph">JOIN FILTER</code> in the <code class="codeph">Operation</code> column, and the prefix <code class="codeph">:BF</code> in the <code class="codeph">Name</code> column, as in the 9th step of the following plan snippet:
                        </p><pre class="pre codeblock"><code>----------------------------------------------------------------------------
| Id  | Operation                  | Name     |    TQ  |IN-OUT| PQ Distrib |
----------------------------------------------------------------------------
...
|   9 |      <span class="bold">JOIN FILTER CREATE</span>    | <span class="bold">:BF0000</span>  |  Q1,03 | PCWP |            |
</code></pre><p>In the <code class="codeph">Predicate Information</code> section of the plan, filters that contain functions beginning with the string <code class="codeph">SYS_OP_BLOOM_FILTER</code> indicate use of a Bloom filter.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="A Bloom filter, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set.">Bloom Filters</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95303"></a><div class="props_rev_3"><a id="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077" name="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077"></a><h5 id="TGSQL-GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077" class="sect5"><span class="enumeration_section">9.4.1.5 </span>Bloom Filters: Scenario
                     </h5>
                     <div>
                        <p>In this example, a parallel query joins the <code class="codeph">sales</code> fact table to the <code class="codeph">products</code> and <code class="codeph">times</code> dimension tables, and filters on fiscal week <code class="codeph">18</code>.
                        </p><pre class="pre codeblock"><code>SELECT /*+ parallel(s) */ p.prod_name, s.quantity_sold
FROM   sh.sales s, sh.products p, sh.times t 
WHERE  s.prod_id = p.prod_id
AND    s.time_id = t.time_id
AND    t.fiscal_week_number = 18;
</code></pre><p>Querying <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> provides the following output:
                        </p><pre class="pre codeblock"><code>SELECT * FROM
  TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format =&gt; 'BASIC,+PARALLEL,+PREDICATE'));

EXPLAINED SQL STATEMENT:
------------------------
SELECT /*+ parallel(s) */ p.prod_name, s.quantity_sold FROM sh.sales s,
sh.products p, sh.times t WHERE s.prod_id = p.prod_id AND s.time_id =
t.time_id AND t.fiscal_week_number = 18
 
Plan hash value: 1183628457
 
----------------------------------------------------------------------------
| Id  | Operation                  | Name     |    TQ  |IN-OUT| PQ Distrib |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |          |        |      |            |
|   1 |  PX COORDINATOR            |          |        |      |            |
|   2 |   PX SEND QC (RANDOM)      | :TQ10003 |  Q1,03 | P-&gt;S | QC (RAND)  |
|*  3 |    HASH JOIN BUFFERED      |          |  Q1,03 | PCWP |            |
|   4 |     PX RECEIVE             |          |  Q1,03 | PCWP |            |
|   5 |      PX SEND BROADCAST     | :TQ10001 |  Q1,01 | S-&gt;P | BROADCAST  |
|   6 |       PX SELECTOR          |          |  Q1,01 | SCWC |            |
|   7 |        TABLE ACCESS FULL   | PRODUCTS |  Q1,01 | SCWP |            |
|*  8 |     HASH JOIN              |          |  Q1,03 | PCWP |            |
|   9 |      JOIN FILTER CREATE    | :BF0000  |  Q1,03 | PCWP |            |
|  10 |       BUFFER SORT          |          |  Q1,03 | PCWC |            |
|  11 |        PX RECEIVE          |          |  Q1,03 | PCWP |            |
|  12 |         PX SEND HYBRID HASH| :TQ10000 |        | S-&gt;P | HYBRID HASH|
|* 13 |          TABLE ACCESS FULL | TIMES    |        |      |            |
|  14 |      PX RECEIVE            |          |  Q1,03 | PCWP |            |
|  15 |       PX SEND HYBRID HASH  | :TQ10002 |  Q1,02 | P-&gt;P | HYBRID HASH|
|  16 |        JOIN FILTER USE     | :BF0000  |  Q1,02 | PCWP |            |
|  17 |         PX BLOCK ITERATOR  |          |  Q1,02 | PCWC |            |
|* 18 |          TABLE ACCESS FULL | SALES    |  Q1,02 | PCWP |            |
----------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("S"."PROD_ID"="P"."PROD_ID")
   8 - access("S"."TIME_ID"="T"."TIME_ID")
  13 - filter("T"."FISCAL_WEEK_NUMBER"=18)
  18 - access(:Z&gt;=:Z AND :Z&lt;=:Z)
       filter(SYS_OP_BLOOM_FILTER(:BF0000,"S"."TIME_ID"))
</code></pre><p>A single server process scans the <code class="codeph">times</code> table (Step 13), and then uses a hybrid hash distribution method to send the rows to the parallel execution servers (Step 12). The processes in set <code class="codeph">Q1,03</code> create a bloom filter (Step 9). The processes in set <code class="codeph">Q1,02</code> scan <code class="codeph">sales</code> in parallel (Step 18), and then use the Bloom filter to discard rows from <code class="codeph">sales</code> (Step 16) before sending them on to set <code class="codeph">Q1,03</code> using hybrid hash distribution (Step 15). The processes in set <code class="codeph">Q1,03</code> hash join the <code class="codeph">times</code> rows to the filtered <code class="codeph">sales</code> rows (Step 8). The processes in set <code class="codeph">Q1,01</code> scan <code class="codeph">products</code> (Step 7), and then send the rows to <code class="codeph">Q1,03</code> (Step 5). Finally, the processes in <code class="codeph">Q1,03</code> join the <code class="codeph">products</code> rows to the rows generated by the previous hash join (Step 3).
                        </p>
                        <p>The following figure illustrates the basic process.</p>
                        <div class="figure" id="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077__GUID-9F1299A0-1098-4E06-AA8A-E40E730B7BCF">
                           <p class="titleinfigure">Figure 9-8 Bloom Filter</p><img src="img/tgsql_vm_082.png" alt="Description of Figure 9-8 follows" title="Description of Figure 9-8 follows" longdesc="img_text/tgsql_vm_082.html"><br><a href="img_text/tgsql_vm_082.html">Description of "Figure 9-8 Bloom Filter"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="A Bloom filter, named after its creator Burton Bloom, is a low-memory data structure that tests membership in a set.">Bloom Filters</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95336"></a><div class="props_rev_3"><a id="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" name="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7"></a><h4 id="TGSQL-GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" class="sect4"><span class="enumeration_section">9.4.2 </span>Partition-Wise Joins
                  </h4>
                  <div>
                     <p>A <strong class="term">partition-wise join</strong> is an optimization that divides a large join of two tables, one of which must be partitioned on the join key, into several smaller joins. 
                     </p>
                     <p>Partition-wise joins are either of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Full partition-wise join</p>
                           <p>Both tables must be equipartitioned on their join keys, or use reference partitioning (that is, be related by referential constraints). The database divides a large join into smaller joins between two partitions from the two joined tables.</p>
                        </li>
                        <li>
                           <p>Partial partition-wise joins</p>
                           <p>Only one table is partitioned on the join key. The other table may or may not be partitioned.</p>
                        </li>
                     </ul>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E">Purpose of Partition-Wise Joins</a><br>Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. 
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02">How Partition-Wise Joins Work</a><br>When the database serially joins two partitioned tables <span class="italic">without</span> using a partition-wise join, a single server process performs the join.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7__GUID-9ECD4737-056A-4005-95EE-5734FCE8558B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../vldbg/partition-wise-joins.html#VLDBG00402" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> explains partition-wise joins in detail
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="Join optimizations enable joins to be more efficient.">Join Optimizations</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95337"></a><div class="props_rev_3"><a id="GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E" name="GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E"></a><h5 id="TGSQL-GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E" class="sect5"><span class="enumeration_section">9.4.2.1 </span>Purpose of Partition-Wise Joins
                     </h5>
                     <div>
                        <p>Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. </p>
                        <p>This technique significantly reduces response time and improves the use of CPU and memory. In Oracle Real Application Clusters (Oracle RAC) environments, partition-wise joins also avoid or at least limit the data traffic over the interconnect, which is the key to achieving good scalability for massive join operations.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" title="A partition-wise join is an optimization that divides a large join of two tables, one of which must be partitioned on the join key, into several smaller joins.">Partition-Wise Joins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95339"></a><a id="TGSQL95338"></a><div class="props_rev_3"><a id="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" name="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02"></a><h5 id="TGSQL-GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" class="sect5"><span class="enumeration_section">9.4.2.2 </span>How Partition-Wise Joins Work
                     </h5>
                     <div>
                        <p>When the database serially joins two partitioned tables <span class="italic">without</span> using a partition-wise join, a single server process performs the join.
                        </p>
                        <p>In the following illustration, the join is <span class="italic">not</span> partition-wise because the server process joins every partition of table <code class="codeph">t1</code> to every partition of table <code class="codeph">t2</code>.
                        </p>
                        <div class="figure" id="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02__BABBAGDD">
                           <p class="titleinfigure">Figure 9-9 Join That Is Not Partition-Wise</p><img src="img/tgsql_vm_085.png" alt="Description of Figure 9-9 follows" title="Description of Figure 9-9 follows" longdesc="img_text/tgsql_vm_085.html"><br><a href="img_text/tgsql_vm_085.html">Description of "Figure 9-9 Join That Is Not Partition-Wise"</a></div>
                        <!-- class="figure" -->
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="joins.html#GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76">How a Full Partition-Wise Join Works</a><br>The database performs a full partition-wise join either serially or in parallel.
                           </li>
                           <li class="ulchildlink"><a href="joins.html#GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC">How a Partial Partition-Wise Join Works</a><br>Partial partition-wise joins, unlike their full partition-wise counterpart, must execute in parallel.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" title="A partition-wise join is an optimization that divides a large join of two tables, one of which must be partitioned on the join key, into several smaller joins.">Partition-Wise Joins</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL95341"></a><a id="TGSQL95340"></a><div class="props_rev_3"><a id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76" name="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76"></a><h6 id="TGSQL-GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76" class="sect6"><span class="enumeration_section">9.4.2.2.1 </span>How a Full Partition-Wise Join Works
                        </h6>
                        <div>
                           <p>The database performs a full partition-wise join either serially or in parallel.</p>
                           <p>The following graphic shows a full partition-wise join performed in parallel. In this case, the granule of parallelism is a partition. Each parallel execution server joins the partitions in pairs. For example, the first parallel execution server joins the first partition of <code class="codeph">t1</code> to the first partition of <code class="codeph">t2</code>. The parallel execution coordinator then assembles the result.
                           </p>
                           <div class="figure" id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76__BABJAHAJ">
                              <p class="titleinfigure">Figure 9-10 Full Partition-Wise Join in Parallel</p><img src="img/tgsql_vm_084.png" alt="Description of Figure 9-10 follows" title="Description of Figure 9-10 follows" longdesc="img_text/tgsql_vm_084.html"><br><a href="img_text/tgsql_vm_084.html">Description of "Figure 9-10 Full Partition-Wise Join in Parallel"</a></div>
                           <!-- class="figure" -->
                           <p>A full partition-wise join can also join partitions to subpartitions, which is useful when the tables use different partitioning methods. For example, <code class="codeph">customers</code> is partitioned by hash, but <code class="codeph">sales</code> is partitioned by range. If you subpartition <code class="codeph">sales</code> by hash, then the database can perform a full partition-wise join between the hash partitions of the <code class="codeph">customers</code> and the hash subpartitions of <code class="codeph">sales</code>.
                           </p>
                           <p>In the execution plan, the presence of a partition operation before the join signals the presence of a full partition-wise join, as in the following snippet:</p><pre class="oac_no_warn" dir="ltr">|   8 |         PX PARTITION HASH ALL|
|*  9 |          HASH JOIN           |</pre></div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76__GUID-C57A6C54-D985-48D9-97CE-4C0A57CE0C8D">
                              <p class="notep1">See Also:</p>
                              <p><a href="../vldbg/partition-wise-joins.html#VLDBG1241" target="_blank"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> explains full partition-wise joins in detail, and includes several examples
                              </p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" title="When the database serially joins two partitioned tables without using a partition-wise join, a single server process performs the join.">How Partition-Wise Joins Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL95343"></a><a id="TGSQL95342"></a><div class="props_rev_3"><a id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC" name="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC"></a><h6 id="TGSQL-GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC" class="sect6"><span class="enumeration_section">9.4.2.2.2 </span>How a Partial Partition-Wise Join Works
                        </h6>
                        <div>
                           <p>Partial partition-wise joins, unlike their full partition-wise counterpart, must execute in parallel.</p>
                           <p>The following graphic shows a partial partition-wise join between <code class="codeph">t1</code>, which is partitioned, and <code class="codeph">t2</code>, which is not partitioned. 
                           </p>
                           <div class="figure" id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC__BABHJHEH">
                              <p class="titleinfigure">Figure 9-11 Partial Partition-Wise Join</p><img src="img/tgsql_vm_083.png" alt="Description of Figure 9-11 follows" title="Description of Figure 9-11 follows" longdesc="img_text/tgsql_vm_083.html"><br><a href="img_text/tgsql_vm_083.html">Description of "Figure 9-11 Partial Partition-Wise Join"</a></div>
                           <!-- class="figure" -->
                           <p>Because <code class="codeph">t2</code> is not partitioned, a set of parallel execution servers must generate partitions from <code class="codeph">t2</code> as needed. A different set of parallel execution servers then joins the <code class="codeph">t1</code> partitions to the dynamically generated partitions. The parallel execution coordinator assembles the result.
                           </p>
                           <p>In the execution plan, the operation <code class="codeph">PX SEND PARTITION (KEY)</code> signals a partial partition-wise join, as in the following snippet:
                           </p><pre class="pre codeblock"><code>|  11 |            PX SEND PARTITION (KEY)    |</code></pre></div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC__GUID-C8433A1E-D755-425A-AF43-ABC094A3B9BC">
                              <p class="notep1">See Also:</p>
                              <p><a href="../vldbg/partition-wise-joins.html#VLDBG1247" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> explains full partition-wise joins in detail, and includes several examples
                              </p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" title="When the database serially joins two partitioned tables without using a partition-wise join, a single server process performs the join.">How Partition-Wise Joins Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650" name="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650"></a><h4 id="TGSQL-GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650" class="sect4"><span class="enumeration_section">9.4.3 </span>In-Memory Join Groups
                  </h4>
                  <div>
                     <p>A <span class="bold">join group</span> is a user-created object that lists two or more columns that can be meaningfully joined.
                     </p>
                     <p>In certain queries, join groups eliminate the performance overhead of decompressing and hashing column values. Join groups require an In-Memory Column Store (IM column store).</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650__GUID-6C592E60-DE2D-4D83-B14A-9A48C67206C7">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=INMEM-GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a> to learn how to optimize In-Memory queries with join groups
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="Join optimizations enable joins to be more efficient.">Join Optimizations</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>