<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Review these recommendations based on performance considerations when choosing a partitioning strategy.">
      <meta name="description" content="Review these recommendations based on performance considerations when choosing a partitioning strategy.">
      <title>Recommendations for Choosing a Partitioning Strategy</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="VLDB and Partitioning Guide">
      <meta property="og:description" content="Review these recommendations based on performance considerations when choosing a partitioning strategy.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="VLDB and Partitioning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00">
      <meta name="dcterms.title" content="VLDB and Partitioning Guide">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96199-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="partition-table-compression.html" title="Previous" type="text/html">
      <link rel="next" href="partition-admin.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-table-compression.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="partition-admin.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB and Partitioning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-availability.html" property="item" typeof="WebPage"><span property="name">Partitioning for Availability, Manageability, and Performance</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Recommendations for Choosing a Partitioning Strategy</li>
            </ol>
            <a id="GUID-9F7809B6-E68A-4425-AC99-BE00C7805408" name="GUID-9F7809B6-E68A-4425-AC99-BE00C7805408"></a><a id="VLDBG00406"></a>
            
            <h2 id="VLDBG-GUID-9F7809B6-E68A-4425-AC99-BE00C7805408" class="sect2">Recommendations for Choosing a Partitioning Strategy</h2>
         </header>
         <div class="ind">
            <div>
               <p>Review these recommendations based on performance considerations when choosing a partitioning strategy.</p>
               <p>The following topics provide recommendations for choosing a partitioning strategy:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" title="Range and interval partitioning are useful when organizing similar data, especially date and time data.">When to Use Range or Interval Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" title="Hash partitioning is useful for randomly distributing data across partitions based on a hashing algorithm, rather than grouping similar data.">When to Use Hash Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" title="List partitioning is useful to explicitly map rows to partitions based on discrete values.">When to Use List Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" title="Composite partitioning offers the benefits of partitioning on multiple dimensions.">When to Use Composite Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" title="Interval partitioning can be used for almost every table that is range partitioned and uses fixed intervals for new partitions.">When to Use Interval Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" title="Reference partitioning is useful in certain situations.">When to Use Reference Partitioning</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" title="Partitioning on virtual columns provides more flexibility to partition on a derived column.">When to Partition on Virtual Columns</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-8FB551B9-431A-4631-AF15-D17C08401E37" title="Review these considerations when using read-only tables.">Considerations When Using Read-Only Tablespaces</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG14029"></a><a id="VLDBG1269"></a><div class="props_rev_3"><a id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" name="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96"></a><h3 id="VLDBG-GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" class="sect3">When to Use Range or Interval Partitioning</h3>
               <div>
                  <p>Range and interval partitioning are useful when organizing similar data, especially date and time data.</p>
                  <p>Range partitioning is a convenient method for partitioning historical data. The boundaries of range partitions define the ordering of the partitions in the tables or indexes.</p>
                  <p>Interval partitioning is an extension to range partitioning in which, beyond a point in time, partitions are defined by an interval. Interval partitions are automatically created by the database when data is inserted into the partition.</p>
                  <p>Range or interval partitioning is often used to organize data by time intervals on a column of type <code class="codeph">DATE</code>. Thus, most SQL statements accessing range partitions focus on time frames. An example of this is a SQL statement similar to "select data from a particular period in time". In such a scenario, if each partition represents data for one month, the query "find data of month 06-DEC" must access only the December partition of year 2006. This reduces the amount of data scanned to a fraction of the total data available, an optimization method called partition pruning.
                  </p>
                  <p>Range partitioning is also ideal when you periodically load new data and purge old data, because it is easy to add or drop partitions. For example, it is common to keep a rolling window of data, keeping the past 36 months' worth of data online. Range partitioning simplifies this process. To add data from a new month, you load it into a separate table, clean it, index it, and then add it to the range-partitioned table using the <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement, all while the original table remains online. After you add the new partition, you can drop the trailing month with the <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement. The alternative to using the <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement can be to archive the partition and make it read only, but this works only when your partitions are in separate tablespaces. You can also implement a rolling window of data using inserts into the partitioned table.
                  </p>
                  <p>Interval partitioning provides an easy way for interval partitions to be automatically created as data arrives. Interval partitions can also be used for all other partition maintenance operations.</p>
                  <p>In conclusion, consider using range or interval partitioning when:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Very large tables are frequently scanned by a range predicate on a good partitioning column, such as <code class="codeph">ORDER_DATE</code> or <code class="codeph">PURCHASE_DATE</code>. Partitioning the table on that column enables partition pruning.
                        </p>
                     </li>
                     <li>
                        <p>You want to maintain a rolling window of data.</p>
                     </li>
                     <li>
                        <p>You cannot complete administrative operations, such as backup and restore, on large tables in an allotted time frame, but you can divide them into smaller logical pieces based on the partition range column.</p>
                     </li>
                  </ul>
                  <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__BABJHDBE">Example 3-5</a> creates the table <code class="codeph">salestable</code> for a period of two years, 2005 and 2006, and partitions it by range according to the column <code class="codeph">s_salesdate</code> to separate the data into eight quarters, each corresponding to a partition. Future partitions are created automatically through the monthly interval definition. Interval partitions are created in the provided list of tablespaces in a round-robin manner. Analysis of sales figures by a short interval can take advantage of partition pruning. The sales table also supports a rolling window approach.
                  </p>
                  <div class="example" id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__BABJHDBE">
                     <p class="titleinexample">Example 3-5 Creating a table with range and interval partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE salestable
  (s_productid  NUMBER,
   s_saledate   DATE,
   s_custid     NUMBER,
   s_totalprice NUMBER)
PARTITION BY RANGE(s_saledate)
INTERVAL(NUMTOYMINTERVAL(1,'MONTH')) STORE IN (tbs1,tbs2,tbs3,tbs4)
 (PARTITION sal05q1 VALUES LESS THAN (TO_DATE('01-APR-2005', 'DD-MON-YYYY')) TABLESPACE tbs1,
  PARTITION sal05q2 VALUES LESS THAN (TO_DATE('01-JUL-2005', 'DD-MON-YYYY')) TABLESPACE tbs2,
  PARTITION sal05q3 VALUES LESS THAN (TO_DATE('01-OCT-2005', 'DD-MON-YYYY')) TABLESPACE tbs3,
  PARTITION sal05q4 VALUES LESS THAN (TO_DATE('01-JAN-2006', 'DD-MON-YYYY')) TABLESPACE tbs4,
  PARTITION sal06q1 VALUES LESS THAN (TO_DATE('01-APR-2006', 'DD-MON-YYYY')) TABLESPACE tbs1,
  PARTITION sal06q2 VALUES LESS THAN (TO_DATE('01-JUL-2006', 'DD-MON-YYYY')) TABLESPACE tbs2,
  PARTITION sal06q3 VALUES LESS THAN (TO_DATE('01-OCT-2006', 'DD-MON-YYYY')) TABLESPACE tbs3,
  PARTITION sal06q4 VALUES LESS THAN (TO_DATE('01-JAN-2007', 'DD-MON-YYYY')) TABLESPACE tbs4);</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__GUID-ADAD3D8B-1CE8-4B1D-BC18-AAF983B37266">
                        <p class="notep1">See Also:</p>
                        <p><a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="Partition administration is an important task when working with partitioned tables and indexes.">Partition Administration</a> for more information about the partition maintenance operations on interval partitions
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14030"></a><a id="VLDBG1270"></a><div class="props_rev_3"><a id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" name="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4"></a><h3 id="VLDBG-GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" class="sect3">When to Use Hash Partitioning</h3>
               <div>
                  <p>Hash partitioning is useful for randomly distributing data across partitions based on a hashing algorithm, rather than grouping similar data.</p>
                  <p>There are times when it is not obvious in which partition data should reside, although the partitioning key can be identified. Rather than group similar data, there are times when it is desirable to distribute data such that it does not correspond to a business or a logical view of the data, as it does in range partitioning. With hash partitioning, a row is placed into a partition based on the result of passing the partitioning key into a hashing algorithm.</p>
                  <p>Using this approach, data is randomly distributed across the partitions rather than grouped. This is a good approach for some data, but may not be an effective way to manage historical data. However, hash partitions share some performance characteristics with range partitions. For example, partition pruning is limited to equality predicates. You can also use partition-wise joins, parallel index access, and parallel DML. </p>
                  <p>As a general rule, use hash partitioning for the following purposes:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>To enable partial or full parallel partition-wise joins with likely equisized partitions.</p>
                     </li>
                     <li>
                        <p>To distribute data evenly among the nodes of an MPP platform that uses Oracle Real Application Clusters. Consequently, you can minimize interconnect traffic when processing internode parallel statements.</p>
                     </li>
                     <li>
                        <p>To use partition pruning and partition-wise joins according to a partitioning key that is mostly constrained by a distinct value or value list.</p>
                     </li>
                     <li>
                        <p>To randomly distribute data to avoid I/O bottlenecks if you do not use a storage management technique that stripes and mirrors across all available devices.</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__GUID-EF785C3F-A390-4F86-BF4F-0DCFF59CA85F">
                     <p class="notep1">Note:</p>
                     <p>With hash partitioning, only equality or <code class="codeph">IN</code>-list predicates are supported for partition pruning.
                     </p>
                  </div>
                  <p>For optimal data distribution, the following requirements should be satisfied:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Choose a column or combination of columns that is unique or almost unique.</p>
                     </li>
                     <li>
                        <p>Create multiple partitions and subpartitions for each partition that is a power of two. For example, 2, 4, 8, 16, 32, 64, 128, and so on.</p>
                     </li>
                  </ul>
                  <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__BABICGIB">Example 3-6</a> creates four hash partitions for the table <code class="codeph">sales_hash</code> using the column <code class="codeph">s_productid</code> as the partitioning key. Parallel joins with the products table can take advantage of partial or full partition-wise joins. Queries accessing sales figures for only a single product or a list of products benefit from partition pruning.
                  </p>
                  <p>If you do not explicitly specify partition names, but instead you specify the number of hash partitions, then Oracle automatically generates internal names for the partitions. Also, you can use the <code class="codeph">STORE</code> <code class="codeph">IN</code> clause to assign hash partitions to tablespaces in a round-robin manner.
                  </p>
                  <div class="example" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__BABICGIB">
                     <p class="titleinexample">Example 3-6 Creating a table with hash partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_hash
  (s_productid  NUMBER,
   s_saledate   DATE,
   s_custid     NUMBER,
   s_totalprice NUMBER)
PARTITION BY HASH(s_productid)
( PARTITION p1 TABLESPACE tbs1
, PARTITION p2 TABLESPACE tbs2
, PARTITION p3 TABLESPACE tbs3
, PARTITION p4 TABLESPACE tbs4
);
</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__GUID-91D6A97E-6B88-4C13-A931-4977532C645E">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="partition-wise-joins.html#GUID-7C28CD29-5189-4A53-9691-380E13515015" title="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">Partition-Wise Operations</a> for information about part-wise joins
                              </p>
                           </li>
                           <li>
                              <p><a href="vldb-storage.html#GUID-02C55147-04B1-4DBC-8CFC-637CE5E751DF" title="Storage management for the database files in a VLDB environment includes high availability, performance, and manageability aspects.">Storage Management for VLDBs</a> for more information about managing storage for VLDBs
                              </p>
                           </li>
                           <li>
                              <p><a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="Partition administration is an important task when working with partitioned tables and indexes.">Partition Administration</a> for more examples on creating hash-partitioned tables
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for partitioning syntax
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14031"></a><a id="VLDBG1271"></a><div class="props_rev_3"><a id="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" name="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0"></a><h3 id="VLDBG-GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" class="sect3">When to Use List Partitioning</h3>
               <div>
                  <p>List partitioning is useful to explicitly map rows to partitions based on discrete values.</p>
                  <p>In <a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0__BABJAEDA">Example 3-7</a>, all the customers for states Oregon and Washington are stored in one partition and customers in other states are stored in different partitions. Account managers who analyze their accounts by region can take advantage of partition pruning.
                  </p>
                  <div class="example" id="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0__BABJAEDA">
                     <p class="titleinexample">Example 3-7 Creating a table with list partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE accounts
( id             NUMBER
, account_number NUMBER
, customer_id    NUMBER
, branch_id      NUMBER
, region         VARCHAR(2)
, status         VARCHAR2(1)
)
PARTITION BY LIST (region)
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1272"></a><div class="props_rev_3"><a id="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" name="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9"></a><h3 id="VLDBG-GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" class="sect3">When to Use Composite Partitioning</h3>
               <div>
                  <p>Composite partitioning offers the benefits of partitioning on multiple dimensions.</p>
                  <p>From a performance perspective you can take advantage of partition pruning on one or two dimensions depending on the SQL statement, and you can take advantage of the use of full or partial partition-wise joins on either dimension.</p>
                  <p>You can take advantage of parallel backup and recovery of a single table. Composite partitioning also increases the number of partitions significantly, which may be beneficial for efficient parallel execution. From a manageability perspective, you can implement a rolling window to support historical data and still partition on another dimension if many statements can benefit from partition pruning or partition-wise joins.</p>
                  <p>You can split backups of your tables and you can decide to store data differently based on identification by a partitioning key. For example, you may decide to store data for a specific product type in a read-only, compressed format, and keep other product type data uncompressed.</p>
                  <p>The database stores every subpartition in a composite partitioned table as a separate segment. Thus, the subpartitions may have properties that differ from the properties of the table or from the partition to which the subpartitions belong.</p>
                  <p>The following topics are discussed:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" title="Range and interval partitioning are useful when organizing similar data, especially date and time data.">When to Use Range or Interval Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" title="Hash partitioning is useful for randomly distributing data across partitions based on a hashing algorithm, rather than grouping similar data.">When to Use Hash Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" title="List partitioning is useful to explicitly map rows to partitions based on discrete values.">When to Use List Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" title="Composite partitioning offers the benefits of partitioning on multiple dimensions.">When to Use Composite Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" title="Interval partitioning can be used for almost every table that is range partitioned and uses fixed intervals for new partitions.">When to Use Interval Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" title="Reference partitioning is useful in certain situations.">When to Use Reference Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" title="Partitioning on virtual columns provides more flexibility to partition on a derived column.">When to Partition on Virtual Columns</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9__GUID-A28604A3-CACF-4B19-92FB-DE149BDE8CEA">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for details regarding syntax and restrictions
                     </p>
                  </div>
               </div><a id="VLDBG14032"></a><a id="VLDBG1273"></a><div class="props_rev_3"><a id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06" name="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06"></a><h4 id="VLDBG-GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06" class="sect4">When to Use Composite Range-Hash Partitioning</h4>
                  <div>
                     <p>Composite range-hash partitioning is particularly common for tables that store history, are very large consequently, and are frequently joined with other large tables.</p>
                     <p>For these types of tables (typical of data warehouse systems), composite range-hash partitioning provides the benefit of partition pruning at the range level with the opportunity to perform parallel full or partial partition-wise joins at the hash level. Specific cases can benefit from partition pruning on both dimensions for specific SQL statements.</p>
                     <p>Composite range-hash partitioning can also be used for tables that traditionally use hash partitioning, but also use a rolling window approach. Over time, data can be moved from one storage tier to another storage tier, compressed, stored in a read-only tablespace, and eventually purged. Information Lifecycle Management (ILM) scenarios often use range partitions to implement a tiered storage approach. </p>
                     <p><a href="recommendations-partition-strategy.html#GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__BABIJJBI">Example 3-8</a> is an example of a range hash partitioned <code class="codeph">page_history</code> table of an Internet service provider. The table definition is optimized for historical analysis for either specific <code class="codeph">client_ip</code> values (in which case queries benefit from partition pruning) or for analysis across many IP addresses, in which case queries can take advantage of full or partial partition-wise joins.
                     </p>
                     <p>This example shows the use of interval partitioning. You can use interval partitioning in addition to range partitioning so that interval partitions are created automatically as data is inserted into the table.</p>
                     <div class="example" id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__BABIJJBI">
                        <p class="titleinexample">Example 3-8  Creating a table with composite range-hash partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE page_history
( id                NUMBER NOT NULL
, url               VARCHAR2(300) NOT NULL
, view_date         DATE NOT NULL
, client_ip         VARCHAR2(23) NOT NULL
, from_url          VARCHAR2(300)
, to_url            VARCHAR2(300)
, timing_in_seconds NUMBER
) PARTITION BY RANGE(view_date) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY HASH(client_ip)
SUBPARTITIONS 32
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2006','dd-MON-yyyy')))
PARALLEL 32 COMPRESS;
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__GUID-A5CD7FDD-1A6E-4D08-BE23-89CE0992433A">
                           <p class="notep1">See Also:</p>
                           <p><a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle Database provides strategies to manage and maintain data based on time.">Managing and Maintaining Time-Based Information</a> for more detail on Information Lifecycle Management (ILM) and implementing tiered storage using partitioning
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14033"></a><a id="VLDBG1274"></a><div class="props_rev_3"><a id="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2" name="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2"></a><h4 id="VLDBG-GUID-EA336B11-7C11-4239-A476-4FE58D6024F2" class="sect4">When to Use Composite Range-List Partitioning</h4>
                  <div>
                     <p>Composite range-list partitioning is commonly used for large tables that store historical data and are commonly accessed on multiple dimensions.</p>
                     <p>Often the historical view of the data is one access path, but certain business cases add another categorization to the access path. For example, regional account managers are very interested in how many new customers they signed up in their region in a specific time period. ILM and its tiered storage approach is a common reason to create range-list partitioned tables so that older data can be moved and compressed, but partition pruning on the list dimension is still available.</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-EA336B11-7C11-4239-A476-4FE58D6024F2__BABCCGFA">Example 3-9</a> creates a range-list partitioned <code class="codeph">call_detail_records</code> table. A telecommunication company can use this table to analyze specific types of calls over time. The table uses local indexes on <code class="codeph">from_number</code> and <code class="codeph">to_number</code>.
                     </p>
                     <p>This example shows the use of interval partitioning. You can use interval partitioning in addition to range partitioning so that interval partitions are created automatically as data is inserted into the table.</p>
                     <div class="example" id="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2__BABCCGFA">
                        <p class="titleinexample">Example 3-9 Creating a table with composite range-list partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE call_detail_records
( id NUMBER
, from_number        VARCHAR2(20)
, to_number          VARCHAR2(20)
, date_of_call       DATE
, distance           VARCHAR2(1)
, call_duration_in_s NUMBER(4)
) PARTITION BY RANGE(date_of_call)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY LIST(distance)
SUBPARTITION TEMPLATE
( SUBPARTITION local VALUES('L') TABLESPACE tbs1
, SUBPARTITION medium_long VALUES ('M') TABLESPACE tbs2
, SUBPARTITION long_distance VALUES ('D') TABLESPACE tbs3
, SUBPARTITION international VALUES ('I') TABLESPACE tbs4
)
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2005','dd-MON-yyyy')))
PARALLEL;

CREATE INDEX from_number_ix ON call_detail_records(from_number)
LOCAL PARALLEL NOLOGGING;

CREATE INDEX to_number_ix ON call_detail_records(to_number)
LOCAL PARALLEL NOLOGGING;
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14034"></a><a id="VLDBG1275"></a><div class="props_rev_3"><a id="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697" name="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697"></a><h4 id="VLDBG-GUID-A0C45C5E-874F-4286-B2BF-027F11B49697" class="sect4">When to Use Composite Range-Range Partitioning</h4>
                  <div>
                     <p>Composite range-range partitioning is useful for applications that store time-dependent data on multiple time dimensions. </p>
                     <p>Often these applications do not use one particular time dimension to access the data, but rather another time dimension, or sometimes both at the same time. For example, a web retailer wants to analyze its sales data based on when orders were placed, and when orders were shipped (handed over to the shipping company).</p>
                     <p>Other business cases for composite range-range partitioning include ILM scenarios, and applications that store historical data and want to categorize its data by range on another dimension.</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-A0C45C5E-874F-4286-B2BF-027F11B49697__BABDJAJH">Example 3-10</a> shows a range-range partitioned table <code class="codeph">account_balance_history</code>. A bank may use access to individual subpartitions to contact its customers for low-balance reminders or specific promotions relevant to a certain category of customers.
                     </p>
                     <p>This example shows the use of interval partitioning. You can use interval partitioning in addition to range partitioning so that interval partitions are created automatically as data is inserted into the table. In this case 7-day (weekly) intervals are created, starting Monday, January 1, 2007.</p>
                     <div class="example" id="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697__BABDJAJH">
                        <p class="titleinexample">Example 3-10 Creating a table with composite range-range partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE account_balance_history
( id                 NUMBER NOT NULL
, account_number     NUMBER NOT NULL
, customer_id        NUMBER NOT NULL
, transaction_date   DATE NOT NULL
, amount_credited    NUMBER
, amount_debited     NUMBER
, end_of_day_balance NUMBER NOT NULL
) PARTITION BY RANGE(transaction_date)
INTERVAL (NUMTODSINTERVAL(7,'DAY'))
SUBPARTITION BY RANGE(end_of_day_balance)
SUBPARTITION TEMPLATE
( SUBPARTITION unacceptable VALUES LESS THAN (-1000)
, SUBPARTITION credit VALUES LESS THAN (0)
, SUBPARTITION low VALUES LESS THAN (500)
, SUBPARTITION normal VALUES LESS THAN (5000)
, SUBPARTITION high VALUES LESS THAN (20000)
, SUBPARTITION extraordinary VALUES LESS THAN (MAXVALUE)
)
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')));
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14035"></a><a id="VLDBG1276"></a><div class="props_rev_3"><a id="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4" name="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4"></a><h4 id="VLDBG-GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4" class="sect4">When to Use Composite List-Hash Partitioning</h4>
                  <div>
                     <p>Composite list-hash partitioning is useful for large tables that are usually accessed on one dimension, but (due to their size) still must take advantage of parallel full or partial partition-wise joins on another dimension in joins with other large tables.</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4__BABBDHAI">Example 3-11</a> shows a <code class="codeph">credit_card_accounts</code> table. The table is list-partitioned on region in order for account managers to quickly access accounts in their region. The subpartitioning strategy is hash on <code class="codeph">customer_id</code> so that queries against the transactions table, which is subpartitioned on <code class="codeph">customer_id</code>, can take advantage of full partition-wise joins. Joins with the hash partitioned customers table can also benefit from full partition-wise joins. The table has a local bitmap index on the <code class="codeph">is_active</code> column.
                     </p>
                     <div class="example" id="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4__BABBDHAI">
                        <p class="titleinexample">Example 3-11 Creating a table with composite list-hash partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE credit_card_accounts
( account_number  NUMBER(16) NOT NULL
, customer_id     NUMBER NOT NULL
, customer_region VARCHAR2(2) NOT NULL
, is_active       VARCHAR2(1) NOT NULL
, date_opened     DATE NOT NULL
) PARTITION BY LIST (customer_region)
SUBPARTITION BY HASH (customer_id)
SUBPARTITIONS 16
( PARTITION emea VALUES ('EU','ME','AF')
, PARTITION amer VALUES ('NA','LA')
, PARTITION apac VALUES ('SA','AU','NZ','IN','CH')
) PARALLEL;

CREATE BITMAP INDEX is_active_bix ON credit_card_accounts(is_active)
LOCAL PARALLEL NOLOGGING;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14036"></a><a id="VLDBG1277"></a><div class="props_rev_3"><a id="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E" name="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E"></a><h4 id="VLDBG-GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E" class="sect4">When to Use Composite List-List Partitioning</h4>
                  <div>
                     <p>Composite list-list partitioning is useful for large tables that are often accessed on different dimensions.</p>
                     <p>You can specifically map rows to partitions on those dimensions based on discrete values.</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E__BABDJFGA">Example 3-12</a> shows an example of a very frequently accessed <code class="codeph">current_inventory</code> table. The table is constantly updated with the current inventory in the supermarket supplier's local warehouses. Potentially perishable foods are supplied from those warehouses to supermarkets, and it is important to optimize supplies and deliveries. The table has local indexes on <code class="codeph">warehouse_id</code> and <code class="codeph">product_id</code>.
                     </p>
                     <div class="example" id="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E__BABDJFGA">
                        <p class="titleinexample">Example 3-12 Creating a table with composite list-list partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE current_inventory
( warehouse_id      NUMBER
, warehouse_region  VARCHAR2(2)
, product_id        NUMBER
, product_category  VARCHAR2(12)
, amount_in_stock   NUMBER
, unit_of_shipping  VARCHAR2(20)
, products_per_unit NUMBER
, last_updated      DATE
) PARTITION BY LIST (warehouse_region)
SUBPARTITION BY LIST (product_category)
SUBPARTITION TEMPLATE
( SUBPARTITION perishable VALUES ('DAIRY','PRODUCE','MEAT','BREAD')
, SUBPARTITION non_perishable VALUES ('CANNED','PACKAGED')
, SUBPARTITION durable VALUES ('TOYS','KITCHENWARE')
)
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);

CREATE INDEX warehouse_id_ix ON current_inventory(warehouse_id)
LOCAL PARALLEL NOLOGGING;

CREATE INDEX product_id_ix ON current_inventory(product_id)
LOCAL PARALLEL NOLOGGING;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14037"></a><a id="VLDBG1278"></a><div class="props_rev_3"><a id="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8" name="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8"></a><h4 id="VLDBG-GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8" class="sect4">When to Use Composite List-Range Partitioning</h4>
                  <div>
                     <p>Composite list-range partitioning is useful for large tables that are accessed on different dimensions.</p>
                     <p>For the most commonly used dimension, you can specifically map rows to partitions on discrete values. List-range partitioning is commonly used for tables that use range values within a list partition, whereas range-list partitioning is commonly used for a discrete list values within a range partition. List-range partitioning is less commonly used to store historical data, even though equivalent scenarios are all suitable. Range-list partitioning can be implemented using interval-list partitioning, whereas list-range partitioning does not support interval partitioning.</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8__BABBHEII">Example 3-13</a> shows a <code class="codeph">donations</code> table that stores donations in different currencies. The donations are categorized into small, medium, and high, depending on the amount. Due to currency differences, the ranges are different.
                     </p>
                     <div class="example" id="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8__BABBHEII">
                        <p class="titleinexample">Example 3-13 Creating a table with composite list-range partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE donations
( id             NUMBER
, name           VARCHAR2(60)
, beneficiary    VARCHAR2(80)
, payment_method VARCHAR2(30)
, currency       VARCHAR2(3)
, amount         NUMBER
) PARTITION BY LIST (currency)
SUBPARTITION BY RANGE (amount)
( PARTITION p_eur VALUES ('EUR')
  ( SUBPARTITION p_eur_small VALUES LESS THAN (8)
  , SUBPARTITION p_eur_medium VALUES LESS THAN (80)
  , SUBPARTITION p_eur_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_gbp VALUES ('GBP')
  ( SUBPARTITION p_gbp_small VALUES LESS THAN (5)
  , SUBPARTITION p_gbp_medium VALUES LESS THAN (50)
  , SUBPARTITION p_gbp_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_aud_nzd_chf VALUES ('AUD','NZD','CHF')
  ( SUBPARTITION p_aud_nzd_chf_small VALUES LESS THAN (12)
  , SUBPARTITION p_aud_nzd_chf_medium VALUES LESS THAN (120)
  , SUBPARTITION p_aud_nzd_chf_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_jpy VALUES ('JPY')
  ( SUBPARTITION p_jpy_small VALUES LESS THAN (1200)
  , SUBPARTITION p_jpy_medium VALUES LESS THAN (12000)
  , SUBPARTITION p_jpy_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_inr VALUES ('INR')
  ( SUBPARTITION p_inr_small VALUES LESS THAN (400)
  , SUBPARTITION p_inr_medium VALUES LESS THAN (4000)
  , SUBPARTITION p_inr_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_zar VALUES ('ZAR')
  ( SUBPARTITION p_zar_small VALUES LESS THAN (70)
  , SUBPARTITION p_zar_medium VALUES LESS THAN (700)
  , SUBPARTITION p_zar_high VALUES LESS THAN (MAXVALUE)
  )
, PARTITION p_default VALUES (DEFAULT)
  ( SUBPARTITION p_default_small VALUES LESS THAN (10)
  , SUBPARTITION p_default_medium VALUES LESS THAN (100)
  , SUBPARTITION p_default_high VALUES LESS THAN (MAXVALUE)
  )
) ENABLE ROW MOVEMENT;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG1279"></a><div class="props_rev_3"><a id="GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" name="GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97"></a><h3 id="VLDBG-GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" class="sect3">When to Use Interval Partitioning</h3>
               <div>
                  <p>Interval partitioning can be used for almost every table that is range partitioned and uses fixed intervals for new partitions.</p>
                  <p>The database automatically creates interval partitions as data for that partition is inserted. Until this happens, the interval partition exists but no segment is created for the partition.</p>
                  <p>The benefit of interval partitioning is that you do not need to create your range partitions explicitly. You should consider using interval partitioning unless you create range partitions with different intervals, or if you always set specific partition attributes when you create range partitions. You can specify a list of tablespaces in the interval definition. The database creates interval partitions in the provided list of tablespaces in a round-robin manner.</p>
                  <p>If you upgrade your application and you use range partitioning or composite range-* partitioning, then you can easily change your existing table definition to use interval partitioning. You cannot manually add partitions to an interval-partitioned table. If you have automated the creation of new partitions, then in the future you must change your application code to prevent the explicit creation of range partitions.</p>
                  <p>The following SQL statement initiates a change from range partitioning to using monthly interval partitioning on the <code class="codeph">sales</code> table.
                  </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH'));
</pre><p>You cannot use interval partitioning with reference partitioned tables. </p>
                  <p>Serializable transactions do not work with interval partitioning. Inserting data into a partition of an interval partitioned table that does not have a segment yet causes an error.</p>
               </div>
            </div><a id="VLDBG1280"></a><div class="props_rev_3"><a id="GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" name="GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84"></a><h3 id="VLDBG-GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" class="sect3">When to Use Reference Partitioning</h3>
               <div>
                  <p>Reference partitioning is useful in certain situations.</p>
                  <p>Reference partitioning is useful in the following scenarios:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>If you have denormalized, or would denormalize, a column from a master table into a child table to get partition pruning benefits on both tables.</p>
                        <p>For example, your <code class="codeph">orders</code> table stores the <code class="codeph">order_date</code>, but the <code class="codeph">order_items</code> table, which stores one or more items for each order, does not. To get good performance for historical analysis of orders data, you would traditionally duplicate the <code class="codeph">order_date</code> column in the <code class="codeph">order_items</code> table to use partition pruning on the <code class="codeph">order_items</code> table.
                        </p>
                        <p>You should consider reference partitioning in such a scenario and avoid having to duplicate the <code class="codeph">order_date</code> column. Queries that join both tables and use a predicate on <code class="codeph">order_date</code> automatically benefit from partition pruning on both tables.
                        </p>
                     </li>
                     <li>
                        <p>If two large tables are joined frequently, then the tables are not partitioned on the join key, but you want to take advantage of partition-wise joins.</p>
                        <p>Reference partitioning implicitly enables full partition-wise joins.</p>
                     </li>
                     <li>
                        <p>If data in multiple tables has a related life cycle, then reference partitioning can provide significant manageability benefits.</p>
                        <p>Partition management operations against the master table are automatically cascaded to its descendents. For example, when you add a partition to the master table, that addition is automatically propagated to all its descendents.</p>
                        <p>To use reference partitioning, you must enable and enforce the foreign key relationship between the master table and the reference table in place. You can cascade reference-partitioned tables. </p>
                        <p>The primary key-foreign key relationship must be enabled all the time and cannot be disabled. Also the relationship cannot be declared as deferred. These are mandatory requirements because the enabled primary key-foreign relationship is required to determine the data placement for the child tables.</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG14038"></a><a id="VLDBG1281"></a><div class="props_rev_3"><a id="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" name="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5"></a><h3 id="VLDBG-GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" class="sect3">When to Partition on Virtual Columns</h3>
               <div>
                  <p>Partitioning on virtual columns provides more flexibility to partition on a derived column. </p>
                  <p>Virtual column partitioning enables you to partition on an expression, which may use data from other columns, and perform calculations with these columns. PL/SQL function calls are not supported in virtual column definitions that are to be used as a partitioning key.</p>
                  <p>Virtual column partitioning supports all partitioning methods, plus performance and manageability features. To get partition pruning benefits, consider using virtual columns if tables are frequently accessed using a predicate that is not directly captured in a column, but can be derived. Traditionally, to get partition pruning benefits, you would have to add a separate column to capture and calculate the correct value and ensure the column is always populated correctly to ensure correct query retrieval.</p>
                  <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5__BABFDBEE">Example 3-14</a> shows a <code class="codeph">car_rentals</code> table. The customer's confirmation number contains a two-character country name as the location where the rental car is picked up. Rental car analyses usually evaluate regional patterns, so it makes sense to partition by country.
                  </p>
                  <p>In this example, the column <code class="codeph">country</code> is defined as a virtual column derived from the confirmation number. The virtual column does not require any storage. As the example illustrates, row movement is supported with virtual columns. The database migrates a row to a different partition if the virtual column evaluates to a different value in another partition.
                  </p>
                  <div class="example" id="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5__BABFDBEE">
                     <p class="titleinexample">Example 3-14 Creating a table with virtual columns for partitioning</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE car_rentals
( id                  NUMBER NOT NULL
 , customer_id         NUMBER NOT NULL
 , confirmation_number VARCHAR2(12) NOT NULL
 , car_id              NUMBER
 , car_type            VARCHAR2(10)
 , requested_car_type  VARCHAR2(10) NOT NULL
 , reservation_date    DATE NOT NULL
 , start_date          DATE NOT NULL
 , end_date            DATE
 , country as (substr(confirmation_number,9,2))
) PARTITION BY LIST (country)
SUBPARTITION BY HASH (customer_id)
SUBPARTITIONS 16
( PARTITION north_america VALUES ('US','CA','MX')
 , PARTITION south_america VALUES ('BR','AR','PE')
 , PARTITION europe VALUES ('GB','DE','NL','BE','FR','ES','IT','CH')
 , PARTITION apac VALUES ('NZ','AU','IN','CN')
) ENABLE ROW MOVEMENT;
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1282"></a><div class="props_rev_3"><a id="GUID-8FB551B9-431A-4631-AF15-D17C08401E37" name="GUID-8FB551B9-431A-4631-AF15-D17C08401E37"></a><h3 id="VLDBG-GUID-8FB551B9-431A-4631-AF15-D17C08401E37" class="sect3">Considerations When Using Read-Only Tablespaces</h3>
               <div>
                  <p>Review these considerations when using read-only tables.</p>
                  <p>When a referential integrity constraint is defined between parent and child tables, an index is defined on the foreign key, and the tablespace in which that index resides is made read-only, then the integrity check for the constraint is implemented in SQL and not through consistent read buffer access.</p>
                  <p>The implication of this is if the child is partitioned and if only some child partitions have their indexes in read-only tablespaces and if an insert is made into one nonread-only child segment, then a TM enqueue is acquired on the child table in SX mode.</p>
                  <p>SX mode is incompatible with S requests, so that if you try to insert into the parent, it is blocked because that insert attempts to acquire an S TM enqueue against the child.</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>