<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">
      <meta name="description" content="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">
      <title>XQuery and Oracle XML&nbsp;DB</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Developer's Guide ">
      <meta property="og:description" content="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96222-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="manipulation-of-XML-in-XML-DB.html" title="Previous" type="text/html">
      <link rel="next" href="query-and-update-XML.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer's Guide">
    <meta name="dcterms.isVersionOf" content="ADXDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="manipulation-of-XML-in-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="query-and-update-XML.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="manipulation-of-XML-in-XML-DB.html" property="item" typeof="WebPage"><span property="name"> Manipulation of XML Data in Oracle XML&nbsp;DB</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XQuery and Oracle XML&nbsp;DB</li>
            </ol>
            <a id="GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" name="GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1"></a><a id="ADXDB1700"></a>
            
            <h2 id="ADXDB-GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" class="sect2"><span class="enumeration_chapter">4 </span>XQuery and Oracle XML&nbsp;DB
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='xquery-and-XML-DB'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus command<code class="codeph">XQUERY</code> and SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>.
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-927FB610-9553-4772-8D3E-FAA7546C4371">Overview of the XQuery Language</a><br>XQuery is the W3C language designed for querying and updating XML data.
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-7DB63F8C-F441-4635-A185-4016016B22CE">Overview of XQuery in Oracle XML&nbsp;DB</a><br>Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>. As a convenience, SQL*Plus command <code class="codeph">XQUERY</code> is also provided, which lets you enter XQuery expressions directly — in effect, this command turns SQL*Plus into an XQuery command-line interpreter.
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a><br>SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code> are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages. 
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B">URI Scheme oradb: Querying Table or View Data with XQuery</a><br>You can use XQuery function <code class="codeph">fn:collection</code> to query data that is in database tables and views.
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513">Oracle XQuery Extension Functions</a><br>Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, <code class="codeph">http://xmlns.oracle.com/xdb</code>, which uses the predefined prefix <span class="bold"><code class="codeph">ora</code></span>. 
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948">Oracle XQuery Extension-Expression Pragmas</a><br>The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces (<code class="codeph">{</code>,&nbsp;<code class="codeph">}</code>) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B">XQuery Static Type-Checking in Oracle XML&nbsp;DB</a><br>When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.
                  </li>
                  <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99">Oracle XML&nbsp;DB Support for XQuery</a><br>Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="manipulation-of-XML-in-XML-DB.html#GUID-87C758D5-5792-483D-8894-4C01FCD2A8A0" title="The following are covered here: XQuery, XMLType operations, and indexing of XML data.">Manipulation of XML Data in Oracle XML&nbsp;DB</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5089"></a><div class="props_rev_3"><a id="GUID-927FB610-9553-4772-8D3E-FAA7546C4371" name="GUID-927FB610-9553-4772-8D3E-FAA7546C4371"></a><h3 id="ADXDB-GUID-927FB610-9553-4772-8D3E-FAA7546C4371" class="sect3"><span class="enumeration_section">4.1 </span>Overview of the XQuery Language
               </h3>
               <div>
                  <p>XQuery is the W3C language designed for querying and updating XML data.</p>
                  <p>Oracle XML&nbsp;DB supports the following W3C XQuery standards:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>XQuery 1.0 Recommendation</p>
                     </li>
                     <li>
                        <p><a id="d20054e188" class="indexterm-anchor"></a>XQuery Update Facility 1.0 Recommendation
                        </p>
                     </li>
                     <li>
                        <p>XQuery and XPath Full Text 1.0 Recommendation</p>
                     </li>
                  </ul>
                  <p>This section presents an overview of the XQuery language. For more information, consult a recent book on the language or refer to the standards documents that define it, all of which are available at <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3c_org" target="_blank"><code class="codeph">http://www.w3c.org/</code></a>. 
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC">XPath Expressions Are XQuery Expressions</a><br>The XPath language is a W3C Recommendation for navigating XML documents. It is a subset of the XQuery language: an XPath expression is also an XQuery expression. 
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D">XQuery: A Functional Language Based on Sequences</a><br>XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED">XQuery Expressions</a><br>XQuery expressions are case-sensitive. An XQuery expression is either a <span class="italic">simple</span> expression or an <span class="italic">updating</span> expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-E40FFA59-701C-43F6-9A89-774321970A19">FLWOR Expressions</a><br>Just as for XQuery in general, there is a lot to learn about FLWOR expressions in particular. This section provides a brief overview.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5805"></a><a id="ADXDB4232"></a><div class="props_rev_3"><a id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC" name="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC"></a><h4 id="ADXDB-GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC" class="sect4"><span class="enumeration_section">4.1.1 </span>XPath Expressions Are XQuery Expressions
                  </h4>
                  <div>
                     <p>The XPath language is a W3C Recommendation for navigating XML documents. It is a subset of the XQuery language: an XPath expression is also an XQuery expression. </p>
                     <div class="section">
                        <p>XPath models an XML document as a tree of nodes. It provides a set of operations that walk this tree and apply predicates and node-test functions. Applying an XPath expression to an XML document results in a set of nodes. For example, the expression <code class="codeph">/PO/PONO</code> selects all <code class="codeph">PONO</code> child elements under the <code class="codeph">PO</code> root element of a document.
                        </p>
                        <p><a href="xquery-and-XML-DB.html#GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__CFHFHBIJ" title="This table describes five common XPath constructs.">Table 4-1</a> lists some common constructs used in XPath.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__CFHFHBIJ">
                        <p class="titleintable">Table 4-1 Common XPath Constructs</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Common XPath Constructs" summary="This table describes five common XPath constructs." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d20054e323">XPath Construct</th>
                                 <th align="left" valign="bottom" width="79%" id="d20054e326">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e331" headers="d20054e323 ">
                                    <p><code class="codeph">/</code></p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e331 d20054e326 ">
                                    <p>Denotes the root of the tree in an XPath expression. For example, <code class="codeph">/PO </code>refers to the child of the root node whose name is <code class="codeph">PO</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e345" headers="d20054e323 ">
                                    <p><code class="codeph">/</code></p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e345 d20054e326 ">
                                    <p>Used as a path separator to identify the child element nodes of a given element node. For example, <code class="codeph">/PurchaseOrder/Reference</code> identifies <code class="codeph">Reference</code> elements that are children of <code class="codeph">PurchaseOrder</code> elements that are children of the root element.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e362" headers="d20054e323 ">
                                    <p><code class="codeph">//</code></p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e362 d20054e326 ">
                                    <p>Used to identify all descendants of the current node. For example, <code class="codeph">PurchaseOrder//ShippingInstructions</code> matches any <code class="codeph">ShippingInstructions</code> element under the <code class="codeph">PurchaseOrder</code> element.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e379" headers="d20054e323 ">
                                    <p><code class="codeph">*</code></p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e379 d20054e326 ">
                                    <p>Used as a wildcard to match any child node. For example, <code class="codeph">/PO/*/STREET</code> matches any street element that is a grandchild of the <code class="codeph">PO</code> element. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e393" headers="d20054e323 ">
                                    <p><code class="codeph">[ ]</code></p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e393 d20054e326 ">
                                    <p>Used to denote predicate expressions. XPath supports a rich list of binary operators such as <code class="codeph">or</code>, <code class="codeph">and</code>, and <code class="codeph">not</code>. For example, <code class="codeph">/PO[PONO = 20 and PNAME = "PO_2"]/SHIPADDR</code> selects the shipping address element of all purchase orders whose purchase-order number is <code class="codeph">20</code> and whose purchase-order name is <code class="codeph">PO_2</code>. 
                                    </p>
                                    <p>Brackets are also used to denote a position (index). For example, <code class="codeph">/PO/PONO[2]</code> identifies the second purchase-order number element under the <code class="codeph">PO</code> root element.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d20054e428" headers="d20054e323 ">
                                    <p>Functions</p>
                                 </td>
                                 <td align="left" valign="top" width="79%" headers="d20054e428 d20054e326 ">
                                    <p>XPath and XQuery support a set of built-in functions such as <code class="codeph">substring</code>, <code class="codeph">round</code>, and <code class="codeph">not</code>. In addition, these languages provide for extension functions through the use of namespaces. Oracle XQuery extension functions use the namespace prefix <code class="codeph">ora</code>, for namespace <code class="codeph">http://xmlns.oracle.com/xdb</code>. See <a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>An XPath expression must identify a single node or a set of element, text, or attribute nodes. The result of evaluating an XPath expression is never a Boolean expression.</p>
                        <p>You can select <code class="codeph">XMLType</code> data using PL/SQL, C, or Java. You can also use <code class="codeph">XMLType</code> method <code class="codeph">getNumberVal()</code> to retrieve XML data as a <code class="codeph">NUMBER</code> value.
                        </p>
                        <div class="infoboxnote" id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__GUID-4E633027-A075-4466-971F-807F8B922B85">
                           <p class="notep1">Note:</p>
                           <p>Oracle SQL functions and <code class="codeph">XMLType</code> methods respect the W3C XPath recommendation, which states that if an XPath expression targets <span class="italic">no nodes</span> when applied to XML data, then an empty sequence must be returned. An error must <span class="italic">not</span> be raised in this case. 
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-927FB610-9553-4772-8D3E-FAA7546C4371" title="XQuery is the W3C language designed for querying and updating XML data.">Overview of the XQuery Language</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5090"></a><div class="props_rev_3"><a id="GUID-498BE184-4F83-4FF8-8799-47D606F9066D" name="GUID-498BE184-4F83-4FF8-8799-47D606F9066D"></a><h4 id="ADXDB-GUID-498BE184-4F83-4FF8-8799-47D606F9066D" class="sect4"><span class="enumeration_section">4.1.2 </span>XQuery: A Functional Language Based on Sequences
                  </h4>
                  <div>
                     <p>XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.</p>
                     <p>You can use XQuery to query XML data wherever it is found, whether it is stored in database tables, available through Web Services, or otherwise created on the fly. In addition to querying XML data, XQuery can be used to <span class="italic">construct</span> XML data. In this regard, XQuery can serve as an alternative or a complement to both XSLT and the other SQL/XML publishing functions, such as <code class="codeph">XMLElement</code>.
                     </p>
                     <p>XQuery builds on the Post-Schema-Validation Infoset (PSVI) data model, which unites the XML Information Set (Infoset) data model and the XML Schema type system. XQuery defines a new data model, the <strong class="term">XQuery Data Model</strong> (XDM), which is based on <span class="italic">sequences</span>. Another name for an XQuery sequence is an <strong class="term">XDM instance</strong>.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526">XQuery Is About Sequences</a><br>XQuery is all about manipulating sequences. This makes XQuery similar to a set-manipulation language, except that sequences are ordered and can contain duplicate items. XQuery sequences differ from the sequences in some other languages in that nested XQuery sequences are always <span class="italic">flattened</span> in their effect.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-30341909-E378-4909-B54B-D112A6144C5B">XQuery Is Referentially Transparent</a><br>XQuery is a <span class="italic">functional</span> language. As such, it consists of a set of possible <span class="italic">expressions</span> that are <span class="italic">evaluated</span> and whose evaluation returns <span class="italic">values</span> (results).
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB">XQuery Update Has Side Effects on Your Data</a><br>Referential transparency applies to the evaluation of XQuery expressions. It does not imply that this evaluation never has a <span class="italic">side effect</span> on your <span class="italic">data</span>. In particular, you use XQuery Update to modify your data. That modification is a side effect of evaluating an XQuery updating expression.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE">XQuery Update Snapshots</a><br>An XQuery expression (query) can call for more than one update operation. XQuery Update performs all such operations for the same query as an <span class="italic">atomic</span> operation: either they all succeed or none of them do (if an error is raised).
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-804D83E9-23F3-4E70-B836-FD30793276D9">XQuery Full Text Provides Full-Text Search</a><br>The XQuery and XPath Full Text 1.0 Recommendation (XQuery Full Text) defines XQuery support for full-text searches in queries. It defines full-text selection operators that perform the search and return instances of the AllMatches model, which complements the XQuery Data Model (XDM). 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-927FB610-9553-4772-8D3E-FAA7546C4371" title="XQuery is the W3C language designed for querying and updating XML data.">Overview of the XQuery Language</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6035"></a><div class="props_rev_3"><a id="GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526" name="GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526"></a><h5 id="ADXDB-GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526" class="sect5"><span class="enumeration_section">4.1.2.1 </span>XQuery Is About Sequences
                     </h5>
                     <div>
                        <p>XQuery is all about manipulating sequences. This makes XQuery similar to a set-manipulation language, except that sequences are ordered and can contain duplicate items. XQuery sequences differ from the sequences in some other languages in that nested XQuery sequences are always <span class="italic">flattened</span> in their effect.
                        </p>
                        <p>In many cases, sequences can be treated as unordered, to maximize optimization &#x2013; where this is available, it is under your control. This <strong class="term">unordered mode</strong> can be applied to join order in the treatment of nested iterations (<code class="codeph">for</code>), and it can be applied to the treatment of XPath expressions (for example, in <code class="codeph">/a/b</code>, the matching <code class="codeph">b</code> elements can be processed without regard to document order).
                        </p>
                        <p>An XQuery <strong class="term">sequence</strong> consists of zero or more <strong class="term">items</strong>, which can be either <span class="italic">atomic</span> (scalar) values or XML <span class="italic">nodes</span>. Items are typed using a rich type system that is based upon the types of XML Schema. This type system is a major change from that of XPath 1.0, which is limited to simple scalar types such as Boolean, number, and string. 
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D" title="XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.">XQuery: A Functional Language Based on Sequences</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6036"></a><div class="props_rev_3"><a id="GUID-30341909-E378-4909-B54B-D112A6144C5B" name="GUID-30341909-E378-4909-B54B-D112A6144C5B"></a><h5 id="ADXDB-GUID-30341909-E378-4909-B54B-D112A6144C5B" class="sect5"><span class="enumeration_section">4.1.2.2 </span>XQuery Is Referentially Transparent
                     </h5>
                     <div>
                        <p>XQuery is a <span class="italic">functional</span> language. As such, it consists of a set of possible <span class="italic">expressions</span> that are <span class="italic">evaluated</span> and whose evaluation returns <span class="italic">values</span> (results).
                        </p>
                        <p> The result of evaluating an XQuery expression has two parts, at least one of which is empty: (a) a sequence (an XDM instance) and (b) a <strong class="term">pending update list</strong>. Informally, the sequence is sometimes spoken of as the expression value, especially when the pending update list is empty, meaning that no data updates are involved.
                        </p>
                        <p>As a functional language, XQuery is also <strong class="term">referentially transparent</strong>. This means that the <span class="italic">same expression</span> evaluated in the <span class="italic">same context</span> returns the <span class="italic">same value</span>.
                        </p>
                        <p><span class="italic">Exceptions</span> to this desirable mathematical property include the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>XQuery expressions that derive their value from interaction with the external environment. For example, an expression such as <code class="codeph">fn:current-time(...)</code> or <code class="codeph">fn:doc(...)</code> does not necessarily always return the same value, since it depends on external conditions that can change (the time changes; the content of the target document might change). 
                              </p>
                              <p>In some cases, like that of <code class="codeph">fn:doc</code>, XQuery is defined to be referentially transparent within the execution of a single query: within a query, each invocation of <code class="codeph">fn:doc</code> with the same argument results in the same document.
                              </p>
                           </li>
                           <li>
                              <p>XQuery expressions that are defined to be dependent on the particular XQuery language implementation. The result of evaluating such expressions might vary between implementations. Function <code class="codeph">fn:doc</code> is an example of a function that is essentially implementation-defined.
                              </p>
                           </li>
                        </ul>
                        <p>XQuery Update is not in the list; it does <span class="italic">not</span> present an exception to referential transparency. See <a href="xquery-and-XML-DB.html#GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB" title="Referential transparency applies to the evaluation of XQuery expressions. It does not imply that this evaluation never has a side effect on your data. In particular, you use XQuery Update to modify your data. That modification is a side effect of evaluating an XQuery updating expression.">XQuery Update Has Side Effects on Your Data</a>.
                        </p>
                        <p>Referential transparency applies also to XQuery <span class="italic">variables</span>: the same variable in the same context has the same value. Functional languages are like mathematics formalisms in this respect and unlike procedural, or imperative, programming languages. A variable in a procedural language is really a name for a memory location; it has a <span class="italic">current</span> value, or state, as represented by its content at any time. A variable in a declarative language such as XQuery is really a name for a <span class="italic">static</span> value.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D" title="XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.">XQuery: A Functional Language Based on Sequences</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6037"></a><div class="props_rev_3"><a id="GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB" name="GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB"></a><h5 id="ADXDB-GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB" class="sect5"><span class="enumeration_section">4.1.2.3 </span>XQuery Update Has Side Effects on Your Data
                     </h5>
                     <div>
                        <p>Referential transparency applies to the evaluation of XQuery expressions. It does not imply that this evaluation never has a <span class="italic">side effect</span> on your <span class="italic">data</span>. In particular, you use XQuery Update to modify your data. That modification is a side effect of evaluating an XQuery updating expression.
                        </p>
                        <p>The side effect is one thing; the expression value is another. The value returned from evaluation includes the pending update list that describes the updates to carry out. For a given XQuery expression, this description is the same regardless of the context in which evaluation occurs (with the above-mentioned exceptions).</p>
                        <p>The XQuery Update standard defines how the XDM instances of your data are updated. How those updates are propagated to persistent data stores (for example <code class="codeph">XMLType</code> tables and columns) is implementation-dependent.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D" title="XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.">XQuery: A Functional Language Based on Sequences</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6038"></a><div class="props_rev_3"><a id="GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE" name="GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE"></a><h5 id="ADXDB-GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE" class="sect5"><span class="enumeration_section">4.1.2.4 </span>XQuery Update Snapshots
                     </h5>
                     <div>
                        <p>An XQuery expression (query) can call for more than one update operation. XQuery Update performs all such operations for the same query as an <span class="italic">atomic</span> operation: either they all succeed or none of them do (if an error is raised).
                        </p>
                        <p>The unit of change is thus an entire XQuery query. To effect this atomic update behavior, before evaluating your query XQuery Update takes a <strong class="term">snapshot</strong> of the data (XDM instances) whose modification is called for by the query. It also adds the update operations called for by the query to the pending update list. The snapshot is an evaluation context for an XDM instance that is the update target.
                        </p>
                        <p>As the last step of XQuery expression evaluation, the pending update list is processed, applying the indicated update operations in an atomic fashion, and terminating the snapshot.</p>
                        <p>The atomic nature of snapshot semantics means that a set of update operations used in a given query are not necessarily applied in the order written. In fact, the order of applying update operations is fixed and specified by the XQuery Update Feature standard.</p>
                        <p>This means that <span class="italic">an update operation does not see the result of any other update operation for the same query</span>. There is no notion of an intermediate or interim update state &#x2013; all updates for a query are applied together, atomically.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D" title="XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.">XQuery: A Functional Language Based on Sequences</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6140"></a><div class="props_rev_3"><a id="GUID-804D83E9-23F3-4E70-B836-FD30793276D9" name="GUID-804D83E9-23F3-4E70-B836-FD30793276D9"></a><h5 id="ADXDB-GUID-804D83E9-23F3-4E70-B836-FD30793276D9" class="sect5"><span class="enumeration_section">4.1.2.5 </span>XQuery Full Text Provides Full-Text Search
                     </h5>
                     <div>
                        <p>The XQuery and XPath Full Text 1.0 Recommendation (XQuery Full Text) defines XQuery support for full-text searches in queries. It defines full-text selection operators that perform the search and return instances of the AllMatches model, which complements the XQuery Data Model (XDM). </p>
                        <p>An AllMatches instance describes all possible solutions to a full-text query for a given search context item. Each solution is described by a Match instance, which contains the search-context tokens (StringInclude instances) that must be included and those (StringExclude instances) that must be excluded.</p>
                        <p>In short, XQuery Full Text adds a full-text contains expression to the XQuery language. You use such an expression in your query to search the text of element nodes and their descendent elements (you can also search the text of attribute nodes).</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-498BE184-4F83-4FF8-8799-47D606F9066D" title="XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.">XQuery: A Functional Language Based on Sequences</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB5091"></a><div class="props_rev_3"><a id="GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" name="GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED"></a><h4 id="ADXDB-GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" class="sect4"><span class="enumeration_section">4.1.3 </span>XQuery Expressions
                  </h4>
                  <div>
                     <p>XQuery expressions are case-sensitive. An XQuery expression is either a <span class="italic">simple</span> expression or an <span class="italic">updating</span> expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:
                     </p>
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><strong class="term">Basic updating expression &#x2013;</strong> an <code class="codeph">insert</code>, <code class="codeph">delete</code>, <code class="codeph">replace</code>, or <code class="codeph">rename</code> expression, or a call to an <span class="italic">updating function</span> (see the XQuery Update Facility 1.0 Recommendation).
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Updating expression &#x2013;</strong> a basic updating expression or an expression (other than a transform expression) that contains another updating expression (this is a recursive definition).
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Simple expression &#x2013;</strong> An XQuery 1.0 expression. It does not call for any updating.
                              </p>
                           </li>
                        </ul>
                        <p>The pending update list that results from evaluating a simple expression is empty. The sequence value that results from evaluating an updating expression is empty.</p>
                        <p><span class="italic">Simple</span> expressions include the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><strong class="term">Primary expression &#x2013;</strong> literal, variable, or function application. A variable name starts with a dollar-sign (<code class="codeph">$</code>) &#x2013; for example, <code class="codeph">$foo</code>. Literals include numerals, strings, and character or entity references.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">XPath expression &#x2013; </strong>Any XPath expression. The XPath 2.0 standard is a subset of XQuery.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">FLWOR expression &#x2013;</strong> The most important XQuery expression, composed of the following, in order, from which FLWOR takes its name: <code class="codeph">for</code>, <code class="codeph">let</code>, <code class="codeph">where</code>, <code class="codeph">order by</code>, <code class="codeph">return</code>.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">XQuery sequence</strong> &#x2013; The comma (<code class="codeph">,</code>) constructor creates sequences. Sequence-manipulating functions such as <code class="codeph">union</code> and <code class="codeph">intersect</code> are also available. All XQuery sequences are effectively <strong class="term">flat</strong>: a nested sequence is treated as its flattened equivalent. Thus, for instance, <code class="codeph">(1, 2, (3, 4, (5), 6), 7)</code> is treated as <code class="codeph">(1, 2, 3, 4, 5, 6, 7)</code>. A singleton sequence, such as <code class="codeph">(42)</code>, acts the same in most XQuery contexts as does its single item, <code class="codeph">42</code>. Remember that the result of any XQuery expression is a sequence.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Direct (literal) constructions</strong> &#x2013; XML element and attribute syntax automatically constructs elements and attributes: what you see is what you get. For example, the XQuery expression <code class="codeph">&lt;a&gt;33&lt;/a&gt;</code> constructs the XML element <code class="codeph">&lt;a&gt;33&lt;/a&gt;</code>.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Computed (dynamic) constructions &#x2013; </strong>You can construct XML data at run time using computed values. For example, the following XQuery expression constructs this XML data: <code class="codeph">&lt;foo toto="5"&gt;&lt;bar&gt;tata titi&lt;/bar&gt; why? &lt;/foo&gt;</code>. 
                              </p><pre class="pre codeblock"><code>&lt;foo&gt;attribute toto {2+3},
     element bar {"tata", "titi"},
     text {" why? "}&lt;/foo&gt;
</code></pre><p>In this example, element <code class="codeph">foo</code> is a direct construction; the other constructions are computed. In practice, the arguments to computed constructors are not literals (such as <code class="codeph">toto</code> and <code class="codeph">"tata"</code>), but expressions to be evaluated (such as <code class="codeph">2+3</code>). Both the name and the value arguments of an element or attribute constructor can be computed. Braces (<code class="codeph">{</code>, <code class="codeph">}</code>) are used to mark off an XQuery expression to be evaluated.
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Conditional expression &#x2013;</strong> As usual, but remember that each part of the expression is itself an arbitrary expression. For instance, in this conditional expression, each of these subexpressions can be any XQuery expression: <code class="codeph">something</code>, <code class="codeph">somethingElse</code>, <code class="codeph">expression1</code>, and <code class="codeph">expression2</code>.
                              </p><pre class="pre codeblock"><code> if (something &lt; somethingElse) then expression1 else expression2
</code></pre></li>
                           <li>
                              <p><strong class="term">Arithmetic, relational expression &#x2013;</strong> As usual, but remember that each relational expression returns a (Boolean<a id="fn_1" name="fn_1" href="#fn_1" onclick="footdisplay(1, "The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value.")"><sup>Foot&nbsp;1</sup></a>) value. Examples:
                              </p><pre class="pre codeblock"><code>2 + 3
42 &lt; $a + 5
(1, 4) = (1, 2)
5 &gt; 3 eq true()
</code></pre></li>
                           <li>
                              <p><strong class="term">Quantifier expression &#x2013;</strong> Universal (<code class="codeph">every</code>) and existential (<code class="codeph">some</code>) quantifier functions provide shortcuts to using a FLWOR expression in some cases. Examples:
                              </p><pre class="pre codeblock"><code>every $foo in doc("bar.xml")//Whatever satisfies $foo/@bar &gt; 42
some $toto in (42, 5), $titi in (123, 29, 5) satisfies $toto = $titi
</code></pre></li>
                           <li>
                              <p><strong class="term">Regular expression &#x2013;</strong> XQuery regular expressions are based on XML Schema 1.0 and Perl. (See <a href="xquery-and-XML-DB.html#GUID-22940B8D-1468-4966-9F55-7DD4518E9612" title="Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest XQuery 1.0 and XPath 2.0 Functions and Operators specification, with a few exceptions.">Support for XQuery Functions and Operators</a>.)
                              </p>
                           </li>
                           <li>
                              <p><strong class="term">Type expression &#x2013;</strong> An XQuery expression that represents an XQuery type. Examples: <code class="codeph">item()</code>, <code class="codeph">node()</code>, <code class="codeph">attribute()</code>, <code class="codeph">element()</code>, <code class="codeph">document-node()</code>, <code class="codeph">namespace()</code>, <code class="codeph">text()</code>, <code class="codeph">xs:integer</code>, <code class="codeph">xs:string</code>.<a id="fn_2" name="fn_2" href="#fn_2" onclick="footdisplay(2, "Namespace prefix xs is predefined for the XML Schema namespace, http://www.w3.org/2001/XMLSchema.")"><sup>Foot&nbsp;2</sup></a></p>
                              <p>Type expressions can have <strong class="term">occurrence indicators</strong>: <span class="bold"><code class="codeph">?</code></span> (optional: zero or one),<span class="bold"><code class="codeph"> *</code></span> (zero or more), <span class="bold"><code class="codeph">+</code></span> (one or more). Examples: <code class="codeph">document-node(element())*</code>, <code class="codeph">item()+</code>, <code class="codeph">attribute()?</code>.
                              </p>
                              <p>XQuery also provides operators for working with types. These include <code class="codeph">cast as</code>, <code class="codeph">castable as</code>, <code class="codeph">treat as</code>, <code class="codeph">instance of</code>, <code class="codeph">typeswitch</code>, and <code class="codeph">validate</code>. For example, <code class="codeph">"42" cast as xs:integer</code> is an expression whose value is the integer 42. (It is not, strictly speaking, a type expression, because its value does not represent a type.)
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Full-text contains expression</span> &#x2013; An XQuery expression that represents a full-text search. This expression is provided by the XQuery and XPath Full Text 1.0 Recommendation. A full-text contains expression (FTContainsExpr) supported by Oracle has these parts: a <span class="bold">search context</span> that specifies the items to search, and a <span class="bold">full-text selection</span> that filters those items, selecting matches.
                              </p>
                              <p>The selection part is itself composed of the following:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="bold">Tokens and phrases</span> used for matching.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Optional <span class="bold">match options</span>, such as the use of stemming.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Optional <span class="bold">Boolean operators</span> for combining full-text selections.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Optional constraint operators, such as <span class="bold">positional filters</span> (e.g. <code class="codeph">ordered window</code>).
                                    </p>
                                 </li>
                              </ul>
                              <p>See <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-927FB610-9553-4772-8D3E-FAA7546C4371" title="XQuery is the W3C language designed for querying and updating XML data.">Overview of the XQuery Language</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5092"></a><div class="props_rev_3"><a id="GUID-E40FFA59-701C-43F6-9A89-774321970A19" name="GUID-E40FFA59-701C-43F6-9A89-774321970A19"></a><h4 id="ADXDB-GUID-E40FFA59-701C-43F6-9A89-774321970A19" class="sect4"><span class="enumeration_section">4.1.4 </span>FLWOR Expressions
                  </h4>
                  <div>
                     <p>Just as for XQuery in general, there is a lot to learn about FLWOR expressions in particular. This section provides a brief overview.</p>
                     <div class="section">
                        <p>FLWOR is the most general expression syntax in XQuery. FLWOR (pronounced "flower") stands for <code class="codeph">for</code>, <code class="codeph">let</code>, <code class="codeph">where</code>, <code class="codeph">order by</code>, and <code class="codeph">return</code>. A FLWOR expression has at least one <code class="codeph">for</code> or <code class="codeph">let</code> clause and a <code class="codeph">return</code> clause; single <code class="codeph">where</code> and <code class="codeph">order by</code> clauses are optional. Only the <code class="codeph">return</code> clause can contain an updating expression; the other clauses cannot.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold"><code class="codeph">for</code></span> &#x2013; Bind one or more variables each to any number of values, in turn. That is, for each variable, iterate, binding the variable to a different value for each iteration.
                              </p>
                              <p>At each iteration, the variables are bound in the order they appear, so that the value of a variable <code class="codeph">$earlier</code> that is listed before a variable <code class="codeph">$later</code> in the <code class="codeph">for</code> list, can be used in the binding of variable <code class="codeph">$later</code>. For example, during its second iteration, this expression binds <code class="codeph">$i</code> to <code class="codeph">4</code> and <code class="codeph">$j</code> to <code class="codeph">6</code> (2+4):
                              </p><pre class="oac_no_warn" dir="ltr"> for $i in (3, 4), $j in ($i, 2+$i)
</pre></li>
                           <li>
                              <p><span class="bold"><code class="codeph">let</code></span> &#x2013; Bind one or more variables.
                              </p>
                              <p>Just as with <code class="codeph">for</code>, a variable can be bound by <code class="codeph">let</code> to a value computed using another variable that is listed previously in the binding list of the <code class="codeph">let</code> (or an enclosing <code class="codeph">for</code> or <code class="codeph">let</code>). For example, this expression binds <code class="codeph">$j</code> to <code class="codeph">5</code> (3+2):
                              </p><pre class="oac_no_warn" dir="ltr">let $i := 3, $j := $i + 2
</pre></li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span> &#x2013; Filter the <code class="codeph">for</code> and <code class="codeph">let</code> variable bindings according to some condition. This is similar to a SQL <code class="codeph">WHERE</code> clause.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">order by</code></span> &#x2013; Sort the result of <code class="codeph">where</code> filtering.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">return</code></span> &#x2013; Construct a result from the ordered, filtered values. This is the result of the FLWOR expression as a whole. It is a flattened sequence. 
                              </p>
                              <p>If the <code class="codeph">return</code> clause contains an updating expression then that expression is evaluated for each tuple generated by the other clauses. The pending update lists from these evaluations are then merged as the result of the FLWOR expression.
                              </p>
                           </li>
                        </ul>
                        <p>Expressions <code class="codeph">for</code> and <code class="codeph">let</code> act similarly to a SQL <code class="codeph">FROM</code> clause. Expression <code class="codeph">where</code> acts like a SQL <code class="codeph">WHERE</code> clause Expression <code class="codeph">order by</code> is similar to <code class="codeph">ORDER BY</code> in SQL. Expression <code class="codeph">return</code> is like <code class="codeph">SELECT</code> in SQL. Except for the two keywords whose names are the same in both languages (<code class="codeph">where</code>, <code class="codeph">order by</code>), FLWOR clause order is more or less opposite to the SQL clause order, but the meanings of the corresponding clauses are quite similar.
                        </p>
                        <p>Using a FLWOR expression (with <code class="codeph">order by</code>) is the <span class="italic">only</span> way to construct an XQuery sequence in any order other than document order.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-927FB610-9553-4772-8D3E-FAA7546C4371" title="XQuery is the W3C language designed for querying and updating XML data.">Overview of the XQuery Language</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5088"></a><div class="props_rev_3"><a id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE" name="GUID-7DB63F8C-F441-4635-A185-4016016B22CE"></a><h3 id="ADXDB-GUID-7DB63F8C-F441-4635-A185-4016016B22CE" class="sect3"><span class="enumeration_section">4.2 </span>Overview of XQuery in Oracle XML&nbsp;DB
               </h3>
               <div>
                  <p>Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>. As a convenience, SQL*Plus command <code class="codeph">XQUERY</code> is also provided, which lets you enter XQuery expressions directly — in effect, this command turns SQL*Plus into an XQuery command-line interpreter.
                  </p>
                  <p>Oracle XML&nbsp;DB compiles XQuery expressions that are passed as arguments to SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>. This compilation produces SQL query blocks and operator trees that use SQL/XML functions and XPath functions. A SQL statement that includes <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, or <code class="codeph">XMLCast</code> is compiled and optimized as a whole, leveraging both relational database and XQuery-specific optimization technologies. Depending on the XML storage and indexing methods used, XPath functions can be further optimized. The resulting optimized operator tree is executed in a streaming fashion.
                  </p>
                  <div class="infoboxnote" id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE__GUID-782F88A1-4C1E-49D8-9A87-926C369F0A33">
                     <p class="notep1">Note:</p>
                     <p>Oracle XML Developer's Kit (XDK) supports XQuery on the mid-tier. You do not need access to Oracle Database to use XQuery. XDK lets you evaluate XQuery expressions using XQuery API for Java (XQJ).</p>
                  </div>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8">When To Use XQuery</a><br>You can use XQuery to do many of the same things that you might do using the SQL/XML generation functions or XSLT; there is a great deal of overlap. The decision to use one or the other tool to accomplish a given task can be based on many considerations, most of which are not specific to Oracle Database. Please consult external documentation on this general question.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702">Predefined XQuery Namespaces and Prefixes</a><br>Several namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></li>
                        <li><a href="query-and-update-XML.html#GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1" title="You can evaluate an XQuery expression using the SQL*Plus XQUERY command.">Using the SQL*Plus XQUERY Command</a></li>
                        <li><a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based.">Query and Update of XML Data</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE__GUID-1F192021-649E-4547-B18B-3A10DE22BEAB">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a> for Oracle-specific XQuery functions that extend the language
                           </p>
                        </li>
                        <li>
                           <p><a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a> for details about Oracle XML&nbsp;DB support for XQuery
                           </p>
                        </li>
                        <li>
                           <p><a href="../adxdk/using-xquery-processor-for-Java.html#ADXDK99930" target="_blank"><span><cite>Oracle XML Developer's Kit Programmer's Guide</cite></span></a> for information about using XQJ
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5103"></a><div class="props_rev_3"><a id="GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8" name="GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8"></a><h4 id="ADXDB-GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8" class="sect4"><span class="enumeration_section">4.2.1 </span>When To Use XQuery
                  </h4>
                  <div>
                     <p>You can use XQuery to do many of the same things that you might do using the SQL/XML generation functions or XSLT; there is a great deal of overlap. The decision to use one or the other tool to accomplish a given task can be based on many considerations, most of which are not specific to Oracle Database. Please consult external documentation on this general question.</p>
                     <p>A general pattern of use is that XQuery is often used when the focus is the world of XML data, and the SQL/XML generation functions (<code class="codeph">XMLElement</code>, <code class="codeph">XMLAgg</code>, and so on) are often used when the focus is the world of relational data.
                     </p>
                     <p>Other things being equal, if a query constructs an XML document from fragments extracted from existing XML documents, then it is likely that an XQuery FLOWR expression is simpler (simplifying code maintenance) than extracting scalar values from relational data and constructing appropriate XML data using SQL/XML generation functions. If, instead, a query constructs an XML document from existing relational data, the SQL/XML generation functions can often be more suitable.</p>
                     <p>With respect to Oracle XML&nbsp;DB, you can expect the same general level of performance using the SQL/XML generation functions as with <code class="codeph">XMLQuery</code> and <code class="codeph">XMLTable</code> — all are subject to rewrite optimizations.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-7DB63F8C-F441-4635-A185-4016016B22CE" title="Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast. As a convenience, SQL*Plus command XQUERY is also provided, which lets you enter XQuery expressions directly — in effect, this command turns SQL*Plus into an XQuery command-line interpreter.">Overview of XQuery in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5105"></a><a id="ADXDB5104"></a><div class="props_rev_3"><a id="GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702" name="GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702"></a><h4 id="ADXDB-GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702" class="sect4"><span class="enumeration_section">4.2.2 </span>Predefined XQuery Namespaces and Prefixes
                  </h4>
                  <div>
                     <p>Several namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB.</p>
                     <div class="tblformalwide" id="GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702__GUID-C082A7D9-3289-4D4E-8F2A-BFA3AA934064">
                        <p class="titleintable">Table 4-2 Predefined Namespaces and Prefixes</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Predefined Namespaces and Prefixes" summary="This table lists predefined namespaces and prefixes  for use with XQuery in Oracle XML&nbsp;DB." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="7%" id="d20054e1921">Prefix</th>
                                 <th align="left" valign="bottom" width="56%" id="d20054e1924">Namespace</th>
                                 <th align="left" valign="bottom" width="37%" id="d20054e1927">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1932" headers="d20054e1921 ">
                                    <p><code class="codeph">ora</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1932 d20054e1924 ">
                                    <p><code class="codeph">http://xmlns.oracle.com/xdb</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1932 d20054e1927 ">
                                    <p>Oracle XML&nbsp;DB namespace</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1944" headers="d20054e1921 ">
                                    <p><code class="codeph">local</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1944 d20054e1924 ">
                                    <p><code class="codeph">http://www.w3.org/2003/11/xpath-local-functions</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1944 d20054e1927 ">
                                    <p>XPath local function declaration namespace</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1956" headers="d20054e1921 ">
                                    <p><code class="codeph">fn</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1956 d20054e1924 ">
                                    <p><code class="codeph">http://www.w3.org/2003/11/xpath-functions</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1956 d20054e1927 ">
                                    <p>XPath function namespace</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1968" headers="d20054e1921 ">
                                    <p><code class="codeph">xml</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1968 d20054e1924 ">
                                    <p><code class="codeph">http://www.w3.org/XML/1998/namespace</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1968 d20054e1927 ">
                                    <p>XML namespace</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1980" headers="d20054e1921 ">
                                    <p><code class="codeph">xs</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1980 d20054e1924 ">
                                    <p><code class="codeph">http://www.w3.org/2001/XMLSchema</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1980 d20054e1927 ">
                                    <p>XML Schema namespace</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="7%" id="d20054e1992" headers="d20054e1921 ">
                                    <p><code class="codeph">xsi</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d20054e1992 d20054e1924 ">
                                    <p><code class="codeph">http://www.w3.org/2001/XMLSchema-instance</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d20054e1992 d20054e1927 ">
                                    <p>XML Schema instance namespace</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>You can use these prefixes in XQuery expressions without first declaring them in the XQuery-expression prolog. You can redefine any of them <span class="italic">except</span> <code class="codeph">xml</code> in the prolog. All of these prefixes except <code class="codeph">ora</code> are predefined in the XQuery standard.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-7DB63F8C-F441-4635-A185-4016016B22CE" title="Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast. As a convenience, SQL*Plus command XQUERY is also provided, which lets you enter XQuery expressions directly — in effect, this command turns SQL*Plus into an XQuery command-line interpreter.">Overview of XQuery in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5093"></a><div class="props_rev_3"><a id="GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" name="GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392"></a><h3 id="ADXDB-GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" class="sect3"><span class="enumeration_section">4.3 </span>SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast
               </h3>
               <div>
                  <p>SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code> are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages. 
                  </p>
                  <p>They are referred to in this book as SQL/XML <span class="italic">query and update</span> functions. As is the case for the other SQL/XML functions, these functions let you take advantage of the power and flexibility of both SQL and XML. Using these functions, you can construct XML data using relational data, query relational data as if it were XML, and construct relational data from XML data.
                  </p>
                  <p>SQL functions <code class="codeph">XMLExists</code> and <code class="codeph">XMLCast</code> are documented elsewhere in this chapter. This section presents functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLTable</code>, but many of the examples in this chapter use also <code class="codeph">XMLExists</code> and <code class="codeph">XMLCast</code>. In terms of typical use:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code> are typically used in a <code class="codeph">SELECT</code> list.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLTable</code> is typically used in a SQL <code class="codeph">FROM</code> clause.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLExists</code> is typically used in a SQL <code class="codeph">WHERE</code> clause.
                        </p>
                     </li>
                  </ul>
                  <p>Both <code class="codeph">XMLQuery</code> and <code class="codeph">XMLTable</code> evaluate an XQuery expression. In the XQuery language, an expression always returns a sequence of items. Function <code class="codeph">XMLQuery</code> aggregates the items in this sequence to return a single XML document or fragment. Function <code class="codeph">XMLTable</code> returns a SQL table whose rows each contain one item from the XQuery sequence.
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D">XMLQUERY SQL/XML Function in Oracle XML&nbsp;DB</a><br>Use SQL/XML function <code class="codeph">XMLQuery</code> to construct or query XML data. 
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a><br>You use SQL/XML function <code class="codeph">XMLTable</code> to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL — in a join expression, for example.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6">XMLEXISTS SQL/XML Function in Oracle XML&nbsp;DB</a><br>SQL/XML standard function <code class="codeph">XMLExists</code> checks whether a given XQuery expression returns a non-empty XQuery sequence. If so, the function returns <code class="codeph">TRUE</code>. Otherwise, it returns <code class="codeph">FALSE</code>. 
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09">Using XMLExists to Find a Node</a><br>You can use SQL/XML standard function <code class="codeph">XMLExists</code> to find a given node. You can create function-based indexes using <code class="codeph">XMLExists</code>. You can also create an <code class="codeph">XMLIndex</code> index to help speed up arbitrary XQuery searching.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB">XMLCAST SQL/XML Function in Oracle XML&nbsp;DB</a><br>You can use SQL/XML function <code class="codeph">XMLCast</code> to cast an XQuery value to a SQL data type.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-A96B4300-2478-43AF-855F-7E104CCE925A">Using XMLCAST to Extract the Scalar Value of an XML Fragment</a><br>You can use standard SQL/XML function <code class="codeph">XMLCast</code> to extract the scalar value of an XML fragment.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392__GUID-F1AFE77A-6B26-4920-BC53-E8AFFB715196">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../sqlrf/Oracle-Compliance-with-SQLXML2011.html#SQLRF55529" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about Oracle support for the SQL/XML standard
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_xquery_30" target="_blank"><code class="codeph">http://www.w3.org/TR/xquery-30/</code></a> for information about the XQuery language
                           </p>
                        </li>
                        <li>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a> for information about using other SQL/XML functions with Oracle XML&nbsp;DB
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5095"></a><a id="ADXDB5096"></a><a id="ADXDB5094"></a><div class="props_rev_3"><a id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D" name="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D"></a><h4 id="ADXDB-GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D" class="sect4"><span class="enumeration_section">4.3.1 </span>XMLQUERY SQL/XML Function in Oracle XML&nbsp;DB
                  </h4>
                  <div>
                     <p>Use SQL/XML function <code class="codeph">XMLQuery</code> to construct or query XML data. 
                     </p>
                     <div class="section">
                        <p>The function takes as arguments an <span class="italic">XQuery expression</span>, as a string literal, and an optional XQuery <span class="italic">context item</span>, as a SQL expression. The context item establishes the XPath context in which the XQuery expression is evaluated. Additionally, <code class="codeph">XMLQuery</code> accepts as arguments any number of SQL expressions whose values are bound to XQuery variables during the XQuery expression evaluation. 
                        </p>
                        <p>The function returns the result of evaluating the XQuery expression, as an <code class="codeph">XMLType</code> instance.
                        </p>
                        <div class="figure" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-5949ADC3-2BA0-4D1B-B977-2392E58209CE">
                           <p class="titleinfigure">Figure 4-1 XMLQUERY Syntax</p><img src="img/xmlquery.gif" width="572" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows" longdesc="img_text/xmlquery.html"><br><a href="img_text/xmlquery.html">Description of "Figure 4-1 XMLQUERY Syntax"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-EE69233D-3CC9-4A42-8370-347462A28F2C"><span class="italic">XML_passing_clause ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-8DD05470-F308-4A02-B114-EEFFB46AA784"><img src="img/xml_passing_clause.gif" width="373" alt="Description of xml_passing_clause.eps follows" title="Description of xml_passing_clause.eps follows" longdesc="img_text/xml_passing_clause.html"><br><a href="img_text/xml_passing_clause.html">Description of the illustration xml_passing_clause.eps</a></div>
                        <!-- class="figure" -->
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">XQuery_string</code></span> is a complete XQuery expression, possibly including a prolog, as a literal string.
                              </p>
                           </li>
                           <li>
                              <p>The <span class="italic"><code class="codeph">XML_passing_clause</code></span> is the keyword <code class="codeph">PASSING</code> followed by one or more SQL expressions (<span class="italic"><code class="codeph">expr</code></span>) that each return an <code class="codeph">XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<span class="italic"><code class="codeph">expr</code></span>) can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. All but possibly one of the expressions must each be followed by the keyword <code class="codeph">AS</code> and an XQuery <span class="italic"><code class="codeph">identifier</code></span>. The result of evaluating each <span class="italic"><code class="codeph">expr</code></span> is bound to the corresponding <span class="italic"><code class="codeph">identifier</code></span> for the evaluation of <span class="italic"><code class="codeph">XQuery_string</code></span>. If there is an <span class="italic"><code class="codeph">expr</code></span> that is not followed by an <code class="codeph">AS</code> clause, then the result of evaluating that <span class="italic"><code class="codeph">expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code class="codeph">XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code class="codeph">BY VALUE</code>, not passing <code class="codeph">BY REFERENCE</code>, so the clause <code class="codeph">BY VALUE</code> is implicit and can be omitted.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">RETURNING</code> <code class="codeph">CONTENT</code> indicates that the value returned by an application of <code class="codeph">XMLQuery</code> is an instance of parameterized XML type <code class="codeph">XML(CONTENT)</code>, not parameterized type <code class="codeph">XML(SEQUENCE)</code>. It is a document fragment that conforms to the <span class="italic">extended</span> Infoset data model. As such, it is a single document node with any number of children. The children can each be of any XML node type; in particular, they can be text nodes.
                              </p>
                              <p>Oracle XML&nbsp;DB supports only the <code class="codeph">RETURNING CONTENT</code> clause of SQL/XML function <code class="codeph">XMLQuery</code>; it does <span class="italic">not</span> support the <code class="codeph">RETURNING SEQUENCE</code> clause. 
                              </p>
                           </li>
                        </ul>
                        <p>You can pass an <code class="codeph">XMLType</code> column, table, or view as the context-item argument to function <code class="codeph">XMLQuery</code> — see, for example, <a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">Example 5-8</a>. 
                        </p>
                        <p>To query a relational table or view as if it were XML data, without having to first create a SQL/XML view on top of it, use XQuery function <code class="codeph">fn:collection</code> within an XQuery expression, passing as argument a URI that uses the URI-scheme name <code class="codeph">oradb</code> together with the database location of the data. See <a href="xquery-and-XML-DB.html#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" title="You can use XQuery function fn:collection to query data that is in database tables and views.">URI Scheme oradb: Querying Table or View Data with XQuery</a>.
                        </p>
                        <div class="infoboxnote" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-26743142-E095-4BF3-91EE-6E9917038A40">
                           <p class="notep1">Note:</p>
                           <p>Prior to Oracle Database&nbsp;11g Release 2, some users employed Oracle SQL functions <code class="codeph">extract</code> and <code class="codeph">extractValue</code> to do some of what can be done better using SQL/XML functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code>. SQL functions <code class="codeph">extract</code> and <code class="codeph">extractValue</code> are <span class="italic">deprecated</span> in Oracle Database&nbsp;11g Release 2.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-057688BE-89D5-4DE4-8F00-3BE6BA782D4C">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/XMLQUERY.html#SQLRF06209" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for reference information about SQL/XML function <code class="codeph">XMLQuery</code> in Oracle Database
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5098"></a><a id="ADXDB5099"></a><a id="ADXDB5100"></a><a id="ADXDB5101"></a><a id="ADXDB5102"></a><a id="ADXDB5097"></a><div class="props_rev_3"><a id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10" name="GUID-F4508470-D420-4B5A-B5DF-59A424887F10"></a><h4 id="ADXDB-GUID-F4508470-D420-4B5A-B5DF-59A424887F10" class="sect4"><span class="enumeration_section">4.3.2 </span>XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB
                  </h4>
                  <div>
                     <p>You use SQL/XML function <code class="codeph">XMLTable</code> to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL — in a join expression, for example.
                     </p>
                     <div class="section">
                        <p>See<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">Example 5-9</a>. 
                        </p>
                        <p>You use <code class="codeph">XMLTable</code>  in a SQL <code class="codeph">FROM</code> clause. 
                        </p>
                        <div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-B85490F0-F81B-4EBA-B66B-CAA4F604A14F">
                           <p class="titleinfigure">Figure 4-2 XMLTABLE Syntax</p><img src="img/xmltable.gif" width="482" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows" longdesc="img_text/xmltable.html"><br><a href="img_text/xmltable.html">Description of "Figure 4-2 XMLTABLE Syntax"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-C23FDE22-744A-4F94-8233-4FD96ECD7B56"><span class="italic">XML_namespaces_clause ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-55CA4B10-7AF2-4267-B4E9-97D32D783A1B"><img src="img/xml_namespaces_clause.gif" alt="Description of xml_namespaces_clause.eps follows" title="Description of xml_namespaces_clause.eps follows" longdesc="img_text/xml_namespaces_clause.html"><br><a href="img_text/xml_namespaces_clause.html">Description of the illustration xml_namespaces_clause.eps</a><p><span class="bold">Note:</span> You can specify at most one DEFAULT <span class="italic">string </span>clause.
                           </p>
                        </div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-DC1611CC-1F25-4A30-809D-D266AA170CD7"><span class="italic">XMLTABLE_options ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-1F93FAB4-CDF9-4E02-ADE6-0AAEA6CC6D48"><img src="img/xmltable_options.gif" width="619" alt="Description of xmltable_options.eps follows" title="Description of xmltable_options.eps follows" longdesc="img_text/xmltable_options.html"><br><a href="img_text/xmltable_options.html">Description of the illustration xmltable_options.eps</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-CD5685A9-97FD-412C-8252-1DACCCD76675"><span class="italic">XML_passing_clause ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-447FD369-E6FC-40BE-8617-22B8E9C6DDD5"><img src="img/xml_passing_clause.gif" width="373" alt="Description of xml_passing_clause.eps follows" title="Description of xml_passing_clause.eps follows" longdesc="img_text/xml_passing_clause.html"><br><a href="img_text/xml_passing_clause.html">Description of the illustration xml_passing_clause.eps</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-1D3F22F4-928E-4EAE-952D-BFC9D6FEAFC7"><span class="italic">XML_table_column ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-C286CD70-ABAA-48B9-92F5-2408B2C78985"><img src="img/xml_table_column.gif" width="598" alt="Description of xml_table_column.eps follows" title="Description of xml_table_column.eps follows" longdesc="img_text/xml_table_column.html"><br><a href="img_text/xml_table_column.html">Description of the illustration xml_table_column.eps</a></div>
                        <!-- class="figure" -->
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">XQuery_string</code></span> is sometimes called the <strong class="term">row pattern</strong> of the XMLTable call. It is a complete XQuery expression, possibly including a prolog, as a literal string. The value of the expression serves as input to the <code class="codeph">XMLTable</code> function; it is this XQuery result that is decomposed and stored as relational data.
                              </p>
                           </li>
                           <li>
                              <p>The optional <code class="codeph">XMLNAMESPACES</code> clause contains XML namespace declarations that are referenced by <span class="italic"><code class="codeph">XQuery_string</code></span> and by the XPath expression in the <code class="codeph">PATH</code> clause of <span class="italic"><code class="codeph">XML_table_column</code></span>.
                              </p>
                           </li>
                           <li>
                              <p>The <span class="italic"><code class="codeph">XML_passing_clause</code></span> is the keyword <code class="codeph">PASSING</code> followed by one or more SQL expressions (<span class="italic"><code class="codeph">expr</code></span>) that each return an <code class="codeph">XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<span class="italic"><code class="codeph">expr</code></span>) can be a table or view column value, a PL/SQL variable, or a bind variables with proper casting. All but possibly one of the expressions must each be followed by the keyword <code class="codeph">AS</code> and an XQuery <span class="italic"><code class="codeph">identifier</code></span>. The result of evaluating each <span class="italic"><code class="codeph">expr</code></span> is bound to the corresponding <span class="italic"><code class="codeph">identifier</code></span> for the evaluation of <span class="italic"><code class="codeph">XQuery_string</code></span>. If there is an <span class="italic"><code class="codeph">expr</code></span> that is not followed by an <code class="codeph">AS</code> clause, then the result of evaluating that <span class="italic"><code class="codeph">expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code class="codeph">XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code class="codeph">BY VALUE</code>, not passing <code class="codeph">BY REFERENCE</code>, so the clause <code class="codeph">BY VALUE</code> is implicit and can be omitted.
                              </p>
                           </li>
                           <li>
                              <p>The optional <code class="codeph">COLUMNS</code> clause defines the columns of the virtual table to be created by <code class="codeph">XMLTable</code>. 
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If you omit the <code class="codeph">COLUMNS</code> clause, then <code class="codeph">XMLTable</code> returns a row with a single <code class="codeph">XMLType</code> pseudo-column, named <span class="bold"><code class="codeph">COLUMN_VALUE</code></span>.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FOR ORDINALITY</code> specifies that <span class="italic"><code class="codeph">column</code></span> is to be a column of generated row numbers (SQL data type <code class="codeph">NUMBER</code>). The row numbers start with 1. There must be at most one <code class="codeph">FOR ORDINALITY</code> clause.
                                    </p>
                                 </li>
                                 <li>
                                    <p>For each resulting <span class="italic"><code class="codeph">column</code></span> except the <code class="codeph">FOR ORDINALITY</code> column, you must specify the column data type, which can be <code class="codeph">XMLType</code> or any other SQL data type (called <span class="italic"><code class="codeph">datatype</code></span> in the syntax description). 
                                    </p>
                                 </li>
                                 <li>
                                    <p>For data type <code class="codeph">XMLType</code>, if you also include the specification <code class="codeph">(SEQUENCE) BY REF</code> then a <span class="italic">reference</span> to the source data targeted by the <code class="codeph">PATH</code> expression (<span class="italic"><code class="codeph">string</code></span>) is returned as the <span class="italic"><code class="codeph">column</code></span> content. Otherwise, <span class="italic"><code class="codeph">column</code></span> contains a <span class="italic">copy</span> of that targeted data.
                                    </p>
                                    <p>Returning the <code class="codeph">XMLType</code> data by reference lets you specify other columns whose paths target nodes in the source data that are outside those targeted by the <code class="codeph">PATH</code> expression for <span class="italic"><code class="codeph">column</code></span>. See <a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIDCFE">Example 5-13</a>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The optional <code class="codeph">PATH</code> clause specifies that the portion of the XQuery result that is addressed by XQuery expression <span class="italic"><code class="codeph">string</code></span> is to be used as the <span class="italic"><code class="codeph">column</code></span> content. This XQuery expression is sometimes called the <span class="bold">column pattern</span>. You can use multiple <code class="codeph">PATH</code> clauses to split the XQuery result into different virtual-table columns.
                                    </p>
                                    <p>If you omit <code class="codeph">PATH</code>, then the XQuery expression <span class="italic"><code class="codeph">column</code></span> is assumed. For example, these two expressions are equivalent:
                                    </p><pre class="oac_no_warn" dir="ltr">XMLTable(... COLUMNS foo)
XMLTable(... COLUMNS foo PATH 'FOO')
</pre><p>The XQuery expression <span class="italic"><code class="codeph">string</code></span> must represent a <span class="italic">relative</span> path; it is relative to the path <span class="italic"><code class="codeph">XQuery_string</code></span>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The optional <code class="codeph">DEFAULT</code> clause specifies the value to use when the <code class="codeph">PATH</code> expression results in an empty sequence (or <code class="codeph">NULL</code>). Its <span class="italic"><code class="codeph">expr</code></span> is an XQuery expression that is evaluated to produce the default value.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-FF0F3AA8-D2A7-457A-97B7-EBB42D7C4ACB">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/XMLTABLE.html#SQLRF06232" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for reference information about SQL/XML function <code class="codeph">XMLTable</code> in Oracle Database
                           </p>
                        </div>
                        <div class="infoboxnote" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-A2D89F13-FE6B-424B-BF70-BC904227B704">
                           <p class="notep1">Note:</p>
                           <p>Prior to Oracle Database&nbsp;11g Release 2, some users employed Oracle SQL function <code class="codeph">XMLSequence</code> within a SQL <code class="codeph">TABLE</code> collection expression, that is, <code class="codeph">TABLE (XMLSequence(...))</code>, to do some of what can be done better using SQL/XML function <code class="codeph">XMLTable</code>. Function <code class="codeph">XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11g Release 2.
                           </p>
                           <p>See <a href="../sqlrf/SELECT.html#SQLRF30047" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about the SQL <code class="codeph">TABLE</code> collection expression.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E">Chaining Calls to SQL/XML Function XMLTABLE</a><br>When you need to expose data contained at multiple levels in an <code class="codeph">XMLType</code> table as individual rows in a relational table (or view), you use the same general approach as for breaking up a single level: Use SQL/XML function <code class="codeph">XMLTable</code> to define the columns making up the table and map the XML nodes to those columns.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6416"></a><a id="ADXDB6415"></a><div class="props_rev_3"><a id="GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E" name="GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E"></a><h5 id="ADXDB-GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E" class="sect5"><span class="enumeration_section">4.3.2.1 </span>Chaining Calls to SQL/XML Function XMLTABLE
                     </h5>
                     <div>
                        <p>When you need to expose data contained at multiple levels in an <code class="codeph">XMLType</code> table as individual rows in a relational table (or view), you use the same general approach as for breaking up a single level: Use SQL/XML function <code class="codeph">XMLTable</code> to define the columns making up the table and map the XML nodes to those columns.
                        </p>
                        <div class="section">
                           <p>But in this case you apply function <code class="codeph">XMLTable</code> to each document level that is to be broken up and stored in relational columns. Use this technique of <strong class="term">chaining</strong> multiple <code class="codeph">XMLTable</code> calls whenever there is a one-to-<span class="italic">many</span> (1:N) relationship between documents in the <code class="codeph">XMLType</code> table and the rows in the relational table. 
                           </p>
                           <p>You pass one level of <code class="codeph">XMLType</code> data from one <code class="codeph">XMLTable</code> call to the next, specifying its column type as <code class="codeph">XMLType</code>.
                           </p>
                           <p>When you chain two <code class="codeph">XMLTable</code> calls, the <span class="italic">row pattern</span> of each call should target the <span class="italic">deepest node that is a common ancestor</span> to all of the nodes that are referenced in the <span class="italic">column patterns</span> of that call.
                           </p>
                           <p>This is illustrated in <a href="xquery-and-XML-DB.html#GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E__BABGABBE">Example 4-1</a>.
                           </p>
                           <p>Each <code class="codeph">PurchaseOrder</code> element in <code class="codeph">XMLType</code> table <code class="codeph">po_binaryxml</code> contains a <code class="codeph">LineItems</code> element, which in turn contains one or more <code class="codeph">LineItem</code> elements. Each <code class="codeph">LineItem</code> element has child elements, such as <code class="codeph">Description</code>, and an <code class="codeph">ItemNumber</code> attribute. To make such lower-level data accessible as a relational value, you use <code class="codeph">XMLTable</code> to project the collection of <code class="codeph">LineItem</code> elements.
                           </p>
                           <p>When element <code class="codeph">PurchaseOrder</code> is decomposed by the first call to <code class="codeph">XMLTable</code>, its descendant <code class="codeph">LineItem</code> element is mapped to a column of type <code class="codeph">XMLType</code>, which contains an XML fragment. That column is then passed to a second call to <code class="codeph">XMLTable</code> to be broken by it into its various parts as multiple columns of relational values.
                           </p>
                           <p>The first call to <code class="codeph">XMLTable</code> uses <code class="codeph">/PurchaseOrder</code> as the row pattern, because <code class="codeph">PurchaseOrder</code> is the deepest common ancestor node for the column patterns, <code class="codeph">Reference</code> and <code class="codeph">LineItems/LineItem</code>. 
                           </p>
                           <p>The second call to <code class="codeph">XMLTable</code> uses <code class="codeph">/LineItem</code> as its row pattern, because that node is the deepest common ancestor node for each of its column patterns (<code class="codeph">@ItemNumber</code>, <code class="codeph">Description</code>, <code class="codeph">Part/@Id</code>, and so on). 
                           </p>
                           <p>The <span class="italic">column pattern</span> (<code class="codeph">LineItems/LineItem</code>) for the column (<code class="codeph">po.lineitem</code>) that is passed from the first <code class="codeph">XMLTable</code> call t o the second <span class="italic">ends with the repeating element </span>(<code class="codeph">LineItem</code>) that the second <code class="codeph">XMLTable</code> call decomposes. That repeating element, written with a leading slash (<code class="codeph">/</code>), is used as the first element of the <span class="italic">row pattern</span> for the second <code class="codeph">XMLTable</code> call.
                           </p>
                           <p>The row pattern in each case is thus expressed as an <span class="italic">absolute</span> path; that is, it starts with <code class="codeph">/</code>. It is the starting point for decomposition by <code class="codeph">XMLTable</code>. Column patterns, on the other hand, <span class="italic">never</span> start with a slash (<code class="codeph">/</code>); they are always relative to the row pattern of the same <code class="codeph">XMLTable</code> call.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E__BABGABBE">
                           <p class="titleinexample">Example 4-1 Chaining XMLTable Calls</p><pre class="oac_no_warn" dir="ltr">  SELECT po.reference, li.*
    FROM po_binaryxml p,
         XMLTable('<span class="bold">/PurchaseOrder</span>' PASSING p.OBJECT_VALUE
                  COLUMNS
                    reference VARCHAR2(30) PATH 'Reference',
                    <span class="bold">lineitem</span>  XMLType      PATH '<span class="bold">LineItems/LineItem</span>') po,
         XMLTable('<span class="bold">/LineItem</span>' PASSING <span class="bold">po.lineitem</span>
                  COLUMNS
                    itemno      NUMBER(38)    PATH '@ItemNumber',
                    description VARCHAR2(256) PATH 'Description',
                    partno      VARCHAR2(14)  PATH 'Part/@Id',
                    quantity    NUMBER(12, 2) PATH 'Part/@Quantity',
                    unitprice   NUMBER(8, 4)  PATH 'Part/@UnitPrice') li;
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL — in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4239"></a><a id="ADXDB4240"></a><a id="ADXDB4238"></a><div class="props_rev_3"><a id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6" name="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6"></a><h4 id="ADXDB-GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6" class="sect4"><span class="enumeration_section">4.3.3 </span>XMLEXISTS SQL/XML Function in Oracle XML&nbsp;DB
                  </h4>
                  <div>
                     <p>SQL/XML standard function <code class="codeph">XMLExists</code> checks whether a given XQuery expression returns a non-empty XQuery sequence. If so, the function returns <code class="codeph">TRUE</code>. Otherwise, it returns <code class="codeph">FALSE</code>. 
                     </p>
                     <div class="section">
                        <p><a href="xquery-and-XML-DB.html#GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__CFHIBEGB">Figure 4-3</a> describes the syntax for function <code class="codeph">XMLExists</code>. 
                        </p>
                        <div class="figure" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__CFHIBEGB">
                           <p class="titleinfigure">Figure 4-3 XMLExists Syntax</p><img src="img/xmlexists.gif" width="475" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows" longdesc="img_text/xmlexists.html"><br><a href="img_text/xmlexists.html">Description of "Figure 4-3 XMLExists Syntax"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-EB8CA0CA-4546-48C8-8E00-323EC13AC98D"><span class="italic">XML_passing_clause ::=</span></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-8C4E0A2C-FA1A-4D29-BFD8-62AA1CBCE53C"><img src="img/xml_passing_clause.gif" width="373" alt="Description of xml_passing_clause.eps follows" title="Description of xml_passing_clause.eps follows" longdesc="img_text/xml_passing_clause.html"><br><a href="img_text/xml_passing_clause.html">Description of the illustration xml_passing_clause.eps</a></div>
                        <!-- class="figure" -->
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">XQuery_string</code></span> is a complete XQuery expression, possibly including a prolog, as a literal string. It can contain XQuery variables that you bind using the XQuery <code class="codeph">PASSING</code> clause (<span class="italic"><code class="codeph">XML_passing_clause</code></span> in the syntax diagram). The predefined namespace prefixes recognized for SQL/XML function <code class="codeph">XMLQuery</code> are also recognized in <span class="italic"><code class="codeph">XQuery_string</code></span> — see <a href="xquery-and-XML-DB.html#GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702" title="Several namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB.">Predefined XQuery Namespaces and Prefixes</a>.
                              </p>
                           </li>
                           <li>
                              <p>The <span class="italic"><code class="codeph">XML_passing_clause</code></span> is the keyword <code class="codeph">PASSING</code> followed by one or more SQL expressions (<span class="italic"><code class="codeph">expr</code></span>) that each return an <code class="codeph">XMLType</code> instance or an instance of a SQL scalar data type. All but possibly one of the expressions must each be followed by the keyword <code class="codeph">AS</code> and an XQuery <span class="italic"><code class="codeph">identifier</code></span>. The result of evaluating each <span class="italic"><code class="codeph">expr</code></span> is bound to the corresponding <span class="italic"><code class="codeph">identifier</code></span> for the evaluation of <span class="italic"><code class="codeph">XQuery_string</code></span>. If there is an <span class="italic"><code class="codeph">expr</code></span> that is not followed by an <code class="codeph">AS</code> clause, then the result of evaluating that <span class="italic"><code class="codeph">expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code class="codeph">XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code class="codeph">BY VALUE</code>, not passing <code class="codeph">BY REFERENCE</code>, so the clause <code class="codeph">BY VALUE</code> is implicit and can be omitted.
                              </p>
                           </li>
                        </ul>
                        <p>If an XQuery expression such as <code class="codeph">/PurchaseOrder/Reference</code> or <code class="codeph">/PurchaseOrder/Reference/text()</code> targets a single node, then <code class="codeph">XMLExists</code> returns <code class="codeph">true</code> for that expression. If <code class="codeph">XMLExists</code> is called with an XQuery expression that locates no nodes, then <code class="codeph">XMLExists</code> returns <code class="codeph">false</code>.
                        </p>
                        <p>Function <code class="codeph">XMLExists</code> can be used in queries, and it can be used to create function-based indexes to speed up evaluation of queries.
                        </p>
                        <div class="infoboxnote" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-0CE1B7FB-A216-4280-A7D2-CDE65A76F854">
                           <p class="notep1">Note:</p>
                           <p>Oracle XML&nbsp;DB limits the use of <code class="codeph">XMLExists</code> to a SQL <code class="codeph">WHERE</code> clause or <code class="codeph">CASE</code> expression. If you need to use <code class="codeph">XMLExists</code> in a <code class="codeph">SELECT</code> list, then wrap it in a <code class="codeph">CASE</code> expression:
                           </p><pre class="oac_no_warn" dir="ltr">CASE WHEN XMLExists(...) THEN 'TRUE' ELSE 'FALSE' END</pre></div>
                        <div class="infoboxnote" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-13AC1800-DF31-4342-9A28-9D11C62444D6">
                           <p class="notep1">Note:</p>
                           <p>Prior to Oracle Database&nbsp;11g Release 2, some users employed Oracle SQL function <code class="codeph">existsNode</code> to do some of what can be done better using SQL/XML function <code class="codeph">XMLExists</code>. Function <code class="codeph">existsNode</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11g Release 2. The two functions differ in these important ways:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Function <code class="codeph">existsNode</code> returns <code class="codeph">0</code> or <code class="codeph">1</code>. Function <code class="codeph">XMLExists</code> returns a Boolean value, <code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>You can use <code class="codeph">existsNode</code> in a query <code class="codeph">SELECT</code> list. You cannot use <code class="codeph">XMLExists</code> directly in a <code class="codeph">SELECT</code> list, but you can use <code class="codeph">XMLExists</code> within a <code class="codeph">CASE</code> expression in a <code class="codeph">SELECT</code> list.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4241"></a><div class="props_rev_3"><a id="GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09" name="GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09"></a><h4 id="ADXDB-GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09" class="sect4"><span class="enumeration_section">4.3.4 </span>Using XMLExists to Find a Node
                  </h4>
                  <div>
                     <p>You can use SQL/XML standard function <code class="codeph">XMLExists</code> to find a given node. You can create function-based indexes using <code class="codeph">XMLExists</code>. You can also create an <code class="codeph">XMLIndex</code> index to help speed up arbitrary XQuery searching.
                     </p>
                     <div class="section">
                        <p><a href="xquery-and-XML-DB.html#GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09__CHDIJGAB">Example 4-2</a> uses <code class="codeph">XMLExists</code> to select rows with <code class="codeph">SpecialInstructions</code> set to <code class="codeph">Expedite</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09__CHDIJGAB">
                        <p class="titleinexample">Example 4-2 Finding a Node Using SQL/XML Function XMLExists</p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE
  FROM purchaseorder
  WHERE XMLExists('/PurchaseOrder[SpecialInstructions="Expedite"]'
                  PASSING OBJECT_VALUE);
 
OBJECT_VALUE
--------------------------------------------------------------------
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 
13 rows selected.
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4250"></a><a id="ADXDB4249"></a><div class="props_rev_3"><a id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB" name="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB"></a><h4 id="ADXDB-GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB" class="sect4"><span class="enumeration_section">4.3.5 </span>XMLCAST SQL/XML Function in Oracle XML&nbsp;DB
                  </h4>
                  <div>
                     <p>You can use SQL/XML function <code class="codeph">XMLCast</code> to cast an XQuery value to a SQL data type.
                     </p>
                     <div class="section">
                        <p><a href="xquery-and-XML-DB.html#GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__CFHFDHHJ">Figure 4-4</a> describes the syntax for SQL/XML standard function <code class="codeph">XMLCast</code>.
                        </p>
                        <div class="figure" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__CFHFDHHJ">
                           <p class="titleinfigure">Figure 4-4 XMLCast Syntax</p><img src="img/xmlcast.gif" width="475" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows" longdesc="img_text/xmlcast.html"><br><a href="img_text/xmlcast.html">Description of "Figure 4-4 XMLCast Syntax"</a></div>
                        <!-- class="figure" -->
                        <p>SQL/XML standard function <code class="codeph">XMLCast</code> casts its first argument to the scalar SQL data type specified by its second argument. The first argument is a SQL expression that is evaluated. Any of the following SQL data types can be used as the second argument:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">NUMBER</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">VARCHAR2</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">REF XMLTYPE</code></p>
                           </li>
                           <li>
                              <p>any SQL date or time data type</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__GUID-865D0C07-DE7D-4FB2-A5F1-4A1471F7A912">
                           <p class="notep1">Note:</p>
                           <p>Unlike the SQL/XML standard, Oracle XML&nbsp;DB limits the use of <code class="codeph">XMLCast</code> to cast XML to a SQL scalar data type. Oracle XML&nbsp;DB does not support casting XML to XML or from a scalar SQL type to XML.
                           </p>
                        </div>
                        <p>The result of evaluating the first <code class="codeph">XMLCast</code> argument is an XML value. It is converted to the target SQL data type by using the XQuery atomization process and then casting the XQuery atomic values to the target data type. If this conversion fails, then an error is raised. If conversion succeeds, the result returned is an instance of the target data type.
                        </p>
                        <div class="infoboxnote" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__GUID-6C201840-E65C-4C21-9AF4-AE2CDE8E6511">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Prior to Oracle Database&nbsp;11g Release 2, some users employed Oracle SQL function <code class="codeph">extractValue</code> to do some of what can be done better using SQL/XML functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code>. Function <code class="codeph">extractValue</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11g Release 2.
                                 </p>
                              </li>
                              <li>
                                 <p>Function <code class="codeph">extractValue</code> raises an error when its XPath expression argument matches multiple text nodes. <code class="codeph">XMLCast</code> applied to an <code class="codeph">XMLQuery</code> result returns the concatenation of the text nodes — it does <span class="italic">not</span> raise an error.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4251"></a><div class="props_rev_3"><a id="GUID-A96B4300-2478-43AF-855F-7E104CCE925A" name="GUID-A96B4300-2478-43AF-855F-7E104CCE925A"></a><h4 id="ADXDB-GUID-A96B4300-2478-43AF-855F-7E104CCE925A" class="sect4"><span class="enumeration_section">4.3.6 </span>Using XMLCAST to Extract the Scalar Value of an XML Fragment
                  </h4>
                  <div>
                     <p>You can use standard SQL/XML function <code class="codeph">XMLCast</code> to extract the scalar value of an XML fragment.
                     </p>
                     <div class="section">
                        <p>The query in <a href="xquery-and-XML-DB.html#GUID-A96B4300-2478-43AF-855F-7E104CCE925A__CHDGFGBA">Example 4-3</a> extracts the scalar value of node <code class="codeph">Reference</code>. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A96B4300-2478-43AF-855F-7E104CCE925A__CHDGFGBA">
                        <p class="titleinexample">Example 4-3 Extracting the Scalar Value of an XML Fragment Using XMLCAST</p><pre class="pre codeblock"><code>SELECT XMLCast(XMLQuery('/PurchaseOrder/Reference' PASSING OBJECT_VALUE
                                                   RETURNING CONTENT)
               AS VARCHAR2(100)) "REFERENCE"
  FROM purchaseorder
  WHERE XMLExists('/PurchaseOrder[SpecialInstructions="Expedite"]'
                  PASSING OBJECT_VALUE);
 
REFERENCE
----------------------------
AMCEWEN-20021009123336271PDT
SKING-20021009123336321PDT
AWALSH-20021009123337303PDT
JCHEN-20021009123337123PDT
AWALSH-20021009123336642PDT
SKING-20021009123336622PDT
SKING-20021009123336822PDT
AWALSH-20021009123336101PDT
WSMITH-20021009123336412PDT
AWALSH-20021009123337954PDT
SKING-20021009123338294PDT
WSMITH-20021009123338154PDT
TFOX-20021009123337463PDT
 
13 rows selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5995"></a><a id="ADXDB5994"></a><div class="props_rev_3"><a id="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" name="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B"></a><h3 id="ADXDB-GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" class="sect3"><span class="enumeration_section">4.4 </span>URI Scheme oradb: Querying Table or View Data with XQuery
               </h3>
               <div>
                  <p>You can use XQuery function <code class="codeph">fn:collection</code> to query data that is in database tables and views.
                  </p>
                  <div class="section">
                     <p>Besides using XQuery functions <code class="codeph">fn:doc</code> and <code class="codeph">fn:collection</code> to query resources in Oracle XML&nbsp;DB Repository (see <a href="query-and-update-XML.html#GUID-767E262F-559F-4EBE-84C1-65683879E1D5" title="Examples are presented that use XQuery with XML data in Oracle XML&nbsp;DB Repository. You use XQuery functions fn:doc and fn:collection to query file and folder resources in the repository, respectively.">Querying XML Data in Oracle XML&nbsp;DB Repository Using XQuery</a>), you can use <code class="codeph">fn:collection</code> to query data in database tables and views.
                     </p>
                     <p>To do this, you pass function <code class="codeph">fn:collection</code> a URI argument that specifies the table or view to query. The Oracle URI scheme <code class="codeph">oradb</code> identifies this usage: without it, the argument is treated as a repository location.
                     </p>
                     <p>The table or view that is queried can be relational or of type <code class="codeph">XMLType</code>. If relational, its data is converted on the fly and treated as XML. The result returned by <code class="codeph">fn:collection</code> is always an XQuery sequence.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For an <code class="codeph">XMLType</code> table, the root element of each XML document returned by <code class="codeph">fn:collection</code> is the same as the root element of an XML document in the table.
                           </p>
                        </li>
                        <li>
                           <p>For a relational table, the root element of each XML document returned by <code class="codeph">fn:collection</code> is <code class="codeph">ROW</code>. The children of the <code class="codeph">ROW</code> element are elements with the same names (uppercase) as columns of the table. The content of a child element corresponds to the column data. That content is an XML element if the column is of type <code class="codeph">XMLType</code>; otherwise (the column is a scalar type), the content is of type <code class="codeph">xs:string</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The format of the URI argument passed to <code class="codeph">fn:collection</code> is as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For an <code class="codeph">XMLType</code> or relational table or view, <span class="italic"><code class="codeph">TABLE</code></span>, in database schema <span class="italic"><code class="codeph">DB-SCHEMA</code></span>:
                           </p><pre class="oac_no_warn" dir="ltr"><span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">TABLE</span>/
</pre><p>You can use <span class="bold"><code class="codeph">PUBLIC</code></span> for <span class="italic"><code class="codeph">DB-SCHEMA</code></span> if <span class="italic"><code class="codeph">TABLE</code></span> is a public synonym or <span class="italic"><code class="codeph">TABLE</code></span> is a table or view that is accessible to the database user currently logged in.
                           </p>
                        </li>
                        <li>
                           <p>For an <code class="codeph">XMLType</code> column in a <span class="italic">relational</span> table or view:
                           </p><pre class="oac_no_warn" dir="ltr"><span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">REL-TABLE</span>/<span class="bold">ROW</span><span class="italic">PRED</span>/<span class="italic">X-COL</span>
</pre><p><span class="italic"><code class="codeph">REL-TABLE</code></span> is a relational table or view; <span class="italic"><code class="codeph">PRED</code></span> is an XPath predicate that does not involve any <code class="codeph">XMLType</code> columns; and <span class="italic"><code class="codeph">X-COL</code></span> is an <code class="codeph">XMLType</code> column in <span class="italic"><code class="codeph">REL-TABLE</code></span>. <span class="italic"><code class="codeph">PRED</code></span> is optional; <span class="italic"><code class="codeph">DB-SCHEMA</code></span>, <span class="italic"><code class="codeph">REL-TABLE</code></span>, and <span class="italic"><code class="codeph">X-COL</code></span> are required. 
                           </p>
                        </li>
                     </ul>
                     <p>Optional XPath predicate <span class="italic"><code class="codeph">PRED</code></span> must satisfy the following conditions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It does not involve any <code class="codeph">XMLType</code> columns.
                           </p>
                        </li>
                        <li>
                           <p>It involves only conjunctions (<code class="codeph">and</code>) and disjunctions (<code class="codeph">or</code>) of general equality and inequality comparisons (<code class="codeph">=</code>, <code class="codeph">!=</code>, <code class="codeph">&gt;</code>, <code class="codeph">&lt;</code>, <code class="codeph">&gt;=</code>, and <code class="codeph">&lt;=</code>).
                           </p>
                        </li>
                        <li>
                           <p>For each comparison operation: Either both sides name (non-XML) columns in <span class="italic"><code class="codeph">REL-TABLE</code></span> or one side names such a column and the other is a value of the proper type, as specified in <a href="xquery-and-XML-DB.html#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B__BABCEJCJ" title="This table shows the column types allowed in comparison expressions of oradb predicates.">Table 4-3</a>. Use of any other type raises an error.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B__BABCEJCJ">
                     <p class="titleintable">Table 4-3 oradb Expressions: Column Types for Comparisons</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="oradb Expressions: Column Types for Comparisons" summary="This table shows the column types allowed in comparison expressions of oradb predicates." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="56%" id="d20054e4151">Relational Column Type</th>
                              <th align="left" valign="bottom" width="44%" id="d20054e4154">XQuery Value Type</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4159" headers="d20054e4151 ">
                                 <p><code class="codeph">VARCHAR2</code>, <code class="codeph">CHAR</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4159 d20054e4154 ">
                                 <p><code class="codeph">xs:string</code> or string literal
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4172" headers="d20054e4151 ">
                                 <p><code class="codeph">NUMBER</code>, <code class="codeph">FLOAT</code>, <code class="codeph">BINARY_FLOAT</code>, <code class="codeph">BINARY_DOUBLE</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4172 d20054e4154 ">
                                 <p><code class="codeph">xs:decimal</code>, <code class="codeph">xs:float</code>, <code class="codeph">xs:double</code>, or numeric literal
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4197" headers="d20054e4151 ">
                                 <p><code class="codeph">DATE</code>, <code class="codeph">TIMESTAMP</code>, <code class="codeph">TIMESTAMP WITH TIMEZONE</code>, <code class="codeph">TIMESTAMP WITH LOCAL TIMEZONE</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4197 d20054e4154 ">
                                 <p><code class="codeph">xs:date</code>, <code class="codeph">xs:time</code>, or <code class="codeph">xs:dateTime</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4221" headers="d20054e4151 ">
                                 <p><code class="codeph">INTERVAL YEAR TO MONTH</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4221 d20054e4154 ">
                                 <p><code class="codeph">xs:yearMonthDuration</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4230" headers="d20054e4151 ">
                                 <p><code class="codeph">INTERVAL DAY TO SECOND</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4230 d20054e4154 ">
                                 <p><code class="codeph">xs:dayTimeDuration</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4239" headers="d20054e4151 ">
                                 <p><code class="codeph">RAW</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4239 d20054e4154 ">
                                 <p><code class="codeph">xs:hexBinary</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="56%" id="d20054e4248" headers="d20054e4151 ">
                                 <p><code class="codeph">ROWID</code></p>
                              </td>
                              <td align="left" valign="top" width="44%" headers="d20054e4248 d20054e4154 ">
                                 <p><code class="codeph">xs:string</code> or string literal
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>For example, this XQuery expression represents all XML documents in <code class="codeph">XMLType</code> column <code class="codeph">warehouse_spec</code> of table <code class="codeph">oe.warehouses</code>, for the rows where column <code class="codeph">warehouse_id</code> has a value less than 6:
                     </p><pre class="pre codeblock"><code>fn:collection('oradb:/OE/WAREHOUSES/ROW[WAREHOUSE_ID &lt; 6]/WAREHOUSE_SPEC')</code></pre></div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0" title="Examples are presented that use XQuery to query relational table or view data as if it were XML data. The examples use XQuery function fn:collection, passing as argument a URI that uses the URI-scheme name oradb together with the database location of the data.">Querying Relational Data Using XQuery and URI Scheme oradb</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5106"></a><div class="props_rev_3"><a id="GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" name="GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513"></a><h3 id="ADXDB-GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" class="sect3"><span class="enumeration_section">4.5 </span>Oracle XQuery Extension Functions 
               </h3>
               <div>
                  <p>Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, <code class="codeph">http://xmlns.oracle.com/xdb</code>, which uses the predefined prefix <span class="bold"><code class="codeph">ora</code></span>. 
                  </p>
                  <div class="infoboxnote" id="GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513__GUID-5AC0B0E7-1356-4EBF-854F-111529A1E06D">
                     <p class="notep1">Note:</p>
                     <p>Oracle XQuery function <code class="codeph">ora:contains</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;12c Release 2 (12.2.0.1). Use XQuery Full Text instead.
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1">ora:contains XQuery Function (Deprecated)</a><br>Oracle XQuery and XPath function <code class="codeph">ora:contains</code> is described. This function is <span class="italic">deprecated</span> in Oracle Database&nbsp;12c Release 2 (12.2.0.1). Use XQuery Full Text instead.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB">ora:sqrt XQuery Function</a><br>Oracle XQuery function <code class="codeph">ora:sqrt</code> returns the square root of its numeric argument, which can be of XQuery type <code class="codeph">xs:decimal</code>,<code class="codeph"> xs:float</code>, or <code class="codeph">xs:double</code>. The returned value is of the same XQuery type as the argument.
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797">ora:tokenize XQuery Function</a><br>Oracle XQuery function <code class="codeph">ora:tokenize</code> lets you use a regular expression to split the input string <span class="italic"><code class="codeph">target_string</code></span> into a sequence of strings.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5110"></a><a id="ADXDB5109"></a><div class="props_rev_3"><a id="GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1" name="GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1"></a><h4 id="ADXDB-GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1" class="sect4"><span class="enumeration_section">4.5.1 </span>ora:contains XQuery Function (Deprecated)
                  </h4>
                  <div>
                     <p>Oracle XQuery and XPath function <code class="codeph">ora:contains</code> is described. This function is <span class="italic">deprecated</span> in Oracle Database&nbsp;12c Release 2 (12.2.0.1). Use XQuery Full Text instead.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1__GUID-5EB1ADAC-44DE-42C1-8630-C507470F6717">ora:contains Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="pre codeblock"><code>ora:contains (<span class="italic">input_text</span>, <span class="italic">text_query</span> [, <span class="italic">policy_name</span>] [, <span class="italic">policy_owner</span>])
</code></pre><p>Deprecated Oracle XQuery and XPath function <code class="codeph">ora:contains</code> can be used in an XQuery expression in a call to SQL/XML function <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, or <code class="codeph">XMLExists</code>. It is used to restrict a structural search with a full-text predicate. Function <code class="codeph">ora:contains</code> returns a positive integer when the <span class="italic"><code class="codeph">input_text</code></span> matches <span class="italic"><code class="codeph">text_query</code></span> (the higher the number, the more relevant the match), and zero otherwise. When used in an XQuery expression (that is not also an XPath expression), the XQuery return type is <code class="codeph">xs:integer()</code>; when used in an XPath expression outside of an XQuery expression, the XPath return type is <code class="codeph">number</code>.
                        </p>
                        <p>Argument <span class="italic"><code class="codeph">input_text</code></span> must evaluate to a single text node or an attribute. The syntax and semantics of <span class="italic"><code class="codeph">text_query</code></span> in <code class="codeph">ora:contains</code> are the same as <span class="italic"><code class="codeph">text_query</code></span> in <code class="codeph">contains</code>, with a few restrictions.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5116"></a><a id="ADXDB5115"></a><div class="props_rev_3"><a id="GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB" name="GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB"></a><h4 id="ADXDB-GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB" class="sect4"><span class="enumeration_section">4.5.2 </span>ora:sqrt XQuery Function
                  </h4>
                  <div>
                     <p>Oracle XQuery function <code class="codeph">ora:sqrt</code> returns the square root of its numeric argument, which can be of XQuery type <code class="codeph">xs:decimal</code>,<code class="codeph"> xs:float</code>, or <code class="codeph">xs:double</code>. The returned value is of the same XQuery type as the argument.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB__GUID-26D14541-6000-4404-BDE4-453F3484F9E1">ora:sqrt Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="pre codeblock"><code>ora:sqrt (<span class="italic">number</span>)
</code></pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5118"></a><a id="ADXDB5117"></a><div class="props_rev_3"><a id="GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797" name="GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797"></a><h4 id="ADXDB-GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797" class="sect4"><span class="enumeration_section">4.5.3 </span>ora:tokenize XQuery Function
                  </h4>
                  <div>
                     <p>Oracle XQuery function <code class="codeph">ora:tokenize</code> lets you use a regular expression to split the input string <span class="italic"><code class="codeph">target_string</code></span> into a sequence of strings.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797__GUID-A98C4610-B449-4FB5-83F9-FF7C072D7BB3">ora:tokenize Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="pre codeblock"><code>ora:tokenize (<span class="italic">target_string</span>, <span class="italic">match_pattern</span> [, <span class="italic">match_parameter</span>])
</code></pre><p></p>
                        <p>Function <code class="codeph">ora:tokenize</code>  treats each substring that matches the regular-expression <span class="italic"><code class="codeph">match_pattern</code></span> as a separator indicating where to split. It returns the sequence of tokens as an XQuery value of type <code class="codeph">xs:string*</code> (a sequence of <code class="codeph">xs:string</code> values). If <span class="italic"><code class="codeph">target_string</code></span> is the empty sequence, it is returned. Optional argument <span class="italic"><code class="codeph">match_parameter</code></span> is a code that qualifies matching: case-sensitivity and so on.
                        </p>
                        <p>The argument types are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">target_string</code></span> &#x2013; <code class="codeph">xs:string?</code><a id="fn_3" name="fn_3" href="#fn_3" onclick="footdisplay(3, "The question mark (?) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See XQuery Expressions.")"><sup>Foot&nbsp;3</sup></a></p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">match_pattern</code></span> &#x2013; <code class="codeph">xs:string</code></p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">match_parameter</code></span> &#x2013; <code class="codeph">xs:string</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5996"></a><div class="props_rev_3"><a id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" name="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948"></a><h3 id="ADXDB-GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" class="sect3"><span class="enumeration_section">4.6 </span>Oracle XQuery Extension-Expression Pragmas
               </h3>
               <div>
                  <p>The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces (<code class="codeph">{</code>,&nbsp;<code class="codeph">}</code>) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.
                  </p>
                  <div class="section">
                     <p>No other pragmas are recognized than those listed here. Use of any other pragma, or use of any of these pragmas with incorrect pragma content (for example, <code class="codeph">(#ora:view_on_null something_else #)</code>), raises an error.
                     </p>
                     <p>In the <code class="codeph">ora:view_on_null</code> examples here, assume that table <code class="codeph">null_test</code> has columns <code class="codeph">a</code> and <code class="codeph">b</code> of type <code class="codeph">VARCHAR2(10)</code>, and that column <code class="codeph">b</code> (but not <code class="codeph">a</code>) is empty.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">(#ora:child-element-name</code> <span class="italic"><code class="codeph">name</code></span> <code class="codeph">#)</code> &#x2013; Specify the name to use for a child element that is inserted. In general, without this pragma the name of the element to be inserted is unknown at compile time. Specifying the name allows for compile-time optimization, to improve runtime performance.
                           </p>
                           <p>As an example, the following SQL statement specifies <code class="codeph">LineItem</code> as the name of the element node that is inserted as a child of element <code class="codeph">LineItems</code>. The element data to be inserted is the value of XQuery variable <code class="codeph">p2</code>, which comes from bind variable <code class="codeph">:1</code>.
                           </p><pre class="pre codeblock"><code>UPDATE oe.purchaseorder p SET p.OBJECT_VALUE =
  XMLQuery(
    'copy $i :=
       $p1 modify (for $j in $i/PurchaseOrder/LineItems
                     return <span class="bold">(#ora:child-element-name LineItem #)</span>
                            {insert node $p2 into $j)
                  return $i'
    PASSING p.OBJECT_VALUE AS "p1", :1 AS "p2" RETURNING CONTENT)
  WHERE XMLQuery(
          '/PurchaseOrder/Reference/text()'
          PASSING p.OBJECT_VALUE RETURNING CONTENT).getStringVal() =
            'EMPTY_LINES';
</code></pre><p>This pragma applies to <code class="codeph">XMLType</code> data stored either object-relationally or as binary XML.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:defaultTable #)</code> &#x2013; Specify the default table used to store repository data. Use this to improve the performance of repository queries that use Query function <code class="codeph">fn:doc</code> or <code class="codeph">fn:collection</code>. See <a href="query-and-update-XML.html#GUID-749BD49D-46E2-4B15-8B9E-1097D6952047" title="You can use Oracle XQuery extension-expression pragma ora:defaultTable to improve the performance of querying repository data.">Using Oracle XQuery Pragma ora:defaultTable</a>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:invalid_path empty #)</code> &#x2013; Treat an invalid XPath expression as if its targeted nodes do not exist. For example:
                           </p><pre class="pre codeblock"><code>SELECT XMLQuery('<span class="bold">(#ora:invalid_path empty #)</span>
                 {exists($p/PurchaseOrder//NotInTheSchema)}'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM oe.purchaseorder p;
</code></pre><p>The XML schema for table <code class="codeph">oe.purchaseorder</code> does not allow any such node <code class="codeph">NotInTheSchema</code> as a descendant of node <code class="codeph">PurchaseOrder</code>. Without the pragma, the use of this invalid XPath expression would raise an error. But with the pragma, the calling context acts just as if the XPath expression had targeted no nodes. That calling context in this example is XQuery function <code class="codeph">exists</code>, which returns XQuery Boolean value <code class="codeph">false</code> when passed an empty node sequence. (XQuery function <code class="codeph">exists</code> is used in this example only to illustrate the behavior; the pragma is not especially related to function <code class="codeph">exists</code>.)
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:view_on_null empty #)</code> &#x2013; XQuery function <code class="codeph">fn:collection</code> returns an empty XML element for each <code class="codeph">NULL</code> column. For example, the following query returns <code class="codeph">&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;</code><span class="bold"><code class="codeph">&lt;B&gt;&lt;/B&gt;</code></span><code class="codeph">&lt;/ROW&gt;</code>:
                           </p><pre class="pre codeblock"><code>SELECT XMLQuery('<span class="bold">(#ora:view_on_null empty #)</span>
                 {for $i in fn:collection("oradb:/PUBLIC/NULL_TEST")/ROW 
                  return $i}'
                RETURNING CONTENT)
  FROM DUAL;
</code></pre></li>
                        <li>
                           <p><code class="codeph">(#ora:view_on_null null #)</code> &#x2013; XQuery function <code class="codeph">fn:collection</code> returns no element for a <code class="codeph">NULL</code> column. For example, the following query returns <code class="codeph">&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;&lt;/ROW&gt;</code>:
                           </p><pre class="pre codeblock"><code>SELECT XMLQuery('<span class="bold">(#ora:view_on_null null #)</span>
                 {for $i in fn:collection("oradb:/PUBLIC/NULL_TEST")/ROW 
                  return $i}'
                RETURNING CONTENT)
  FROM DUAL;
</code></pre></li>
                        <li>
                           <p><code class="codeph">(#ora:no_xmlquery_rewrite #)</code><a id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__BABBJEDA" name="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__BABBJEDA" href="#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__BABBJEDA" onclick="footdisplay(4, "Prior to Oracle Database 12c Release 1 (12.1.0.1), pragmas ora:no_xmlquery_rewrite and ora:xmlquery_rewrite were named ora:xq_proc and ora:xq_qry, respectively. They were renamed for readability, with no change in meaning.")"><sup>Foot&nbsp;4</sup></a> &#x2013; Do not optimize XQuery procedure calls in the XQuery expression that follows the pragma; use functional evaluation instead. 
                           </p>
                           <p>This has the same effect as the SQL hint <code class="codeph">/*+ NO_XML_QUERY_REWRITE */</code>, but the scope of the pragma is only the XQuery expression that follows it (not an entire SQL statement).
                           </p>
                           <div class="infoboxnotealso" id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__GUID-6BD8322E-AFDD-4325-B85F-6BEEBBD5837A">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */.">Turning Off Use of XMLIndex</a> for information about optimizer hint <code class="codeph">NO_XML_QUERY_REWRITE</code></p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:xmlquery_rewrite #)</code><a id="fnsrc_d20054e5052" name="fnsrc_d20054e5052" href="#fnsrc_d20054e5052" onclick="footdisplay(4, "Prior to Oracle Database 12c Release 1 (12.1.0.1), pragmas ora:no_xmlquery_rewrite and ora:xmlquery_rewrite were named ora:xq_proc and ora:xq_qry, respectively. They were renamed for readability, with no change in meaning.")"><sup>Footref&nbsp;4</sup></a> &#x2013; Try to optimize the XQuery expression that follows the pragma. That is, if possible, do not evaluate it functionally.
                           </p>
                           <p>As an example of using both <code class="codeph">ora:no_xmlquery_rewrite</code> and <code class="codeph">ora:xmlquery_rewrite</code>, in the following query the XQuery expression argument to <code class="codeph">XMLQuery</code> will in general be evaluated functionally, but the <code class="codeph">fn:collection</code> subexpressions that are preceded by pragma <code class="codeph">ora:xmlquery_rewrite</code> will be optimized, if possible.
                           </p><pre class="pre codeblock"><code>SELECT XMLQuery('<span class="bold">(#ora:no_xmlquery_rewrite#)</span> (: Do not optimize expression :)
                 {for $i in <span class="bold">(#ora:xmlquery_rewrite#)</span> (: Optimize subexp. :)
                            {fn:collection("oradb:/HR/REGIONS")},
                      $j in <span class="bold">(#ora:xmlquery_rewrite#)</span> (: Optimize subexpr. :)
                            {fn:collection("oradb:/HR/COUNTRIES")}
                  where $i/ROW/REGION_ID = $j/ROW/REGION_ID
                    and $i/ROW/REGION_NAME = $regionname
                  return $j}'
         PASSING CAST('&amp;REGION' AS VARCHAR2(40)) AS "regionname"
           RETURNING CONTENT)
  AS asian_countries FROM DUAL;
</code></pre></li>
                        <li>
                           <p><code class="codeph">(#ora:no_schema #)</code> &#x2013; Do not raise an error if an XQuery Full Text expression is used with XML Schema-based <code class="codeph">XMLType</code> data. Instead, implicitly cast the data to non XML-Schema-based data. In particular, this means ignore XML Schema data types. 
                           </p>
                           <p>Oracle supports XQuery Full Text only for <code class="codeph">XMLType</code> data stored as binary XML, so this pragma applies only for the same case.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:use_xmltext_idx #)</code> &#x2013; Use an XML search index, if available, to evaluate the query. Do not use an <code class="codeph">XMLIndex</code> index or streaming evaluation. 
                           </p>
                           <p>An XML search index applies only to <code class="codeph">XMLType</code> data stored as binary XML, so this pragma does also.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(#ora:transform_keep_schema #)</code> &#x2013; Retain XML Schema information for the documents returned by the XQuery expression that follows the pragma. This is useful for XQuery Update, which uses copy semantics. 
                           </p>
                           <p>Without the pragma, when XML schema-based data is copied during an XQuery Update operation, the XML schema information is lost. This is the behavior specified by the XQuery Update standard. If you then try to insert the updated data  into an XML schema-based column or table then an error is raised: the data to be inserted is untyped, so it does not conform to the XML schema.</p>
                           <p>If you use the pragma then the data retains its XML schema information, preventing the insertion error. Here is an example of using the pragma:</p><pre class="pre codeblock"><code>SELECT XMLQuery('declare default element namespace
                 "http://xmlns.oracle.com/xdb/xdbconfig.xsd"; (: :)
                 <span class="bold">(#ora:transform_keep_schema#)</span>
                 {copy $NEWXML :=
                   $XML modify (for $CFG in $NEWXML/xdbconfig//httpconfig 
                                  return (replace value of node
                                          $CFG/http-port with xs:int($PORTNO)))
                               return $NEWXML}'
                PASSING CFG AS "XML", 81 as "PORTNO" RETURNING CONTENT)
  FROM DUAL;</code></pre></li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5151"></a><a id="ADXDB5152"></a><a id="ADXDB5150"></a><div class="props_rev_3"><a id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" name="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B"></a><h3 id="ADXDB-GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" class="sect3"><span class="enumeration_section">4.7 </span>XQuery Static Type-Checking in Oracle XML&nbsp;DB
               </h3>
               <div>
                  <p>When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.</p>
                  <p>Oracle XML&nbsp;DB type-checks <span class="italic">all</span> XQuery expressions. Doing this at run time can be costly, however. As an optimization technique, whenever there is sufficient static type information available for a given query at compile time, Oracle XML&nbsp;DB performs <span class="italic">static</span> (compile time) type-checking of that query. Whenever sufficient static type information is not available for a given query at compile time, Oracle XML&nbsp;DB uses dynamic (run-time) type checking for that query.
                  </p>
                  <p>Static type-checking can save execution time by raising errors at compile time. Static type-checking errors include both data-type errors and the use of XPath expressions that are invalid with respect to an XML schema.</p>
                  <p>Typical ways of providing sufficient static type information at query compile time include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Using XQuery with <code class="codeph">fn:doc</code> or <code class="codeph">fn:collection</code> over relational data.
                        </p>
                     </li>
                     <li>
                        <p>Using XQuery to query an <code class="codeph">XMLType</code> table, column, or view whose XML Schema information is available at query compile time.
                        </p>
                     </li>
                     <li>
                        <p>Using XQuery Update with a transform expression whose input is from an <code class="codeph">XMLType</code> table or column that is based on an XML schema.
                        </p>
                     </li>
                  </ul>
                  <p>This section presents examples that demonstrate the utility of static type-checking and the use of these two means of communicating type information.</p>
                  <p>The XML data produced on the fly by <code class="codeph">fn:collection</code> together with URI scheme <code class="codeph">oradb</code> has <code class="codeph">ROW</code> as its top-level element, but the query of <a href="xquery-and-XML-DB.html#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABFDFHI">Example 4-4</a> incorrectly lacks that <code class="codeph">ROW</code> wrapper element. This omission raises a query compile-time error. Forgetting that <code class="codeph">fn:collection</code> with <code class="codeph">oradb</code> wraps relational data in this way is an easy mistake to make, and one that could be difficult to diagnose without static type-checking. <a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAFCFCF">Example 5-5</a> shows the correct code.
                  </p>
                  <p>In <a href="xquery-and-XML-DB.html#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABIDDDF">Example 4-5</a>, XQuery static type-checking finds a mismatch between an XPath expression and its target XML schema-based data. Element <code class="codeph">CostCenter</code> is misspelled here as <code class="codeph">costcenter</code> (XQuery and XPath are case-sensitive). <a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">Example 5-11</a> shows the correct code.
                  </p>
                  <div class="example" id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABFDFHI">
                     <p class="titleinexample">Example 4-4 Static Type-Checking of XQuery Expressions: oradb URI scheme</p><pre class="pre codeblock"><code>-- This produces a static-type-check error, because "ROW" is missing.
SELECT XMLQuery('for $i in fn:collection("oradb:/HR/REGIONS"),
                     $j in fn:collection("oradb:/HR/COUNTRIES")
                 where $i/REGION_ID = $j/REGION_ID and $i/REGION_NAME = "Asia"
                 return $j'
                RETURNING CONTENT) AS asian_countries
  FROM DUAL;
SELECT XMLQuery('for $i in fn:collection("oradb:/HR/REGIONS"),
*
ERROR at line 1:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(REGION_ID)
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABIDDDF">
                     <p class="titleinexample">Example 4-5 Static Type-Checking of XQuery Expressions: XML Schema-Based Data</p><pre class="pre codeblock"><code>-- This results in a static-type-check error: CostCenter is not the right case.
SELECT xtab.poref, xtab.usr, xtab.requestor
  FROM purchaseorder,
       XMLTable('for $i in /PurchaseOrder where $i/<span class="bold">costcenter</span> eq "A10" return $i'
                PASSING OBJECT_VALUE
                COLUMNS poref     VARCHAR2(20) PATH 'Reference',
                        usr       VARCHAR2(20) PATH 'User' DEFAULT 'Unknown',
                        requestor VARCHAR2(20) PATH 'Requestor') xtab;
  FROM purchaseorder,
       *
ERROR at line 2:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(costcenter)</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5159"></a><div class="props_rev_3"><a id="GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" name="GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99"></a><h3 id="ADXDB-GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" class="sect3"><span class="enumeration_section">4.8 </span>Oracle XML&nbsp;DB Support for XQuery
               </h3>
               <div>
                  <p>Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D">Support for XQuery and SQL</a><br>Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together. 
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-22940B8D-1468-4966-9F55-7DD4518E9612">Support for XQuery Functions and Operators</a><br>Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest <span class="italic">XQuery 1.0 and XPath 2.0 Functions and Operators</span> specification, with a few exceptions. 
                     </li>
                     <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048">Support for XQuery Full Text</a><br>Oracle XML&nbsp;DB supports XQuery Full Text for <code class="codeph">XMLType</code> data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5160"></a><div class="props_rev_3"><a id="GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" name="GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D"></a><h4 id="ADXDB-GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" class="sect4"><span class="enumeration_section">4.8.1 </span>Support for XQuery and SQL
                  </h4>
                  <div>
                     <p>Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together. </p>
                     <div class="section">
                        <p>The specific properties of the Oracle XML&nbsp;DB XQuery implementation are described in this section. The XQuery standard explicitly calls out certain aspects of the language processing as implementation-defined or implementation-dependent. There are also some features that are specified by the XQuery standard but are not supported by Oracle XML&nbsp;DB.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16">Implementation Choices Specified in the XQuery Standards</a><br>The XQuery standards specify several aspects of language processing that are to be defined by the implementation.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-7E668693-38C0-481A-B118-2E1A654D6E0D">XQuery Features Not Supported by Oracle XML&nbsp;DB</a><br>The features specified by the XQuery standard that are not supported by Oracle XML&nbsp;DB are specified.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E">XQuery Optional Features</a><br>The optional XQuery features that are not supported by Oracle XML&nbsp;DB are specified.
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB5161"></a><div class="props_rev_3"><a id="GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16" name="GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16"></a><h5 id="ADXDB-GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16" class="sect5"><span class="enumeration_section">4.8.1.1 </span>Implementation Choices Specified in the XQuery Standards
                     </h5>
                     <div>
                        <p>The XQuery standards specify several aspects of language processing that are to be defined by the implementation.</p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="italic">Implicit time zone support &#x2013; </span>In Oracle XML&nbsp;DB, the implicit time zone is always assumed to be <code class="codeph">Z</code>, and instances of <code class="codeph">xs:date</code>, <code class="codeph">xs:time</code>, and <code class="codeph">xs:datetime</code> that are missing time zones are&nbsp; automatically converted to UTC.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">copy-namespaces</code></span><span class="italic"> default value &#x2013;</span> The default value for a <code class="codeph">copy-namespaces</code> declaration (used in XQuery Update) is <code class="codeph">inherit</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic">Revalidation mode</span> &#x2013; The default mode for XQuery Update transform expression revalidation is <code class="codeph">skip</code>. However, if the result of a transform expression is an update to XML schema-based data in an <code class="codeph">XMLType</code> table or column, then XML schema validation is enforced.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" title="Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together.">Support for XQuery and SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5162"></a><div class="props_rev_3"><a id="GUID-7E668693-38C0-481A-B118-2E1A654D6E0D" name="GUID-7E668693-38C0-481A-B118-2E1A654D6E0D"></a><h5 id="ADXDB-GUID-7E668693-38C0-481A-B118-2E1A654D6E0D" class="sect5"><span class="enumeration_section">4.8.1.2 </span>XQuery Features Not Supported by Oracle XML&nbsp;DB
                     </h5>
                     <div>
                        <p>The features specified by the XQuery standard that are not supported by Oracle XML&nbsp;DB are specified.</p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="italic">Copy-namespace mode &#x2013;</span> Oracle XML&nbsp;DB supports only <code class="codeph">preserve</code> and <code class="codeph">inherit</code> for a <code class="codeph">copy-namespaces</code> declaration. If an existing element node is copied by an element constructor or a document constructor, all in-scope namespaces of the original element are retained in the copy. Otherwise, the copied node inherits all in-scope namespaces of the constructed node. An error is raised if you specify <code class="codeph">no-preserve</code> or <code class="codeph">no-inherit</code>. 
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic">Version encoding</span> &#x2013; Oracle XML&nbsp;DB does not support an optional encoding declaration in a version declaration. That is, you cannot include <code class="codeph">(encoding </code><span class="italic"><code class="codeph">an-encoding</code></span><code class="codeph">)</code> in a declaration <code class="codeph">xquery version </code><span class="italic"><code class="codeph">a-version</code></span><code class="codeph">;</code>. In particular, you cannot specify an encoding used in the query. An error is raised if you include an encoding declaration.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic">xml:id</span> &#x2013; Oracle XML&nbsp;DB does not support use of <code class="codeph">xml:id</code>. If you use <code class="codeph">xml:id</code>, then an error is raised.
                                 </p>
                              </li>
                              <li>
                                 <p>XQuery prolog default-collation declaration.</p>
                              </li>
                              <li>
                                 <p>XQuery prolog boundary-space declaration.</p>
                              </li>
                              <li>
                                 <p>XQuery data type <code class="codeph">xs:duration</code>. Use either <code class="codeph">xs:yearMonthDuration</code> or <code class="codeph">xs:DayTimeDuration</code> instead.
                                 </p>
                              </li>
                              <li>
                                 <p>XQuery Update function <code class="codeph">fn:put</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" title="Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together.">Support for XQuery and SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5163"></a><div class="props_rev_3"><a id="GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E" name="GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E"></a><h5 id="ADXDB-GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E" class="sect5"><span class="enumeration_section">4.8.1.3 </span>XQuery Optional Features
                     </h5>
                     <div>
                        <p>The optional XQuery features that are not supported by Oracle XML&nbsp;DB are specified.</p>
                        <div class="section">
                           <p>The XQuery standard specifies that some features are <span class="italic">optional</span> for a given implementation. The following optional XQuery features are <span class="italic">not</span> supported by Oracle XML&nbsp;DB:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Schema Validation Feature</p>
                              </li>
                              <li>
                                 <p>Module Feature</p>
                              </li>
                           </ul>
                           <p>The following optional XQuery features are supported by Oracle XML&nbsp;DB:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>XQuery Static Typing Feature</p>
                              </li>
                              <li>
                                 <p>XQuery Update Static Typing Feature</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="xquery-and-XML-DB.html#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" title="When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.">XQuery Static Type-Checking in Oracle XML&nbsp;DB</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" title="Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together.">Support for XQuery and SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB5164"></a><div class="props_rev_3"><a id="GUID-22940B8D-1468-4966-9F55-7DD4518E9612" name="GUID-22940B8D-1468-4966-9F55-7DD4518E9612"></a><h4 id="ADXDB-GUID-22940B8D-1468-4966-9F55-7DD4518E9612" class="sect4"><span class="enumeration_section">4.8.2 </span>Support for XQuery Functions and Operators
                  </h4>
                  <div>
                     <p>Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest <span class="italic">XQuery 1.0 and XPath 2.0 Functions and Operators</span> specification, with a few exceptions. 
                     </p>
                     <div class="section">
                        <p>Oracle XML&nbsp;DB does <span class="italic">not</span> support the following XQuery functions and operators:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Function <code class="codeph">fn:tokenize</code>. Use Oracle XQuery function <code class="codeph">ora:tokenize</code> instead.
                              </p>
                           </li>
                           <li>
                              <p>Functions <code class="codeph">fn:id</code> and <code class="codeph">fn:idref</code>.
                              </p>
                           </li>
                           <li>
                              <p>Function <code class="codeph">fn:collection</code> without arguments.
                              </p>
                           </li>
                           <li>
                              <p>Optional collation parameters for XQuery functions.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1">XQuery Functions fn:doc, fn:collection, and fn:doc-available</a><br>Oracle XML&nbsp;DB supports XQuery functions <code class="codeph">fn:doc</code>, <code class="codeph">fn:collection</code>, and <code class="codeph">fn:doc-available</code> for all resources in Oracle XML&nbsp;DB Repository. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB5165"></a><div class="props_rev_3"><a id="GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1" name="GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1"></a><h5 id="ADXDB-GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1" class="sect5"><span class="enumeration_section">4.8.2.1 </span>XQuery Functions fn:doc, fn:collection, and fn:doc-available
                     </h5>
                     <div>
                        <p>Oracle XML&nbsp;DB supports XQuery functions <code class="codeph">fn:doc</code>, <code class="codeph">fn:collection</code>, and <code class="codeph">fn:doc-available</code> for all resources in Oracle XML&nbsp;DB Repository. 
                        </p>
                        <div class="section">
                           <p>Function <code class="codeph">fn:doc</code> returns the repository <span class="italic">file</span> resource that is targeted by its URI argument; it must be a file of well-formed XML data. Function <code class="codeph">fn:collection</code> is similar, but works on repository <span class="italic">folder</span> resources (each file in the folder must contain well-formed XML data). 
                           </p>
                           <p>When used with Oracle URI scheme <code class="codeph">oradb</code>, <code class="codeph">fn:collection</code> can return XML data derived on the fly from existing relational data that is not in the repository.
                           </p>
                           <p>XQuery function <code class="codeph">fn:collection</code> raises an error when used with URI scheme <code class="codeph">oradb</code>, if its targeted table or view, or a targeted column, does not exist. Functions <code class="codeph">fn:doc</code> and <code class="codeph">fn:collection</code> do <span class="italic">not</span> raise an error if the repository resource passed as argument is not found. Instead, they return an empty sequence.
                           </p>
                           <p>You can determine whether a given document exists using XQuery function <code class="codeph">fn:doc-available</code>. It returns <code class="codeph">true</code> if its document argument exists, <code class="codeph">false</code> if not.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1__GUID-9C6BF6CF-A679-46EB-8942-0615AE0D9E8D">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xquery30_fn_op" target="_blank">XQuery 3.0 Functions and Operators</a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-22940B8D-1468-4966-9F55-7DD4518E9612" title="Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest XQuery 1.0 and XPath 2.0 Functions and Operators specification, with a few exceptions.">Support for XQuery Functions and Operators</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB6134"></a><div class="props_rev_3"><a id="GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" name="GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048"></a><h4 id="ADXDB-GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" class="sect4"><span class="enumeration_section">4.8.3 </span>Support for XQuery Full Text
                  </h4>
                  <div>
                     <p>Oracle XML&nbsp;DB supports XQuery Full Text for <code class="codeph">XMLType</code> data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.
                     </p>
                     <div class="section">
                        <p>Refer to the XQuery and XPath Full Text 1.0 Recommendation (hereafter XQuery Full Text, or XQFT) for information about any terms that are not detailed here.</p>
                        <p>Oracle supports XQuery Full Text  <span class="italic">only</span> for <code class="codeph">XMLType</code> data that is stored as <span class="italic">binary XML</span>. You can perform a full-text search of <code class="codeph">XMLType</code> data that is stored object-relationally using an Oracle Text index, but not using XQuery Full Text.
                        </p>
                        <p>A general rule for understanding Oracle support for XQuery Full Text is that the Oracle implementation of XQFT is based on Oracle Text, which provides full-text indexing and search for Oracle products and for applications developed using them. The XQFT support details provided in this section are a consequence of this Oracle Text based implementation.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E">XQuery Full Text, XML Schema-Based Data, and Pragma ora:no_schema</a><br>Use Oracle pragma <code class="codeph">ora:no_schema</code> with XQuery Full Text to query XML Schema-based <code class="codeph">XMLType</code> data that is stored as binary XML. The data is treated as if it were non XML Schema-based.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A">Restrictions on Using XQuery Full Text with XMLExists</a><br>Restrictions are specified for using XQuery Full Text with SQL/XML function <code class="codeph">XMLExists</code>.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C">Supported XQuery Full Text FTSelection Operators</a><br>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text FTSelection operators.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E">Supported XQuery Full Text Match Options</a><br>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text match options.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6">Unsupported XQuery Full Text Features</a><br>The XQuery Full Text features that are not supported by Oracle XML&nbsp;DB are specified.
                        </li>
                        <li class="ulchildlink"><a href="xquery-and-XML-DB.html#GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD">XQuery Full Text Errors</a><br>Compile-time errors that can be raised when you use XQuery Full Text are described.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048__GUID-05F84375-25A7-4C56-ABDD-73AF10606155">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccapp/index.html" target="_blank"><span><cite>Oracle Text Application Developer's Guide</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../ccref/index.html" target="_blank"><span><cite>Oracle Text Reference</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6141"></a><div class="props_rev_3"><a id="GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E" name="GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E"></a><h5 id="ADXDB-GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E" class="sect5"><span class="enumeration_section">4.8.3.1 </span>XQuery Full Text, XML Schema-Based Data, and Pragma ora:no_schema
                     </h5>
                     <div>
                        <p>Use Oracle pragma <code class="codeph">ora:no_schema</code> with XQuery Full Text to query XML Schema-based <code class="codeph">XMLType</code> data that is stored as binary XML. The data is treated as if it were non XML Schema-based.
                        </p>
                        <div class="section">
                           <p>You can use XQuery Full Text to query <code class="codeph">XMLType</code> data that is stored as binary XML. However, if you use it with XML Schema-based data then you must also use the XQuery extension-expression pragma <code class="codeph">ora:no_schema</code> in your query, or else an error is raised. 
                           </p>
                           <p>And if you use <code class="codeph">ora:no_schema</code> then, for purposes of XQuery Full Text, the XML data is implicitly cast to non XML Schema-based data. In other words, Oracle support of XQuery Full Text treats all XML data as if it were not based on an XML schema. 
                           </p>
                           <p>In particular, this means that if you include in your query an XQuery Full Text condition that makes use of XML Schema data types, such type considerations are ignored. A comparison of two XML Schema date values, for instance, is handled as a simple string comparison. Oracle support for XQuery Full Text is not XML Schema-aware.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="indexes-for-XMLType-data.html#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2" title="Oracle recommends in general that you use non XML Schema-based XMLType data when you use XQuery Full Text and an XML search index. But you can in some circumstances use XML Schema-based XMLType data that is stored as binary XML. Oracle XQuery pragma ora:no_schema can be useful in this context.">Pragma ora:no_schema: Using XML Schema-Based Data with XQuery Full Text</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6142"></a><div class="props_rev_3"><a id="GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A" name="GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A"></a><h5 id="ADXDB-GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A" class="sect5"><span class="enumeration_section">4.8.3.2 </span>Restrictions on Using XQuery Full Text with XMLExists
                     </h5>
                     <div>
                        <p>Restrictions are specified for using XQuery Full Text with SQL/XML function <code class="codeph">XMLExists</code>.
                        </p>
                        <div class="section">
                           <p>You can pass only one <code class="codeph">XMLType</code> instance as a SQL expression in the <code class="codeph">PASSING</code> clause of SQL/XML function <code class="codeph">XMLExists</code>, and each of the other, non-<code class="codeph">XMLType</code> SQL expressions in that clause must be either a <span class="italic">compile-time constant</span> of a SQL built-in data type or a <span class="italic">bind variable</span> that is bound to an instance of such a data type. If this restriction is not respected then compile-time error ORA-18177 is raised.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6135"></a><div class="props_rev_3"><a id="GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C" name="GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C"></a><h5 id="ADXDB-GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C" class="sect5"><span class="enumeration_section">4.8.3.3 </span>Supported XQuery Full Text FTSelection Operators
                     </h5>
                     <div>
                        <p>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text FTSelection operators.</p>
                        <div class="section">
                           <p>Oracle XML&nbsp;DB supports <span class="italic">only</span> the following XQuery Full Text FTSelection operators. Any applicable restrictions are noted. Use of the terms "must" and "must not" means that an error is raised if the specified restriction is not respected. Use of any operators not listed here raises an error.
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>FTAnd (<code class="codeph">ftand</code>)
                                 </p>
                              </li>
                              <li>
                                 <p>FTMildNot (<code class="codeph">not in</code>)
                                 </p>
                                 <p>Each operand for operator FTMildNot must be either a term or a phrase, that is, an instance of FTWords. It must not be an expression. Oracle handles FTMildNot the same way it handles Oracle Text operator <code class="codeph">MNOT</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>FTOr (<code class="codeph">ftor</code>)
                                 </p>
                              </li>
                              <li>
                                 <p>FTOrder (<code class="codeph">ordered</code>)
                                 </p>
                                 <p>Oracle supports the use of FTOrder <span class="italic">only</span> when used in the context of a window (FTWindow). Otherwise, it is not supported. For example, you can use <code class="codeph">ordered window 5 words</code>, but you cannot use only <code class="codeph">ordered</code> without also <code class="codeph">window</code>. Oracle handles FTOrder the same way it handles Oracle Text operator <code class="codeph">NEAR</code> with a <code class="codeph">TRUE</code> value for option <code class="codeph">ORDER</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>FTUnaryNot (<code class="codeph">ftnot</code>)
                                 </p>
                                 <p>FTUnaryNot must be used with FTAnd. You cannot use FTUnaryNot by itself. For example, you can use <code class="codeph">ftand ftnot</code>, but you cannot use only <code class="codeph">ftnot</code> without also <code class="codeph">ftand</code>. Oracle handles FTUnaryNot the same way it handles Oracle Text operator <code class="codeph">NOT</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>FTWindow (<code class="codeph">window</code>)
                                 </p>
                                 <p>Oracle handles FTWindow the same way it handles Oracle Text operator <code class="codeph">NEAR</code>. You must specify the window size only in words, not in sentences or paragraphs (for example, <code class="codeph">window 2 paragraphs</code>), and you must specify it as a numeric constant that is less than or equal to 100.
                                 </p>
                              </li>
                              <li>
                                 <p>FTWords</p>
                                 <p>FTWordsValue must be an XQuery literal string or a SQL bind variable whose value is passed to SQL function <code class="codeph">XMLExists</code> or <code class="codeph">XMLQuery</code> from a SQL expression whose evaluation returns a non-<code class="codeph">XMLType</code> value.
                                 </p>
                                 <p>In addition, FTAnyallOption, if present, must be <code class="codeph">any</code>. That is, FTWords must correspond to a sequence with only one item.
                                 </p>
                                 <div class="infoboxnote" id="GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C__GUID-C2D9AC8E-1D67-41D3-A06A-A7445EA3454D">
                                    <p class="notep1">Note:</p>
                                    <p>Even though FTWords corresponds to a sequence of only one item, you can still search for a phrase of multiple words, by using a single string for the entire phrase. So for example, although Oracle XML&nbsp;DB does not support using <code class="codeph">{"found" "necklace"}</code> for FTWords, you can use <code class="codeph">"found necklace"</code>.
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6136"></a><div class="props_rev_3"><a id="GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E" name="GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E"></a><h5 id="ADXDB-GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E" class="sect5"><span class="enumeration_section">4.8.3.4 </span>Supported XQuery Full Text Match Options
                     </h5>
                     <div>
                        <p>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text match options.</p>
                        <div class="section">
                           <p>Oracle XML&nbsp;DB supports <span class="italic">only</span> the following XQuery Full Text match options. Any applicable restrictions are noted. Use of the terms "must" and "must not" means that an error is raised if the specified restriction is not respected. Use of any match options not listed here raises an error.
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>FTStemOption (<code class="codeph">stemming</code>, <code class="codeph">no stemming</code>)
                                 </p>
                              </li>
                           </ul>
                           <p>The default behavior specified in the XQuery and XPath Full Text 1.0 Recommendation is used for each unsupported match option, with the following exceptions:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>FTLanguage (unsupported) &#x2013; The language used is the language defined by the <span class="italic">default lexer</span>, which means the language that was used when the database was installed.
                                 </p>
                              </li>
                              <li>
                                 <p>FTStopWordOption (unsupported) &#x2013; The stoplist used is the stoplist defined for that language.</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E__GUID-75B2B68B-5437-4B05-9721-DB9390636137">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF2052" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about the default lexer
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../ccref/oracle-text-supplied-stoplists.html#CCREF1400" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about the stoplist used for each supported language
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6143"></a><div class="props_rev_3"><a id="GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6" name="GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6"></a><h5 id="ADXDB-GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6" class="sect5"><span class="enumeration_section">4.8.3.5 </span>Unsupported XQuery Full Text Features
                     </h5>
                     <div>
                        <p>The XQuery Full Text features that are not supported by Oracle XML&nbsp;DB are specified.</p>
                        <div class="section">
                           <p>In addition to all FTSelection operators not mentioned in <a href="xquery-and-XML-DB.html#GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C" title="Oracle XML&nbsp;DB supports a subset of the XQuery Full Text FTSelection operators.">Supported XQuery Full Text FTSelection Operators</a> and all match options not mentioned in <a href="xquery-and-XML-DB.html#GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E" title="Oracle XML&nbsp;DB supports a subset of the XQuery Full Text match options.">Supported XQuery Full Text Match Options</a>, Oracle XML&nbsp;DB does <span class="italic">not</span> support the following XQuery Full Text features:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>FTIgnoreOption</p>
                              </li>
                              <li>
                                 <p>FTWeight (weight declarations, used with FTPrimaryWithOptions)</p>
                              </li>
                              <li>
                                 <p>FTScoreVar (score variables, used with XQuery ForClause and LetClause or with XPath 2.0 SimpleForClause)</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6144"></a><div class="props_rev_3"><a id="GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD" name="GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD"></a><h5 id="ADXDB-GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD" class="sect5"><span class="enumeration_section">4.8.3.6 </span>XQuery Full Text Errors
                     </h5>
                     <div>
                        <p>Compile-time errors that can be raised when you use XQuery Full Text are described.</p>
                        <div class="section">
                           <p>A compile-time error is raised whenever you use an XQuery Full Text (XQFT) feature that Oracle does not support.</p>
                           <p>In addition, compile-time error ORA-18177 is raised whenever you use a supported XQFT expression in a SQL <code class="codeph">WHERE</code> clause (typically in <code class="codeph">XMLExists</code>), if you did not create a corresponding XML search index or if that index is not picked up.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="xquery-and-XML-DB.html#GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6" title="The XQuery Full Text features that are not supported by Oracle XML&nbsp;DB are specified.">Unsupported XQuery Full Text Features</a></li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD__GUID-78DB5F8A-98CF-45B1-9CBF-68359076D4A8">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a> for information about creating an XML search index and handling error ORA-18177
                                 </p>
                              </li>
                              <li>
                                 <p><a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="A SQL query that involves XQuery expressions can often be automatically rewritten (optimized) in one or more ways. This optimization is referred to as XML query rewrite or optimization. When this happens, the XQuery expression is, in effect, evaluated directly against the XML document without constructing a DOM in memory.">Performance Tuning for XQuery</a> for information about axes other than forward and descendent
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Data-Types.html#SQLRF50972" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about SQL built-in data types
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">Footnote Legend</p>Footnote&nbsp;1: 
            <p>The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value.</p><br>Footnote&nbsp;2: 
            <p>Namespace prefix <code class="codeph">xs</code> is predefined for the XML Schema namespace, <code class="codeph">http://www.w3.org/2001/XMLSchema</code>.
            </p><br>Footnote&nbsp;3: 
            <p>The question mark (<code class="codeph">?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <a href="xquery-and-XML-DB.html#GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" title="XQuery expressions are case-sensitive. An XQuery expression is either a simple expression or an updating expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:">XQuery Expressions</a>.
            </p><br>Footnote&nbsp;4: 
            <p>Prior to Oracle Database 12c Release 1 (12.1.0.1), pragmas <code class="codeph">ora:no_xmlquery_rewrite</code> and <code class="codeph">ora:xmlquery_rewrite</code> were named <code class="codeph">ora:xq_proc</code> and <code class="codeph">ora:xq_qry</code>, respectively. They were renamed for readability, with no change in meaning.
            </p><br></div>
      </article>
   </body>
</html>