<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes the nature of and relationships among logical storage structures. These structures are created and recognized by Oracle Database and are not known to the operating system.">
      <meta name="description" content="This chapter describes the nature of and relationships among logical storage structures. These structures are created and recognized by Oracle Database and are not known to the operating system.">
      <title>Logical Storage Structures</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Concepts">
      <meta property="og:description" content="This chapter describes the nature of and relationships among logical storage structures. These structures are created and recognized by Oracle Database and are not known to the operating system.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Concepts">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00">
      <meta name="dcterms.title" content="Database Concepts">
      <meta name="dcterms.dateCopyrighted" content="1993, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96138-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="physical-storage-structures.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-instance-architecture.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="physical-storage-structures.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-instance-architecture.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Concepts</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-database-storage-structures.html" property="item" typeof="WebPage"><span property="name">Oracle Database Storage Structures</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Logical Storage Structures</li>
            </ol>
            <a id="GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D" name="GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D"></a>
            
            <h2 id="CNCPT-GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D" class="sect2"><span class="enumeration_chapter">12 </span>Logical Storage Structures
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the nature of and relationships among logical storage structures. These structures are created and recognized by Oracle Database and are not known to the operating system.</p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="logical-storage-structures.html#GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659" title="Oracle Database allocates logical space for all data in the database.">Introduction to Logical Storage Structures</a></p>
                  </li>
                  <li>
                     <p><a href="logical-storage-structures.html#GUID-1AED5140-E820-436C-BEB7-2A985524911E" title="Oracle Database manages the logical storage space in the data files of a database in a unit called a data block, also called an Oracle block or page. A data block is the minimum unit of database I/O.">Overview of Data Blocks</a></p>
                  </li>
                  <li>
                     <p><a href="logical-storage-structures.html#GUID-E3D8E030-A056-40AC-9B7E-8C957E28EE75" title="An extent is a unit of database storage made up of logically contiguous data blocks. Data blocks can be physically spread out on disk because of RAID striping and file system implementations.">Overview of Extents</a></p>
                  </li>
                  <li>
                     <p><a href="logical-storage-structures.html#GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" title="A segment is a set of extents that contains all the data for a logical storage structure within a tablespace.">Overview of Segments</a></p>
                  </li>
                  <li>
                     <p><a href="logical-storage-structures.html#GUID-3502CA78-FBC9-4927-B455-0ECB22E53066" title="A tablespace is a logical storage container for segments. Segments are database objects, such as tables and indexes, that consume storage space. At the physical level, a tablespace stores data in one or more data files or temp files.">Overview of Tablespaces</a></p>
                  </li>
               </ul>
            </div><a id="CNCPT89000"></a><a id="CNCPT301"></a><div class="props_rev_3"><a id="GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659" name="GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659"></a><h3 id="CNCPT-GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659" class="sect3">Introduction to Logical Storage Structures</h3>
               <div>
                  <p>Oracle Database allocates logical space for all data in the database.</p>
                  <p>The logical units of database space allocation are data blocks, extents, segments, and tablespaces. At a physical level, the data is stored in data files on disk. The data in the data files is stored in operating system blocks.</p>
                  <p>The following figure is an entity-relationship diagram for physical and logical storage. The crow's foot notation represents a one-to-many relationship.</p>
                  <div class="figure" id="GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659__BABDADHH">
                     <p class="titleinfigure">Figure 12-1 Logical and Physical Storage</p><img src="img/cncpt227.gif" alt="Description of Figure 12-1 follows" title="Description of Figure 12-1 follows" longdesc="img_text/cncpt227.html"><br><a href="img_text/cncpt227.html">Description of "Figure 12-1 Logical and Physical Storage"</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659__GUID-B4E4DF18-35BC-4C1C-B0FC-F84909A54460">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="physical-storage-structures.html#GUID-FFA872E1-7F63-4DC5-8A35-F21394AB4595" title="The physical database structures of an Oracle database are viewable at the operating system level.">Physical Storage Structures</a>"</span></p>
                  </div>
               </div><a id="CNCPT89001"></a><a id="CNCPT3000"></a><div class="props_rev_3"><a id="GUID-DC561B64-67D9-43CC-A9BA-BE5B92A7B869" name="GUID-DC561B64-67D9-43CC-A9BA-BE5B92A7B869"></a><h4 id="CNCPT-GUID-DC561B64-67D9-43CC-A9BA-BE5B92A7B869" class="sect4">Logical Storage Hierarchy</h4>
                  <div>
                     <p>A segment contains one or more extents, each of which contains multiple data blocks.</p>
                     <p>The following figure shows the relationships among data blocks, extents, and segments within a tablespace. In this example, a segment has two extents stored in different data files.</p>
                     <div class="figure" id="GUID-DC561B64-67D9-43CC-A9BA-BE5B92A7B869__I10251">
                        <p class="titleinfigure">Figure 12-2 Segments, Extents, and Data Blocks Within a Tablespace</p><img src="img/cncpt027.gif" alt="Description of Figure 12-2 follows" title="Description of Figure 12-2 follows" longdesc="img_text/cncpt027.html"><br><a href="img_text/cncpt027.html">Description of "Figure 12-2 Segments, Extents, and Data Blocks Within a Tablespace"</a></div>
                     <!-- class="figure" -->
                     <p>From the lowest level of granularity to the highest, Oracle Database stores data </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A <a href="glossary.html#GUID-2141C31D-6752-4260-91CE-99B4CC557247"><span class="xrefglossterm">data block</span></a> is the smallest logical unit of data storage in Oracle Database.
                           </p>
                           <p>One logical data block corresponds to a specific number of bytes of physical disk space, for example, 2 KB. Data blocks are the smallest units of storage that Oracle Database can use or allocate.</p>
                        </li>
                        <li>
                           <p>An <a href="glossary.html#GUID-C56D833A-B3D3-4B85-AAB4-334F7CF3F5E9"><span class="xrefglossterm">extent</span></a> is a set of logically contiguous data blocks allocated for storing a specific type of information
                           </p>
                           <p>In the preceding graphic, the 24 KB extent has 12 data blocks, while the 72 KB extent has 36 data blocks.</p>
                        </li>
                        <li>
                           <p>A <a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">segment</span></a> is a set of extents allocated for a specific database object, such as a <a href="glossary.html#GUID-DA8F7E11-B6AF-4ED3-B2A9-B5741E9AE2D4"><span class="xrefglossterm">table</span></a>. 
                           </p>
                           <p>For example, the data for the <code class="codeph">employees</code> table is stored in its own <a href="glossary.html#GUID-2CDB4221-D152-4C89-BB2B-4A7FC6DA340B"><span class="xrefglossterm">data segment</span></a>, whereas each <a href="glossary.html#GUID-3CDC5A7E-10A5-4F63-9ED3-49A74D001CA5"><span class="xrefglossterm">index</span></a> for <code class="codeph">employees</code> is stored in its own <a href="glossary.html#GUID-BDF74E0F-51FF-44C5-9A3B-26B8ACBB683C"><span class="xrefglossterm">index segment</span></a>. Every database object that consumes storage consists of a single segment.
                           </p>
                        </li>
                        <li>
                           <p>A <a href="glossary.html#GUID-AA66891C-71B2-4D55-8F64-0E427AE24E88"><span class="xrefglossterm">tablespace</span></a> is a database storage unit that contains one or more segments.
                           </p>
                           <p>Each segment belongs to one and only one tablespace. Thus, all extents for a segment are stored in the same tablespace. Within a tablespace, a segment can include extents from multiple data files, as shown in the preceding graphic. For example, one extent for a segment may be stored in <code class="codeph">users01.dbf</code>, while another is stored in <code class="codeph">users02.dbf</code>. A single extent can never span data files.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-DC561B64-67D9-43CC-A9BA-BE5B92A7B869__GUID-AAA40D4D-102E-4355-B94A-138DFAFA8202">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="physical-storage-structures.html#GUID-008A1F08-9C75-4E9F-A70B-41FB942C60B4" title="At the operating system level, Oracle Database stores database data in structures called data files. Every Oracle database must have at least one data file.">Overview of Data Files</a>"</span></p>
                     </div>
                  </div>
               </div><a id="CNCPT89002"></a><a id="CNCPT1095"></a><div class="props_rev_3"><a id="GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F" name="GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F"></a><h4 id="CNCPT-GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F" class="sect4">Logical Space Management</h4>
                  <div>
                     <p>Oracle Database must use logical space management to track and allocate the extents in a tablespace.</p>
                     <p>When a database object requires an extent, the database must have a method of finding and providing it. Similarly, when an object no longer requires an extent, the database must have a method of making the free extent available.</p>
                     <p>Oracle Database manages space within a tablespace based on the type that you create. You can create either of the following types of tablespaces:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Locally managed tablespaces (default)</p>
                           <p>The database uses bitmaps in the tablespaces themselves to manage extents. Thus, locally managed tablespaces have a part of the tablespace set aside for a bitmap. Within a tablespace, the database can manage segments with automatic segment space management (ASSM) or manual segment space management (MSSM).</p>
                        </li>
                        <li>
                           <p>Dictionary-managed tablespaces</p>
                           <p>The database uses the <a href="glossary.html#GUID-D6A3934F-BA6D-464F-9612-C683E20514A4"><span class="xrefglossterm">data dictionary</span></a> to manage extents.
                           </p>
                        </li>
                     </ul>
                     <p><a href="logical-storage-structures.html#GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F__BABDJBGD">Figure 12-3</a> shows the alternatives for logical space management in a tablespace.
                     </p>
                     <div class="figure" id="GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F__BABDJBGD">
                        <p class="titleinfigure">Figure 12-3 Logical Space Management</p><img src="img/cncpt268.gif" alt="Description of Figure 12-3 follows" title="Description of Figure 12-3 follows" longdesc="img_text/cncpt268.html"><br><a href="img_text/cncpt268.html">Description of "Figure 12-3 Logical Space Management"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F__GUID-2CA1387B-BE22-491E-95D2-FF0AEDD94CB9">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="data-dictionary-and-dynamic-performance-views.html#GUID-9B9ABE1C-A1E3-464F-8936-978250DC3E1F" title="An important part of an Oracle database is its data dictionary, which is a read-only set of tables that provides administrative metadata about the database.">Overview of the Data Dictionary</a>"</span></p>
                     </div>
                  </div><a id="CNCPT1096"></a><div class="props_rev_3"><a id="GUID-190867AF-0714-4B34-9AA4-C23293BDA2F0" name="GUID-190867AF-0714-4B34-9AA4-C23293BDA2F0"></a><h5 id="CNCPT-GUID-190867AF-0714-4B34-9AA4-C23293BDA2F0" class="sect5">Locally Managed Tablespaces</h5>
                     <div>
                        <p>A locally managed tablespace maintains a bitmap in the data file header to track free and used space in the data file body. </p>
                        <p>Each bit corresponds to a group of blocks. When space is allocated or freed, Oracle Database changes the bitmap values to reflect the new status of the blocks.</p>
                        <p>The following graphic is a conceptual representation of bitmap-managed storage. A <code class="codeph">1</code> in the header refers to used space, whereas a <code class="codeph">0</code> refers to free space. 
                        </p>
                        <div class="figure" id="GUID-190867AF-0714-4B34-9AA4-C23293BDA2F0__GUID-560F61DE-3165-455D-82D9-8813611CFD92">
                           <p class="titleinfigure">Figure 12-4 Bitmap-Managed Storage</p><img src="img/cncpt332.gif" alt="Description of Figure 12-4 follows" title="Description of Figure 12-4 follows" longdesc="img_text/cncpt332.html"><br><a href="img_text/cncpt332.html">Description of "Figure 12-4 Bitmap-Managed Storage"</a></div>
                        <!-- class="figure" -->
                        <p>A locally managed tablespace has the following advantages:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Avoids using the data dictionary to manage extents</p>
                              <p>Recursive operations can occur in dictionary-managed tablespaces if consuming or releasing space in an extent results in another operation that consumes or releases space in a data dictionary table or undo segment.</p>
                           </li>
                           <li>
                              <p>Tracks adjacent free space automatically</p>
                              <p>In this way, the database eliminates the need to coalesce free extents.</p>
                           </li>
                           <li>
                              <p>Determines the size of locally managed extents automatically</p>
                              <p>Alternatively, all extents can have the same size in a locally managed tablespace and override object storage options.</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-190867AF-0714-4B34-9AA4-C23293BDA2F0__GUID-12892D78-3F3E-4A71-B737-7F36B06D5083">
                           <p class="notep1">Note:</p>
                           <p>Oracle strongly recommends the use of locally managed tablespaces with Automatic Segment Space Management.</p>
                        </div>
                        <p>Segment space management is an attribute inherited from the tablespace that contains the segment. Within a locally managed tablespace, the database can manage segments automatically or manually. For example, segments in tablespace <code class="codeph">users</code> can be managed automatically while segments in tablespace <code class="codeph">tools</code> are managed manually.
                        </p>
                     </div><a id="CNCPT7668"></a><div class="props_rev_3"><a id="GUID-4AF2D61A-8675-4D48-97A4-B20F401ADA16" name="GUID-4AF2D61A-8675-4D48-97A4-B20F401ADA16"></a><h6 id="CNCPT-GUID-4AF2D61A-8675-4D48-97A4-B20F401ADA16" class="sect6">Automatic Segment Space Management</h6>
                        <div>
                           <p>The <span class="bold">automatic segment space management (ASSM)</span> method uses bitmaps to manage space in a tablespace.
                           </p>
                           <p>Bitmaps provide the following advantages:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Simplified administration</p>
                                 <p>ASSM avoids the need to manually determine correct settings for many storage parameters. Only one crucial SQL parameter controls space allocation: <code class="codeph">PCTFREE</code>. This parameter specifies the percentage of space to be reserved in a block for future updates (see <span class="q">"<a href="logical-storage-structures.html#GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E" title="The PCTFREE SQL parameter sets the minimum percentage of a data block reserved as free space for updates to existing rows. PCTFREE is important for preventing row migration and avoiding wasted space.">Percentage of Free Space in Data Blocks</a>"</span>). 
                                 </p>
                              </li>
                              <li>
                                 <p>Increased concurrency</p>
                                 <p>Multiple transactions can search separate lists of free data blocks, thereby reducing contention and waits. For many standard workloads, application performance with ASSM is better than the performance of a well-tuned application that uses MSSM.</p>
                              </li>
                              <li>
                                 <p>Dynamic affinity of space to instances in an Oracle Real Application Clusters (Oracle RAC) environment</p>
                              </li>
                           </ul>
                           <p>ASSM is more efficient and is the default for permanent, locally managed tablespaces.</p>
                           <div class="infoboxnote" id="GUID-4AF2D61A-8675-4D48-97A4-B20F401ADA16__GUID-240DF394-3738-4867-84E2-1DCA6B26FF23">
                              <p class="notep1">Note:</p>
                              <p>This chapter assumes the use of ASSM in all of its discussions of logical storage space.</p>
                           </div>
                        </div>
                     </div><a id="CNCPT89176"></a><a id="CNCPT7669"></a><div class="props_rev_3"><a id="GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF" name="GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF"></a><h6 id="CNCPT-GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF" class="sect6">Manual Segment Space Management</h6>
                        <div>
                           <p>The legacy <span class="bold">manual segment space management (MSSM)</span> method uses a linked list called a <span class="bold">free list</span> to manage free space in the segment.
                           </p>
                           <p> For a database object that has free space, a free list keeps track of blocks under the <a href="glossary.html#GUID-F3F5ACB2-94C8-483F-B427-1981836D0609"><span class="xrefglossterm">high water mark (HWM)</span></a> (HWM), which is the dividing line between segment space that is used and not yet used. As blocks are used, the database puts blocks on or removes blocks from the free list as needed.
                           </p>
                           <p>In addition to <code class="codeph">PCTFREE</code>, MSSM requires you to control space allocation with SQL parameters such as <code class="codeph">PCTUSED</code>, <code class="codeph">FREELISTS</code>, and <code class="codeph">FREELIST GROUPS</code>. <code class="codeph">PCTUSED</code> sets the percentage of free space that must exist in a currently used block for the database to put it on the free list. For example, if you set <code class="codeph">PCTUSED</code> to <code class="codeph">40</code> in a <code class="codeph">CREATE TABLE</code> statement, then you cannot insert rows into a block in the segment until less than 40% of the block space is used.
                           </p>
                           <p>For example, suppose you insert a row into a table. The database checks a free list of the table for the first available block. If the row does not fit in the block, and if the used space in the block is greater than or equal to <code class="codeph">PCTUSED</code>, then the database removes the block from the list and searches for another block. If you delete rows from the block, then the database checks whether used space in the block is now less than <code class="codeph">PCTUSED</code>. If so, then the database places the block at the beginning of the free list.
                           </p>
                           <p>An object may have multiple free lists. In this way, multiple sessions performing DML on a table can use different lists, which can reduce contention. Each database session uses only one free list for the duration of its session.</p>
                           <p>As shown in <a href="logical-storage-structures.html#GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF__BABJABGH">Figure 12-5</a>, you can also create an object with one or more <span class="italic">free list groups</span>, which are collections of free lists. Each group has a <span class="italic">master free list</span> that manages the individual <span class="italic">process free list</span> in the group. Space overhead for free lists, especially for free list groups, can be significant.
                           </p>
                           <div class="figure" id="GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF__BABJABGH">
                              <p class="titleinfigure">Figure 12-5 Free List Groups</p><img src="img/cncpt320.gif" alt="Description of Figure 12-5 follows" title="Description of Figure 12-5 follows" longdesc="img_text/cncpt320.html"><br><a href="img_text/cncpt320.html">Description of "Figure 12-5 Free List Groups"</a></div>
                           <!-- class="figure" -->
                           <p>Managing segment space manually can be complex. You must adjust <code class="codeph">PCTFREE</code> and <code class="codeph">PCTUSED</code> to reduce row migration and avoid wasting space. For example, if every used block in a segment is half full, and if <code class="codeph">PCTUSED</code> is <code class="codeph">40</code>, then the database does not permit inserts into any of these blocks. Because of the difficulty of fine-tuning space allocation parameters, Oracle strongly recommends ASSM. In ASSM, <code class="codeph">PCTFREE</code> determines whether a new row can be inserted into a block, but it does not use free lists and ignores <code class="codeph">PCTUSED</code>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF__GUID-1C3A2F09-9D3A-4164-9FEC-032DA100BE6B">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="logical-storage-structures.html#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" title="Oracle Database uses chaining and migration to manage rows that are too large to fit into a single block.">Chained and Migrated Rows</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../admin/managing-tablespaces.html#ADMIN11360" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about locally managed tablespaces
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../admin/managing-tablespaces.html#ADMIN10065" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn more about automatic segment space management
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/physical_attributes_clause.html#SQLRF30011" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about storage parameters such as <code class="codeph">PCTFREE</code> and <code class="codeph">PCTUSED</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT1098"></a><div class="props_rev_3"><a id="GUID-E0A29F9D-3987-46BE-AD07-EE27068FDD92" name="GUID-E0A29F9D-3987-46BE-AD07-EE27068FDD92"></a><h5 id="CNCPT-GUID-E0A29F9D-3987-46BE-AD07-EE27068FDD92" class="sect5">Dictionary-Managed Tablespaces </h5>
                     <div>
                        <p>A dictionary-managed tablespace uses the data dictionary to manage its extents. </p>
                        <p>Oracle Database updates tables in the data dictionary whenever an extent is allocated or freed for reuse. For example, when a table needs an extent, the database queries the data dictionary tables, and searches for free extents. If the database finds space, then it modifies one data dictionary table and inserts a row into another. In this way, the database manages space by modifying and moving data.</p>
                        <p>The SQL that the database executes in the background to obtain space for database objects is <a href="glossary.html#GUID-31B21CCC-5324-4B86-A58A-2BC7DF57AB33"><span class="xrefglossterm">recursive SQL</span></a>. Frequent use of recursive SQL can have a negative impact on performance because updates to the data dictionary must be serialized. Locally managed tablespaces, which are the default, avoid this performance problem.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E0A29F9D-3987-46BE-AD07-EE27068FDD92__GUID-59F84071-A1CA-4946-ABD8-FF8662278BD3">
                           <p class="notep1">See Also:</p>
                           <p><a href="../admin/managing-tablespaces.html#ADMIN11392" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to migrate tablespaces from dictionary-managed to locally managed
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT302"></a><div class="props_rev_3"><a id="GUID-1AED5140-E820-436C-BEB7-2A985524911E" name="GUID-1AED5140-E820-436C-BEB7-2A985524911E"></a><h3 id="CNCPT-GUID-1AED5140-E820-436C-BEB7-2A985524911E" class="sect3">Overview of Data Blocks</h3>
               <div>
                  <p>Oracle Database manages the logical storage space in the data files of a database in a unit called a <span class="bold">data block</span>, also called an <span class="italic">Oracle block</span> or <span class="italic">page</span>. A data block is the minimum unit of database I/O.
                  </p>
               </div><a id="CNCPT89003"></a><a id="CNCPT250"></a><div class="props_rev_3"><a id="GUID-B4F626CB-9909-47B9-ACF1-A4EA913B5053" name="GUID-B4F626CB-9909-47B9-ACF1-A4EA913B5053"></a><h4 id="CNCPT-GUID-B4F626CB-9909-47B9-ACF1-A4EA913B5053" class="sect4">Data Blocks and Operating System Blocks</h4>
                  <div>
                     <p>At the physical level, database data is stored in disk files made up of operating system blocks.</p>
                     <p>An <a href="glossary.html#GUID-D3D87FDB-24AD-4B10-A61E-1E6F40FCE562"><span class="xrefglossterm">operating system block</span></a> is the minimum unit of data that the operating system can read or write. In contrast, an Oracle block is a logical storage structure whose size and structure are not known to the operating system.
                     </p>
                     <p>The following figure shows that operating system blocks may differ in size from data blocks. The database requests data in multiples of data blocks, not operating system blocks. </p>
                     <div class="figure" id="GUID-B4F626CB-9909-47B9-ACF1-A4EA913B5053__BABDCGIB">
                        <p class="titleinfigure">Figure 12-6 Data Blocks and Operating System Blocks</p><img src="img/cncpt293.gif" alt="Description of Figure 12-6 follows" title="Description of Figure 12-6 follows" longdesc="img_text/cncpt293.html"><br><a href="img_text/cncpt293.html">Description of "Figure 12-6 Data Blocks and Operating System Blocks"</a></div>
                     <!-- class="figure" -->
                     <p>When the database requests a data block, the operating system translates this operation into a requests for data in permanent storage. The logical separation of data blocks from operating system blocks has the following implications: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Applications do not need to determine the physical addresses of data on disk.</p>
                        </li>
                        <li>
                           <p>Database data can be striped or mirrored on multiple physical disks.</p>
                        </li>
                     </ul>
                  </div><a id="CNCPT7670"></a><div class="props_rev_3"><a id="GUID-39B58094-478C-4DD9-8419-504439F4E8F7" name="GUID-39B58094-478C-4DD9-8419-504439F4E8F7"></a><h5 id="CNCPT-GUID-39B58094-478C-4DD9-8419-504439F4E8F7" class="sect5">Database Block Size</h5>
                     <div>
                        <p>Every database has a database block size. </p>
                        <p>The <code class="codeph">DB_BLOCK_SIZE</code> initialization parameter sets the data block size for a database when it is created. The size is set for the <code class="codeph">SYSTEM</code> and <code class="codeph">SYSAUX</code> tablespaces and is the default for all other tablespaces. The database block size cannot be changed except by re-creating the database.
                        </p>
                        <p>If <code class="codeph">DB_BLOCK_SIZE</code> is not set, then the default data block size is operating system-specific. The standard data block size for a database is 4 KB or 8 KB. If the size differs for data blocks and operating system blocks, then the data block size must be a multiple of the operating system block size.
                        </p>
                        <div class="infoboxnotealso" id="GUID-39B58094-478C-4DD9-8419-504439F4E8F7__GUID-060A75CE-194F-40B0-B553-68D46B36B23E">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../refrn/DB_BLOCK_SIZE.html#REFRN10031" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">DB_BLOCK_SIZE</code> initialization parameter
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN11106" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> and <a href="../tgdba/IO-configuration-and-design.html#TGDBA94404" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to choose block sizes
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT7671"></a><div class="props_rev_3"><a id="GUID-C6AFF186-0A2A-40C2-A0AF-7450CBFF9603" name="GUID-C6AFF186-0A2A-40C2-A0AF-7450CBFF9603"></a><h5 id="CNCPT-GUID-C6AFF186-0A2A-40C2-A0AF-7450CBFF9603" class="sect5">Tablespace Block Size</h5>
                     <div>
                        <p>You can create individual tablespaces whose block size differs from the <code class="codeph">DB_BLOCK_SIZE</code> setting. 
                        </p>
                        <p>A nonstandard block size can be useful when moving a <a href="glossary.html#GUID-F3AC6538-2722-4916-BD9F-EDAB8318CCCD"><span class="xrefglossterm">transportable tablespace</span></a> to a different platform.
                        </p>
                        <div class="infoboxnotealso" id="GUID-C6AFF186-0A2A-40C2-A0AF-7450CBFF9603__GUID-B362AC6C-9B50-4C6F-8799-D22934AC2E42">
                           <p class="notep1">See Also:</p>
                           <p><a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN11107" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to specify a nonstandard block size for a tablespace
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89004"></a><a id="CNCPT1046"></a><div class="props_rev_3"><a id="GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2" name="GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2"></a><h4 id="CNCPT-GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2" class="sect4">Data Block Format</h4>
                  <div>
                     <p>Every data block has a format or internal structure that enables the database to track the data and free space in the block. This format is similar whether the data block contains table, index, or table cluster data. </p>
                     <p>The following figure shows the format of an uncompressed data block.</p>
                     <div class="figure" id="GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2__I4902">
                        <p class="titleinfigure">Figure 12-7 Data Block Format</p><img src="img/cncpt028.gif" alt="Description of Figure 12-7 follows" title="Description of Figure 12-7 follows" longdesc="img_text/cncpt028.html"><br><a href="img_text/cncpt028.html">Description of "Figure 12-7 Data Block Format"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2__GUID-2DAE5318-A62B-4C45-A8EB-7C876008764A">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="logical-storage-structures.html#GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46" title="The database can use table compression to eliminate duplicate values in a data block. This section describes the format of data blocks that use compression.">Data Block Compression</a>"</span> to learn about compressed blocks
                        </p>
                     </div>
                  </div><a id="CNCPT1050"></a><div class="props_rev_3"><a id="GUID-D12A9269-54D8-4765-9E92-CEDDC98F1468" name="GUID-D12A9269-54D8-4765-9E92-CEDDC98F1468"></a><h5 id="CNCPT-GUID-D12A9269-54D8-4765-9E92-CEDDC98F1468" class="sect5">Data Block Overhead</h5>
                     <div>
                        <p>Oracle Database uses the <strong class="term">block overhead</strong> to manage the block itself. The block overhead is not available to store user data. 
                        </p>
                        <p>As shown in <span class="q">"<a href="logical-storage-structures.html#GUID-754ECC03-DD58-4B49-95D1-B98A23B508B2" title="Every data block has a format or internal structure that enables the database to track the data and free space in the block. This format is similar whether the data block contains table, index, or table cluster data.">Data Block Format</a>"</span>, the block overhead includes the following parts:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Block header</p>
                              <p>This part contains general information about the block, including disk address and segment type. For blocks that are transaction-managed, the <a href="glossary.html#GUID-78394D5D-A1F6-4978-8F13-028185F514B5"><span class="xrefglossterm">block header</span></a> contains active and historical transaction information. 
                              </p>
                              <p>A <a href="glossary.html#GUID-B7820ED2-E8D7-40B3-AAAE-2B8F935C220C"><span class="xrefglossterm">transaction entry</span></a> is required for every transaction that updates the block. Oracle Database initially reserves space in the block header for transaction entries. In data blocks allocated to segments that support transactional changes, free space can also hold transaction entries when the header space is depleted. The space required for transaction entries is operating system dependent. However, transaction entries in most operating systems require approximately 23 bytes.
                              </p>
                           </li>
                           <li>
                              <p>Table directory</p>
                              <p>For a <a href="glossary.html#GUID-861D8FCE-B86C-46B3-AA01-35066D24F4CF"><span class="xrefglossterm">heap-organized table</span></a>, this directory contains metadata about tables whose rows are stored in this block. In a table cluster, multiple tables can store rows in the same block.
                              </p>
                           </li>
                           <li>
                              <p>Row directory</p>
                              <p>For a heap-organized table, this directory describes the location of rows in the data portion of the block. The database can place a row anywhere in the bottom of the block. The row address is recorded in one of the slots of the row directory vector.</p>
                              <p>A rowid points to a specific file, block, and row number. For example, in the rowid <code class="codeph">AAAPecAAFAAAABSAAA</code>, the final <code class="codeph">AAA</code> represents the row number. The row number is an index into an entry in the row directory. The row directory entry contains a pointer to the location of the row on the data block. If the database moves a row within a block, then the database updates the row directory entry to modify the pointer. The rowid stays constant.
                              </p>
                              <p>After the database allocates space in the row directory, the database does not reclaim this space after deleting rows. Thus, a block that is currently empty but formerly had up to 50 rows continues to have 100 bytes allocated for the row directory. The database reuses this space only when a session inserts new rows in the block.</p>
                           </li>
                        </ul>
                        <p>Some parts of the block overhead are fixed in size, but the total size is variable. On average, the block overhead totals 84 to 107 bytes.</p>
                     </div>
                  </div><a id="CNCPT89005"></a><a id="CNCPT1051"></a><div class="props_rev_3"><a id="GUID-D993A749-93D0-448C-BDC8-330D805AC481" name="GUID-D993A749-93D0-448C-BDC8-330D805AC481"></a><h5 id="CNCPT-GUID-D993A749-93D0-448C-BDC8-330D805AC481" class="sect5">Row Format</h5>
                     <div>
                        <p>The row data part of the block contains the actual data, such as table rows or index key entries. Just as every data block has an internal format, every row has a row format that enables the database to track the data in the row.</p>
                        <p>Oracle Database stores rows as variable-length records. A row is contained in one or more sections. Each section is called a <a href="glossary.html#GUID-4C16E45D-79AF-40D5-ACE2-CE2B301CA97B"><span class="xrefglossterm">row piece</span></a>. Each row piece has a row header and column data.
                        </p>
                        <p>The following figure shows the format of a row.</p>
                        <div class="figure" id="GUID-D993A749-93D0-448C-BDC8-330D805AC481__THEFORMATOFAROWPIECE-EC1F5807">
                           <p class="titleinfigure">Figure 12-8 The Format of a Row Piece</p><img src="img/cncpt043.gif" alt="Description of Figure 12-8 follows" title="Description of Figure 12-8 follows" longdesc="img_text/cncpt043.html"><br><a href="img_text/cncpt043.html">Description of "Figure 12-8 The Format of a Row Piece"</a></div>
                        <!-- class="figure" -->
                     </div><a id="CNCPT89006"></a><div class="props_rev_3"><a id="GUID-D01C1E10-43DE-461D-9B41-A65266EAB70B" name="GUID-D01C1E10-43DE-461D-9B41-A65266EAB70B"></a><h6 id="CNCPT-GUID-D01C1E10-43DE-461D-9B41-A65266EAB70B" class="sect6">Row Header</h6>
                        <div>
                           <p>Oracle Database uses the row header to manage the row piece stored in the block.</p>
                           <p>The row header contains information such as the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Columns in the row piece</p>
                              </li>
                              <li>
                                 <p>Pieces of the row located in other data blocks</p>
                                 <p>If an entire row can be inserted into a single data block, then Oracle Database stores the row as one row piece. However, if all of the row data cannot be inserted into a single block or an update causes an existing row to outgrow its block, then the database stores the row in multiple row pieces. A data block usually contains only one row piece per row.</p>
                              </li>
                              <li>
                                 <p>Cluster keys for table clusters</p>
                              </li>
                           </ul>
                           <p>A row fully contained in one block has at least 3 bytes of row header.</p>
                           <div class="infoboxnotealso" id="GUID-D01C1E10-43DE-461D-9B41-A65266EAB70B__GUID-63FA5FB5-B7CA-42F1-AC89-AE0757F648CC">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="logical-storage-structures.html#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" title="Oracle Database uses chaining and migration to manage rows that are too large to fit into a single block.">Chained and Migrated Rows</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-04AADD81-E5C2-498B-B857-DF2A37DD3520" title="A table cluster is a group of tables that share common columns and store related data in the same blocks.">Overview of Table Clusters</a>"</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT89007"></a><div class="props_rev_3"><a id="GUID-4B9E65B3-327F-49C3-AD98-D412A98D2151" name="GUID-4B9E65B3-327F-49C3-AD98-D412A98D2151"></a><h6 id="CNCPT-GUID-4B9E65B3-327F-49C3-AD98-D412A98D2151" class="sect6">Column Data</h6>
                        <div>
                           <p>After the row header, the column data section stores the actual data in the row. The row piece usually stores columns in the order listed in the <code class="codeph">CREATE TABLE</code> statement, but this order is not guaranteed. For example, columns of type <code class="codeph">LONG</code> are created last.
                           </p>
                           <p>As shown in the figure in <span class="q">"<a href="logical-storage-structures.html#GUID-D993A749-93D0-448C-BDC8-330D805AC481" title="The row data part of the block contains the actual data, such as table rows or index key entries. Just as every data block has an internal format, every row has a row format that enables the database to track the data in the row.">Row Format</a>"</span>, for each column in a row piece, Oracle Database stores the column length and data separately. The space required depends on the data type. If the data type of a column is variable length, then the space required to hold a value can grow and shrink with updates to the data.
                           </p>
                           <p>Each row has a slot in the row directory of the data block header. The slot points to the beginning of the row.</p>
                           <div class="infoboxnotealso" id="GUID-4B9E65B3-327F-49C3-AD98-D412A98D2151__GUID-943E3E3A-5402-4B2C-BC19-4BDFB33A1169">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-85BE900A-0047-4B7C-A992-F1E35B640CA3" title="Oracle Database uses a data segment in a tablespace to hold table data.">Table Storage</a>"</span> and <span class="q">"<a href="indexes-and-index-organized-tables.html#GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" title="Oracle Database stores index data in an index segment. .">Index Storage</a>"</span></p>
                           </div>
                        </div>
                     </div><a id="CNCPT89010"></a><a id="CNCPT89009"></a><a id="CNCPT89008"></a><div class="props_rev_3"><a id="GUID-684E6324-A874-4304-8015-5634199BEE81" name="GUID-684E6324-A874-4304-8015-5634199BEE81"></a><h6 id="CNCPT-GUID-684E6324-A874-4304-8015-5634199BEE81" class="sect6">Rowid Format</h6>
                        <div>
                           <p>Oracle Database uses a <span class="bold">rowid</span> to uniquely identify a row. Internally, the rowid is a structure that holds information that the database needs to access a row. A rowid is not physically stored in the database, but is inferred from the file and block on which the data is stored.
                           </p>
                           <p>An extended rowid includes a data object number. This rowid type uses a base 64 encoding of the physical address for each row. The encoding characters are <code class="codeph">A-Z</code>, <code class="codeph">a-z</code>, <code class="codeph">0-9</code>, <code class="codeph">+</code>, and <code class="codeph">/</code>. 
                           </p>
                           <div class="example" id="GUID-684E6324-A874-4304-8015-5634199BEE81__BABJJJIB">
                              <p class="titleinexample">Example 12-1 ROWID Pseudocolumn</p>
                              <p>The following example queries the <code class="codeph">ROWID</code> <a href="glossary.html#GUID-175D4923-5C7E-4FF0-A69B-C4D8F3D93A3D"><span class="xrefglossterm">pseudocolumn</span></a> to show the extended rowid of the row in the <code class="codeph">employees</code> table for employee 100:
                              </p><pre class="pre codeblock"><code>SQL&gt; SELECT ROWID FROM employees WHERE employee_id = 100;
 
ROWID
------------------
AAAPecAAFAAAABSAAA
</code></pre><p>The following figure illustrates the format of an extended rowid.</p>
                              <div class="figure" id="GUID-684E6324-A874-4304-8015-5634199BEE81__CBBFDAHG">
                                 <p class="titleinfigure">Figure 12-9 ROWID Format</p><img src="img/cncpt249.gif" alt="Description of Figure 12-9 follows" title="Description of Figure 12-9 follows" longdesc="img_text/cncpt249.html"><br><a href="img_text/cncpt249.html">Description of "Figure 12-9 ROWID Format"</a></div>
                              <!-- class="figure" -->
                              <p>An extended rowid is displayed in a four-piece format, <code class="codeph">OOOOOOFFFBBBBBBRRR</code>, with the format divided into the following components:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">OOOOOO</code></p>
                                    <p>The data object number identifies the segment (data object <code class="codeph">AAAPec</code> in the sample query). A data object number is assigned to every database segment. Schema objects in the same segment, such as a <a href="glossary.html#GUID-1C56177E-6BEE-4FE7-B45E-38298CDB946D"><span class="xrefglossterm">table cluster</span></a>, have the same data object number.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FFF</code></p>
                                    <p>The tablespace-relative data file number identifies the data file that contains the row (file <code class="codeph">AAF</code> in the sample query).
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">BBBBBB</code></p>
                                    <p>The data block number identifies the block that contains the row (block <code class="codeph">AAAABS</code> in the sample query). Block numbers are relative to their data file, not their tablespace. Thus, two rows with identical block numbers could reside in different data files of the same tablespace.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">RRR</code></p>
                                    <p>The row number identifies the row in the block (row <code class="codeph">AAA</code> in the sample query). 
                                    </p>
                                 </li>
                              </ul>
                              <p>After a rowid is assigned to a row piece, the rowid can change in special circumstances. For example, if row movement is enabled, then the rowid can change because of partition key updates, Flashback Table operations, shrink table operations, and so on. If row movement is disabled, then a rowid can change if the row is exported and imported using Oracle Database utilities.</p>
                              <div class="infoboxnote" id="GUID-684E6324-A874-4304-8015-5634199BEE81__GUID-9936FEA7-CAED-4962-A233-EE102BD2E5B5">
                                 <p class="notep1">Note:</p>
                                 <p>Internally, the database performs row movement as if the row were physically deleted and reinserted. However, row movement is considered an update, which has implications for triggers.</p>
                              </div>
                              <div class="infoboxnotealso" id="GUID-684E6324-A874-4304-8015-5634199BEE81__GUID-79F0CAE4-4611-4A71-BD57-CA91F8806B00">
                                 <p class="notep1">See Also:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-0258C4C2-2BF2-445F-B1E1-F282A57A6859" title="Every row stored in the database has an address. Oracle Database uses a ROWID data type to store the address (rowid) of every row in the database.">Rowid Data Types</a>"</span></p>
                                    </li>
                                    <li>
                                       <p><a href="../sqlrf/Data-Types.html#SQLRF50998" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about rowids
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89140"></a><a id="CNCPT89143"></a><a id="CNCPT89141"></a><a id="CNCPT89142"></a><a id="CNCPT89139"></a><div class="props_rev_3"><a id="GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46" name="GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46"></a><h4 id="CNCPT-GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46" class="sect4">Data Block Compression</h4>
                  <div>
                     <p>The database can use <span class="bold">table compression</span> to eliminate duplicate values in a data block. This section describes the format of data blocks that use compression.
                     </p>
                     <p>The format of a data block that uses basic table and advanced row compression is essentially the same as an uncompressed block. The difference is that a symbol table at the beginning of the block stores duplicate values for the rows and columns. The database replaces occurrences of these values with a short reference to the symbol table.</p>
                     <div class="example" id="GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46__GUID-952CDC5E-81B3-4983-BBBF-B7F81C90006D">
                        <p class="titleinexample">Example 12-2 Format of Compressed Data Blocks</p>
                        <p>Assume that the following rows are stored in a data block for the seven-column <code class="codeph">sales</code> table:
                        </p><pre class="pre codeblock"><code>2190,13770,25-NOV-00,S,9999,23,161
2225,15720,28-NOV-00,S,9999,25,1450
34005,120760,29-NOV-00,P,9999,44,2376
9425,4750,29-NOV-00,I,9999,11,979
1675,46750,29-NOV-00,S,9999,19,1121
</code></pre><p>When basic table or advanced row compression is applied to this table, the database replaces duplicate values with a symbol reference. The following conceptual representation of the compression shows the symbol <code class="codeph">*</code> replacing <code class="codeph">29-NOV-00</code> and <code class="codeph">%</code> replacing <code class="codeph">9999</code>:
                        </p><pre class="pre codeblock"><code>2190,13770,25-NOV-00,S,%,23,161
2225,15720,28-NOV-00,S,%,25,1450
34005,120760,*,P,%,44,2376
9425,4750,*,I,%,11,979
1675,46750,*,S,%,19,1121
</code></pre><p><a href="logical-storage-structures.html#GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46__BABCFDJG" title="This table represents the symbol table that maps symbols to values.">Table 12-1</a> conceptually represents the symbol table that maps symbols to values.
                        </p>
                        <div class="tblformal" id="GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46__BABCFDJG">
                           <p class="titleintable">Table 12-1 Symbol Table</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Symbol Table" summary="This table represents the symbol table that maps symbols to values." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d61599e5829">Symbol</th>
                                    <th align="left" valign="bottom" id="d61599e5832">Value</th>
                                    <th align="left" valign="bottom" id="d61599e5835">Column</th>
                                    <th align="left" valign="bottom" id="d61599e5838">Rows</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d61599e5843" headers="d61599e5829 ">
                                       <p>*</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5843 d61599e5832 ">
                                       <p>29-NOV-00</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5843 d61599e5835 ">
                                       <p>3</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5843 d61599e5838 ">
                                       <p>958-960</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d61599e5856" headers="d61599e5829 ">
                                       <p>%</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5856 d61599e5832 ">
                                       <p>9999</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5856 d61599e5835 ">
                                       <p>5</p>
                                    </td>
                                    <td align="left" valign="top" headers="d61599e5856 d61599e5838 ">
                                       <p>956-960</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-B248DC2A-3F65-42CF-ACA5-0B096CFCFC46__GUID-FA5F7C5B-8D2D-45BB-BE9C-75AFCC152518">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-54EE5325-0894-4869-B3AD-8912D9B4A329" title="The database can use table compression to reduce the amount of storage required for the table.">Table Compression</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="CNCPT1053"></a><div class="props_rev_3"><a id="GUID-2785BB10-1628-4645-AEE9-27EC18E8BB21" name="GUID-2785BB10-1628-4645-AEE9-27EC18E8BB21"></a><h4 id="CNCPT-GUID-2785BB10-1628-4645-AEE9-27EC18E8BB21" class="sect4">Space Management in Data Blocks</h4>
                  <div>
                     <p>As the database fills a data block from the bottom up, the amount of free space between the row data and the block header decreases. </p>
                     <p>Free space in a data block can also shrink during updates, as when changing a trailing null value to a non-null value. The database manages free space in the data block to optimize performance and avoid wasted space.</p>
                     <div class="infoboxnote" id="GUID-2785BB10-1628-4645-AEE9-27EC18E8BB21__GUID-51F1E991-DDA8-491D-BC02-2D6180DC4682">
                        <p class="notep1">Note:</p>
                        <p>This section assumes the use of automatic segment space management.</p>
                     </div>
                  </div><a id="CNCPT89011"></a><a id="CNCPT1057"></a><div class="props_rev_3"><a id="GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E" name="GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E"></a><h5 id="CNCPT-GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E" class="sect5">Percentage of Free Space in Data Blocks</h5>
                     <div>
                        <p>The <code class="codeph">PCTFREE</code> SQL parameter sets the minimum percentage of a data block reserved as free space for updates to existing rows. <code class="codeph">PCTFREE</code> is important for preventing row migration and avoiding wasted space.
                        </p>
                        <p>For example, assume that you create a table that will require only occasional updates, most of which will not increase the size of the existing data. You specify the <code class="codeph">PCTFREE</code> parameter within a <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> statement as follows:
                        </p><pre class="pre codeblock"><code>CREATE TABLE test_table (n NUMBER) PCTFREE 20;
</code></pre><p><a href="logical-storage-structures.html#GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E__BABHHIDA">Figure 12-10</a> shows how a <code class="codeph">PCTFREE</code> setting of <code class="codeph">20</code> affects space management. The database adds rows to the block over time, causing the row data to grow upwards toward the block header, which is itself expanding downward toward the row data. The <code class="codeph">PCTFREE</code> setting ensures that <span class="italic">at least</span> 20% of the data block is free. For example, the database prevents an <code class="codeph">INSERT</code> statement from filling the block so that the row data and header occupy a combined 90% of the total block space, leaving only 10% free.
                        </p>
                        <div class="figure" id="GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E__BABHHIDA">
                           <p class="titleinfigure">Figure 12-10 PCTFREE</p><img src="img/cncpt029.gif" alt="Description of Figure 12-10 follows" title="Description of Figure 12-10 follows" longdesc="img_text/cncpt029.html"><br><a href="img_text/cncpt029.html">Description of "Figure 12-10 PCTFREE"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnote" id="GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E__GUID-0CEE6A52-FB64-4527-9224-3F4D14E041F9">
                           <p class="notep1">Note:</p>
                           <p>This discussion does not apply to <a href="glossary.html#GUID-A85748CE-C4D4-43ED-BD49-29AFC4AD3A02"><span class="xrefglossterm">LOB</span></a> data types, which do not use the <code class="codeph">PCTFREE</code> storage parameter or free lists.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-ECB2069B-A7DC-4D3D-A345-D3216CAEDB6E__GUID-A3171D81-13C6-4976-91AA-4CC21C1468D1">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="concepts-for-database-developers.html#GUID-E918382E-0E0A-444C-ABD3-BCC6EFC0AB38" title="Large object (LOB) data types enable you to store and manipulate large blocks of unstructured data in binary or character format.">Overview of LOBs</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/physical_attributes_clause.html#SQLRF52292" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax and semantics of the <code class="codeph">PCTFREE</code> parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1054"></a><div class="props_rev_3"><a id="GUID-298A5447-858D-4384-84A8-6DE6804EBEB0" name="GUID-298A5447-858D-4384-84A8-6DE6804EBEB0"></a><h5 id="CNCPT-GUID-298A5447-858D-4384-84A8-6DE6804EBEB0" class="sect5">Optimization of Free Space in Data Blocks</h5>
                     <div>
                        <p>While the percentage of free space cannot be <span class="italic">less</span> than <code class="codeph">PCTFREE</code>, the amount of free space can be <span class="italic">greater</span>. For example, setting <code class="codeph">PCTFREE</code> to 20% prevents the total amount of free space from dropping to 5% of the block, but allows 50% of the block to be free.
                        </p>
                     </div><a id="CNCPT89222"></a><div class="props_rev_3"><a id="GUID-DB1E5A0D-84A7-4620-8197-6928F2DC0A9B" name="GUID-DB1E5A0D-84A7-4620-8197-6928F2DC0A9B"></a><h6 id="CNCPT-GUID-DB1E5A0D-84A7-4620-8197-6928F2DC0A9B" class="sect6">Optimization by Increasing Free Space</h6>
                        <div>
                           <p>Some DML statements can increase free space in data blocks.</p>
                           <p>The following statements can increase space:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">DELETE</code> statements
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UPDATE</code> statements that either update existing values to smaller values or increase existing values and force a row to migrate
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">INSERT</code> statements on a table that uses advanced row compression
                                 </p>
                                 <p>If <code class="codeph">INSERT</code> statements fill a block with data, then the database invokes block compression, which may result in the block having more free space.
                                 </p>
                              </li>
                           </ul>
                           <p>The space released is available for <code class="codeph">INSERT</code> statements under the following conditions:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If the <code class="codeph">INSERT</code> statement is in the same transaction, and if it is after the statement that frees space, then the statement can use the space. 
                                 </p>
                              </li>
                              <li>
                                 <p>If the <code class="codeph">INSERT</code> statement is in a separate transaction from the statement that frees space (perhaps run by another user), and if space is needed, then the statement can use the space made available, but only after the other transaction commits.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-DB1E5A0D-84A7-4620-8197-6928F2DC0A9B__GUID-4A4CEC03-1043-4802-BE68-D568D59E31E6">
                              <p class="notep1">See Also:</p>
                              <p><a href="../admin/managing-tables.html#ADMIN13948" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about advanced row compression
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT89013"></a><a id="CNCPT89014"></a><a id="CNCPT89012"></a><div class="props_rev_3"><a id="GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9" name="GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9"></a><h6 id="CNCPT-GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9" class="sect6">Optimization by Coalescing Fragmented Space</h6>
                        <div>
                           <p>Released space may or may not be contiguous with the main area of free space in a data block. Noncontiguous free space is called <span class="italic">fragmented space</span>.
                           </p>
                           <p>The following figure shows a data block with noncontiguous free space.</p>
                           <div class="figure" id="GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9__BABJHCCE">
                              <p class="titleinfigure">Figure 12-11 Data Block with Fragmented Space</p><img src="img/cncpt210.gif" alt="Description of Figure 12-11 follows" title="Description of Figure 12-11 follows" longdesc="img_text/cncpt210.html"><br><a href="img_text/cncpt210.html">Description of "Figure 12-11 Data Block with Fragmented Space"</a></div>
                           <!-- class="figure" -->
                           <p>Oracle Database automatically and transparently coalesces the free space of a data block <span class="italic">only</span> when the following conditions are true:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>An <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> statement attempts to use a block that contains sufficient free space to contain a new row piece.
                                 </p>
                              </li>
                              <li>
                                 <p>The free space is fragmented so that the row piece cannot be inserted in a contiguous section of the block.</p>
                              </li>
                           </ul>
                           <p>After coalescing, the amount of free space is identical to the amount before the operation, but the space is now contiguous. <a href="logical-storage-structures.html#GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9__BABIIACD">Figure 12-12</a> shows a data block after space has been coalesced.
                           </p>
                           <div class="figure" id="GUID-D25D436C-02D2-4AA5-B14A-7A7FA2C665C9__BABIIACD">
                              <p class="titleinfigure">Figure 12-12 Data Block After Coalescing Free Space</p><img src="img/cncpt211.gif" alt="Description of Figure 12-12 follows" title="Description of Figure 12-12 follows" longdesc="img_text/cncpt211.html"><br><a href="img_text/cncpt211.html">Description of "Figure 12-12 Data Block After Coalescing Free Space"</a></div>
                           <!-- class="figure" -->
                           <p>Oracle Database performs coalescing only in the preceding situations because otherwise performance would decrease because of the continuous coalescing of the free space in data blocks.</p>
                        </div>
                     </div>
                  </div><a id="CNCPT89017"></a><a id="CNCPT89167"></a><a id="CNCPT1055"></a><div class="props_rev_3"><a id="GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" name="GUID-49D4E586-57BF-4310-9EE9-2DD54108E651"></a><h5 id="CNCPT-GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" class="sect5">Chained and Migrated Rows </h5>
                     <div>
                        <p>Oracle Database uses chaining and migration to manage rows that are too large to fit into a single block.</p>
                        <p>The following situations are possible:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The row is too large to fit into one data block when it is first inserted. </p>
                              <p>In <a href="glossary.html#GUID-0F47A5E4-2B7F-4101-AA04-E9641F71AC7F"><span class="xrefglossterm">row chaining</span></a>, Oracle Database stores the data for the row in a chain of one or more data blocks reserved for the segment. Row chaining most often occurs with large rows. Examples include rows that contain a column of data type <code class="codeph">LONG</code> or <code class="codeph">LONG RAW</code> , or a row with a huge number of columns. Row chaining in these cases is unavoidable.
                              </p>
                           </li>
                           <li>
                              <p>A row that originally fit into one data block is updated so that the overall row length increases, but insufficient free space exists to hold the updated row. </p>
                              <p>In <a href="glossary.html#GUID-CF217247-B358-44B4-9AB6-7FC1557230B7"><span class="xrefglossterm">row migration</span></a>, Oracle Database moves the entire row to a new data block, assuming the row can fit in a new block. The original row piece of a migrated row contains a pointer or "forwarding address" to the new block containing the migrated row. The rowid of a migrated row does not change.
                              </p>
                           </li>
                           <li>
                              <p>A row has more than 255 columns.</p>
                              <p>Oracle Database can only store 255 columns in a row piece. Thus, if you insert a row into a table that has 1000 columns, then the database creates 4 row pieces, typically chained over multiple blocks.</p>
                           </li>
                        </ul>
                        <p><a href="logical-storage-structures.html#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651__BABFBDIH">Figure 12-13</a> depicts the insertion of a large row in a data block. The row is too large for the left block, so the database chains the row by placing the first row piece in the left block and the second row piece in the right block.
                        </p>
                        <div class="figure" id="GUID-49D4E586-57BF-4310-9EE9-2DD54108E651__BABFBDIH">
                           <p class="titleinfigure">Figure 12-13 Row Chaining</p><img src="img/cncpt316.gif" alt="Description of Figure 12-13 follows" title="Description of Figure 12-13 follows" longdesc="img_text/cncpt316.html"><br><a href="img_text/cncpt316.html">Description of "Figure 12-13 Row Chaining"</a></div>
                        <!-- class="figure" -->
                        <p><a href="logical-storage-structures.html#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651__BABBGEGE">Figure 12-14</a>, the left block contains a row that is updated so that the row is now too large for the block. The database moves the entire row to the right block and leaves a pointer to the migrated row in the left block. 
                        </p>
                        <div class="figure" id="GUID-49D4E586-57BF-4310-9EE9-2DD54108E651__BABBGEGE">
                           <p class="titleinfigure">Figure 12-14 Row Migration</p><img src="img/cncpt306.gif" alt="Description of Figure 12-14 follows" title="Description of Figure 12-14 follows" longdesc="img_text/cncpt306.html"><br><a href="img_text/cncpt306.html">Description of "Figure 12-14 Row Migration"</a></div>
                        <!-- class="figure" -->
                        <p>When a row is chained or migrated, the I/O needed to retrieve the data increases. This situation results because Oracle Database must scan multiple blocks to retrieve the information for the row. For example, if the database performs one I/O to read an index and one I/O to read a nonmigrated table row, then an additional I/O is required to obtain the data for a migrated row.</p>
                        <p>The Segment Advisor, which can be run both manually and automatically, is an Oracle Database component that identifies segments that have space available for reclamation. The advisor can offer advice about objects that have significant free space or too many chained rows.</p>
                        <div class="infoboxnotealso" id="GUID-49D4E586-57BF-4310-9EE9-2DD54108E651__GUID-05939B4D-BB1C-459E-B3A6-0F1830B8E19B">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-37546C88-24EE-47BE-8662-A9CED99BB90F" title="The database stores rows in data blocks. Each row of a table containing data for less than 256 columns is contained in one or more row pieces.">Row Storage</a>"</span> and <span class="q">"<a href="tables-and-table-clusters.html#GUID-83BDB6CC-8CE1-44FE-9BCB-B018AC316FFC" title="A rowid is effectively a 10-byte physical address of a row.">Rowids of Row Pieces</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-space-for-schema-objects.html#ADMIN01401" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to reclaim wasted space
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/instance-tuning-using-performance-views.html#GUID-07836086-3C62-4A4A-8392-25A8C34C4A66" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn about reducing chained and migrated rows
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89223"></a><div class="props_rev_3"><a id="GUID-82531CDF-407E-4D70-AFD0-8E8929B72783" name="GUID-82531CDF-407E-4D70-AFD0-8E8929B72783"></a><h4 id="CNCPT-GUID-82531CDF-407E-4D70-AFD0-8E8929B72783" class="sect4">Overview of Index Blocks</h4>
                  <div>
                     <p>An <span class="bold">index block</span> is a special type of data block that manages space differently from table blocks. Oracle Database uses index blocks to manage the logical storage space in an index.
                     </p>
                  </div><a id="CNCPT89328"></a><div class="props_rev_3"><a id="GUID-84F0C09B-222C-4CA6-85F2-807445844E51" name="GUID-84F0C09B-222C-4CA6-85F2-807445844E51"></a><h5 id="CNCPT-GUID-84F0C09B-222C-4CA6-85F2-807445844E51" class="sect5">Types of Index Blocks</h5>
                     <div>
                        <p>An index contains a root block, branch blocks, and leaf blocks.</p>
                        <p>The block types are defined as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Root block</p>
                              <p>This block identifies the entry point into the index.</p>
                           </li>
                           <li>
                              <p>Branch blocks</p>
                              <p>The databases navigates through branch blocks when searching for an index key.</p>
                           </li>
                           <li>
                              <p>Leaf blocks</p>
                              <p>These blocks contain the indexed key values rowids that point to the associated rows. The leaf blocks store key values in sorted order so that the database can search efficiently for all rows in a range of key values.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89454"></a><div class="props_rev_3"><a id="GUID-223F3DC7-0103-460E-A8E7-B4A44A39BAD8" name="GUID-223F3DC7-0103-460E-A8E7-B4A44A39BAD8"></a><h5 id="CNCPT-GUID-223F3DC7-0103-460E-A8E7-B4A44A39BAD8" class="sect5">Storage of Index Entries</h5>
                     <div>
                        <p>Index entries are stored in index blocks in the same way as table rows in a data block The index entries in the block portion are not stored in binary order, but in a heap.</p>
                        <p>The database manages the row directory in an index block differently from the directory in a data block. The entries in the row directory (not the entries in the body of the index block) are ordered by key value. For example, in the row directory, the directory entry for index key <code class="codeph">000000</code> precedes the directory entry for index key <code class="codeph">111111</code>, and so on.
                        </p>
                        <p>The ordering of entries in the row directory improves the efficiency of index scans. In a range scan, the database must read all the index keys specified in the range. The database traverses the branch blocks to identify the leaf block that contains the first key. Because entries in the row directory are sorted, the database can use a binary search to find the first index key in the range, and then progress sequentially through the entries in the row directory until it finds the last key. In this way, the database avoids reading all the keys in the leaf block body.</p>
                        <div class="infoboxnotealso" id="GUID-223F3DC7-0103-460E-A8E7-B4A44A39BAD8__GUID-F226AAF1-C53A-4A11-9387-638A39741162">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="logical-storage-structures.html#GUID-D12A9269-54D8-4765-9E92-CEDDC98F1468" title="Oracle Database uses the block overhead to manage the block itself. The block overhead is not available to store user data.">Data Block Overhead</a>"</span></p>
                        </div>
                     </div>
                  </div><a id="CNCPT89224"></a><div class="props_rev_3"><a id="GUID-B32BF8EA-E51B-4F69-BEEF-53902AE04A9D" name="GUID-B32BF8EA-E51B-4F69-BEEF-53902AE04A9D"></a><h5 id="CNCPT-GUID-B32BF8EA-E51B-4F69-BEEF-53902AE04A9D" class="sect5">Reuse of Slots in an Index Block</h5>
                     <div>
                        <p>The database can reuse space within an index block.</p>
                        <p>For example, an application may insert a value into a column and then delete the value. When a row requires space, the database can reuse the index slot formerly occupied by the deleted value.</p>
                        <p>An index block usually has many more rows than a heap-organized table block. The ability to store many rows in a single index block makes it easier for the database to maintain an index because it avoids frequent splits of the block to store new data.</p>
                        <p>An index cannot coalesce itself, although you can manually coalesce it with an <code class="codeph">ALTER INDEX</code> statement with the <code class="codeph">REBUILD</code> or <code class="codeph">COALESCE</code> options. For example, if you populate a column with values <code class="codeph">1</code> to <code class="codeph">500000</code>, and if you then delete the rows that contain even numbers, then the index will contain 250,000 empty slots. The database reuses a slot only if it can insert data that fits into an index block that contains an empty slot.
                        </p>
                     </div>
                  </div><a id="CNCPT89165"></a><a id="CNCPT89166"></a><a id="CNCPT89225"></a><div class="props_rev_3"><a id="GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F" name="GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F"></a><h5 id="CNCPT-GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F" class="sect5">Coalescing an Index Block</h5>
                     <div>
                        <p>Index coalescing compacts existing index data in place and, if the reorganization frees blocks, leaves the free blocks in the index structure. Thus, coalescing does not release index blocks for other uses or cause the index to reallocate blocks. </p>
                        <p>Oracle Database does not automatically compact the index: you must run an <code class="codeph">ALTER INDEX</code> statement with the <code class="codeph">REBUILD</code> or <code class="codeph">COALESCE</code> options.
                        </p>
                        <p><a href="logical-storage-structures.html#GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__BABIBCII">Figure 12-15</a> shows an index of the <code class="codeph">employees.department_id</code> column before the index is coalesced. The first three leaf blocks are only partially full, as indicated by the gray fill lines.
                        </p>
                        <div class="figure" id="GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__BABIBCII">
                           <p class="titleinfigure">Figure 12-15 Index Before Coalescing</p><img src="img/cncpt294.gif" alt="Description of Figure 12-15 follows" title="Description of Figure 12-15 follows" longdesc="img_text/cncpt294.html"><br><a href="img_text/cncpt294.html">Description of "Figure 12-15 Index Before Coalescing"</a></div>
                        <!-- class="figure" -->
                        <p><a href="logical-storage-structures.html#GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__BABJACFA">Figure 12-16</a> shows the index in <a href="logical-storage-structures.html#GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__BABIBCII">Figure 12-15</a> after the index has been coalesced. The first two leaf blocks are now full, as indicated by the gray fill lines, and the third leaf block has been freed.
                        </p>
                        <div class="figure" id="GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__BABJACFA">
                           <p class="titleinfigure">Figure 12-16 Index After Coalescing</p><img src="img/cncpt295.gif" alt="Description of Figure 12-16 follows" title="Description of Figure 12-16 follows" longdesc="img_text/cncpt295.html"><br><a href="img_text/cncpt295.html">Description of "Figure 12-16 Index After Coalescing"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F__GUID-BD1104F3-3669-429B-8870-13E10A12A61C">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-indexes.html#ADMIN11720" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to coalesce and rebuild indexes
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/COALESCE.html#SQLRF00617" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">COALESCE</code> statement
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT303"></a><div class="props_rev_3"><a id="GUID-E3D8E030-A056-40AC-9B7E-8C957E28EE75" name="GUID-E3D8E030-A056-40AC-9B7E-8C957E28EE75"></a><h3 id="CNCPT-GUID-E3D8E030-A056-40AC-9B7E-8C957E28EE75" class="sect3">Overview of Extents</h3>
               <div>
                  <p>An extent is a unit of database storage made up of logically contiguous data blocks. Data blocks can be physically spread out on disk because of RAID striping and file system implementations.</p>
               </div><a id="CNCPT89018"></a><a id="CNCPT89019"></a><a id="CNCPT1060"></a><div class="props_rev_3"><a id="GUID-C205981E-182A-466D-B151-090455F9ECE7" name="GUID-C205981E-182A-466D-B151-090455F9ECE7"></a><h4 id="CNCPT-GUID-C205981E-182A-466D-B151-090455F9ECE7" class="sect4">Allocation of Extents</h4>
                  <div>
                     <p>By default, the database allocates an initial extent for a data segment when the segment is created. An extent is always contained in one data file.</p>
                     <p>Although no data has been added to the segment, data blocks in the initial extent are reserved for this segment exclusively. The first data block of every segment contains a directory of the extents in the segment. <a href="logical-storage-structures.html#GUID-C205981E-182A-466D-B151-090455F9ECE7__BABFIFCF">Figure 12-17</a> shows the initial extent in a segment in a data file that previously contained no data.
                     </p>
                     <div class="figure" id="GUID-C205981E-182A-466D-B151-090455F9ECE7__BABFIFCF">
                        <p class="titleinfigure">Figure 12-17 Initial Extent of a Segment</p><img src="img/cncpt274.gif" alt="Description of Figure 12-17 follows" title="Description of Figure 12-17 follows" longdesc="img_text/cncpt274.html"><br><a href="img_text/cncpt274.html">Description of "Figure 12-17 Initial Extent of a Segment"</a></div>
                     <!-- class="figure" -->
                     <p>If the initial extent become full, and if more space is required, then the database automatically allocates an incremental extent for this segment. An incremental extent is a subsequent extent created for the segment.</p>
                     <p>The allocation algorithm depends on whether the tablespace is locally managed or dictionary-managed. In the locally managed case, the database searches the bitmap of a data file for adjacent free blocks. If the data file has insufficient space, then the database looks in another data file. Extents for a segment are always in the same tablespace but may be in different data files.</p>
                     <p><a href="logical-storage-structures.html#GUID-C205981E-182A-466D-B151-090455F9ECE7__BABGHIED">Figure 12-18</a> shows that the database can allocate extents for a segment in any data file in the tablespace. For example, the segment can allocate the initial extent in <code class="codeph">users01.dbf</code>, allocate the first incremental extent in <code class="codeph">users02.dbf</code>, and then allocate the next extent in <code class="codeph">users01.dbf</code>.
                     </p>
                     <div class="figure" id="GUID-C205981E-182A-466D-B151-090455F9ECE7__BABGHIED">
                        <p class="titleinfigure">Figure 12-18 Incremental Extent of a Segment</p><img src="img/cncpt278.gif" alt="Description of Figure 12-18 follows" title="Description of Figure 12-18 follows" longdesc="img_text/cncpt278.html"><br><a href="img_text/cncpt278.html">Description of "Figure 12-18 Incremental Extent of a Segment"</a></div>
                     <!-- class="figure" -->
                     <p>The blocks of a newly allocated extent, although they were free, may not be empty of old data. In ASSM, Oracle Database formats the blocks of a newly allocated extent when it starts using the extent, but only as needed.</p>
                     <div class="infoboxnote" id="GUID-C205981E-182A-466D-B151-090455F9ECE7__GUID-BD8A07EE-0F3A-4312-A155-19E0ECB47541">
                        <p class="notep1">Note:</p>
                        <p>This section applies to serial operations, in which one <a href="glossary.html#GUID-E660AC1C-B704-4DC1-A35A-DB49EFB34F4A"><span class="xrefglossterm">server process</span></a> parses and runs a statement. The database allocates extents differently in parallel SQL statements, which entail multiple server processes.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C205981E-182A-466D-B151-090455F9ECE7__GUID-3F889902-0B05-4902-8642-BA682F08106A">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" title="To manage space, Oracle Database tracks the state of blocks in the segment. The high water mark (HWM) is the point in a segment beyond which data blocks are unformatted and have never been used.">Segment Space and the High Water Mark</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-tables.html#ADMIN11660" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manually allocate extents
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT1063"></a><div class="props_rev_3"><a id="GUID-0385358A-7F7F-4151-AAC4-F49B3B123852" name="GUID-0385358A-7F7F-4151-AAC4-F49B3B123852"></a><h4 id="CNCPT-GUID-0385358A-7F7F-4151-AAC4-F49B3B123852" class="sect4">Deallocation of Extents</h4>
                  <div>
                     <p>In general, the extents of a user segment do not return to the tablespace unless you drop the object using a <code class="codeph">DROP</code> statement.
                     </p>
                     <p>For example, if you delete all rows in a table, then the database does not reclaim the data blocks for use by other objects in the tablespace. You can also drop the segment using the <code class="codeph">DBMS_SPACE_ADMIN</code> package.
                     </p>
                     <div class="infoboxnote" id="GUID-0385358A-7F7F-4151-AAC4-F49B3B123852__GUID-BC034FC0-40D1-47A6-9F08-33C849206445">
                        <p class="notep1">Note:</p>
                        <p>In an undo segment, Oracle Database periodically deallocates one or more extents if it has the <code class="codeph">OPTIMAL</code> size specified or if the database is in <a href="glossary.html#GUID-31B8DD86-BD6D-446D-A35D-B5BF3654DF9E"><span class="xrefglossterm">automatic undo management mode</span></a>.
                        </p>
                     </div>
                     <p>In some circumstances, you can manually deallocate space. The Oracle Segment Advisor helps determine whether an object has space available for reclamation based on the level of fragmentation in the object. The following techniques can free extents:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use an online segment shrink to reclaim fragmented space in a segment. Segment shrink is an online, in-place operation. In general, data compaction leads to better cache utilization and requires fewer blocks to be read in a <a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a>.
                           </p>
                        </li>
                        <li>
                           <p>Move the data of a nonpartitioned table or table partition into a new segment, and optionally into a different tablespace for which you have quota.</p>
                        </li>
                        <li>
                           <p>Rebuild or coalesce the index.</p>
                        </li>
                        <li>
                           <p>Truncate a table or table cluster, which removes all rows. By default, Oracle Database deallocates all space used by the removed rows except that specified by the <code class="codeph">MINEXTENTS</code> storage parameter. Starting in <span>Oracle Database 11g</span> Release 2 (11.2.0.2), you can also use <code class="codeph">TRUNCATE</code> with the <code class="codeph">DROP ALL STORAGE</code> option to drop entire segments.
                           </p>
                        </li>
                        <li>
                           <p>Deallocate unused space, which frees the unused space at the high water mark end of the database segment and makes the space available for other segments in the tablespace.</p>
                        </li>
                     </ul>
                     <p>When extents are freed, Oracle Database modifies the bitmap in the data file for locally managed tablespaces to reflect the regained extents as available space. Any data in the blocks of freed extents becomes inaccessible.</p>
                     <div class="infoboxnotealso" id="GUID-0385358A-7F7F-4151-AAC4-F49B3B123852__GUID-0D623B4B-15C0-4A34-AFA7-2841291B7D12">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="logical-storage-structures.html#GUID-84CF442F-B8CB-4BFA-9878-743F39EBB48F" title="Index coalescing compacts existing index data in place and, if the reorganization frees blocks, leaves the free blocks in the index structure. Thus, coalescing does not release index blocks for other uses or cause the index to reallocate blocks.">Coalescing an Index Block</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="logical-storage-structures.html#GUID-29C6EBF7-64AB-468E-A8CD-6ED36677D604" title="An undo tablespace is a locally managed tablespace reserved for system-managed undo data.">Undo Tablespaces</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" title="To manage space, Oracle Database tracks the state of blocks in the segment. The high water mark (HWM) is the point in a segment beyond which data blocks are unformatted and have never been used.">Segment Space and the High Water Mark</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-space-for-schema-objects.html#ADMIN01401" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to reclaim segment space
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT1061"></a><div class="props_rev_3"><a id="GUID-38EC39DC-D9A2-41AD-8AD4-0E1A8A91FFED" name="GUID-38EC39DC-D9A2-41AD-8AD4-0E1A8A91FFED"></a><h4 id="CNCPT-GUID-38EC39DC-D9A2-41AD-8AD4-0E1A8A91FFED" class="sect4">Storage Parameters for Extents </h4>
                  <div>
                     <p>Every segment is defined by storage parameters expressed in terms of extents. These parameters control how Oracle Database allocates free space for a segment.</p>
                     <p>The storage settings are determined in the following order of precedence, with settings higher on the list overriding settings lower on the list:</p>
                     <ol>
                        <li>
                           <p>Segment storage clause</p>
                        </li>
                        <li>
                           <p>Tablespace storage clause</p>
                        </li>
                        <li>
                           <p>Oracle Database default</p>
                        </li>
                     </ol>
                     <p>A locally managed tablespace can have either uniform extent sizes or variable extent sizes determined automatically by the system:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For uniform extents, you can specify an extent size or use the default size of 1 MB. All extents in the tablespace are of this size. Locally managed temporary tablespaces can only use this type of allocation.</p>
                        </li>
                        <li>
                           <p>For automatically allocated extents, Oracle Database determines the optimal size of additional extents.</p>
                        </li>
                     </ul>
                     <p>For locally managed tablespaces, some storage parameters cannot be specified at the tablespace level. However, you can specify these parameters at the segment level. In this case, the database uses all parameters together to compute the initial size of the segment. Internal algorithms determine the subsequent size of each extent.</p>
                     <div class="infoboxnotealso" id="GUID-38EC39DC-D9A2-41AD-8AD4-0E1A8A91FFED__GUID-8172B6A1-E252-4C62-A0B6-B5DF5819E855">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../admin/managing-tablespaces.html#ADMIN11361" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about extent management considerations when creating a locally managed tablespace
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/storage_clause.html#SQLRF30013" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about options in the storage clause
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT304"></a><div class="props_rev_3"><a id="GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" name="GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866"></a><h3 id="CNCPT-GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" class="sect3">Overview of Segments</h3>
               <div>
                  <p>A segment is a set of extents that contains all the data for a logical storage structure within a tablespace. </p>
                  <p>For example, Oracle Database allocates one or more extents to form the data segment for a table. The database also allocates one or more extents to form the index segment for an index on a table.</p>
                  <p>Oracle Database manages segment space automatically or manually. This section assumes the use of ASSM.</p>
                  <div class="infoboxnotealso" id="GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866__GUID-0491FBDE-5809-496C-B180-4252378079D2">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="logical-storage-structures.html#GUID-5E81D8A9-2D4C-4991-9D64-B23DD476E22F" title="Oracle Database must use logical space management to track and allocate the extents in a tablespace.">Logical Space Management</a>"</span> to learn more about ASSM
                     </p>
                  </div>
               </div><a id="CNCPT1070"></a><div class="props_rev_3"><a id="GUID-EFB292CB-87EA-42AA-808C-BD85E540BACC" name="GUID-EFB292CB-87EA-42AA-808C-BD85E540BACC"></a><h4 id="CNCPT-GUID-EFB292CB-87EA-42AA-808C-BD85E540BACC" class="sect4">User Segments</h4>
                  <div>
                     <p>A single data segment in a database stores the data for one user object.</p>
                     <p>There are different types of segments. Examples of user segments include:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Table, table partition, or table cluster</p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-A85748CE-C4D4-43ED-BD49-29AFC4AD3A02"><span class="xrefglossterm">LOB</span></a> or LOB partition
                           </p>
                        </li>
                        <li>
                           <p>Index or index partition</p>
                        </li>
                     </ul>
                     <p>Each nonpartitioned object and object partition is stored in its own segment. For example, if an index has five partitions, then five segments contain the index data.</p>
                  </div><a id="CNCPT89020"></a><a id="CNCPT89021"></a><a id="CNCPT998"></a><div class="props_rev_3"><a id="GUID-733C09AF-70D1-4D53-A34A-5521115A596E" name="GUID-733C09AF-70D1-4D53-A34A-5521115A596E"></a><h5 id="CNCPT-GUID-733C09AF-70D1-4D53-A34A-5521115A596E" class="sect5">User Segment Creation</h5>
                     <div>
                        <p>By default, the database uses deferred segment creation to update only database metadata when creating tables, indexes, and partitions.</p>
                        <p>When a user inserts the first row into a table or partition, the database creates segments for the table or partition, its LOB columns, and its indexes. Deferred segment creation avoids using database resources unnecessarily. For example, installation of an application can create thousands of objects, consuming significant disk space. Many of these objects may never be used.</p>
                        <p>The <code class="codeph">DBMS_SPACE_ADMIN</code> package manages segments for empty objects. You can use this PL/SQL package to do the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Manually materialize segments for empty tables or partitions that do not have segments created</p>
                           </li>
                           <li>
                              <p>Remove segments from empty tables or partitions that currently have an empty segment allocated</p>
                           </li>
                        </ul>
                        <p>To best illustrate the relationship between object creation and segment creation, assume that deferred segment creation is disabled. You create a table as follows:</p><pre class="pre codeblock"><code>CREATE TABLE test_table (my_column NUMBER);
</code></pre><p>As shown in <a href="logical-storage-structures.html#GUID-733C09AF-70D1-4D53-A34A-5521115A596E__BABCHBJC">Figure 12-19</a>, the database creates one segment for the table.
                        </p>
                        <div class="figure" id="GUID-733C09AF-70D1-4D53-A34A-5521115A596E__BABCHBJC">
                           <p class="titleinfigure">Figure 12-19 Creation of a User Segment</p><img src="img/cncpt246.gif" alt="Description of Figure 12-19 follows" title="Description of Figure 12-19 follows" longdesc="img_text/cncpt246.html"><br><a href="img_text/cncpt246.html">Description of "Figure 12-19 Creation of a User Segment"</a></div>
                        <!-- class="figure" -->
                        <p>When you create a table with a <a href="glossary.html#GUID-8640EFA5-276C-4812-A078-1F21F55F4200"><span class="xrefglossterm">primary key</span></a> or unique key, Oracle Database automatically creates an index for this key. Again assume that deferred segment creation is disabled. You create a table as follows:
                        </p><pre class="pre codeblock"><code>CREATE TABLE lob_table (my_column NUMBER PRIMARY KEY, clob_column CLOB);
</code></pre><p><a href="logical-storage-structures.html#GUID-733C09AF-70D1-4D53-A34A-5521115A596E__BABJJADA">Figure 12-20</a> shows that the data for <code class="codeph">lob_table</code> is stored in one segment, while the implicitly created index is in a different segment. Also, the CLOB data is stored in its own segment, as is its associated CLOB index. Thus, the <code class="codeph">CREATE TABLE</code> statement results in the creation of <span class="italic">four</span> different segments.
                        </p>
                        <div class="figure" id="GUID-733C09AF-70D1-4D53-A34A-5521115A596E__BABJJADA">
                           <p class="titleinfigure">Figure 12-20 Multiple Segments</p><img src="img/cncpt245.gif" alt="Description of Figure 12-20 follows" title="Description of Figure 12-20 follows" longdesc="img_text/cncpt245.html"><br><a href="img_text/cncpt245.html">Description of "Figure 12-20 Multiple Segments"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnote" id="GUID-733C09AF-70D1-4D53-A34A-5521115A596E__GUID-9DA417BE-F333-4082-A166-2EAE5B4EBDDA">
                           <p class="notep1">Note:</p>
                           <p>The segments of a table and the index for this table do not have to occupy the same tablespace.</p>
                        </div>
                        <p>The database allocates one or more extents when a segment is created. Storage parameters for the object determine how the extents for each segment are allocated. The parameters affect the efficiency of data retrieval and storage for the data segment associated with the object.</p>
                        <div class="infoboxnotealso" id="GUID-733C09AF-70D1-4D53-A34A-5521115A596E__GUID-87989EE9-24FD-4BB2-9919-FEEC758DC07E">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p> <span class="q">"<a href="concepts-for-database-developers.html#GUID-3C50EAB8-FC39-4BB3-B680-4EACCE49E866" title="An internal LOB stores data in the database itself rather than in external files.">Internal LOBs</a>"</span></p>
                              </li>
                              <li>
                                 <p> <span class="q">"<a href="logical-storage-structures.html#GUID-38EC39DC-D9A2-41AD-8AD4-0E1A8A91FFED" title="Every segment is defined by storage parameters expressed in terms of extents. These parameters control how Oracle Database allocates free space for a segment.">Storage Parameters for Extents</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-tables.html#ADMIN13319" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage deferred segment creation
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE TABLE</code> syntax
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1072"></a><div class="props_rev_3"><a id="GUID-BFC69020-DECA-4F2D-8BED-57A612A4E7C8" name="GUID-BFC69020-DECA-4F2D-8BED-57A612A4E7C8"></a><h4 id="CNCPT-GUID-BFC69020-DECA-4F2D-8BED-57A612A4E7C8" class="sect4">Temporary Segments</h4>
                  <div>
                     <p>When processing a query, Oracle Database often requires temporary workspace for intermediate stages of SQL statement execution.</p>
                     <p>Typical operations that may require a <a href="glossary.html#GUID-12B9FBED-5452-4D45-A43A-B33AB6DE9390"><span class="xrefglossterm">temporary segment</span></a> include sorting, <a href="glossary.html#GUID-90B8C458-65EB-4868-9CC5-175955A7AD91"><span class="xrefglossterm">hashing</span></a>, and merging bitmaps. While creating an index, Oracle Database also places index segments into temporary segments and then converts them into permanent segments when the index is complete.
                     </p>
                     <p>Oracle Database does not create a temporary segment if an operation can be performed in memory. However, if memory use is not possible, then the database automatically allocates a temporary segment on disk.</p>
                  </div><a id="CNCPT1076"></a><div class="props_rev_3"><a id="GUID-2F77DB80-8AAD-468A-AA34-D1230009AEAC" name="GUID-2F77DB80-8AAD-468A-AA34-D1230009AEAC"></a><h5 id="CNCPT-GUID-2F77DB80-8AAD-468A-AA34-D1230009AEAC" class="sect5">Allocation of Temporary Segments for Queries</h5>
                     <div>
                        <p>Oracle Database allocates temporary segments for queries as needed during a user session and drops them when the query completes. Changes to temporary segments are not recorded in the online redo log, except for space management operations on the temporary segment.</p>
                        <p>The database creates temporary segments in the temporary tablespace assigned to the user. The default storage characteristics of the tablespace determine the characteristics of the extents in the temporary segment. Because allocation and deallocation of temporary segments occurs frequently, the best practice is to create at least one special tablespace for temporary segments. The database distributes I/O across disks and avoids fragmenting <code class="codeph">SYSTEM</code> and other tablespaces with temporary segments.
                        </p>
                        <div class="infoboxnote" id="GUID-2F77DB80-8AAD-468A-AA34-D1230009AEAC__GUID-12611FC6-2178-4EA0-8118-0C4B036783EE">
                           <p class="notep1">Note:</p>
                           <p>When <code class="codeph">SYSTEM</code> is locally managed, you must define a default temporary tablespace at database creation. A locally managed <code class="codeph">SYSTEM</code> tablespace cannot be used for default temporary storage.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-2F77DB80-8AAD-468A-AA34-D1230009AEAC__GUID-D6307853-A80F-464F-A572-E8B6C41F96B8">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li><span class="q">"<a href="physical-storage-structures.html#GUID-47557C86-E551-46B5-B28E-28D6C500694E" title="The most crucial structure for recovery is the online redo log, which consists of two or more preallocated files that store changes to the database as they occur. The online redo log records changes to the data files.">Overview of the Online Redo Log</a>"</span></li>
                              <li>
                                 <p><a href="../admin/managing-tablespaces.html#ADMIN11366" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create temporary tablespaces
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-TABLESPACE.html#SQLRF01403" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE TEMPORARY TABLESPACE</code> syntax and semantics
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1077"></a><div class="props_rev_3"><a id="GUID-98855434-8F27-4809-990C-5F8DC25AD5A9" name="GUID-98855434-8F27-4809-990C-5F8DC25AD5A9"></a><h5 id="CNCPT-GUID-98855434-8F27-4809-990C-5F8DC25AD5A9" class="sect5">Allocation of Segments for Temporary Tables and Indexes</h5>
                     <div>
                        <p>Oracle Database can allocate temporary segments for temporary tables and their indexes. </p>
                        <p>Temporary tables hold data that exists only for the duration of a transaction or session. Each session accesses only the extents allocated for itself and cannot access extents allocated for other sessions.</p>
                        <p>Oracle Database allocates segments for a global temporary table when the first <code class="codeph">INSERT</code> into the table occurs, and for a private temporary table only when needed. The insertion can occur explicitly or because of <code class="codeph">CREATE TABLE AS SELECT</code>. The database allocates the segments for the table and its indexes, creates the root page for the indexes, and allocates any <code class="codeph">LOB</code> segments.
                        </p>
                        <p>A temporary tablespace of the current user allocates segments for a temporary table. For example, the temporary tablespace assigned to <code class="codeph">user1</code> is <code class="codeph">temp1</code> and the temporary tablespace assigned to <code class="codeph">user2</code> is <code class="codeph">temp2</code>. In this case, <code class="codeph">user1</code> stores temporary data in the <code class="codeph">temp1</code> segments, while <code class="codeph">user2</code> stores temporary data in the <code class="codeph">temp2</code> segments.
                        </p>
                        <div class="infoboxnotealso" id="GUID-98855434-8F27-4809-990C-5F8DC25AD5A9__GUID-FA084362-E202-4875-8762-F4E630B246F9">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-23B23DCF-7482-4585-9C63-AC073C5DE224" title="A temporary table holds data that exists only for the duration of a transaction or session.">Overview of Temporary Tables</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-tables.html#ADMIN-GUID-A48CB362-FC15-4A26-8386-906A55F6788E" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to create temporary tables
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT305"></a><div class="props_rev_3"><a id="GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE" name="GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE"></a><h4 id="CNCPT-GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE" class="sect4">Undo Segments</h4>
                  <div>
                     <p>Oracle Database maintains records of the actions of transactions, collectively known as <strong class="term">undo data</strong>.
                     </p>
                     <p>Oracle Database uses undo data to do the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Roll back an <a href="glossary.html#GUID-6A310BE1-83AB-4C87-ABE1-09CD847A31FB"><span class="xrefglossterm">active transaction</span></a></p>
                        </li>
                        <li>
                           <p>Recover a terminated transaction</p>
                        </li>
                        <li>
                           <p>Provide <a href="glossary.html#GUID-A2D92FBD-9C36-432E-A44F-0462DB2E5527"><span class="xrefglossterm">read consistency</span></a></p>
                        </li>
                        <li>
                           <p>Perform some logical flashback operations</p>
                        </li>
                     </ul>
                     <p>Oracle Database stores undo data inside the database rather than in external logs. Undo data is stored in blocks that are updated just like data blocks, with changes to these blocks generating redo records. In this way, Oracle Database can efficiently access undo data without needing to read external logs.</p>
                     <p>Undo data for permanent objects is stored in an <a href="glossary.html#GUID-78A7FBF2-2EB5-4BD6-AECC-D61A5AEF1158"><span class="xrefglossterm">undo tablespace</span></a>. Oracle Database provides a fully automated mechanism, known as <a href="glossary.html#GUID-31B8DD86-BD6D-446D-A35D-B5BF3654DF9E"><span class="xrefglossterm">automatic undo management mode</span></a>, for managing undo segments and space in an undo tablespace.
                     </p>
                     <p>The database separates undo data into two streams. A temporary undo stream encapsulates only undo records generated by changes to temporary objects, whereas a permanent undo stream encapsulates only undo records for permanent objects. The database manages temporary and permanent undo independently. Undo separation decreases storage and enhances performance by doing the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Enabling you to configure permanent and undo tablespace sizes that best fit the workloads for permanent and temporary tables</p>
                        </li>
                        <li>
                           <p>Reducing the size of redo written to the online redo log</p>
                        </li>
                        <li>
                           <p>Avoiding the need to back up temporary undo data</p>
                        </li>
                     </ul>
                     <p>On an Active Data Guard instance, DML on global temporary tables requires undo to be generated in temporary undo segments. </p>
                     <div class="infoboxnotealso" id="GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE__GUID-40B9DB5A-EC89-46B0-BA79-DDF150485A7C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="physical-storage-structures.html#GUID-B7EB99F2-0D79-4E22-BBB6-75191035DE8D" title="The database maintains online redo log files to protect against data loss. Specifically, after an instance failure, the online redo log files enable Oracle Database to recover committed data that it has not yet written to the data files.">Use of the Online Redo Log</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="logical-storage-structures.html#GUID-311EBE7D-F01F-4E52-9B8B-DBF84116207D" title="A temporary undo segment is an optional space management container for temporary undo data only.">Temporary Undo Segments</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-undo.html#ADMIN13740" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about temporary undo segments
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/TEMP_UNDO_ENABLED.html#REFRN10326" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">TEMP_UNDO_ENABLED</code> initialization parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89185"></a><a id="CNCPT89186"></a><a id="CNCPT89187"></a><a id="CNCPT89184"></a><div class="props_rev_3"><a id="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37" name="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37"></a><h5 id="CNCPT-GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37" class="sect5">Undo Segments and Transactions</h5>
                     <div>
                        <p>When a transaction starts, the database binds (assigns) the transaction to an undo segment, and therefore to a <span class="bold">transaction table</span>, in the current undo tablespace. In rare circumstances, if the database instance does not have a designated undo tablespace, then the transaction binds to the system undo segment.
                        </p>
                        <p>Multiple active transactions can write concurrently to the same undo segment or to different segments. For example, transactions T1 and T2 can both write to undo segment U1, or T1 can write to U1 while T2 writes to undo segment U2. </p>
                        <p>Conceptually, the extents in an undo segment form a ring. Transactions write to one undo extent, and then to the next extent in the ring, and so on in cyclical fashion. <a href="logical-storage-structures.html#GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABGAFCA">Figure 12-21</a> shows two transactions, T1 and T2, which begin writing in the third extent (E3) of an undo segment and continue writing to the fourth extent (E4).
                        </p>
                        <div class="figure" id="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABGAFCA">
                           <p class="titleinfigure">Figure 12-21 Ring of Allocated Extents in an Undo Segment </p><img src="img/cncpt328.gif" alt="Description of Figure 12-21 follows" title="Description of Figure 12-21 follows" longdesc="img_text/cncpt328.html"><br><a href="img_text/cncpt328.html">Description of "Figure 12-21 Ring of Allocated Extents in an Undo Segment "</a></div>
                        <!-- class="figure" -->
                        <p>At any given time, a transaction writes sequentially to only one extent in an undo segment, known as the <span class="italic">current extent</span> for the transaction. Multiple active transactions can write simultaneously to the same current extent or to different current extents. <a href="logical-storage-structures.html#GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABGAFCA">Figure 12-21</a> shows transactions T1 and T2 writing simultaneously to extent E3. Within an undo extent, a data block contains data for only one transaction.
                        </p>
                        <p>As the current undo extent fills, the first transaction needing space checks the availability of the next allocated extent in the ring. If the next extent does <span class="italic">not</span> contain data from an active transaction, then this extent becomes the current extent. Now all transactions that need space can write to the new current extent. In <a href="logical-storage-structures.html#GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABEHGDD">Figure 12-22</a>, when E4 is full, T1 and T2 continue writing to E1, overwriting the nonactive undo data in E1.
                        </p>
                        <div class="figure" id="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABEHGDD">
                           <p class="titleinfigure">Figure 12-22 Cyclical Use of Allocated Extents in an Undo Segment</p><img src="img/cncpt327.gif" alt="Description of Figure 12-22 follows" title="Description of Figure 12-22 follows" longdesc="img_text/cncpt327.html"><br><a href="img_text/cncpt327.html">Description of "Figure 12-22 Cyclical Use of Allocated Extents in an Undo Segment"</a></div>
                        <!-- class="figure" -->
                        <p>If the next extent <span class="italic">does</span> contain data from an active transaction, then the database must allocate a new extent. <a href="logical-storage-structures.html#GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABFECCE">Figure 12-23</a> shows a scenario in which T1 and T2 are writing to E4. When E4 fills up, the transactions cannot continue writing to E1 because E1 contains active undo entries. Therefore, the database allocates a new extent (E5) for this undo segment. The transactions continue writing to E5.
                        </p>
                        <div class="figure" id="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__BABFECCE">
                           <p class="titleinfigure">Figure 12-23 Allocation of a New Extent for an Undo Segment</p><img src="img/cncpt326.gif" alt="Description of Figure 12-23 follows" title="Description of Figure 12-23 follows" longdesc="img_text/cncpt326.html"><br><a href="img_text/cncpt326.html">Description of "Figure 12-23 Allocation of a New Extent for an Undo Segment"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-BB42D7D8-2C93-4F5B-B0C1-6361AEEF4B37__GUID-38913373-F1D6-44D8-96DB-0EA5E9C0E0A7">
                           <p class="notep1">See Also:</p>
                           <p><a href="../admin/managing-undo.html#ADMIN013" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage undo segments
                           </p>
                        </div>
                     </div>
                  </div><a id="CNCPT89188"></a><div class="props_rev_3"><a id="GUID-E99834E8-596C-49BE-99CD-B5FC39C70333" name="GUID-E99834E8-596C-49BE-99CD-B5FC39C70333"></a><h5 id="CNCPT-GUID-E99834E8-596C-49BE-99CD-B5FC39C70333" class="sect5">Transaction Rollback</h5>
                     <div>
                        <p>When a <code class="codeph">ROLLBACK</code> statement is issued, the database uses undo records to roll back changes made to the database by the uncommitted transaction.
                        </p>
                        <p>During recovery, the database rolls back any uncommitted changes applied from the online redo log to the data files. Undo records provide <a href="glossary.html#GUID-A2D92FBD-9C36-432E-A44F-0462DB2E5527"><span class="xrefglossterm">read consistency</span></a> by maintaining the before image of the data for users accessing data at the same time that another user is changing it.
                        </p>
                     </div>
                  </div><a id="CNCPT89227"></a><div class="props_rev_3"><a id="GUID-311EBE7D-F01F-4E52-9B8B-DBF84116207D" name="GUID-311EBE7D-F01F-4E52-9B8B-DBF84116207D"></a><h5 id="CNCPT-GUID-311EBE7D-F01F-4E52-9B8B-DBF84116207D" class="sect5">Temporary Undo Segments</h5>
                     <div>
                        <p>A <strong class="term">temporary undo segment</strong> is an optional space management container for temporary undo data only.
                        </p>
                        <p>Undo records for changes to temporary tables are both session-specific and useful only for read consistency and transaction rollback. Before <span>Oracle Database 12c</span>, the database always stored these records in the online redo log. Because changes to temporary objects are not logged in the online redo log, writing undo for temporary objects into temporary undo segments saves space in the online redo log and archived redo log files. The database does not log changes to the undo or changes to the temporary table, which improves performance.
                        </p>
                        <p>You can set the <code class="codeph">TEMP_UNDO_ENABLED</code> initialization parameter so that temporary tables store undo data in a temporary undo segment. When this parameter is <code class="codeph">TRUE</code>, the database allocates temporary undo segments from temporary tablespaces.
                        </p>
                        <div class="infoboxnotealso" id="GUID-311EBE7D-F01F-4E52-9B8B-DBF84116207D__GUID-316D0F49-8593-4E9A-BE11-4923EB2849E4">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-undo.html#ADMIN13740" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about temporary undo segments
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/TEMP_UNDO_ENABLED.html#REFRN10326" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">TEMP_UNDO_ENABLED</code> initialization parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89023"></a><a id="CNCPT89024"></a><a id="CNCPT89194"></a><a id="CNCPT89025"></a><a id="CNCPT89022"></a><div class="props_rev_3"><a id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" name="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE"></a><h4 id="CNCPT-GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" class="sect4">Segment Space and the High Water Mark</h4>
                  <div>
                     <p>To manage space, Oracle Database tracks the state of blocks in the segment. The <span class="bold">high water mark (HWM)</span> is the point in a segment beyond which data blocks are unformatted and have never been used.
                     </p>
                     <p>MSSM uses free lists to manage segment space. At table creation, no blocks in the segment are formatted. When a session first inserts rows into the table, the database searches the free list for usable blocks. If the database finds no usable blocks, then it preformats a group of blocks, places them on the free list, and begins inserting data into the blocks. In MSSM, a full table scan reads <span class="italic">all</span> blocks below the HWM.
                     </p>
                     <p>ASSM does not use free lists and so must manage space differently. When a session first inserts data into a table, the database formats a single bitmap block instead of preformatting a group of blocks as in MSSM. The bitmap tracks the state of blocks in the segment, taking the place of the free list. The database uses the bitmap to find free blocks and then formats each block before filling it with data. ASSM spread out inserts among blocks to avoid concurrency issues. </p>
                     <p>Every data block in an ASSM segment is in one of the following states:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Above the HWM</p>
                           <p>These blocks are unformatted and have never been used.</p>
                        </li>
                        <li>
                           <p>Below the HWM</p>
                           <p>These blocks are in one of the following states:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Allocated, but currently unformatted and unused</p>
                              </li>
                              <li>
                                 <p>Formatted and contain data</p>
                              </li>
                              <li>
                                 <p>Formatted and empty because the data was deleted</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p><a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABJIIAI">Figure 12-24</a> depicts an ASSM segment as a horizontal series of blocks. At table creation, the HWM is at the beginning of the segment on the left. Because no data has been inserted yet, all blocks in the segment are unformatted and never used.
                     </p>
                     <div class="figure" id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABJIIAI">
                        <p class="titleinfigure">Figure 12-24 HWM at Table Creation</p><img src="img/cncpt275.gif" alt="Description of Figure 12-24 follows" title="Description of Figure 12-24 follows" longdesc="img_text/cncpt275.html"><br><a href="img_text/cncpt275.html">Description of "Figure 12-24 HWM at Table Creation"</a></div>
                     <!-- class="figure" -->
                     <p>Suppose that a transaction inserts rows into the segment. The database must allocate a group of blocks to hold the rows. The allocated blocks fall below the HWM. The database formats a bitmap block in this group to hold the metadata, but does not preformat the remaining blocks in the group.</p>
                     <p>In <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABJGIBJ">Figure 12-25</a>, the blocks below the HWM are allocated, whereas blocks above the HWM are neither allocated or formatted. As inserts occur, the database can write to any block with available space. The low high water mark (low HWM) marks the point below which all blocks are known to be formatted because they either contain data or formerly contained data.
                     </p>
                     <div class="figure" id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABJGIBJ">
                        <p class="titleinfigure">Figure 12-25 HWM and Low HWM</p><img src="img/cncpt276.gif" width="371" alt="Description of Figure 12-25 follows" title="Description of Figure 12-25 follows" longdesc="img_text/cncpt276.html"><br><a href="img_text/cncpt276.html">Description of "Figure 12-25 HWM and Low HWM"</a></div>
                     <!-- class="figure" -->
                     <p>In <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__CHDBFGBB">Figure 12-26</a>, the database chooses a block between the HWM and low HWM and writes to it. The database could have just as easily chosen any other block between the HWM and low HWM, or any block below the low HWM that had available space. In <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__CHDBFGBB">Figure 12-26</a>, the blocks to either side of the newly filled block are unformatted.
                     </p>
                     <div class="figure" id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__CHDBFGBB">
                        <p class="titleinfigure">Figure 12-26 HWM and Low HWM</p><img src="img/cncpt333.gif" alt="Description of Figure 12-26 follows" title="Description of Figure 12-26 follows" longdesc="img_text/cncpt333.html"><br><a href="img_text/cncpt333.html">Description of "Figure 12-26 HWM and Low HWM"</a></div>
                     <!-- class="figure" -->
                     <p>The low HWM is important in a <a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a>. Because blocks below the HWM are formatted only when used, some blocks could be unformatted, as in <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__CHDBFGBB">Figure 12-26</a>. For this reason, the database reads the bitmap block to obtain the location of the low HWM. The database reads all blocks up to the low HWM because they are known to be formatted, and then carefully reads only the formatted blocks between the low HWM and the HWM.
                     </p>
                     <p>Assume that a new transaction inserts rows into the table, but the bitmap indicates that insufficient free space exists under the HWM. In <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABFHJIC">Figure 12-27</a>, the database advances the HWM to the right, allocating a new group of unformatted blocks.
                     </p>
                     <div class="figure" id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__BABFHJIC">
                        <p class="titleinfigure">Figure 12-27 Advancing HWM and Low HWM</p><img src="img/cncpt277.gif" alt="Description of Figure 12-27 follows" title="Description of Figure 12-27 follows" longdesc="img_text/cncpt277.html"><br><a href="img_text/cncpt277.html">Description of "Figure 12-27 Advancing HWM and Low HWM"</a></div>
                     <!-- class="figure" -->
                     <p>When the blocks between the HWM and low HWM are full, the HWM advances to the right and the low HWM advances to the location of the old HWM. As the database inserts data over time, the HWM continues to advance to the right, with the low HWM always trailing behind it. Unless you manually rebuild, truncate, or shrink the object, the HWM never retreats.</p>
                     <div class="infoboxnotealso" id="GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE__GUID-BB3B416A-0E34-495D-87FE-090FE5DA4884">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADMIN10161" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to shrink segments online
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/TRUNCATE-TABLE.html#SQLRF01707" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">TRUNCATE TABLE</code> syntax and semantics
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT89168"></a><a id="CNCPT402"></a><div class="props_rev_3"><a id="GUID-3502CA78-FBC9-4927-B455-0ECB22E53066" name="GUID-3502CA78-FBC9-4927-B455-0ECB22E53066"></a><h3 id="CNCPT-GUID-3502CA78-FBC9-4927-B455-0ECB22E53066" class="sect3">Overview of Tablespaces</h3>
               <div>
                  <p>A <span class="bold">tablespace</span> is a logical storage container for segments. Segments are database objects, such as tables and indexes, that consume storage space. At the physical level, a tablespace stores data in one or more data files or temp files.
                  </p>
                  <p>A database must have the <code class="codeph">SYSTEM</code> and <code class="codeph">SYSAUX</code> tablespaces. The following figure shows the tablespaces in a typical database. The following sections describe the tablespace types.
                  </p>
                  <div class="figure" id="GUID-3502CA78-FBC9-4927-B455-0ECB22E53066__BABBBFDJ">
                     <p class="titleinfigure">Figure 12-28 Tablespaces</p><img src="img/cncpt319.gif" alt="Description of Figure 12-28 follows" title="Description of Figure 12-28 follows" longdesc="img_text/cncpt319.html"><br><a href="img_text/cncpt319.html">Description of "Figure 12-28 Tablespaces"</a></div>
                  <!-- class="figure" -->
               </div><a id="CNCPT89026"></a><div class="props_rev_3"><a id="GUID-BD3962AF-D4E1-47C0-96CD-0A56807D7850" name="GUID-BD3962AF-D4E1-47C0-96CD-0A56807D7850"></a><h4 id="CNCPT-GUID-BD3962AF-D4E1-47C0-96CD-0A56807D7850" class="sect4">Permanent Tablespaces</h4>
                  <div>
                     <p>A <strong class="term">permanent tablespace</strong> groups persistent schema objects. The segments for objects in the tablespace are stored physically in data files.
                     </p>
                     <p>Each database user is assigned a default permanent tablespace. A very small database may need only the default <code class="codeph">SYSTEM</code> and <code class="codeph">SYSAUX</code> tablespaces. However, Oracle recommends that you create at least one tablespace to store user and application data. You can use tablespaces to achieve the following goals:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Control disk space allocation for database data</p>
                        </li>
                        <li>
                           <p>Assign a quota (space allowance or limit) to a database user</p>
                        </li>
                        <li>
                           <p>Take individual tablespaces online or offline without affecting the availability of the whole database</p>
                        </li>
                        <li>
                           <p>Perform backup and recovery of individual tablespaces</p>
                        </li>
                        <li>
                           <p>Import or export application data by using the Oracle Data Pump utility</p>
                        </li>
                        <li>
                           <p>Create a <a href="glossary.html#GUID-F3AC6538-2722-4916-BD9F-EDAB8318CCCD"><span class="xrefglossterm">transportable tablespace</span></a> that you can copy or move from one database to another, even across platforms
                           </p>
                           <p>Moving data by transporting tablespaces can be orders of magnitude faster than either export/import or unload/load of the same data, because transporting a tablespace involves only copying data files and integrating the tablespace metadata. When you transport tablespaces you can also move index data.</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-BD3962AF-D4E1-47C0-96CD-0A56807D7850__GUID-E226603D-E95C-4AE8-AAE2-8F32B264FFF5">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-DCDD0FBF-0AD2-45E1-B723-21CC72ADDCD6" title="Oracle Data Pump enables high-speed movement of data and metadata from one database to another.">Oracle Data Pump Export and Import</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/transporting-data.html#ADMIN01101" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to transport tablespaces
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=SUTIL100" target="_blank"><span><cite>Oracle Database Utilities</cite></span></a> to learn about Oracle Data Pump 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89028"></a><a id="CNCPT1086"></a><div class="props_rev_3"><a id="GUID-C1500AE3-17CD-4EF8-A83C-66A058C92CF5" name="GUID-C1500AE3-17CD-4EF8-A83C-66A058C92CF5"></a><h5 id="CNCPT-GUID-C1500AE3-17CD-4EF8-A83C-66A058C92CF5" class="sect5">The SYSTEM Tablespace</h5>
                     <div>
                        <p>The <code class="codeph">SYSTEM</code> tablespace is a necessary administrative tablespace included with the database when it is created. Oracle Database uses <code class="codeph">SYSTEM</code> to manage the database. 
                        </p>
                        <p>The <code class="codeph">SYSTEM</code> tablespace includes the following information, all owned by the <code class="codeph">SYS</code> user:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The data dictionary</p>
                           </li>
                           <li>
                              <p>Tables and views that contain administrative information about the database</p>
                           </li>
                           <li>
                              <p>Compiled stored objects such as triggers, procedures, and packages</p>
                           </li>
                        </ul>
                        <p>The <code class="codeph">SYSTEM</code> tablespace is managed as any other tablespace, but requires a higher level of privilege and is restricted in some ways. For example, you cannot rename or drop the <code class="codeph">SYSTEM</code> tablespace.
                        </p>
                        <p>By default, Oracle Database sets all newly created user tablespaces to be locally managed. In a database with a locally managed <code class="codeph">SYSTEM</code> tablespace, you cannot create dictionary-managed tablespaces (which are deprecated). However, if you execute the <code class="codeph">CREATE DATABASE</code> statement manually and accept the defaults, then the <code class="codeph">SYSTEM</code> tablespace is dictionary managed. You can migrate an existing dictionary-managed <code class="codeph">SYSTEM</code> tablespace to a locally managed format.
                        </p>
                        <div class="infoboxnote" id="GUID-C1500AE3-17CD-4EF8-A83C-66A058C92CF5__GUID-BAF01C9A-BFEB-47F9-81D8-5B20635EB726">
                           <p class="notep1">Note:</p>
                           <p>Oracle strongly recommends that you use Database Configuration Assistant (DBCA) to create new databases so that all tablespaces, including <code class="codeph">SYSTEM</code>, are locally managed by default.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-C1500AE3-17CD-4EF8-A83C-66A058C92CF5__GUID-D37BA428-FF63-43F6-AF45-F7E33A839D9D">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="logical-storage-structures.html#GUID-DBE61726-0DE6-4A85-A49B-9F5587234A87" title="A tablespace can be online (accessible) or offline (not accessible) whenever the database is open.">Online and Offline Tablespaces</a>"</span> for information about the permanent online condition of the <code class="codeph">SYSTEM</code> tablespace
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-87ACF317-FEBC-418C-9BE6-253F2C43F482" title="Oracle provides several tools to simplify the task of installing and configuring Oracle Database software.">Tools for Database Installation and Configuration</a>"</span> to learn about DBCA
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADMIN11393" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to create or migrate to a locally managed <code class="codeph">SYSTEM</code> tablespace
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-DATABASE.html#SQLRF01204" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE DATABASE</code> syntax and semantics
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1089"></a><div class="props_rev_3"><a id="GUID-E4055936-C426-4B5C-8811-32FF98284F16" name="GUID-E4055936-C426-4B5C-8811-32FF98284F16"></a><h5 id="CNCPT-GUID-E4055936-C426-4B5C-8811-32FF98284F16" class="sect5">The SYSAUX Tablespace</h5>
                     <div>
                        <p>The <code class="codeph">SYSAUX</code> tablespace is an auxiliary tablespace to the <code class="codeph">SYSTEM</code> tablespace.
                        </p>
                        <p>Because <code class="codeph">SYSAUX</code> is the default tablespace for many Oracle Database features and products that previously required their own tablespaces, it reduces the number of tablespaces required by the database. It also reduces the load on the <code class="codeph">SYSTEM</code> tablespace.
                        </p>
                        <p>Database creation or upgrade automatically creates the <code class="codeph">SYSAUX</code> tablespace. During normal database operation, the database does not allow the <code class="codeph">SYSAUX</code> tablespace to be dropped or renamed. If the <code class="codeph">SYSAUX</code> tablespace becomes unavailable, then core database functionality remains operational. The database features that use the <code class="codeph">SYSAUX</code> tablespace could fail, or function with limited capability.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E4055936-C426-4B5C-8811-32FF98284F16__GUID-F9D1E871-6556-47B3-9342-0E00585E39CD">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADMIN00203" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about the <code class="codeph">SYSAUX</code> tablespace
                           </p>
                        </div>
                     </div>
                  </div><a id="CNCPT1090"></a><div class="props_rev_3"><a id="GUID-29C6EBF7-64AB-468E-A8CD-6ED36677D604" name="GUID-29C6EBF7-64AB-468E-A8CD-6ED36677D604"></a><h5 id="CNCPT-GUID-29C6EBF7-64AB-468E-A8CD-6ED36677D604" class="sect5">Undo Tablespaces</h5>
                     <div>
                        <p>An <span class="bold">undo tablespace</span> is a locally managed tablespace reserved for system-managed undo data.
                        </p>
                        <p>Like other permanent tablespaces, undo tablespaces contain data files. Undo blocks in these files are grouped in extents.</p>
                        <div class="infoboxnotealso" id="GUID-29C6EBF7-64AB-468E-A8CD-6ED36677D604__GUID-91966206-7CCF-469C-B8FF-BD4C1B681FBA">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="logical-storage-structures.html#GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE" title="Oracle Database maintains records of the actions of transactions, collectively known as undo data.">Undo Segments</a>"</span></p>
                        </div>
                     </div><a id="CNCPT1079"></a><div class="props_rev_3"><a id="GUID-3BC7D6F1-8060-4A00-800E-A00C2F621634" name="GUID-3BC7D6F1-8060-4A00-800E-A00C2F621634"></a><h6 id="CNCPT-GUID-3BC7D6F1-8060-4A00-800E-A00C2F621634" class="sect6">Automatic Undo Management Mode</h6>
                        <div>
                           <p>Undo tablespaces require the database to be in the <strong class="term">default automatic undo mode</strong>.
                           </p>
                           <p>Automatic mode eliminates the complexities of manually administering undo segments. The database automatically tunes itself to provide the best possible retention of undo data to satisfy long-running queries that may require this data.</p>
                           <p>A new installation of Oracle Database automatically creates an undo tablespace. Earlier versions of Oracle Database may not include an undo tablespace and use legacy rollback segments instead, known as <a href="glossary.html#GUID-D30B79E4-A641-4521-98C2-6F500A553736"><span class="xrefglossterm">manual undo management mode</span></a>. When upgrading to <span>Oracle Database 11g</span> or later, you can enable automatic undo management mode and create an undo tablespace. Oracle Database contains an Undo Advisor that provides advice on and helps automate your undo environment.
                           </p>
                           <p>A database can contain multiple undo tablespaces, but only one can be in use at a time. When an instance attempts to open a database, Oracle Database automatically selects the first available undo tablespace. If no undo tablespace is available, then the instance starts without an undo tablespace and stores undo data in the <code class="codeph">SYSTEM</code> tablespace. Storing undo data in <code class="codeph">SYSTEM</code> is not recommended.
                           </p>
                           <div class="infoboxnotealso" id="GUID-3BC7D6F1-8060-4A00-800E-A00C2F621634__GUID-E835BD0F-F4D5-485D-87E7-07B4702A38A5">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../admin/managing-undo.html#ADMIN11461" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about automatic undo management
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../upgrd/index.html" target="_blank"><span><cite>Oracle Database Upgrade Guide</cite></span></a> to learn how to migrate to automatic undo management mode
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT1080"></a><div class="props_rev_3"><a id="GUID-0C389DB8-AAD1-49E2-9E9F-0270F7B25B3D" name="GUID-0C389DB8-AAD1-49E2-9E9F-0270F7B25B3D"></a><h6 id="CNCPT-GUID-0C389DB8-AAD1-49E2-9E9F-0270F7B25B3D" class="sect6">Automatic Undo Retention</h6>
                        <div>
                           <p>The <span class="bold">undo retention period</span> is the minimum amount of time that Oracle Database attempts to retain old undo data before overwriting it.
                           </p>
                           <p>Undo retention is important because long-running queries may require older block images to supply <a href="glossary.html#GUID-A2D92FBD-9C36-432E-A44F-0462DB2E5527"><span class="xrefglossterm">read consistency</span></a>. Also, some Oracle Flashback features can depend on undo availability.
                           </p>
                           <p>In general, it is desirable to retain old undo data as long as possible. After a transaction commits, undo data is no longer needed for rollback or transaction recovery. The database can retain old undo data if the undo tablespace has space for new transactions. When available space is low, the database begins to overwrite old undo data for committed transactions.</p>
                           <p>Oracle Database automatically provides the best possible undo retention for the current undo tablespace. The database collects usage statistics and tunes the retention period based on these statistics and the undo tablespace size. If the undo tablespace is configured with the <code class="codeph">AUTOEXTEND</code> option, and if the maximum size is not specified, then undo retention tuning is different. In this case, the database tunes the undo retention period to be slightly longer than the longest-running query, if space allows.
                           </p>
                           <div class="infoboxnotealso" id="GUID-0C389DB8-AAD1-49E2-9E9F-0270F7B25B3D__GUID-4AEF661C-C1F8-4DD9-A099-DF1CB22BE1A0">
                              <p class="notep1">See Also:</p>
                              <p><a href="../admin/managing-undo.html#ADMIN-GUID-049380AF-220F-43C0-81B2-27DCD7953574" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for more details on automatic tuning of undo retention
                              </p>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-36AAD6A3-1677-432C-B40A-4288F870A3C8" name="GUID-36AAD6A3-1677-432C-B40A-4288F870A3C8"></a><h5 id="CNCPT-GUID-36AAD6A3-1677-432C-B40A-4288F870A3C8" class="sect5">Shadow Tablespaces</h5>
                     <div>
                        <p>A <strong class="term">shadow tablespace</strong> is a bigfile tablespace intended for <strong class="term">shadow lost write protection</strong>.
                        </p>
                        <div class="infoboxnote" id="GUID-36AAD6A3-1677-432C-B40A-4288F870A3C8__GUID-380497CF-2D1E-47CB-85F5-5C50466D0C83">
                           <p class="notep1">Note:</p>
                           <p>Shadow lost write protection is not related to lost write protection that is configured with the <code class="codeph">DB_LOST_WRITE_PROTECT</code> initialization parameter and a standby database.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-44C7652F-78D8-410A-8717-FA43F1D5E645" name="GUID-44C7652F-78D8-410A-8717-FA43F1D5E645"></a><h6 id="CNCPT-GUID-44C7652F-78D8-410A-8717-FA43F1D5E645" class="sect6">Purpose of Shadow Tablespaces</h6>
                        <div>
                           <p>Shadow lost write protection provides fast detection and immediate response to a <strong class="term">lost write</strong>. 
                           </p>
                           <p>A data block lost write occurs when an I/O subsystem acknowledges the completion of the block write even though the write did not occur or when a former image of the block overwrites the current image.</p>
                           <p>An undetected lost write can result in data corruption because the incorrect data can be used for other DML transactions. For example, a transaction can read old and incorrect data from one table, and then update hundreds of other tables based on this data. In this way, data corruption can spread throughout the database.</p>
                           <p>Shadow lost write protection provides the following benefits:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>It detects a lost write before it is consumed for standard DML, SQL*Loader conventional path load, direct path load, and RMAN backups.</p>
                              </li>
                              <li>
                                 <p>No standby database is necessary, as in the lost write protection introduced in <span>Oracle Database 11g</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>You can enable shadow lost write protection for specific tablespaces and data files. You do not need to track all data.</p>
                              </li>
                              <li>
                                 <p>You can replace one shadow tablespace with another to change its configuration or location.</p>
                              </li>
                              <li>
                                 <p>You can suspend and resume shadow lost write protection for a tablespace or data file.</p>
                              </li>
                              <li>
                                 <p>You can enable or disable it for the entire non-CDB or PDB with a single <code class="codeph">ALTER DATABASE ... LOST WRITE TRACKING</code> statement. Note that the <code class="codeph">PROP$</code> table indicates whether tracking is enabled for a PDB.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-44C7652F-78D8-410A-8717-FA43F1D5E645__GUID-3932BD9E-C47C-4C4F-9DCF-075EF0A1B431">
                              <p class="notep1">See Also:</p>
                              <p><a href="../sqlrf/ALTER-DATABASE.html#SQLRF00802" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">LOST WRITE TRACKING</code> clause
                              </p>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-16C39881-6B6B-45C2-860E-5462C3896AC5" name="GUID-16C39881-6B6B-45C2-860E-5462C3896AC5"></a><h6 id="CNCPT-GUID-16C39881-6B6B-45C2-860E-5462C3896AC5" class="sect6">How Shadow Tablespaces Work</h6>
                        <div>
                           <p>Lost write protection requires two tablespaces: a shadow tablespace, and a non-shadow tablespace whose blocks are tracked by the shadow tablespace.</p>
                           <p>The following figure provides a sample scenario. The data files in tablespaces <code class="codeph">TBS1</code> and <code class="codeph">TBS2</code> are tracked by a shadow tablespace. Only data file <code class="codeph">DBF6</code> in tablespace <code class="codeph">TBS3</code> is tracked by the shadow tablespace.
                           </p>
                           <div class="figure" id="GUID-16C39881-6B6B-45C2-860E-5462C3896AC5__GUID-1784D4D7-21A0-4020-9BF8-4B523BCBC90C"><img src="img/cncpt390.png" alt="Description of cncpt390.eps follows" title="Description of cncpt390.eps follows" longdesc="img_text/cncpt390.html"><br><a href="img_text/cncpt390.html">Description of the illustration cncpt390.eps</a></div>
                           <!-- class="figure" -->
                           <p>One <a href="glossary.html#GUID-8A0DABA5-3509-4298-B206-C379910EC038"><span class="xrefglossterm">tracked data file</span></a> maps to one <a href="glossary.html#GUID-2A32C405-187E-47FB-85C7-2B56E9C34286"><span class="xrefglossterm">shadow extent</span></a> in a shadow tablespace. Every data block in a tracked data file has a corresponding entry in a shadow block. This entry contains the SCN of the tracked data block. When a tracked data block is read from disk, shadow lost write protection compares the SCN for the block in the shadow tablespace with the SCN of the most recent write in the tracked data block. If the shadow entry has an SCN greater than the data block being read, then a lost write has occurred, prompting an error.
                           </p>
                           <p>The shadow extent is sized with significant extra space to prevent the automatic resizing of data files from causing the shadow extent to grow too large. If a tracked data file is resized either manually or automatically, and if the shadow extent needs to grow, then the database attempts to resize the tracking data. If sufficient space in the shadow tablespaces does not exist, then the database writes a warning to the alert log, and tracks as many data blocks as possible.</p>
                           <div class="infoboxnotealso" id="GUID-16C39881-6B6B-45C2-860E-5462C3896AC5__GUID-D463D237-F7F2-473C-BB87-57A1E0D2CFE9">
                              <p class="notep1">See Also:</p>
                              <p><a href="../admin/managing-tablespaces.html#GUID-23154DE0-B2AA-4D73-BBCA-73ED5786FF2B" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage shadow lost write protection
                              </p>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-62BDBC60-6356-480C-BA98-F5C95330EDFA" name="GUID-62BDBC60-6356-480C-BA98-F5C95330EDFA"></a><h6 id="CNCPT-GUID-62BDBC60-6356-480C-BA98-F5C95330EDFA" class="sect6">User Interface for Shadow Tablespaces</h6>
                        <div>
                           <p>You enable and disable shadow lost write protection using the <code class="codeph">ALTER DATABASE</code> command.
                           </p>
                           <p>For shadow lost write protection to protect a specific tablespace or data file, the following conditions must be met:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>You must have enabled shadow lost write protection for the entire non-CDB or PDB by using the <code class="codeph">ALTER DATABASE ENABLE LOST WRITE PROTECTION</code> statement.
                                 </p>
                                 <div class="infoboxnote" id="GUID-62BDBC60-6356-480C-BA98-F5C95330EDFA__GUID-7B9BFA1C-B8EB-4C39-AE44-390AFF183318">
                                    <p class="notep1">Note:</p>
                                    <p>In a CDB, if you enable shadow lost write protection in the root, then the PDBs do not inherit it. You must enable shadow lost write protection for every PDB that you want to protect.</p>
                                 </div>
                              </li>
                              <li>
                                 <p>You must have enabled shadow lost write protection for the tablespace or data file to be protected by using the <code class="codeph">ENABLE LOST WRITE PROTECTION</code> clause.
                                 </p>
                                 <p>When you enable shadow lost write protection for a tablespace, all of the data files of the tablespace are protected, and any data files added to the tablespace are also protected. Note that you cannot enable lost write protection on temporary tablespaces or another lost write tablespace. </p>
                              </li>
                              <li>
                                 <p>You must have created one or more shadow tablespaces by using the <code class="codeph">CREATE BIGFILE TABLESPACE</code> statement with the <code class="codeph">LOST WRITE PROTECTION</code> clause.
                                 </p>
                              </li>
                           </ul>
                           <p>Oracle Database assigns a tracked data file to a specific shadow tablespace automatically. You cannot specify which shadow tablespace is used for a particular data file.</p>
                           <p>The following data dictionary views monitor shadow tablespaces:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">DBA_TABLESPACES</code></p>
                                 <p>Shows which tablespaces are shadow tablespaces by querying.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">DBA_DATA_FILES.LOST_WRITE_PROTECT</code></p>
                                 <p>Shows whether lost write protections is enabled for a data file</p>
                              </li>
                              <li>
                                 <p><code class="codeph">USER_TABLESPACES.LOST_WRITE_PROTECT</code></p>
                                 <p>Shows whether lost write protection is turned on for a specific tablespace. <code class="codeph">DBA_DATA_FILES</code> does not indicate whether lost write is turned on for a tablespace: you must look at <code class="codeph">USER_TABLESPACES</code> instead.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-62BDBC60-6356-480C-BA98-F5C95330EDFA__GUID-BFC9EFB9-13A6-4E43-9F81-EF5CEB54493A">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="topics-for-database-administrators-and-developers.html#GUID-CEA4D714-A143-4F9F-8EED-EE5A6B29B3C3" title="A data corruption occurs when a hardware, software, or network component causes corrupt data to be read or written.">Data Corruption</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../admin/managing-tablespaces.html#ADMIN-GUID-23154DE0-B2AA-4D73-BBCA-73ED5786FF2B" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage shadow tablespaces
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLESPACE.html#SQLRF01403" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">CREATE TABLESPACE</code> statement
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../refrn/DBA_TABLESPACES.html#REFRN-GUID-B28A7D79-24E3-49B5-B948-7C2277CB1FB8" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about <code class="codeph">DBA_TABLESPACES</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-DE072DB9-9375-4FCA-91E3-AEB37535AA44" name="GUID-DE072DB9-9375-4FCA-91E3-AEB37535AA44"></a><h6 id="CNCPT-GUID-DE072DB9-9375-4FCA-91E3-AEB37535AA44" class="sect6">Example: Configuring Lost Write Protection</h6>
                        <div>
                           <p>This example enables shadow lost write tracking for a set of tablespaces.</p>
                           <div class="section">
                              <p>In this example, your goal is to protect the <code class="codeph">salestbs</code> and <code class="codeph">hrtbs</code> tablespaces within a non-CDB. You also want to protect the <code class="codeph">oetbs01.dbf</code> data file, and only this data file, within the <code class="codeph">oetbs</code> tablespace. You do the following:
                              </p>
                              <ol>
                                 <li>
                                    <p>Log in to the database as <code class="codeph">SYSTEM</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Create a single shadow tablespace as follows:</p><pre class="pre codeblock"><code>CREATE BIGFILE TABLESPACE shadow_lwp1 
  DATAFILE 'shadow_lwp1_df' SIZE 10M LOST WRITE PROTECTION;
</code></pre></li>
                                 <li>
                                    <p>Enable lost write protection for the entire database as follows:</p><pre class="pre codeblock"><code>ALTER DATABASE ENABLE LOST WRITE PROTECTION;</code></pre></li>
                                 <li>
                                    <p>Enable shadow lost write protection for the <code class="codeph">salestbs</code> and <code class="codeph">hrtbs</code> tablespaces as follows:
                                    </p><pre class="pre codeblock"><code>ALTER TABLESPACE salestbs ENABLE LOST WRITE PROTECTION;
ALTER TABLESPACE hrtbs ENABLE LOST WRITE PROTECTION;</code></pre></li>
                                 <li>
                                    <p>Enable shadow lost write protection for the <code class="codeph">oetbs01.dbf</code> data file as follows:
                                    </p><pre class="pre codeblock"><code>ALTER DATABASE DATAFILE 'oetbs01.dbf' ENABLE LOST WRITE PROTECTION;</code></pre></li>
                              </ol>
                              <div class="infoboxnotealso" id="GUID-DE072DB9-9375-4FCA-91E3-AEB37535AA44__GUID-63FA5FB5-B7CA-42F1-AC89-AE0757F648CC">
                                 <p class="notep1">See Also:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><a href="../admin/managing-tablespaces.html#ADMIN-GUID-23154DE0-B2AA-4D73-BBCA-73ED5786FF2B" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage shadow tablespaces
                                       </p>
                                    </li>
                                    <li>
                                       <p><a href="../sqlrf/CREATE-TABLESPACE.html#SQLRF01403" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">CREATE TABLESPACE</code> statement
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1092"></a><a id="CNCPT89029"></a><div class="props_rev_3"><a id="GUID-93848D41-A32B-494F-87A0-A090FF1B2E9A" name="GUID-93848D41-A32B-494F-87A0-A090FF1B2E9A"></a><h4 id="CNCPT-GUID-93848D41-A32B-494F-87A0-A090FF1B2E9A" class="sect4">Temporary Tablespaces</h4>
                  <div>
                     <p>A <span class="bold">temporary tablespace</span> contains transient data that persists only for the duration of a session. No permanent schema objects can reside in a temporary tablespace. A <span class="bold">temp file</span> stores temporary tablespace data.
                     </p>
                     <p>Temporary tablespaces can improve the concurrency of multiple sort operations that do not fit in memory. These tablespaces also improve the efficiency of space management operations during sorts.</p>
                  </div>
                  <div class="sect4"><a id="GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486" name="GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486"></a><h5 id="CNCPT-GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486" class="sect5">Shared and Local Temporary Tablespaces</h5>
                     <div>
                        <p>Temporary tablespaces are either shared or local.</p>
                        <p>A <a href="glossary.html#GUID-66347815-8AB8-4E23-9B86-F3748CB46AA6"><span class="xrefglossterm">shared temporary tablespace</span></a> stores temp files on shared disk, so that the temporary space is accessible to all database instances. In contrast, a <a href="glossary.html#GUID-3B1784FE-857F-4421-B6F8-17105AEBB6B7"><span class="xrefglossterm">local temporary tablespace</span></a> stores separate, non-shared temp files for every database instance. Local temporary tablespaces are useful for Oracle Real Application Clusters or Oracle Flex Clusters.
                        </p>
                        <div class="infoboxnote" id="GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486__GUID-9C316BCB-4A99-41DD-B6A2-AA7A8BB2E4C3">
                           <p class="notep1">Note:</p>Local temporary tablespaces are new in <span>Oracle Database 12c</span> Release 2 (12.2). In previous releases, shared temporary tablespaces were simply called <span class="italic">temporary tablespaces</span>. Starting in this release, the term <span class="italic">temporary tablespace</span> refers to a shared temporary tablespace unless specified otherwise.
                        </div>
                        <p>You can create local temporary tablespaces for both read-only and read/write database instances. When many read-only instances access a single database, local temporary tablespaces can improve performance for queries that involve sorts, hash aggregations, and joins. The advantages are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Improving I/O performance by using local rather than shared disk storage</p>
                           </li>
                           <li>
                              <p>Avoiding expensive cross-instance temporary space management</p>
                           </li>
                           <li>
                              <p>Improving instance startup performance by eliminating on-disk space metadata management</p>
                           </li>
                        </ul>
                        <p>The following table compares the characteristics of shared and local temporary tablespaces.</p>
                        <div class="tblformal" id="GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486__GUID-6FA2085C-EE5C-4293-A045-D1FA379FE57F">
                           <p class="titleintable">Table 12-2 Shared and Local Temporary Tablespaces</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Shared and Local Temporary Tablespaces" summary="This table compares the characteristics of shared and local temporary tablespaces." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d61599e18611">Shared Temporary Tablespace</th>
                                    <th align="left" valign="bottom" width="20%" id="d61599e18613">Local Temporary Tablespace</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d61599e18617" headers="d61599e18611 ">Created with the <code class="codeph">CREATE TEMPORARY TABLESPACE</code> statement.
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d61599e18617 d61599e18613 ">Created with the <code class="codeph">CREATE LOCAL TEMPORARY TABLESPACE</code> statement.
                                       <p><span class="bold">Note:</span> A local temporary tablespaces is always a <a href="glossary.html#GUID-02B4A6A1-8828-47C9-A921-11966359363E"><span class="xrefglossterm">bigfile tablespace</span></a>, but the <code class="codeph">BIGFILE</code> keyword is not required in the creation statement.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d61599e18638" headers="d61599e18611 ">Creates a single temporary tablespace for the database.</td>
                                    <td align="left" valign="top" width="20%" headers="d61599e18638 d61599e18613 ">Creates separate temporary tablespaces for every database instance. The <code class="codeph">FOR LEAF</code> option creates tablespaces only for read-only instances. The <code class="codeph">FOR ALL</code> option creates tablespaces for all instances, both read-only and read/write.
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d61599e18649" headers="d61599e18611 ">Supports tablespace groups.</td>
                                    <td align="left" valign="top" width="20%" headers="d61599e18649 d61599e18613 ">Does not support tablespace groups.</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d61599e18654" headers="d61599e18611 ">Stores temp file metadata in the control file.</td>
                                    <td align="left" valign="top" width="20%" headers="d61599e18654 d61599e18613 ">Stores temp file metadata common to all instances in the control file, and instance-specific metadata (for example, the bitmaps for allocation, current temp file sizes, and file status) in the SGA.</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-8EB47FD3-2C96-4130-98B7-36E0B1DA0486__GUID-84084335-4A4D-4158-9802-2C327C01C353">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="oracle-database-instance.html#GUID-2942B648-70FA-47B4-8950-0CC6884B1F80" title="A database instance is a set of memory structures that manage database files.">Introduction to the Oracle Database Instance</a>"</span></p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3F457D7A-93F3-411A-94B7-75C0888C1F94" name="GUID-3F457D7A-93F3-411A-94B7-75C0888C1F94"></a><h5 id="CNCPT-GUID-3F457D7A-93F3-411A-94B7-75C0888C1F94" class="sect5">Default Temporary Tablespaces</h5>
                     <div>
                        <p>Every database user account is assigned a default shared temporary tablespace. If the database contains local temporary tablespaces, then every user account is also assigned default local temporary storage.</p>
                        <p>You can specify a different temporary tablespace for a user account with the <code class="codeph">CREATE USER</code> or <code class="codeph">ALTER USER</code> statements. Oracle Database use the system-level default temporary tablespace for users for whom you do not specify a different temporary tablespace.
                        </p>
                        <div class="infoboxnotealso" id="GUID-3F457D7A-93F3-411A-94B7-75C0888C1F94__GUID-CF428B87-8218-46D4-B11B-C1B33AAC4F50">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/CREATE-USER.html#SQLRF01503" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">CREATE USER</code> statement
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-428FB762-4EDE-4BAC-B23D-C4789F148943" name="GUID-428FB762-4EDE-4BAC-B23D-C4789F148943"></a><h6 id="CNCPT-GUID-428FB762-4EDE-4BAC-B23D-C4789F148943" class="sect6">Creation of Default Temporary Tablespaces</h6>
                        <div>
                           <p>When creating a database, the default temporary storage depends on whether the <code class="codeph">SYSTEM</code> tablespace is locally managed.
                           </p>
                           <p>The following table shows how Oracle Database chooses default temporary tablespaces at database creation.</p>
                           <div class="tblformal" id="GUID-428FB762-4EDE-4BAC-B23D-C4789F148943__GUID-181EE4F0-DD68-42F4-90E2-15A6C8235303">
                              <p class="titleintable">Table 12-3 Creation of Default Temporary Tablespaces</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Creation of Default Temporary Tablespaces" summary="This table shows the options for creation of default temporary tablespaces" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d61599e19239">Is the SYSTEM tablespace locally managed?</th>
                                       <th align="left" valign="bottom" width="20%" id="d61599e19241">Does the CREATE DATABASE statement specify a default temporary tablespace?</th>
                                       <th align="left" valign="bottom" width="20%" id="d61599e19243">Then the database ...</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d61599e19247" headers="d61599e19239 ">Yes</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19247 d61599e19241 ">Yes</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19247 d61599e19243 ">Uses the specified tablespace as the default.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d61599e19254" headers="d61599e19239 ">Yes</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19254 d61599e19241 ">No</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19254 d61599e19243 ">Creates a temporary tablespace.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d61599e19261" headers="d61599e19239 ">No</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19261 d61599e19241 ">Yes</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19261 d61599e19243 ">Uses the specified tablespace as the default.</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d61599e19268" headers="d61599e19239 ">No</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19268 d61599e19241 ">No</td>
                                       <td align="left" valign="top" width="20%" headers="d61599e19268 d61599e19243 ">Uses <code class="codeph">SYSTEM</code> for default temporary storage. The database writes a warning in the <a href="glossary.html#GUID-ACC7727F-41AE-47B1-AADB-2585EE828792"><span class="xrefglossterm">alert log</span></a> saying that a default temporary tablespace is recommended.
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>After database creation, you can change the default temporary tablespace for the database with the <code class="codeph">ALTER DATABASE DEFAULT TEMPORARY TABLESPACE</code> statement.
                           </p>
                           <div class="infoboxnote" id="GUID-428FB762-4EDE-4BAC-B23D-C4789F148943__GUID-3B85D03F-11B4-4622-A385-806F5029CEA8">
                              <p class="notep1">Note:</p>
                              <p>You cannot make a default temporary tablespace permanent.</p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-428FB762-4EDE-4BAC-B23D-C4789F148943__GUID-22CF2657-823D-44D1-A854-115EC3EA6A51">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="physical-storage-structures.html#GUID-D59095AD-F79B-4C54-BBED-798E510B049E" title="A permanent tablespace contains persistent schema objects. Objects in permanent tablespaces are stored in data files.">Permanent and Temporary Data Files</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN11090" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to create a default temporary tablespace
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-DATABASE.html#SQLRF53870" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of the <code class="codeph">DEFAULT TEMPORARY TABLESPACE</code> clause of <code class="codeph">CREATE DATABASE</code> and <code class="codeph">ALTER DATABASE</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-5387D7B2-C0CA-4C1E-811B-C7EB9B636442" name="GUID-5387D7B2-C0CA-4C1E-811B-C7EB9B636442"></a><h6 id="CNCPT-GUID-5387D7B2-C0CA-4C1E-811B-C7EB9B636442" class="sect6">Access to Temporary Storage</h6>
                        <div>
                           <p>If a user has a temporary tablespace assigned, then the database accesses it first; otherwise, the database accesses the default temporary tablespace. After the database accesses a temporary tablespace for a query, it does not switch to a different one.</p>
                           <p>A user query can access either shared or local temporary storage. Furthermore, a user could have one default local temporary tablespace assigned for read-only instances, and a different default local temporary tablespace assigned for read/write instances.</p>
                           <p>For read/write instances, the database gives higher priority to shared temporary tablespaces. For read-only instances, the database gives higher priority to local temporary tablespaces. If the database instance is read/write, then the database searches for space in the following order:</p>
                           <ol>
                              <li>
                                 <p>Is a shared temporary tablespace assigned to the user?</p>
                              </li>
                              <li>
                                 <p>Is a local temporary tablespace assigned to the user?</p>
                              </li>
                              <li>
                                 <p>Does the database default temporary tablespace have space?</p>
                              </li>
                           </ol>
                           <p>If the answer to any preceding question is yes, then the database stops the search and allocates space from the specified tablespace; otherwise, space is allocated from the database default local temporary tablespace.</p>
                           <p>If the database instance is read-only, then the database searches for space in the following order:</p>
                           <ol>
                              <li>
                                 <p>Is a local temporary tablespace assigned to the user?</p>
                              </li>
                              <li>
                                 <p>Does the database default local temporary tablespace assigned have space?</p>
                              </li>
                              <li>
                                 <p>Is a shared temporary tablespace assigned to the user?</p>
                              </li>
                           </ol>
                           <p>If the answer to any preceding questions is yes, then the database stops the search and allocates space from the specified tablespace; otherwise, space is allocated from the database default shared temporary tablespace.</p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89027"></a><div class="props_rev_3"><a id="GUID-4984EBD7-4250-48F0-8EA9-A28DD8A17C6B" name="GUID-4984EBD7-4250-48F0-8EA9-A28DD8A17C6B"></a><h4 id="CNCPT-GUID-4984EBD7-4250-48F0-8EA9-A28DD8A17C6B" class="sect4">Tablespace Modes</h4>
                  <div>
                     <p>The tablespace mode determines the accessibility of the tablespace.</p>
                  </div><a id="CNCPT1102"></a><div class="props_rev_3"><a id="GUID-274AC80E-624C-4B23-A88C-7E73C22C6040" name="GUID-274AC80E-624C-4B23-A88C-7E73C22C6040"></a><h5 id="CNCPT-GUID-274AC80E-624C-4B23-A88C-7E73C22C6040" class="sect5">Read/Write and Read-Only Tablespaces</h5>
                     <div>
                        <p>Every tablespace is in a write mode that specifies whether it can be written to. </p>
                        <p>The mutually exclusive modes are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Read/write mode</p>
                              <p>Users can read and write to the tablespace. All tablespaces are initially created as read/write. The <code class="codeph">SYSTEM</code> and <code class="codeph">SYSAUX</code> tablespaces and temporary tablespaces are permanently read/write, which means that they cannot be made read-only.
                              </p>
                           </li>
                           <li>
                              <p>Read-only mode</p>
                              <p>Write operations to the data files in the tablespace are prevented. A read-only tablespace can reside on read-only media such as DVDs or WORM drives.</p>
                              <p>Read-only tablespaces eliminate the need to perform backup and recovery of large, static portions of a database. Read-only tablespaces do not change and thus do not require repeated backup. If you recover a database after a media failure, then you do not need to recover read-only tablespaces.</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-274AC80E-624C-4B23-A88C-7E73C22C6040__GUID-88244713-9B1A-4EFE-947B-8717D71744BF">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-tablespaces.html#ADMIN11379" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to change a tablespace to read only or read/write mode
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/ALTER-TABLESPACE.html#SQLRF53606" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">ALTER TABLESPACE</code> syntax and semantics
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../bradv/getting-started-rman.html#BRADV89370" target="_blank"><span><cite>Oracle Database Backup and Recovery User’s Guide</cite></span></a> for more information about recovery
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1099"></a><div class="props_rev_3"><a id="GUID-DBE61726-0DE6-4A85-A49B-9F5587234A87" name="GUID-DBE61726-0DE6-4A85-A49B-9F5587234A87"></a><h5 id="CNCPT-GUID-DBE61726-0DE6-4A85-A49B-9F5587234A87" class="sect5">Online and Offline Tablespaces</h5>
                     <div>
                        <p>A tablespace can be online (accessible) or offline (not accessible) whenever the database is open. </p>
                        <p>A tablespace is usually online so that its data is available to users. The <code class="codeph">SYSTEM</code> tablespace and temporary tablespaces cannot be taken offline.
                        </p>
                        <p>A tablespace can go offline automatically or manually. For example, you can take a tablespace offline for maintenance or backup and recovery. The database automatically takes a tablespace offline when certain errors are encountered, as when the <a href="glossary.html#GUID-C27AAA54-E60B-49BC-AB04-7B3848EBAFD6"><span class="xrefglossterm">database writer (DBW)</span></a> process fails in several attempts to write to a data file. Users trying to access tables in an offline tablespace receive an error.
                        </p>
                        <p>When a tablespace goes offline, the database does the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The database does not permit subsequent DML statements to reference objects in the offline tablespace. An offline tablespace cannot be read or edited by any utility other than Oracle Database. </p>
                           </li>
                           <li>
                              <p>Active transactions with completed statements that refer to data in that tablespace are not affected at the transaction level.</p>
                           </li>
                           <li>
                              <p>The database saves undo data corresponding to those completed statements in a deferred undo segment in the <code class="codeph">SYSTEM</code> tablespace. When the tablespace is brought online, the database applies the undo data to the tablespace, if needed.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-DBE61726-0DE6-4A85-A49B-9F5587234A87__GUID-25520263-EEA9-43CA-8AA7-9EA64819BAC7">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="physical-storage-structures.html#GUID-A9ADC3BA-D991-4CA6-A4CA-8953A75AEF9D" title="Every data file is either online (available) or offline (unavailable).">Online and Offline Data Files</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="process-architecture.html#GUID-DC9CBDED-3978-450A-9D7A-0A94CE8FF233" title="The database writer process (DBW) writes the contents of database buffers to data files. DBW processes write modified buffers in the database buffer cache to disk.">Database Writer Process (DBW)</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-tablespaces.html#ADMIN12490" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to alter tablespace availability
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1083"></a><div class="props_rev_3"><a id="GUID-D02B2220-E6F5-40D9-AFB5-BC69BCEF6CD4" name="GUID-D02B2220-E6F5-40D9-AFB5-BC69BCEF6CD4"></a><h4 id="CNCPT-GUID-D02B2220-E6F5-40D9-AFB5-BC69BCEF6CD4" class="sect4">Tablespace File Size</h4>
                  <div>
                     <p>A tablespace is either a <span class="bold">bigfile tablespace</span> or a <span class="bold">smallfile tablespace</span>. These tablespaces are indistinguishable in terms of execution of SQL statements that do not explicitly refer to data files or temp files.
                     </p>
                     <p>The difference is as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A smallfile tablespace can contain multiple data files or temp files, but the files cannot be as large as in a bigfile tablespace. This is the default tablespace type.</p>
                        </li>
                        <li>
                           <p>A bigfile tablespace contains one very large data file or temp file. This type of tablespace can do the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Increase the storage capacity of a database</p>
                                 <p>The maximum number of data files in a database is limited, so increasing the size of each data file increases the overall storage.</p>
                              </li>
                              <li>
                                 <p>Reduce the burden of managing many data files and temp files</p>
                                 <p>Bigfile tablespaces simplify file management with Oracle Managed Files and Automatic Storage Management (Oracle ASM) by eliminating the need for adding new files and dealing with multiple files.</p>
                              </li>
                              <li>
                                 <p>Perform operations on tablespaces rather than individual files</p>
                                 <p>Bigfile tablespaces make the tablespace the main unit of the disk space administration, backup and recovery, and so on.</p>
                              </li>
                           </ul>
                           <p>Bigfile tablespaces are supported only for locally managed tablespaces with ASSM. However, locally managed undo and temporary tablespaces can be bigfile tablespaces even when segments are manually managed.</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-D02B2220-E6F5-40D9-AFB5-BC69BCEF6CD4__GUID-2988500D-7C02-4A92-8A0D-0A76EE5C7FB6">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-DCE361D9-B486-43B4-B4FD-5722A93203F0" title="Backup and recovery is the set of concepts, procedures, and strategies involved in protecting the database against data loss caused by media failure or users errors. In general, the purpose of a backup and recovery strategy is to protect the database against data loss and reconstruct lost data.">Backup and Recovery</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-tablespaces.html#ADMIN01102" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage bigfile tablespaces
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>