<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. Using secure communications between two systems with OpenSSH</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="assembly_using-secure-communications-with-openssh-securing-networks"/>Chapter 1. Using secure communications between two systems with OpenSSH</h1></div></div></div><p>
			<code class="literal">SSH</code> (Secure Shell) is a protocol which facilitates secure communications between two systems using a client-server architecture and allows users to log in to server host systems remotely. Unlike other remote communication protocols, such as <code class="literal">FTP</code> or <code class="literal">Telnet</code>, SSH encrypts the login session, rendering the connection difficult for intruders to collect unencrypted passwords.
		</p><p>
			The <span class="strong"><strong><span class="application">ssh</span></strong></span> program is designed to replace older, less secure terminal applications used to log in to remote hosts, such as <code class="literal">telnet</code> or <code class="literal">rsh</code>. A related program called <code class="literal">scp</code> replaces older programs designed to copy files between hosts, such as <code class="literal">rcp</code>. Because these older applications do not encrypt passwords transmitted between the client and the server, avoid them whenever possible. Using secure methods to log in to remote systems decreases the risks for both the client system and the remote host.
		</p><p>
			Red Hat Enterprise Linux includes the general <code class="literal">OpenSSH</code> package, <span class="strong"><strong><span class="package">openssh</span></strong></span>, as well as the <code class="literal">OpenSSH</code> server, <span class="strong"><strong><span class="package">openssh-server</span></strong></span>, and client, <span class="strong"><strong><span class="package">openssh-clients</span></strong></span>, packages. Note, the <code class="literal">OpenSSH</code> packages require the <code class="literal">OpenSSL</code> package <span class="strong"><strong><span class="package">openssl-libs</span></strong></span>, which installs several important cryptographic libraries, enabling <code class="literal">OpenSSH</code> to provide encrypted communications.
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="The_SSH_protocol_configuring-and-managing-security"/>The <code class="literal">SSH</code> protocol</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Why_use_SSH_configuring-and-managing-security"/>Reasons for using SSH</h2></div></div></div><p>
					Potential intruders have a variety of tools at their disposal enabling them to disrupt, intercept, and re-route network traffic in an effort to gain access to a system. In general terms, these threats can be categorized as follows:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Interception of communication between two systems</span></dt><dd><p class="simpara">
								The attacker can be somewhere on the network between the communicating parties, copying any information passed between them. He may intercept and keep the information, or alter the information and send it on to the intended recipient.
							</p><p class="simpara">
								This attack is usually performed using a <span class="emphasis"><em>packet sniffer</em></span>, a rather common network utility that captures each packet flowing through the network, and analyzes its content.
							</p></dd><dt><span class="term">Impersonation of a particular host</span></dt><dd><p class="simpara">
								Attacker’s system is configured to pose as the intended recipient of a transmission. If this strategy works, the user’s system remains unaware that it is communicating with the wrong host.
							</p><p class="simpara">
								This attack can be performed using a technique known as <span class="emphasis"><em>DNS poisoning</em></span>, or via so-called <span class="emphasis"><em>IP spoofing</em></span>. In the first case, the intruder uses a cracked DNS server to point client systems to a maliciously duplicated host. In the second case, the intruder sends falsified network packets that appear to be from a trusted host.
							</p></dd></dl></div><p>
					Both techniques intercept potentially sensitive information and, if the interception is made for hostile reasons, the results can be disastrous. If <code class="literal">SSH</code> is used for remote shell login and file copying, these security threats can be greatly diminished. This is because the <code class="literal">SSH</code> client and server use digital signatures to verify their identity. Additionally, all communication between the client and server systems is encrypted. Attempts to spoof the identity of either side of a communication does not work, since each packet is encrypted using a key known only by the local and remote systems.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="SSH_features_configuring-and-managing-security"/>Main features</h2></div></div></div><p>
					The <code class="literal">SSH</code> protocol provides the following safeguards:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">No one can pose as the intended server</span></dt><dd>
								After an initial connection, the client can verify that it is connecting to the same server it had connected to previously.
							</dd><dt><span class="term">No one can capture the authentication information</span></dt><dd>
								The client transmits its authentication information to the server using strong, 128-bit encryption.
							</dd><dt><span class="term">No one can intercept the communication</span></dt><dd>
								All data sent and received during a session is transferred using 128-bit encryption, making intercepted transmissions extremely difficult to decrypt and read.
							</dd></dl></div><p>
					Additionally, it also offers the following options:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">It provides secure means to use graphical applications over a network</span></dt><dd>
								Using a technique called <span class="emphasis"><em>X11 forwarding</em></span>, the client can forward <span class="emphasis"><em>X11</em></span> (<span class="emphasis"><em>X Window System</em></span>) applications from the server.
							</dd><dt><span class="term">It provides a way to secure otherwise insecure protocols</span></dt><dd>
								The <code class="literal">SSH</code> protocol encrypts everything it sends and receives. Using a technique called <span class="emphasis"><em>port forwarding</em></span>, an <code class="literal">SSH</code> server can become a conduit to securing otherwise insecure protocols, like <span class="strong"><strong>POP</strong></span>, and increasing overall system and data security.
							</dd><dt><span class="term">It can be used to create a secure channel</span></dt><dd>
								The <code class="literal">OpenSSH</code> server and client can be configured to create a tunnel similar to a virtual private network for traffic between server and client machines.
							</dd><dt><span class="term">It supports the <code class="literal">Kerberos</code> authentication</span></dt><dd>
								<code class="literal">OpenSSH</code> servers and clients can be configured to authenticate using the <span class="strong"><strong>GSSAPI</strong></span> (Generic Security Services Application Program Interface) implementation of the <code class="literal">Kerberos</code> network authentication protocol.
							</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="SSH_versions_configuring-and-managing-security"/>Protocol versions</h2></div></div></div><p>
					Two varieties of <code class="literal">SSH</code> currently exist: version 1, and newer version 2. The <code class="literal">OpenSSH</code> suite under Red Hat Enterprise Linux 8; uses <code class="literal">SSH</code> version 2, which has an enhanced key exchange algorithm not vulnerable to the known exploit in version 1. In Red Hat Enterprise Linux 8, the <code class="literal">OpenSSH</code> suite does not support version 1 connections.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="SSH_event_sequence_configuring-and-managing-security"/>Event sequence of an <code class="literal">SSH</code> connection</h2></div></div></div><p>
					The following series of events help protect the integrity of <code class="literal">SSH</code> communication between two hosts.
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							A cryptographic handshake is made so that the client can verify that it is communicating with the correct server.
						</li><li class="listitem">
							The transport layer of the connection between the client and remote host is encrypted using a symmetric cipher.
						</li><li class="listitem">
							The client authenticates itself to the server.
						</li><li class="listitem">
							The client interacts with the remote host over the encrypted connection.
						</li></ol></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="SSH_conn_transport_configuring-and-managing-security"/>Transport layer</h3></div></div></div><p>
						The primary role of the transport layer is to facilitate safe and secure communication between the two hosts at the time of authentication and during subsequent communication. The transport layer accomplishes this by handling the encryption and decryption of data, and by providing integrity protection of data packets as they are sent and received. The transport layer also provides compression, speeding the transfer of information.
					</p><p>
						Once an <code class="literal">SSH</code> client contacts a server, key information is exchanged so that the two systems can correctly construct the transport layer. The following steps occur during this exchange:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Keys are exchanged
							</li><li class="listitem">
								The public key encryption algorithm is determined
							</li><li class="listitem">
								The symmetric encryption algorithm is determined
							</li><li class="listitem">
								The message authentication algorithm is determined
							</li><li class="listitem">
								The hash algorithm is determined
							</li></ul></div><p>
						During the key exchange, the server identifies itself to the client with a unique <span class="emphasis"><em>host key</em></span>. If the client has never communicated with this particular server before, the server’s host key is unknown to the client and it does not connect. <code class="literal">OpenSSH</code> gets around this problem by accepting the server’s host key. This is done after the user is notified and has both accepted and verified the new host key. In subsequent connections, the server’s host key is checked against the saved version on the client, providing confidence that the client is indeed communicating with the intended server. If, in the future, the host key no longer matches, the user must remove the client’s saved version before a connection can occur.
					</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							It is possible for an attacker to masquerade as an <code class="literal">SSH</code> server during the initial contact since the local system does not know the difference between the intended server and a false one set up by an attacker. To help prevent this, verify the integrity of a new <code class="literal">SSH</code> server by contacting the server administrator before connecting for the first time or in the event of a host key mismatch.
						</p></div><p>
						<code class="literal">SSH</code> is designed to work with almost any kind of public key algorithm or encoding format. After an initial key exchange creates a hash value used for exchanges and a shared secret value, the two systems immediately begin calculating new keys and algorithms to protect authentication and future data sent over the connection.
					</p><p>
						After a certain amount of data has been transmitted using a given key and algorithm (the exact amount depends on the <code class="literal">SSH</code> implementation), another key exchange occurs, generating another set of hash values and a new shared secret value. Even if an attacker is able to determine the hash and shared secret value, this information is only useful for a limited period of time.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="SSH_authentication_configuring-and-managing-security"/>Authentication</h3></div></div></div><p>
						Once the transport layer has constructed a secure tunnel to pass information between the two systems, the server tells the client the different authentication methods supported, such as using a private key-encoded signature or typing a password. The client then tries to authenticate itself to the server using one of these supported methods.
					</p><p>
						<code class="literal">SSH</code> servers and clients can be configured to allow different types of authentication, which gives each side the optimal amount of control. The server can decide which encryption methods it supports based on its security model, and the client can choose the order of authentication methods to attempt from the available options.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="SSH_channels_configuring-and-managing-security"/>Channels</h3></div></div></div><p>
						After a successful authentication over the <code class="literal">SSH</code> transport layer, multiple channels are opened using a technique called <span class="emphasis"><em>multiplexing</em></span><a href="#ftn.idm140509308915136" class="footnote" id="idm140509308915136"><sup class="footnote">[1]</sup></a>. Each of these channels handles communication for different terminal sessions and for forwarded X11 sessions.
					</p><p>
						Both clients and servers can create a new channel. Each channel is then assigned a different number on each end of the connection. When the client attempts to open a new channel, the clients sends the channel number along with the request. This information is stored by the server and is used to direct communication to that channel. This is done so that different types of sessions do not affect one another and so that when a given session ends, its channel can be closed without disrupting the primary <code class="literal">SSH</code> connection.
					</p><p>
						Channels also support <span class="emphasis"><em>flow-control</em></span>, which allows them to send and receive data in an orderly fashion. In this way, data is not sent over the channel until the client receives a message that the channel is open.
					</p><p>
						The client and server negotiate the characteristics of each channel automatically, depending on the type of service the client requests and the way the user is connected to the network. This allows great flexibility in handling different types of remote connections without having to change the basic infrastructure of the protocol.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Configuring-OpenSSH_configuring-and-managing-security"/>Setting <code class="literal">OpenSSH</code> up using configuration files</h1></div></div></div><p>
				The <code class="literal">OpenSSH</code> suite uses two different sets of configuration files: those for client programs (that is, <code class="literal">ssh</code>, <code class="literal">scp</code>, and <code class="literal">sftp</code>), and those for the server (the <code class="literal">sshd</code> daemon).
			</p><p>
				System-wide <code class="literal">SSH</code> configuration information is stored in the <code class="literal">/etc/ssh/</code> directory. User-specific <code class="literal">SSH</code> configuration information is stored in <code class="literal">~/.ssh/</code> within the user’s home directory.
			</p><div class="table"><a id="table-ssh-configuration-configs-system_configuring-and-managing-security"/><p class="title"><strong>Table 1.1. System-wide configuration files</strong></p><div class="table-contents"><table summary="System-wide configuration files" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">File</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/moduli</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Contains Diffie-Hellman groups used for the Diffie-Hellman key exchange which is critical for constructing a secure transport layer. When keys are exchanged at the beginning of an SSH session, a shared, secret value is created which cannot be determined by either party alone. This value is then used to provide host authentication.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/ssh_config</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The default SSH client configuration file. Note that it is overridden by <code class="literal">~/.ssh/config</code> if it exists.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/sshd_config</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The configuration file for the <code class="literal">sshd</code> daemon.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/ssh_host_ecdsa_key</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The ECDSA private key used by the <code class="literal">sshd</code> daemon.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/ssh_host_ecdsa_key.pub</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The ECDSA public key used by the <code class="literal">sshd</code> daemon.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/ssh_host_rsa_key</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The RSA private key used by the <code class="literal">sshd</code> daemon for version 2 of the SSH protocol.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/ssh/ssh_host_rsa_key.pub</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The RSA public key used by the <code class="literal">sshd</code> daemon for version 2 of the SSH protocol.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/pam.d/sshd</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The PAM configuration file for the <code class="literal">sshd</code> daemon.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">/etc/sysconfig/sshd</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Configuration file for the <code class="literal">sshd</code> service.
							</p>
							 </td></tr></tbody></table></div></div><div class="table"><a id="table-ssh-configuration-configs-user_configuring-and-managing-security"/><p class="title"><strong>Table 1.2. User-specific configuration files</strong></p><div class="table-contents"><table summary="User-specific configuration files" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">File</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/authorized_keys</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Holds a list of authorized public keys for servers. When the client connects to a server, the server authenticates the client by checking its signed public key stored within this file.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/id_ecdsa</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Contains the ECDSA private key of the user.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/id_ecdsa.pub</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The ECDSA public key of the user.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/id_rsa</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The RSA private key used by <code class="literal">ssh</code> for version 2 of the SSH protocol.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/id_rsa.pub</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The RSA public key used by <code class="literal">ssh</code> for version 2 of the SSH protocol.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">~/.ssh/known_hosts</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Contains host keys of SSH servers accessed by the user. This file is very important for ensuring that the SSH client is connecting to the correct SSH server.
							</p>
							 </td></tr></tbody></table></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
					If setting up an <code class="literal">SSH</code> server, do not turn off the <code class="literal">Privilege Separation</code> feature by using the <span class="strong"><strong>UsePrivilegeSeparation no</strong></span> directive in the <code class="literal">/etc/ssh/sshd_config</code> file. Turning off <code class="literal">Privilege Separation</code> disables many security features and exposes the server to potential security vulnerabilities and targeted attacks. For more information about <span class="strong"><strong>UsePrivilegeSeparation</strong></span>, see the <code class="literal">sshd_config</code>(5) manual page or the <a class="link" href="https://access.redhat.com/solutions/1354953">What is the significance of UsePrivilegeSeparation directive in /etc/ssh/sshd_config file and how to test it</a> Red Hat Knowledgebase article.
				</p></div><p>
				For information about various directives that can be used in the SSH configuration files, see the <code class="literal">ssh_config</code>(5) and <code class="literal">sshd_config</code>(5) manual pages.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Starting-OpenSSH-server_configuring-and-managing-security"/>Starting an OpenSSH server</h1></div></div></div><p>
				To run an <code class="literal">OpenSSH</code> server, install the <span class="strong"><strong><span class="package">openssh-server</span></strong></span> package. To start the <code class="literal">sshd</code> daemon in the current session:
			</p><pre class="screen"># systemctl start sshd.service</pre><p>
				To stop the running <code class="literal">sshd</code> daemon in the current session:
			</p><pre class="screen"># systemctl stop sshd.service</pre><p>
				To start the daemon automatically at boot time:
			</p><pre class="screen"># systemctl enable sshd.service
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd.service to /usr/lib/systemd/system/sshd.service.</pre><p>
				The <code class="literal">sshd</code> daemon depends on the <code class="literal">network.target</code> target unit, which is sufficient for static configured network interfaces and for default <code class="literal">ListenAddress</code> <code class="literal">0.0.0.0</code> options. To specify different addresses in the <code class="literal">ListenAddress</code> directive and to use a slower dynamic network configuration, add dependency on the <code class="literal">network-online.target</code> target unit to the <code class="literal">sshd.service</code> unit file. To achieve this, create the <code class="literal">/etc/systemd/system/sshd.service.d/local.conf</code> file with the following options:
			</p><pre class="screen">  [Unit]
  Wants=<code class="literal">network-online.target</code>
  After=<code class="literal">network-online.target</code></pre><p>
				After this, reload the <code class="literal">systemd</code> manager configuration using the following command:
			</p><pre class="screen"># systemctl daemon-reload</pre><p>
				Note that if you reinstall the system, a new set of identification keys will be created. As a result, clients who had connected to the system with any of the <code class="literal">OpenSSH</code> tools before the reinstall will see the following message:
			</p><pre class="screen">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.</pre><p>
				To prevent this, you can backup the relevant files from the <code class="literal">/etc/ssh/</code> directory. See <a class="xref" href="assembly_using-secure-communications-with-openssh-securing-networks.html#table-ssh-configuration-configs-system_configuring-and-managing-security" title="Table 1.1. System-wide configuration files">Table 1.1, “System-wide configuration files”</a> for a complete list, and restore the files whenever you reinstall the system.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Configuring-the-OpenSSH-server-keys-generation_configuring-and-managing-security"/>Configuring the OpenSSH server keys generation</h2></div></div></div><p>
					<code class="literal">OpenSSH</code> creates RSA, ECDSA, and ED25519 server keys automatically if they are missing. Prior to RHEL 8, administrators have configured the automatic host keys creation in the <code class="literal">/etc/sysconfig/sshd</code> file when needed. To configure the host key creation in RHEL 8, use the <code class="literal">sshd-keygen@.service</code> instantiated service.
				</p><p>
					For example, the following commands disable the automatic RSA key creation and enable the automatic DSA key creation on the OpenSSH server:
				</p><pre class="screen"># systemctl mask sshd-keygen@rsa.service
# systemctl enable sshd-keygen@dsa.service</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Note that DSA keys are insecure due to only small key size supported and thus deprecated.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Requiring_SSH_for_remote_connections_configuring-and-managing-security"/>Requiring SSH for remote connections</h1></div></div></div><p>
				To make <code class="literal">SSH</code> truly effective, using insecure connection protocols should be prohibited. Otherwise, a user’s password may be protected using <code class="literal">SSH</code> for one session, only to be captured later while logging in using <code class="literal">Telnet</code>. Some services to disable include <code class="literal">telnet</code>, <code class="literal">rsh</code>, <code class="literal">rlogin</code>, and <code class="literal">vsftpd</code>.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuration-keypairs_configuring-and-managing-security"/>Using key-based authentication</h1></div></div></div><p>
				To improve the system security even further, generate <code class="literal">SSH</code> key pairs and then enforce key-based authentication by disabling password authentication. To do so, open the <code class="literal">/etc/ssh/sshd_config</code> configuration file in a text editor such as <span class="strong"><strong><span class="application">vi</span></strong></span> or <span class="strong"><strong><span class="application">nano</span></strong></span>, and change the <code class="literal">PasswordAuthentication</code> option as follows:
			</p><pre class="screen">PasswordAuthentication no</pre><p>
				On a system other than a new default installation, check that <code class="literal">PubkeyAuthentication no</code> has <span class="strong"><strong>not</strong></span> been set. If connected remotely, not using console or out-of-band access, testing the key-based log in process before disabling password authentication is advised.
			</p><p>
				To be able to use <code class="literal">ssh</code>, <code class="literal">scp</code>, or <code class="literal">sftp</code> to connect to the server from a client machine, generate an authorization key pair by following the steps below. Note that keys must be generated for each user separately.
			</p><p>
				To use key-based authentication with NFS-mounted home directories, enable the <code class="literal">use_nfs_home_dirs</code> SELinux boolean first:
			</p><pre class="screen"># setsebool -P use_nfs_home_dirs 1</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					If you complete the steps as <code class="literal">root</code>, only <code class="literal">root</code> is able to use the keys.
				</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					If you reinstall your system and want to keep previously generated key pairs, backup the <code class="literal">~/.ssh/</code> directory. After reinstalling, copy it back to your home directory. This process can be done for all users on your system, including <code class="literal">root</code>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ssh-configuration-keypairs-generating_configuring-and-managing-security"/>Generating key pairs</h2></div></div></div><p>
					To generate an RSA key pair for version 2 of the SSH protocol, follow these steps:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Generate an RSA key pair by typing the following at a shell prompt:
						</p><pre class="screen">$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/USER/.ssh/id_rsa):</pre></li><li class="listitem">
							Press <span class="keycap"><strong>Enter</strong></span> to confirm the default location, <code class="literal">~/.ssh/id_rsa</code>, for the newly created key.
						</li><li class="listitem"><p class="simpara">
							Enter a passphrase, and confirm it by entering it again when prompted to do so. For security reasons, avoid using the same password as you use to log in to your account.
						</p><p class="simpara">
							After this, you will be presented with a message similar to this:
						</p><pre class="screen">Your identification has been saved in /home/USER/.ssh/id_rsa.
Your public key has been saved in /home/USER/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:UNIgIT4wfhdQH/K7yqmjsbZnnyGDKiDviv492U5z78Y USER@penguin.example.com
The key's randomart image is:
+---[RSA 2048]----+
|o ..==o+.        |
|.+ . .=oo        |
| .o. ..o         |
|  ...  ..        |
|       .S        |
|o .     .        |
|o+ o .o+ ..      |
|+.++=o*.o .E     |
|BBBo+Bo.  oo     |
+----[SHA256]-----+</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								To get an MD5 key fingerprint, which was the default fingerprint in previous versions, use the <code class="literal">ssh-keygen</code> command with the <code class="literal">-E md5</code> option.
							</p></div></li><li class="listitem"><p class="simpara">
							By default, the permissions of the <code class="literal">~/.ssh/</code> directory are set to <code class="literal">rwx------</code> or <code class="literal">700</code> expressed in octal notation. This is to ensure that only the <span class="emphasis"><em>USER</em></span> can view the contents. If required, this can be confirmed with the following command:
						</p><pre class="screen">$ <code class="literal">ls -ld ~/.ssh</code>
drwx------. 2 USER USER 54 Nov 25 16:56 /home/USER/.ssh/</pre></li><li class="listitem"><p class="simpara">
							To copy the public key to a remote machine, issue a command in the following format:
						</p><pre class="screen"> <code class="literal">ssh-copy-id <span class="emphasis"><em>user@hostname</em></span></code></pre><p class="simpara">
							This copies the most recently modified <code class="literal">~/.ssh/id*.pub</code> public key if it is not yet installed. Alternatively, specify the public key’s file name as follows:
						</p><pre class="screen">ssh-copy-id -i ~/.ssh/id_rsa.pub user@hostname</pre><p class="simpara">
							This copies the content of <code class="literal">~/.ssh/id_rsa.pub</code> into the <code class="literal">~/.ssh/authorized_keys</code> file on the machine to which you want to connect. If the file already exists, the keys are appended to its end.
						</p></li></ol></div><p>
					To generate an ECDSA key pair for version 2 of the SSH protocol, follow these steps:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Generate an ECDSA key pair by typing the following at a shell prompt:
						</p><pre class="screen">$ ssh-keygen -t ecdsa
Generating public/private ecdsa key pair.
Enter file in which to save the key (/home/USER/.ssh/id_ecdsa):</pre></li><li class="listitem">
							Press <span class="keycap"><strong>Enter</strong></span> to confirm the default location, <code class="literal">~/.ssh/id_ecdsa</code>, for the newly created key.
						</li><li class="listitem"><p class="simpara">
							Enter a passphrase, and confirm it by entering it again when prompted to do so. For security reasons, avoid using the same password as you use to log in to your account.
						</p><p class="simpara">
							After this, you will be presented with a message similar to this:
						</p><pre class="screen">Your identification has been saved in /home/USER/.ssh/id_ecdsa.
Your public key has been saved in /home/USER/.ssh/id_ecdsa.pub.
The key fingerprint is:
SHA256:8BhZageKrLXM99z5f/AM9aPo/KAUd8ZZFPcPFWqK6+M USER@penguin.example.com
The key's randomart image is:
+---[ECDSA 256]---+
|      . .      +=|
| . . . =      o.o|
|  + . * .    o...|
| = . . *  . + +..|
|. + . . So o * ..|
|   . o . .+ =  ..|
|      o oo ..=. .|
|        ooo...+  |
|        .E++oo   |
+----[SHA256]-----+</pre></li><li class="listitem"><p class="simpara">
							By default, the permissions of the <code class="literal">~/.ssh/</code> directory are set to <code class="literal">rwx------</code> or <code class="literal">700</code> expressed in octal notation. This is to ensure that only the <span class="emphasis"><em>USER</em></span> can view the contents. If required, this can be confirmed with the following command:
						</p><pre class="screen">$ <code class="literal">ls -ld ~/.ssh</code>
              $ ls -ld ~/.ssh/
drwx------. 2 USER USER 54 Nov 25 16:56 /home/USER/.ssh/</pre></li><li class="listitem"><p class="simpara">
							To copy the public key to a remote machine, issue a command in the following format:
						</p><pre class="screen"><code class="literal">ssh-copy-id <span class="emphasis"><em>USER@hostname</em></span></code></pre><p class="simpara">
							This copies the most recently modified <code class="literal">~/.ssh/id*.pub</code> public key if it is not yet installed. Alternatively, specify the public key’s file name as follows:
						</p><pre class="screen">ssh-copy-id -i ~/.ssh/id_ecdsa.pub USER@hostname</pre><p class="simpara">
							This copies the content of <code class="literal">~/.ssh/id_ecdsa.pub</code> into the <code class="literal">~/.ssh/authorized_keys</code> on the machine to which you want to connect. If the file already exists, the keys are appended to its end.
						</p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
						The private key is for your personal use only, and it is important that you never give it to anyone.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="related_information"/>Related information</h1></div></div></div><p>
				For more information on how to configure or connect to an <code class="literal">OpenSSH</code> server on Red Hat Enterprise Linux, see the resources listed below.
			</p><div class="itemizedlist"><p class="title"><strong>Installed Documentation</strong></p><ul class="itemizedlist"><li class="listitem">
						<code class="literal">sshd</code>(8) — The manual page for the <code class="literal">sshd</code> daemon documents available command-line options and provides a complete list of supported configuration files and directories.
					</li><li class="listitem">
						<code class="literal">ssh</code>(1) — The manual page for the <code class="literal">ssh</code> client application provides a complete list of available command-line options and supported configuration files and directories.
					</li><li class="listitem">
						<code class="literal">scp</code>(1) — The manual page for the <code class="literal">scp</code> utility provides a more detailed description of this utility and its usage.
					</li><li class="listitem">
						<code class="literal">sftp</code>(1) — The manual page for the <code class="literal">sftp</code> utility.
					</li><li class="listitem">
						<code class="literal">ssh-keygen</code>(1) — The manual page for the <code class="literal">ssh-keygen</code> utility documents in detail how to use it to generate, manage, and convert authentication keys used by <code class="literal">ssh</code>.
					</li><li class="listitem">
						<code class="literal">ssh_config</code>(5) — The manual page named <code class="literal">ssh_config</code> documents available SSH client configuration options.
					</li><li class="listitem">
						<code class="literal">sshd_config</code>(5) — The manual page named <code class="literal">sshd_config</code> provides a full description of available SSH daemon configuration options.
					</li></ul></div><div class="itemizedlist"><p class="title"><strong>Online Documentation</strong></p><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="http://www.openssh.com/">OpenSSH Home Page</a> — The OpenSSH home page containing further documentation, frequently asked questions, links to the mailing lists, bug reports, and other useful resources.
					</li><li class="listitem">
						<a class="link" href="http://www.openssl.org/">OpenSSL Home Page</a> — The OpenSSL home page containing further documentation, frequently asked questions, links to the mailing lists, and other useful resources.
					</li></ul></div></div><div class="footnotes"><br/><hr/><div id="ftn.idm140509308915136" class="footnote"><p><a href="#idm140509308915136" class="simpara"><sup class="simpara">[1] </sup></a>
							A multiplexed connection consists of several signals being sent over a shared, common medium. With SSH, different channels are sent over a common secure connection.
						</p></div></div></div></body></html>