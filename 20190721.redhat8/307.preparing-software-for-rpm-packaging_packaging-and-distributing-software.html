<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 2. Preparing software for RPM packaging</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="preparing-software-for-rpm-packaging_packaging-and-distributing-software"/>Chapter 2. Preparing software for RPM packaging</h1></div></div></div><p>
			This section explains how to prepare software for RPM packaging. To do so, knowing how to code is not necessary. However, you need to understand the basic concepts, such as <a class="link" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#what-is-source-code_preparing-software-for-rpm-packaging" title="What source code is">What source code is</a> and <a class="link" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#how-programs-are-made_preparing-software-for-rpm-packaging" title="How programs are made">How programs are made</a>.
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="what-is-source-code_preparing-software-for-rpm-packaging"/>What source code is</h1></div></div></div><p>
				This part explains what source code is and shows example source codes of a program written in three different programming languages.
			</p><p>
				Source code is human-readable instructions to the computer, which describe how to perform a computation. Source code is expressed using a programming language.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="source-code-examples"/>Source code examples</h2></div></div></div><p>
					This document features three versions of the <code class="literal">Hello World</code> program written in three different programming languages:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-bash" title="Hello World written in bash">the section called “Hello World written in bash”</a>
						</li><li class="listitem">
							<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-python" title="Hello World written in Python">the section called “Hello World written in Python”</a>
						</li><li class="listitem">
							<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-c" title="Hello World written in C">the section called “Hello World written in C”</a>
						</li></ul></div><p>
					Each version is packaged differently.
				</p><p>
					These versions of the <code class="literal">Hello World</code> program cover the three major use cases of an RPM packager.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="hello-world-bash"/>Hello World written in bash</h3></div></div></div><p>
						The <span class="emphasis"><em>bello</em></span> project implements <code class="literal">Hello World</code> in <a class="link" href="https://www.gnu.org/software/bash/">bash</a>. The implementation only contains the <code class="literal">bello</code> shell script. The purpose of the program is to output <code class="literal">Hello World</code> on the command line.
					</p><p>
						The <code class="literal">bello</code> file has the following syntax:
					</p><pre class="literallayout">#!/bin/bash

printf "Hello World\n"</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="hello-world-python"/>Hello World written in Python</h3></div></div></div><p>
						The <span class="emphasis"><em>pello</em></span> project implements <code class="literal">Hello World</code> in <a class="link" href="https://www.python.org/">Python</a>. The implementation only contains the <code class="literal">pello.py</code> program. The purpose of the program is to output <code class="literal">Hello World</code> on the command line.
					</p><p>
						The <code class="literal">pello.py</code> file has the following syntax:
					</p><pre class="literallayout">#!/usr/bin/python3

print("Hello World")</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="hello-world-c"/>Hello World written in C</h3></div></div></div><p>
						The <span class="emphasis"><em>cello</em></span> project implements <code class="literal">Hello World</code> in C. The implementation only contains the <code class="literal">cello.c</code> and the <code class="literal">Makefile</code> files, so the resulting <code class="literal">tar.gz</code> archive will have two files apart from the <code class="literal">LICENSE</code> file.
					</p><p>
						The purpose of the program is to output <code class="literal">Hello World</code> on the command line.
					</p><p>
						The <code class="literal">cello.c</code> file has the following syntax:
					</p><pre class="literallayout">#include &lt;stdio.h&gt;

int main(void) {
    printf("Hello World\n");
    return 0;
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="how-programs-are-made_preparing-software-for-rpm-packaging"/>How programs are made</h1></div></div></div><p>
				Methods of conversion from human-readable source code to machine code (instructions that the computer follows to execute the program) include the following:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						The program is natively compiled.
					</li><li class="listitem">
						The program is interpreted by raw interpreting.
					</li><li class="listitem">
						The program is interpreted by byte compiling.
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="natively-compiled-code"/>Natively Compiled Code</h2></div></div></div><p>
					Natively compiled software is software written in a programming language that compiles to machine code with a resulting binary executable file. Such software can be run stand-alone.
				</p><p>
					RPM packages built this way are architecture-specific.
				</p><p>
					If you compile such software on a computer that uses a 64-bit (x86_64) AMD or Intel processor, it does not execute on a 32-bit (x86) AMD or Intel processor. The resulting package has architecture specified in its name.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="interpreted-code"/>Interpreted Code</h2></div></div></div><p>
					Some programming languages, such as <a class="link" href="https://www.gnu.org/software/bash/">bash</a> or <a class="link" href="https://www.python.org/">Python</a>, do not compile to machine code. Instead, their programs' source code is executed step by step, without prior transformations, by a Language Interpreter or a Language Virtual Machine.
				</p><p>
					Software written entirely in interpreted programming languages is not architecture-specific. Hence, the resulting RPM Package has the <code class="literal">noarch</code> string in its name.
				</p><p>
					Interpreted languages are either <a class="link" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#raw-interpreted-code" title="Raw-interpreted programs">Raw-interpreted programs</a> or <a class="link" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#byte-compiled-code" title="Byte-compiled programs">Byte-compiled programs</a>. These two types differ in program build process and in packaging procedure.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="raw-interpreted-code"/>Raw-interpreted programs</h3></div></div></div><p>
						Raw-interpreted language programs do not need to be compiled and are directly executed by the interpreter.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="byte-compiled-code"/>Byte-compiled programs</h3></div></div></div><p>
						Byte-compiled languages need to be compiled into byte code, which is then executed by the language virtual machine.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Some languages offer a choice: they can be raw-interpreted or byte-compiled.
						</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="building-software-from-source_preparing-software-for-rpm-packaging"/>Building software from source</h1></div></div></div><p>
				This part describes how to build software from source code.
			</p><p>
				For software written in compiled languages, the source code goes through a build process, producing machine code. This process, commonly called compiling or translating, varies for different languages. The resulting built software can be run, which makes the computer perform the task specified by the programmer.
			</p><p>
				For software written in raw interpreted languages, the source code is not built, but executed directly.
			</p><p>
				For software written in byte-compiled interpreted languages, the source code is compiled into byte code, which is then executed by the language virtual machine.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="natively-compiled-code-building-software-from-source"/>Natively Compiled Code</h2></div></div></div><p>
					This section shows how to build the <code class="literal">cello.c</code> program written in the C language into an executable.
				</p><p>
					<code class="literal">cello.c</code>
				</p><pre class="literallayout">#include &lt;stdio.h&gt;

int main(void) {
    printf("Hello World\n");
    return 0;
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual-building"/>Manual building</h3></div></div></div><p>
						If you want to build the <code class="literal">cello.c</code> program manually, use this procedure:
					</p><h5><a id="procedure"/>Procedure</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								Invoke the C compiler from the <a class="link" href="https://gcc.gnu.org/">GNU Compiler Collection</a> to compile the source code into binary:
							</p><pre class="literallayout">gcc -g -o cello cello.c</pre></li><li class="listitem"><p class="simpara">
								Execute the resulting output binary <code class="literal">cello</code>:
							</p><pre class="literallayout">$ ./cello
Hello World</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="automated_building"/>Automated building</h3></div></div></div><p>
						Large-scale software commonly uses automated building that is done by creating the <code class="literal">Makefile</code> file and then running the <a class="link" href="http://www.gnu.org/software/make/">GNU <code class="literal">make</code></a> utility.
					</p><p>
						If you want to use the automated building to build the <code class="literal">cello.c</code> program, use this procedure:
					</p><h5><a id="procedure_2"/>Procedure</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								To set up automated building, create the <code class="literal">Makefile</code> file with the following content in the same directory as <code class="literal">cello.c</code>.
							</p><p class="simpara">
								<code class="literal">Makefile</code>
							</p><pre class="literallayout">cello:
gcc -g -o cello cello.c
clean:
rm cello</pre></li><li class="listitem"><p class="simpara">
								To build the software, run the <code class="literal">make</code> command:
							</p><pre class="literallayout">$ make
make: 'cello' is up to date.</pre></li><li class="listitem"><p class="simpara">
								Since there is already a build available, run the <code class="literal">make clean</code> command, and after run the <code class="literal">make</code> command again:
							</p><pre class="literallayout">$ make clean
rm cello

$ make
gcc -g -o cello cello.c</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									Trying to build the program after another build has no effect.
								</p><pre class="literallayout">$ make
make: 'cello' is up to date.</pre></div></li><li class="listitem"><p class="simpara">
								Execute the program:
							</p><pre class="literallayout">$ ./cello
Hello World</pre></li></ol></div><p>
						You have now compiled a program both manually and using a build tool.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="interpreted-code-building-software-from-source"/>Interpreting code</h2></div></div></div><p>
					This section shows how to byte-compile a program written in <a class="link" href="https://www.python.org/">Python</a> and raw-interpret a program written in <a class="link" href="https://www.gnu.org/software/bash/">bash</a>.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						In the two examples below, the <code class="literal">#!</code> line at the top of the file is known as a <span class="strong"><strong>shebang</strong></span>, and is not part of the programming language source code.
					</p><p>
						The <span class="strong"><strong>shebang</strong></span> enables using a text file as an executable: the system program loader parses the line containing the <span class="strong"><strong>shebang</strong></span> to get a path to the binary executable, which is then used as the programming language interpreter. The functionality requires the text file to be marked as executable.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="byte-compiling-code"/>Byte-compiling code</h3></div></div></div><p>
						This section shows how to compile the <code class="literal">pello.py</code> program written in Python into byte code, which is then executed by the Python language virtual machine.
					</p><p>
						Python source code can also be raw-interpreted, but the byte-compiled version is faster. Hence, RPM Packagers prefer to package the byte-compiled version for distribution to end users.
					</p><p>
						<code class="literal">pello.py</code>
					</p><pre class="literallayout">#!/usr/bin/python3

print("Hello World")</pre><p>
						Procedure for byte-compiling programs varies depending on the following factors:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Programming language
							</li><li class="listitem">
								Language’s virtual machine
							</li><li class="listitem">
								Tools and processes used with that language
							</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							<a class="link" href="https://www.python.org/">Python</a> is often byte-compiled, but not in the way described here. The following procedure aims not to conform to the community standards, but to be simple. For real-world Python guidelines, see <a class="link" href="https://docs.python.org/2/library/distribution.html">Software Packaging and Distribution</a>.
						</p></div><p>
						Use this procedure to compile <code class="literal">pello.py</code> into byte code:
					</p><h5><a id="procedure_3"/>Procedure</h5><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								Byte-compile the <code class="literal">pello.py</code> file:
							</p><pre class="literallayout">$ python -m compileall pello.py

$ file pello.pyc
pello.pyc: python 2.7 byte-compiled</pre></li><li class="listitem"><p class="simpara">
								Execute the byte code in <code class="literal">pello.pyc</code>:
							</p><pre class="literallayout">$ python pello.pyc
Hello World</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="raw-interpreting"/>Raw-interpreting code</h3></div></div></div><p>
						This section shows how to raw-interpret the <code class="literal">bello</code> program written in the <a class="link" href="https://www.gnu.org/software/bash/">bash</a> shell built-in language.
					</p><p>
						<code class="literal">bello</code>
					</p><pre class="literallayout">#!/bin/bash

printf "Hello World\n"</pre><p>
						Programs written in shell scripting languages, like <span class="emphasis"><em>bash</em></span>, are raw-interpreted.
					</p><h5><a id="procedure_4"/>Procedure</h5><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
								Make the file with source code executable and run it:
							</p><pre class="literallayout">$ chmod +x bello
$ ./bello
Hello World</pre></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="patching-software_preparing-software-for-rpm-packaging"/>Patching software</h1></div></div></div><p>
				This section explains how to patch the software.
			</p><p>
				In RPM packaging, instead of modifying the original source code, we keep it, and use patches on it.
			</p><p>
				A patch is a source code that updates other source code. It is formatted as a <span class="emphasis"><em>diff</em></span>, because it represents what is different between two versions of the text. A <span class="emphasis"><em>diff</em></span> is created using the <code class="literal">diff</code> utility, which is then applied to the source code using the <a class="link" href="http://savannah.gnu.org/projects/patch/">patch</a> utility.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					Software developers often use Version Control Systems such as <a class="link" href="https://git-scm.com/">git</a> to manage their code base. Such tools provide their own methods of creating diffs or patching software.
				</p></div><p>
				The following example shows how to create a patch from the original source code using <code class="literal">diff</code>, and how to apply the patch using <code class="literal">patch</code>. Patching is used in a later section when creating an RPM; see <a class="xref" href="packaging-software_packaging-and-distributing-software.html#working-with-spec-files" title="Working with SPEC files">the section called “Working with SPEC files”</a>.
			</p><p>
				This procedure shows how to create a patch from the original source code for <code class="literal">cello.c</code>.
			</p><h3><a id="procedure_5"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Preserve the original source code:
					</p><pre class="literallayout">$ cp cello.c cello.c.orig</pre></li><li class="listitem"><p class="simpara">
						Modify <code class="literal">cello.c</code> as needed:
					</p><pre class="literallayout">#include &lt;stdio.h&gt;

int main(void) {
    printf("Hello World from my very first patch!\n");
    return 0;
}</pre></li><li class="listitem"><p class="simpara">
						Generate a patch using the <code class="literal">diff</code> utility:
					</p><pre class="literallayout">$ diff -Naur cello.c.orig cello.c
--- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
+ cello.c     2016-05-27 14:53:20.668588245 -0500
@@ -1,6 +1,6 @@
 #include&lt;stdio.h&gt;

 int main(void){
-    printf("Hello World!\n");
+    printf("Hello World from my very first patch!\n");
     return 0;
 }
\ No newline at end of file</pre><p class="simpara">
						Lines starting with a <code class="literal">-</code> are removed from the original source code and replaced with the lines that start with <code class="literal">+</code>.
					</p><p class="simpara">
						For more information on common arguments for the <code class="literal">diff</code> utility, see the <code class="literal">diff</code> manual page.
					</p></li><li class="listitem"><p class="simpara">
						Save the patch to a file:
					</p><pre class="literallayout">$ diff -Naur cello.c.orig cello.c &gt; cello-output-first-patch.patch</pre></li><li class="listitem"><p class="simpara">
						Restore the original <code class="literal">cello.c</code>:
					</p><pre class="literallayout">$ cp cello.c.orig cello.c</pre><p class="simpara">
						The original <code class="literal">cello.c</code> must be retained, because when an RPM is built, the original file is used, not the modified one. For more information, see <a class="xref" href="packaging-software_packaging-and-distributing-software.html#working-with-spec-files" title="Working with SPEC files">the section called “Working with SPEC files”</a>.
					</p></li></ol></div><p>
				The following procedure shows how to patch <code class="literal">cello.c</code> using <code class="literal">cello-output-first-patch.patch</code>, built the patched program, and run it.
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Redirect the patch file to the <code class="literal">patch</code> command:
					</p><pre class="literallayout">$ patch &lt; cello-output-first-patch.patch
patching file cello.c</pre></li><li class="listitem"><p class="simpara">
						Check that the contents of <code class="literal">cello.c</code> now reflect the patch:
					</p><pre class="literallayout">$ cat cello.c
#include&lt;stdio.h&gt;

int main(void){
    printf("Hello World from my very first patch!\n");
    return 1;
}</pre></li><li class="listitem"><p class="simpara">
						Build and run the patched <code class="literal">cello.c</code>:
					</p><pre class="literallayout">$ make clean
rm cello

$ make
gcc -g -o cello cello.c

$ ./cello
Hello World from my very first patch!</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="installing-arbitrary-artifacts_preparing-software-for-rpm-packaging"/>Installing arbitrary artifacts</h1></div></div></div><p>
				Unix-like systems use the Filesystem Hierarchy Standard (FHS) to specify a directory suitable for a particular file.
			</p><p>
				Files installed from the RPM packages are placed according to FHS. For example, an executable file should go into a directory that is in the system <code class="literal">$PATH</code> variable.
			</p><p>
				In the context of this documentation, an <span class="emphasis"><em>Arbitrary Artifact</em></span> is anything installed from an RPM to the system. For RPM and for the system it can be a script, a binary compiled from the package’s source code, a pre-compiled binary, or any other file.
			</p><p>
				This section describes two common ways of placing <span class="emphasis"><em>Arbitrary Artifacts</em></span> in the system:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#install-command" title="Using the install command">the section called “Using the install command”</a>
					</li><li class="listitem">
						<a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#make-install" title="Using the make install command">the section called “Using the make install command”</a>
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="install-command"/>Using the install command</h2></div></div></div><p>
					Packagers often use the <code class="literal">install</code> command in cases when build automation tooling such as <a class="link" href="http://www.gnu.org/software/make/">GNU make</a> is not optimal; for example if the packaged program does not need extra overhead.
				</p><p>
					The <code class="literal">install</code> command is provided to the system by <a class="link" href="http://www.gnu.org/software/coreutils/coreutils.html">coreutils</a>, which places the artifact to the specified directory in the file system with a specified set of permissions.
				</p><p>
					The following procedure uses the <code class="literal">bello</code> file that was previously created as the arbitrary artifact as a subject to this installation method.
				</p><h3><a id="procedure_6"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Run the <code class="literal">install</code> command to place the <code class="literal">bello</code> file into the <code class="literal">/usr/bin</code> directory with permissions common for executable scripts:
						</p><pre class="literallayout">$ sudo install -m 0755 bello /usr/bin/bello</pre><p class="simpara">
							As a result, <code class="literal">bello</code> is now located in the directory that is listed in the <code class="literal">$PATH</code> variable.
						</p></li><li class="listitem"><p class="simpara">
							Execute <code class="literal">bello</code> from any directory without specifying its full path:
						</p><pre class="literallayout">$ cd ~

$ bello
Hello World</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="make-install"/>Using the make install command</h2></div></div></div><p>
					Using the <code class="literal">make install</code> command is an automated way to install built software to the system. In this case, you need to specify how to install the arbitrary artifacts to the system in the <code class="literal">Makefile</code> that is usually written by the developer.
				</p><p>
					This procedure shows how to install a build artifact into a chosen location on the system.
				</p><h3><a id="procedure_7"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Add the <code class="literal">install</code> section to the <code class="literal">Makefile</code>:
						</p><p class="simpara">
							<code class="literal">Makefile</code>
						</p><pre class="literallayout">cello:
gcc -g -o cello cello.c

clean:
rm cello

install:
mkdir -p $(DESTDIR)/usr/bin
install -m 0755 cello $(DESTDIR)/usr/bin/cello</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The <a class="link" href="https://www.gnu.org/software/make/manual/html_node/DESTDIR.html">$(DESTDIR)</a> variable is a <a class="link" href="http://www.gnu.org/software/make/">GNU make</a> built-in and is commonly used to specify installation to a directory different than the root directory.
							</p></div><p class="simpara">
							Now you can use <code class="literal">Makefile</code> not only to build software, but also to install it to the target system.
						</p></li><li class="listitem"><p class="simpara">
							Build and install the <code class="literal">cello.c</code> program:
						</p><pre class="literallayout">$ make
gcc -g -o cello cello.c

$ sudo make install
install -m 0755 cello /usr/bin/cello</pre><p class="simpara">
							As a result, <code class="literal">cello</code> is now located in the directory that is listed in the <code class="literal">$PATH</code> variable.
						</p></li><li class="listitem"><p class="simpara">
							Execute <code class="literal">cello</code> from any directory without specifying its full path:
						</p><pre class="literallayout">$ cd ~

$ cello
Hello World</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="preparing-source-code-for-packaging_preparing-software-for-rpm-packaging"/>Preparing source code for packaging</h1></div></div></div><p>
				Developers often distribute software as compressed archives of source code, which are then used to create packages. RPM packagers work with a ready source code archive.
			</p><p>
				Software should be distributed with a software license.
			</p><p>
				This procedure uses the <a class="link" href="https://www.gnu.org/licenses/quick-guide-gplv3.html">GPLv3</a> license text as an example content of the <code class="literal">LICENSE</code> file.
			</p><h3><a id="procedure_8"/>Procedure</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
						Create a <code class="literal">LICENSE</code> file, and make sure that it includes the following content:
					</p><pre class="literallayout">$ cat /tmp/LICENSE
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see <a class="link" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</pre></li></ul></div><h3><a id="additional_resources"/>Additional resources</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						The code created in this section can be found <a class="link" href="https://github.com/redhat-developer/rpm-packaging-guide/tree/master/example-code">here</a>.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="putting-source-code-into-tarball_preparing-software-for-rpm-packaging"/>Putting source code into tarball</h1></div></div></div><p>
				This section describes how to put each of the three <code class="literal">Hello World</code> programs introduced in <a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#source-code-examples" title="Source code examples">the section called “Source code examples”</a> into a <a class="link" href="https://www.gnu.org/software/gzip/">gzip</a>-compressed tarball, which is a common way to release the software to be later packaged for distribution.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="bello"/>Putting the bello project into tarball</h2></div></div></div><p>
					The <span class="emphasis"><em>bello</em></span> project implements <code class="literal">Hello World</code> in <a class="link" href="https://www.gnu.org/software/bash/">bash</a>. The implementation only contains the <code class="literal">bello</code> shell script, so the resulting <code class="literal">tar.gz</code> archive will have only one file apart from the <code class="literal">LICENSE</code> file.
				</p><p>
					This procedure shows how to prepare the <span class="emphasis"><em>bello</em></span> project for distribution.
				</p><h3><a id="prerequisites"/>Prerequisites</h3><p>
					Considering that this is version <code class="literal">0.1</code> of the program.
				</p><h3><a id="procedure_9"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Put all required files into a single directory:
						</p><pre class="literallayout">$ mkdir /tmp/bello-0.1

$ mv ~/bello /tmp/bello-0.1/

$ cp /tmp/LICENSE /tmp/bello-0.1/</pre></li><li class="listitem"><p class="simpara">
							Create the archive for distribution and move it to the <code class="literal">~/rpmbuild/SOURCES/</code> directory:
						</p><pre class="literallayout">$ cd /tmp/

$ tar -cvzf bello-0.1.tar.gz bello-0.1
bello-0.1/
bello-0.1/LICENSE
bello-0.1/bello

$ mv /tmp/bello-0.1.tar.gz ~/rpmbuild/SOURCES/</pre></li></ol></div><h3><a id="additional_resources_2"/>Additional resources</h3><p>
					For more information about the example source code written in bash, see <a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-bash" title="Hello World written in bash">the section called “Hello World written in bash”</a>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="pello"/>Putting the pello project into tarball</h2></div></div></div><p>
					The <span class="emphasis"><em>pello</em></span> project implements <code class="literal">Hello World</code> in <a class="link" href="https://www.python.org/">Python</a>. The implementation only contains the <code class="literal">pello.py</code> program, so the resulting <code class="literal">tar.gz</code> archive will have only one file apart from the <code class="literal">LICENSE</code> file.
				</p><p>
					This procedure shows how to prepare the <span class="emphasis"><em>pello</em></span> project for distribution.
				</p><h3><a id="prerequisites_2"/>Prerequisites</h3><p>
					Considering that this is version <code class="literal">0.1.1</code> of the program.
				</p><h3><a id="procedure_10"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Put all required files into a single directory:
						</p><pre class="literallayout">$ mkdir /tmp/pello-0.1.2

$ mv ~/pello.py /tmp/pello-0.1.2/

$ cp /tmp/LICENSE /tmp/pello-0.1.2/</pre></li><li class="listitem"><p class="simpara">
							Create the archive for distribution and move it to the <code class="literal">~/rpmbuild/SOURCES/</code> directory:
						</p><pre class="literallayout">$ cd /tmp/

$ tar -cvzf pello-0.1.2.tar.gz pello-0.1.2
pello-0.1.2/
pello-0.1.2/LICENSE
pello-0.1.2/pello.py

$ mv /tmp/pello-0.1.2.tar.gz ~/rpmbuild/SOURCES/</pre></li></ol></div><h3><a id="additional_resources_3"/>Additional resources</h3><p>
					For more information about the example source code written in Python, see <a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-python" title="Hello World written in Python">the section called “Hello World written in Python”</a>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="cello"/>Putting the cello project into tarball</h2></div></div></div><p>
					The <span class="emphasis"><em>cello</em></span> project implements <code class="literal">Hello World</code> in C. The implementation only contains the <code class="literal">cello.c</code> and the <code class="literal">Makefile</code> files, so the resulting <code class="literal">tar.gz</code> archive will have two files apart from the <code class="literal">LICENSE</code> file.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The <code class="literal">patch</code> file is not distributed in the archive with the program. The RPM Packager applies the patch when the RPM is built. The patch will be placed into the <code class="literal">~/rpmbuild/SOURCES/</code> directory alongside the <code class="literal">.tar.gz</code> archive.
					</p></div><p>
					This procedure shows how to prepare the <span class="emphasis"><em>cello</em></span> project for distribution.
				</p><h3><a id="prerequisites_3"/>Prerequisites</h3><p>
					Considering that this is version <code class="literal">1.0</code> of the program.
				</p><h3><a id="procedure_11"/>Procedure</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Put all required files into a single directory:
						</p><pre class="literallayout">$ mkdir /tmp/cello-1.0

$ mv ~/cello.c /tmp/cello-1.0/

$ mv ~/Makefile /tmp/cello-1.0/

$ cp /tmp/LICENSE /tmp/cello-1.0/</pre></li><li class="listitem"><p class="simpara">
							Create the archive for distribution and move it to the <code class="literal">~/rpmbuild/SOURCES/</code> directory:
						</p><pre class="literallayout">$ cd /tmp/

$ tar -cvzf cello-1.0.tar.gz cello-1.0
cello-1.0/
cello-1.0/Makefile
cello-1.0/cello.c
cello-1.0/LICENSE

$ mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/</pre></li><li class="listitem"><p class="simpara">
							Add the patch:
						</p><pre class="literallayout">$ mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/</pre></li></ol></div><h3><a id="additional_resources_4"/>Additional resources</h3><p>
					For more information about the example source code written in C, see <a class="xref" href="preparing-software-for-rpm-packaging_packaging-and-distributing-software.html#hello-world-c" title="Hello World written in C">the section called “Hello World written in C”</a>.
				</p></div></div></div></body></html>