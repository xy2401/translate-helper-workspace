<html id="06175.using-consolidated-database-replay.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Database Replay enables you to capture a workload on the production system and replay it on a test system. This can be very useful when evaluating or adopting new database technologies because these changes can be tested on a test system without affecting the production system."></meta>
      <meta name="description" content="Database Replay enables you to capture a workload on the production system and replay it on a test system. This can be very useful when evaluating or adopting new database technologies because these changes can be tested on a test system without affecting the production system."></meta>
      <title>使用Consolidated Database Replay</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Testing Guide "></meta>
      <meta property="og:description" content="Database Replay enables you to capture a workload on the production system and replay it on a test system. This can be very useful when evaluating or adopting new database technologies because these changes can be tested on a test system without affecting the production system."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Testing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="testing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-07T01:43:11-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96279-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-workload-intelligence.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-workload-scale-up.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Testing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="RATUG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-workload-intelligence.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-workload-scale-up.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">测试指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="database-replay.html" property="item" typeof="WebPage"><span property="name">数据库重播</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用Consolidated Database Replay</li>
            </ol>
            <a id="GUID-62AAF505-1DD4-414A-9F1D-4386B59B7138" name="GUID-62AAF505-1DD4-414A-9F1D-4386B59B7138"></a><a id="RATUG4080"></a>
            
            <h2 id="RATUG-GUID-62AAF505-1DD4-414A-9F1D-4386B59B7138" class="sect2"><span class="enumeration_chapter">15</span>使用Consolidated Database Replay</h2>
         </header>
         <div class="ind">
            <div>
               <div><span>通过数据库重放，您可以捕获生产系统上的工作负载并在测试系统上重放它。这在评估或采用新数据库技术时非常有用，因为这些更改可以在测试系统上进行测试，而不会影响生产系统。</span> 但是，如果正在测试的新系统提供比现有系统明显更好的性能，则数据库重放可能无法准确预测新系统可以处理多少额外工作负载。
               </div>
               <p>例如，如果要将多个生产系统整合到单个Oracle Exadata计算机中，则重放从Oracle Exadata计算机上的某个现有系统捕获的工作负载可能会在重放期间导致资源使用率降低（例如主机CPU和I / O）因为新系统功能更强大。在这种情况下，评估新系统如何处理来自所有现有系统的组合工作负载，而不是来自一个系统的单个工作负载的工作负载更为有用。</p>
               <p><a id="d31544e81" class="indexterm-anchor"></a>通过Consolidated Database Replay，您可以整合从一个或多个系统捕获的多个工作负载，并在单个测试系统上同时重放这些工作负载。在此示例中，使用Consolidated Database Replay将帮助您评估数据库整合将如何影响生产系统，以及单个Oracle Exadata计算机是否可以处理来自统一数据库的组合工作负载。
               </p>
               <p>本章介绍如何使用Consolidated Database Replay并包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-CA75813D-10DB-4635-B127-6747CEC0C6D8" title="通过统一数据库重放，您可以同时重播从一个或多个系统捕获的多个工作负载。">用例进行统一数据库重放</a></p>
                  </li>
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-ED30A383-7236-44C7-9DD0-A9FC4F75F686" title="本节介绍使用Consolidated Workload Replay时涉及的步骤。">使用统一数据库重播的步骤</a></p>
                  </li>
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-BBC96414-F08A-4D57-BA72-B28C1BBEE9F2" title="本节介绍如何将Consolidated Database Replay与Enterprise Manager一起使用。">在企业管理器中使用Consolidated Database Replay</a></p>
                  </li>
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建和重播整合的工作负载。">使用Consolidated Database Replay和API</a></p>
                  </li>
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8" title="在仅查询数据库重放中，仅重播工作负载捕获的只读查询。换句话说，在仅查询重放中，只有SELECT语句在重放时发送到服务器。在仅查询重放期间不执行DML语句，并且重放不会对用户模式或数据进行任何更改。">关于仅查询数据库重播</a></p>
                  </li>
                  <li>
                     <p><a href="using-consolidated-database-replay.html#GUID-29988B63-F974-46EF-9AAD-3D04AF774337" title="本节假设一个场景，来自三个独立生产系统的工作负载在不同操作系统上运行不同版本的Oracle数据库。">示例：使用API重播Consolidated Workload</a></p>
                  </li>
               </ul>
            </div><a id="RATUG4082"></a><div class="props_rev_3"><a id="GUID-CA75813D-10DB-4635-B127-6747CEC0C6D8" name="GUID-CA75813D-10DB-4635-B127-6747CEC0C6D8"></a><h3 id="RATUG-GUID-CA75813D-10DB-4635-B127-6747CEC0C6D8" class="sect3"><span class="enumeration_section">15.1</span>统一数据库重放的用例</h3>
               <div>
                  <div><span>通过统一数据库重放，您可以同时重播从一个或多个系统捕获的多个工作负载。</span> 在重放期间，合并重播开始时，合并的每个工作负载捕获都将开始重放。
                  </div>
                  <p>整合数据库重放的一些典型用例包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-42958859-005D-4B93-9DD3-79807968EA9E" title="统一数据库重放的一个用途是评估系统是否可以处理来自数据库整合的组合工作负载。">使用可插拔数据库进行数据库整合</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-A2836514-C2B9-4170-B76F-DA8E4B298C2B" title="Consolidated Database Replay的另一个用途是用于压力测试或容量规划。">压力测试</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-0A835930-BD73-4C32-AC02-35D2E21AF725" title="Consolidated Database Replay的第三个用途是用于扩展测试。">放大测试</a></p>
                     </li>
                  </ul>
                  <p>可以使用本章中描述的过程执行这些用例中的每一个。此外，在使用Consolidated Database Replay时，您可以使用各种工作负载扩展技术，如<a href="using-workload-scale-up.html#GUID-6EE876DA-F6E0-435A-8728-CFDA1AFD1FF0" title="本章介绍如何使用各种工作负载扩展技术和Consolidated Database Replay。">使用Workload Scale-Up中所述</a> 。
                  </p>
               </div><a id="RATUG4199"></a><div class="props_rev_3"><a id="GUID-42958859-005D-4B93-9DD3-79807968EA9E" name="GUID-42958859-005D-4B93-9DD3-79807968EA9E"></a><h4 id="RATUG-GUID-42958859-005D-4B93-9DD3-79807968EA9E" class="sect4"><span class="enumeration_section">15.1.1</span>使用可插拔数据库进行数据库整合</h4>
                  <div>
                     <p>统一数据库重放的一个用途是评估系统是否可以处理来自数据库整合的组合工作负载。</p>
                     <p>例如，假设您希望通过将它们迁移到可插拔数据库（PDB）来合并CRM，ERP和SCM应用程序的数据库。您可以使用Consolidated Database Replay组合三个应用程序中捕获的工作负载，并在PDB上同时重放它们。</p>
                     <div class="infoboxnotealso" id="GUID-42958859-005D-4B93-9DD3-79807968EA9E__GUID-3EE5DD0E-B6F9-4E27-BEE9-D37D734EB6B2">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-29988B63-F974-46EF-9AAD-3D04AF774337" title="本节假设一个场景，来自三个独立生产系统的工作负载在不同操作系统上运行不同版本的Oracle数据库。">示例：使用API重播Consolidated Workload</a> ”</span>作为此用例的示例</p>
                     </div>
                  </div>
               </div><a id="RATUG4200"></a><div class="props_rev_3"><a id="GUID-A2836514-C2B9-4170-B76F-DA8E4B298C2B" name="GUID-A2836514-C2B9-4170-B76F-DA8E4B298C2B"></a><h4 id="RATUG-GUID-A2836514-C2B9-4170-B76F-DA8E4B298C2B" class="sect4"><span class="enumeration_section">15.1.2</span>压力测试</h4>
                  <div>
                     <p>Consolidated Database Replay的另一个用途是用于压力测试或容量规划。</p>
                     <p>例如，假设您希望Sales应用程序的工作负载在假日期间翻倍。您可以使用Consolidated Database Replay通过将工作负载加倍并重放组合工作负载来测试系统上的额外压力。</p>
                     <div class="infoboxnotealso" id="GUID-A2836514-C2B9-4170-B76F-DA8E4B298C2B__GUID-721FA44F-2680-47A0-ACEF-9EC7267391C2">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="using-workload-scale-up.html#GUID-A8D66BDD-5B60-4A0D-81E8-FF88D9F68A49" title="本节介绍如何使用Consolidated Database Replay进行时移，并假设您希望使用时移来协调从三个应用程序捕获的工作负载峰值并同时重放它们。">使用时间转换</a> ”</span>作为此用例的示例</p>
                     </div>
                  </div>
               </div><a id="RATUG4201"></a><div class="props_rev_3"><a id="GUID-0A835930-BD73-4C32-AC02-35D2E21AF725" name="GUID-0A835930-BD73-4C32-AC02-35D2E21AF725"></a><h4 id="RATUG-GUID-0A835930-BD73-4C32-AC02-35D2E21AF725" class="sect4"><span class="enumeration_section">15.1.3放大</span>测试</h4>
                  <div>
                     <p>Consolidated Database Replay的第三个用途是用于扩展测试。</p>
                     <p>例如，假设您要测试您的系统是否可以同时处理Financials应用程序和Orders应用程序中捕获的工作负载。您可以使用Consolidated Database Replay通过组合工作负载并同时重放它们来测试扩展工作负载对系统的影响。</p>
                     <div class="infoboxnotealso" id="GUID-0A835930-BD73-4C32-AC02-35D2E21AF725__GUID-2AABD94E-E630-4F44-BBD1-A817F1CD367F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="using-workload-scale-up.html#GUID-8564F1A9-E002-45DB-B049-6AABB3A88B82" title="本节介绍如何使用Consolidated Database Replay进行模式重新映射，并假设您希望在部署应用程序的多个实例时使用模式重新映射来识别可能的主机瓶颈。">使用架构重映射</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="using-workload-scale-up.html#GUID-756772FF-1F7E-4EB5-AFB5-152CB3DF6704" title="本节介绍如何使用Consolidated Database Replay使用工作负载折叠，并假设您希望使用工作负载折叠将捕获的工作负载增加三倍。该场景演示了如何使用工作负载折叠进行向上扩展测试。">使用工作负载折叠</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="RATUG4081"></a><div class="props_rev_3"><a id="GUID-ED30A383-7236-44C7-9DD0-A9FC4F75F686" name="GUID-ED30A383-7236-44C7-9DD0-A9FC4F75F686"></a><h3 id="RATUG-GUID-ED30A383-7236-44C7-9DD0-A9FC4F75F686" class="sect3"><span class="enumeration_section">15.2</span>使用统一数据库重播的步骤</h3>
               <div>
                  <div><span>本节介绍使用Consolidated Workload Replay时涉及的步骤。</span> 它包含以下主题：</div>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-29DEF1D4-AA77-4BF5-938E-52EFC666D47C" title="统一数据库重放不需要任何特殊步骤来捕获数据库工作负载。">捕获数据库工作负载以进行统一数据库重放</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667" title="为Consolidated Database Replay设置测试系统类似于为数据库重放设置测试系统。">设置统一数据库重放的测试系统</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-E8EB57F8-8977-47FA-8FD4-B2C528CE7FE4" title="为Consolidated Database Replay预处理数据库工作负载与为数据库重放预处理数据库工作负载类似。">为综合数据库重放预处理数据库工作负载</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-BFC7713A-5BEB-4A2E-9B0F-9F43A983BC6C" title="使用Consolidated Database Replay重播整合的工作负载与使用Database Replay重放单个数据库工作负载完全不同。">重播数据库工作负载以进行统一数据库重放</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954" title="使用重播比较期间报告执行统一数据库重放的报告和分析。看到" ="">统一数据库重放的报告和分析</a></p>
                     </li>
                  </ul>
               </div><a id="RATUG4086"></a><div class="props_rev_3"><a id="GUID-29DEF1D4-AA77-4BF5-938E-52EFC666D47C" name="GUID-29DEF1D4-AA77-4BF5-938E-52EFC666D47C"></a><h4 id="RATUG-GUID-29DEF1D4-AA77-4BF5-938E-52EFC666D47C" class="sect4"><span class="enumeration_section">15.2.1</span>捕获数据库工作负载以进行统一数据库重放</h4>
                  <div>
                     <div><span>统一数据库重放不需要任何特殊步骤来捕获数据库工作负载。</span> 捕获数据库工作负载的步骤与捕获数据库重放的单个工作负载完全相同，如<a href="capturing-a-database-workload.html#GUID-E774C161-98C0-43EF-8B78-DD74E2A2A219" title="本章介绍如何在生产系统上捕获数据库工作负载。">捕获数据库工作负载中所述</a> 。
                     </div>
                     <p>本节包含以下有关特定于Consolidated Database Replay的工作负载捕获的主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-180A4527-003B-4441-8FE7-524A2206FB54" title="Consolidated Database Replay支持从一个或多个操作系统上运行Oracle Database 9i第2版（版本9.2.0.8.0）或更高版本的一个或多个系统捕获的多个工作负载。">支持的工作负载类型</a></p>
                        </li>
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8" title="通过Consolidated Database Replay，您可以将现有工作负载捕获转换为新的较小的捕获子集。">捕获子集</a></p>
                        </li>
                     </ul>
                  </div><a id="RATUG4087"></a><div class="props_rev_3"><a id="GUID-180A4527-003B-4441-8FE7-524A2206FB54" name="GUID-180A4527-003B-4441-8FE7-524A2206FB54"></a><h5 id="RATUG-GUID-180A4527-003B-4441-8FE7-524A2206FB54" class="sect5"><span class="enumeration_section">15.2.1.1</span>支持的工作负载类型</h5>
                     <div>
                        <div><span>Consolidated Database Replay支持从一个或多个操作系统上运行Oracle Database 9 <span class="italic">i</span> Release 2（版本9.2.0.8.0）或更高版本的一个或多个系统捕获的多个工作负载。</span> 例如，您可以在AIX上使用从运行Oracle Database 9 <span class="italic">i</span> Release 2（版本9.2.0.8.0）的一个系统捕获的工作负载，以及在AIX上运行Oracle Database <span class="italic">10g</span>第2版（版本10.2.0.4.0）的另一个系统。</div>
                        <div class="infoboxnote" id="GUID-180A4527-003B-4441-8FE7-524A2206FB54__GUID-3D39C9AB-52AD-4AF2-B52C-4A5131DB8D62">
                           <p class="notep1">注意：</p>
                           <p>统一数据库重放仅适用于Oracle Database <span class="italic">11g</span>第2版（版本11.2.0.2.0）及更高版本。
                           </p>
                        </div>
                     </div>
                  </div><a id="RATUG4088"></a><div class="props_rev_3"><a id="GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8" name="GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8"></a><h5 id="RATUG-GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8" class="sect5"><span class="enumeration_section">15.2.1.2</span>捕获子集</h5>
                     <div>
                        <div><span>通过Consolidated Database Replay，您可以将现有工作负载捕获转换为新的较小的捕获子集。</span> 然后，您可以从可在不同用例中使用的捕获子集生成新的工作负载捕获，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CA75813D-10DB-4635-B127-6747CEC0C6D8" title="通过统一数据库重放，您可以同时重播从一个或多个系统捕获的多个工作负载。">使用整合数据库重放的用例</a> ”中所述</span> 。
                        </div>
                        <p><span class="bold">捕获子集</span>是工作负载捕获的一部分，通过应用时间范围从现有工作负载捕获定义。时间范围指定为从工作负载捕获开始的偏移量。在指定时间范围内捕获的所有用户工作负载都包含在定义的捕获子集中。
                        </p>
                        <p>例如，假设从上午2点到晚上8点捕获工作负载，并确定峰值工作负载从上午10点到下午4点。您可以通过应用从8小时开始的时间范围来定义捕获子集以表示峰值工作负载工作量开始后（或上午10点），并在工作量开始后14小时（或下午4点）结束。</p>
                        <p>但是，如果捕获子集仅包含满足指定时间范围的记录用户工作负载，则不会记录在指定时间范围之前发生的用户登录。如果重放需要这些用户登录，则捕获子集可能无法重播。例如，如果用户会话在上午9:30开始并在上午10:30结束，并且捕获子集的指定时间范围是上午10:00到下午4:00，则如果用户登录为9，则重播可能会失败。 ：工作量不包括上午30点。类似地，指定的时间范围还可以包括仅在用户会话在下午3:30开始但直到下午4:30才完成的部分记录的不完整用户呼叫。</p>
                        <p>Consolidated Database Replay通过仅包含由指定时间范围的开始时间引起的不完整用户调用来解决此问题。如果折叠工作负载捕获，则避免将相同的不完整用户调用包括两次，默认情况下<span class="italic">不</span>包括由结束时间引起的不完整用户调用。因此，捕获子集基本上是在正确重放所需的指定时间范围内记录的用户调用的最小数量，包括必要的用户登录，更改会话语句和由开始时间引起的不完整的用户调用。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8__GUID-43ACD249-5A94-411D-B55B-5FC6EA5BAB9A">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包从现有工作负载捕获生成捕获子集。">使用API生成捕获子集</a> ”</span></p>
                        </div>
                     </div>
                  </div>
               </div><a id="RATUG4091"></a><a id="RATUG4090"></a><div class="props_rev_3"><a id="GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667" name="GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667"></a><h4 id="RATUG-GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667" class="sect4"><span class="enumeration_section">15.2.2</span>设置统一数据库重播的测试系统</h4>
                  <div>
                     <div><span>为Consolidated Database Replay设置测试系统类似于为数据库重放设置测试系统。</span> 但是，在为Consolidated Database Replay设置重播数据库时还有一些其他注意事项。有关为数据库重放设置测试系统的详细信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-EA0C0608-0B0C-4D2B-B6A4-2B8FFC548F8F" title="正确准备重播系统和规划工作负载重放可确保重放准确。">重播数据库工作负载的步骤</a> ”</span> 。
                     </div>
                     <p>为了最大限度地减少重放过程中的分歧，测试系统应包含相同的应用程序数据，并且应用程序数据的状态在逻辑上应与每个工作负载捕获开始时捕获系统的状态等效。但是，由于合并捕获可能包含来自不同生产系统的多个工作负载捕获，因此需要为所有捕获设置测试系统。在这种情况下，建议使用多租户架构来整合多个数据库，以便每个数据库在捕获开始时具有与其捕获系统等效的数据。</p>
                     <p>对于Consolidated Database Replay，所有参与的工作负载捕获必须放在测试系统上的新捕获目录下。您可以将所有工作负载捕获复制到新的<a id="d31544e1083" class="indexterm-anchor"></a>捕获目录，或创建指向原始工作负载捕获的符号链接。在合并工作负载捕获之前，请确保新的捕获目录具有足够的磁盘空间来存储所有参与的捕获。
                     </p>
                     <p><a href="using-consolidated-database-replay.html#GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667__CHDEFCDA">图15-1</a>说明了如何设置测试系统和新的捕获目录以合并三个工作负载捕获。
                     </p>
                     <div class="figure" id="GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667__CHDEFCDA">
                        <p class="titleinfigure">图15-1设置统一数据库重放的测试系统</p><img src="img/ratug004.png" width="279" alt="下面是图15-1的描述" title="下面是图15-1的描述" longdesc="img_text/ratug004.html"><br><a href="img_text/ratug004.html">“图15-1设置统一数据库重放测试系统”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667__GUID-C9AEA61F-FC73-49D6-9614-D130925F9A09">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包在测试系统上设置统一重播目录。">使用API设置合并重播目录</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关多租户架构的信息，请参见<a href="../multi/introduction-to-the-multitenant-architecture.html#CNCPT89234" target="_blank"><span><cite>Oracle数据库概念</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="RATUG4089"></a><div class="props_rev_3"><a id="GUID-E8EB57F8-8977-47FA-8FD4-B2C528CE7FE4" name="GUID-E8EB57F8-8977-47FA-8FD4-B2C528CE7FE4"></a><h4 id="RATUG-GUID-E8EB57F8-8977-47FA-8FD4-B2C528CE7FE4" class="sect4"><span class="enumeration_section">15.2.3</span>为综合数据库重放预处理数据库工作负载</h4>
                  <div>
                     <div><span>为Consolidated Database Replay预处理数据库工作负载与为数据库重放预处理数据库工作负载类似。</span> 有关为数据库重放预处理数据库工作负载的信息，请参阅<span class="q">“ <a href="preprocessing-a-database-workload.html#GUID-4CEE2F79-F5A7-4EBA-9018-0CB99AB51C0A" title="捕获工作负载并完成测试系统的设置后，必须预处理捕获的数据。">预处理数据库工作负载</a> ”</span> 。
                     </div>
                     <p>对于Consolidated Database Replay，将每个捕获的工作负载预处理到其自己的目录中。不要将不同的工作负载捕获组合到一个目录中进行预处理。必须使用运行与将重放工作负载的测试系统相同版本的Oracle数据库的数据库来执行捕获的工作负载的预处理。</p>
                  </div>
               </div><a id="RATUG4092"></a><div class="props_rev_3"><a id="GUID-BFC7713A-5BEB-4A2E-9B0F-9F43A983BC6C" name="GUID-BFC7713A-5BEB-4A2E-9B0F-9F43A983BC6C"></a><h4 id="RATUG-GUID-BFC7713A-5BEB-4A2E-9B0F-9F43A983BC6C" class="sect4"><span class="enumeration_section">15.2.4</span>重播数据库工作负载以进行统一数据库重放</h4>
                  <div>
                     <p>使用Consolidated Database Replay重播整合的工作负载与使用Database Replay重放单个数据库工作负载完全不同。</p>
                     <p>本节包含有关重放特定于Consolidated Database Replay的工作负载的以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A" title="重播计划将一个或多个工作负载捕获添加到统一重播，并指定捕获在重放期间开始的顺序。">定义重播计划</a></p>
                        </li>
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9" title="与使用数据库重放重放单个数据库工作负载的情况一样，用于连接到生产系统的捕获的连接字符串需要重新映射到重放系统。">重新映射统一数据库重播的连接</a></p>
                        </li>
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-48411BB5-E585-4783-B016-72DCD97074CE" title="与使用数据库重放重放单个数据库工作负载的情况一样，可以在重放期间重新映射用于连接到生产系统的数据库用户和模式的用户名。看到" ="">重新映射用户以进行统一数据库重播</a></p>
                        </li>
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE" title="与使用数据库重放重放单个数据库工作负载的情况一样，在准备重播期间定义了重播选项。">准备合并数据库重播</a></p>
                        </li>
                        <li>
                           <p><a href="using-consolidated-database-replay.html#GUID-C0629657-BFE2-48AB-8BF6-E1EBBCEB79EE" title="建议在重播统一工作负载之前单独重播每个参与的工作负载。">重播个人工作量</a></p>
                        </li>
                     </ul>
                  </div><a id="RATUG4093"></a><div class="props_rev_3"><a id="GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A" name="GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A"></a><h5 id="RATUG-GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A" class="sect5"><span class="enumeration_section">15.2.4.1</span>定义重播计划</h5>
                     <div>
                        <div><span><span class="bold">重播计划</span>将一个或多个工作负载捕获添加到统一重播，并指定捕获在重放期间开始的顺序。</span> 必须先创建重播计划，然后才能初始化整合重播。可以为整合重播定义多个重播计划。在重放初始化期间，您可以从任何现有的重播计划中进行选择。
                        </div>
                        <p>重播计划执行两种类型的操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-consolidated-database-replay.html#GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70" title="重放计划执行的第一种操作是将参与的工作负载捕获添加到重放。">添加工作量捕获</a></p>
                           </li>
                           <li>
                              <p><a href="using-consolidated-database-replay.html#GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA" title="重播计划执行的第二种操作是添加计划订单，指定参与工作负载捕获在重放期间开始的顺序。">添加计划订单</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A__GUID-E9D32462-7C44-427F-87D6-1157183438F2">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包定义重播计划。">使用API定义重播计划</a> ”</span></p>
                        </div>
                     </div><a id="RATUG4094"></a><div class="props_rev_3"><a id="GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70" name="GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70"></a><h6 id="RATUG-GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70" class="sect6"><span class="enumeration_section">15.2.4.1.1</span>添加工作量捕获</h6>
                        <div>
                           <p>重放计划执行的第一种操作是将参与的工作负载捕获添加到重放。</p>
                           <p>将工作负载捕获添加到重播计划时，将返回唯一编号以标识工作负载捕获。工作负载捕获可以多次添加到重放计划中，因为每次添加时都会为其分配不同的捕获编号。重放计划每次都指向相同的捕获目录，以避免每次添加捕获时复制捕获所浪费磁盘空间。</p>
                           <div class="infoboxnotealso" id="GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70__GUID-C33A7BE0-BE78-4C77-BEBC-EB5A511FFA0C">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载捕获重播计划</a> ”</span></p>
                           </div>
                        </div>
                     </div><a id="RATUG4095"></a><div class="props_rev_3"><a id="GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA" name="GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA"></a><h6 id="RATUG-GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA" class="sect6"><span class="enumeration_section">15.2.4.1.2</span>添加计划订单</h6>
                        <div>
                           <p>重播计划执行的第二种操作是添加计划订单，指定参与工作负载捕获在重放期间开始的顺序。</p>
                           <p>一个<a id="d31544e1621" class="indexterm-anchor"></a> <span class="bold">计划顺序</span>定义已添加到重放计划的两个工作负荷捕获的开始之间的顺序。可以将多个计划订单添加到重播计划中。例如，假设重播计划添加了三个工作负载捕获。可以添加一个计划订单，以指定Capture 2必须等待Capture 1在启动之前完成。可以添加另一个计划订单，以指定Capture 3必须等待Capture 1在启动之前完成。在这种情况下，Capture 2和Capture 3必须等待Capture 1完成才能启动。
                           </p>
                           <p>重播计划可能不包含任何计划订单。在这种情况下，重播计划中的所有参与工作负载捕获将在整合重播开始时同时开始重播。</p>
                           <div class="infoboxnotealso" id="GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA__GUID-1379BFFF-3832-4AEF-A41E-DAC7254ECDA5">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重播计划添加计划订单和删除计划订单。">添加计划订单以使用API重播计划</a> ”</span></p>
                           </div>
                        </div>
                     </div>
                  </div><a id="RATUG4096"></a><div class="props_rev_3"><a id="GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9" name="GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9"></a><h5 id="RATUG-GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9" class="sect5"><span class="enumeration_section">15.2.4.2</span>重新映射统一数据库重播的连接</h5>
                     <div>
                        <div><span>与使用数据库重放重放单个数据库工作负载的情况一样，用于连接到生产系统的捕获的连接字符串需要重新映射到重放系统。</span> 有关详细信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-823FEDBB-B93B-47DF-AE72-FBD3832DFD9B" title="在工作负载捕获期间，将捕获用于连接到生产系统的连接字符串。为了使重放成功，您需要将这些连接字符串重新映射到重放系统。然后，重播客户端可以使用重新映射的连接连接到重放系统。">连接重新映射</a> ”</span> 。
                        </div>
                        <p>对于<a id="d31544e1731" class="indexterm-anchor"></a>统一数据库重放，您需要在重放期间将捕获的连接字符串从多个工作负载捕获重新映射到不同的连接字符串。
                        </p>
                        <div class="infoboxnotealso" id="GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9__GUID-8E052D59-1915-4BA9-B3EA-CD59DC22C6AE">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-284D7908-40EE-4570-AE78-E75AAA294327" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射整合重播的连接字符串。">使用API重新映射连接</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="RATUG4097"></a><div class="props_rev_3"><a id="GUID-48411BB5-E585-4783-B016-72DCD97074CE" name="GUID-48411BB5-E585-4783-B016-72DCD97074CE"></a><h5 id="RATUG-GUID-48411BB5-E585-4783-B016-72DCD97074CE" class="sect5"><span class="enumeration_section">15.2.4.3</span>重新映射用户以进行统一数据库重播</h5>
                     <div>
                        <div><span>与使用数据库重放重放单个数据库工作负载的情况一样，可以在重放期间重新映射用于连接到生产系统的数据库用户和模式的用户名。有关详细信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-A00C24B9-28C9-46E4-839F-A0ABDA6C4C24" title="在工作负载捕获期间，将捕获用于连接到生产系统的数据库用户或模式的用户名。您可以选择将捕获的用户名重新映射到新用户或架构的用户名。">用户重新映射</a> ”</span> 。</span></div>
                        <p>对于<a id="d31544e1835" class="indexterm-anchor"></a>通过统一数据库重放，您可以选择在重放期间将捕获的用户从多个工作负载捕获重新映射到不同的用户或模式。
                        </p>
                        <div class="infoboxnotealso" id="GUID-48411BB5-E585-4783-B016-72DCD97074CE__GUID-18CC0161-29E8-42BB-AC28-D211140E85C5">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射用户以进行整合重播。">使用API重新映射用户</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="RATUG4098"></a><div class="props_rev_3"><a id="GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE" name="GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE"></a><h5 id="RATUG-GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE" class="sect5"><span class="enumeration_section">15.2.4.4</span>准备合并数据库重播</h5>
                     <div>
                        <div><span>与使用数据库重放重放单个数据库工作负载的情况一样，在准备重播期间定义了重播选项。</span> 有关详细信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-289F573A-9C83-4A29-A1D4-323705E8293D" title="还原数据库并重新映射连接和用户后，您可以设置相应的重播选项。">指定重播选项</a> ”</span> 。
                        </div>
                        <p>对于<a id="d31544e1940" class="indexterm-anchor"></a>统一数据库重放，整合重播中的所有参与工作负载捕获在重放准备期间定义的重放期间使用相同的重播选项。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE__GUID-3C4FAAE0-B74D-44BA-B8EF-C951BC4E3869">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包准备整合重播。">准备使用API进行统一数据库重放</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="RATUG4099"></a><div class="props_rev_3"><a id="GUID-C0629657-BFE2-48AB-8BF6-E1EBBCEB79EE" name="GUID-C0629657-BFE2-48AB-8BF6-E1EBBCEB79EE"></a><h5 id="RATUG-GUID-C0629657-BFE2-48AB-8BF6-E1EBBCEB79EE" class="sect5"><span class="enumeration_section">15.2.4.5</span>重播单个工作负载</h5>
                     <div>
                        <div><span>建议在重播统一工作负载之前单独重播每个参与的工作负载。</span> 有关详细信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-1F638D8F-7168-492D-BAD6-39F4F36EAD9B" title="在对捕获的工作负载进行预处理后，可以在运行相同版本的Oracle数据库的重放系统上重复执行该工作负载。">重播数据库工作负载</a> ”</span> 。
                        </div>
                        <p>单个重放可以为每个工作负载捕获建立基准性能，并用于分析整合重放的性能。</p>
                     </div>
                  </div>
               </div><a id="RATUG4202"></a><a id="RATUG4100"></a><div class="props_rev_3"><a id="GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954" name="GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954"></a><h4 id="RATUG-GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954" class="sect4"><span class="enumeration_section">15.2.5</span>统一数据库重放的报告和分析</h4>
                  <div>
                     <div><span>使用重播比较期间报告执行统一数据库重放的报告和分析。有关详细信息，请参阅<span class="q">“ <a href="analyzing-captured-and-replayed-workloads.html#GUID-A4EEC94D-ACA1-4B1C-937E-51BBA20CF91D" title="重播比较期间报告可用于多种目的。">使用重播比较期间报告</a> ”</span> 。</span></div>
                     <p>统一数据库重放的重播比较期间报告标识每个单独工作负载捕获的活动会话历史记录（ASH）数据，并将来自工作负载捕获的ASH数据与来自整合重放的过滤ASH数据进行比较。使用此报告来比较相同整合工作负载捕获的重放。</p>
                     <p>统一数据库重放的重播比较期间报告将整合重播视为多次捕获与重放比较。报告的摘要部分包含一个表格，该表格总结了所有Capture捕获与重放比较。查看本节中的信息，以全面了解整合重播的运行方式。</p>
                     <p><a href="using-consolidated-database-replay.html#GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954__CHDCBGFE">图15-2</a>显示了Consolidated Database Replay的重播比较期间报告的摘要部分。
                     </p>
                     <div class="figure" id="GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954__CHDCBGFE">
                        <p class="titleinfigure">图15-2比较期间报告：合并重播</p><img src="img/dbr_rep_cons_replay.gif" width="505" alt="下面是图15-2的描述" title="下面是图15-2的描述" longdesc="img_text/dbr_rep_cons_replay.html"><br><a href="img_text/dbr_rep_cons_replay.html">“图15-2比较期间报告：合并重播”的说明</a></div>
                     <!-- class="figure" -->
                     <p>报告中的其余部分类似于重播比较期间报告的ASH数据比较部分，并通过在整合重播中加入所有Capture与重播报告而形成。有关本节的说明，请参阅<span class="q">“ <a href="analyzing-captured-and-replayed-workloads.html#GUID-1741E117-65B1-4DEE-8E3E-314BD09AA4C8" title="本节比较两次运行中的ASH数据。">ASH数据比较</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div><a id="RATUG4137"></a><div class="props_rev_3"><a id="GUID-BBC96414-F08A-4D57-BA72-B28C1BBEE9F2" name="GUID-BBC96414-F08A-4D57-BA72-B28C1BBEE9F2"></a><h3 id="RATUG-GUID-BBC96414-F08A-4D57-BA72-B28C1BBEE9F2" class="sect3"><span class="enumeration_section">15.3</span>在企业管理器中使用Consolidated Database Replay</h3>
               <div>
                  <p>本节介绍如何将Consolidated Database Replay与Enterprise Manager一起使用。</p>
                  <p>重放统一数据库工作负载的主要工具是Oracle Enterprise Manager。如果Oracle Enterprise Manager不可用，您还可以使用API重播统一数据库工作负载，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" title="This section describes how to create and replay consolidated workloads using the DBMS_WORKLOAD_REPLAY package.">使用</a></span> API中的<span class="q"><a href="using-consolidated-database-replay.html#GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建和重播整合的工作负载。">使用统一数据库重放</a> ”中所述</span> 。
                  </p>
                  <p>重放统一数据库工作负载的过程几乎与重放单个数据库工作负载的过程相同。以下各节中的单次重放过程中记录了这些差异：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="preprocessing-a-database-workload.html#GUID-4CEE2F79-F5A7-4EBA-9018-0CB99AB51C0A" title="捕获工作负载并完成测试系统的设置后，必须预处理捕获的数据。">预处理数据库工作负载中的</a> <span class="q">“ <a href="preprocessing-a-database-workload.html#GUID-8012B6B9-4571-4802-9B87-CC44B3E51DF0" title="在创建数据库重播任务之前，请确保要重播的捕获具有一些捕获的用户调用。">创建数据库重放任务</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q"><a href="preprocessing-a-database-workload.html#GUID-6C328D8F-9451-4733-AB51-595BE096DAC9" title="The final preparation for the replay involves preprocessing the workload and deploying the replay clients.">预处理</a></span> <a href="preprocessing-a-database-workload.html#GUID-4CEE2F79-F5A7-4EBA-9018-0CB99AB51C0A" title="捕获工作负载并完成测试系统的设置后，必须预处理捕获的数据。">数据库工作负载中的</a> <span class="q">“ <a href="preprocessing-a-database-workload.html#GUID-6C328D8F-9451-4733-AB51-595BE096DAC9" title="重播的最后准备工作包括预处理工作负载和部署重播客户端。">预处理工作负载和部署重放客户端</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="replaying-a-database-workload.html#GUID-B97B7550-A947-45D0-A31B-636A6427DD86" title="This section describes how to replay a database workload using Enterprise Manager.">重播数据库工作负载</a> ”</span>中的<span class="q">“ <a href="replaying-a-database-workload.html#GUID-B97B7550-A947-45D0-A31B-636A6427DD86" title="本节介绍如何使用Enterprise Manager重播数据库工作负载。">使用Enterprise Manager</a></span> <a href="replaying-a-database-workload.html#GUID-1F638D8F-7168-492D-BAD6-39F4F36EAD9B" title="在对捕获的工作负载进行预处理后，可以在运行相同版本的Oracle数据库的重放系统上重复执行该工作负载。">重播数据库工作负载”</a></p>
                     </li>
                  </ul>
                  <p>以下列表概述了重放统一数据库工作负载与重放单个数据库工作负载之间的差异：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>创建重播任务时，需要从“创建任务”页面的“选择捕获”表中选择两个或多个捕获的工作负载。</p>
                     </li>
                     <li>
                        <p>“预处理捕获的工作负载：向导的复制工作负载”步骤对“捕获名称”下拉列表有多个选项，因此您可能需要为工作负载目录的当前位置输入多个凭据。</p>
                     </li>
                     <li>
                        <p>预处理捕获的工作负载：向导的“选择目录”步骤不会像单次重放那样显示“捕获摘要”。</p>
                     </li>
                     <li>
                        <p>向导的“重播工作负载：复制工作负载”步骤对“捕获名称”下拉列表有多个选项，因此您可能需要为工作负载目录的当前位置输入多个凭据。</p>
                     </li>
                     <li>
                        <p>重播工作负载：向导的“选择目录”步骤不会像单次重播那样显示“捕获摘要”。</p>
                     </li>
                     <li>
                        <p>向导的“重播工作负载：初始化选项”步骤不显示“标识源”部分。</p>
                     </li>
                     <li>
                        <p>“重播工作负载：自定义选项”步骤在“连接映射”选项卡中为“捕获名称”下拉列表提供了多个选项，因此您可以重新映射每个捕获的工作负载的连接。使用单个连接描述符或网络服务名称的选项不可用。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="RATUG4102"></a><div class="props_rev_3"><a id="GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" name="GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5"></a><h3 id="RATUG-GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" class="sect3"><span class="enumeration_section">15.4</span>使用API进行统一数据库重放</h3>
               <div>
                  <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包创建和重播整合的工作负载。</span> 您还可以使用Oracle Enterprise Manager创建和重播整合的工作负载，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-BBC96414-F08A-4D57-BA72-B28C1BBEE9F2" title="本节介绍如何将Consolidated Database Replay与Enterprise Manager一起使用。">使用Consolidated Database Replay with Enterprise Manager</a> ”中所述</span> 。
                  </div>
                  <p>使用API创建和重放整合工作负载是一个包含以下步骤的多步骤过程：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包从现有工作负载捕获生成捕获子集。">使用API生成捕获子集</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包在测试系统上设置统一重播目录。">使用API设置合并重播目录</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包定义重播计划。">使用API定义重播计划</a></p>
                     </li>
                     <li>
                        <p><a href="using-consolidated-database-replay.html#GUID-10610AAB-EB5C-441C-A1E3-64DEDEC6B45F" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包运行Consolidated Database Replay。">使用API运行Consolidated Database Replay</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5__GUID-582B0AC9-B098-4AB4-9317-D73A941DD678">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包的信息，请<code class="codeph">DBMS_WORKLOAD_REPLAY</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS208" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                  </div>
               </div><a id="RATUG4104"></a><a id="RATUG4103"></a><div class="props_rev_3"><a id="GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC" name="GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC"></a><h4 id="RATUG-GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC" class="sect4"><span class="enumeration_section">15.4.1</span>使用API生成捕获子集</h4>
                  <div>
                     <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包从现有工作负载捕获生成捕获子集。</span> 有关捕获子集的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-C4DC0795-74B2-456D-AA0A-B4F7F45C81F8" title="通过Consolidated Database Replay，您可以将现有工作负载捕获转换为新的较小的捕获子集。">捕获子集</a> ”</span> 。
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC__GUID-A33C5A55-01CF-4624-BEDB-A4161822E486">从现有工作负载捕获生成捕获子集：</p>
                        <ol>
                           <li>
                              <p>使用<a id="d31544e2574" class="indexterm-anchor"></a> <code class="codeph">GENERATE_CAPTURE_SUBSET</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.GENERATE_CAPTURE_SUBSET（input_capture_dir IN VARCHAR2，output_capture_dir IN VARCHAR2，new_capture_name IN VARCHAR2，begin_time IN NUMBER，begin_include_incomplete IN BOOLEAN DEFAULT TRUE，end_time IN NUMBER，end_include_incomplete IN BOOLEAN DEFAULT FALSE，parallel_level IN NUMBER DEFAULT NULL）;</pre></li>
                           <li>
                              <p>将<code class="codeph">input_capture_dir</code>参数设置为指向现有工作负载捕获的目录对象的名称。
                              </p>
                           </li>
                           <li>
                              <p>将<code class="codeph">output_capture_dir</code>参数设置为目录对象的名称，该目录对象指向将存储新工作负载捕获的空目录。
                              </p>
                           </li>
                           <li>
                              <p>将<code class="codeph">new_capture_name</code>参数设置为要生成的新工作负载捕获的名称。
                              </p>
                           </li>
                           <li>
                              <p>根据需要设置其他参数，这些参数是可选的。</p>
                              <p>有关这些参数的信息，请参阅<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73989" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> 。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例显示如何从目录对象<code class="codeph">peak_capdir</code>的现有工作负载捕获在目录对象<code class="codeph">rec_dir</code>处创建名为<code class="codeph">peak_wkld</code>的捕获子集。捕获子集包括工作负载捕获开始后2小时（或7,200秒）到工作负载捕获开始后3小时（或10,800秒）的工作负载。
                        </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.GENERATE_CAPTURE_SUBSET（'rec_dir'，'peak_capdir'，'peak_wkld'，7200，TRUE，10800，FALSE，1）;</pre><div class="infoboxnotealso" id="GUID-936472E4-89E9-4FBA-8474-1E3831BFB3CC__GUID-92C841A0-762E-470B-A2FD-4244B1C407CF">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">GENERATE_CAPTURE_SUBSET</code>过程的信息<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73988" target="_blank"><span><cite>，请参见Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="RATUG4106"></a><a id="RATUG4105"></a><div class="props_rev_3"><a id="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" name="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA"></a><h4 id="RATUG-GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" class="sect4"><span class="enumeration_section">15.4.2</span>使用API设置合并重播目录</h4>
                  <div>
                     <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包在测试系统上设置统一重播目录。</span> 将整合的重播目录设置为测试系统上的目录，该目录包含要合并和重放的工作负载捕获。有关设置测试系统的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-D4B92163-DB56-403B-81B2-B3E91D3EA667" title="为Consolidated Database Replay设置测试系统类似于为数据库重放设置测试系统。">为统一数据库重放设置测试系统</a> ”</span> 。
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA__GUID-08AA053F-1F61-4480-91C6-54DC27CD74D5">要设置重播目录：</p>
                        <ol>
                           <li>
                              <p>使用<a id="d31544e2744" class="indexterm-anchor"></a> <code class="codeph">SET_CONSOLIDATED_DIRECTORY</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.SET_CONSOLIDATED_DIRECTORY（replay_dir IN VARCHAR2）;</pre></li>
                           <li>
                              <p>将<code class="codeph">replay_dir</code>参数设置为目录对象的名称，该目录对象指向包含要用于工作负载整合的工作负载捕获的操作系统目录。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infobox-tip" id="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA__GUID-115AB160-02CF-4480-867C-003560AADEFF">
                           <p class="notep1">小费：</p>
                           <p>不推荐使用<code class="codeph">SET_REPLAY_DIRECTORY</code>过程，并将其替换为<code class="codeph">SET_CONSOLIDATED_DIRECTORY</code>过程。
                           </p>
                        </div>
                        <p>此示例显示如何将replay目录设置为名为<code class="codeph">rep_dir</code>的目录对象。
                        </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.SET_CONSOLIDATED_DIRECTORY（'rep_dir'）;</pre><p>您还可以使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包来查看由<code class="codeph">SET_CONSOLIDATED_DIRECTORY</code>过程设置的当前整合重播目录。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA__GUID-555DD23B-9C2A-4F48-8F75-02E46F4BAC1D">要查看已设置的当前整合重播目录：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<a id="d31544e2792" class="indexterm-anchor"></a> <code class="codeph">GET_REPLAY_DIRECTORY</code>函数：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.GET_REPLAY_DIRECTORY RETURN VARCHAR2;</pre><p>如果未设置整合的重播目录，则该函数返回<code class="codeph">NULL</code> 。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA__GUID-D44D28BA-6804-4D88-A07D-A40A8FDB3CA8">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">SET_REPLAY_DIRECTORY</code>过程的信息，请<code class="codeph">SET_REPLAY_DIRECTORY</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73107" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">GET_REPLAY_DIRECTORY</code>函数的信息，请<code class="codeph">GET_REPLAY_DIRECTORY</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73993" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="RATUG4107"></a><div class="props_rev_3"><a id="GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD" name="GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD"></a><h4 id="RATUG-GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD" class="sect4"><span class="enumeration_section">15.4.3</span>使用API定义重播计划</h4>
                  <div>
                     <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包定义重播计划。</span> 有关重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A" title="重播计划将一个或多个工作负载捕获添加到统一重播，并指定捕获在重放期间开始的顺序。">定义重播计划</a> ”</span> 。
                     </div>
                     <div class="p">
                        <p>在定义重播计划之前，请确保满足以下先决条件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在运行与重放系统相同的数据库版本的系统上，使用<code class="codeph">PROCESS_CAPTURE</code>过程对所有工作负载捕获进行预处理，如<a href="preprocessing-a-database-workload.html#GUID-4CEE2F79-F5A7-4EBA-9018-0CB99AB51C0A" title="捕获工作负载并完成测试系统的设置后，必须预处理捕获的数据。">预处理数据库工作负载中所述</a> 。
                              </p>
                           </li>
                           <li>
                              <p>所有捕获目录都将复制到重放系统上的重播目录中</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">SET_REPLAY_DIRECTORY</code>过程设置重播目录，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包在测试系统上设置统一重播目录。">使用API设置合并重播目录</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>数据库状态不在重播模式</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0C2C161B-76C7-4D14-87A1-2364EF731ECD__GUID-A9FEED3A-A934-4E0A-BDCF-1A66BA473135">要定义重播计划：</p>
                        <ol>
                           <li>
                              <p>创建新的重播计划，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建重播计划。">使用API创建重播计划</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>将工作负载捕获添加到重播计划中，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载以重播计划</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>将计划订单添加到重播计划，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" title="This section describes how to add schedule orders to and remove schedule orders from replay schedules using the DBMS_WORKLOAD_REPLAY package.">使用API</a></span>重新计划计划<span class="q"><a href="using-consolidated-database-replay.html#GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重播计划添加计划订单和删除计划订单。">添加计划订单</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>保存重播计划，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6" title="本节介绍如何保存使用DBMS_WORKLOAD_REPLAY包定义的重播计划。">使用API保存重播计划</a> ”中所述</span> 。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div><a id="RATUG4109"></a><a id="RATUG4108"></a><div class="props_rev_3"><a id="GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" name="GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB"></a><h5 id="RATUG-GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" class="sect5"><span class="enumeration_section">15.4.3.1</span>使用API创建重播计划</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包创建重播计划。</span> 有关重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-B1AEA82F-60E5-43CE-BB12-C6D72232886A" title="重播计划将一个或多个工作负载捕获添加到统一重播，并指定捕获在重放期间开始的顺序。">定义重播计划</a> ”</span> 。
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB__GUID-A5058A68-E1F9-407F-A94D-09ADD270A720">要创建重播计划：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e3132" class="indexterm-anchor"></a> <code class="codeph">BEGIN_REPLAY_SCHEDULE</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.BEGIN_REPLAY_SCHEDULE（schedule_name IN VARCHAR2）;</pre></li>
                              <li>
                                 <p>将<code class="codeph">schedule_name</code>参数设置为此重播计划的名称。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB__GUID-05D8F5D8-67E1-4BBC-A2E2-59797D522AE0">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">BEGIN_REPLAY_SCHEDULE</code>过程启动创建可重用的重播计划。一次只能定义一个重播计划。在定义重播计划时再次调用此过程将导致错误。
                              </p>
                           </div>
                           <p>此示例显示如何创建名为<code class="codeph">peak_schedule</code>的重播计划。
                           </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.BEGIN_REPLAY_SCHEDULE（'peak_schedule'）;</pre><div class="infoboxnotealso" id="GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB__GUID-47E10147-6E85-4499-A23C-A83CAAB4188D">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">BEGIN_REPLAY_SCHEDULE</code>过程的信息，请<code class="codeph">BEGIN_REPLAY_SCHEDULE</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73985" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4111"></a><a id="RATUG4110"></a><div class="props_rev_3"><a id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" name="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE"></a><h5 id="RATUG-GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" class="sect5"><span class="enumeration_section">15.4.3.2</span>使用API添加工作负载以重播计划</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包向重放计划添加工作负载捕获和删除工作负载捕获。</span> 有关将工作负载捕获添加到重放计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-816A1006-2A04-4C6C-B046-8C0F26FB7C70" title="重放计划执行的第一种操作是将参与的工作负载捕获添加到重放。">添加工作负载捕获</a> ”</span> 。
                        </div>
                        <div class="p">
                           <p>在将工作负载捕获添加到重播计划之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>创建要添加工作负载捕获的重放计划。</p>
                                 <p>有关创建重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建重播计划。">使用API创建重播计划</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE__GUID-5C6BF56D-BFF5-427F-A82F-7B4CC3A917D2">要将工作负载捕获添加到重播计划：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e3301" class="indexterm-anchor"></a> <code class="codeph">ADD_CAPTURE</code>函数：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（capture_dir_name IN VARCHAR2，start_delay_seconds IN NUMBER DEFAULT 0，stop_replay IN BOOLEAN DEFAULT FALSE，take_begin_snapshot IN BOOLEAN DEFAULT FALSE，take_end_snapshot IN BOOLEAN DEFAULT FALSE，query_only IN BOOLEAN DEFAULT FALSE）返回号码;</pre><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（capture_dir_name IN VARCHAR2，start_delay_seconds IN NUMBER，stop_replay IN VARCHAR2，take_begin_snapshot IN VARCHAR2 DEFAULT'N'，take_end_snapshot IN VARCHAR2 DEFAULT'N'，query_only IN VARCHAR2 DEFAULT'N'）返回号码;</pre><p>此函数返回唯一标识符，用于标识此重播计划中的工作负载捕获。</p>
                                 <div class="infoboxnote" id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE__GUID-53354CB5-FBFD-442D-8276-6BB72D1D1A53">
                                    <p class="notep1">看到：</p>
                                    <p><span class="q">“ <a href="using-consolidated-database-replay.html#GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8" title="在仅查询数据库重放中，仅重播工作负载捕获的只读查询。换句话说，在仅查询重放中，只有SELECT语句在重放时发送到服务器。在仅查询重放期间不执行DML语句，并且重放不会对用户模式或数据进行任何更改。">关于仅查询数据库重播</a> ”，</span>以获取有关仅查询数据库重放的信息。
                                    </p>
                                 </div>
                                 <div class="infoboxnote" id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE__GUID-B085FB32-1640-415E-9700-AC8703E5BD8E">
                                    <p class="notep1">注意：</p>
                                    <p>仅查询数据库重放仅在测试环境中使用和执行。</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>不要在生产系统上使用仅查询数据库重放。</p>
                                       </li>
                                       <li>
                                          <p>在仅查询数据库重放期间，预期会发散。</p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li>
                                 <p>将<code class="codeph">capture_dir_name</code>参数设置为指向顶级重播目录下的工作负载捕获的目录对象的名称。
                                 </p>
                                 <p>该目录必须包含在与重放系统运行相同数据库版本的系统上预处理的有效工作负载捕获。</p>
                              </li>
                              <li>
                                 <p>根据需要设置其他参数，这些参数是可选的。</p>
                                 <p>有关这些参数的信息，请参阅<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73982" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>以下示例说明如何使用<code class="codeph">SELECT</code>语句中的<code class="codeph">ADD_CAPTURE</code>函数将名为<code class="codeph">peak_wkld</code>的工作负载捕获添加到重播计划。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（'peak_wkld'）FROM dual;</pre><p>您还可以使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包删除<a id="d31544e3374" class="indexterm-anchor"></a>工作负载从重播计划中捕获。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE__GUID-E63D6BCD-D837-4F8C-8061-58BDD6D5D0C9">要从重播计划中删除工作负载捕获：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e3388" class="indexterm-anchor"></a> <code class="codeph">REMOVE_CAPTURE</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.REMOVE_CAPTURE（schedule_capture_number IN NUMBER）;</pre></li>
                              <li>
                                 <p>将<code class="codeph">schedule_capture_number</code>参数设置为标识此重播计划中的工作负载捕获的唯一标识符。
                                 </p>
                                 <p>唯一标识符与将工作负载捕获添加到重播计划时<code class="codeph">ADD_CAPTURE</code>函数返回的标识符相同。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE__GUID-EEA18DF4-962E-4C25-A7DF-AA804E9CC66E">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<code class="codeph">ADD_CAPTURE</code>函数的信息，请<code class="codeph">ADD_CAPTURE</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73981" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">REMOVE_CAPTURE</code>过程的信息<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73998" target="_blank"><span class="italic">，请参见Oracle Database PL / SQL包和类型参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4112"></a><div class="props_rev_3"><a id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" name="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73"></a><h5 id="RATUG-GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" class="sect5"><span class="enumeration_section">15.4.3.3</span>添加计划订单以使用API重播计划</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包向重播计划添加计划订单和删除计划订单。</span> 有关向重播计划添加计划订单的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-03A418A1-2FB3-43FE-AC82-C9703C3224EA" title="重播计划执行的第二种操作是添加计划订单，指定参与工作负载捕获在重放期间开始的顺序。">添加计划订单</a> ”</span> 。
                        </div>
                        <div class="p">
                           <p>在将计划订单添加到重播计划之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>创建要添加计划订单的重放计划。</p>
                                 <p>有关创建重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建重播计划。">使用API创建重播计划</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>参与计划订单的所有工作负载捕获都将添加到重播计划中。</p>
                                 <p>有关将工作负载捕获添加到重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载以重播计划</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73__GUID-04FD230E-1B5F-4195-B515-83108436357A">
                              <p class="notep1">注意：</p>
                              <p>将计划订单添加到重播计划是可选的。如果未向重播计划添加计划顺序，则在整合重播开始时，添加到重播计划的所有工作负载捕获将同时开始重播。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73__GUID-EE69F9DB-1E1E-46A1-A8A0-86DD81D758D7">要将计划订单添加到重播计划：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e3579" class="indexterm-anchor"></a> <code class="codeph">ADD_SCHEDULE_ORDERING</code>函数：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.ADD_SCHEDULE_ORDERING（schedule_capture_id IN NUMBER，waitfor_capture_id IN NUMBER）返回号码;</pre><p>此功能在已添加到重播计划的两个工作负载捕获之间添加计划顺序。如果无法添加计划订单，则会返回非零错误代码。</p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">schedule_capture_id</code>参数设置为要在此计划顺序中等待的工作负载捕获。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">wait_for_capture_id</code>参数设置为要在此计划顺序中启动其他工作负载捕获之前要完成的工作负载捕获。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>您还可以使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包删除<a id="d31544e3609" class="indexterm-anchor"></a>从重播计划安排订单。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73__GUID-7143E517-B55F-4E4D-A566-EB7871324702">要从重播计划中删除计划订单：</p>
                           <ol>
                              <li>
                                 <p>使用<code class="codeph">REMOVE_SCHEDULE_ORDERING</code>过程：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.REMOVE_SCHEDULE ORDERING（schedule_capture_id IN VARCHAR2，wait_for_capture_id IN VARCHAR2）;</pre></li>
                              <li>
                                 <p>将<code class="codeph">schedule_capture_id</code>参数设置为以此计划顺序等待的工作负载捕获。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">wait_for_capture_id</code>参数设置为需要在此计划顺序中启动其他工作负载捕获之前完成的工作负载捕获。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73__GUID-0E63F9CC-EAE1-4A45-8145-EA6777342EA5">要查看计划订单：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<code class="codeph">DBA_WORKLOAD_SCHEDULE_ORDERING</code>视图。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73__GUID-01E4C99D-5167-4500-AA93-CCB305191218">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<code class="codeph">ADD_SCHEDULE_ORDERING</code>函数的信息，请<code class="codeph">ADD_SCHEDULE_ORDERING</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS72130" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">REMOVE_SCHEDULE_ORDERING</code>过程的信息，请<code class="codeph">REMOVE_SCHEDULE_ORDERING</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS74000" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">DBA_WORKLOAD_SCHEDULE_ORDERING</code>视图的信息，请<code class="codeph">DBA_WORKLOAD_SCHEDULE_ORDERING</code> <a href="../refrn/DBA_WORKLOAD_SCHEDULE_ORDERING.html#REFRN23844" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4113"></a><div class="props_rev_3"><a id="GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6" name="GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6"></a><h5 id="RATUG-GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6" class="sect5"><span class="enumeration_section">15.4.3.4</span>使用API保存重播计划</h5>
                     <div>
                        <p>本节介绍如何保存使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包定义的重播计划。
                        </p>
                        <div class="p">
                           <p>在保存重播计划之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将创建将保存的重播计划。</p>
                                 <p>有关创建重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建重播计划。">使用API创建重播计划</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>参与计划订单的所有工作负载捕获都将添加到重播计划中。</p>
                                 <p>有关将工作负载捕获添加到重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载以重播计划</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>您要使用的任何计划订单都会添加到重播计划中（此步骤是可选的）。</p>
                                 <p>有关将计划订单添加到重播计划的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" title="This section describes how to add schedule orders to and remove schedule orders from replay schedules using the DBMS_WORKLOAD_REPLAY package.">使用API</a></span>重新计划计划<span class="q"><a href="using-consolidated-database-replay.html#GUID-CB0EBAEF-AE24-4EFA-A3F1-27C2479B3A73" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重播计划添加计划订单和删除计划订单。">添加计划订单</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6__GUID-84F8B405-BB69-40CE-B1F1-191D17A36854">要保存重播计划：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<a id="d31544e3830" class="indexterm-anchor"></a> <code class="codeph">END_REPLAY_SCHEDULE</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.END_REPLAY_SCHEDULE;</pre><p>此过程完成重播计划的创建。重播计划已保存并与重播目录关联。保存重播计划后，您可以将其用于整合重播。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6__GUID-DF78CE64-0AF7-4F9E-A53B-D71022E5D08B">要查看重播计划：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<code class="codeph">DBA_WORKLOAD_REPLAY_SCHEDULES</code>视图。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-40B753EE-A8E0-4C58-AF63-70B23FBF73A6__GUID-8895EC74-CFA2-4AB2-9051-90C081E635B6">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<code class="codeph">END_REPLAY_SCHEDULE</code>过程的信息，请<code class="codeph">END_REPLAY_SCHEDULE</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73987" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">DBA_WORKLOAD_REPLAY_SCHEDULES</code>视图的信息，请<code class="codeph">DBA_WORKLOAD_REPLAY_SCHEDULES</code> <a href="../refrn/DBA_WORKLOAD_REPLAY_SCHEDULES.html#REFRN-GUID-5C3B2723-B9F9-491A-9226-171B8DAD6553" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="RATUG4114"></a><div class="props_rev_3"><a id="GUID-10610AAB-EB5C-441C-A1E3-64DEDEC6B45F" name="GUID-10610AAB-EB5C-441C-A1E3-64DEDEC6B45F"></a><h4 id="RATUG-GUID-10610AAB-EB5C-441C-A1E3-64DEDEC6B45F" class="sect4"><span class="enumeration_section">15.4.4</span>使用API运行Consolidated Database Replay</h4>
                  <div>
                     <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包运行Consolidated Database Replay。</span> 有关整合重播的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-BFC7713A-5BEB-4A2E-9B0F-9F43A983BC6C" title="使用Consolidated Database Replay重播整合的工作负载与使用Database Replay重放单个数据库工作负载完全不同。">重新合并数据库工作负载以进行统一数据库重放</a> ”</span> 。
                     </div>
                     <div class="p">
                        <p>在运行Consolidated Database Replay之前，请确保满足以下先决条件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在运行与重放系统相同的数据库版本的系统上，使用<code class="codeph">PROCESS_CAPTURE</code>过程对所有工作负载捕获进行预处理，如<a href="preprocessing-a-database-workload.html#GUID-4CEE2F79-F5A7-4EBA-9018-0CB99AB51C0A" title="捕获工作负载并完成测试系统的设置后，必须预处理捕获的数据。">预处理数据库工作负载中所述</a> 。
                              </p>
                           </li>
                           <li>
                              <p>所有捕获目录都将复制到重放系统上的重播目录中</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">SET_REPLAY_DIRECTORY</code>过程设置重播目录，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-3A5F701E-6200-45C4-BDFD-D5A4740875DA" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包在测试系统上设置统一重播目录。">使用API设置合并重播目录</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>在所有工作负载捕获的开始时间，数据库在逻辑上恢复到与所有捕获系统相同的应用程序状态。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-10610AAB-EB5C-441C-A1E3-64DEDEC6B45F__GUID-28E06ED6-C11C-4310-BCD4-F08CA40D7C1D">要运行Consolidated Database Replay：</p>
                        <ol>
                           <li>
                              <p>初始化重播数据，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包初始化整合重播的重播数据。">使用API初始化统一数据库重放</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>重新映射连接字符串，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-284D7908-40EE-4570-AE78-E75AAA294327" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射整合重播的连接字符串。">使用API重新映射连接</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>重新映射用户，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射用户以进行整合重播。">使用API重新映射用户</a> ”中所述</span> 。
                              </p>
                              <p>重新映射用户是可选的。</p>
                           </li>
                           <li>
                              <p>准备整合重播，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包准备整合重播。">使用API准备合并数据库重放</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>设置并启动重播客户端，如<span class="q">“ <a href="replaying-a-database-workload.html#GUID-80A5AAE5-53E8-4775-AE5F-B43ADDB6E07F" title="此时，您需要设置并启动重播客户端，这些客户端将连接到重放系统并根据工作负载中捕获的内容发送请求。">设置重播客户端</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>启动整合重播，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包启动整合重播。">使用API启动统一数据库重放</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>生成报告并执行分析，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-D7C55F09-D604-4AD6-8B4A-C8C93D954954" title="使用重播比较期间报告执行统一数据库重放的报告和分析。看到" ="">统一数据库重放的报告和分析</a> ”中所述</span> 。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div><a id="RATUG4116"></a><a id="RATUG4115"></a><div class="props_rev_3"><a id="GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65" name="GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65"></a><h5 id="RATUG-GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65" class="sect5"><span class="enumeration_section">15.4.4.1</span>使用API初始化统一数据库重放</h5>
                     <div>
                        <p>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包初始化整合重播的重播数据。
                        </p>
                        <div class="section">
                           <p>初始化重播数据执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将数据库状态置于初始化模式以重放统一工作负载。</p>
                              </li>
                              <li>
                                 <p>指向重播目录，其中包含参与重播计划的所有工作负载捕获。</p>
                              </li>
                              <li>
                                 <p>将必要的元数据加载到重播所需的表中。</p>
                                 <p>例如，捕获的连接字符串被加载到表中，在表中可以重新映射它们以进行重放。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65__GUID-D8874968-8015-448B-A276-AC0CF4922D8F">要初始化Consolidated Database Replay：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e4217" class="indexterm-anchor"></a> <code class="codeph">INITIALIZE_CONSOLIDATED_REPLAY</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.INITIALIZE_CONSOLIDATED_REPLAY（replay_name IN VARCHAR2，schedule_name IN VARCHAR2，plsql_mode IN VARCHAR2 DEFAULT'TOP_LEVEL'）;</pre></li>
                              <li>
                                 <p>将<code class="codeph">replay_name</code>参数设置为整合重播的名称。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">schedule_name</code>参数设置为要使用的重播计划的名称。
                                 </p>
                                 <p><code class="codeph">schedule_name</code>参数是在创建过程中使用的重放计划的名称，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-CC592BD9-1FBE-46BA-88DD-ABB191C93EAB" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建重播计划。">使用API创建重播计划</a> ”中所述</span> 。
                                 </p>
                              </li>
                           </ol>
                           <p>可选的<code class="codeph">plsql_mode</code>参数指定PL / SQL重放模式。
                           </p>
                           <p>可以为<code class="codeph">plsql_mode</code>参数设置这两个值：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">top_level</code> ：只有顶级PL / SQL调用。这是默认值。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">extended</code> ：如果内部没有记录SQL，则在PL / SQL或顶级PL / SQL中执行SQL。所有捕获都必须在<code class="codeph">'extended'</code> PL / SQL模式下完成。非PL / SQL调用将以通常的方式重放。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>下面的例子显示了如何初始化命名合并重播<code class="codeph">peak_replay</code>使用名为重播时间表<code class="codeph">peak_schedule</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.INITIALIZE_CONSOLIDATED_REPLAY（'peak_replay'，'peak_schedule'）;</pre><div class="infoboxnotealso" id="GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65__GUID-F69A8ED8-D38D-4C88-A697-667085ABC2F2">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">INITIALIZE_CONSOLIDATED_REPLAY</code>过程的信息，请参阅<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73994" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4117"></a><div class="props_rev_3"><a id="GUID-284D7908-40EE-4570-AE78-E75AAA294327" name="GUID-284D7908-40EE-4570-AE78-E75AAA294327"></a><h5 id="RATUG-GUID-284D7908-40EE-4570-AE78-E75AAA294327" class="sect5"><span class="enumeration_section">15.4.4.2</span>使用API重新映射连接</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包重新映射整合重播的连接字符串。</span> 有关连接重新映射的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-A2D6CDAF-A91D-4DA4-ADCE-038595E851A9" title="与使用数据库重放重放单个数据库工作负载的情况一样，用于连接到生产系统的捕获的连接字符串需要重新映射到重放系统。">重新映射统一数据库重播的连接</a> ”</span> 。
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-284D7908-40EE-4570-AE78-E75AAA294327__GUID-CC13AAA9-08DC-448B-9818-C83536C25724">要重新映射连接字符串：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e4404" class="indexterm-anchor"></a> <code class="codeph">REMAP_CONNECTION</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.REMAP_CONNECTION（schedule_cap_id IN NUMBER，connection_id IN NUMBER，replay_connection IN VARCHAR2）;</pre><p>此过程将捕获的连接重新映射到重播计划中所有参与工作负载捕获的新连接字符串。</p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">schedule_capture_id</code>参数设置为当前重播计划中的参与工作负载捕获。
                                 </p>
                                 <p><code class="codeph">schedule_capture_id</code>参数是将工作负载捕获添加到重播计划时返回的唯一标识符，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载到重播计划</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">connection_id</code>参数设置为要重新映射的连接。
                                 </p>
                                 <p><code class="codeph">connection_id</code>参数在初始化重放数据时生成，并且对应于工作负载捕获的连接。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">replay_connection</code>参数设置为将在重播期间使用的新连接字符串。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-284D7908-40EE-4570-AE78-E75AAA294327__GUID-01C606DC-D44E-4016-B215-C5F1146A4FB6">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">REMAP_CONNECTION</code>过程的信息，请<code class="codeph">REMAP_CONNECTION</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS69093" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4119"></a><a id="RATUG4118"></a><div class="props_rev_3"><a id="GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915" name="GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915"></a><h5 id="RATUG-GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915" class="sect5"><span class="enumeration_section">15.4.4.3</span>使用API重新映射用户</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包重新映射用户以进行整合重播。</span> 有关重新映射用户的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-48411BB5-E585-4783-B016-72DCD97074CE" title="与使用数据库重放重放单个数据库工作负载的情况一样，可以在重放期间重新映射用于连接到生产系统的数据库用户和模式的用户名。看到" ="">重新映射用户以进行统一数据库重播</a> ”</span> 。
                        </div>
                        <div class="p">
                           <p>在重新映射用户之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>重播数据已初始化，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包初始化整合重播的重播数据。">使用API初始化统一数据库重放</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>数据库状态不处于重播模式。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915__GUID-68972639-9541-46C0-8C4F-FFC32411E689">要重新映射用户：</p>
                           <ol>
                              <li>
                                 <p>使用<a id="d31544e4594" class="indexterm-anchor"></a> <code class="codeph">SET_USER_MAPPING</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.SET_USER_MAPPING（schedule_cap_id IN NUMBER，capture_user IN VARCHAR2，replay_user IN VARCHAR2）;</pre></li>
                              <li>
                                 <p>将<code class="codeph">schedule_capture_id</code>参数设置为当前重播计划中的参与工作负载捕获。
                                 </p>
                                 <p><code class="codeph">schedule_capture_id</code>参数是将工作负载捕获添加到重播计划时返回的唯一标识符，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载到重播计划</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">capture_user</code>参数设置为在工作负载捕获期间捕获的用户或模式的用户名。
                                 </p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">replay_user</code>参数设置为在重放期间将捕获的用户重新映射到的新用户或模式的用户名。
                                 </p>
                                 <p>如果此参数设置为<code class="codeph">NULL</code> ，则禁用映射。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>此示例显示如何在重放期间将捕获期间使用的<code class="codeph">PROD</code>用户重新映射到<code class="codeph">TEST</code>用户，以识别标识为<code class="codeph">1001</code>的工作负载捕获。
                           </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.SET_USER_MAPPING（1001，'PROD'，'TEST'）;</pre><div class="infoboxnotealso" id="GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915__GUID-5B470F97-CDFE-4350-8E8D-D6D5457D2505">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">SET_USER_MAPPING</code>过程的信息，请<code class="codeph">SET_USER_MAPPING</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS74963" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4120"></a><div class="props_rev_3"><a id="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68" name="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68"></a><h5 id="RATUG-GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68" class="sect5"><span class="enumeration_section">15.4.4.4</span>使用API准备统一数据库重放</h5>
                     <div>
                        <div><span>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包准备整合重播。</span> 有关准备合并重播的信息，请参阅<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-C2F6DA54-9C2C-40CE-B357-F58126C0E2EE" title="与使用数据库重放重放单个数据库工作负载的情况一样，在准备重播期间定义了重播选项。">准备合并数据库重播</a> ”</span> 。
                        </div>
                        <div class="p">
                           <p>在准备整合重播之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>重播数据已初始化，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-7FA57ECB-BFF9-4595-AB3E-DDED8BEE3E65" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包初始化整合重播的重播数据。">使用API初始化统一数据库重放</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>捕获的连接将重新映射，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-284D7908-40EE-4570-AE78-E75AAA294327" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射整合重播的连接字符串。">使用API重新映射连接</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>映射用户，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-12BFB1A9-B0C6-4AE9-9E1B-F7237FAED915" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包重新映射用户以进行整合重播。">使用API重新映射用户</a> ”中所述</span> 。
                                 </p>
                                 <p>重新映射用户是可选的。但是，如果您计划在重放期间重新映射用户，则必须在准备整合重播之前完成该操作。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>准备整合重播将执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>指定重播选项，例如同步模式，会话连接速率和会话请求速率。</p>
                              </li>
                              <li>
                                 <p>将数据库状态置于重放模式。</p>
                              </li>
                              <li>
                                 <p>启用重播客户端的启动。</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68__GUID-FE5EE87C-72B4-41DA-A7E8-61E2562C8C0F">
                              <p class="notep1">注意：</p>
                              <p>Consolidated Database Replay仅支持基于时间或基于<code class="codeph">OBJECT_ID</code>的同步（ <code class="codeph">synchronization</code> = <code class="codeph">TIME</code>或<code class="codeph">OBJECT_ID</code> ）。目前不支持基于SCN的同步。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68__GUID-25F965C4-613B-4246-BD1E-5A3F05B1EF8E">准备合并重播：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<a id="d31544e4843" class="indexterm-anchor"></a> <code class="codeph">PREPARE_CONSOLIDATED_REPLAY</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.PREPARE_CONSOLIDATED_REPLAY（同步IN VARCHAR2 DEFAULT'OBJECT_ID'，connect_time_scale IN NUMBER DEFAULT 100，think_time_scale IN NUMBER DEFAULT 100，think_time_auto_correct IN BOOLEAN DEFAULT TRUE，capture_sts IN BOOLEAN DEFAULT FALSE，sts_cap_interval in NUMBER DEFAULT 300）;</pre><p>有关这些参数及其设置方法的信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-289F573A-9C83-4A29-A1D4-323705E8293D" title="还原数据库并重新映射连接和用户后，您可以设置相应的重播选项。">指定重播选项</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68__GUID-3AB11FC9-F51A-4526-87F2-6289B811322E">
                              <p class="notep1">注意：</p>
                              <p>使用<code class="codeph">PREPARE_CONSOLIDATED_REPLAY</code>过程时，请确保将<code class="codeph">synchronization</code>设置为<code class="codeph">false</code> 。
                              </p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68__GUID-2C656CF4-9A96-4455-B835-17A3513F4450">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">PREPARE_CONSOLIDATED_REPLAY</code>过程的信息，请<code class="codeph">PREPARE_CONSOLIDATED_REPLAY</code> <a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS73996" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="RATUG4121"></a><div class="props_rev_3"><a id="GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1" name="GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1"></a><h5 id="RATUG-GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1" class="sect5"><span class="enumeration_section">15.4.4.5</span>使用API启动统一数据库重放</h5>
                     <div>
                        <p>本节介绍如何使用<code class="codeph">DBMS_WORKLOAD_REPLAY</code>包启动整合重播。
                        </p>
                        <div class="p">
                           <p>在开始整合重播之前，请确保满足以下先决条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>准备整合重播，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-84EE2D27-04A8-4C78-8C08-4A5FF4472B68" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包准备整合重播。">使用API准备合并数据库重放</a> ”中所述</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>启动了足够数量的重播客户端。</p>
                                 <p>有关设置和启动重播客户端的信息，请参阅<span class="q">“ <a href="replaying-a-database-workload.html#GUID-80A5AAE5-53E8-4775-AE5F-B43ADDB6E07F" title="此时，您需要设置并启动重播客户端，这些客户端将连接到重放系统并根据工作负载中捕获的内容发送请求。">设置重播客户端</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1__GUID-DF65BFF4-F297-41C5-BE1C-13C04DF55E98">要开始整合重播：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<a id="d31544e5009" class="indexterm-anchor"></a> <code class="codeph">START_CONSOLIDATED_REPLAY</code>程序：</p><pre class="oac_no_warn" dir="ltr">DBMS_WORKLOAD_REPLAY.START_CONSOLIDATED_REPLAY;</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-62E2EA2B-D34C-47A0-BDA3-83E446DCC3D1__GUID-9B347C48-85D3-40C4-B94D-82D904A642CD">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">START_CONSOLIDATED_REPLAY</code>过程的信息<a href="../arpls/DBMS_WORKLOAD_REPLAY.html#ARPLS74454" target="_blank"><span><cite>，请参见Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="RATUG4265"></a><div class="props_rev_3"><a id="GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8" name="GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8"></a><h3 id="RATUG-GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8" class="sect3"><span class="enumeration_section">15.5</span>关于仅查询数据库重播</h3>
               <div>
                  <p>在仅查询数据库重放中，仅重播工作负载捕获的只读查询。换句话说，在仅查询重放中，只有<code class="codeph">SELECT</code>语句在重放时发送到服务器。在仅查询重放期间不执行DML语句，并且重放不会对用户模式或数据进行任何更改。
                  </p>
                  <div class="infoboxnote" id="GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8__GUID-9E11040B-0E83-4E6B-B2D4-6E228FF9ACE8">
                     <p class="notep1">注意：</p>
                     <p>只能使用Consolidated Database Replay执行仅查询数据库重播。</p>
                  </div>
                  <div class="infoboxnote" id="GUID-14A9F425-0888-4CA8-90C4-9E7B476852B8__GUID-E04313E2-44BA-49E6-B069-B1E39B523120">
                     <p class="notep1">注意：</p>
                     <p>仅查询数据库重放仅在测试环境中使用和执行。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不要在生产系统上使用仅查询数据库重放。</p>
                        </li>
                        <li>
                           <p>在仅查询数据库重放期间，预期会发散。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="RATUG4266"></a><div class="props_rev_3"><a id="GUID-5BF0AEE7-A64C-4523-ACDE-7043AE0AAEFE" name="GUID-5BF0AEE7-A64C-4523-ACDE-7043AE0AAEFE"></a><h4 id="RATUG-GUID-5BF0AEE7-A64C-4523-ACDE-7043AE0AAEFE" class="sect4"><span class="enumeration_section">15.5.1</span>仅查询数据库重播的用例</h4>
                  <div>
                     <div><span>您可以使用仅查询数据库重放来预热数据库缓冲区缓存并查找回归。</span> 例如：</div>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>预热数据库缓冲区缓存</p>
                           <p>在某些情况下，当数据库缓冲区高速缓存为热时（数据块已在缓冲区高速缓存中），将捕获工作负载。但是，当您在测试系统上重放该工作负载时，缓冲区缓存将不会变热，并且最初需要从磁盘加载数据块。这可能使重播持续时间长于捕获持续时间，并增加数据库时间。</p>
                           <p>为了避免必须预热缓冲区缓存，您可以执行仅查询重放，然后执行读/写重放，而无需重新启动数据库，也无需刷新缓冲区缓存。请注意，在仅查询重播之后，您不必重新启动数据库，因为仅查询重播是只读的。</p>
                        </li>
                        <li>
                           <p>寻找回归</p>
                           <p>仅查询重播是一种通过并发从工作负载的只读部分查找回归的简单方法。只读部分包括<code class="codeph">SELECT</code> （不是<code class="codeph">SELECT...FOR UPDATE</code> ）语句，没有DML和DDL的PL / SQL，LOB读取等。它通常是工作负载捕获的主要部分。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="RATUG4267"></a><div class="props_rev_3"><a id="GUID-81A86A84-E915-4A40-A9C1-B3BA4C5410E1" name="GUID-81A86A84-E915-4A40-A9C1-B3BA4C5410E1"></a><h4 id="RATUG-GUID-81A86A84-E915-4A40-A9C1-B3BA4C5410E1" class="sect4"><span class="enumeration_section">15.5.2</span>执行仅查询数据库重播</h4>
                  <div>
                     <p>您可以执行仅查询数据库重播。</p>
                     <p>要执行仅查询数据库重播，请按照<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-F3F44EF1-5E8E-4758-BB59-602E7E07CAE5" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包创建和重播整合的工作负载。">使用API中的合并数据库重放</a> ”中</span>的说明进行操作。当您使用<code class="codeph">ADD_CAPTURE</code>函数将工作负载捕获添加到重播计划时，如<span class="q">“ <a href="using-consolidated-database-replay.html#GUID-5D8972FE-DCB0-4CE4-A930-28E211387ECE" title="本节介绍如何使用DBMS_WORKLOAD_REPLAY包向重放计划添加工作负载捕获和删除工作负载捕获。">使用API添加工作负载捕获重播计划</a> ”中所述</span> ，将<code class="codeph">query_only</code>参数设置为<code class="codeph">Y</code></p>
                  </div>
               </div>
            </div><a id="RATUG4130"></a><a id="RATUG4122"></a><div class="props_rev_3"><a id="GUID-29988B63-F974-46EF-9AAD-3D04AF774337" name="GUID-29988B63-F974-46EF-9AAD-3D04AF774337"></a><h3 id="RATUG-GUID-29988B63-F974-46EF-9AAD-3D04AF774337" class="sect3"><span class="enumeration_section">15.6</span>示例：使用API重新合并工作负载</h3>
               <div>
                  <p>本节假设一个场景，来自三个独立生产系统的工作负载在不同操作系统上运行不同版本的Oracle数据库。</p>
                  <div class="section">
                     <p>此方案使用以下假设：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>要整合的第一个工作负载是从CRM系统捕获的，该系统在Solaris服务器上运行Oracle数据库10g第2版（版本10.2.0.4）。</p>
                        </li>
                        <li>
                           <p>要整合的第二个工作负载是从ERP系统捕获的，该系统在Linux服务器上运行Oracle数据库10g第2版（版本10.2.0.5）。</p>
                        </li>
                        <li>
                           <p>要整合的第三个工作负载是从SCM系统捕获的，该系统在Solaris服务器上运行Oracle Database <span class="italic">11g</span>第2版（版本11.2.0.2）。
                           </p>
                        </li>
                        <li>
                           <p>测试系统设置为运行Oracle Database 12 <span class="italic">c</span> Release 1（版本12.1.0.1）的多租户容器数据库（CDB）。
                           </p>
                        </li>
                        <li>
                           <p>CDB包含从CRM，ERP和SCM系统创建的三个PDB。</p>
                        </li>
                        <li>
                           <p>CDB中包含的每个PDB在捕获开始时恢复到与CRM，ERP和SCM系统相同的应用程序数据状态。</p>
                        </li>
                     </ul>
                     <p><a href="using-consolidated-database-replay.html#GUID-29988B63-F974-46EF-9AAD-3D04AF774337__CHDJGAIH">图15-3</a>说明了这种情况。
                     </p>
                     <div class="figure" id="GUID-29988B63-F974-46EF-9AAD-3D04AF774337__CHDJGAIH">
                        <p class="titleinfigure">图15-3合并三个工作负载的场景</p><img src="img/ratug005.png" width="298" alt="下面是图15-3的描述" title="下面是图15-3的描述" longdesc="img_text/ratug005.html"><br><a href="img_text/ratug005.html">“图15-3合并三个工作负载的场景”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-29988B63-F974-46EF-9AAD-3D04AF774337__GUID-52916F2F-D49E-4071-ADD0-BBEA157DD284">要在此方案中合并工作负载并重播整合工作负载：</p>
                     <ol>
                        <li>
                           <p>在测试系统上，将各个工作负载捕获预处理到单独的目录中：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于CRM工作负载：</p>
                                 <ol type="a">
                                    <li>
                                       <p>创建目录对象：</p><pre class="oac_no_warn" dir="ltr">创建或替换DIRECTORY目录crm AS'/ u01 / test / cap_crm';</pre></li>
                                    <li>
                                       <p>确保从CRM系统捕获的工作负载存储在此目录中。</p>
                                    </li>
                                    <li>
                                       <p>预处理工作量：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.PROCESS_CAPTURE（'CRM'）;</pre></li>
                                 </ol>
                              </li>
                              <li>
                                 <p>对于ERP工作量：</p>
                                 <ol type="a">
                                    <li>
                                       <p>创建目录对象：</p><pre class="oac_no_warn" dir="ltr">创建或替换目录erp AS'/ u01 / test / cap_erp';</pre></li>
                                    <li>
                                       <p>确保从ERP系统捕获的工作负载存储在此目录中。</p>
                                    </li>
                                    <li>
                                       <p>预处理工作量：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.PROCESS_CAPTURE（'ERP'）;</pre></li>
                                 </ol>
                              </li>
                              <li>
                                 <p>对于SCM工作负载：</p>
                                 <ol type="a">
                                    <li>
                                       <p>创建目录对象：</p><pre class="oac_no_warn" dir="ltr">创建或替换DIRECTORY目录scm AS'/ u01 / test / cap_scm';</pre></li>
                                    <li>
                                       <p>确保从SCM系统捕获的工作负载存储在此目录中。</p>
                                    </li>
                                    <li>
                                       <p>预处理工作量：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.PROCESS_CAPTURE（'SCM'）;</pre></li>
                                 </ol>
                              </li>
                           </ul>
                        </li>
                        <li id="GUID-29988B63-F974-46EF-9AAD-3D04AF774337__CHDCFBIC">
                           <p>创建根目录以存储预处理的工作负载：</p><pre class="oac_no_warn" dir="ltr">mkdir'/ u01 / test / cons_dir';创建或替换DIRECTORY目录cons_workload AS'/ u01 / test / cons_dir';</pre></li>
                        <li>
                           <p>将每个预处理的工作负载目录复制到根目录：</p><pre class="oac_no_warn" dir="ltr">cp -r / u01 / test / cap_crm / u01 / test / cons_dir cp -r / u01 / test / cap_erp / u01 / test / cons_dir cp -r / u01 / test / cap_scm / u01 / test / cons_dir</pre></li>
                        <li>
                           <p>对于每个工作负载，使用新的操作系统目录路径创建目录对象：</p><pre class="oac_no_warn" dir="ltr">创建或更换目录crm AS'/ u01 / test / cons_dir / cap_crm';创建或替换DIRECTORY erp AS'/ u01 / test / cons_dir / cap_erp';创建或替换DIRECTORY scm AS'/ u01 / test / cons_dir / cap_scm';</pre></li>
                        <li>
                           <p>将重播目录设置为先前在步骤<a href="using-consolidated-database-replay.html#GUID-29988B63-F974-46EF-9AAD-3D04AF774337__CHDCFBIC">2中</a>创建的根目录：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.SET_REPLAY_DIRECTORY（'CONS_WORKLOAD'）;</pre></li>
                        <li>
                           <p>创建重播计划并添加工作负载捕获：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.BEGIN_REPLAY_SCHEDULE（'CONS_SCHEDULE'）; SELECT DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（'CRM'）FROM dual; SELECT DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（'ERP'）FROM dual; SELECT DBMS_WORKLOAD_REPLAY.ADD_CAPTURE（'SCM'）FROM dual; EXEC DBMS_WORKLOAD_REPLAY.END_REPLAY_SCHEDULE;</pre></li>
                        <li>
                           <p>初始化整合重播：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.INITIALIZE_CONSOLIDATED_REPLAY（'CONS_REPLAY'，'CONS_SCHEDULE'）;</pre></li>
                        <li>
                           <p>重新映射连接：</p>
                           <ol type="a">
                              <li>
                                 <p>在<code class="codeph">DBA_WORKLOAD_CONNECTION_MAP</code>视图中查询连接映射信息：</p><pre class="oac_no_warn" dir="ltr">SELECT schedule_cap_id，conn_id，capture_conn，replay_conn FROM dba_workload_connection_map;</pre></li>
                              <li>
                                 <p>重新映射连接：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.REMAP_CONNECTION（schedule_cap_id =&gt; 1，conn_id =&gt; 1，replay_connection =&gt;'CRM'）; EXEC DBMS_WORKLOAD_REPLAY.REMAP_CONNECTION（schedule_cap_id =&gt; 2，conn_id =&gt; 1，replay_connection =&gt;'ERP'）; EXEC DBMS_WORKLOAD_REPLAY.REMAP_CONNECTION（schedule_cap_id =&gt; 3，conn_id =&gt; 1，replay_connection =&gt;'SCM'）;</pre><p><code class="codeph">replay_connection</code>参数表示在测试系统上定义的服务。
                                 </p>
                              </li>
                              <li>
                                 <p>验证连接重映射：</p><pre class="oac_no_warn" dir="ltr">SELECT schedule_cap_id，conn_id，capture_conn，replay_conn FROM dba_workload_connection_map;</pre></li>
                           </ol>
                        </li>
                        <li>
                           <p>准备整合重播：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.PREPARE_CONSOLIDATED_REPLAY（synchronization =&gt;'OBJECT_ID'）;</pre></li>
                        <li>
                           <p>开始重播客户：</p>
                           <ol type="a">
                              <li>
                                 <p>估计所需的重播客户端数量：</p><pre class="oac_no_warn" dir="ltr">wrc mode = calibrate replaydir = / u01 / test / cons_dir / cap_crm wrc mode = calibrate replaydir = / u01 / test / cons_dir / cap_erp wrc mode = calibrate replaydir = / u01 / test / cons_dir / cap_scm</pre></li>
                              <li>
                                 <p>添加输出以确定所需的重播客户端数。</p>
                                 <p>您需要在整合工作负载中包含的每个工作负载捕获中至少启动一个重播客户端。</p>
                              </li>
                              <li>
                                 <p>重复此命令启动所需数量的重播客户端：</p><pre class="oac_no_warn" dir="ltr">wrc <span class="italic">用户名</span> / <span class="italic">密码</span>模式=重播replaydir = / u01 / test / cons_dir</pre><p><code class="codeph">replaydir</code>参数设置为存储工作负载捕获的根目录。
                                 </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>开始整合重播：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_WORKLOAD_REPLAY.START_CONSOLIDATED_REPLAY;</pre></li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-29988B63-F974-46EF-9AAD-3D04AF774337__GUID-F9378433-DF10-42F0-A2EB-3F062B2776EE">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关配置CDB的信息，请参见<a href="../multi/creating-and-configuring-a-cdb.html#ADMIN13514" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关创建PDB的信息，请参见<a href="../admin/index.html" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="04338.objects-collections-and-OPAQUE-types.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象，集合和OPAQUE类型</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="type-support.html" title="Previous" type="text/html"></link>
      <link rel="next" href="advanced-language-features.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="type-support.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="advanced-language-features.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象，集合和OPAQUE类型</li>
            </ol>
            <a id="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" name="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF"></a><a id="JSQLJ409"></a>
            
            <h2 id="JSQLJ-GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" class="sect2"><span class="enumeration_chapter">7个</span>对象，集合和OPAQUE类型</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论Oracle SQLJ实现如何支持用户定义的SQL类型。关于Oracle OPAQUE类型，最后还有一小部分。</p>
               <p>本章包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-83FAE830-C137-413B-8654-5378A60A2E03">Oracle对象和集合</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E">自定义Java类</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B">用户定义的类型</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810">SQLJ可执行语句中的强类型对象和引用</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD">SQLJ可执行语句中强类型的集合</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化的Java对象</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55">弱类型Objects_ References_和Collections</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4">Oracle OPAQUE类型</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ410"></a><div class="props_rev_3"><a id="GUID-83FAE830-C137-413B-8654-5378A60A2E03" name="GUID-83FAE830-C137-413B-8654-5378A60A2E03"></a><h3 id="JSQLJ-GUID-83FAE830-C137-413B-8654-5378A60A2E03" class="sect3">Oracle对象和集合</h3>
               <div>
                  <p>本节提供有关Oracle Database 12 <span class="italic">c</span>第2版（12.2）对象和集合的一些背景概念信息。
                  </p>
                  <div class="infoboxnotealso" id="GUID-83FAE830-C137-413B-8654-5378A60A2E03__GUID-31E81DE6-4FD3-495F-8C99-47989088638D">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../sqlrf/Database-Objects.html#SQLRF-GUID-31BE00A7-7FF9-41CB-852A-F1416912CA9E" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>和<a href="../adfns/sql-data-types.html#ADFNS-GUID-CCC643C7-88E1-421C-87DC-4353899FFB9E" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> 。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-535092B2-B9CA-4978-A01E-6209609B579D">对象和集合概述</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7">Oracle对象基础知识</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300">Oracle Collection Fundamentals</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591">对象和集合数据类型</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ412"></a><a id="JSQLJ413"></a><a id="JSQLJ411"></a><div class="props_rev_3"><a id="GUID-535092B2-B9CA-4978-A01E-6209609B579D" name="GUID-535092B2-B9CA-4978-A01E-6209609B579D"></a><h4 id="JSQLJ-GUID-535092B2-B9CA-4978-A01E-6209609B579D" class="sect4">对象和集合概述</h4>
                  <div>
                     <p>Oracle SQLJ实现支持用户定义的SQL对象类型，它们是复合数据结构，相关SQL对象引用类型和用户定义的SQL集合类型。Oracle对象和集合是由各个数据元素组成的复合数据结构。</p>
                     <p>Oracle SQLJ实现支持在迭代器或宿主表达式中使用的对象类型，引用类型和集合类型的强类型或弱类型Java表示。强类型表示使用映射到特定对象类型，引用类型或集合类型的自定义Java类，并且必须实现Java数据库连接（JDBC）2.0标准<code class="codeph">java.sql.SQLData</code>接口，仅用于对象类型，或Oracle <code class="codeph">oracle.sql.ORAData</code>接口。
                     </p>
                     <p>术语stron gly typed用于特定Java类型与特定SQL命名类型或用户定义类型相关联的情况。例如，如果存在<code class="codeph">PERSON</code>类型，则会将相应的<code class="codeph">Person</code> Java类与其关联。
                     </p>
                     <p>弱类型表示使用<code class="codeph">oracle.sql.对象的STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>用于对象引用，或<code class="codeph">oracle.sql.ARRAY</code>收藏品。或者，您可以使用标准<code class="codeph">java.sql.Struct</code> ， <code class="codeph">java.sql.Ref</code>或<code class="codeph">java.sql.弱类型场景中的Array</code>对象。
                     </p>
                     <p>wea kly typed这个术语用于Java类型以通用方式使用的地方，可以映射到多个SQL命名类型。Java类或接口没有特定于任何SQL类型的特殊信息。这是<code class="codeph">oracle.sql.的情况<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code>类型和<code class="codeph">java.sql.Struct</code> ， <code class="codeph">java.sql.Ref</code>和<code class="codeph">java.sql.Array</code>类型。
                     </p>
                     <p>请注意，在代码中使用Oracle扩展需要以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用Oracle JDBC驱动程序之一。</p>
                        </li>
                        <li>
                           <p>使用默认的Oracle特定代码生成，或者，对于ISO代码生成，适当地自定义配置文件。对于特定于Oracle的生成代码，不会生成任何配置文件，因此自定义不适用。Oracle JDBC应用程序编程接口（API）直接通过生成的Java代码调用。</p>
                           <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C9E90461-A7B3-4278-A8AD-B2FE60B33C61">
                              <p class="notep1">注意：</p>
                              <p>Oracle建议使用默认的自定义程序<code class="codeph">oracle.sqlj.runtime.util.OraCustomizer</code> 。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>在应用程序运行时使用Oracle SQLJ运行时。即使您没有在代码中实际使用Oracle扩展，每当您使用Oracle自定义程序时，都需要Oracle SQLJ运行时和Oracle JDBC驱动程序。</p>
                        </li>
                     </ul>
                     <p>对于特定于Oracle的语义检查，您必须使用适当的检查程序。默认检查器<code class="codeph">oracle.sqlj.checker.OracleChecker</code>充当前端，将根据您的环境运行相应的检查程序。如果您使用的是Oracle JDBC驱动程序，那么这将是Oracle特定的检查程序之一。
                     </p>
                     <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C034D024-E023-4F6E-B390-2E5FB82C96A3">
                        <p class="notep1">注意：</p>
                        <p>Oracle对象和集合的Oracle特定类型包含在<code class="codeph">oracle.sql</code>包中。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-3CF36A38-7E2C-4A91-A180-87CD56E3DA39">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">连接选项</a> ”</span>和<span class="q">“ <a href="translator-command-line-and-options.html#GUID-ED7DD3DE-CA91-4085-82B2-D07EC9B15FB6">语义 - 检查和脱机 - 解析选项</a> ”</span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-E505B2A1-D691-4E7A-9D48-BE09505E01FE">自定义Java类使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>本章主要讨论使用具有用户定义类型的自定义Java类。但是，实现<code class="codeph">ORAData</code>类也可以用于其他Oracle SQL类型。实现<code class="codeph">ORAData</code>的类可用于在SQL和Java之间传输数据的过程中执行任何类型的所需处理或转换。
                              </p>
                              <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-F5985ACE-4494-448B-9928-9B5E963A902A">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a> ”</span></p>
                              </div>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code>接口仅适用于自定义对象类。<code class="codeph">ORAData</code>接口可用于任何自定义Java类。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-D84FE6D8-6B4A-4ABF-9A2A-F16EF64ED31F">术语说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用户定义的SQL对象类型和用户定义的SQL集合类型称为用户定义的类型（UDT）。</p>
                           </li>
                           <li>
                              <p>对象，引用和集合的自定义Java类分别称为自定义对象类，自定义引用类和自定义集合类。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-AC170A44-CEEC-40FA-8CB0-A0CB783A1A1D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../adobj/introduction-to-oracle-objects.html#ADOBJ-GUID-7667A5B4-22E3-465F-9F7B-7043A9525DD2" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关Oracle对象特性和功能的一般信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ414"></a><div class="props_rev_3"><a id="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" name="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7"></a><h4 id="JSQLJ-GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" class="sect4">Oracle对象基础知识</h4>
                  <div>
                     <p>Oracle SQL对象是复合数据结构，它将相关数据项（例如每个员工的事实）分组到一个数据单元中。对象类型在功能上类似于Java类。您可以填充和使用给定对象类型的任意数量的单个对象，就像您可以实例化和使用Java类的单个对象一样。</p>
                     <p>例如，你可以定义一个对象类型<code class="codeph">EMPLOYEE</code>具有属性<code class="codeph">name</code>类型的<code class="codeph">CHAR</code> ， <code class="codeph">address</code>类型的<code class="codeph">CHAR</code> ， <code class="codeph">phonenumber</code>类型的<code class="codeph">CHAR</code>和<code class="codeph">employeenumber</code>类型的<code class="codeph">NUMBER</code> 。</p>
                     <p>Oracle对象还可以具有与对象类型关联的方法或存储过程。这些方法可以是静态方法，也可以是实例方法，可以在PL / SQL或Java中实现。它们的签名可以包括任意数量的输入，输出或输入输出参数。所有这些都取决于它们最初的定义方式</p>
                  </div>
               </div><a id="JSQLJ415"></a><div class="props_rev_3"><a id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" name="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300"></a><h4 id="JSQLJ-GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" class="sect4">Oracle Collection Fundamentals</h4>
                  <div>
                     <p>有两类Oracle SQL集合：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d32224e422" class="indexterm-anchor"></a>可变长度数组（VARRAY类型）</p>
                        </li>
                        <li>
                           <p><a id="d32224e429" class="indexterm-anchor"></a>嵌套表（TABLE类型）</p>
                        </li>
                     </ul>
                     <p>两个类别都是一维的，尽管元素可以是复杂的对象类型。VARRAY类型用于一维数组，嵌套表类型用于外部表中的单列表。任何VARRAY类型的变量都可以称为VARRAY。任何嵌套表类型的变量都可以称为嵌套表。</p>
                     <p>与任何数组一样，VARRAY是一组有序的数据元素，每个元素都有一个索引，所有元素都具有相同的数据类型。VARRAY的大小是指元素的最大数量。Oracle VARRAYs，如其名称所示，具有可变大小，但在声明VARRAY类型时，必须指定任何特定VARRAY类型的最大大小。</p>
                     <p>嵌套表是一组无序元素。表中的嵌套表元素本身可以在SQL中查询。与任何表一样，嵌套表不会使用任何特定数量的行创建。这是动态确定的。</p>
                     <div class="infoboxnote" id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300__GUID-B67BEE30-0D52-4C1C-BD8E-7008B83D1D4E">
                        <p class="notep1">注意：</p>
                        <p>VARRAY中的元素或嵌套表中的行可以是用户定义的对象类型，VARRAY和嵌套表类型可以用于用户定义的对象类型中的属性。Oracle Database 12 <span class="italic">c</span>第2版（12.2）支持嵌套类型的嵌套。VARRAY的元素或嵌套表的行可以是另一个VARRAY或嵌套表类型，或者这些元素可以是具有VARRAY或嵌套表属性的用户定义对象类型。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ416"></a><div class="props_rev_3"><a id="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" name="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591"></a><h4 id="JSQLJ-GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" class="sect4">对象和集合数据类型</h4>
                  <div>
                     <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，用户定义的对象和集合定义用作SQL数据类型定义。在定义表列，SQL对象属性和存储过程或函数参数时，可以像使用任何其他数据类型一样使用这些数据类型。此外，一旦定义了对象类型，相关对象引用类型就可以用作任何其他SQL引用类型。
                     </p>
                     <p>例如，请考虑上一节中描述的<code class="codeph">EMPLOYEE</code> Oracle对象。定义此对象后，它将成为Oracle数据类型。您可以拥有类型为<code class="codeph">EMPLOYEE</code>的表列，就像您可以拥有<code class="codeph">NUMBER</code>类型的表列一样。 <code class="codeph">EMPLOYEE</code>列中的每一行都包含一个完整的<code class="codeph">EMPLOYEE</code>对象。您还可以使用<code class="codeph">REF EMPLOYEE</code>列类型，其中包含对<code class="codeph">EMPLOYEE</code>对象的引用。
                     </p>
                     <p>类似地，您可以将可变长度数组<code class="codeph">MYVARR</code>定义为<code class="codeph">NUMBER</code> <code class="codeph">VARRAY(10)</code>和<code class="codeph">CHAR(20)</code>的嵌套表<code class="codeph">NTBL</code> 。<code class="codeph">MYVARR</code>和<code class="codeph">NTBL</code>集合类型成为Oracle数据类型，您可以拥有任一类型的表列。<code class="codeph">MYVARR</code>列的每一行都包含一个最多10个数字的数组。<code class="codeph">NTBL</code>列的每一行由20个字符组成。
                     </p>
                  </div>
               </div>
            </div><a id="JSQLJ417"></a><div class="props_rev_3"><a id="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" name="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E"></a><h3 id="JSQLJ-GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" class="sect3">自定义Java类</h3>
               <div>
                  <p>自定义Java类是第一类类型，可用于透明地读取和写入用户定义的SQL类型。自定义Java类的目的是提供一种在SQL和Java之间转换数据并使数据可访问的方法，特别是在支持对象和集合时，或者如果要执行自定义数据转换。</p>
                  <p>通常建议为在SQLJ应用程序中使用的所有用户定义类型提供自定义Java类。Oracle JDBC驱动程序将使用这些类的实例来转换数据，这比使用弱类型的<code class="codeph">oracle.sql.更方便，更不容易出错<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code>课程。
                  </p>
                  <p>要在SQLJ迭代器或主机表达式中使用，自定义Java类必须实现<code class="codeph">oracle.sql.ORAData</code>和<code class="codeph">oracle.sql.ORADataFactory</code>接口或标准<code class="codeph">java.sql.SQLData</code>接口。本节概述了这些接口和自定义Java类功能，包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F">自定义Java类接口规范</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80">对象方法的自定义Java类支持</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D">自定义Java类要求</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-700E14BF-E4F8-4A36-9092-05000452C60B">编译自定义Java类</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7">阅读和编写自定义数据</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ419"></a><a id="JSQLJ421"></a><a id="JSQLJ418"></a><div class="props_rev_3"><a id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" name="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F"></a><h4 id="JSQLJ-GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" class="sect4">自定义Java类接口规范</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口以及标准<code class="codeph">SQLData</code>接口的规范。
                        </p>
                        <p>Oracle Database 12 <span class="italic">c</span>第2版（12.2）包含一组API，用于针对用户定义类型的Oracle特定的自定义Java类功能： <code class="codeph">oracle.sql.ORAData</code>和<code class="codeph">oracle.sql.ORADataFactory</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-755AD7E5-59DF-4D06-BA3B-81EED07E7AD6">ORAData和ORADataFactory规范</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle提供了<code class="codeph">oracle.sql.ORAData</code>接口和相关的<code class="codeph">oracle.sql.ORADataFactory</code>接口，用于将Oracle对象类型，引用类型和集合类型映射和转换为自定义Java类。
                        </p>
                        <p>以<code class="codeph">oracle.sql.的形式发送或检索数据<code class="codeph">oracle.sql.Datum</code>对象，底层数据采用适当的<code class="codeph">oracle.sql.格式<code class="codeph">oracle.sql.Datum</code>子类，例如<code class="codeph">oracle.sql.STRUCT</code> 。此数据仍为SQL格式。<code class="codeph">oracle.sql.Datum</code>对象只是一个包装器。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-1198871C-6658-4BEC-AA49-199C99152250">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-5905674A-A045-40B1-96DE-726761517D50" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></p>
                        </div>
                        <p><code class="codeph">ORAData</code>接口指定用于从Java格式到SQL格式的数据转换的<code class="codeph">toDatum()</code>方法。此方法将连接对象作为输入，并将数据转换为适当的<code class="codeph">oracle.sql.*</code>表示。连接对象是必需的，以便JDBC驱动程序可以在运行时执行适当的类型检查和类型转换。<code class="codeph">ORAData</code>和<code class="codeph">toDatum()</code>规范如下：</p><pre class="oac_no_warn" dir="ltr">接口oracle.sql。ORAData {oracle.sql。Datum toDatum（java.sql。连接c）抛出SQLException; }</pre><p><code class="codeph">ORADataFactory</code>接口指定一个<code class="codeph">create()</code>方法，该方法构造自定义Java类的实例，从SQL格式转换为Java格式。此方法将包含数据的<code class="codeph">Datum</code>对象和类型代码（如<code class="codeph">OracleTypes.作为输入<code class="codeph">OracleTypes.RAW</code> ，表示底层数据的SQL类型。它返回自定义Java类的对象，该类实现<code class="codeph">ORAData</code>接口。此对象从输入的<code class="codeph">Datum</code>对象接收其数据。<code class="codeph">ORADataFactory</code>和<code class="codeph">create()</code>规范如下：</p><pre class="oac_no_warn" dir="ltr">接口oracle.sql。ORADataFactory {oracle.sql。ORAData create（oracle.sql。Datum d，int sqlType）抛出SQLException; }</pre><p>要完成<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口之间的关系，必须在任何实现<code class="codeph">ORAData</code>接口的自定义Java类中实现静态<code class="codeph">getORADataFactory()</code>方法。此方法返回一个实现<code class="codeph">ORADataFactory</code>接口的对象，因此可用于创建自定义Java类的实例。返回的对象本身可以是自定义Java类的实例，并且Oracle JDBC驱动程序使用其<code class="codeph">create()</code>方法根据需要生成自定义Java类的更多实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-AB441F71-EEC4-404E-8AA6-FA0399EDF7E4">SQLData规范</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>标准JDBC 2.0提供<code class="codeph">java.sql.用于映射和将结构化对象类型转换为Java类的SQLData</code>接口。此接口仅用于映射结构化对象类型，而不是对象引用，集合或数组或其他SQL类型。
                        </p>
                        <p>所述<code class="codeph">SQLData</code>接口是JDBC 2.0标准，指定一个<code class="codeph">readSQL()</code>方法将数据读入Java对象和<code class="codeph">writeSQL()</code>方法写入从Java对象的数据库。
                        </p>
                        <p>有关标准<code class="codeph">SQLData</code>功能的其他信息，请参阅Sun Microsystems JDBC 2.0或更高版本的API规范。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ422"></a><div class="props_rev_3"><a id="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" name="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80"></a><h4 id="JSQLJ-GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" class="sect4">对象方法的自定义Java类支持</h4>
                  <div>
                     <p>可以从自定义Java类包装器调用Oracle对象的方法。底层存储过程是用PL / SQL编写的还是用Java编写并发布到SQL对用户是不可见的。</p>
                     <p>用于调用服务器方法的Java包装器方法需要连接以与服务器通信。连接对象可以作为显式参数提供，或者可以以其他方式关联。例如，作为自定义Java类的属性。如果包装器方法使用的连接对象是非静态属性，则包装器方法必须是自定义Java类的实例方法才能访问该连接。</p>
                     <p>Oracle对象的方法中也存在有关输出和输入输出参数的问题。如果存储过程（即SQL对象方法）修改其某个参数的内部状态，则会修改传递给存储过程的实际参数。在Java中，这是不可能的。从存储过程调用返回JDBC输出参数时，它必须存储在新创建的对象中。原始对象标识丢失。</p>
                     <p>将输出或输入输出参数返回给调用者的一种方法是将参数作为数组的元素传递。如果参数是输入输出，则包装器方法将数组元素作为输入。处理完成后，包装器将输出分配给数组元素。</p>
                  </div>
               </div><a id="JSQLJ424"></a><a id="JSQLJ425"></a><a id="JSQLJ426"></a><a id="JSQLJ427"></a><a id="JSQLJ423"></a><div class="props_rev_3"><a id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" name="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D"></a><h4 id="JSQLJ-GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" class="sect4">自定义Java类要求</h4>
                  <div>
                     <div class="section">
                        <p>自定义Java类必须满足某些要求，以便Oracle SQLJ转换程序将其识别为有效的主机变量类型，并启用转换程序的类型检查。</p>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-11C55F73-1AA9-4697-8B54-BDA0EA01B7A5">
                           <p class="notep1">注意：</p>
                           <p>用户定义类型的自定义Java类在本手册中通常称为“包装类”。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005846">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-6F102C1C-7597-47AE-96DB-651AD0D4E593">Oracle对类实现ORAData的要求</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于任何类型的自定义Java类， <code class="codeph">ORAData</code>实现的Oracle要求<code class="codeph">ORAData</code>相同，但根据该类是否用于映射到对象，对象引用，集合或某些其他SQL类型而略有不同。
                        </p>
                        <p>这些要求如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该类实现了<code class="codeph">oracle.sql.ORAData</code>接口。
                              </p>
                           </li>
                           <li>
                              <p>该类实现了返回<code class="codeph">oracle.sql.的<code class="codeph">getORADataFactory()</code>方法<code class="codeph">oracle.sql.ORADataFactory</code>对象。方法签名如下：</p><pre class="oac_no_warn" dir="ltr">public static oracle.sql。ORADataFactory getORADataFactory（）;</pre></li>
                           <li>
                              <p>该类有一个<code class="codeph">String</code>常量<code class="codeph">_SQL_TYPECODE</code> ，初始化为<code class="codeph">oracle.jdbc.OracleTypes</code>类型代码是<code class="codeph">toDatum()</code>返回的<code class="codeph">Datum</code>子类实例的类型代码。类型代码是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>对于自定义对象类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。STRUCT;</pre></li>
                                 <li>
                                    <p>对于自定义引用类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。REF;</pre></li>
                                 <li>
                                    <p>对于自定义集合类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。ARRAY;</pre></li>
                              </ul>
                              <p>对于其他用途，某些其他类型的代码可能是合适的。例如，使用自定义Java类将Java对象序列化和反序列化为<code class="codeph">RAW</code>字段或从<code class="codeph">RAW</code>字段中反序列化<code class="codeph">OracleTypes.的<code class="codeph">_SQL_TYPECODE</code> <code class="codeph">OracleTypes.RAW</code> 。
                              </p>
                              <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-4E064F67-09E6-4981-A253-435722E9E50E">
                                 <p class="notep1">注意：</p>
                                 <p><code class="codeph">OracleTypes</code>类只为每种Oracle数据类型定义一个类型代码，它是一个整型常量。对于标准SQL类型， <code class="codeph">OracleTypes</code>条目与标准<code class="codeph">java.sql.的条目相同<code class="codeph">java.sql.Types</code>定义类。
                                 </p>
                              </div>
                              <div class="infoboxnotealso" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-0CCC42C7-3E76-4C14-8B6E-ED26B8E63F89">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化Java对象</a> ”</span></p>
                              </div>
                           </li>
                           <li>
                              <p>对于具有<code class="codeph">STRUCT</code> ， <code class="codeph">REF</code>或<code class="codeph">ARRAY</code> <code class="codeph">_SQL_TYPECODE</code>的自定义Java类，即，对于表示对象，对象引用或集合的自定义Java类，该类具有一个常量，指示相关的用户定义的类型名称。具体如下：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>自定义对象类和自定义集合类必须具有<code class="codeph">String</code>常量<code class="codeph">_SQL_NAME</code> ，初始化为您为用户定义类型声明的SQL名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = <span class="italic">UDT name</span> ;</pre><p>例如，用户定义的<code class="codeph">PERSON</code>对象的自定义对象类将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON”;</pre><p>如果合适，可以与模式一起指定相同的内容，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“HR.PERSON”;</pre><p><code class="codeph">PERSON</code>对象集合的自定义集合类（已声明为<code class="codeph">PERSON_ARRAY</code> ）将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON_ARRAY”;</pre></li>
                                 <li>
                                    <p>自定义引用类必须具有<code class="codeph">String</code>常量<code class="codeph">_SQL_BASETYPE</code> ，初始化为您为引用的用户定义类型声明的SQL名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE = <span class="italic">UDT name</span> ;</pre><p><code class="codeph">PERSON</code>引用的自定义引用类将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE =“PERSON”;</pre><p>对于其他<code class="codeph">ORAData</code>用法，指定UDT名称不适用。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>请记住以下使用说明：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集合类型名称反映集合类型，而不是基本类型。例如，如果您为<code class="codeph">PERSON</code>对象声明了VARRAY或嵌套表类型<code class="codeph">PERSON_ARRAY</code> ，那么您为<code class="codeph">_SQL_NAME</code>条目指定的集合类型的名称是<code class="codeph">PERSON_ARRAY</code> ，而不是<code class="codeph">PERSON</code> 。</p>
                           </li>
                           <li>
                              <p>在<code class="codeph">_SQL_NAME</code>字段中指定SQL类型时，如果以类型敏感的方式（在引号中）声明SQL类型，则必须完全按照声明的方式指定SQL名称，例如<code class="codeph">CaseSensitive</code>或<code class="codeph">HR.CaseSensitive</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005901">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-066060FB-A06B-4EBB-9A1C-72989676D075">实现SQLData的类的要求</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>ISO SQLJ标准概述了实现<code class="codeph">SQLData</code>接口的类的类型映射定义的要求。或者， <code class="codeph">SQLData</code>包装类可以通过<code class="codeph">public static final</code>字段标识关联的SQL对象类型。
                        </p>
                        <p>请注意以下要点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>无论是使用类型映射还是使用备用（非标准） <code class="codeph">public static final</code>字段来指定映射，您的方法都必须保持一致。使用指定所有相关映射的类型映射，以便不需要<code class="codeph">public static final</code>字段，或者根本不使用类型映射，并通过<code class="codeph">public static final</code>字段指定所有映射。
                              </p>
                           </li>
                           <li>
                              <p>与<code class="codeph">ORAData</code>不同， <code class="codeph">SQLData</code>仅用于映射结构化对象类型。它不适用于对象引用，集合或数组或任何其他SQL类型。如果您没有使用<code class="codeph">ORAData</code> ，那么映射对象引用和集合的唯一选择是弱<code class="codeph">java.sql.Ref</code>和<code class="codeph">java.sql.Array</code>类型，分别是<code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code>实现需要Java Development Kit（JDK）1.4.x或1.5.x环境。
                              </p>
                           </li>
                           <li>
                              <p>在指定从SQL类型到Java类型的映射时，如果以类型敏感的方式声明SQL类型，则必须完全按照声明的方式指定SQL名称，例如<code class="codeph">CaseSensitive</code>或<code class="codeph">HR.CaseSensitive</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-43CB770B-3D70-4FF9-9429-F42104B9B158">类型映射资源中指定的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>首先，根据ISO SQLJ标准考虑映射表示。假设<code class="codeph">Address</code> ， <code class="codeph">pack.Person</code> ，和<code class="codeph">pack.经理。InnerPM</code> ，其中<code class="codeph">InnerPM</code>是<code class="codeph">Manager</code>的内部类，是三个实现<code class="codeph">java.sql.包装类<code class="codeph">java.sql.SQLData</code> 。
                        </p>
                        <p>然后，您需要考虑以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须仅在使用声明的连接上下文类型的显式连接上下文实例的语句中使用这些类。例如，假设此类型称为<code class="codeph">SDContext</code> ：</p><pre class="oac_no_warn" dir="ltr">地址a = ......;包。人p = ......;包。经理。InnerPM pm = ...; SDContext ctx = new SDContext（url，user，pwd，false）; #sql [ctx] {...：a ...：p ...：pm ...};</pre></li>
                           <li>
                              <p>必须使用<code class="codeph">with</code>属性<code class="codeph">typeMap</code>声明连接上下文类型，该属性指定实现<code class="codeph">java.util.的关联类<code class="codeph">java.util.PropertyResourceBundle</code> 。在前面的示例中， <code class="codeph">SDContext</code>可以声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql public static context SDContext with（typeMap =“SDMap”）;</pre></li>
                           <li>
                              <p>类型映射资源必须提供从SQL对象类型到实现<code class="codeph">java.sql.相应Java类的映射<code class="codeph">java.sql.SQLData</code>接口。使用以下格式的条目指定此映射：</p><pre class="oac_no_warn" dir="ltr">class.java_class_name = STRUCT sql_type_name</pre><p><code class="codeph">STRUCT</code>关键字也可以省略。在该示例中， <code class="codeph">SDMap.properties</code>资源文件可能包含以下条目：</p><pre class="oac_no_warn" dir="ltr">类。Address = STRUCT HR.ADDRESS class.pack。Person = PERSON class.pack。经理$ InnerPM = STRUCT PRODUCT_MANAGER</pre><p>虽然句点（。）分隔了包名和类名，但<span class="italic">必须</span>使用美元符号（$）来分隔内部类名。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-E739A417-D3D5-4D36-9A46-3C5EA7BE37CE">
                           <p class="notep1">注意：</p>
                           <p>如果在此示例中使用了默认的Oracle特定代码生成，那么用于上下文类型为<code class="codeph">SDContext</code>的语句的任何迭代器也必须使用相同的关联类型映射<code class="codeph">SDMap</code> ，如下例所示：</p><pre class="oac_no_warn" dir="ltr">#sql public static iterator SDIter with（typeMap =“SDMap”）; ...SDContext sdctx = ...SDIter sditer; #sql [sdctx] sditer = {SELECT ...};</pre><p>这是为了确保为迭代器类生成正确的代码。</p>
                        </div>
                        <p>这种在类型映射资源中指定映射的机制比非标准替代方法更复杂。此外，无法将类型映射资源与默认连接上下文相关联。优点是所有映射信息都放在一个位置，即类型映射资源。这意味着可以在以后轻松调整已编译应用程序中的类型映射，例如，在扩展的SQL-Java类型层次结构中容纳新的SQL类型和Java包装器。</p>
                        <p>请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您必须使用SQLJ <code class="codeph">runtime12</code>或<code class="codeph">runtime12ee</code>库来使用此功能。类型映射表示为<code class="codeph">java.util.Map</code>对象。它们在SQLJ运行时API中公开，因此通用运行时库<span class="italic">不</span>支持。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">SQLData</code>包装类在SQLJ语句中作为<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>参数出现，则必须使用Oracle SQLJ运行时和Oracle特定的代码生成或配置文件自定义。这是因为Oracle JDBC驱动程序需要这种参数的SQL类型为<code class="codeph">registerOutParameter()</code> 。此外，对于<code class="codeph">OUT</code>参数类型注册，SQL类型在转换期间由类型映射“冻结”。
                              </p>
                           </li>
                           <li>
                              <p>SQLJ类型映射独立于您可能在底层连接上使用的任何JDBC类型映射。因此，如果两者都使用<code class="codeph">SQLData</code>包装器，则在混合SQLJ和JDBC代码时必须小心。但是，您可以轻松地提取对给定SQLJ连接上下文有效的类型映射：</p><pre class="oac_no_warn" dir="ltr">ctx.getTypeMap（）;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-FEAB3CB0-F57A-4DD3-B257-42E3D6810583">包装类静态字段中指定的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>实现<code class="codeph">SQLData</code>的类可以满足以下非标准要求：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>Java类声明<code class="codeph">String</code>常量<code class="codeph">_SQL_NAME</code> ，它定义了Java类包装的SQL类型的名称。在示例中， <code class="codeph">Address</code>类将具有以下字段声明：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“HR.ADDRESS”;</pre><p>以下声明将<code class="codeph">pack.Person</code> ：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON”;</pre><p>和<code class="codeph">pack.经理。InnerPM</code>类将具有以下内容：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PRODUCT_MANAGER”;</pre></li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-30647C5B-96B2-47B1-BEDF-6A9FC67D9CD9">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果在具有显式连接上下文类型和关联类型映射的SQLJ语句中使用实现<code class="codeph">_SQL_NAME</code>字段的类，则使用该类型映射并忽略<code class="codeph">_SQL_NAME</code>字段。这简化了现有SQLJ程序到ISO SQLJ标准的迁移。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">_SQL_NAME</code>字段中指定的静态SQL-Java类型对应关系与您在底层连接上使用的任何JDBC类型映射无关。因此，如果两者都使用<code class="codeph">SQLData</code>包装器，则在混合SQLJ和JDBC代码时必须小心。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ428"></a><div class="props_rev_3"><a id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B" name="GUID-700E14BF-E4F8-4A36-9092-05000452C60B"></a><h4 id="JSQLJ-GUID-700E14BF-E4F8-4A36-9092-05000452C60B" class="sect4">编译自定义Java类</h4>
                  <div>
                     <div class="section">
                        <p>您可以在SQLJ命令行中为自定义Java类（无论是<code class="codeph">ORAData</code>还是<code class="codeph">SQLData</code>实现）包含任何<code class="codeph">.java</code>文件以及应用程序的<code class="codeph">.sqlj</code>文件。但是，如果SQLJ <code class="codeph">-checksource</code>标志设置为<code class="codeph">true</code> （默认值），并且类路径包含自定义Java源所在的目录，则<code class="codeph">-checksource</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-D2BCD3EE-5E8D-49F0-9698-BDDA15D07FFA">
                           <p class="notep1">注意：</p>
                           <p>本讨论假定您正在为自定义对象和集合创建<code class="codeph">.java</code>文件，而不是<code class="codeph">.sqlj</code>文件。任何<code class="codeph">.sqlj</code>文件都必须包含在SQLJ命令行中。
                           </p>
                        </div>
                        <p>例如，如果<code class="codeph">ObjectDemo.sqlj</code>使用<code class="codeph">ADDRESS</code>和<code class="codeph">PERSON</code> Oracle对象类型，并且您已为这些对象生成自定义Java类，则可以按如下方式运行SQLJ。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">-checksource=true</code>且类路径包含自定义Java源位置：</p><pre class="oac_no_warn" dir="ltr">％sqlj ObjectDemo.sqlj</pre></li>
                           <li>
                              <p>如果<code class="codeph">-checksource=false</code> （这是一条环绕线）：</p><pre class="oac_no_warn" dir="ltr">％sqlj ObjectDemo.sqlj Address.java AddressRef.java Person.java PersonRef.java</pre></li>
                        </ul>
                        <p>您还可以选择使用Java编译器直接编译自定义<code class="codeph">.java</code>源文件。如果您这样做，那么您必须在翻译<code class="codeph">.sqlj</code>文件之前执行此操作。
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-03FD8712-CC7C-4A68-B275-EE9BB22F03B5">
                           <p class="notep1">注意：</p>
                           <p>由于<code class="codeph">ORAData</code>实现依赖于Oracle特定的功能，因此如果您不使用<code class="codeph">-warn=noportable</code>转换器可移植性设置（默认设置），SQLJ将报告大量可移植性警告。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ429"></a><div class="props_rev_3"><a id="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" name="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7"></a><h4 id="JSQLJ-GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" class="sect4">阅读和编写自定义数据</h4>
                  <div>
                     <div class="section">
                        <p>通过使用自定义Java类实例，Oracle SQLJ和JDBC实现允许您读取和编写用户定义的类型，就像它们是内置类型一样。究竟如何实现这一点对用户来说是透明的。</p>
                        <p>有关如何读取和写入数据的机制，对于<code class="codeph">ORAData</code>实现和<code class="codeph">SQLData</code>实现，请参阅<a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ431"></a><a id="JSQLJ430"></a><div class="props_rev_3"><a id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" name="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3"></a><h4 id="JSQLJ-GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" class="sect4">ORAData实现的其他用途</h4>
                  <div>
                     <div class="section">
                        <p>到目前为止，对自定义Java类的讨论已被用作以下之一。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL对象的包装器：自定义对象类，用于<code class="codeph">oracle.sql.STRUCT</code>实例</p>
                           </li>
                           <li>
                              <p>SQL引用的包装器：自定义引用类，用于<code class="codeph">oracle.sql.REF</code>实例</p>
                           </li>
                           <li>
                              <p>SQL集合的包装器：自定义集合类，用于<code class="codeph">oracle.sql.ARRAY</code>实例</p>
                           </li>
                        </ul>
                        <p>但是，提供自定义Java类以包装其他<code class="codeph">oracle.sql.*</code>类型，以进行自定义转换或处理可能会很有用。您可以使用实现<code class="codeph">ORAData</code>但不是<code class="codeph">SQLData</code>类来完成此操作，如以下示例所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>执行数据的加密和解密或验证。</p>
                           </li>
                           <li>
                              <p>执行已读取或正在写入的值的记录。</p>
                           </li>
                           <li>
                              <p>将字符列（例如包含URL信息的字符字段）解析为较小的组件。</p>
                           </li>
                           <li>
                              <p>将字符串映射到数字常量。</p>
                           </li>
                           <li>
                              <p>将数据映射到更理想的Java格式，例如将<code class="codeph">DATE</code>字段映射到<code class="codeph">java.util.Date</code>格式。
                              </p>
                           </li>
                           <li>
                              <p>自定义数据表示，例如，表格列中的数据以英尺为单位，但您希望在选择后以米为单位表示。</p>
                           </li>
                           <li>
                              <p>将Java对象序列化和反序列化，例如，进入或退出<code class="codeph">RAW</code>字段。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D6E68D4B-71B8-4068-BAE0-1BBBB741C629">
                           <p class="notep1">注意：</p>
                           <p>通过<code class="codeph">SQLData</code>接口无法实现这种功能，因为<code class="codeph">SQLData</code>实现只能包装结构化对象类型。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-02339C2A-8772-490B-9FCC-DBD04CE1050D">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化Java对象</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D49D802B-B373-4078-8EB6-1EB63B54EDD0">ORAData的一般用法：BetterDate.java</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例显示了一个实现<code class="codeph">ORAData</code>接口的类，以提供Java日期的自定义表示，并可用于代替<code class="codeph">java.sql.Date</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-9395F43C-FEE6-4060-A640-D4D3FC5EE3AC">
                           <p class="notep1">注意：</p>
                           <p>这不是一个完整的应用程序。没有<code class="codeph">main()</code>方法。
                           </p>
                        </div><pre class="oac_no_warn" dir="ltr">import java.util。日期; import oracle.sql。ORADATA; import oracle.sql。日期; import oracle.sql。ORADataFactory; import oracle.jdbc。OracleTypes; //为用户的首选项定制的日期类：//  - 月份是数字1..12，而不是0..11 //  - 年份是通过四位数字而不是两位来引用的。公共类BetterDate扩展了java.util。Date实现ORAData，ORADataFactory {public static final int _SQL_TYPECODE = OracleTypes。日期; String [] monthNames = {“JAN”，“FEB”，“MAR”，“APR”，“MAY”，“JUN”，“JUL”，“AUG”，“SEP”，“OCT”，“NOV”， “DEC”}; String [] toDigit = {“0”，“1”，“2”，“3”，“4”，“5”，“6”，“7”，“8”，“9”}; static final BetterDate _BetterDateFactory = new BetterDate（）; public static ORADataFactory getORADataFactory（）{return _BetterDateFactory;} //当前时间......public BetterDate（）{super（）; public oracle.sql。Datum toDatum（java.sql。连接conn）{return new DATE（toSQLDate（））; public oracle.sql。ORAData create（oracle.sql。Datum dat，int intx）{if（dat == null）返回null; DATE DAT =（（DATE）dat）; java.sql中。日期jsd = DAT.dateValue（）;返回新的BetterDate（jsd）; public java.sql。日期toSQLDate（）{java.sql。日期延期; retval = new java.sql。Date（this.getYear（） -  1900，this.getMonth（） -  1，this.getDate（））;返回; public BetterDate（java.sql。日期d）{this（d.getYear（）+ 1900，d.getMonth（）+ 1，d.getDate（））; private static int [] deconstructString（String s）{int [] retval = new int [3]; int y，m，d; char temp; int offset; StringBuffer sb = new StringBuffer（s）;温度= sb.charAt（1）; //计算月中的日期if（temp &lt;'0'|| temp&gt;'9'）{m = sb.charAt（0） - '0';偏移量= 2; } else {m =（sb.charAt（0） - '0'）* 10 +（temp-'0'）;偏移量= 3; } //计算月份temp = sb.charAt（offset + 1）; if（temp &lt;'0'|| temp&gt;'9'）{d = sb.charAt（offset） - '0';偏移+ = 2; } else {d =（sb.charAt（offset） - '0'）* 10 +（temp-'0'）;偏移+ = 3; } //计算年份，格式为“yy”或“yyyy”//（前者假设当前世纪）if（sb.length（）&lt;=（offset + 2））{y =（（ （new BetterDate（））。getYear（））/ 100）* 100 +（sb.charAt（offset） - '0'）* 10 +（sb.charAt（offset + 1） - '0'）; } else {y =（sb.charAt（offset） - '0'）* 1000 +（sb.charAt（offset + 1） - '0'）* 100 +（sb.charAt（offset + 2） - '0' ）* 10 +（sb.charAt（偏移+3） - '0'）; } retval [0] = y; RETVAL [1] =米; RETVAL [2] = d; // System.out.println（“从字符串构造日期为：”+ d +“/”+ m +“/”+ y）;返回;私有BetterDate（int [] stuff）{this（stuff [0]，stuff [1]，stuff [2]）; } //采用以下格式的字符串：“mm-dd-yyyy”或“mm / dd / yyyy”或//“mm-dd-yy”或“mm / dd / yy”（假设当前世纪） public BetterDate（String s）{this（BetterDate.deconstructString（s））; } //年为'1990'，月份为1..12（与java.util不同）。日期！），日期//为'1'到'31'公共BetterDate（int year，int months，int date）{super（year-1900，months-1，date）; } //返回“Date：dd-mon-yyyy”public String toString（）{int yr = getYear（）; return getDate（）+“ - ”+ monthNames [getMonth（） -  1] +“ - ”+ toDigit [（yr / 1000）％10] + toDigit [（yr / 100）％10] + toDigit [（年/ 10 ）％10] + toDigit [yr％10]; //返回“Date：”+ getDate（）+“ - ”+ getMonth（）+“ - ”+（getYear（）％100）; public BetterDate addDays（int i）{if（i == 0）return this;返回new BetterDate（getYear（），getMonth（），getDate（）+ i）; public BetterDate addMonths（int i）{if（i == 0）return this; int yr = getYear（）; int mon = getMonth（）+ i; int dat = getDate（）; while（mon &lt;1）{--yr; mon + = 12;返回new BetterDate（yr，mon，dat）; } //返回year，如1996年，2007年public int getYear（）{return super.getYear（）+ 1900; } //将month返回为1..12 public int getMonth（）{return super.getMonth（）+ 1; public boolean equals（BetterDate sd）{return（sd.getDate（）== this.getDate（）&amp;&amp; sd.getMonth（）== this.getMonth（）&amp;&amp; sd.getYear（）== this.getYear（）） ; } //减去两个日期;返回全年的答案//使用一年的平均长度，即365天加上//每4个闰年，除了100，除了400年= // = 365 97/400 = 365.2425天= 31,556,952秒公开double minusInYears（BetterDate sd）{//年份（如前文所定义），以毫秒为单位longInInLillis = 31556952L; long diff = myUTC（） -  sd.myUTC（）; return（（（double）diff /（double）yearInMillis）/1000.0）; public long myUTC（）{return Date。UTC（getYear（） -  1900，getMonth（） -  1，getDate（），0,0,0）; } //返回&lt;0如果它早于sd //则返回=如果这= = sd // else返回&gt; 0 public int compare（BetterDate sd）{if（getYear（）！= sd.getYear（））{return getYear（） -  sd.getYear（）;} if（getMonth（）！= sd.getMonth（））{return getMonth（） -  sd.getMonth（）;} return getDate（） -  sd.getDate（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ433"></a><a id="JSQLJ434"></a><a id="JSQLJ432"></a><div class="props_rev_3"><a id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" name="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B"></a><h3 id="JSQLJ-GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" class="sect3">用户定义的类型</h3>
               <div>
                  <div class="section">
                     <p>本节包含在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中创建和使用用户定义的对象类型和集合类型的示例。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006222">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-0999BCAD-A95F-4507-B369-D93708A039AD">创建对象类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>用于创建对象类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS OBJECT（ <span class="italic">attrname1 datatype1</span> ， <span class="italic">attrname2 datatype2</span> ，......）
  <span class="italic">attrnameN datatypeN</span> ）;</pre><p>其中<span class="italic"><code class="codeph">typename</code></span>是对象类型的所需名称， <span class="italic"><code class="codeph">attrname1</code></span>到<span class="italic"><code class="codeph">attrnameN</code></span>是所需的属性名称， <span class="italic"><code class="codeph">datatype1</code></span>到<span class="italic"><code class="codeph">datatypeN</code></span>是属性数据类型。
                     </p>
                     <p>本节的其余部分提供了在Oracle Database 12 <span class="italic">c</span>第1版（12.1）中创建用户定义的对象类型的示例。
                     </p>
                     <p>在此示例中，使用SQL创建以下项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两种对象类型， <code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PERSON</code>对象的类型表</p>
                        </li>
                        <li>
                           <p>一个<code class="codeph">EMPLOYEES</code>表，其中包含<code class="codeph">ADDRESS</code>列和两列<code class="codeph">PERSON</code>引用</p>
                        </li>
                     </ul>
                     <p>创建这些项目的脚本如下：</p><pre class="oac_no_warn" dir="ltr">/ ***在SQLJ中使用用户定义的类型（UDT）*** / / / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），状态CHAR （2），zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ / ***为PERSON对象创建一个类型表*** / CREATE TABLE人员人员/ / ***创建一个关系表，其中包含两列作为PERSON对象的REF，以及一个作为地址ADT的列。 *** / CREATE TABLE员工（人数为INTEGER PRIMARY KEY，person_data REF PERSON，经理REF PERSON，office_addr ADDRESS，工资号码）/ ***将一些数据 -  2个对象插入到人员类型表中*** / INSERT INTO人员价值观（人物（'Wolfgang Amadeus Mozart'，123456，ADDRESS（'Am Berg 100'，'Salzburg'，'AT'，'10424'）））/ INSERT INTO VALUES（PERSON（'Ludwig van Beethoven'，234567， ADDRESS（'Rheinallee'，'Bonn'，'DE'，'69234'）））/ / **在员工表中添加一行** / INSERT INTO员工（empnumber，office_addr，薪水）VALUES（1001，ADDRESS（ '500 Oracle Parkway'，'Redwood Shores'，'CA'，'94065'），50000）/ / **为员工设置经理和PERSON REF ** / UPDATE员工SET manager =（SELECT REF（p）FROM人员p WHERE p.name ='Wolfgang Amadeus Mozart'）/ UPDATE员工SET person_data =（SELECT REF（p）FROM人员p WHERE p.name ='Ludwig van Beethoven'）</pre><div class="infoboxnote" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-8AB87128-031C-4267-9A11-6945A39C8326">
                        <p class="notep1">注意：</p>
                        <p>在SQL SQL实现中，建议使用表别名（例如<code class="codeph">p</code>中的<code class="codeph">p</code> ，尤其是在访问具有用户定义类型的表时。在某些情况下，访问对象属性是必需的语法。即使不需要，也有助于避免含糊不清。有关表别名的更多信息，请参阅<a href="../sqlrf/Data-Types.html#SQLRF-GUID-7CF27C66-9908-4C02-9401-06C2F2C4021C" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006305">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-C5274E1D-36DB-4983-9C7E-BA6135481AF5">创建集合类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>有两类收藏</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可变长度数组（VARRAY）</p>
                        </li>
                        <li>
                           <p>嵌套表</p>
                        </li>
                     </ul>
                     <p>用于创建VARRAY类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> IS VARRAY（ <span class="italic">n</span> ）OF <span class="italic">数据类型</span> ;</pre><p><span class="italic"><code class="codeph">typename</code></span>标识是VARRAY类型的所需名称， <span class="italic"><code class="codeph">n</code></span>是数组中所需的最大元素数， <span class="italic"><code class="codeph">datatype</code></span>是数组元素的数据类型。例如：</p><pre class="oac_no_warn" dir="ltr">创建类型myvarr IS VARRAY（10）OF INTEGER;</pre><p>用于创建嵌套表类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS TABLE OF <span class="italic">数据类型</span> ;</pre><p><span class="italic"><code class="codeph">typename</code></span>指定是嵌套表类型的所需名称， <span class="italic"><code class="codeph">datatype</code></span>是表元素的数据类型。这可以是用户定义的类型以及标准数据类型。嵌套表仅限于一列，但该列类型可以是具有多个属性的复杂对象。与任何数据库表一样，嵌套表可以包含任意数量的行。例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_array AS TABLE of person;</pre><p>此命令创建一个嵌套表，其中每一行都包含一个<code class="codeph">PERSON</code>对象。
                     </p>
                     <p>本节的其余部分提供了在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中创建用户定义的集合类型以及对象类型的示例。
                     </p>
                     <p>使用SQL创建并填充以下项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两种对象类型， <code class="codeph">PARTICIPANT_T</code>和<code class="codeph">MODULE_T</code></p>
                        </li>
                        <li>
                           <p>一种集合类型<code class="codeph">MODULETBL_T</code> ，它是<code class="codeph">MODULE_T</code>对象的嵌套表</p>
                        </li>
                        <li>
                           <p><code class="codeph">PROJECTS</code>表，其中包含一列<code class="codeph">PARTICIPANT_T</code>引用和一列<code class="codeph">MODULETBL_T</code>嵌套表</p>
                        </li>
                        <li>
                           <p>集合类型<code class="codeph">PHONE_ARRAY</code> ，它是<code class="codeph">VARCHAR2(30)</code>的VARRAY <code class="codeph">VARCHAR2(30)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code>对象（重复前面使用的相同定义）</p>
                        </li>
                        <li>
                           <p><code class="codeph">EMPLOYEES</code>表，包含<code class="codeph">PHONE_ARRAY</code>列</p>
                        </li>
                     </ul>
                     <p>创建这些项目的脚本如下：</p><pre class="oac_no_warn" dir="ltr">Rem这是一个SQL * Plus脚本，用于创建模式以演示SQLJ CREATE TYPE PARTICIPANT_T AS OBJECT中的集合Rem操作（empno NUMBER（4），ename VARCHAR2（20），job VARCHAR2（12），mgr NUMBER（4），hiredate DATE，sal NUMBER（7,2），deptno NUMBER（2））/ SHOW ERRORS创建类型MODULE_T作为对象（module_id NUMBER（4），module_name VARCHAR2（20），module_owner REF PARTICIPANT_T，module_start_date DATE，module_duration NUMBER）/显示错误创建类型MODULETBL_T作为MODULE_T表; / SHOW ERRORS CREATE TABLE项目（id NUMBER（4），name VARCHAR（30），owner REF PARTICIPANT_T，start_date DATE，duration NUMBER（3），modules MODULETBL_T）NESTED TABLE modules STORE AS modules_tab;显示错误创建类型PHONE_ARRAY是varchar2（30）的VARRAY（10）/ / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），州CHAR（2） ，zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ CREATE TABLE employees（empnumber INTEGER PRIMARY KEY，person_data REF人，经理REF人，office_addr地址，工资号码，phone_nums phone_array）/</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSQLJ467"></a><div class="props_rev_3"><a id="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" name="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810"></a><h3 id="JSQLJ-GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" class="sect3">SQLJ可执行语句中的强类型对象和引用</h3>
               <div>
                  <p>Oracle SQLJ实现非常灵活，它使您能够在通过强类型对象或引用读取或写入对象数据时使用主机表达式和迭代器。</p>
                  <p>对于迭代器，您可以将自定义对象类用作迭代器列类型。或者，您可以使用适当映射到属性的SQL数据类型的列类型，使用与范围表类似的对应于单个对象属性的迭代器列。</p>
                  <p>对于主机表达式，您可以使用自定义对象类类型或自定义引用类类型的主机变量。或者，您可以使用与对象属性对应的主变量，使用适当映射到属性的SQL数据类型的变量类型。</p>
                  <p>本节的其余部分提供了如何使用自定义对象类，自定义对象类属性以及SQLJ可执行语句中的主机变量和迭代器列的自定义引用类来操作Oracle对象的示例。</p>
                  <p>以下两个示例在对象级别运行：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84">选择对象和对象引用到迭代器列中</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B">更新对象</a></p>
                     </li>
                  </ul>
                  <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013">插入从单个对象属性创建的对象</a>示例在标量属性级别运行。
                  </p>
                  <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51">更新对象参考</a>示例通过引用进行操作。
                  </p>
               </div><a id="JSQLJ468"></a><div class="props_rev_3"><a id="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" name="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84"></a><h4 id="JSQLJ-GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" class="sect4">选择对象和对象引用到迭代器列中</h4>
                  <div>
                     <div class="section">
                        <p>此示例使用自定义Java类和自定义引用类作为迭代器列类型。假设<code class="codeph">ADDRESS</code> Oracle对象类型的以下定义：</p><pre class="oac_no_warn" dir="ltr">创建类型地址作为对象（街道VARCHAR（40），zip NUMBER）;</pre><p>以及<code class="codeph">EMPADDRS</code>表的以下定义，其中包括<code class="codeph">ADDRESS</code>列和<code class="codeph">ADDRESS</code>参考列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE empaddrs（名称VARCHAR（60），home ADDRESS，loc REF ADDRESS）;</pre><p>一旦创建了与<code class="codeph">ADDRESS</code> Oracle对象类型对应的自定义Java类， <code class="codeph">Address</code>和自定义引用类<code class="codeph">AddressRef</code> ，就可以在命名迭代器中使用<code class="codeph">Address</code>和<code class="codeph">AddressRef</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter（String name，Address home，AddressRef loc）; ...Emp eter ecur; #sql ecur = {SELECT name，home，loc FROM empaddrs}; while（ecur.next（））{Address homeAddr = ecur.home（）; //打印出家庭住址。System.out.println（“Name：”+ ecur.name（）+“\ n”+“Home address：”+ homeAddr.getStreet（）+“”+ homeAddr.getZip（））; //现在通过地址参考更新loc地址邮政编码。AddressRef homeRef = ecur.loc（）;地址location = homeRef.getValue（）; location.setZip（new BigDecimal（98765））; homeRef.setValue（位置）; } ...
</pre><p><code class="codeph">ecur.home()</code>方法调用从迭代器的<code class="codeph">home</code>列中提取<code class="codeph">Address</code>对象，并将其分配给<code class="codeph">homeAddr</code>局部变量（为了提高效率）。然后可以使用标准Java点语法访问该对象的属性：</p><pre class="oac_no_warn" dir="ltr">homeAddr.getStreet（）</pre><p>使用<code class="codeph">getValue()</code>和<code class="codeph">setValue()</code>方法来操作位置地址（在本例中为其邮政编码）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ469"></a><div class="props_rev_3"><a id="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" name="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B"></a><h4 id="JSQLJ-GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" class="sect4">更新对象</h4>
                  <div>
                     <div class="section">
                        <p>此示例声明并设置<code class="codeph">Address</code> Java类型的输入主机变量，以更新<code class="codeph">employees</code>表的列中的<code class="codeph">ADDRESS</code>对象。在更新之前和之后，地址被选择为<code class="codeph">Address</code>类型的输出主变量并打印以进行验证。
                        </p><pre class="oac_no_warn" dir="ltr">...//更新对象static void updateObject（）{Address addr;地址new_addr; int empnum = 1001;试试{#sql {SELECT office_addr INTO：addr FROM employees WHERE empnumber =：empnum}; System.out.println（“员工1001的当前办公地址：”）; printAddressDetails（addr）;将/ *现在更新地址街道* / String street =“100 Oracle Parkway”; addr.setStreet（街道）; / *将更新的对象放回数据库中* / try {#sql {UPDATE employees SET office_addr =：addr WHERE empnumber =：empnum}; System.out.println（“将员工1001更新为Oracle Parkway的新地址。”）; / *选择新地址以验证更新* / try {#sql {SELECT office_addr INTO：new_addr FROM employees WHERE empnumber =：empnum}; System.out.println（“员工1001的新办公地址：”）; printAddressDetails（new_addr）; } catch（SQLException exn）{System.out.println（“Verification SELECT failed with”+ exn）; catch（SQLException exn）{System.out.println（“UPDATE failed with”+ exn）; catch（SQLException exn）{System.out.println（“SELECT failed with”+ exn）; } ...
</pre><p>请注意使用<code class="codeph">Address</code>对象的<code class="codeph">setStreet()</code>访问器方法。
                        </p>
                        <p>此示例使用<code class="codeph">printAddressDetails()</code>实用程序。此方法的源代码如下：</p><pre class="oac_no_warn" dir="ltr">static void printAddressDetails（Address a）抛出SQLException {if（a == null）{System.out.println（“No Address available。”）;返回; } String street =（（a.getStreet（）== null）？“NULL street”：a.getStreet（））; String city =（a.getCity（）== null）？“NULL city”：a.getCity（）;字符串状态=（a.getState（）== null）？“NULL状态”：a.getState（）;字符串zip_code =（a.getZipCode（）== null）？“NULL zip”：a.getZipCode（）; System.out.println（“Street：'”+ street +“'”）; System.out.println（“City：'”+ city +“'”）; System.out.println（“State：'”+ state +“'”）; System.out.println（“Zip：'”+ zip_code +“'”）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ470"></a><div class="props_rev_3"><a id="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" name="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013"></a><h4 id="JSQLJ-GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" class="sect4">插入从单个对象属性创建的对象</h4>
                  <div>
                     <div class="section">
                        <p>此示例声明并设置与<code class="codeph">PERSON</code>属性和嵌套<code class="codeph">ADDRESS</code>对象相对应的输入主机变量，然后使用这些值将新<code class="codeph">PERSON</code>对象插入到数据库中的<code class="codeph">persons</code>表中。
                        </p><pre class="oac_no_warn" dir="ltr">...//插入对象static void insertObject（）{String new_name =“NEW PERSON”; int new_ssn = 987654; String new_street =“NEW STREET”; String new_city =“NEW CITY”; String new_state =“NS”; String new_zip =“NZIP”; / * *在person表中插入一个新的PERSON对象* / try {#sql {INSERT INTO人VALUES（PERSON（：new_name，：new_ssn，ADDRESS（：new_street，：new_city，：new_state，：new_zip）））}; System.out.println（“Inserted PERSON object NEW PERSON。”）; } catch（SQLException exn）{System.out.println（“INSERT failed with”+ exn）; } ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ471"></a><div class="props_rev_3"><a id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" name="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51"></a><h4 id="JSQLJ-GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" class="sect4">更新对象引用</h4>
                  <div>
                     <div class="section">
                        <p>本实施例中选择一个<code class="codeph">PERSON</code>从参考<code class="codeph">persons</code>表并使用它来更新<code class="codeph">PERSON</code>在参考<code class="codeph">employees</code>表。它使用简单的输入主机变量来检查属性值标准。然后，使用新更新的引用来选择它所引用的<code class="codeph">PERSON</code>对象，以便可以将信息输出给用户以验证更改。
                        </p><pre class="oac_no_warn" dir="ltr">...//将REF更新为对象static void updateRef（）{int empnum = 1001; String new_manager =“NEW PERSON”; System.out.println（“更新管理器REF。”）; try {#sql {UPDATE employees SET manager =（SELECT REF（p）FROM persons p WHERE p.name =：new_manager）WHERE empnumber =：empnum}; System.out.println（“员工1001的更新经理。选择返回“）;} catch（SQLException exn）{System.out.println（”UPDATE REF失败，带有“+ exn）;} / *选择管理器返回以验证更新* /人员管理器;尝试{#sql {SELECT deref （经理）INTO：经理来自员工e WHERE empnumber =：empnum}; System.out.println（“当前经理”+ empnum +“：”）; printPersonDetails（manager）;} catch（SQLException exn）{System.out。 println（“SELECT REF失败了”+ exn）;}} ...
</pre><div class="infoboxnote" id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51__GUID-5E9841E5-65A2-4F61-8D59-A299294C1B22">
                           <p class="notep1">注意：</p>
                           <p>此示例使用表别名语法（ <code class="codeph">p</code> ），如前所述。此外，在通过它引用的对象选择引用时需要<code class="codeph">REF</code>语法，并且在通过引用选择对象时需要<code class="codeph">DEREF</code>语法。有关表别名， <code class="codeph">REF</code>和<code class="codeph">DEREF</code>更多信息，请参阅<a href="../sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#SQLRF-GUID-08B73ED6-2ABA-4737-B8A1-F7BD0456AEDB" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ472"></a><div class="props_rev_3"><a id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" name="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD"></a><h3 id="JSQLJ-GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" class="sect3">SQLJ可执行语句中强类型的集合</h3>
               <div>
                  <p>与强类型对象和引用一样，Oracle SQLJ实现支持使用迭代器或宿主表达式通过强类型集合读取和写入数据的不同方案。</p>
                  <p>从SQLJ开发人员的角度来看，两个集合类别VARRAY和嵌套表的处理方式基本相同，但在实现和性能方面存在一些差异。</p>
                  <p>Oracle SQLJ实现支持语法选择，因此嵌套表可以与其外表一起访问或操作。在本节中，嵌套表的操作本身将被称为详细级操作，嵌套表及其外表的操作将被称为主级操作。</p>
                  <p>在对一些语法进行简要讨论之后，本节的大部分内容都集中在操作嵌套表的示例上，因为它们的使用比VARRAY的使用稍微复杂一些。</p>
                  <div class="infoboxnote" id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD__GUID-D0E7C0F8-8F58-41EF-B4AE-90B046B25F07">
                     <p class="notep1">注意：</p>
                     <p>在Oracle SQLJ实现中，只能完整地检索VARRAY类型和嵌套表类型。这与Oracle SQL实现相反，后者可以有选择地查询嵌套表。</p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF">访问嵌套表：TABLE语法和CURSOR语法</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-2CDD8601-C214-4895-96D3-35585F3D5796">插入包含嵌套表的行</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521">选择嵌套表到主机表达式</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8">使用TABLE语法操作嵌套表</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">使用嵌套迭代器从嵌套表中选择数据</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB">选择VARRAY到主机表达式</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36">插入包含VARRAY的行</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ473"></a><div class="props_rev_3"><a id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" name="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF"></a><h4 id="JSQLJ-GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" class="sect4">访问嵌套表：TABLE语法和CURSOR语法</h4>
                  <div>
                     <div class="section">
                        <p>Oracle SQLJ实现支持使用嵌套迭代器来访问嵌套表中的数据。使用外部<code class="codeph">SELECT</code>语句中的<code class="codeph">CURSOR</code>关键字来封装内部<code class="codeph">SELECT</code>语句。这在<span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">使用嵌套迭代器从嵌套表中选择数据</a> ”中显示</span> 。
                        </p>
                        <p>Oracle还支持使用<code class="codeph">TABLE</code>关键字来操作嵌套表的各个行。此关键字通知Oracle子查询返回的列值是嵌套表，而不是标量值。您必须将<code class="codeph">TABLE</code>关键字前缀添加到返回单个列值的子查询或产生嵌套表的表达式。
                        </p>
                        <p>以下示例显示了<code class="codeph">TABLE</code>语法的用法：</p><pre class="oac_no_warn" dir="ltr">UPDATE TABLE（SELECT a.modules FROM project a WHERE a.id = 555）b SET module_owner =（SELECT ref（p）FROM employees p WHERE p.ename ='Smith'）WHERE b.module_name ='Zebra';</pre><p>当您看到此处使用的<code class="codeph">TABLE</code>时，请意识到它指的是从外部表的列中选择的单个嵌套表。
                        </p>
                        <div class="infoboxnote" id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF__GUID-78769A8D-4B7E-4487-ABF6-B993D472C1C9">
                           <p class="notep1">注意：</p>
                           <p>此示例使用表别名语法（ <code class="codeph">a</code>表示<code class="codeph">projects</code> ， <code class="codeph">b</code>表示嵌套表， <code class="codeph">p</code>表示<code class="codeph">employees</code> ），如前所述。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ474"></a><div class="props_rev_3"><a id="GUID-2CDD8601-C214-4895-96D3-35585F3D5796" name="GUID-2CDD8601-C214-4895-96D3-35585F3D5796"></a><h4 id="JSQLJ-GUID-2CDD8601-C214-4895-96D3-35585F3D5796" class="sect4">插入包含嵌套表的行</h4>
                  <div>
                     <div class="section">
                        <p>此示例显示了同时且显式地操作主级别（外部表）和详细级别（嵌套表）的操作。这会在<code class="codeph">projects</code>表中插入一行，其中每行包含<code class="codeph">MODULETBL_T</code>类型的嵌套表，该表包含<code class="codeph">MODULE_T</code>对象的行。
                        </p>
                        <p>首先，设置标量值（ <code class="codeph">id</code> ， <code class="codeph">name</code> ， <code class="codeph">start_date</code> ， <code class="codeph">duration</code> ），然后设置嵌套表值。这涉及额外的抽象级别，因为嵌套的表元素是具有多个属性的对象。在设置嵌套表值时，必须为嵌套表中的每个<code class="codeph">MODULE_T</code>对象设置每个属性值。最后，最初设置为<code class="codeph">null</code>的<code class="codeph">owner</code>值在单独的语句中设置。
                        </p><pre class="oac_no_warn" dir="ltr">//插入嵌套表详细信息以及主要详细信息public static void insertProject2（int id）throws Exception {System.out.println（“使用嵌套表详细信息插入项目..”）;尝试{#sql {INSERT INTO Projects（id，name，owner，start_date，duration，modules）VALUES（600，'Ruby'，null，'10 -MAY-98'，300，moduletbl_t（module_t（6001，'Setup'） ，null，'01 -JAN-98'，100），module_t（6002，'BenchMark'，null，'05-FEB-98'，20），module_t（6003，'Purchase'，null，'15 -MAR- 98'，50），module_t（6004，'Install'，null，'15 -MAR-98'，44），module_t（6005，'Launch'，null，'12 -MAY-98'，34）））} ; } catch（Exception e）{System.out.println（“Error：insertProject2”）; e.printStackTrace（）; } //将项目所有者分配给此项目try {#sql {UPDATE Projects pr SET owner =（SELECT ref（pa）FROM participant pa paERE pa.empno = 7698）WHERE pr.id = 600}; } catch（Exception e）{System.out.println（“Error：insertProject2：update”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ475"></a><div class="props_rev_3"><a id="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" name="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521"></a><h4 id="JSQLJ-GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" class="sect4">选择嵌套表到主机表达式</h4>
                  <div>
                     <div class="section">
                        <p>此示例提供了一种直接在嵌套表的详细级别上运行的操作。</p><pre class="oac_no_warn" dir="ltr">static ModuletblT mymodules = null; ...public static void getModules2（int projId）throws Exception {System.out.println（“display modules for project”+ projId）; try {#sql {SELECT modules INTO：mymodules FROM projects WHERE id =：projId}; showArray（mymodules）; } catch（Exception e）{System.out.println（“Error：getModules2”）; e.printStackTrace（）; public static void showArray（ModuletblT a）{try {if（a == null）System.out.println（“the array is null”）; else {System.out.println（“打印大小的ModuleTable数组对象”+ a.length（））; ModuleT [] modules = a.getArray（）; for（int i = 0; i &lt;modules.length; i ++）{ModuleT module = modules [i]; System.out.println（“module”+ module.getModuleId（）+“，”+ module.getModuleName（）+“，”+ module.getModuleStartDate（）+“，”+ module.getModuleDuration（））; catch（Exception e）{System.out.println（“Show Array”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ476"></a><div class="props_rev_3"><a id="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" name="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8"></a><h4 id="JSQLJ-GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" class="sect4">使用TABLE语法操作嵌套表</h4>
                  <div>
                     <div class="section">
                        <p>此示例使用<code class="codeph">TABLE</code>语法在详细级别工作，以根据主级别条件直接访问和更新嵌套表元素。
                        </p>
                        <p><code class="codeph">assignModule()</code>方法从<code class="codeph">PROJECTS</code>表的<code class="codeph">MODULES</code>列中选择一个嵌套的<code class="codeph">MODULE_T</code>对象表，然后更新嵌套表的特定行的<code class="codeph">MODULE_NAME</code> 。类似地， <code class="codeph">deleteUnownedModules()</code>方法选择嵌套的<code class="codeph">MODULE_T</code>对象表，然后删除嵌套表中的任何无主模块，其中<code class="codeph">MODULE_OWNER</code>为<code class="codeph">null</code> 。
                        </p>
                        <p>如前所述，这些方法使用表别名语法。在这种情况下， <code class="codeph">m</code>用于嵌套表， <code class="codeph">p</code>用于<code class="codeph">participants</code>表。
                        </p><pre class="oac_no_warn" dir="ltr">/ * assignModule说明使用TABLE构造访问嵌套表并更新嵌套表行* / public static void assignModule（int projId，String moduleName，String modOwner）throws Exception {System.out.println（“Update：Assign'”+ moduleName +“'to'”+ modOwner +“'”）; try {#sql {UPDATE TABLE（SELECT modules FROM projects WHERE id =：projId）m SET m.module_owner =（SELECT ref（p）FROM participant p WHERE p.ename =：modOwner）WHERE m.module_name =：moduleName}; } catch（Exception e）{System.out.println（“Error：insertModules”）; e.printStackTrace（）; / * deleteUnownedModules //演示删除嵌套表元素* / public static void deleteUnownedModules（int projId）throws Exception {System.out.println（“删除项目的无主模块”+ projId）; try {#sql {DELETE TABLE（SELECT modules FROM projects WHERE id =：projId）m WHERE m.module_owner IS NULL}; } catch（Exception e）{System.out.println（“Error：deleteUnownedModules”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ477"></a><div class="props_rev_3"><a id="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" name="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E"></a><h4 id="JSQLJ-GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" class="sect4">使用嵌套迭代器从嵌套表中选择数据</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ支持使用嵌套迭代器作为访问嵌套表的方法。这需要<code class="codeph">CURSOR</code>语法，如以下示例所示。该代码定义了一个命名迭代器类<code class="codeph">ModuleIter</code> ，然后将该类用作另一个命名迭代器类<code class="codeph">ProjIter</code>的<code class="codeph">modules</code>列的类型。在填充的<code class="codeph">ProjIter</code>实例中，每个<code class="codeph">modules</code>项都是一个嵌套的表，呈现为嵌套的迭代器。
                        </p>
                        <p><code class="codeph">CURSOR</code>语法是填充嵌套迭代器的嵌套<code class="codeph">SELECT</code>语句的一部分。选择数据后，将通过迭代器访问器方法将其输出给用户。
                        </p>
                        <p>此示例使用必需的表别名语法，如前所述。在这种情况下， <code class="codeph">a</code>表示<code class="codeph">projects</code>表， <code class="codeph">b</code>表示嵌套表。
                        </p><pre class="oac_no_warn" dir="ltr">...//使用ModuleIter访问嵌套表//将ModuleIter定义为Named Iterator #sql public static iterator ModuleIter（int moduleId，String moduleName，String moduleOwner）; //使用定义为//命名迭代器的ProjIter获取项目详细信息。注意ModuleIter的使用：#sql public static iterator ProjIter（int id，String name，String owner，Date start_date，ModuleIter modules）; ...public static void listAllProjects（）抛出SQLException {System.out.println（“列出项目......”）; //实例化并初始化迭代器ProjIter projs = null; ModuleIter mods = null; #sql projs = {SELECT a.id，a.name，initcap（a.owner.ename）as“owner”，a.start_date，CURSOR（SELECT b.module_id AS“moduleId”，b.module_name AS“moduleName”， initcap（b.module_owner.ename）AS“moduleOwner”FROM TABLE（a.modules）b）AS“modules”FROM projects a}; //显示项目详细信息while（projs.next（））{System.out.println（“\ n'”+ projs.name（）+“'Project Id：”+ projs.id（）+“归”所有+“'”+ projs.owner（）+“'”+“start on”+ projs.start_date（））; //注意ProjIter中的模块被分配给模块//迭代器变量mods = projs.modules（）; System.out.println（“此项目中的模块是：”）; //显示模块详细信息while（mods.next（））{System.out.println（“”+ mods.moduleId（）+“'”+ mods.moduleName（）+“'owner is'”+ mods.moduleOwner（ ）+“'”）; } //模块结束mods.close（）; } //项目结束projs.close（）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ478"></a><div class="props_rev_3"><a id="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" name="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB"></a><h4 id="JSQLJ-GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" class="sect4">选择VARRAY到主机表达式</h4>
                  <div>
                     <div class="section">
                        <p>本节提供了将VARRAY选择到主机表达式的示例。假定以下SQL定义：</p><pre class="oac_no_warn" dir="ltr">创建类型PHONE_ARRAY是varray2（30）的VARRAY（10）/ / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），状态CHAR（2），zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ CREATE TABLE employees（empnumber INTEGER PRIMARY KEY， person_data REF人，经理REF人，office_addr地址，工资号码，phone_nums phone_array）/</pre><p>并假设您创建了一个<code class="codeph">PhoneArray</code>自定义集合类，以便从<code class="codeph">PHONE_ARRAY</code> SQL类型进行映射。
                        </p>
                        <p>以下方法从此表中选择一行，将数据放入<code class="codeph">PhoneArray</code>类型的主机变量中：</p><pre class="oac_no_warn" dir="ltr">private static void selectVarray（）抛出SQLException {PhoneArray ph; #sql {select phone_nums into：ph emp from employees empnumber = 2001}; System.out.println（PhoneArray中有“+ ph.length（）+”电话号码。它们是：“）; String [] pharr = ph.getArray（）; for（int i = 0; i &lt;pharr.length; ++ i）System.out.println（pharr [i]）;}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ479"></a><div class="props_rev_3"><a id="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" name="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36"></a><h4 id="JSQLJ-GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" class="sect4">插入包含VARRAY的行</h4>
                  <div>
                     <div class="section">
                        <p>本节提供了使用与上一节中相同的SQL定义和自定义集合类（ <code class="codeph">PhoneArray</code> ）将主机表达式中的数据插入VARRAY的示例。
                        </p>
                        <p>以下方法填充<code class="codeph">PhoneArray</code>实例并将其用作主机变量，将其数据插入数据库中的VARRAY：</p><pre class="oac_no_warn" dir="ltr">//创建一个PhoneArray的varray对象并将其插入一个新行private static void insertVarray（）抛出SQLException {PhoneArray phForInsert = consUpPhoneArray（）; //从先前的演示运行中清理#sql {从员工中删除empnumber = 2001}; //插入PhoneArray对象#sql {insert into employees（empnumber，phone_nums）values（2001，：phForInsert）}; private static PhoneArray consUpPhoneArray（）{String [] strarr = new String [3]; strarr [0] =“（510）555.1111”; strarr [1] =“（617）555.2222”; strarr [2] =“（650）555.3333”;返回新的PhoneArray（strarr）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ480"></a><div class="props_rev_3"><a id="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" name="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A"></a><h3 id="JSQLJ-GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" class="sect3">序列化的Java对象</h3>
               <div>
                  <p>在向数据库写入或从数据库中读取Java对象的实例时，有时候定义与Java类对应的SQL对象类型并使用映射前面描述的自定义Java类的机制是有利的。这完全允许对Java对象进行SQL查询。</p>
                  <p>但是，在某些情况下，您可能希望“按原样”存储Java对象，并使用<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>类型的数据库列稍后检索它们。有不同的方法来实现这一目标：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您可以使用类型映射工具的非标准扩展或通过向可序列化类添加类型代码字段将可序列化Java类映射到<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列，以便可序列化类的实例可以存储为<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                     </li>
                     <li>
                        <p>您可以使用<code class="codeph">ORAData</code>工具来定义可序列化的包装类，其实例可以存储在<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列中。
                        </p>
                     </li>
                  </ul>
                  <p>以任何这些方式进行序列化都适用于任何Oracle SQLJ运行时库。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C">将Java类序列化为RAW和BLOB列</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-57A81264-D048-417F-8097-FDB9842DFAF0">SerializableDatum：ORAData实现</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-13212854-72AA-451F-8F85-CD8602AAB6DB">SQLJ应用程序中的SerializableDatum</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4">SerializableDatum（完整类）</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ482"></a><a id="JSQLJ483"></a><a id="JSQLJ484"></a><a id="JSQLJ481"></a><div class="props_rev_3"><a id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" name="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C"></a><h4 id="JSQLJ-GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" class="sect4">将Java类序列化为RAW和BLOB列</h4>
                  <div>
                     <p>如果要直接在<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列中存储Java类的实例，则必须满足某些非标准要求才能指定所需的SQL-Java映射。请注意，在SQLJ语句中，可序列化的Java对象可以透明地读取和写入，就像它们是内置类型一样。
                     </p>
                     <p>在指定SQL-Java类型映射时有两个选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在连接上下文声明中声明类型映射，并使用此类型映射指定映射。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">public static final</code> field <code class="codeph">_SQL_TYPECODE</code>指定映射。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-13105C6E-E3BC-4DDA-B83F-924EF821467F">为可序列化类定义类型映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>考虑一个<code class="codeph">SAddress</code> ， <code class="codeph">pack.的例子<code class="codeph">pack.SPerson</code> ，并<code class="codeph">pack.经理。InnerSPM</code> ，其中<code class="codeph">InnerSPM</code>是<code class="codeph">Manager</code>的内部类，是可序列化的Java类。换句话说，这些类实现了<code class="codeph">java.io.Serializable</code>界面。
                        </p>
                        <p>必须仅在使用声明的连接上下文类型的显式连接上下文实例的语句中使用这些类，例如以下示例中的<code class="codeph">SerContext</code> ：</p><pre class="oac_no_warn" dir="ltr">SAddress a = ...;包。SPerson p = ......;包。经理。InnerSPM pm = ...; SerContext ctx = new SerContext（url，user，pwd，false）; #sql [ctx] {...：a ...：OUT p ......：下午......};</pre><p>以下是必需的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须使用<code class="codeph">with</code>子句的<code class="codeph">typeMap</code>属性声明连接上下文类型<code class="codeph">with</code>以指定实现<code class="codeph">java.util.的关联类<code class="codeph">java.util.PropertyResourceBundle</code> 。在示例中， <code class="codeph">SerContext</code>可以声明如下。
                              </p><pre class="oac_no_warn" dir="ltr">#sql public static context SerContext with（typeMap =“SerMap”）;</pre></li>
                           <li>
                              <p>类型映射资源必须提供从<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列到可序列化Java类的非标准映射。此映射使用以下格式的条目指定，具体取决于Java类是映射到<code class="codeph">RAW</code>列还是<code class="codeph">BLOB</code>列：</p><pre class="oac_no_warn" dir="ltr">甲骨文级。 <span class="variable" translate="no">java_class_name</span> = JAVA_OBJECT RAW oracle-class。 <span class="variable" translate="no">java_class_name</span> = JAVA_OBJECT BLOB</pre><p>关键字<code class="codeph">oracle-class</code>标记为特定于Oracle的扩展。在该示例中， <code class="codeph">SerMap.properties</code>资源文件可能包含以下条目：</p><pre class="oac_no_warn" dir="ltr">甲骨文级。SAddress = JAVA_OBJECT RAW oracle-class.pack。SPerson = JAVA_OBJECT BLOB oracle-class.packManager $ InnerSPM = JAVA_OBJECT RAW</pre><p>虽然句点（。）分隔包名和类名，但<span class="italic">必须</span>使用美元符号（$）来分隔内部类名。
                              </p>
                           </li>
                        </ul>
                        <p>请注意，此特定于Oracle的扩展可以放在与标准<code class="codeph">SQLData</code>类型映射条目相同的类型映射资源中。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-7F86B2A1-EBF8-4CC2-AB63-3D5F3845993F">使用字段确定可序列化类的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>作为对可序列化类使用类型映射的替代方法，可以使用可序列化类中的静态字段来确定类型映射。您可以将以下任一字段添加到实现<code class="codeph">java.io.的类中。Serializable</code>接口，例如前面示例中的<code class="codeph">SAddress</code>和<code class="codeph">SPerson</code>类：</p><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc。OracleTypes。生的;</pre><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc。OracleTypes。BLOB;</pre><div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-288B229B-EA5B-49BE-82EE-710F3E70AF45">
                           <p class="notep1">注意：</p>
                           <p>使用类型映射工具取代手动将<code class="codeph">_SQL_TYPECODE</code>字段添加到类中。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-CAD8FCC7-B322-484C-9DBA-6305A3982F2F">序列化Java对象的限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您应该了解序列化的影响。如果两个对象A和B共享同一个对象C，那么在序列化和随后的A和B反序列化时，每个对象都指向它自己的对象C的克隆。共享被破坏。</p>
                        <p>另外，请注意，对于给定的Java类，您只能声明一种序列化： <code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。 SQLJ转换器只能检查实际使用是否符合<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                        <p><code class="codeph">RAW</code>色谱柱的大小有限。如果序列化Java对象的实际大小超过列的大小，则可能会遇到运行时错误。
                        </p>
                        <p>列大小对<code class="codeph">BLOB</code>列的限制要少得多。Oracle JDBC Oracle调用接口（OCI）驱动程序和Oracle JDBC Thin驱动程序支持将序列化Java对象写入<code class="codeph">BLOB</code>列。自Oracle9 <span class="italic">i</span>以来，所有Oracle JDBC驱动程序都支持从<code class="codeph">BLOB</code>列检索序列化对象。
                        </p>
                        <p>最后，以这种方式处理序列化Java对象是Oracle特定的扩展，需要Oracle SQLJ运行时以及默认的Oracle特定代码生成（ <code class="codeph">-codegen=oracle</code>期间<code class="codeph">-codegen=oracle</code> ）或ISO标准代码生成（ <code class="codeph">-codegen=iso</code> ），Oracle特定的配置文件定制。
                        </p>
                        <p>10iProd：请注意，Oracle的未来版本可能支持直接封装Java序列化对象的SQL类型。这些在JDBC 2.0中被描述为JAVA_OBJECT SQL类型。此时，您可以使用相应的JAVA_OBJECT SQL类型的名称替换每个BLOB和RAW名称，并且可以在条目上删除oracle-前缀。</p>
                        <div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-427AA3C2-4FF2-4001-939B-DA07D0969E16">
                           <p class="notep1">注意：</p>
                           <p>此特定序列化机制的实现不使用JDBC类型映射。映射（到<code class="codeph">BLOB</code>或<code class="codeph">RAW</code> ）在转换时在Oracle配置文件自定义中进行硬编码，或直接生成到Java代码中。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ485"></a><div class="props_rev_3"><a id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0" name="GUID-57A81264-D048-417F-8097-FDB9842DFAF0"></a><h4 id="JSQLJ-GUID-57A81264-D048-417F-8097-FDB9842DFAF0" class="sect4">SerializableDatum：ORAData实现</h4>
                  <div>
                     <div class="section">
                        <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a> ”</span>包括您可能希望定义映射到<code class="codeph">oracle.sql.*</code>以外的某些<code class="codeph">oracle.sql.*</code>类型的自定义Java类的情况示例<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code> ，或<code class="codeph">oracle.sql.ARRAY</code> 。</p>
                        <p>这种情况的一个示例是，如果要将Java对象序列化和反序列化为<code class="codeph">RAW</code>字段，请使用映射到<code class="codeph">oracle.sql.的自定义Java类<code class="codeph">oracle.sql.RAW</code>类型。这可以同样适用于<code class="codeph">BLOB</code>字段，使用映射到<code class="codeph">oracle.sql.的自定义Java类<code class="codeph">oracle.sql.BLOB</code>类型。
                        </p>
                        <p>本节提供了这样一个应用程序的示例，创建了一个类<code class="codeph">SerializableDatum</code> ，它实现了<code class="codeph">ORAData</code>接口并遵循自定义Java类的一般形式。该示例首先介绍了<code class="codeph">SerializableDatum</code>开发的逐步方法，然后是完整的示例代码。
                        </p>
                        <div class="infoboxnote" id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0__GUID-5AC9D3E6-9A06-4C30-93D6-E3E04AEE81BE">
                           <p class="notep1">注意：</p>
                           <p>此应用程序使用<code class="codeph">java.io</code> ， <code class="codeph">java.sql</code> ， <code class="codeph">oracle.sql</code>和<code class="codeph">oracle.jdbc</code>包中的类。导入语句未在此处显示。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>从课程的骨架开始。</span><div><pre class="oac_no_warn" dir="ltr">public class SerializableDatum实现ORAData {// <span class="italic">用于构造和访问Java对象</span> public Datum toDatum的<span class="italic">客户端方法</span> （java.sql。连接c）抛出SQLException {// <span class="italic">执行toDatum（）</span> } public static ORADataFactory getORADataFactory（）{return FACTORY; private static final ORADataFactory FACTORY = // <span class="italic">SerializableDatum的ORADataFactory实现</span> // <span class="italic">从oracle.sql构造SerializableDatum。RAW</span> public static final int _SQL_TYPECODE = OracleTypes。生的; }</pre><p><code class="codeph">SerializableDatum</code>不实现<code class="codeph">ORADataFactory</code>接口，但其<code class="codeph">getORADataFactory()</code>方法返回实现此接口的静态成员。
                              </p>
                              <p><code class="codeph">_SQL_TYPECODE</code>设置为<code class="codeph">OracleTypes.RAW</code>因为这是从数据库读取和写入的数据类型。SQLJ转换器在执行在线类型检查时需要此类型代码信息，以验证用户定义的Java类型与SQL类型之间的兼容性。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>定义执行以下操作的客户端方法：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>创建<code class="codeph">SerializableDatum</code>对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>填充<code class="codeph">SerializableDatum</code>对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>从<code class="codeph">SerializableDatum</code>对象中检索数据。
                                    </p>
                                 </li>
                              </ul><pre class="oac_no_warn" dir="ltr">//构造和访问SerializableDatum私有对象的客户端方法m_data; public SerializableDatum（）{m_data = null; public void setData（Object data）{m_data = data; public Object getData（）{return m_data; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>实现一个<code class="codeph">toDatum()</code>方法，该方法将<code class="codeph">SerializableDatum</code>对象中的数据序列化为<code class="codeph">oracle.sql.RAW</code>对象。<code class="codeph">toDatum()</code>的实现必须将<code class="codeph">m_data</code>字段中对象的序列化表示形式返回为<code class="codeph">oracle.sql.RAW</code>实例。</span><div><pre class="oac_no_warn" dir="ltr">// toDatum（）的实现尝试{ByteArrayOutputStream os = new ByteArrayOutputStream（）; ObjectOutputStream oos = new ObjectOutputStream（os）; oos.writeObject（M_DATA）; oos.close（）;返回新的RAW（os.toByteArray（））; } catch（Exception e）{throw new SQLException（“SerializableDatum.toDatum：”+ e.toString（））; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>从<code class="codeph">oracle.sql.实现数据转换<code class="codeph">oracle.sql.RAW</code>对象为<code class="codeph">SerializableDatum</code>对象。此步骤反序列化数据。</span><div><pre class="oac_no_warn" dir="ltr">//从oracle.sql构造SerializableDatum。RAW private SerializableDatum（RAW raw）抛出SQLException {try {InputStream rawStream = new ByteArrayInputStream（raw.getBytes（））; ObjectInputStream是= new ObjectInputStream（rawStream）; m_data = is.readObject（）; is.close（）; } catch（Exception e）{throw new SQLException（“SerializableDatum.create：”+ e.toString（））; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>实现<code class="codeph">ORADataFactory</code> 。在这种情况下，它被实现为匿名类。</span><div><pre class="oac_no_warn" dir="ltr">//为SerializableDatum实现ORADataFactory new ORADataFactory（）{public ORAData create（Datum d，int sqlCode）抛出SQLException {if（sqlCode！= _SQL_TYPECODE）{throw new SQLException（“SerializableDatum：无效的SQL类型”+ sqlCode）; } return（d == null）？null：new SerializableDatum（（RAW）d）; }};</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSQLJ487"></a><a id="JSQLJ488"></a><a id="JSQLJ486"></a><div class="props_rev_3"><a id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" name="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB"></a><h4 id="JSQLJ-GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" class="sect4">SQLJ应用程序中的SerializableDatum</h4>
                  <div>
                     <p>给定在上一节中创建的<code class="codeph">SerializableDatum</code>类，本节将介绍如何在SQLJ应用程序中使用它的实例，包括宿主变量和迭代器列。
                     </p>
                     <p>假设下表定义：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE PERSONDATA（NAME VARCHAR2（20）NOT NULL，INFO RAW（2000））;</pre><div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-D7DFEB61-72D8-4391-BC8B-0D678CB18099">SerializableDatum作为主变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下使用<code class="codeph">SerializableDatum</code>实例作为主机变量：</p><pre class="oac_no_warn" dir="ltr">...SerializableDatum pinfo = new SerializableDatum（）; pinfo.setData（new Object [] {“Some objects”，new Integer（51），new Double（1234.27）}）; String pname =“MILLER”; #sql {INSERT INTO persondata VALUES（：pname，：pinfo）}; ...
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-7D5AB996-FA5A-460A-9DC8-90FDEB946214">Iterator列中的SerializableDatum</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是使用<code class="codeph">SerializableDatum</code>作为命名迭代器列的示例：</p><pre class="oac_no_warn" dir="ltr">#sql iterator PersonIter（SerializableDatum info，String name）; ...PersonIter pcur; #sql pcur = {SELECT * FROM persondata WHERE info IS NOT NULL}; while（pcur.next（））{System.out.println（“Name：”+ pcur.name（）+“Info：”+ pcur.info（））; } pcur.close（）; ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ489"></a><div class="props_rev_3"><a id="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" name="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4"></a><h4 id="JSQLJ-GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" class="sect4">SerializableDatum（完整类）</h4>
                  <div>
                     <p>以下是<code class="codeph">SerializableDatum</code>类的完整代码，它是在前面几节中逐步开发的。
                     </p><pre class="oac_no_warn" dir="ltr">import java.io.*; import java.sql。*; import oracle.sql。*; import oracle.jdbc。*; public class SerializableDatum实现ORAData {//用于构造和访问SerializableDatum私有对象m_data的客户端方法; public SerializableDatum（）{m_data = null; public void setData（Object data）{m_data = data; public Object getData（）{return m_data; } // toDatum（）的实现public Datum toDatum（Connection c）抛出SQLException {try {ByteArrayOutputStream os = new ByteArrayOutputStream（）; ObjectOutputStream oos = new ObjectOutputStream（os）; oos.writeObject（M_DATA）; oos.close（）;返回新的RAW（os.toByteArray（））; } catch（Exception e）{throw new SQLException（“SerializableDatum.toDatum：”+ e.toString（））; public static ORADataFactory getORADataFactory（）{return FACTORY; } //为SerializableDatum实现一个ORADataFactory私有静态最终ORADataFactory FACTORY = new ORADataFactory（）{public ORAData create（Datum d，int sqlCode）抛出SQLException {if（sqlCode！= _SQL_TYPECODE）{throw new SQLException（“SerializableDatum：无效的SQL类型”+ sqlCode）; } return（d == null）？null：new SerializableDatum（（RAW）d）; }}; //从oracle.sql构造SerializableDatum。RAW private SerializableDatum（RAW raw）抛出SQLException {try {InputStream rawStream = new ByteArrayInputStream（raw.getBytes（））; ObjectInputStream是= new ObjectInputStream（rawStream）; m_data = is.readObject（）; is.close（）; } catch（Exception e）{throw new SQLException（“SerializableDatum.create：”+ e.toString（））; public static final int _SQL_TYPECODE = OracleTypes。生的; }</pre></div>
               </div>
            </div><a id="JSQLJ490"></a><div class="props_rev_3"><a id="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" name="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55"></a><h3 id="JSQLJ-GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" class="sect3">弱类型对象，引用和集合</h3>
               <div>
                  <p>SQLJ支持弱类型的对象，引用和集合。通常不建议使用它们，并且存在一些特定的限制，但在某些情况下它们可能很有用。例如，您可能具有可以使用“任何<code class="codeph">STRUCT</code> ”或“任何<code class="codeph">REF</code> ”的通用代码。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006">支持弱类型Objects_ References_和Collections</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4EF76552-5997-4966-970E-1947416861D3">弱类型Objects_ References_和Collections的限制</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ491"></a><div class="props_rev_3"><a id="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" name="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006"></a><h4 id="JSQLJ-GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" class="sect4">支持弱类型对象，引用和集合</h4>
                  <div>
                     <div class="section">
                        <p>在SQLJ应用程序中使用Oracle对象，引用或集合时，您可以选择使用泛型和弱类型的<code class="codeph">java.sql</code>或<code class="codeph">oracle.sql</code>实例，而不是实现<code class="codeph">ORAData</code>接口的强类型自定义对象，引用和集合类。或者实现<code class="codeph">SQLData</code>接口的强类型自定义对象类。请注意，如果您对自定义对象类使用<code class="codeph">SQLData</code>实现，那么您将别无选择，只能使用弱类型的自定义引用实例。
                        </p>
                        <p>以下弱类型可用于Oracle SQLJ实现中的迭代器列或主机表达式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">java.sql中。Struct</code>或<code class="codeph">oracle.sql.对象的STRUCT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql中。Ref</code>或<code class="codeph">oracle.sql.REF</code>用于对象引用</p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql中。Array</code>或<code class="codeph">oracle.sql.ARRAY</code>收藏品</p>
                           </li>
                        </ul>
                        <p>在主机表达式中，它们受支持如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>作为输入主机表达式</p>
                           </li>
                           <li>
                              <p>作为<code class="codeph">INTO</code> -list中的输出主机表达式</p>
                           </li>
                        </ul>
                        <p>但是，通常不建议使用这些弱类型，因为您将失去SQLJ提供的强类型范例的所有优点。</p>
                        <p><code class="codeph">STRUCT</code>对象中的每个属性或<code class="codeph">ARRAY</code>对象中的每个元素都存储在<code class="codeph">oracle.sql.Datum</code>对象，其底层数据采用<code class="codeph">Datum</code>的相应<code class="codeph">oracle.sql.*</code>子类型的形式，例如<code class="codeph">oracle.sql.NUMBER</code>或<code class="codeph">oracle.sql.CHAR</code> 。 <code class="codeph">STRUCT</code>对象中的属性是无名的。由于<code class="codeph">STRUCT</code>和<code class="codeph">ARRAY</code>类的通用特性，SQLJ无法执行类型检查，其中对象或集合被写入或读取这些类的实例。
                        </p>
                        <p>通常建议您为对象，引用和集合使用自定义Java类。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ492"></a><div class="props_rev_3"><a id="GUID-4EF76552-5997-4966-970E-1947416861D3" name="GUID-4EF76552-5997-4966-970E-1947416861D3"></a><h4 id="JSQLJ-GUID-4EF76552-5997-4966-970E-1947416861D3" class="sect4">弱类型对象，引用和集合的限制</h4>
                  <div>
                     <div class="section">
                        <p>在以下情况下， <span class="italic">不能</span>在主机表达式中使用弱类型对象（ <code class="codeph">Struct</code>或<code class="codeph">STRUCT</code>实例），引用（ <code class="codeph">Ref</code>或<code class="codeph">REF</code>实例）或集合（ <code class="codeph">Array</code>或<code class="codeph">ARRAY</code>实例）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">IN</code>参数如果为null</p>
                           </li>
                           <li>
                              <p>存储过程或函数调用中的<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>参数</p>
                           </li>
                           <li>
                              <p>存储函数结果表达式中的<code class="codeph">OUT</code>参数</p>
                           </li>
                        </ul>
                        <p>它们不能以这些方式使用，因为无法知道底层SQL类型名称，例如<code class="codeph">Person</code> ，Oracle JDBC驱动程序需要它来实现Java中用户定义类型的实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ493"></a><div class="props_rev_3"><a id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" name="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4"></a><h3 id="JSQLJ-GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" class="sect3">Oracle OPAQUE类型</h3>
               <div>
                  <p>Oracle OPAQUE类型是抽象数据类型。由于数据仅作为一系列字节实现，因此不会公开内部表示。通常，Oracle将提供OPAQUE类型，而不是由客户实现。</p>
                  <p>OPAQUE类型在对象类型的一些基本方式上类似，具有静态方法，实例和实例方法的类似概念。通常，只有OPAQUE类型提供的方法允许您操作状态和内部字节表示。在Java中，OPAQUE类型可以表示为<code class="codeph">oracle.sql.OPAQUE</code>或作为实现<code class="codeph">oracle.sql.的自定义类<code class="codeph">oracle.sql.ORAData</code>接口。在客户端，假设字节模式已知，可以实现Java代码来操作字节。
                  </p>
                  <p>OPAQUE类型的一个关键示例是<code class="codeph">XMLType</code> ，随Oracle Database 12 <span class="italic">c</span>第2版（12.2）提供。此Oracle提供的类型有助于在数据库中本机处理XML数据。
                  </p>
                  <p><code class="codeph">SYS.XMLType</code>提供以下通过Java <code class="codeph">SYS.XMLType</code>的功能<code class="codeph">oracle.xdb.XMLType</code>类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它可以用作表或视图中列的数据类型。<code class="codeph">XMLType</code>可以存储任何内容，但旨在优化存储XML内容。它的一个实例可以表示SQL中的XML文档。</p>
                     </li>
                     <li>
                        <p>它有一个带有内置成员函数的SQL API，可以对XML内容进行操作。例如，您可以使用<code class="codeph">XMLType</code>函数来创建，查询，提取和索引存储在Oracle Database <span class="italic">12c</span>第1版（12.1）实例中的XML数据。
                        </p>
                     </li>
                     <li>
                        <p>它可以在存储过程中用于参数，返回值和变量。</p>
                     </li>
                     <li>
                        <p>它的功能也可通过PL / SQL，Java和C（OCI）中提供的API获得。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4__GUID-F648856C-579D-4A37-A61E-A85176A1790F">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adxdb/XML-DB-basics.html#ADXDB-GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" target="_blank"><span class="italic">Oracle XML DB开发人员指南</span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="03624.PRCS-01000.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>PRCS-01000至PRCS-01172</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Error Messages"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Error Messages"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-error-messages.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-16T07:32:34-07:00"></meta>
      <meta name="dcterms.title" content="Database Error Messages"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E95938-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="PRCR-01000.html" title="Previous" type="text/html"></link>
      <link rel="next" href="PRCT-01000.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ERRMG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="PRCR-01000.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="PRCT-01000.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库错误消息</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PRCS-01000至PRCS-01172</li>
            </ol>
            <a id="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686" name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686"></a>
            
            <h2 id="ERRMG-GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686" class="sect2"><span class="enumeration_chapter">115</span> PRCS-01000至PRCS-01172</h2>
         </header>
         <div class="ind">
            <div>
               <dl>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F0C1386F-C102-4D9C-8A92-F83D2A904729"><!-- --></a> PRCS-01000：无法启用{0}的启用状态</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检查服务器是否已启用失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-7E605B41-7D52-49B9-9E4E-CAB22D37D2B2"><!-- --></a> PRCS-01001：无法启用{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试启用指定的服务器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A47AED4D-3E03-4FB9-960B-1B2A3E27D4C3"><!-- --></a> PRCS-01002：无法禁用{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试禁用指定的服务器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-7C6C0FCF-3151-4CD7-8656-436AD5FD0C96"><!-- --></a> PRCS-01005：无法创建服务器{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建指定的服务器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B53F513D-097D-46D6-82DA-4A935973225A"><!-- --></a> PRCS-01006：无法获取节点{0}的服务器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试获取指定节点的服务器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-D97715DF-E8BC-49BB-8A81-16737E637F47"><!-- --></a> PRCS-01007：服务器池{0}已存在</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的服务器池已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-41CF3E1F-BD63-42DF-B923-1E74E22DEFA9"><!-- --></a> PRCS-01008：服务器池{0}不存在</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的服务器池不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用srvctl命令创建服务器池。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-EEE490EF-7BE0-4E8B-985D-A74A87CEA047"><!-- --></a> PRCS-01009：无法创建服务器池{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建指定的服务器池失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A44D0882-6953-45D4-B950-8DDEC08892C9"><!-- --></a> PRCS-01010：无法获得服务器池{1}的{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试获取指定服务器池的属性值失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-EC811F33-FFE3-48A7-B680-796A362BDA57"><!-- --></a> PRCS-01011：无法修改服务器池{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试修改指定的服务器池失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F459E423-DE92-474D-94B9-A0985ACD6DA8"><!-- --></a> PRCS-01012：无法删除服务器池{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法注销服务器池。此消息后面是失败的原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>解决失败消息中报告的问题后重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-2FE8F9E3-0810-43F4-AF15-6EB6F5132EC9"><!-- --></a> PRCS-01013：无法查找服务器池{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试获取指定的服务器池失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B43B06CB-931C-415F-BD68-14DECA107650"><!-- --></a> PRCS-01014：服务器{0}已经是服务器池{1}的一部分</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将服务器添加为指定服务器池的候选服务器失败，因为服务器已在池的SERVER_NAME属性中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>不需要采取任何行动。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4418D88B-91B9-4DAC-A68B-60F850C33198"><!-- --></a> PRCS-01015：服务器{0}不是服务器池{1}的一部分</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从服务器池的SERVER_NAMES属性中删除服务器失败，因为指定的服务器不在池的SERVER_NAME属性中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>将服务器添加到服务器池。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A8DCF726-7F2B-4B9F-8483-9BB2FD121903"><!-- --></a> PRCS-01016：无法解析单客户端访问名{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将指定的单客户端访问名称解析为IP地址列表失败，因为无法使用nslookup或其他查找方法在DNS中解析单客户端访问名称。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查指定的单客户端访问名称是否正确。查看提供无法解析的资源详细信息的基础错误消息。检查个别错误的原因和操作。如果应在DNS中解析单客户端访问名称，请检查DNS中单客户端访问名称的配置。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3C225B12-CE0C-4FAA-80C9-6237BBF45ED5"><!-- --></a> PRCS-01017：无法配置单客户端访问名{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试为单客户端访问名称添加群集配置失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，这些消息提供无法创建的资源的详细信息。检查单个资源创建失败的原因和操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-AE865F6F-A6C6-4BA9-9E5C-73874B9BBB67"><!-- --></a> PRCS-01018：无法为单客户端访问名称侦听器{0}添加群集配置</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试配置单客户端访问名称侦听器失败，因为未正确指定端点或其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，这些消息提供无法创建的资源的详细信息。检查单个资源创建失败的原因和操作。如果未正确指定端点，请更正端点。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-DCF6ED49-5A3B-4099-BCCF-DDCAB313CA39"><!-- --></a> PRCS-01019：无法删除单客户端访问名称侦听器{0}的配置</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试删除单个客户端访问名称侦听器的配置失败，因为其他资源依赖于它或其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，这些消息提供无法删除的资源的详细信息。在删除之前停止单个客户端访问名称侦听器资源。如果没有其他资源依赖它，可以考虑使用force flag来删除Single Client Access Name侦听器资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-07832A5F-9AAE-493C-BCE8-01C467D86FC6"><!-- --></a> PRCS-01020：无法启用单客户端访问名称资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试启用单客户端访问名称资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，这些消息提供无法启用哪些资源的详细信息。检查单个资源创建失败的原因和操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-47D7C2D7-75FE-455B-BFDF-D51A50DAB4BA"><!-- --></a> PRCS-01021：无法禁用单客户端访问名称资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试禁用单客户端访问名称资源失败，因为当前用户没有足够的权限来执行此操作或其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，这些消息提供无法禁用哪些资源的详细信息。检查单个资源故障的原因和操作。确保用户在Linux上具有Linux / Unix和Administrator的root权限。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-7186534E-2290-49DE-A24E-13A06677269C"><!-- --></a> PRCS-01022：无法启动单客户端访问名称资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试启动单客户端访问名称资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，该消息提供无法启动的资源的详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-056D2A5E-AF2C-41C8-ADE9-F22D7463F2C9"><!-- --></a> PRCS-01023：无法停止单客户端访问名称资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试停止单客户端访问名称资源失败，因为没有停止/重定位单客户端访问名称侦听器或其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，该消息提供无法停止的资源的详细信息。检查单个资源创建失败的原因和操作。首先停止单客户端访问名称侦听器，或者如果没有其他资源依赖它们，则使用强制标志来停止单个客户端访问名称虚拟Internet协议（VIP）资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F77AD2A9-C929-4463-8FAC-2AB0504FD423"><!-- --></a> PRCS-01024：无法删除单个客户端访问名称虚拟Internet协议（VIP）资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法删除单个客户端访问名称虚拟Internet协议（VIP）资源，因为资源正在运行或单个客户端访问名称侦听器取决于其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，该消息提供无法删除的资源的详细信息。停止单客户端访问名称VIP和单客户端访问名称侦听器，然后删除单客户端访问名称侦听器。或者，如果没有其他资源依赖于它们，请使用强制标志来删除单个客户端访问名称虚拟Internet协议（VIP）资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-8C11CB53-DBA9-453A-80B9-18B6B4969148"><!-- --></a> PRCS-01025：使用过滤器{0}找不到任何单客户端访问名称（SCAN）虚拟Internet协议（VIP）资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索SCAN VIP资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保提供的资源名称正确无误。检查附带的错误消息以获取其他详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C51CB41E-970F-414A-A6E3-00D10734B947"><!-- --></a> PRCS-01026：使用过滤器{0}找不到任何单客户端访问名称（SCAN）侦听器资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索SCAN侦听器资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保提供的资源名称正确无误。检查附带的错误消息以获取其他详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-D9268AE9-1C71-4DDC-BC8E-B67FFD40C277"><!-- --></a> PRCS-01027：找不到序号为{0}的任何单客户端访问名称侦听器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>找不到指定序号的单客户端访问名称侦听器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl config scan_listener'检查可用的序号。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A0C7AAFE-1051-4DC7-A33C-0D89322A756D"><!-- --></a> PRCS-01028：网络{0}上已存在单客户端访问名称（SCAN）侦听器资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>已在指定网络上创建单客户端访问名称侦听器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果需要，使用命令'srvctl modify scan_listener'修改属性。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C2AD7965-B1D2-4AD1-987D-61133BBE5493"><!-- --></a> PRCS-01031：无法使用端点{0}修改单个客户端访问名称侦听器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试修改单客户端访问名称侦听器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查指定的端点是否有效。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6C6D487B-829F-498F-BF84-E19A07EB0E37"><!-- --></a> PRCS-01032：找不到与查询{0}匹配的服务器池</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试查找与给定查询匹配的服务器池未找到匹配的服务器池。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>通过命令'srvctl add srvpool'配置服务器池，或通过命令'srvctl modify srvpool'修改现有服务器池以匹配查询并重试请求。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-96A1AE1C-B980-4CB4-99A7-1AB9EE9969D3"><!-- --></a> PRCS-01034：无法修改单个客户端访问名{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法修改单客户端访问名的配置，因为未正确指定端点或无法删除额外的单客户端访问名称VIP或其他原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看基础错误消息，该消息提供无法修改的资源的详细信息。解决报告的问题并重试。如果要修改端点，请指定正确的端点。如果要更新单客户端访问名称VIP的数量，请停止依赖的单客户端访问名称侦听器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B548011A-8D66-471B-A6CF-86DF044DEBBE"><!-- --></a> PRCS-01035：SCAN侦听器的TCP端口数（{0}）无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>未指定端口，或指定了多个端口。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>仅为SCAN侦听器的TCP协议指定一个端口号。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-593CE132-7275-4377-932B-6EA12EE1AC5E"><!-- --></a> PRCS-01037：网络{0}上已存在单客户端访问名称（SCAN）虚拟Internet协议（VIP）资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在已配置SCAN VIP时添加SCAN VIP。每个群集网络只能配置一个SCAN。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>删除给定网络上的现有SCAN并添加新的SCAN。或者，修改SCAN以使用新的SCAN名称或将现有的SCAN名称映射到不同的SCAN VIP。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-45410219-576A-4D14-BBB1-5ED97122C674"><!-- --></a> PRCS-01038：无法找到与侦听器{0}关联的单客户端访问名称虚拟Internet协议（VIP）</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>找不到与给定侦听器关联的单客户端访问名称虚拟Internet协议（VIP）。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以确定如何响应。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-FD0CA21C-5A7B-4EDB-80CB-3FE70C99A85E"><!-- --></a> PRCS-01039：无法找到与给定虚拟Internet协议（VIP）{0}关联的单客户端访问名称侦听器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>找不到与给定虚拟Internet协议（VIP）关联的单客户端访问名称侦听器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以确定如何响应。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-849BB2A5-4608-4BA5-A2F4-8805974BEFDC"><!-- --></a> PRCS-01040：用户{0}没有CRS管理员角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的用户没有CRS管理员角色。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'crsctl add crs administrator -u &lt;user_name&gt;'将CRS管理员角色授予用户，然后重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B3D82D39-3BBB-4209-9EB6-7BD302047614"><!-- --></a> PRCS-01041：内置服务器池名称{0}无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的内置服务器池名称无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供有效的内置服务器池名称。它可以是Generic或Free。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B555E75B-EDE0-49D0-9682-8A4373AD65D9"><!-- --></a> PRCS-01042：服务器池{0}当前未托管任何数据库</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>找不到引用给定服务器池的数据库。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add database ... -serverpool &lt;server_pool&gt;'创建数据库配置并重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-78215FAC-75D9-4F7B-9168-6DF991A7C4CB"><!-- --></a> PRCS-01043：服务器池{0}当前未托管任何数据库服务</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>找不到引用给定服务器池的服务。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add service ... -serverpool &lt;server_pool&gt;'创建服务配置并重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-121CEC72-AE49-48B6-8263-94E79EAF4380"><!-- --></a> PRCS-01046：名称{0}无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的名称无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定有效的字符串名称，然后重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B075CAE5-AD2E-4F94-90C5-FDE5BBC419CB"><!-- --></a> PRCS-01047：最小大小{0}无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的最小尺寸无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：将</span>最小大小指定为等于或大于零且小于最大大小（不是-1）的整数，然后重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-EE0A6204-D341-4E73-B741-75CD18FDF129"><!-- --></a> PRCS-01048：{0}的最大大小无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的最大大小无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：将</span>最大大小指定为大于或等于-1的整数并重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6876EA42-A565-47AE-8980-6AF31BC46C5C"><!-- --></a> PRCS-01049：{0}的重要性无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的重要性无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：将</span>重要性值指定为大于或等于0的整数并重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4B703C53-94F6-40BB-B67C-4FC38C4FA004"><!-- --></a> PRCS-01050：无法添加GNS VIP {0}，因为名称为{1}的另一个已存在</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>要添加的GNS VIP的名称与已存在的名称相匹配。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定其他名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-9C56BDF3-5D47-458F-A0F4-B8EAC98151CC"><!-- --></a> PRCS-01051：无法使用网络{0}添加GNS VIP，因为已使用网络{1}注册了另一个</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>为要添加的GNS VIP指定的网络与已存在的网络匹配。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定另一个网络。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-609025E4-1805-4B1F-A372-F590D4158D51"><!-- --></a> PRCS-01053：无法解析网格命名服务VIP {0}的地址：\ n {1}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法解析为GNS VIP指定的地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定有效地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E27B6800-921F-45A3-8788-BB3F1ECBCDC7"><!-- --></a> PRCS-01054：无法为网格命名服务VIP {0}配置VIP</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> GNS VIP的创建失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-7B5E0316-E8D8-4642-8C41-8105C8226E97"><!-- --></a> PRCS-01055：无法修改网格命名服务VIP {0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> GNS VIP的修改失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C258ABB6-7AAF-4E5E-B768-FB784DA88C40"><!-- --></a> PRCS-01056：无法找到网格命名服务虚拟Internet协议（VIP）{0}的资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的GNS VIP不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定有效的GNS VIP名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6BB43CC0-4853-489A-B48A-C872C6F117D3"><!-- --></a> PRCS-01057：内部错误：未指定任何属性。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>没有将要修改GNS的属性传递给方法。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>这是一个内部错误。请联系Oracle客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-958E98C9-FEA9-45D2-ADBB-FF7B31650F36"><!-- --></a> PRCS-01058：内部错误：不支持的查询类型：“$ {0}”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法识别要对GNS进行的查询类型。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>这是一个内部错误，不应该是可见的。请联系Oracle客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B4DF41F1-994D-4E40-A0F5-0B085E7A3BA1"><!-- --></a> PRCS-01059：无法获得服务器池{0}的子服务器池</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法查找包含给定服务器池名称的服务器池的PARENT_POOLS属性。确保当前用户对给定服务器池及其子服务器池具有读取权限。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>授予给定服务器池及其子服务器池的读取权限。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E5ECF05A-DF8E-4160-AE02-46456C2C4797"><!-- --></a> PRCS-01060：无法将服务器{0}重定位到服务器池{1}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法将服务器重定位到给定的服务器池中。此消息可能伴随其他人提供其他详细信息。可能的原因是违反了已定义的配置属性，例如池MIN_SIZE，SERVER_NAMES等。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果问题源于违反配置属性，请修改属性或重新构造请求。否则，请与Oracle支持服务联系。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-ED4913E9-2E8D-4FD0-9E77-31FE7D687386"><!-- --></a> PRCS-01061：无法找到由服务器池{0}托管的正在运行的数据库实例</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法找到给定服务器池中的服务器托管的正在运行的数据库实例。此消息附有其他提供其他详细信息的消息。可能的原因是当前用户可能没有权限查询由给定服务器池托管的数据库的配置文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果缺少权限是导致此故障的原因，则使用命令'srvctl config <span class="variable" translate="no">object</span> -a'查找实体的当前所有者，并以该所有者用户身份重试查询。否则，请与Oracle支持服务联系。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-EDF7EDFF-D72A-4880-B682-FC9959A3446D"><!-- --></a> PRCS-01062：无法确定服务器池{0}是否有父母或子女</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法找到给定服务器池的父项或子项。可能的原因是当前用户可能没有权限查询给定服务器池的配置文件或其PARENT_POOLS属性包含此服务器池名称的其他服务器池的配置文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果缺少权限是导致此故障的原因，则使用命令'srvctl config serverpool <span class="variable" translate="no">serverpool</span> -a'查找服务器池的当前所有者，并以该所有者用户身份重试查询。否则，请与Oracle支持服务联系。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-97C07CEF-C609-4B84-B8B3-973B16744418"><!-- --></a> PRCS-01063：无法创建最小大小为{1}，最大大小为{2}，重要性为{3}且服务器列表（{4}）的服务器池{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>由于附带的异常消息提供的原因，无法创建指定的服务器池。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>根据随附的异常消息进行响应。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-917CC20A-A15A-4ED7-AF95-A6853EB615B2"><!-- --></a> PRCS-01064：无法使用过滤器{0}查找服务器池</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用给定的筛选器失败来查找服务器池权限。可能的原因是当前用户没有查询服务器池实体的权限</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果缺少权限是导致此故障的原因，则使用命令'srvctl config serverpool -a'查找服务器池的当前所有者，并以该所有者用户身份重试查询。否则，请与Oracle支持服务联系。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-0C08EA7C-846E-489A-8B74-C351C22800CE"><!-- --></a> PRCS-01065：此群集中未配置GNS服务器。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>拒绝仅适用于GNS服务器群集的命令，因为此群集尚未配置为GNS服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果要在此群集中运行GNS服务器，请使用'srvctl add gns'命令对其进行配置。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4340099A-F134-46F5-A61D-7DA340104509"><!-- --></a> PRCS-01066：无法创建具有服务器列表（{1}）的服务器组{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>由于附带的异常消息提供的原因，无法创建指定的服务器组。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>根据随附的异常消息进行响应。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-690D1D8F-06D7-414B-938A-EB6A56DE4492"><!-- --></a> PRCS-01067：无法找到服务器池{0}托管的在线数据库实例</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>无法找到给定服务器池中的服务器托管的联机数据库实例。此消息附有其他提供其他详细信息的消息。可能的原因是当前用户可能没有权限查询由给定服务器池托管的数据库的配置文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>如果缺少权限是导致此故障的原因，则使用命令'srvctl config <span class="variable" translate="no">object</span> -a'查找实体的当前所有者，并以该所有者用户身份重试查询。否则，请与Oracle支持服务联系。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-036C12A6-46E1-490E-BD48-E07E6AB13D65"><!-- --></a> PRCS-01068：节点{0}的Oracle Clusterware服务器实体不存在</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定节点的服务器实体不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>在给定节点上启动Oracle Clusterware并重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-259E9483-936B-472B-8BDC-5ED2EAA74202"><!-- --></a> PRCS-01069：GNS域名{1}中的标签{0}未遵循RFC-1035惯例</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> GNS域名的指定部分不遵循RFC-1035标签约定。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定遵循RFC-1035约定的域名。根据RFC-1035约定，域名由一组以“。”分隔的标签组成。标签必须以字母字符开头，并且只能包含字母数字和“ - ”（短划线或减号），以字母数字结尾，且长度不超过63个字符。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-D29B668C-EF48-48EA-AEFC-321A40EFECF9"><!-- --></a> PRCS-01070：GNS域名{1}的标签{0}部分太长</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> GNS域名的指定部分不遵循RFC-1035标签约定，因为它超过63个字符。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定遵循RFC-1035约定的域名。域名由一组以“。”分隔的标签组成。标签必须以字母字符开头，并且只能包含字母数字字符和“ - ”（短划线或减号字符），以字母数字结尾且长度不超过63个字符。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-D004A72B-306B-4CF0-A822-7C269AEB4194"><!-- --></a> PRCS-01071：尝试查找“{0}”的IP地址时发生错误。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>请求的操作失败，因为它在尝试解析GNS服务器的指示的完全限定域名（FQDN）时发生错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保本地节点已正确配置名称服务器。如果FQDN中的域是GNS域名，请确保已设置DNS以将请求转发到GNS并且GNS资源处于联机状态。确保本地节点和名称服务器之间没有防火墙。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F86D4383-055A-4317-AAE9-42C9BA30168D"><!-- --></a> PRCS-01072：无法创建保留名称为{0}的服务器池</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>拒绝创建指定服务器池的请求，因为指定的服务器池名称是Oracle Clusterware的内置服务器池的名称。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供除Oracle Clusterware的内置服务器池名称（通用或免费）以外的服务器池名称，然后重试。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4E319F02-7A67-47A7-8B49-335414A067B8"><!-- --></a> PRCS-01073：指定的GNS日志记录级别{0}超出了预期的{1}到{2}范围</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> 'srvctl start gns -loglevel &lt;log_level&gt;'命令中的'log_level'值小于最小限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保'log_level'值在有效范围内。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A8414822-9183-49EE-ACB4-E7B32A210BF4"><!-- --></a> PRCS-01074：指定的GNS日志记录级别{0}超出预期范围{1}到{2}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> 'srvctl start gns -loglevel &lt;log_level&gt;'命令中的'log_level'值大于最大限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保'log_level'值在有效范围内。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F1555A3A-AFB6-4184-949F-371D39DD8A9B"><!-- --></a> PRCS-01075：GNS域名{0}以无效字符{1}结尾</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的GNS域名以无效字符结尾，不遵循RFC-1035标签约定。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定遵循RFC-1035约定的域名。根据RFC-1035约定，域名由一组以“。”分隔的标签组成。标签必须以字母字符开头，并且只能包含字母数字字符或“ - ”（短划线或减号字符），以字母数字结尾，且长度不超过63个字符。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-990E0607-6281-41AC-89CD-D9B2F9F7048D"><!-- --></a> PRCS-01076：无效的单客户端访问名{0}。SCAN VIP {2}的子网{1}与网络{4}的子网{3}不同</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>从指定的单客户端访问名称解析的SCAN VIP位于与网络子网不同的子网中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用可以解析为网络资源的同一子网中的SCAN VIP的SCAN名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-9CC50FF2-CDE2-46D6-85CD-EEB88628BA4B"><!-- --></a> PRCS-01077：指定的跟踪级别{0}超出了预期的{1}到{2}范围</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>跟踪级别值小于最小限制或大于最大限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保跟踪级别值在有效范围内。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-327DDFFD-B451-478C-94A6-0E70B91CC06E"><!-- --></a> PRCS-01078：无法使用扫描侦听器{1}更新受邀节点{0}以进行服务注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试更新受邀节点属性失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保CRS堆栈正在运行，已配置SCAN侦听器资源，并且用户具有SCAN侦听器资源的更新权限后，请重试该请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E46E7CA2-2817-49E1-8D71-964E3D58276B"><!-- --></a> PRCS-01079：无法使用扫描侦听器{0}检索受邀节点以进行服务注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索扫描侦听器的受邀节点属性值失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保CRS堆栈正在运行，已配置SCAN侦听器资源，并且用户具有SCAN侦听器资源的更新权限后，请重试该请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-68F96BB5-8365-471D-AE9A-3E6F21EA48FB"><!-- --></a> PRCS-01080：无法使用扫描侦听器{1}更新受邀子网{0}以进行服务注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试更新扫描侦听器的受邀子网属性失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保CRS堆栈正在运行，已配置SCAN侦听器资源，并且用户具有SCAN侦听器资源的更新权限后，请重试该请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C3A2FABD-7014-48AC-90AF-2D4178C82947"><!-- --></a> PRCS-01081：无法使用扫描侦听器{0}检索受邀的子网以进行服务注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索扫描侦听器的受邀子网属性失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保CRS堆栈正在运行，已配置SCAN侦听器资源，并且用户具有SCAN侦听器资源的更新权限后，请重试该请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-0866ECD7-EC86-48D1-AD47-4752E9CCFD7C"><!-- --></a> PRCS-01082：无效的内置服务器类别名称{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的类别名称无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供有效的类别名称。它可以是ora.hub.category或ora.leaf.category。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4D037DBA-6954-4747-BEB0-6597413811FD"><!-- --></a> PRCS-01083：CRS中没有注册服务器类别{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器类别不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'crsctl add category &lt;category_name&gt;'添加服务器类别，或使用命令'crsctl status category'获取已在CRS中注册的服务器类别列表。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E65C8890-D0EE-4DA1-81C5-F3FCBFF6E213"><!-- --></a> PRCS-01084：无法使用过滤器{0}查找服务器类别</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用给定的筛选器查找服务器类别权限失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>有关详细信息，请参阅随附的错误消息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-27C4E702-20C7-4A29-8AA3-D325ABD3A585"><!-- --></a> PRCS-01085：服务器类别{0}已存在</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定了已存在的服务器类别。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-05208D12-7E31-44E6-9F7E-B6103E54BE46"><!-- --></a> PRCS-01086：无法创建类别{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建指定的服务器类别失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F6CA8C7B-897C-4532-9E35-0F7DCDE6FA78"><!-- --></a> PRCS-01087：SCAN名称“{0}”未解析为IPv4或IPv6地址</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> SCAN名称未解析为IP地址（IPv4或IPv6）。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保SCAN名称解析为IP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-783BB51A-3A9A-4215-BB61-B748BA14F062"><!-- --></a> PRCS-01088：SCAN名称“{0}”解析为不同数量的IPv4（{1}）和IPv6（{2}）地址</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> SCAN名称解析为的IPv4和IPv6地址数不相等。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保SCAN名称解析为相同数量的IPv4和IPv6地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-2AF05DBB-CB61-421F-B621-E9E4D477A2BD"><!-- --></a> PRCS-01089：必须提供域，因为网络“{0}”的类型为“{1}”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在非静态网络上添加GNS被拒绝，因为未提供域。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保从DNS转发域，并使用命令'srvctl add gns -vip <span class="variable" translate="no">address</span> -domain <span class="variable" translate="no">domain</span> '提供<span class="variable" translate="no">domain</span> 。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-BA0D9F90-DDB2-4E1F-9CAD-C67272E39D6B"><!-- --></a> PRCS-01090：无法检索为GNS配置的子域</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索指定网格命名服务（GNS）的子域属性失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保CRS堆栈正在运行，已配置GNS资源，并且用户对GNS资源具有读取权限后，请重试该请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-CFB5BF36-0C63-43A9-A51A-BBC616CE0D15"><!-- --></a> PRCS-01091：扫描名称“{0}”解析为{1}地址，例如“{2}”，而网络{3}只有{4}子网</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>给定的扫描名称解析为网络没有的地址类型。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>通过命令'srvctl modify network -subnet'修改网络以包含缺少的类型，或确保扫描名称仅解析为与网络相同类型的地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-26C3F14E-68FE-4FA8-840D-EAC080B0B8D0"><!-- --></a> PRCS-01092：无法获取服务器类别{1}的属性{0}的值</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试获取指定服务器类别的属性值失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息以获取详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-58E595B1-0C6A-48AC-A9DF-C77326285CE8"><!-- --></a> PRCS-01093：服务器池{0}未定义服务器类别</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池没有为Oracle Flex Cluster中的策略管理数据库定义的服务器类别。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl modify srvpool -serverpool <span class="variable" translate="no">serverpool</span> -category <span class="variable" translate="no">category</span> -servers“”'修改服务器池。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-DB49C5F8-BB1E-4945-B799-F193D1EA4914"><!-- --></a> PRCS-01094：服务器池{1}的服务器类别{0}具有以下非集线器活动CSS角色：{2}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池的服务器类别没有PTC集群中策略管理数据库所需的ACTIVE_CSS_ROLE = HUB。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改服务器池以使用具有集线器活动CSS角色的服务器类别，或修改服务器类别以使用ACTIVE_CSS_ROLE = HUB。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-119629A3-BC27-4CBA-893B-FC12D2F83F01"><!-- --></a> PRCS-01095：服务器池{0}的'服务器'和'类别'参数的冲突规范</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在命令中指定了“服务器”和“类别”参数。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用“服务器”或“类别”参数重试请求。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-06A320C2-7DD4-41B9-A365-DD1E5930E3E0"><!-- --></a> PRCS-01096：服务器池{0}已包含服务器名称</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>命令'srvctl modify srvpool'指定'category'选项，但服务器池已具有服务器名称属性。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>通过发出命令'srvctl modify srvpool -serverpool &lt;pool_name&gt; -servers“”'删除服务器名称属性</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6693CAB3-F4E9-4401-A6CC-3B57A988BD4F"><!-- --></a> PRCS-01097：服务器池{0}已包含服务器类别</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> 'srvctl modify srvpool'命令指定了'servers'，但服务器池已经具有服务器类别属性。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>通过发出命令'srvctl modify srvpool -serverpool &lt;pool_name&gt; -category“”'删除服务器类别属性</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-17D9DBCB-B7AC-4AB3-BF22-E2B67ACB9DEE"><!-- --></a> PRCS-01098：未设置PQ服务器池{1}的服务器类别{0}的活动CSS角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池的服务器类别未指定ACTIVE_CSS_ROLE。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改PQ服务器池以使用具有有效活动CSS角色的服务器类别，或修改服务器类别以设置ACTIVE_CSS_ROLE。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-BD50087F-D6C1-4FC5-B592-48B6011BBC03"><!-- --></a> PRCS-01099：服务器池{1}的节点{0}没有HUB活动CSS角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池没有具有ACTIVE_CSS_ROLE = HUB的节点，这是Flex群集中策略管理数据库所需的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改服务器池以使用具有HUB活动CSS角色的节点。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-190E5E82-077B-4D6F-9E88-F6CB3F08AD21"><!-- --></a> PRCS-01100：PQ服务器池{1}的节点{0}没有LEAF活动CSS角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池没有具有ACTIVE_CSS_ROLE = LEAF的节点，这是Flex Cluster中策略管理数据库所需的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改服务器池以使用具有LEAF活动CSS角色的节点。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-918B313A-DE11-4DCE-86B6-C004B2F317F5"><!-- --></a> PRCS-01101：无法创建GNS资源，因为它已经存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加GNS资源但资源已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>删除GNS资源，然后添加它，或者避免添加已存在的资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E2E7001B-4F6C-4F72-83B6-B3D4DE14B12D"><!-- --></a> PRCS-01102：使用网络{1}上的过滤器{0}找不到任何单客户端访问名称（SCAN）虚拟Internet协议（VIP）资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在指示的网络上检索SCAN VIP资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保提供的资源名称正确无误。检查附带的错误消息以获取其他详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3F164242-2303-4E8E-8663-01372556F226"><!-- --></a> PRCS-01103：使用网络{1}上的过滤器{0}找不到任何单客户端访问名称（SCAN）侦听器资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在指示的网络上检索SCAN侦听器资源失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保提供的资源名称正确无误。检查附带的错误消息以获取其他详细信息。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A85EE771-0ED9-4BB7-9843-14B5AE34EB76"><!-- --></a> PRCS-01104：在网络{1}上找不到序号为{0}的单客户端访问名称（SCAN）侦听器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试查找指定序号和网络的SCAN侦听器失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl config scan_listener -netnum'检查给定网络上的可用序号。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-5DC07319-DEF6-4FF3-9D44-48DD13FFF0D5"><!-- --></a> PRCS-01105：并行查询服务器池{1}的服务器类别{0}具有以下非叶活动CSS角色：{2}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池的服务器类别没有根据Flex群集中策略管理数据库的并行查询帮助程序服务所需的ACTIVE_CSS_ROLE = LEAF。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改并行查询服务器池以使用具有叶活动CSS角色的服务器类别，或修改服务器类别以使用ACTIVE_CSS_ROLE = LEAF。</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-130D4C72-52C7-4341-9B80-5637D0920BC5"><!-- --></a> PRCS-01106：并行查询服务器池{1}的节点{0}没有叶活动CSS角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器池没有具有ACTIVE_CSS_ROLE = LEAF的节点，这是Flex Cluster中策略管理数据库所需的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改服务器池以使用具有叶活动CSS角色的节点。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-8855D27C-3504-4101-8550-2F8A888EC4EE"><!-- --></a> PRCS-01107：无法在网络{0}上添加资源，该资源配置为leaf。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用配置为“leaf”的网络添加资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>在未配置为“leaf”的网络上添加资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-10975027-EE50-45CF-9694-B30ADE888E93"><!-- --></a> PRCS-01108：无法修改资源以使用配置为leaf的网络{0}。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用配置为“leaf”的网络修改资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供未配置为“叶子”的网络。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6F0CAD5C-1DE9-43D4-AB47-734B49D7A0BF"><!-- --></a> PRCS-01110：单客户端访问名称（SCAN）{0}无法解析为{1}个地址，尽管它应解析为IPv4和IPv6地址</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在网络类型为“BOTH”时修改SCAN名称，因为指定的SCAN名称未解析为网络所需的IPv4和IPv6地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保指定的SCAN名称解析为IPv4和IPv6地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-51738010-C3F9-403A-A674-FB28130ECE08"><!-- --></a> PRCS-01111：无法修改GNS VIP，因为注册类型和IP地址类型不同</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>为添加的GNS VIP指定的IP地址类型与注册的网络类型不同。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定已注册类型的IP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-1E2B4F07-876C-472E-BAFB-50757C6A7CB6"><!-- --></a> PRCS-01112：服务器{0}未分配给任何服务器池。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> Oracle Clusterware尚未识别给定服务器，因此在任何服务器池中都不活动。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'crsctl status server <span class="variable" translate="no">server</span> -f'检查服务器的状态。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-551BFE64-2969-4842-A117-9BFC95FE103E"><!-- --></a> PRCS-01113：单客户端访问名称（SCAN）VIP地址“{0}”不属于仅具有{2}子网的网络{1}。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>网络修改失败，因为指定的SCAN VIP地址的类型与指定网络的子网不兼容。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>通过命令'srvctl modify network -subnet'修改网络以包含缺少的类型，或确保SCAN VIP是与网络相同类型的地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F369C3FE-9071-440E-BF1A-5EF13480ED2C"><!-- --></a> PRCS-01115：尝试检索Rapid Home Provisioning Server主机名和端口号失败，并显示以下错误：\ n {0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在网格命名服务（GNS）中查找Rapid Home Provisioning Server（RHPS）连接详细信息时，尝试检索主机名和端口号失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查随附的错误消息。确保GNS和Rapid Home Provisioning Server都在RHPS群集上运行。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-7CEC5234-04A1-49F4-A92D-6706037A8597"><!-- --></a> PRCS-01116：在网格命名服务（GNS）中找不到服务{0}的SRV记录</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>这是一个内部错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>联系Oracle支持服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-9E5FE802-7F0A-4B11-B822-D9F1DA5BCB46"><!-- --></a> PRCS-01117：从网格命名服务（GNS）返回的SRV记录{0}的格式无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>这是一个内部错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>联系Oracle支持服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-8048B732-C27C-4443-9A62-72E846C50C21"><!-- --></a> PRCS-01118：提供的GNS VIP名称“{0}”解析为多个IP地址“{1}”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>安装先决条件检查确定输入的指示GNS VIP名称已解析为显示的多个IP地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重复安装面试，提供GNS VIP名称，该名称解析为一个地址或数字GNS VIP地址。或者，修改名称服务地址映射以仅将一个地址与名称关联，然后重新运行先决条件检查。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A3C5C121-CA72-4812-BC3A-FC6FAED6D0F7"><!-- --></a> PRCS-01119：非法尝试将网格命名服务实例角色修改为客户端</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将网格命名服务（GNS）角色修改为客户端。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>有效的GNS角色是PRIMARY和SECONDARY。指定其中一个并重新发出该命令。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-25350DC8-2647-49F5-B98D-1C9EA17F119C"><!-- --></a> PRCS-01120：提供的GNS VIP名称“{0}”解析为IPv4或IPv6类型的多个地址“{1}”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>解析指定的网格命名服务（GNS）VIP名称时，找到了多个类型为IPv4或IPv6类型的IP地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供GNS VIP名称，该名称可解析为两个地址，一个是IPv4类型，另一个是IPv6类型。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-5A793E8D-461E-4089-A723-1EF23F183BDF"><!-- --></a> PRCS-01121：提供的GNS VIP名称“{0}”解析为IPv4类型的多个地址“{1}”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>解析指定的网格命名服务（GNS）VIP名称时，找到多个IPv4类型的IP地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供GNS VIP名称，该名称解析为一个IPv4地址，或提供数字GNS VIP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3E643CC7-1A60-4DFF-9754-60E3B88AF5EF"><!-- --></a> PRCS-01122：提供的GNS VIP名称“{0}”解析为IPv6类型的多个地址“{1}”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>解析指定的网格命名服务（GNS）VIP名称时，找到了多个IPv6类型的IP地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>提供GNS VIP名称，该名称解析为一个IPv6地址，或提供数字GNS VIP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-5E7F644E-272B-446D-A97D-D8677BD25AD2"><!-- --></a> PRCS-01123：无法获取扩展群集配置信息</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试获取扩展群集配置信息失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的错误消息以获取详细信息，然后重试该命令，确保CRS堆栈正在运行。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E98C0A80-199C-48B2-9886-AB707D2AF948"><!-- --></a> PRCS-01124：未能获得Oracle Clusterware站点</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使Oracle Clusterware站点失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的错误消息以获取详细信息，然后重试该命令，确保CRS堆栈正在运行。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-27B11847-285C-4F9D-B2D1-C91222A2AA8A"><!-- --></a> PRCS-01125：无法获取节点{0}的Oracle Clusterware站点</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索指定节点的Oracle Clusterware站点失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的错误消息以获取详细信息，然后重试该命令，确保CRS堆栈正在运行。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-6FB894B5-B6AB-484D-9BC6-6A37247CC503"><!-- --></a> PRCS-01126：SCAN {0}没有为单客户端访问名称（SCAN）虚拟IP（VIP）配置静态IPv4地址。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将指示的SCAN的网络类型修改为“静态”被拒绝，因为SCAN没有配置静态IPv4地址的SCAN VIP。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl modify scan'配置带有SCAN VIP的指示SCAN，其地址解析为静态IPv4地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E3D675CC-3714-43F8-8C80-C129160DB63E"><!-- --></a> PRCS-01127：SCAN {0}没有为单客户端访问名称（SCAN）虚拟IP（VIP）配置静态IPv6地址。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将指示的SCAN的网络类型修改为“静态”被拒绝，因为SCAN没有配置静态IPv6地址的SCAN VIP。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl modify scan'配置带有SCAN VIP的指示SCAN，其地址解析为静态IPv6地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-0BC416E6-F3FA-403F-85B2-BCB38A5DBD6A"><!-- --></a> PRCS-01128：SCAN {0}没有为单客户端访问名称（SCAN）虚拟IP（VIP）配置的IPv4和IPv6两种类型的静态IP地址。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试将指示的SCAN的网络类型修改为“静态”被拒绝，因为SCAN没有为SCAN VIP配置IPv4和IPv6中的每种类型的静态地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl modify scan'配置SCAN VIP指示的SCAN，其地址解析为静态IPv4和IPv6地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B3D2E4FB-50D6-492B-B188-86B4408E15B3"><!-- --></a> PRCS-01129：阅读器场服务器池{1}的节点{0}没有LEAF活动CSS角色</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加或修改服务被拒绝，因为指定的服务器池没有使用阅读器场服务的策略管理数据库所需的ACTIVE_CSS_ROLE = LEAF节点。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用“srvctl modify serverpool -category”修改服务器池以使用具有LEAF活动Oracle集群同步服务（CSS）角色的节点，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-8D7B87B8-2A7B-47D3-A288-7E39AF312879"><!-- --></a> PRCS-01130：无法添加阅读器服务器场服务，因为网络{0}未扩展为在叶节点上运行</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加读者服务器场服务被拒绝，因为提供的网络未扩展到叶节点。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定扩展为在叶节点上工作的网络，或运行'srvctl modify network -extendtoleaf'并重复操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-FBA20FF8-8A9D-4ABE-BF4E-762437921C7F"><!-- --></a> PRCS-01131：无法将读者服务器场服务转换为其他服务类型</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>拒绝尝试修改阅读器场服务配置，因为不支持服务类型转换。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>创建所需服务类型的新服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C7DF0423-9D82-4BD8-A571-1CF384F7D2D2"><!-- --></a> PRCS-01132：数据库{0}配置为使用并行查询服务。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加读者服务器场服务配置被拒绝，因为指定的数据库已配置为使用并行查询服务。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl remove service'指定其他数据库或删除并行查询服务，并使用命令'srvctl add service'添加reader服务器服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3DD3582D-B2A2-4913-BDE3-51E918C9080C"><!-- --></a> PRCS-01133：数据库{0}配置为使用读者服务器场服务。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加并行查询服务配置被拒绝，因为指定的数据库已配置为使用reader farm服务。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl remove service'指定其他数据库或删除reader farm服务，并使用命令'srvctl add service'添加并行查询服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-8AE085A6-21D9-4B3E-BECF-5E8EEF52488C"><!-- --></a> PRCS-01134：服务器池{1}的服务器类别{0}具有以下非LEAF CSS角色：{2}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加或修改阅读器服务器场服务被拒绝，因为指定服务器池的服务器类别没有阅读器场服务所需的ACTIVE_CSS_ROLE = LEAF。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>修改服务器池以使用具有LEAF活动CSS角色的服务器类别，或修改服务器类别以使用ACTIVE_CSS_ROLE = LEAF并重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-54009608-BE1D-45AF-9D43-C127D2D78ECD"><!-- --></a> PRCS-01135：无法将非读者服务器场服务{0}转换为读者服务器场服务类型</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试修改非读者服务器场服务配置被拒绝，因为不支持服务类型转换。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add service -rfpool'创建新的阅读器服务器场服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A05370D4-F35C-4D45-B1EC-C7324B7BAA04"><!-- --></a> PRCS-01136：无法将服务器池的候选服务器列表设置为具有混合CSS角色的服务器列表。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试设置服务器池的候选服务器列表被拒绝，因为指定的服务器不是所有集线器节点或所有叶节点。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试操作，指定所有将ACTIVE_CSS_ROLE设置为“hub”的服务器列表，或者将ACTIVE_CSS_ROLE都设置为“leaf”的服务器列表。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-597A3502-CC37-4E21-81C1-41B0B6C1E50C"><!-- --></a> PRCS-01137：指定的版本必须为12.1.0.2或更高版本。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用-version选项导出网格命名服务（GNS）凭据失败，因为指定的版本早于12.1.0.2</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重新发出该命令，指定版本12.1.0.2或更高版本。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-1D706941-6AE7-4F92-AE1C-B7159A684CBE"><!-- --></a> PRCS-01138：无效的VIP地址“{0}”，因为指定的IP地址可以访问</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>指定的命令被拒绝，因为可以访问虚拟Internet协议（VIP）地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：将</span> VIP配置为使用在任何主机系统上不活动且无法使用“ping”访问的IP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-1F259E2A-2367-4912-B9ED-09CD01F5EE41"><!-- --></a> PRCS-01139：无法添加阅读器服务器场服务</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加读者服务器场服务被拒绝，因为中心服务未提供或无效。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定存在的中心服务，并为读取器服务器服务可以连接的可插拔数据库提供服务。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-51C07BDD-AAF0-4257-BEA0-AD046082738F"><!-- --></a> PRCS-01140：无效的GNS VIP地址{0}，因为指定的IP地址不在网络资源{2}的子网{1}中</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>网格命名服务虚拟Internet协议（GNS VIP）的子网与网络资源的子网不匹配。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用GNS VIP地址和子网匹配的网络的组合重试SRVCTL命令。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-902D08DD-0F3C-41D2-B8C5-6652617F33F0"><!-- --></a> PRCS-01141：无效的GNS VIP地址{0}，因为指定的IP地址不是网络资源{2}的{1}类型</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>为添加的GNS VIP指定的IP地址类型与注册的网络类型不同。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>指定已注册类型的IP地址。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-1CB4178F-1427-4988-AFCC-01A1687B8EC3"><!-- --></a> PRCS-01142：无法创建CDP资源，因为它已经存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加跨群集依赖关系代理（CDP）资源已被拒绝，因为该资源已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-73D3D07D-8E6B-4AAA-8D22-6EA1FF730C25"><!-- --></a> PRCS-01143：无法配置跨群集依赖项代理资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试为跨群集依赖关系代理（CDP）资源添加群集配置失败。随附的消息提供详细的故障信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>查看随附的错误消息，其中提供了无法创建的资源的详细信息。检查各个资源创建失败的原因和操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-AD938020-A004-4796-B7F4-17889FF77BC3"><!-- --></a> PRCS-01144：执行CDP的配置脚本时出错。详情：{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>执行跨群集依赖关系代理（CDP）资源的配置脚本时发生错误。消息后面会显示特定的故障数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的消息，解决已识别的问题，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-CE8B7BB6-BA49-4F91-8AD8-AECEBF52A3DF"><!-- --></a> PRCS-01145：找不到客户端群集{0}的单客户端访问名称（SCAN）侦听器资源。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试为指示的客户端检索SCAN侦听器资源失败。随附的错误消息提供详细的故障信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的错误消息，解决指示的问题，然后重试该操作，确保提供的群集名称正确。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-149A6188-E9A8-4A4B-9F21-5DFBFBF565EF"><!-- --></a> PRCS-01146：客户端群集{0}已存在单客户端访问名称（SCAN）侦听器资源。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建单客户端访问名称（SCAN）侦听器被拒绝，因为已为指定的客户端群集创建了资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，指定其他客户端群集名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-23057149-56B5-477B-80BA-D94C5FB3E4CB"><!-- --></a> PRCS-01147：无法为客户端群集{0}找到任何Oracle Notification Service（ONS）资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索指示客户端的ONS资源失败。随附的错误消息提供详细的故障信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的错误消息，解决指示的问题，然后重试该操作，确保提供的资源名称正确。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-207B3F33-C732-4CAC-A3CA-2942D3BB5E80"><!-- --></a> PRCS-01148：客户端群集{0}已存在ONS资源。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建Oracle Notification Service（ONS）资源被拒绝，因为已指定的客户端群集已存在资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，指定其他群集名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-297BE6E2-DA29-4B43-86E5-9D0C252FC471"><!-- --></a> PRCS-01149：无法找到ONS {0}的资源</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试查询资源失败，因为指示的Oracle Notification Service（ONS）资源不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，指定有效的ONS名称。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-4779AD61-FD3F-4835-986C-4DADCDB21865"><!-- --></a> PRCS-01150：ONS资源已存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试创建资源被拒绝，因为Oracle Notification Service（ONS）资源已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-96459DD5-8618-4FCA-97CE-E4175F1ACB1F"><!-- --></a> PRCS-01151：未为客户端群集配置指定的ONS资源。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试导出Oracle Notification Service（ONS）资源的客户端数据被拒绝，因为指定的ONS资源未配置为服务于客户端群集。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，指定配置为服务客户端群集的ONS资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-F1CD035E-CC4A-4658-8E47-C412511C8AC7"><!-- --></a> PRCS-01152：无法为客户端群集上的SCAN侦听器修改受邀节点。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>拒绝尝试修改SCAN侦听器的受邀节点，因为已为客户端群集配置了资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，在服务器群集上指定SCAN侦听器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-FE7327EE-00CE-4D67-8A41-EE69C48F05F2"><!-- --></a> PRCS-01153：无法为客户端群集上的SCAN侦听器修改受邀子网。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>拒绝尝试修改SCAN侦听器的受邀子网，因为已为客户端群集配置了资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，在服务器群集上指定SCAN侦听器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3090D831-51F8-4180-8222-B696E6512A62"><!-- --></a> PRCS-01154：未为客户端群集配置指定的SCAN侦听器资源。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试导出SCAN侦听器资源的客户端数据被拒绝，因为指定的SCAN侦听器资源未配置为服务于客户端群集。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，指定为客户端群集提供服务的SCAN侦听器资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-FCA8C2C6-104D-4F01-AD90-E20ADDA82237"><!-- --></a> PRCS-01155：缺少属性{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从指示的数据文件中获取XML属性失败，因为所需的XML属性属性不存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，提供有效的客户端数据文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-DACAA5A5-6D36-4D43-BEE2-95BEBBBDD3EA"><!-- --></a> PRCS-01156：服务器{1}中已配置服务{0}。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试修改指定服务器池的reader场服务池失败，因为该服务已经是服务器池的一部分。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>不需要采取任何行动。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-9AB4C729-8AF2-49AC-8E75-321849864C06"><!-- --></a> PRCS-01157：CDP资源不存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索跨群集依赖关系代理（CDP）资源失败，因为找不到该资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add cdp'创建CDP资源，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-75116319-EA9A-431A-A071-AEE145C797E4"><!-- --></a> PRCS-01158：TFA资源不存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索跟踪文件分析器（TFA）失败，因为找不到该资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add tfa'创建TFA资源，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A2802BE8-4FC5-4AF7-94CE-FBA2B66B3E15"><!-- --></a> PRCS-01159：无法创建TFA资源，因为它已存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加跟踪文件分析器（TFA）资源被拒绝，因为该资源已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-A7EE4B7F-CFB0-4489-B5C8-3D0E9737783E"><!-- --></a> PRCS-01160：CDP代理资源不存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试检索跨群集依赖关系代理（CDP）代理资源，但未找到CDP代理资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用命令'srvctl add cdpproxy'创建CDP代理资源，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-5D1324CF-A9BC-4246-AA77-DE161E99D171"><!-- --></a> PRCS-01161：无法创建CDP代理资源，因为它已存在。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加跨群集依赖关系代理（CDP）代理资源，但资源已存在。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-2CC24F6F-6A15-4C9E-8855-878039EA5843"><!-- --></a> PRCS-01162：无法使用不支持的类型“{0}”创建CDP代理。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试使用未知或不受支持的代理类型添加跨群集依赖关系代理（CDP）代理资源。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>重试该操作，提供有效的受支持代理类型。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-B3749404-AE43-4B21-8DBE-B4C4371E68A0"><!-- --></a> PRCS-01163：无法删除CDP资源{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试删除跨群集依赖关系代理（CDP）资源失败，因为资源正在运行或其他资源依赖于它。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查已标识的CDP资源的状态，并在删除之前停止CDP资源。如果CDP代理依赖于它，则强制标志可用于移除CDP资源。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-CB234486-47B1-48B8-BB49-118CAE6FCB00"><!-- --></a> PRCS-01164：无法修改CDP资源，因为以下CDP资源正在运行：{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试修改一个或多个跨群集依赖关系代理（CDP）资源被拒绝，因为指示的资源正在运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保已停止指示的CDP资源，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-2BE5A620-85B4-4C89-9152-9AE38E7614A5"><!-- --></a> PRCS-01165：群集{0}未向GNS注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从网格命名服务（GNS）检索有关指示群集的信息，发现群集未注册。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保向GNS注册指示的群集名称，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-2CA45278-AB73-4827-833C-3714B5222C45"><!-- --></a> PRCS-01166：群集GUID {0}未向GNS注册</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从网格命名服务（GNS）检索有关指示群集的信息，发现群集未注册。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保向GNS注册指示的群集GUID，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-3594E700-42C1-40E8-A0FA-FABE5BD5BEF5"><!-- --></a> PRCS-01167：没有向GNS注册的群集</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从网格命名服务（GNS）检索已注册的群集列表，检测到没有注册群集。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保至少有一个向GNS注册的群集，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-9007369A-64F8-4A8E-9703-27D842A4BF69"><!-- --></a> PRCS-01168：存储在客户端数据文件中的群集名称“{0}”与配置的群集名称“{1}”不同。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试在客户端群集上配置单客户端访问名称（SCAN）资源被拒绝，因为客户端数据文件包含不同群集名称的信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保为此群集名称导出客户端数据文件，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-197CD4C7-A99C-4C7A-82AA-AED9F3898339"><!-- --></a> PRCS-01169：无效的受邀子网值{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试更改受邀子网值的操作被拒绝，因为使用不正确的语法指定了受邀子网值。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保受邀子网值使用无类别域间路由（CIDR）语法（例如192.196.16.0/24）或通配符（例如192.196.16）。*）。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-13C5D5E3-2FE9-4C77-AD6A-5FFCAEE1A872"><!-- --></a> PRCS-01170：无效的节点名称值{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试添加单客户端访问名称（SCAN）被拒绝，因为节点名称值包含无效的活动节点。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保节点名称处于活动状态且唯一，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-C74D7288-F484-4591-96AF-DD5B8F3578D1"><!-- --></a> PRCS-01171：无法删除类别{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试删除指定的服务器类别失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的消息，解决已识别的问题，然后重试该操作。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-F8AA9823-5160-49ED-8EC9-06B03AC3A686__GUID-E9CD3AD9-1C6B-4AE3-AC0F-A19CC5E26B81"><!-- --></a> PRCS-01172：无法更新类别{0}</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试更新指定的服务器类别失败。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查附带的消息，解决已识别的问题，然后重试该操作。

                     </p>
                     
                  </dd>
               </dl>
            </div>
         </div>
      </article>
   </body>
</html><html id="06334.RECOVER.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>恢复</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Backup and Recovery Reference"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Backup and Recovery Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-backup-and-recovery-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T19:31:58-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2003, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96242-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="rman-commands-recover-to-validate.html" title="Previous" type="text/html"></link>
      <link rel="next" href="REGISTER-DATABASE.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Backup and Recovery Reference"></meta>
    <meta name="dcterms.isVersionOf" content="RCMRF"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="rman-commands-recover-to-validate.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="REGISTER-DATABASE.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">备份和恢复参考</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="rman-commands-recover-to-validate.html" property="item" typeof="WebPage"><span property="name">RMAN命令：RECOVER to VALIDATE</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">恢复</li>
            </ol>
            <a id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95" name="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95"></a><a id="RCMRF90237"></a><a id="RCMRF90238"></a><a id="RCMRF90613"></a><a id="RCMRF90239"></a><a id="RCMRF90614"></a><a id="RCMRF90240"></a><a id="RCMRF90241"></a><a id="RCMRF90242"></a><a id="RCMRF90615"></a><a id="RCMRF90244"></a><a id="RCMRF90245"></a><a id="RCMRF90616"></a><a id="RCMRF90247"></a><a id="RCMRF90248"></a><a id="RCMRF90249"></a><a id="RCMRF90617"></a><a id="RCMRF90251"></a><a id="RCMRF90252"></a><a id="RCMRF90618"></a><a id="RCMRF90253"></a><a id="RCMRF90254"></a><a id="RCMRF90255"></a><a id="RCMRF90256"></a><a id="RCMRF90257"></a><a id="RCMRF90258"></a><a id="RCMRF90259"></a><a id="RCMRF90619"></a><a id="RCMRF90620"></a><a id="RCMRF90621"></a><a id="RCMRF140"></a>
            
            <h2 id="RCMRF-GUID-CA98040F-9865-4F4F-BAF2-91C518612E95" class="sect2"><span class="enumeration_section">3.1</span>恢复</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-E2EEEAE0-06B3-4D2E-8A83-1A9DD49AF7C2">目的</p>
                  <p><a id="d69128e179" class="indexterm-anchor"></a><a id="d69128e181" class="indexterm-anchor"></a><a id="d69128e185" class="indexterm-anchor"></a><a id="d69128e189" class="indexterm-anchor"></a><a id="d69128e193" class="indexterm-anchor"></a>使用<code class="codeph">RECOVER</code>命令执行以下不同任务之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>执行完整恢复整个数据库或一个或多个恢复的数据文件</p>
                     </li>
                     <li>
                        <p>执行数据库（DBPITR），可插拔数据库（PDB），表空间（TSPITR），表或表分区的时间点恢复</p>
                     </li>
                     <li>
                        <p>将增量备份应用于数据文件映像副本（ <span class="italic">而不是</span>还原的数据文件）以及时向前滚动</p>
                     </li>
                     <li>
                        <p>恢复数据文件中的损坏数据块或数据块集</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-CABC3DC6-1EE1-421F-BACB-D2E12B7000AF">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../bradv/rman-complete-database-recovery.html#BRADV8005" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南</span></a> ，了解如何恢复数据文件</p>
                  </div>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-54DB059A-FF1D-4027-931F-CFBE966ECB50">先决条件</p>
                  <p>恢复所需的所有重做或增量更改必须存在于磁盘或SBT中。如果RMAN需要在恢复期间还原增量备份或归档重做日志文件，则必须配置自动通道或手动分配创建这些备份的相同类型的通道。</p>
                  <p><a id="d69128e230" class="indexterm-anchor"></a>如果在加密数据库或表空间上执行介质恢复，则在执行介质恢复时必须打开Oracle密钥库。请参阅<a href="../admin/managing-tablespaces.html#ADMIN12327" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a>以了解加密表空间。
                  </p>
                  <p></p>
                  <p>要使用预包装备份在目标CDB中执行恢复，必须打开根，并且必须以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限的公共用户身份连接到根。
                  </p>
                  <p></p>
                  <p>在使用共享撤消的CDB中，要执行一个或多个PDB的时间点恢复，必须提供包含所列PDB的CDB的根和种子数据库的备份。</p>
                  <p>要在PDB中执行表空间的TSPITR，必须提供包含PDB的CDB的根和种子数据库（ <code class="codeph">PDB$SEED</code> ）的备份。
                  </p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBDFJFG"><span class="bold">特殊于RECOVER BLOCK的先决条件</span></p>
                  <p>以下先决条件适用于<code class="codeph">RECOVER BLOCK</code> ：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a id="d69128e268" class="indexterm-anchor"></a><a id="d69128e270" class="indexterm-anchor"></a><a id="d69128e274" class="indexterm-anchor"></a>目标数据库必须以<code class="codeph">ARCHIVELOG</code>模式运行，并使用当前控制文件打开或挂载。
                        </p>
                     </li>
                     <li>
                        <p>RMAN只能恢复标记为媒体损坏的块。该<a id="d69128e285" class="indexterm-anchor"></a><a id="d69128e287" class="indexterm-anchor"></a> <code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图指示自最近的<code class="codeph">BACKUP</code>或<code class="codeph">BACKUP ...以来文件中的哪些块被标记为已损坏<code class="codeph">BACKUP ...对文件运行VALIDATE</code>命令。
                        </p>
                     </li>
                     <li>
                        <p><a id="d69128e302" class="indexterm-anchor"></a>包含损坏块的数据文件的备份必须是完全备份而不是代理备份。如果仅存在代理备份，则可以将它们还原到磁盘上的非默认位置，在这种情况下，RMAN会将它们视为数据文件副本。然后，您可以使用数据文件副本进行块介质恢复。
                        </p>
                     </li>
                     <li>
                        <p>RMAN只能使用归档的重做日志文件进行恢复。阻止介质恢复无法在丢失或无法访问的日志中生存，尽管有时可能会丢失或无法访问的记录（请参阅<a href="../bradv/rman-block-media-recovery.html#BRADV118" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南</span></a> ）。
                        </p>
                     </li>
                     <li>
                        <p>为使RMAN能够在闪回日志中搜索损坏块的良好副本，必须在目标数据库上启用闪回数据库。</p>
                     </li>
                     <li>
                        <p>为使RMAN能够在备用数据库中搜索损坏块的良好副本，目标数据库必须与Data Guard环境中的物理备用数据库相关联。此外，物理备用数据库必须在受管恢复中以只读方式打开。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-0795BA20-1B1D-457C-9356-41EA26EB01DE">
                     <p class="notep1">注意：</p>
                     <p>此操作需要有效的Data Guard许可证。</p>
                  </div>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDJBACD">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-4A9DDA45-6C70-4EFA-A1B0-597F0CD3D347">使用说明</p>
                  <p>默认情况下，RMAN执行完全恢复。对于时间点恢复，最佳做法是在<code class="codeph"><a href="RUN.html#GUID-88250EEF-DC49-42A9-822C-4011B1345C7B">RUN</a></code>命令中的<code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B">RESTORE</a></code>和<code class="codeph">RECOVER</code>命令之前输入<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">UNTIL</code>命令，以便<code class="codeph">UNTIL</code>时间适用于这两个命令。如果在还原数据库后运行<code class="codeph">SET UNTIL</code> ，则可能无法将数据库恢复到目标时间，因为还原的文件的时间戳可能晚于目标时间。
                  </p>
                  <div class="infoboxnote" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-2BB576D3-8963-4E72-9060-A02160E5639E">
                     <p class="notep1">注意：</p>
                     <p>使用备份控制文件进行不完全恢复或恢复后，必须使用<code class="codeph">RESETLOGS</code>选项打开数据库。
                     </p>
                  </div>
                  <p><span class="bold">增量备份和归档重做日志文件</span></p>
                  <p><a id="d69128e366" class="indexterm-anchor"></a>除<code class="codeph">RECOVER BLOCK</code> ，RMAN可以使用增量备份和归档重做日志文件进行恢复。RMAN使用以下搜索顺序：</p>
                  <ol>
                     <li>
                        <p>磁盘或磁带上的增量备份集</p>
                     </li>
                     <li>
                        <p>磁盘上存档的重做日志文件</p>
                     </li>
                     <li>
                        <p>磁盘上存档的重做日志备份</p>
                     </li>
                     <li>
                        <p>磁带上存档的重做日志备份集</p>
                     </li>
                  </ol>
                  <p>当RMAN选择目标来还原存档的重做日志文件时，它使用以下优先顺序：</p>
                  <ol>
                     <li>
                        <p><code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">ARCHIVELOG DESTINATION</code></p>
                     </li>
                     <li>
                        <p>该<a id="d69128e402" class="indexterm-anchor"></a> <code class="codeph">LOG_ARCHIVE_DEST_</code> <span class="italic"><code class="codeph">n</code></span>参数，其值设置为<code class="codeph">LOCATION=USE_DB_RECOVERY_FILE_DEST</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">LOG_ARCHIVE_DEST_1</code></p>
                     </li>
                  </ol>
                  <p>RMAN可以将增量备份应用于未从增量备份还原的数据文件。如果存在重叠级别的增量备份，则RMAN会自动选择覆盖最长时间段的级别。</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAJHAJF"><span class="bold">使用存储快照进行恢复</span><a id="d69128e421" class="indexterm-anchor"></a><a id="d69128e425" class="indexterm-anchor"></a></p>
                  <p>通过Storage Snapshot Optimization，您可以使用第三方技术获取存储快照，而无需将数据库或关联的数据文件置于<code class="codeph">BACKUP</code>模式。使用存储快照恢复数据库时，请指定<code class="codeph">SNAPSHOT TIME</code>选项。
                  </p>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-D74FCC5A-A06C-42D6-A992-32DE427071AC">
                     <p class="notep1">也可以看看：</p>
                     <p>有关指定快照时间的信息，请参见“ <a href="../bradv/user-managed-flashback-dbpitr.html#BRADV727" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”</span></a></p>
                  </div>
                  <p>要在恢复操作中使用，快照必须符合以下要求。请您的供应商保证合规性。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>快照期间数据库崩溃一致。</p>
                     </li>
                     <li>
                        <p>快照保留每个文件的写入顺序。</p>
                     </li>
                     <li>
                        <p>快照技术存储快照完成的时间。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-534F440E-B7A4-4B28-B13A-146304135AA7">
                     <p class="notep1">警告：</p>
                     <p>请注意数据库快照是否可用。如果在快照期间进行了结构更改，Oracle数据库不会使用快照进行恢复。某些SQL操作可以进行数据库结构更改，不应在快照期间使用。此类操作的一些示例包括<code class="codeph">OFFLINE</code> ， <code class="codeph">ONLINE</code> ， <code class="codeph">READONLY</code> ， <code class="codeph">DROP</code> ， <code class="codeph">RENAME</code> ， <code class="codeph">SHRINK</code>和<code class="codeph">ADD</code>子句。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-0E8A6B09-3A17-4A69-B93A-D8DC78ACCF18">
                     <p class="notep1">也可以看看：</p>
                     <p>有关使数据库结构更改的子句的信息，请参阅<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span class="italic">Oracle数据库SQL语言参考中的</span></a> <code class="codeph">ALTER DATABASE</code>和<code class="codeph">ALTER TABLESPACE</code>命令</p>
                  </div>
                  <p><span class="bold">通过RESETLOGS恢复</span></p>
                  <p>您必须先<code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B">RESTORE</a></code>数据文件，然后才能恢复它们。如果要恢复的数据文件来自父级化身，RMAN可以透明地通过<code class="codeph">RESETLOGS</code>操作进行恢复。如果需要， <code class="codeph">RECOVER</code>命令还可以从以前的数据库版本中恢复和应用归档重做日志文件和增量备份，即使这些日志是在以前版本的Oracle数据库中生成的。
                  </p>
                  <p>通过<code class="codeph">OPEN RESETLOGS</code>进行恢复时，请确保拥有恢复所需的所有日志。在以前的数据库版本中，您必须具有从备份时间到SCN小于<code class="codeph">RESETLOGS SCN</code>的日志。化身表必须具有从数据库备份创建时起的<code class="codeph">RESETLOGS</code>操作的完整历史记录。如果在<code class="codeph">V$DATABASE_INCARNATION</code>找不到完整的元数据，则可以使用<code class="codeph"><a href="CATALOG.html#GUID-6E337759-9860-463A-BF7C-8512B272B8E1">CATALOG</a></code>为缺少的化身中的归档重做日志文件重新创建此元数据。
                  </p>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-F1C84C0F-5BF0-45A0-866C-0D7EFD208082">
                     <p class="notep1">也可以看看：</p>
                     <p><code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B">RESTORE</a></code>命令用于说明还原存档重做日志文件的默认位置。在快速恢复区域中登录日志时，RMAN会自动指定<code class="codeph">MAXSIZE</code>选项。
                     </p>
                  </div>
                  <p><span class="bold">恢复CDB和PDB</span><a id="d69128e543" class="indexterm-anchor"></a><a id="d69128e547" class="indexterm-anchor"></a><a id="d69128e551" class="indexterm-anchor"></a><a id="d69128e555" class="indexterm-anchor"></a></p>
                  <p>RMAN使您可以在根或PDB中恢复整个多租户容器数据库（CDB），根，一个或多个PDB以及表空间。您可以为PDB和CDB执行完全恢复或时间点恢复。但是，您无法将根恢复到指定的时间点。</p>
                  <p>恢复CDB和PDB的过程类似于非CDB的过程。不同之处在于连接到CDB或PDB以及使用的命令。要恢复整个CDB，根或多个PDB，请连接到根。要恢复特定PDB，请连接到该PDB。要恢复PDB，请使用<code class="codeph">RECOVER PLUGGABLE DATABASE</code>命令。要恢复整个CDB，请使用<code class="codeph">RECOVER DATABASE</code>命令并恢复根，使用<code class="codeph">RECOVER DATABASE ROOT</code>命令。
                  </p>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-57812173-E962-49EE-A77D-A3CD12866D9D">
                     <p class="notep1">也可以看看：</p>
                     <p>有关连接到CDB和PDB的信息，请<span class="q">“ <a href="CONNECT.html#GUID-64ECF1B8-4F70-413E-BEBE-1D5E8CD48B67">CONNECT</a> ”</span></p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-6F472BF4-CDDF-477F-B334-85ECFE12C039">
                     <p class="notep1">也可以看看：</p>
                     <p>有关执行CDB PDB恢复的信息，请参见<a href="../bradv/rman-complete-database-recovery.html#BRADV-GUID-1F744C63-2D4C-4F65-8773-1340A85993ED" target="_blank"><span><cite>“Oracle数据库备份和恢复用户指南”</cite></span></a></p>
                  </div>
                  <p>在Data Guard环境中，您可能需要在主数据库的时间点恢复之后还原整个CDB，以使备用数据库跟随主数据库。</p>
                  <p><span class="bold">恢复稀疏数据库</span></p>
                  <p>当<code class="codeph">COMPATIBLE</code>初始化参数设置为12.2或更高时，RMAN还允许您为多租户和非CDB稀疏数据库执行时间点恢复。为了完全恢复，RMAN通过应用归档重做日志文件和联机重做日志来恢复数据文件。因此， <code class="codeph">FROM SPARSE</code>和<code class="codeph">FROM NONSPARSE</code>子句不适用于完全恢复。对于时间点恢复，RMAN首先恢复数据文件然后恢复它们，因此， <code class="codeph">FROM SPARSE</code>和<code class="codeph">FROM NONSPARSE</code>子句适用于PITR。</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-556716D3-A8C9-403C-9D20-05D91101C2B4">句法</p>
                  <p><a id="d69128e614" class="indexterm-anchor"></a><a id="d69128e618" class="indexterm-anchor"></a> <span class="bold"><span class="italic">recover</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-626816AA-492D-40F4-823E-F18B2E559D2B"><img src="img/recover.gif" alt="recover.eps的描述如下" title="recover.eps的描述如下" longdesc="img_text/recover.html"><br><a href="img_text/recover.html">说明recover.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC__BABDEJAC">deviceSpecifier :: =</a></span> ， <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDECJGE">recoverObject :: =</a></span> ， <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIIEGB">recoverOptionList :: =</a></span> ）</p>
                  <p><a id="d69128e644" class="indexterm-anchor"></a><a id="d69128e648" class="indexterm-anchor"></a> <span class="bold"><span class="italic">recoverSpec</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-95C09C81-4D2A-469A-92D9-5406587262FB"><img src="img/recoverspec.gif" alt="recoverspec.eps的描述如下" title="recoverspec.eps的描述如下" longdesc="img_text/recoverspec.html"><br><a href="img_text/recoverspec.html">说明recoverspec.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDECJGE">recoverObject :: =</a></span> ， <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIDHBB">blockObject :: =</a></span> ， <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIIEGB">recoverOptionList :: =</a></span> ）</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDECJGE"><a id="d69128e674" class="indexterm-anchor"></a><a id="d69128e678" class="indexterm-anchor"></a> <span class="bold"><span class="italic">recoverObject</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-8DCC3752-98AF-42A1-9424-BB3AA7E55921"><img src="img/recoverobject.gif" alt="recoverobject.eps的描述如下" title="recoverobject.eps的描述如下" longdesc="img_text/recoverobject.html"><br><a href="img_text/recoverobject.html">说明recoverobject.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAFEGJI">dbObject</a></span> ， <span class="italic"><a href="untilClause.html#GUID-6A6C502A-6E21-4673-9FC9-C075D1E2F97A__BABEDABD">untilClause :: =</a></span> ）</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAJHCII"><a id="d69128e700" class="indexterm-anchor"></a> <span class="bold"><span class="italic">dbObject</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-A5F60A2C-39AF-436E-8DED-C75012D2568B"><img src="img/dbobject.gif" alt="dbobject.eps的描述如下" title="dbobject.eps的描述如下" longdesc="img_text/dbobject.html"><br><a href="img_text/dbobject.html">说明dbobject.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIDHBB"><a id="d69128e713" class="indexterm-anchor"></a><a id="d69128e717" class="indexterm-anchor"></a> <span class="bold"><span class="italic">blockObject</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-67388E93-D8D6-47B6-BDA5-0AED88D2E424"><img src="img/blockobject.gif" alt="下面是blockobject.eps的描述" title="下面是blockobject.eps的描述" longdesc="img_text/blockobject.html"><br><a href="img_text/blockobject.html">插图描述blockobject.eps</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220__BABCCBBJ">datafileSpec :: =</a></span> ）</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIIEGB"><a id="d69128e735" class="indexterm-anchor"></a><a id="d69128e739" class="indexterm-anchor"></a> <span class="bold"><span class="italic">recoverOptionList</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-5918B74D-F768-40DF-A974-DF6569C81C7E"><img src="img/recoveroptionlist.gif" alt="recoveroptionlist.eps的描述如下" title="recoveroptionlist.eps的描述如下" longdesc="img_text/recoveroptionlist.html"><br><a href="img_text/recoveroptionlist.html">说明recoveroptionlist.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFADCCJE">remapTableList :: =</a></span> ， <span class="italic"><a href="sizeSpec.html#GUID-146EDBEE-BCED-4BD4-A720-8E51AA8DC577__BABHAICB">sizeSpec :: =</a></span> ）</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFADCCJE"><span class="bold"><span class="italic">remapTableList</span> :: =</span></p>
                  <div class="figure" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-F3F8F791-01F9-4786-988A-59C86673D5FF"><img src="img/remaptablelist.gif" alt="下面是remaptablelist.eps的描述" title="下面是remaptablelist.eps的描述" longdesc="img_text/remaptablelist.html"><br><a href="img_text/remaptablelist.html">说明remaptablelist.eps的说明</a></div>
                  <!-- class="figure" -->
               </div>
               <!-- class="section" -->
               <div class="section">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-10B79C7C-F269-4531-9B9E-1DE4E1E743BD">语义</p>
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBHDECB"><span class="bold"><span class="italic">恢复</span></span></p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-BAD26656-02EE-4DAC-8BA0-8CBFF972BBF7">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes RECOVER command parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e783">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e786">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e791" headers="d69128e783 ">
                                 <p><code class="codeph">DEVICE TYPE</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e791 d69128e786 ">
                                 <p>仅为指定的设备类型分配自动通道。例如，如果配置自动磁盘和磁带通道，并且发出<code class="codeph">RECOVER DEVICE TYPE DISK</code> ，则RMAN仅分配磁盘通道。
                                 </p>
                                 <p>在指定<code class="codeph">DEVICE TYPE</code>选项之前，使用<code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A">CONFIGURE</a></code> <code class="codeph">DEVICE TYPE</code>命令<code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A">CONFIGURE</a></code> <code class="codeph">DEVICE TYPE</code> （ <code class="codeph">DISK</code>除外，它是预先配置的）。
                                 </p>
                                 <p><span class="bold">注意：</span>您无法手动分配通道，然后运行<code class="codeph">RECOVER DEVICE TYPE</code> 。</p>
                                 <p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e840" headers="d69128e783 ">
                                 <p><span class="italic"><code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDBIFBF">recoverSpec</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e840 d69128e786 ">
                                 <p>指定要恢复的对象的类型。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDBIFBF"><span class="bold"><span class="italic">recoverSpec</span></span></p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-5CA85DE2-B4F2-4844-9C6E-32A85D645F06">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes RECOVER command recoverSpec parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e861">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e864">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e869" headers="d69128e861 ">
                                 <p><span class="italic"><code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBIGJEH">recoverObject</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e869 d69128e864 ">
                                 <p>指定要恢复的对象的类型。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e879" headers="d69128e861 ">
                                 <p><span class="italic"><code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDCAGGA">blockObject</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e879 d69128e864 ">
                                 <p>指定要使用块介质恢复恢复的块。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e889" headers="d69128e861 ">
                                 <p><span class="italic"><code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__I999383">recoverOptionList</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e889 d69128e864 ">
                                 <p>指定恢复选项。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBIGJEH"><span class="bold"><span class="italic">recoverObject</span></span></p>
                  <p>本小节指定要恢复的文件。有关语法图，请参阅<span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDECJGE">recoverObject :: =</a></span> 。
                  </p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-F4C3820B-534E-4F16-BF3C-768698D33D91">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes RECOVER command recoverObject parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e916">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e919">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e924" headers="d69128e916 ">
                                 <p><span class="italic"><code class="codeph"><a href="dbObject.html#GUID-C5C5EC3A-1B4E-4591-8E70-715E4BDC9FF8">dbObject</a></code></span> <code class="codeph">COPY OF</code>   
                                 </p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e924 d69128e919 ">
                                 <p>将增量备份应用于指定的映像副本，以将其前滚到与文件的最新增量备份相等或之前的任何时间。现有的图像副本被覆盖并在恢复期间保持模糊状态。恢复映像副本后，RMAN进行自动备份。</p>
                                 <p>此命令更新数据文件副本，而<span class="italic">不是</span>当前数据库文件的介质恢复。此命令旨在与<code class="codeph">BACKUP ...一起使用<code class="codeph">BACKUP ...FOR RECOVER OF COPY</code>恢复FOR RECOVER OF COPY</code>语法以使用增量更新的备份实施策略。
                                 </p>
                                 <p>必须满足以下要求：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>必须至少存在要恢复的每个数据文件的一个副本。</p>
                                    </li>
                                    <li>
                                       <p>必须存在要恢复的映像副本后执行的增量备份。</p>
                                    </li>
                                 </ul>
                                 <p>如果存在可以应用增量备份以执行操作的多个可能副本，则RMAN选择一个合适的副本。</p>
                                 <p><span class="bold">注意：如果</span> RMAN无法恢复到指定的时间，则会发出警告（而不是错误），因为没有可用的增量备份。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e962" headers="d69128e916 ">
                                 <p><code class="codeph">WITH TAG</code> <span class="italic"><code class="codeph">tag_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e962 d69128e919 ">
                                 <p>指定标记名称以标识要前滚的图像副本。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e974" headers="d69128e916 ">
                                 <p><code class="codeph">DATAFILECOPY</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e974 d69128e919 ">
                                 <p>将增量备份应用于指定的数据文件映像副本（请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDFCFJI">示例3-4</a> ）。请参阅<code class="codeph">RECOVER COPY OF</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e995" headers="d69128e916 ">
                                 <p><span class="italic"><code class="codeph"><a href="dbObject.html#GUID-C5C5EC3A-1B4E-4591-8E70-715E4BDC9FF8">DBOBJECT</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e995 d69128e919 ">
                                 <p>指定需要恢复的数据块。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1006" headers="d69128e916 ">
                                 <p><code class="codeph">备用数据库</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1006 d69128e919 ">
                                 <p></p>
                                 <p>应用增量备份，前滚，然后重新启动物理备用数据库。必须使用<code class="codeph">FROM SERVICE</code>子句指定用于刷新备用数据库的主数据库。
                                 </p>
                                 <p>以目标身份连接到物理备用数据库，并在<code class="codeph">FROM SERVICE</code>子句中指定物理备用数据库的网络服务名称。
                                 </p>
                                 <p><span class="bold">注意：</span>可以与<code class="codeph">STANDBY DATABASE</code>一起使用的唯一子句是<code class="codeph">PFILE</code>和<code class="codeph">FROM SERVICE</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1036" headers="d69128e916 ">
                                 <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAIFDBG"><code class="codeph">FOREIGN DATAFILECOPY</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1036 d69128e919 ">
                                 <p>指定需要通过应用增量备份使外部数据文件副本的名称一致。这些外部数据文件副本是在不一致的跨平台备份期间使用带有<code class="codeph">ALLOW INCONSISTENT</code>子句的<code class="codeph">CONVERT</code>或<code class="codeph">BACKUP</code>命令创建的。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1060" headers="d69128e916 ">
                                 <p>  <code class="codeph">FROM BACKUPSET</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1060 d69128e919 ">
                                 <p>指定包含跨平台增量备份的备份集的名称，该备份集必须应用于使用<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAIFDBG">FOREIGN DATAFILECOPY'filename'</a>子句指定的外部数据文件副本。
                                 </p>
                                 <p>要应用跨平台增量备份，必须满足以下条件：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>跨平台增量备份中每个数据文件的起始SCN必须小于外部数据文件副本的当前检查点SCN。</p>
                                    </li>
                                    <li>
                                       <p>不得修改外部数据文件副本。</p>
                                       <p>例如，它不应该插入目标数据库，更改为读写模式，然后更改回只读模式。这会更改外部数据文件副本标头中的数据库ID和文件号。</p>
                                    </li>
                                 </ul>
                                 <p>如果不满足这些条件，则会发生错误，并且跨平台增量备份不会应用于外部数据文件副本。</p>
                                 <p></p>
                                 <p><span class="bold">注意：</span>您不能将包含多个备份集的增量备份应用于一组外部数据文件。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1098" headers="d69128e916 ">
                                 <p><code class="codeph">TABLE</code> <span class="italic"><code class="codeph">schema.table</code></span> <code class="codeph">[:</code> <span class="italic"><code class="codeph">partition</code></span> <code class="codeph">]</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1098 d69128e919 ">
                                 <p>指定必须恢复的表或表分区。目标数据库必须处于读写模式。</p>
                                 <p></p>
                                 <p>在执行恢复之前，RMAN会检查目标主机上是否有足够的空间来存储恢复期间使用的辅助实例的文件。如果不存在足够的空间，则RMAN将显示错误消息并退出。</p>
                                 <p>您可以使用<code class="codeph">REMAP TABLE</code>选项为目标数据库中的已恢复表或表分区分配新名称。
                                 </p>
                                 <p>将恢复的表导入目标数据库时，如果目标数据库中存在具有相同名称的表，则会显示一条错误消息，指示必须使用<code class="codeph">REMAP TABLE</code>子句重命名表。
                                 </p>
                                 <p>从分区表中仅恢复某些分区时，每个分区将作为单独的表导入目标数据库。如果<code class="codeph">REMAP TABLE</code>未用于重命名已恢复的对象，则RMAN使用表名和分区名的串联为每个表命名。已恢复对象的表名称格式为<span class="italic"><code class="codeph">tablename_partitionname</code></span> 。如果目标数据库中存在具有此名称的表，则RMAN会将_1附加到生成的表名称。如果存在具有此名称的表，则RMAN会将_2附加到表名，依此类推。
                                 </p>
                                 <p>参见<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAFEEDH">例3-8</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1142" headers="d69128e916 ">
                                 <p><code class="codeph">OF PLUGGABLE DATABASE</code> <span class="italic"><code class="codeph">pdb_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1142 d69128e919 ">
                                 <p>在CDB中，a的名称<a id="d69128e1153" class="indexterm-anchor"></a><a id="d69128e1157" class="indexterm-anchor"></a>其中必须恢复的表或表分区所在的PDB。要恢复PDB中的表或表分区，必须按照<span class="q">“ <a href="CONNECT.html#GUID-64ECF1B8-4F70-413E-BEBE-1D5E8CD48B67__BGBGAIGG">连接到CDB和PDB</a> ”中的说明</span>连接到根。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1167" headers="d69128e916 ">
                                 <p><code class="codeph">跳跃</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1167 d69128e919 ">
                                 <p>在开始介质恢复之前，使指定表空间中的数据文件脱机。介质恢复完成后，这些文件将保持脱机状态。</p>
                                 <p>此选项对于避免恢复仅包含临时数据的表空间或推迟某些表空间的恢复非常有用。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1177" headers="d69128e916 ">
                                 <p><code class="codeph">永远</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1177 d69128e919 ">
                                 <p>使用<code class="codeph">DROP</code>选项使数据文件脱机（请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDGFJAD">示例3-3</a> ）。在使用<code class="codeph">RESETLOGS</code>选项打开数据库后，如果要删除指定的表空间，请使用<code class="codeph">SKIP FOREVER TABLESPACE</code> 。
                                 </p>
                                 <p><span class="bold">注意：</span>如果执行不完全恢复，则<code class="codeph">SKIP</code>需要<code class="codeph">FOREVER</code>选项。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1207" headers="d69128e916 "><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1207 d69128e919 ">
                                 <p>指定要脱机的表空间的名称。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1218" headers="d69128e916 ">
                                 <p><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">pdb_name</code></span> <code class="codeph">:</code> <span class="italic"><code class="codeph">tablespace_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1218 d69128e919 ">
                                 <p>PDB中表空间的名称。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1234" headers="d69128e916 ">
                                 <p><code class="codeph">SNAPSHOT TIME</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">date_string</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1234 d69128e919 ">
                                 <p>指定使用存储快照优化创建的快照备份的基于时间的恢复。 date_string是快照完成的时间，以RMAN <code class="codeph">TIME</code>格式（由<code class="codeph">NLS_DATE_FORMAT</code>环境变量定义）指定。
                                 </p>
                                 <p>您可以将<code class="codeph">SNAPSHOT TIME</code>与<code class="codeph">UNTIL TIME</code>或<code class="codeph">UNTIL SCN</code>结合使用来执行数据库时间点恢复（DBPITR）。但是，您只能将DBPITR执行到某个时间或SCN大于指定的快照完成时间。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <span class="q">“ <a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAJHAJF">使用存储快照</a></span>进行<span class="q"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAJHAJF">恢复</a> ”，</span>以获取有关快照系统要求以及如何指定快照时间的信息。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1275" headers="d69128e916 "><a id="d69128e1276" class="indexterm-anchor"></a><a id="d69128e1280" class="indexterm-anchor"></a> <code class="codeph">TO RESTORE POINT</code> <span class="italic"><code class="codeph">restore_point_name</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1275 d69128e919 ">
                                 <p>指定用于终止<code class="codeph">RECOVER</code>命令的还原点，其中创建还原点的SCN为包含上限的上限。由于限制是包含的，因此RMAN仅选择可用于恢复<span class="italic">并包括</span>与还原点对应的SCN的文件。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1300" headers="d69128e916 ">
                                 <p><span class="italic"><code class="codeph"><a href="untilClause.html#GUID-6A6C502A-6E21-4673-9FC9-C075D1E2F97A">untilClause</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1300 d69128e919 ">
                                 <p>指定用于终止<code class="codeph">RECOVER</code>命令的过去时间，SCN或日志序列号。
                                 </p>
                                 <p>与一个或多个表空间一起使用时，该子句指示命名表空间的表空间时间点恢复（TSPITR）操作。不要将此子句与<code class="codeph">RECOVER DATAFILE</code>或<code class="codeph">RECOVER DATABASE</code> （请参阅<span class="q">“ <a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDJBACD">使用说明</a> ”</span> ）。在数据库时间点恢复（DBPITR）之后，必须使用<code class="codeph">RESETLOGS</code>选项打开数据库。
                                 </p>
                                 <p><span class="bold">另见：</span> <span class="italic"><code class="codeph"><a href="untilClause.html#GUID-6A6C502A-6E21-4673-9FC9-C075D1E2F97A">untilClause</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1338" headers="d69128e916 ">
                                 <p><code class="codeph">直到可用的重做</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1338 d69128e919 ">查找最后一个可用的归档重做日志和联机重做日志，并将数据库恢复到缺少日志的位置。
                                 <p>只有在为整个数据库执行恢复时，才能使用此选项。您无法使用<code class="codeph">UNTIL AVAILABLE REDO</code>选项恢复数据文件，表空间或PDB。
                                 </p>
                                 <p>要为PDB执行时间点恢复，必须指定SCN以进行恢复。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAFEGJI"><span class="bold"><span class="italic">DBOBJECT</span></span></p>
                  <p>本子条款指定是恢复数据库还是恢复数据库的子集。有关语法图，请参阅<span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAJHCII">dbObject :: =</a></span> 。
                  </p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-C00879F3-38C3-4D79-ADBD-DB07E23AA9C9">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes dbObject subclause parameters of RECOVER command" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e1369">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e1372">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1377" headers="d69128e1369 "><code class="codeph">应用根数据库</code></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1377 d69128e1372 ">
                                 <p></p>
                                 <p>指定应用程序根目录中的所有数据文件。</p>
                                 <p>使用<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限以普通用户身份连接到CDB根目录。或者，以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限的应用程序通用用户身份连接到应用程序根目录。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1399" headers="d69128e1369 ">
                                 <p><code class="codeph">数据库</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1399 d69128e1372 ">
                                 <p>指定整个数据库（请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDGFJAD">示例3-3</a> ）。对于CDB，它指定整个CDB。</p>
                                 <p>在CDB中，恢复整个CDB。您连接到根以备份整个CDB，如<span class="q">“ <a href="CONNECT.html#GUID-64ECF1B8-4F70-413E-BEBE-1D5E8CD48B67__BGBGAIGG">连接到CDB和PDB</a> ”中所述</span> 。
                                 </p>
                                 <p></p>
                                 <p>在应用程序容器中，将整个应用程序容器恢复到指定的时间点。这包括应用程序根目录和属于此应用程序根目录的所有应用程序PDB。您以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限的应用程序通用用户身份连接到应用程序根目录。
                                 </p>
                                 <p>默认情况下， <code class="codeph">RECOVER DATABASE</code>命令不会恢复在恢复文件的时间点处于脱机正常状态的文件。RMAN省略了脱机正常文件而无需进一步检查。
                                 </p>
                                 <p>在丢失控制文件后进行恢复时，RMAN会自动更新控制文件以指向磁盘上数据文件的实际位置（请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDEAEGH">示例3-5</a> ）。
                                 </p>
                                 <p>如果RMAN遇到重做以添加数据文件，则RMAN会自动创建新数据文件，除非在恢复期间跳过包含添加的数据文件的表空间。在恢复之前恢复备份控制文件并且备份控制文件不包含最近添加的数据文件的记录时，可能会出现这种情况。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1435" headers="d69128e1369 ">
                                 <p><code class="codeph">数据库根</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1435 d69128e1372 ">
                                 <p>仅指定<a id="d69128e1442" class="indexterm-anchor"></a><a id="d69128e1446" class="indexterm-anchor"></a> CDB中的根。按照<span class="q">“ <a href="CONNECT.html#GUID-64ECF1B8-4F70-413E-BEBE-1D5E8CD48B67__BGBGAIGG">连接到CDB和PDB</a> ”中的说明</span>连接到根目录。
                                 </p>
                                 <p></p>
                                 <p>在应用程序容器中，恢复属于应用程序根目录和所有应用程序PDB的在线数据文件。以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限的应用程序通用用户身份连接到应用程序根目录。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1465" headers="d69128e1369 ">
                                 <p><code class="codeph">PLUGGABLE DATABASE</code> <span class="italic"><code class="codeph">pdb_name</code></span> 
                                 </p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1465 d69128e1372 ">
                                 <p>指定一个或多个<a id="d69128e1477" class="indexterm-anchor"></a><a id="d69128e1481" class="indexterm-anchor"></a> CDB中的PDB。没有其他PDB受到影响;他们可以保持开放和运作。使用逗号分隔的列表指定多个PDB。要使用此子句，必须连接到root。
                                 </p>
                                 <p>执行完全恢复不需要您连接到根。您连接到根以执行以下任何PDB操作：时间点恢复，表恢复，TSPITR或复制。要连接到根或PDB，请参阅<span class="q">“ <a href="CONNECT.html#GUID-64ECF1B8-4F70-413E-BEBE-1D5E8CD48B67__BGBGAIGG">连接到CDB和PDB”</a> 。</span> 。
                                 </p>
                                 <p></p>
                                 <p>在应用程序容器中，以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>权限的公共用户身份连接到CDB根目录，并在<code class="codeph">SYSBACKUP</code>指定应用程序根目录的<code class="codeph"><span class="codeinlineitalic">pdb_name</span></code>以恢复应用程序根目录和所有应用程序PDB。
                                 </p>
                                 <p>要恢复应用程序PDB，请以具有<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACK</code>权限的应用程序通用用户身份连接到应用程序根目录。要恢复多个应用程序PDB，请指定应用程序PDB名称的公共分隔列表。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1515" headers="d69128e1369 ">
                                 <p><code class="codeph">DATAFILE</code> <span class="italic"><code class="codeph"><span class="codeinlineitalic"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220">datafileSpec</a></span></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1515 d69128e1372 ">
                                 <p>通过文件名或绝对数据文件号指定一个或多个数据文件的列表。</p>
                                 <p>必须安装或打开目标数据库。如果数据库已打开，则要恢复的数据文件必须处于脱机状态。</p>
                                 <p>如果未使用恢复目录，则文件名必须是控制文件中记录的数据文件的名称。如果使用恢复目录，则数据文件的文件名必须是目录中记录的最新名称，即使控制文件中的名称最近已更新。例如，假设在控制文件中重命名了数据文件，但在重新同步目录之前实例失败。在<code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95">RECOVER</a></code>命令中指定数据文件的旧名称，因为这是目录中记录的名称。
                                 </p>
                                 <p><span class="bold">注意：</span>您不能随意将各个数据文件恢复到不同的时间点，尽管您可以将整个数据库恢复到单个时间点，或者将完全包含的表空间恢复到与数据库其余部分（TSPITR）不同的时间点。有关TSPITR的详细信息，请参阅“ <a href="../bradv/performing-rman-tspitr.html#BRADV009" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”中</span></a>描述的过程。
                                 </p>
                                 <p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220">datafileSpec</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1557" headers="d69128e1369 "><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1557 d69128e1372 ">
                                 <p>指定一个或多个表空间的列表。必须安装或打开目标数据库。如果数据库已打开，则要恢复的表空间必须处于脱机状态。</p>
                                 <p>连接到根目录时<a id="d69128e1569" class="indexterm-anchor"></a><a id="d69128e1575" class="indexterm-anchor"></a> CDB，指定根中的表空间。指定连接到PDB时PDB中的表空间的名称。</p>
                                 <p>在CDB中，在连接到根时指定根中的表空间的名称，并在连接到PDB时指定PDB中的表空间的名称。</p>
                                 <p><span class="bold">注意：</span>如果RMAN遇到重做以添加数据文件，则RMAN会自动创建新数据文件。在恢复之前恢复备份控制文件并且备份控制文件不包含最近添加的数据文件的记录时，可能会出现这种情况。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1587" headers="d69128e1369 ">
                                 <p><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">pdb-name</code></span> <code class="codeph">:</code> <span class="italic"><code class="codeph">tablespace_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1587 d69128e1372 ">
                                 <p>PDB中表空间的名称。多个PDB可以具有相同名称的表空间。名称前面的限定符唯一标识表空间。仅在连接到根时才需要此语法。直接连接到PDB时，请使用<code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span> 。 <span class="italic"><code class="codeph">pdb-name</code></span>是PDB的名称。</p>
                                 <p>有关一般信息，请参阅前面的<code class="codeph">TABLESPACE</code>描述。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDCAGGA"><span class="bold"><span class="italic">blockObject</span></span></p>
                  <p>本小节指定了需要恢复的数据块。有关语法图，请参阅<span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIDHBB">blockObject :: =</a></span> 。有关阻止介质恢复的先决条件，请参阅<span class="q">“ <a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBDFJFG">RECOVER BLOCK</a></span>特有的先决条件<span class="q">”</span> 。
                  </p>
                  <p>您可以使用<code class="codeph">RECOVER CORRUPTION LIST</code>恢复<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图中报告的所有块，也可以指定数据文件编号和块编号或表空间和数据块地址（DBA）。RMAN只能执行单个块的完全恢复。
                  </p>
                  <p>默认情况下，如果启用了闪回数据库，则RMAN会在闪回日志中搜索损坏块的良好副本。默认情况下，如果目标数据库存在于Data Guard环境中，则<code class="codeph">RECOVER BLOCK</code>命令可以自动将块从物理备用数据库检索到主数据库，反之亦然。
                  </p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-FEA4B081-D317-4180-81E6-9054E16ACA7B">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes RECOVER command blockObject parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e1654">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e1657">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1662" headers="d69128e1654 ">
                                 <p><a id="d69128e1664" class="indexterm-anchor"></a><a id="d69128e1666" class="indexterm-anchor"></a><code class="codeph">CORRUPTION LIST</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1662 d69128e1657 ">
                                 <p>恢复<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图中列出的所有物理损坏的块。阻止介质恢复可能无法修复所有列出的逻辑损坏的块。在这些情况下，备用恢复方法（如表空间时间点恢复）或删除和重新创建受影响的对象可能会修复损坏。
                                 </p>
                                 <p>该<a id="d69128e1680" class="indexterm-anchor"></a><a id="d69128e1682" class="indexterm-anchor"></a> <code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图显示Oracle数据库组件（如RMAN命令， <code class="codeph">ANALYZE</code> ，SQL查询等）标记为已损坏的块。简而言之，任何遇到过程的过程<a id="d69128e1692" class="indexterm-anchor"></a><a id="d69128e1694" class="indexterm-anchor"></a> <code class="codeph">ORA-1578</code>错误在此视图中记录块损坏。以下类型的损坏会导致向此视图添加行：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>物理腐败（有时称为媒体腐败）。数据库根本无法识别块：校验和无效，块包含全零，或块的页眉和页脚不匹配。</p>
                                    </li>
                                    <li>
                                       <p>逻辑腐败。该块具有有效的校验和，页眉和页脚匹配等，但内容在逻辑上是不一致的。</p>
                                    </li>
                                 </ul>
                                 <p>该视图不记录可以通过验证块和段之间的关系来检测的损坏，但不能通过检查单个块来检测。</p>
                                 <p><span class="bold">注意：</span>修复或检测到块已修复的任何RMAN命令都会更新<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code> 。例如，RMAN在成功阻止介质恢复结束时更新存储库。如果<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code> ， <code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B">RESTORE</a></code>或<code class="codeph"><a href="VALIDATE.html#GUID-ECE57997-40CE-4029-A434-320441D2AD1E">VALIDATE</a></code>命令检测到块不再被破坏，则它会从视图中删除已修复的块。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1733" headers="d69128e1654 ">
                                 <p><code class="codeph">DATAFILE</code> <span class="italic"><code class="codeph"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220">datafileSpec</a></code></span>       
                                 </p>
                                 <p><code class="codeph">BLOCK</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">TO</code> <span class="italic"><code class="codeph">integer</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1733 d69128e1657 ">
                                 <p>恢复数据文件中的单个数据块或数据块集。它可以从备用数据库或主数据库中复制块。<code class="codeph">TO</code>范围包括在内，因此<code class="codeph">BLOCK 10 TO BLOCK 20</code>包括块10和块20。
                                 </p>
                                 <p>当数据丢失或损坏适用于少量块而不是整个数据文件时，块介质恢复很有用。通常，在跟踪文件中的错误消息中或通过<code class="codeph"><a href="ADVISE-FAILURE.html#GUID-40985161-61A8-4C0A-9BEF-1DEECBCDF49C">ADVISE FAILURE</a></code>命令报告块损坏。块级数据丢失通常来自：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>I / O错误导致轻微数据丢失</p>
                                    </li>
                                    <li>
                                       <p>写入磁盘的内存损坏</p>
                                    </li>
                                 </ul>
                                 <p>如果未指定<span class="italic"><code class="codeph"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__I999383">recoverOptionList</a></code></span>的选项，并且在数据库上启用了闪回数据库，则<code class="codeph">RECOVER BLOCK</code>首先搜索闪回日志，然后搜索备份以获取要恢复的块的正常版本。
                                 </p>
                                 <p>在恢复完成之前，无法访问标记为介质损坏的块。</p>
                                 <p><span class="bold">注意：</span>您只能执行单个块的完全恢复。换句话说，在将所有重做应用于块之前，您无法停止恢复。
                                 </p>
                                 <p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220">datafileSpec</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1806" headers="d69128e1654 "><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span> <code class="codeph">DBA</code> <span class="italic"><code class="codeph">integer</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1806 d69128e1657 ">
                                 <p>指定包含损坏块的表空间名称或编号以及损坏块的数据块地址（DBA）。您只能在损坏的块上执行块介质恢复。</p>
                                 <p><span class="bold">注意：</span>无法恢复数据文件头块（块1）。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1828" headers="d69128e1654 ">
                                 <p><code class="codeph">TABLESPACE</code> <span class="italic"><code class="codeph">pdb-name</code></span> <code class="codeph">:</code> <span class="italic"><code class="codeph">tablespace_name</code></span> <code class="codeph">DBA</code> <span class="italic"><code class="codeph">integer</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1828 d69128e1657 ">
                                 <p>PDB中表空间的名称。多个PDB可以具有相同名称的表空间。名称前面的限定符唯一标识表空间。 <span class="italic"><code class="codeph">pdb-name</code></span>是PDB的名称。</p>
                                 <p>有关一般信息，请参阅前面的<code class="codeph">TABLESPACE</code>描述。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__I999383"><span class="bold"><span class="italic">recoverOptionList</span></span></p>
                  <p>本小节规定了各种恢复选项。有关语法图，请参阅<span class="italic"><a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDIIEGB">recoverOptionList :: =</a></span> 。
                  </p>
                  <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-B6882697-4195-4B85-8FB3-E38351AF4A86">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes RECOVER command recoverOptionList parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d69128e1878">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d69128e1881">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1886" headers="d69128e1878 ">
                                 <p><code class="codeph">ALLOW</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">CORRUPTION</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1886 d69128e1881 ">
                                 <p>指定允许恢复继续时可以容忍的损坏块数。您可以在重做日志损坏的情况下设置此参数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1901" headers="d69128e1878 ">
                                 <p><code class="codeph">ARCHIVELOG TAG</code> <span class="italic"><code class="codeph">tag_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1901 d69128e1881 ">
                                 <p>指定在恢复期间使用的归档日志备份的标记。标记名称不区分大小写并以全部大写形式显示。如果标记的备份不包含用于恢复的所有必需的归档重做日志文件，则RMAN会根据需要使用日志或增量备份。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1913" headers="d69128e1878 "><code class="codeph">AUXILIARY DESTINATION</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">location</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d69128e1913 d69128e1881 ">
                                 <p>如果未明确指定单个文件的其他位置，则指定在TSPITR期间创建辅助集数据文件，控制文件和联机重做日志的位置。</p>
                                 <p>如果没有为TSPITR指定<code class="codeph">AUXILIARY DESTINATION</code> ，则必须在使用<code class="codeph">UNTIL</code>子句执行<code class="codeph">RECOVER TABLESPACE</code>之前指定各个辅助集数据文件，控制文件和联机重做日志的命名。否则，TSPITR失败。
                                 </p>
                                 <p>在执行PDB的时间点恢复时，如果未指定辅助目标，则将快速恢复区域用作辅助目标。如果未指定辅助目标且未配置快速恢复区域，则PDB的恢复将失败。</p>
                                 <p><span class="bold">另请参阅：</span> “ <a href="../bradv/performing-rman-tspitr.html#BRADV009" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”中</span></a>有关TSPITR的章节，以获取有关辅助目标的更多详细信息</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1950" headers="d69128e1878 ">
                                 <p><code class="codeph">检查逻辑</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1950 d69128e1881 ">
                                 <p>测试通过物理损坏检查逻辑损坏的数据和索引块，例如，行片段或索引条目的损坏。如果RMAN发现逻辑损坏，则它会在<code class="codeph">alert.log</code>和服务器会话跟踪文件中记录该块。
                                 </p>
                                 <p><code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">MAXCORRUPT</code>设置表示文件允许的物理和逻辑损坏总数。默认情况下， <code class="codeph">MAXCORRUPT</code>为<code class="codeph">0</code> ，因此如果存在任何损坏的块，则介质恢复将失败。如果允许恢复包括损坏的块，则将<code class="codeph">MAXCORRUPT</code>设置为导致介质恢复失败的最小数量的损坏块。例如，要容忍一个损坏的块，请将<code class="codeph">MAXCORRUPT</code>设置为1。
                                 </p>
                                 <p>如果为文件检测到的物理和逻辑损坏总数小于其<code class="codeph">MAXCORRUPT</code>设置，则RMAN命令完成，数据库将使用损坏的块范围填充<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code> 。否则，该命令将终止，而不会填充<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e1995" headers="d69128e1878 ">
                                 <p><code class="codeph">DATAPUMP DESTINATION</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">datapump_destination</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e1995 d69128e1881 ">
                                 <p>指定数据泵导出转储文件的位置，该文件包含从RMAN备份恢复的表或表分区。</p>
                                 <p>如果未指定数据泵目标，RMAN将在<code class="codeph">AUXILARY DESTINATION</code>指示的目标中创建导出转储文件。如果未指定辅助目标，则RMAN会在特定于操作系统的默认位置创建转储文件。在Linux上，默认位置是<code class="codeph">$ORACLE_HOME/dbs</code> 。在Windows上，默认位置为<code class="codeph">%ORACLE_HOME\database</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2022" headers="d69128e1878 ">
                                 <p><code class="codeph">删除ARCHIVELOG</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2022 d69128e1881 ">
                                 <p>删除从不再需要的备份或副本还原的归档重做日志文件。在<code class="codeph">RESTORE</code>命令启动之前，RMAN不会删除磁盘上存档的重做日志文件。如果未指定<code class="codeph">MAXSIZE</code> ，则RMAN会在应用时删除已还原的归档重做日志文件。
                                 </p>
                                 <p><span class="bold">注意：</span>如果归档的重做日志文件还原到快速恢复区域，则默认情况下会启用<code class="codeph">DELETE ARCHIVELOG</code>选项。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2043" headers="d69128e1878 ">
                                 <p><code class="codeph">MAXSIZE</code> <span class="italic"><code class="codeph">sizeSpec</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2043 d69128e1881 ">
                                 <p>对于还原的归档重做日志文件，不要使用大于<span class="italic"><code class="codeph">sizeSpec</code></span>的磁盘空间量。如果恢复需要恢复大于<code class="codeph">MAXSIZE</code>值的日志，则RMAN会报告错误，指示您必须增加<code class="codeph">MAXSIZE</code>值。如果<code class="codeph">MAXSIZE</code>小于包含日志的备份集，则RMAN必须多次读取备份集以提取日志。在这种情况下，RMAN发出警告以增加<code class="codeph">MAXSIZE</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2071" headers="d69128e1878 ">
                                 <p><code class="codeph">DUMP FILE</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2071 d69128e1881 ">
                                 <p>指定包含已恢复表或表分区的数据泵导出转储文件的名称。如果未指定转储文件的名称，RMAN将根据目标数据库的操作系统分配默认名称。默认名称为<code class="codeph">tspitr_</code> <span class="italic"><code class="codeph">SID-of-clone_n.dmp</code></span> ，其中<span class="italic"><code class="codeph">SID-of-clone</code></span>是RMAN用于恢复的辅助数据库的Oracle SID， <span class="italic"><code class="codeph">n</code></span>是随机生成的数字。转储文件在<code class="codeph">DATAPUMP DESTINATION</code>指定的位置创建。</p>
                                 <p>如果<code class="codeph">DATAPUMP DESTINATION</code>包含具有在<code class="codeph">DUMP FILE</code>指定的名称的<code class="codeph">DUMP FILE</code> ，则恢复过程将失败。
                                 </p>
                                 <p><span class="bold">另请参见：</span> <a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBHIFDB">DATAPUMP DESTINATION</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2118" headers="d69128e1878 ">
                                 <p><code class="codeph">排除闪回日志</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2118 d69128e1881 ">
                                 <p>不搜索闪回日志以查找要还原的块。默认情况下，如果启用了闪回数据库，RMAN将搜索闪回日志。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2126" headers="d69128e1878 ">
                                 <p><code class="codeph">排除待机</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2126 d69128e1881 ">
                                 <p>不搜索物理备用数据库以查找要还原的块。默认情况下，在Data Guard环境中，RMAN从物理备用数据库中搜索块。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2134" headers="d69128e1878 ">
                                 <p><code class="codeph">来自BACKUPSET</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2134 d69128e1881 ">
                                 <p>指定仅还原备份集。仅在执行块介质恢复时支持此子句。<code class="codeph">RECOVER ...BLOCK</code>命令用于执行块介质恢复。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2146" headers="d69128e1878 ">
                                 <p><code class="codeph">来自DATAFILECOPY</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2146 d69128e1881 ">
                                 <p>仅还原数据文件映像副本。</p>
                                 <p>仅在执行块介质恢复时支持此子句。<code class="codeph">RECOVER ...</code><code class="codeph">BLOCK</code>命令用于执行块介质恢复。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2161" headers="d69128e1878 "><code class="codeph">从SPARSE</code></td>
                              <td align="left" valign="top" width="71%" headers="d69128e2161 d69128e1881 ">
                                 <p></p>
                                 <p>从选定的稀疏备份还原数据文件后，从存档日志和重做日志中恢复数据文件。RMAN首先从稀疏备份还原数据文件，然后恢复数据文件。</p>
                                 <p>要使用<code class="codeph">FROM SPARSE</code>子句执行恢复，要还原的稀疏数据库的<code class="codeph">COMPATIBLE</code>初始化参数必须为12.2或更高。
                                 </p>
                                 <p><span class="bold">注意：</span>此子句仅在执行时间点恢复时使用。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2181" headers="d69128e1878 "><code class="codeph">来自NONSPARSE</code></td>
                              <td align="left" valign="top" width="71%" headers="d69128e2181 d69128e1881 ">
                                 <p></p>
                                 <p>对指定的非稀疏数据库执行传统的完全恢复。首先从非稀疏备份还原数据文件，然后恢复。要使用<code class="codeph">FROM NONSPARSE</code>子句执行时间点恢复，要还原的稀疏数据库的<code class="codeph">COMPATIBLE</code>初始化参数必须设置为12.2或更高。数据文件首先从非稀疏备份还原，然后恢复。
                                 </p>
                                 <p><span class="bold">注意：</span>此子句仅在执行时间点恢复时使用。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2199" headers="d69128e1878 ">
                                 <p><code class="codeph">FROM PLATFORM</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">platform</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2199 d69128e1881 ">
                                 <p>指定创建跨平台备份的源平台的名称。指定的平台名称必须与跨平台备份标头中存储的平台标识符匹配。</p>
                                 <p>在目标数据库上执行转换时，此子句是必需的。如果在源数据库上执行转换（通过使用<code class="codeph">BACKUP</code>命令中的<code class="codeph">TO PLATFORM</code>子句），则此子句是可选的。省略此子句时，仍可以通过使用<code class="codeph">FROM BACKUPSET</code>子句指定<code class="codeph">FOREIGN DATAFILECOPY</code>子句来恢复跨平台备份。
                                 </p>
                                 <p></p>
                                 <p>要通过网络连接到远程数据库来执行跨平台表空间传输，请使用带有<code class="codeph">FROM SERVICE</code>子句的<code class="codeph">FROM PLATFORM</code>子句。然后，RMAN在源数据库上创建所需的备份集，将它们传输到目标数据库，然后在目标上还原它们。
                                 </p>
                                 <p>请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAIFDBG">FOREIGN DATAFILECOPY'文件名'</a> 。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../bradv/rman-transporting-data-across-platforms.html#BRADV-GUID-65AADCB6-CC9A-4229-9AB8-805C37E4471F" target="_blank"><span><cite>Oracle数据库备份和恢复用户指南</cite></span></a> ，以获取有关源和目标平台转换的更多信息。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2253" headers="d69128e1878 ">
                                 <p><code class="codeph">来自PREPLUGIN</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2253 d69128e1881 ">
                                 <p>使用预刷新增量备份和预刷新存档重做日志备份来恢复PDB。 PDB可以是插入当前CDB的源非CDB或PDB。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2261" headers="d69128e1878 ">
                                 <p><code class="codeph">FROM SERVICE</code> <span class="italic"><code class="codeph">service_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2261 d69128e1881 ">
                                 <p>使用通过网络从远程数据库传输的备份集恢复数据文件。 <span class="italic"><code class="codeph">service_name</code></span>指定远程数据库的服务名称。
                                 </p>
                                 <p>请参阅<span class="q">“ <a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B__CFAFGIJJ">使用远程主机中的文件还原数据文件和控制文件</a> ”</span> 。
                                 </p>
                                 <p></p>
                                 <p>要通过网络连接到远程数据库来执行跨平台表空间传输，请使用带有<code class="codeph">FROM SERVICE</code>子句的<code class="codeph">FROM PLATFORM</code>子句。RMAN连接到源数据库，创建所需的备份，将它们传输到目标，然后还原目标上的备份。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2292" headers="d69128e1878 "><code class="codeph">非封闭的块</code></td>
                              <td align="left" valign="top" width="71%" headers="d69128e2292 d69128e1881 ">
                                 <p>将恢复扩展到<code class="codeph">V$NONLOGGED_BLOCK</code>视图中列出的非记录块。RMAN首先执行验证以确定未记录的块范围，然后使用这些范围来执行<span class="italic">dbObject</span>子句中指定的对象的恢复。在Oracle Database 11.2和更早版本中， <code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图中提供了有关非记录块的信息。
                                 </p>
                                 <p>在物理备用数据库上运行时， <code class="codeph">RECOVER</code>从主数据库中提取数据块。在主数据库上运行时，将从最合适的备用数据库中提取数据块。在这种情况下，必须安装主数据库。
                                 </p>
                                 <p>在使用此选项发出<code class="codeph">RECOVER</code>命令之前，必须停止备用恢复。
                                 </p>
                                 <p>如果目标数据库未使用自动内存管理且未设置<code class="codeph">SGA_TARGET</code>参数，则必须为<code class="codeph">DATA_TRANSFER_CACHE_SIZE</code>初始化参数指定值。
                                 </p>
                                 <p></p>
                                 <p><span class="bold">另请参阅：</span> <a href="../sbydb/creating-oracle-data-guard-physical-standby.html#GUID-AE2B1237-57A1-4745-A04C-4246A831A963" target="_blank"><span><span><cite>Oracle Data Guard概念和管理</cite></span></span></a></p>
                                 <p><span class="bold">另请参阅：</span> <a href="../admin/managing-memory.html#ADMIN-GUID-0E201F66-D280-472A-AD80-20AB8F7E9C01" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></p>
                                 <p><span class="bold">另请参见：</span> <a href="../refrn/DATA_TRANSFER_CACHE_SIZE.html#REFRN-GUID-322093B7-1673-490D-8A1A-5F461D7897DD" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2355" headers="d69128e1878 ">
                                 <p><code class="codeph">FROM TAG</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">tag_name</code></span> <code class="codeph">'</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2355 d69128e1881 ">
                                 <p>指定在恢复期间使用的增量备份的标记。如果标记的备份不包含恢复所需的所有必要增量，则RMAN会根据需要使用日志或增量备份。标记名称不区分大小写并以全部大写形式显示。</p>
                                 <p><span class="bold">另请参阅：</span> <code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>以了解如何将标记应用于双工备份集的单个副本，以及了解备份标记的默认文件名格式</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2380" headers="d69128e1878 ">
                                 <p><code class="codeph">NOPARALLEL</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2380 d69128e1881 ">
                                 <p>不并行执行介质恢复。并行执行是<code class="codeph">RECOVER</code>的默认执行（请参阅<code class="codeph">RECOVER</code>的说明<code class="codeph">RECOVER ...PARALLEL</code>选项）。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2394" headers="d69128e1878 ">
                                 <p><code class="codeph">NOREDO</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2394 d69128e1881 ">
                                 <p>在恢复期间禁止重做日志的应用。仅应用增量备份。</p>
                                 <p>此选项的一个用途是使用增量备份来更新<code class="codeph">NOARCHIVELOG</code>数据库的完整备份（请参阅<a href="RECOVER.html#GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDHFBFI">示例3-6</a> ）。如果没有重做日志，则需要<code class="codeph">NOREDO</code>选项。如果在恢复<code class="codeph">NOARCHIVELOG</code>数据库时未指定<code class="codeph">NOREDO</code> ，则RMAN将终止恢复并发出错误。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph">NOARCHIVELOG</code>数据库的增量备份只能在一致关闭后进行。
                                 </p>
                                 <p>另一个用途是更新备用数据库或重复数据库。使用<code class="codeph">BACKUP INCREMENTAL FROM SCN</code>命令创建的增量备份可以应用于备用数据库或重复数据库。<a href="../sbydb/using-RMAN-in-oracle-data-guard-configurations.html#SBYDB04700" target="_blank"><span class="italic">Oracle Data Guard概念和管理中</span></a>描述了备用数据库过程<a href="../sbydb/using-RMAN-in-oracle-data-guard-configurations.html#SBYDB04700" target="_blank">。</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2435" headers="d69128e1878 ">
                                 <p><code class="codeph">NOTABLEIMPORT</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2435 d69128e1881 ">
                                 <p>指定RMAN不得将已恢复的表或表分区导入目标数据库。</p>
                                 <p>已恢复的对象存储在使用<code class="codeph">DUMP FILE</code>和<code class="codeph" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__BGBHIFDB">DATAPUMP DESTINATION</code>指定的数据泵导出转储文件中。如果省略这些子句，则会在默认位置创建导出转储文件。
                                 </p>
                                 <p>必要时，需要将导出转储文件中包含的表或表分区显式导入目标数据库。使用Data Pump导入实用程序导入已恢复的对象。</p>
                                 <p><span class="bold">注意：</span>您不能将<code class="codeph">NOTABLEIMPORT</code>与<code class="codeph">REMAP TABLE</code>或<code class="codeph">REMAP TABLESPACE</code>子句一起使用。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2467" headers="d69128e1878 ">
                                 <p><code class="codeph">平行</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2467 d69128e1881 ">
                                 <p>指定并行恢复（默认）。</p>
                                 <p>默认情况下，数据库使用并行介质恢复来提高介质恢复前滚阶段的性能。要覆盖执行并行恢复的默认行为，请使用带有<code class="codeph">NOPARALLEL</code>选项的<code class="codeph">RECOVER</code>或<code class="codeph">RECOVER PARALLEL 0</code> 。
                                 </p>
                                 <p>在并行介质恢复中，数据库使用“分工”方法在向前滚动时将不同的进程分配给不同的数据块，从而使操作更有效。进程数源自<a id="d69128e2487" class="indexterm-anchor"></a><a id="d69128e2489" class="indexterm-anchor"></a> <code class="codeph">CPU_COUNT</code>初始化参数，默认情况下等于系统上的CPU数。例如，如果在<code class="codeph">CPU_COUNT</code>为4的系统上执行并行恢复，并且只恢复了一个数据文件，则四个生成的进程从数据文件中读取块并应用重做。
                                 </p>
                                 <p>通常，恢复是对数据块的读取和写入进行I / O绑定。块级别的并行性只有在增加总I / O时才有助于恢复性能，例如，绕过操作系统对异步I / O的限制。具有高效异步I / O的系统几乎没有从并行介质恢复中获益。</p>
                                 <p><span class="bold">注意：</span> <a id="d69128e2505" class="indexterm-anchor"></a><a id="d69128e2507" class="indexterm-anchor"></a> <code class="codeph">RECOVERY_PARALLELISM</code>初始化参数仅控制实例或崩溃恢复。媒体恢复不受<code class="codeph">RECOVERY_PARALLELISM</code>使用的值的影响。</p>
                                 <p><span class="bold">另请参见：</span> <a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>有关<code class="codeph">CREATE TABLE</code>的讨论中的<code class="codeph">PARALLEL</code>子句的说明</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2532" headers="d69128e1878 ">
                                 <p><code class="codeph">   </code><span class="italic"><code class="codeph">integer</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2532 d69128e1881 ">
                                 <p>指定<span class="italic"><code class="codeph">integer</code></span>并行度。
                                 </p>
                                 <p>每个并行线程可以使用一个或两个并行执行服务器。可选的。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2549" headers="d69128e1878 ">
                                 <p><code class="codeph">FILE_NAME_CONVERT</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2549 d69128e1881 ">
                                 <p></p>
                                 <p>指定在将PDB跨平台传输到目标CDB期间，源CDB上的数据库文件名如何映射到目标CDB上的相应文件。</p>
                                 <p>指定用于转换文件名的字符串对。您可以根据需要使用多对源和目标替换字符串。例如，您可以将字符串模式设置为以下值：</p><pre class="pre codeblock"><code>FILE_NAME_CONVERT =（'str1'，'str2'，'str3'，'str4'...）</code></pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2562" headers="d69128e1878 ">
                                 <p><code class="codeph">REMAP TABLE</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2562 d69128e1881 ">
                                 <p></p>
                                 <p>重命名目标数据库中的已恢复表或表分区。</p>
                                 <p>可以将恢复的表或表分区映射到与它们最初存在的目标数据库模式不同的目标数据库模式。将表或表分区恢复到不同的模式时，可以重命名对象或保留原始对象名。您可以将所有指定的对象导入到同一目标模式或不同的目标模式中。</p>
                                 <p>单个<code class="codeph">RECOVER</code>命令可以包含属于不同源模式的表和表分区。
                                 </p>
                                 <p>恢复分区表时，如果仅重新映射表中的某些分区，则所有表分区都将作为单独的表导入。使用<code class="codeph">REMAP TABLE</code>选项时，不会导入命名约束和索引。
                                 </p>
                                 <p><span class="bold"><span class="italic">注意：</span></span>您无法重新映射<code class="codeph">RECOVER</code>命令的<code class="codeph">TABLE</code>子句中未列出的表或分区。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2594" headers="d69128e1878 ">
                                 <p><code class="codeph">REMAP TABLESPACE</code> <span class="italic"><code class="codeph">source_tablespace_name:target_tablespace_name</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2594 d69128e1881 ">
                                 <p>将恢复的表或表分区导入到与源数据库中所属的表空间不同的表空间中。</p>
                                 <p><code class="codeph">source_tablespace_name</code>指的是表空间，其中表或分区驻留在源数据库中，而<code class="codeph">target_tablespace_name</code>指的是必须将表或表分区导入其中的表空间的名称。
                                 </p>
                                 <p>使用REMAP选项时，不会导入命名约束和索引。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2615" headers="d69128e1878 ">
                                 <p><span class="italic"><code class="codeph">sizeSpec</code></span> <code class="codeph">SECTION SIZE</code> <span class="italic"><code class="codeph">sizeSpec</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2615 d69128e1881 ">
                                 <p>通过将每个文件划分为指定的节大小来并行化验证。</p>
                                 <p>请参见<span class="q">“ <a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50__BGBJCAHI">SECTION SIZE sizeSpec</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2633" headers="d69128e1878 ">
                                 <p><code class="codeph">跳过离线</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2633 d69128e1881 ">
                                 <p></p>
                                 <p>在恢复期间跳过脱机数据文件。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2642" headers="d69128e1878 ">
                                 <p><code class="codeph">跳过READONLY</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2642 d69128e1881 ">
                                 <p>忽略恢复中的只读文件。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2650" headers="d69128e1878 ">
                                 <p><code class="codeph">测试</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2650 d69128e1881 ">
                                 <p>启动试验恢复。</p>
                                 <p>如果正常的恢复过程遇到问题，则试用恢复很有用。它使数据库能够预览重做流以检测可能的问题。试用恢复以类似于正常恢复的方式应用重做，但它不会将更改写入磁盘，并在试用恢复结束时回滚其更改。</p>
                                 <p><span class="bold">注意：</span>仅当您已恢复自上次<code class="codeph">RESETLOGS</code>操作以来所执行的备份时，才能使用此子句。否则，数据库将返回错误。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2667" headers="d69128e1878 "><code class="codeph">UNDO TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d69128e2667 d69128e1881 ">
                                 <p>指定在目标时间具有还原段的表空间列表。仅适用于<code class="codeph">RECOVER TABLESPACE</code> 。</p>
                                 <p>在TSPITR期间，RMAN需要有关哪些表空间在TSPITR目标时间具有还原段的信息。如果使用此信息，通常可在恢复目录中使用此信息。</p>
                                 <p>如果没有恢复目录，或者如果在恢复目录中找不到该信息，则如果在目标时间具有还原段的表空间集合等于具有还原段的表空间集合，则RMAN继续运行。如果此假设不正确，则TSPITR会因错误而失败。在这种情况下，您可以使用<code class="codeph">UNDO TABLESPACE</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2688" headers="d69128e1878 ">
                                 <p><code class="codeph">使用[COMPRESSED] BACKUPSET</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2688 d69128e1881 ">
                                 <p>指定正在恢复的文件必须作为压缩备份集从远程数据库传输，如果<code class="codeph">USING COMPRESSED BACKUPSET</code> 。默认情况下，RMAN将文件作为备份集传输。因此，即使您不使用<code class="codeph">USING BACKUPSET</code>子句，文件也会作为备份集传输。来自RMAN配置的压缩算法用于执行压缩。您可以通过在<code class="codeph">RECOVER</code>命令之前运行<code class="codeph">SET COMPRESSION ALGORITHM</code>来使用不同的压缩算法。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2709" headers="d69128e1878 ">
                                 <p><code class="codeph">USING</code> <code class="codeph"><span class="codeinlineitalic">'filename'</span></code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2709 d69128e1881 ">
                                 <p></p>
                                 <p>执行PDB跨平台传输到不同的目标CDB。包含将PDB插入目标CDB所需的元数据的XML文件使用<code class="codeph"><span class="codeinlineitalic">filename</span></code>指定。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d69128e2726" headers="d69128e1878 ">
                                 <p><code class="codeph">确认标题</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d69128e2726 d69128e1881 ">
                                 <p>报告和验证 - 但不还原 -  RMAN可用于还原恢复所需文件的备份。</p>
                                 <p>使用<code class="codeph">VALIDATE HEADER</code>运行<code class="codeph">RECOVER</code>时，RMAN执行与指定<code class="codeph">RESTORE ...</code>时相同的功能<code class="codeph">RESTORE ...</code> <code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B__CHDFAJFI">PREVIEW</a></code>选项。但是，除了列出还原和恢复所需的文件之外，RMAN还会验证备份文件头，以确定磁盘上或介质管理目录中的文件是否与RMAN存储库中的元数据相对应。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <code class="codeph">RESTORE ...</code>的说明<code class="codeph">RESTORE ...</code> <code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B__CHDFAJFI">PREVIEW</a></code>选项</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAGEBEI">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-9CC03609-50AD-4DA6-9E59-0415AC566B12"><span class="italic">remapTableList</span></p>
                  <p>本小节指定必须恢复的表或表分区。</p>
                  <p></p>
               </div>
               <!-- class="section" -->
               <div class="tblformalwide" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-170D876A-CABB-4A02-BC24-C35E8DE2C371">
                  <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Element descriptions for RECOVER remapTableList" frame="hsides" rules="rows">
                     <thead>
                        <tr align="left" valign="top">
                           <th align="left" valign="bottom" width="29%" id="d69128e2774">语法元素</th>
                           <th align="left" valign="bottom" width="71%" id="d69128e2777">描述</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="29%" id="d69128e2782" headers="d69128e2774 ">
                              <p><code class="codeph">old_schema</code></p>
                           </td>
                           <td align="left" valign="top" width="71%" headers="d69128e2782 d69128e2777 ">
                              <p>包含要恢复的表或表分区的模式的名称。</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="29%" id="d69128e2790" headers="d69128e2774 ">
                              <p><code class="codeph">old_tablename</code></p>
                           </td>
                           <td align="left" valign="top" width="71%" headers="d69128e2790 d69128e2777 ">
                              <p>必须恢复的表的名称。</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="29%" id="d69128e2798" headers="d69128e2774 ">
                              <p><code class="codeph">划分</code></p>
                           </td>
                           <td align="left" valign="top" width="71%" headers="d69128e2798 d69128e2777 ">
                              <p>必须恢复的表分区的名称。</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="29%" id="d69128e2806" headers="d69128e2774 ">
                              <p><code class="codeph">new_schema</code></p>
                           </td>
                           <td align="left" valign="top" width="71%" headers="d69128e2806 d69128e2777 ">
                              <p>必须恢复表和表分区的模式的名称。</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="29%" id="d69128e2814" headers="d69128e2774 ">
                              <p><code class="codeph">new_tablename</code></p>
                           </td>
                           <td align="left" valign="top" width="71%" headers="d69128e2814 d69128e2777 ">
                              <p>目标数据库中已恢复的表或表分区的名称。</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <!-- class="inftblhruleinformal" -->
               <div class="section">
                  <p class="subhead1" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-A9CFEB9A-926F-4D11-AF9D-39ACD242006C">例子</p>
               </div>
               <!-- class="section" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-BA087714-AD22-48A1-AA29-8D55298AFE99">
                  <p class="titleinexample">示例3-1在开放式数据库中恢复表空间</p>
                  <p><a id="d69128e2828" class="indexterm-anchor"></a><a id="d69128e2830" class="indexterm-anchor"></a>假设包含表空间<code class="codeph">users</code>数据文件的磁盘由于硬件错误而变得不可用，但在几分钟后就会修复。此示例使表空间<code class="codeph">users</code>脱机，使用自动通道将数据文件还原到其默认位置并恢复它们（删除从磁带还原的日志），然后使表空间重新联机。
                  </p><pre class="oac_no_warn" dir="ltr">ALTER TABLESPACE用户立即离线; RESTORE TABLESPACE用户; RECOVER TABLESPACE用户DELETE ARCHIVELOG MAXSIZE 2M; ALTER TABLESPACE用户在线;</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-A03F2C8D-C33B-4E77-8D25-F5DCE6646BB6">
                  <p class="titleinexample">示例3-2恢复还原到新位置的数据文件</p>
                  <p><a id="d69128e2845" class="indexterm-anchor"></a>此示例使用预配置的磁盘通道并手动分配一个介质管理通道以使用磁盘上的数据文件副本和磁带上的备份，并将表空间<code class="codeph">USERS</code>的数据文件还原到其他位置。
                  </p><pre class="oac_no_warn" dir="ltr">RUN {ALLOCATE CHANNEL ch1 DEVICE TYPE sbt; ALTER TABLESPACE用户立即离线;为数据文件设置NEWNAME'/disk1/oradata/prod/users01.dbf'TO'/disk2/users01.dbf'; RESTORE TABLESPACE用户; SWITCH DATAFILE ALL; RECOVER TABLESPACE用户; ALTER TABLESPACE用户在线; }</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDGFJAD">
                  <p class="titleinexample">示例3-3使用备份控制文件和恢复目录执行DBPITR</p>
                  <p><a id="d69128e2859" class="indexterm-anchor"></a>假设由于磁盘故障导致所有数据文件，所有控制文件和归档重做日志58丢失。还假设您没有增量备份。您必须使用可用的归档重做日志文件恢复数据库。您不需要还原表空间<code class="codeph">TOOLS</code>因为它在最近的备份之前是只读的。将RMAN连接到目标数据库和恢复目录后，发出以下命令：</p><pre class="oac_no_warn" dir="ltr">STARTUP FORCE NOMOUNT;运行{SET UNTIL SEQUENCE 40 THREAD 1; ＃恢复数据库，直到日志序列40 RESTORE CONTROLFILE; ALTER DATABASE MOUNT; RESTORE DATABASE SKIP TABLESPACE工具; RECOVER DATABASE SKIP TABLESPACE工具; ALTER DATABASE OPEN RESETLOGS;</pre><p>RMAN自动跳过数据文件<code class="codeph">8</code>的恢复和恢复，数据文件<code class="codeph">8</code>是只读表空间中的数据文件。以下部分示例输出表示跳过：</p><pre class="oac_no_warn" dir="ltr">使用通道ORA_DISK_1分配通道：ORA_SBT_TAPE_1通道ORA_SBT_TAPE_1：SID = 104设备类型= SBT_TAPE通道ORA_SBT_TAPE_1：Oracle Secure Backup跳过数据文件8;已恢复到文件/disk1/oradata/prod/tools01.dbf通道ORA_DISK_1：启动数据文件备份集还原。。。在19-FEB-13完成恢复使用通道ORA_DISK_1在19-FEB-13开始恢复，使用通道ORA_SBT_TAPE_1数据文件8未处理，因为文件是只读的</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDFCFJI">
                  <p class="titleinexample">示例3-4逐步更新备份</p>
                  <p><a id="d69128e2881" class="indexterm-anchor"></a><a id="d69128e2885" class="indexterm-anchor"></a>通过逐步更新备份，可以避免对数据文件进行完整映像副本备份的开销，同时还可以最大限度地减少介质恢复数据库所需的时间。此示例使您可以恢复到前一周内的任何SCN，但可以避免必须应用一天以上的重做。
                  </p>
                  <p>假设您每天运行以下脚本。首次执行时，该脚本使用指定的标记在磁盘上创建数据库的映像副本备份。在第二次到第七次执行时，脚本会创建数据库的1级差异备份。在第八次和所有后续执行中，RMAN将1级增量应用于7天前制作的数据文件副本，然后使用前一天的更改进行新的1级备份。</p><pre class="oac_no_warn" dir="ltr">运行{TRATVER COPY OF DATABASE with TAG'incr_update'ENTIL TIME'SYSDATE  -  7';用TAG'incr_update'数据库恢复补充级别1以恢复复制; }</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDEAEGH">
                  <p class="titleinexample">示例3-5从备用数据库上的控制文件丢失中恢复</p>
                  <p><a id="d69128e2898" class="indexterm-anchor"></a>假设由于介质故障而导致备用数据库<code class="codeph">dgprod3</code>控制文件丢失。主数据库和备用数据库共享SBT存储。磁带上存在主数据库控制文件的备份。
                  </p>
                  <p>启动RMAN客户端并连接到<code class="codeph">dgprod3</code>作为<code class="codeph">TARGET</code>并连接到恢复目录。以下RMAN命令还原备用数据库可用的控制文件，将文件名更新为磁盘上的现有文件，并恢复备用数据库：</p><pre class="oac_no_warn" dir="ltr">RESTORE CONTROLFILE; ALTER DATABASE MOUNT;恢复数据库;</pre><p>然后，您可以在备用数据库上启动重做应用。</p>
               </div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CHDHFBFI">
                  <p class="titleinexample">示例3-6恢复NOARCHIVELOG数据库</p>
                  <p><a id="d69128e2922" class="indexterm-anchor"></a><a id="d69128e2926" class="indexterm-anchor"></a><a id="d69128e2930" class="indexterm-anchor"></a>您可以通过应用增量备份对在<code class="codeph">NOARCHIVELOG</code>模式下运行的数据库执行有限的恢复恢复。增量备份必须一致，就像在<code class="codeph">NOARCHIVELOG</code>模式下运行的数据库的所有备份一样，因此在打开数据库时无法备份数据库。
                  </p>
                  <p>假设您使用恢复目录在<code class="codeph">NOARCHIVELOG</code>模式下运行数据库<code class="codeph">prod</code> 。你一直关闭数据库，使数据库的0级备份<code class="codeph">prod</code>到磁带上周日下午。您始终关闭数据库，并在星期三和星期五凌晨3:00对磁带进行1级差异增量备份。
                  </p>
                  <p>星期六，媒体故障会破坏一半的数据文件和所有在线重做日志。由于联机日志丢失，因此必须在<code class="codeph">RECOVER</code>命令中指定<code class="codeph">NOREDO</code>选项。否则，RMAN在应用星期五增量备份后搜索重做日志，并在找不到它们时发出错误消息。
                  </p>
                  <p>将RMAN连接到<code class="codeph">prod</code>和目录数据库后，恢复如下：</p><pre class="oac_no_warn" dir="ltr">STARTUP FORCE NOMOUNT; RESTORE CONTROLFILE; ＃从一致备份恢复控制文件ALTER DATABASE MOUNT; RESTORE DATABASE; ＃从一致备份恢复数据文件RECOVER DATABASE NOREDO; ＃指定NOREDO，因为联机重做日志丢失了ALTER DATABASE OPEN RESETLOGS;</pre><p>恢复的数据库仅反映星期五增量备份时的更改。由于没有归档的重做日志文件，因此无法恢复增量备份后所做的更改。</p>
               </div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-A154A3CC-90CE-4DE1-AF19-54D705893DA6">
                  <p class="titleinexample">示例3-7恢复数据库中的所有块损坏</p>
                  <p>此示例运行备份验证以填充<code class="codeph">V$DATABASE_BLOCK_CORRUPTION</code>视图，然后恢复视图中记录的任何损坏块。两个命令都包含示例输出。
                  </p><pre class="oac_no_warn" dir="ltr">RMAN&gt;验证<span class="bold">数据库;</span>使用通道ORA_DISK_1通道ORA_DISK_1在19-FEB-13开始验证：开始验证数据文件通道ORA_DISK_1：指定用于验证的数据文件。。。数据文件列表=================文件状态标记损坏空块阻止检查高SCN ---- ------ ---------- ---- ------------ --------------- ---------- 1 FAILED 0 4070 57600 555975文件名： /disk1/oradata/prod/system01.dbf块类型块处理失败块---------- -------------- ---------- ------数据1 41550索引0 7677其他0 4303。。。RMAN&gt; <span class="bold">恢复腐败清单;</span>使用通道ORA_DISK_1分配的通道在19-FEB-13开始恢复：ORA_SBT_TAPE_1通道ORA_SBT_TAPE_1：SID = 104设备类型= SBT_TAPE通道ORA_SBT_TAPE_1：Oracle Secure Backup搜索块图像的闪回日志，直到SCN 547548完成闪回日志搜索，恢复1块启动媒体恢复介质恢复完成，已用时间：00：00：03在19-FEB-13完成恢复</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__CFAFEEDH">
                  <p class="titleinexample">示例3-8从备份中恢复表分区</p>
                  <p>此示例将表<code class="codeph">SALES</code>的分区<code class="codeph">sales_2009</code>和<code class="codeph">sales_2010</code>恢复到目标数据库的SCN为34582的时间。在源数据库中，表由架构<code class="codeph">SH</code>拥有。将这些分区导入目标数据库时，会将分区创建为名为<code class="codeph">historic_sales_2009</code>和<code class="codeph">historic_sales_2010</code>表。
                  </p><pre class="oac_no_warn" dir="ltr">RECOVER TABLE SH.SALES：SALES_2009，SH.SALES：SALES_2010 UNTIL SCN 34582 AUXILIARY DESTINATION'/ tmp / oracle / recover'REMAP TABLE'SH'。'SALES'：'SALES_2009'：'HISTORIC_SALES_2009'，'SH'。'SALES'： 'SALES_2010'： 'HISTORIC_SALES_2010';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-9C3F590D-6BC1-481C-BA17-C6F8B8432D2E">
                  <p class="titleinexample">示例3-9将表恢复到指定的日志序列并重命名表</p>
                  <p>此示例使用辅助实例将表<code class="codeph">EMP</code>从<code class="codeph">SCOTT</code>模式恢复到数据库的日志序列号为5466的时间。恢复<code class="codeph">EMP</code>表后，使用名称<code class="codeph">MY_EMP</code>将其导入目标数据库。</p><pre class="oac_no_warn" dir="ltr">RECOVER TABLE SCOTT.EMP直到序列5466 AUXILARY DESTINATION'/ tmp / recover'REMAP TABLE'SCOTT'。'EMP'： 'MY_EMP';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-12B467A8-372A-4797-AE0D-123DA9C862C0">
                  <p class="titleinexample">示例3-10将表恢复到指定时间并进入不同的表空间</p>
                  <p>此示例将表<code class="codeph">EMP</code>和<code class="codeph">DEPT</code>恢复到<code class="codeph">UNTIL TIME</code>子句指定的时间点。这些表最初是<code class="codeph">EXAMPLE_TBS</code>表空间的一部分。但是，在恢复操作之后，它们将映射到目标数据库中的表空间<code class="codeph">MY_TBS</code> 。
                  </p><pre class="oac_no_warn" dir="ltr">RECOVER TABLE SCOTT.EMP，SCOTT.DEPT直到“TO_CHAR（'12 / 23/2012 12:00:00'，'mm / dd / yyyy hh24：mi：ss'）”AUXILIARY DESTINATION'/ tmp / oracle / recover 'REMAP TABLESPACE'Example_TBS'：'MY_TBS';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-73587392-C1F7-40A7-AD3A-7C196B9CBF45">
                  <p class="titleinexample">示例3-11将<span class="bold">多个表恢复到不同的模式</span></p>
                  <p>此示例恢复表<code class="codeph">HR.EMPLOYEES</code>和<code class="codeph">SH.CHANNELS</code>表，直到指定的SCN。恢复的<code class="codeph">EMPLOYEES</code>表映射到EXAMPLES模式，恢复的CHANNELS表映射到<code class="codeph">TEST</code>模式。这些模式已在目标数据库中创建。<code class="codeph">CHANNELS</code>表存储在<code class="codeph">SALES_TBS</code>表空间中。表恢复后，它将映射到<code class="codeph">NEW_SALES_TBS</code>表空间。辅助目标用于存储作为表恢复过程的一部分创建的临时数据库文件。
                  </p>
                  <p>要恢复此表，您必须备份<code class="codeph">SYSTEM</code> ， <code class="codeph">SYSAUX</code> ，undo， <code class="codeph">HR</code>和<code class="codeph">SH</code>表空间。创建备份时，数据库必须处于<code class="codeph">ARCHIVELOG</code>模式。
                  </p><pre class="oac_no_warn" dir="ltr">RECOVER TABLE hr.employees，sh.channels UNTIL SCN 3456 REMAP TABLE hr.employees：examples.employees，sh.channels：test.channels REMAP TABLESPACE'SALES_TBS'：'NEW_SALES_TBS'AUXILIARY DESTINATION'/ tmp / auxdest';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-E695DDEA-1C67-4E90-84AE-DAE2E787757D">
                  <p class="titleinexample">示例3-12将<span class="bold">表分区恢复为不同的模式</span></p>
                  <p>此示例将<code class="codeph">SH</code>模式中的分区<code class="codeph">SALES_H1_1997</code>和<code class="codeph">SALES_H2_1997</code>恢复到使用SCN指定的先前时间点。分区分别重命名为<code class="codeph">historic_sales_h1_1997</code>和<code class="codeph">historic_sales_h2_1997</code> 。必须将恢复的分区导入到目标数据库中存在的模式<code class="codeph">new_sh</code>中。
                  </p>
                  <p>必须将<code class="codeph">COMPATIBLE</code>设置为11.1.0或更高，因为正在恢复分区。存在指定恢复SCN处的<code class="codeph">SYSTEM</code> ， <code class="codeph">SYSAUX</code> ， <code class="codeph">UNDO</code>和<code class="codeph">SH</code>表空间的备份。创建备份时，数据库必须处于<code class="codeph">ARCHIVELOG</code>模式。
                  </p><pre class="oac_no_warn" dir="ltr">RECOVER TABLE sh.sales：sales_h1_1997，sh.sales：sales_h2_1997 UNTIL SCN 810234878 REMAP TABLE sh.sales：sales_h1_1997：sh.historic_sales_h1_1997，sh.sales：sales_h2_1997：sh.historic_sales_h2_1997 AUXILIARY DESTINATION'/ tmp / auxdest /';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-CA98040F-9865-4F4F-BAF2-91C518612E95__GUID-4E82B26B-4CFA-449E-A75C-E45070D9DA23">
                  <p class="titleinexample">示例3-13 <span class="bold">将PDB的跨平台备份恢复到目标CDB</span></p>
                  <p></p>
                  <p>此示例在目标数据库上还原PDB <code class="codeph">pdb2</code>的跨平台一致增量级别1备份。目标CDB和源CDB位于不同的平台上，但使用相同的endian格式。
                  </p>
                  <p><code class="codeph">USING</code>子句指定XML文件的名称，该文件包含将PDB插入目标CDB所需的元数据。 <code class="codeph">FOREIGN DATAFILECOPY</code>子句列出了在恢复此PDB的数据文件时创建的所有数据文件。需要对所有这些数据文件执行恢复。<code class="codeph">FILE_NAME_CONVERT</code>子句指定必须如何在目标CDB中重命名源CDB上的文件名</p><pre class="pre codeblock"><code>从PLATFORM'Linux x86 64位'使用'/u02/backup_restore/metadata_pdb2.xml'FILE_NAME_CONVERT =（'/ u01 / oradata'，'/ u02 / oradata / cdb'）FOREIGN DATAFILECOPY'/ u02 / oradata / pdb1恢复。 dbf'，'/ u02 / oradata / pdb1_tmp.dbf'FROM BACKUPSET'/u02/backup_restore/bkup_level1_pdb1.bck';</code></pre></div>
               <!-- class="example" -->
            </div>
         </div>
      </article>
   </body>
</html><html id="06253.CONFIGURE.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>配置</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Backup and Recovery Reference"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Backup and Recovery Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-backup-and-recovery-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T19:31:58-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2003, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96242-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="CHANGE.html" title="Previous" type="text/html"></link>
      <link rel="next" href="CONNECT.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Backup and Recovery Reference"></meta>
    <meta name="dcterms.isVersionOf" content="RCMRF"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="CHANGE.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="CONNECT.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">备份和恢复参考</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="rman-commands-at-sign-to-quit.html" property="item" typeof="WebPage"><span property="name">RMAN命令：@（at符号）到QUIT</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">配置</li>
            </ol>
            <a id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A" name="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A"></a><a id="RCMRF90071"></a><a id="RCMRF90072"></a><a id="RCMRF90073"></a><a id="RCMRF90074"></a><a id="RCMRF90075"></a><a id="RCMRF90076"></a><a id="RCMRF90077"></a><a id="RCMRF90079"></a><a id="RCMRF90080"></a><a id="RCMRF90081"></a><a id="RCMRF90082"></a><a id="RCMRF90083"></a><a id="RCMRF90084"></a><a id="RCMRF90085"></a><a id="RCMRF90086"></a><a id="RCMRF90087"></a><a id="RCMRF90088"></a><a id="RCMRF90089"></a><a id="RCMRF90090"></a><a id="RCMRF90091"></a><a id="RCMRF90092"></a><a id="RCMRF90093"></a><a id="RCMRF90094"></a><a id="RCMRF90095"></a><a id="RCMRF90514"></a><a id="RCMRF113"></a>
            
            <h2 id="RCMRF-GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A" class="sect2"><span class="enumeration_section">2.9</span>配置</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-4F9C3B03-597E-433A-9E15-F60D033EA560">目的</p>
                  <p>使用<code class="codeph">CONFIGURE</code>命令可以创建或更改影响特定数据库上的RMAN备份，还原，复制和维护作业的持久性配置。配置对此数据库上的任何RMAN会话有效，直到明确清除或更改配置为止。您可以使用<code class="codeph"><a href="SHOW.html#GUID-6C2AF43B-FADD-41AF-9408-852A69538E2F">SHOW</a></code>命令显示一个或多个数据库的配置。
                  </p>
                  <div class="infoboxnotealso" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-38280D82-4E07-485F-897F-90942607C590">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../bradv/configuring-rman-client-basic.html#BRADV8002" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南</span></a> ，了解如何配置RMAN环境</p>
                  </div>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-781A68AD-6969-425D-8163-3A9CB259AE25">其他主题</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDCACAG">先决条件</a></p>
                     </li>
                     <li>
                        <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHFHDB">使用说明</a></p>
                     </li>
                     <li>
                        <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDBHBBA">句法</a></p>
                     </li>
                     <li>
                        <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDJDIEA">语义</a></p>
                     </li>
                     <li>
                        <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDDCBH">例子</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDCACAG">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-4238CD57-8FB0-4777-8997-46BE9E4E282F">先决条件</p>
                  <p>仅在RMAN提示符下执行此命令。</p>
                  <p>除非指定<code class="codeph">FOR DB_UNIQUE_NAME</code>子句，否则需要与目标数据库建立RMAN连接。必须安装或打开目标数据库。
                  </p>
                  <p>在CDB中，您必须连接到根才能创建或更改配置设置。连接到PDB时无法配置设置。</p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHFHDB">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-6B29A62A-8AE9-4A8F-A3CE-35C5432FB1A1">使用说明</p>
                  <p><code class="codeph">CONFIGURE</code>命令始终在目标数据库控制文件中存储目标数据库的配置。如果将RMAN与恢复目录一起使用，则RMAN还会为目录中的每个已注册数据库存储持久性配置设置。
                  </p>
                  <p><span class="bold">默认RMAN配置设置</span></p>
                  <p><a id="d28529e243" class="indexterm-anchor"></a> RMAN <code class="codeph">CONFIGURE</code>设置具有默认值。您可以通过使用<code class="codeph">CLEAR</code>选项重新运行命令来返回任何<code class="codeph">CONFIGURE</code>命令的默认值，但不能以这种方式清除单个参数。例如，以下命令有效：</p><pre class="oac_no_warn" dir="ltr">配置频道设备类型sbt CLEAR</pre><p>但是，以下命令无效：</p><pre class="oac_no_warn" dir="ltr">配置通道设备类型sbt MAXPIECESIZE 5M CLEAR</pre><p><span class="bold">Data Guard环境中的RMAN配置</span></p>
                  <p><a id="d28529e267" class="indexterm-anchor"></a><a id="d28529e271" class="indexterm-anchor"></a>在Data Guard环境中，Oracle建议您始终将RMAN与恢复目录一起使用。您可以使用<code class="codeph">CONFIGURE</code>命令为Data Guard环境中的任何单个主数据库或备用数据库创建持久性RMAN配置，但备份保留策略，表空间排除和辅助名称的设置除外。因此，主数据库和备用数据库可以具有不同的通道配置，控制文件自动备份位置等。
                  </p>
                  <p>您可以使用<code class="codeph">FOR DB_UNIQUE_NAME</code>子句将RMAN未连接的数据库配置为<code class="codeph">TARGET</code> 。您可以使用<code class="codeph">CONFIGURE DB_UNIQUE_NAME</code>创建恢复目录已知的新物理备用数据库并隐式注册它。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDBHBBA">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-612E56B4-3537-43F8-9DF3-6E4D3E46E38C">句法</p>
                  <p><a id="d28529e294" class="indexterm-anchor"></a><a id="d28529e298" class="indexterm-anchor"></a> <span class="bold"><span class="italic">configure</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-B9A6D832-3EFA-4451-80BF-3D32CC249577"><img src="img/configure.gif" alt="configure.eps的描述如下" title="configure.eps的描述如下" longdesc="img_text/configure.html"><br><a href="img_text/configure.html">插图说明configure.eps</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220__BABCCBBJ">datafileSpec :: =</a></span> ， <span class="italic"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDIHIEG">backupConf :: =</a></span> ， <span class="italic"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHEECI">cfauConf :: =</a></span> ， <span class="italic"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHIHDH">deviceConf :: =</a></span> ， <span class="italic"><a href="forDbUniqueNameOption.html#GUID-D1D9CFED-9A57-438A-A80C-D8B7B6E131BE__BABBBGBC">forDbUniqueNameOption :: =</a></span> ）</p>
                  <p><a id="d28529e332" class="indexterm-anchor"></a><a id="d28529e336" class="indexterm-anchor"></a> <span class="bold"><span class="italic">delalConf</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-EA67CAB9-FE67-48BC-9984-29E1D47B6A33"><img src="img/delalconf.gif" alt="下面是delalconf.eps的描述" title="下面是delalconf.eps的描述" longdesc="img_text/delalconf.html"><br><a href="img_text/delalconf.html">说明delalconf.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC__BABDEJAC">deviceSpecifier :: =</a></span> ）</p>
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDIHIEG"><a id="d28529e354" class="indexterm-anchor"></a><a id="d28529e358" class="indexterm-anchor"></a> <span class="bold"><span class="italic">backupConf</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-BD3D52F8-766C-4DFC-8AD9-A0FEBD0E768E"><img src="img/backupconf.gif" alt="backupconf.eps的描述如下" title="backupconf.eps的描述如下" longdesc="img_text/backupconf.html"><br><a href="img_text/backupconf.html">backupconf.eps插图说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC__BABDEJAC">deviceSpecifier :: =</a></span> ， <span class="italic"><a href="sizeSpec.html#GUID-146EDBEE-BCED-4BD4-A720-8E51AA8DC577__BABHAICB">sizeSpec :: =</a></span> ）</p>
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHEECI"><a id="d28529e380" class="indexterm-anchor"></a><a id="d28529e384" class="indexterm-anchor"></a> <span class="bold"><span class="italic">cfauConf</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-758799D0-DFCC-4EE1-8EAA-8696EBC1C0F5"><img src="img/cfauconf.gif" alt="cfauconf.eps的描述如下" title="cfauconf.eps的描述如下" longdesc="img_text/cfauconf.html"><br><a href="img_text/cfauconf.html">说明cfauconf.eps的说明</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC__BABDEJAC">deviceSpecifier :: =</a></span> ， <span class="italic"><a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED__BABHCHAG">formatSpec :: =</a></span> ）</p>
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHIHDH"><a id="d28529e407" class="indexterm-anchor"></a><a id="d28529e411" class="indexterm-anchor"></a> <span class="bold"><span class="italic">deviceConf</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-88A4112F-F9CE-4635-9CA6-C210659551AB"><img src="img/deviceconf.gif" alt="下面是deviceconf.eps的说明" title="下面是deviceconf.eps的说明" longdesc="img_text/deviceconf.html"><br><a href="img_text/deviceconf.html">插图描述deviceconf.eps</a></div>
                  <!-- class="figure" -->
                  <p>（ <span class="italic"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC__BABDEJAC">deviceSpecifier :: =</a></span> ， <span class="italic"><a href="allocOperandList.html#GUID-8B6C1DAB-F27A-4DA8-BECC-5DA04F5907DA__BABFFJCH">allocOperandList :: =</a></span> ）</p>
                  <p><a id="d28529e433" class="indexterm-anchor"></a><a id="d28529e437" class="indexterm-anchor"></a> <span class="bold"><span class="italic">forDbUniqueNameOption</span> :: =</span></p>
                  <div class="figure" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-ADB071A8-5C0E-4C1B-9A81-2125D82040C9"><img src="img/fordbuniquenameoption.gif" alt="下面是fordbuniquenameoption.eps的描述" title="下面是fordbuniquenameoption.eps的描述" longdesc="img_text/fordbuniquenameoption.html"><br><a href="img_text/fordbuniquenameoption.html">说明fordbuniquenameoption.eps的说明</a></div>
                  <!-- class="figure" -->
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDJDIEA">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-3E4B26DF-0300-4F9E-87D5-84D9D2394E00">语义</p>
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1017464"><a id="d28529e452" class="indexterm-anchor"></a><a id="d28529e456" class="indexterm-anchor"></a> <span class="bold"><span class="italic">配置</span></span> 
                  </p>
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-98D50301-81B1-4410-8E2E-88A1A12733FE">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes CONFIGURE command parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d28529e472">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d28529e475">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e480" headers="d28529e472 "><code class="codeph">DB_UNIQUE_NAME</code> <span class="italic"><code class="codeph">db_unique_name</code> <code class="codeph">CONNECT IDENTIFIER</code></span> <code class="codeph">'</code> <span class="italic"><code class="codeph">connect_string</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e480 d28529e475 ">
                                 <p>指定<code class="codeph">DB_UNIQUE_NAME</code>指定的物理备用数据库的网络服务名称。 <code class="codeph">CONNECT IDENTIFIER</code>字符串不得包含数据库用户名和密码。
                                 </p>
                                 <p>RMAN还必须作为<code class="codeph">TARGET</code>连接到主数据库。 RMAN必须连接到恢复目录。
                                 </p>
                                 <p>运行<code class="codeph"><a href="RESYNC-CATALOG.html#GUID-DF91BD12-A00D-49CC-99C5-E8EDD0094CCE">RESYNC CATALOG</a></code> <code class="codeph">FROM DB_UNIQUE_NAME</code>命令时，Data Guard环境中的数据库使用网络服务名称与<span class="italic"><code class="codeph">db_unique_name</code></span>数据库连接。例如，假设备用数据库具有唯一名称<code class="codeph">standby1</code>和网络服务名称<code class="codeph">sby1</code> 。您将RMAN作为<code class="codeph">TARGET</code>连接到主数据库并执行<code class="codeph">CONFIGURE DB_UNIQUE_NAME 'standby1' CONNECT IDENTIFIER 'sby1'</code> 。当需要与<code class="codeph">standby1</code>建立Oracle Net连接时，环境中的每个主数据库和备用数据库都使用网络服务名称<code class="codeph">sby1</code> 。
                                 </p>
                                 <p><span class="bold">注意：</span>当目标数据库需要连接到其他备用数据库或主数据库时，它将使用现有的Data Guard身份验证机制作为<code class="codeph">SYSDBA</code>或<code class="codeph">SYSBACKUP</code>用户进行连接。
                                 </p>
                                 <p>假设您最近将RMAN作为<code class="codeph">TARGET</code>连接到主数据库并使用了<code class="codeph">CONFIGURE ...FOR DB_UNIQUE_NAME standby_new</code>配置备用数据库<code class="codeph">standby_new</code>备份设置。但是，您还没有将RMAN作为<code class="codeph">TARGET</code>连接到<code class="codeph">standby_new</code> 。在这种情况下，您可以执行<code class="codeph">RESYNC CATALOG FROM DB_UNIQUE_NAME standby_new</code> 。主数据库使用连接标识符与备用数据库建立Oracle Net连接。稍后将RMAN连接到备用数据库时，RMAN会将配置从恢复目录推送到已装入的控制文件。
                                 </p>
                                 <p><span class="bold">注意：</span>如果<code class="codeph">CONFIGURE DB_UNIQUE_NAME</code>指定的数据库未在恢复目录中注册，则RMAN会隐式注册它。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e584" headers="d28529e472 ">
                                 <p><code class="codeph">明确</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e584 d28529e475 ">
                                 <p>将参数返回到其默认设置。请参阅使用说明。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e592" headers="d28529e472 ">
                                 <p><span class="italic"><code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDIFEEE">delalConf</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e592 d28529e475 ">
                                 <p>配置存档的重做日志删除策略。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e602" headers="d28529e472 "><code class="codeph">AUXNAME FOR DATAFILE</code> <span class="italic"><code class="codeph"><a href="datafileSpec.html#GUID-A0A69931-D404-4D89-8F95-3AB898B6A220">datafileSpec</a></code></span> <code class="codeph">CLEAR | TO</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e602 d28529e475 ">
                                 <p>将指定目标数据文件的辅助文件名配置为<code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code> （请参见<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHHHDF">示例2-54</a> ）。指定<code class="codeph">CLEAR</code>以指定辅助文件名。
                                 </p>
                                 <p>如果您正在执行TSPITR或使用<code class="codeph"><a href="DUPLICATE.html#GUID-E13D8A02-80F9-49A2-9C31-92DD3A795CE4">DUPLICATE</a></code> ，则可以设置<code class="codeph">AUXNAME</code>以预配置文件名以在辅助数据库上使用，而无需在过程中手动指定辅助文件名。您不能将<code class="codeph">CONFIGURE AUXNAME</code>用于恢复集，您必须使用<code class="codeph">SET NEWNAME</code> 。</p>
                                 <p>例如，如果数据文件位于原始磁盘上，则必须在TSPITR期间使用此命令，并且出于性能原因必须将辅助数据文件还原到原始磁盘。通常，您在TSPITR中为<code class="codeph">SYSTEM</code>和<code class="codeph">SYSAUX</code>表空间的数据文件以及包含回滚或还原段的表空间设置<code class="codeph">AUXNAME</code>参数。不要覆盖生产数据库正在使用的文件，并且可以在TSPITR完成后丢弃。实质上，数据文件的<code class="codeph">AUXNAME</code>是TSPITR可以创建它的临时副本的位置。
                                 </p>
                                 <p>使用<code class="codeph">DUPLICATE</code>命令重命名文件时， <code class="codeph">CONFIGURE</code> <span class="bold"> </span> <code class="codeph">AUXNAME</code>是<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">NEWNAME</code>的替代品。不同之处在于，在您第一次设置<code class="codeph">AUXNAME</code>后，在发出另一个<code class="codeph">DUPLICATE</code>命令时无需重置文件名： <code class="codeph">AUXNAME</code>设置保持有效，直到您发出<code class="codeph">CONFIGURE AUXNAME ...CLEAR</code> 。相反，每次执行<code class="codeph">DUPLICATE</code>命令时都必须重新<code class="codeph">SET NEWNAME</code>命令。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../bradv/performing-rman-tspitr.html#BRADV009" target="_blank"><span><cite>Oracle数据库备份和恢复用户指南</cite></span></a> ，了解如何执行RMAN TSPITR，以及<a href="../bradv/rman-duplicating-databases.html#BRADV-GUID-F31F9FCE-B610-49EB-B9DB-44B9AA4E838F" target="_blank"><span><cite>Oracle数据库备份和恢复用户指南</cite></span></a> ，了解如何使用RMAN复制数据库</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e723" headers="d28529e472 ">
                                 <p><span class="italic"><code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1017487">backupConf</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e723 d28529e475 ">
                                 <p>配置默认备份选项，例如双工，优化，排除表空间，备份集大小和保留策略。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e733" headers="d28529e472 ">
                                 <p><span class="italic"><code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1017491">cfauConf</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e733 d28529e475 ">
                                 <p>配置控制文件自动备份设置。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e743" headers="d28529e472 "><code class="codeph">COMPRESSION ALGORITHM</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">algorithm_name</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e743 d28529e475 ">
                                 <p>指定RMAN用于创建压缩备份集的算法。</p>
                                 <p>默认压缩算法设置为<code class="codeph">BASIC</code> ，不需要高级压缩选项。
                                 </p>
                                 <p>但是，如果您启用了“高级压缩选项”，则可以从以下压缩级别中进行选择：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">HIGH -</code> <a id="d28529e769" class="indexterm-anchor"></a>最适合在较慢网络上进行备份，其中限制因素是网络速度</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">MEDIUM -</code> <a id="d28529e778" class="indexterm-anchor"></a>推荐用于大多数环境。压缩比和速度的良好组合</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">LOW</code> - <a id="d28529e788" class="indexterm-anchor"></a>对备份吞吐量的影响最小，适用于CPU资源是限制因素的环境。
                                       </p>
                                    </li>
                                 </ul>
                                 <p><span class="bold">注意：</span>压缩率通常从低到高增加，可能会消耗更多的CPU资源。
                                 </p>
                                 <p>由于各种压缩级别的性能取决于数据库中的数据性质，网络配置，系统资源以及计算机系统的类型及其功能，因此Oracle无法记录普遍适用的性能统计信息。关于哪个级别最佳的决定必须考虑系统与CPU的带宽和CPU的实际速度之间的平衡程度。强烈建议您对环境中的数据运行具有不同压缩级别的测试。根据您的环境，网络流量特征（工作负载）和数据集选择压缩级别是确保备份集压缩级别能够满足组织的性能要求和任何适用的服务级别协议的唯一方法。</p>
                                 <p><span class="bold">注意：</span> <a id="d28529e803" class="indexterm-anchor"></a><a id="d28529e805" class="indexterm-anchor"></a> <code class="codeph">V$RMAN_COMPRESSION_ALGORITHM</code>视图描述了支持的算法。
                                 </p>
                                 <p><span class="bold">另请参阅</span> ： <code class="codeph">V$RMAN_COMPRESSION_ALGORITHM</code> <span class="italic">Oracle数据库参考</span>条目。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e823" headers="d28529e472 ">
                                 <p>   <code class="codeph">优化负载</code>  
                                 </p>
                                 <p> <code class="codeph">{TRUE | FALSE}</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e823 d28529e475 ">
                                 <p>指定Oracle数据库是否在请求压缩备份时执行预压缩块处理。<code class="codeph">TRUE</code>是默认值， <code class="codeph">FALSE</code>启用预压缩处理。默认行为是不执行预压缩块处理。这样的处理可能消耗额外的CPU资源，并且对于包含所有最初加载的数据的块不需要，并且从未成为单行插入和删除的主题。指定<code class="codeph">FALSE</code>使用额外的CPU资源来执行预压缩块处理，该处理由内部块清理和碎片整理组成，可以提高二进制压缩级别。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <span class="italic">Oracle数据库备份和恢复用户指南，</span>以了解有关此选项的更多信息。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e853" headers="d28529e472 ">
                                 <p>   <code class="codeph">作为释放</code>  
                                 </p>
                                 <p><span class="italic">'版'</span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e853 d28529e475 ">
                                 <p>指定发行版本。版本号使用版本号格式，并且可以使用多达5个数字来完全限定版本。例如，10.2.0.3.0和11.2是可接受的值。此选项可确保未来版本的压缩算法稳定性。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e866" headers="d28529e472 ">
                                 <p><span class="italic"><code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1019177">deviceConf</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e866 d28529e475 ">
                                 <p>配置设备的默认备份设置，例如默认备份设备，设备的通道配置，每个设备的默认备份类型以及并行度。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e876" headers="d28529e472 ">
                                 <p><code class="codeph">加密</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e876 d28529e475 ">
                                 <p>指定数据库或表空间的透明模式加密设置。</p>
                                 <p>除非使用<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">ENCRYPTION</code>命令覆盖，否则此配置适用。为单个表空间指定的选项优先于为整个数据库指定的选项。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <span class="q">“ <a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50__CHDIHIGD">备份集加密</a> ”</span>以了解不同的备份加密模式，以及<a href="../asoag/introduction-to-transparent-data-encryption.html#ASOAG10139" target="_blank"><span class="italic">Oracle数据库高级安全性指南</span></a>以了解透明数据加密</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e908" headers="d28529e472 "><code class="codeph">ALGORITHM</code> <code class="codeph">'</code> <span class="italic"><code class="codeph">algorithm_name</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e908 d28529e475 ">
                                 <p><a id="d28529e921" class="indexterm-anchor"></a>指定编写备份集时用于加密的默认算法。可能的值列在<a id="d28529e924" class="indexterm-anchor"></a><a id="d28529e926" class="indexterm-anchor"></a><a id="d28529e930" class="indexterm-anchor"></a><a id="d28529e934" class="indexterm-anchor"></a> <code class="codeph">V$RMAN_ENCRYPTION_ALGORITHMS</code> 。 <code class="codeph">CLEAR</code>选项将数据库重置为默认值。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e945" headers="d28529e472 "><code class="codeph">FOR DATABASE</code> <code class="codeph">[ON | OFF | CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e945 d28529e475 ">
                                 <p><a id="d28529e953" class="indexterm-anchor"></a><a id="d28529e957" class="indexterm-anchor"></a><a id="d28529e959" class="indexterm-anchor"></a>指定是否为整个数据库启用透明加密。选项如下：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">ON</code>启用所有数据库文件的加密。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OFF</code>关闭所有数据库文件的加密。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CLEAR</code>恢复默认设置<code class="codeph">OFF</code> 。</p>
                                    </li>
                                 </ul>
                                 <p><span class="bold">注意：</span>必须使用<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">ENCRYPTION IDENTIFIED BY</code>命令启用密码加密。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e996" headers="d28529e472 "><code class="codeph">FOR TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span> <code class="codeph">[ON | OFF | CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e996 d28529e475 ">
                                 <p><a id="d28529e1008" class="indexterm-anchor"></a>指定是否为一个或多个表空间启用透明加密。表空间的已配置设置始终覆盖数据库级别的配置集。选项如下：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">ON</code>启用对指定表空间的加密，除非使用<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">ENCRYPTION OFF FOR ALL TABLESPACES</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OFF</code>禁用指定表空间的加密，除非使用<code class="codeph">SET ENCRYPTION ON FOR ALL TABLESPACES</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CLEAR</code>表示指定表空间的加密由整个数据库的当前默认值确定。
                                       </p>
                                    </li>
                                 </ul>
                                 <p><span class="bold">注意：</span>必须使用<code class="codeph">SET ENCRYPTION IDENTIFIED BY</code>命令启用密码加密。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1048" headers="d28529e472 "><code class="codeph">FOR TABLESPACE</code> <span class="italic"><code class="codeph">pdb_name:tablespace_name</code></span> <code class="codeph">[ON | OFF | CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1048 d28529e475 ">
                                 <p>CDB中表空间的名称。多个数据库可以具有相同名称的表空间。名称前面的限定符唯一标识表空间。 <span class="italic"><code class="codeph">pdb-name</code></span>是PDB的名称。</p>
                                 <p>请参阅前面的<code class="codeph">FOR TABLESPACE</code>描述。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1071" headers="d28529e472 ">
                                 <p><code class="codeph">RMAN OUTPUT TO KEEP FOR</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">DAYS</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e1071 d28529e475 ">
                                 <p>将RMAN输出日志记录配置为<span class="italic"><code class="codeph">integer</code></span>指定的天<span class="italic"><code class="codeph">integer</code></span> 。有关RMAN命令输出的信息存储在两个视图<code class="codeph">RC_RMAN_OUTPUT</code>和<code class="codeph">V$RMAN_OUTPUT</code> 。将输出日志记录配置为<span class="italic"><code class="codeph">integer</code></span>天时，将从<code class="codeph">RC_RMAN_OUTPUT</code>和<code class="codeph">V$RMAN_OUTPUT</code>视图中删除任何早于<span class="italic"><code class="codeph">integer</code></span>天的日志记录条目。
                                 </p>
                                 <p>例如，假设现有输出日志记录配置设置为20天。使用<code class="codeph">CONFIGURE</code>命令将输出日志记录更改为10天。从<code class="codeph">RC_RMAN_OUTPUT</code>和<code class="codeph">V$_RMAN_OUTPUT</code>中删除任何超过10天的日志记录条目。</p>
                                 <p>要禁用RMAN输出日志记录，请将<span class="italic"><code class="codeph">integer</code></span>设置为零，如以下示例所示。
                                 </p><pre class="oac_no_warn" dir="ltr">配置RMAN输出保持0天;</pre><p>禁用输出日志记录时， <code class="codeph">RC_RMAN_OUTPUT</code>和<code class="codeph">V$RMAN_OUTPUT</code>视图中不存储任何日志记录信息。<code class="codeph">RC_RMAN_OUTPUT</code>中的现有日志记录条目<code class="codeph">RC_RMAN_OUTPUT</code>被删除。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1139" headers="d28529e472 ">
                                 <p>      <code class="codeph">明确</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e1139 d28529e475 ">
                                 <p>清除现有的RMAN输出日志记录配置并将其重置为7天，这是默认值。</p>
                                 <p>RMAN将输出日志记录信息存储在<code class="codeph">RC_RMAN_OUTPUT</code>和<code class="codeph">V$RMAN_OUTPUT</code>视图中。清除输出日志记录配置时，将从<code class="codeph">RC_RMAN_OUTPUT</code>视图中删除任何超过7天的日志记录条目（默认值）。<code class="codeph">V$RMAN_RMAN_OUTPUT</code>视图中超过7天的条目不会立即删除。仅在超出此视图允许的最大行数时才删除它们。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1162" headers="d28529e472 "><code class="codeph">SNAPSHOT CONTROLFILE</code> <code class="codeph">NAME TO '</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1162 d28529e475 ">
                                 <p><a id="d28529e1175" class="indexterm-anchor"></a>将快照控制文件名和位置配置为<code class="codeph">'</code> <span class="italic"><code class="codeph">filename</code></span> <code class="codeph">'</code> 。如果运行<code class="codeph">CONFIGURE SNAPSHOT CONTROLFILE NAME CLEAR</code> ，则RMAN将快照控制文件名设置为其默认值。
                                 </p>
                                 <p>快照控制文件名的默认值是特定于平台的，并且取决于Oracle主目录。例如，某些UNIX系统上的默认值是<code class="codeph">?/dbs/snapcf_@.f</code> .如果清除控制文件名，并且更改了Oracle主目录，则快照控制文件的默认位置也会更改。
                                 </p>
                                 <p>快照控制文件名仅对此数据库有效。假设您将快照控制文件名配置为主数据库上的非默认值。如果使用<code class="codeph"><a href="DUPLICATE.html#GUID-E13D8A02-80F9-49A2-9C31-92DD3A795CE4">DUPLICATE</a></code>创建备用数据库，则备用数据库上的快照控制文件位置将设置为默认值。如果需要，可以将备用数据库上的快照位置配置为非默认值。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../bradv/configuring-rman-client-advanced.html#BRADV141" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南</span></a> ，以获取有关快照控制文件的更多信息</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1213" headers="d28529e472 ">
                                 <p><span class="italic"><code class="codeph"><a href="forDbUniqueNameOption.html#GUID-D1D9CFED-9A57-438A-A80C-D8B7B6E131BE">forDbUniqueNameOption</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e1213 d28529e475 ">
                                 <p><a id="d28529e1222" class="indexterm-anchor"></a><a id="d28529e1226" class="indexterm-anchor"></a>在<code class="codeph">DB_UNIQUE_NAME</code>指定的Data Guard环境中的数据库的恢复目录中创建RMAN配置。您可以使用<span class="italic"><code class="codeph">db_unique_name</code></span>指定单个数据库，也可以对恢复目录中共享目标数据库的DBID（或<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">DBID</code>命令指定的<code class="codeph">DBID</code> ）的所有数据库使用<code class="codeph">ALL</code> 。
                                 </p>
                                 <p>在Data Guard环境中执行操作时，需要恢复目录。RMAN必须作为<code class="codeph">TARGET</code>连接到已装入或已打开的数据库（可以是主数据库或备用数据库）， <span class="italic">或者</span>必须使用<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">DBID</code>命令标识目标数据库。因此，您可以使用此子句为备用数据库创建持久性配置， <span class="italic">而无需</span>将<code class="codeph">TARGET</code>连接到备用数据库或主数据库。例如，您可以在创建备用数据库之前为其创建配置，以便在创建数据库后应用配置（请参阅<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDEIDFD">示例2-56</a> ）。
                                 </p>
                                 <p>指定<code class="codeph">FOR DB_UNIQUE_NAME</code> ，RMAN会直接更新恢复目录中的配置元数据。当RMAN作为<code class="codeph">TARGET</code>连接到使用<code class="codeph">FOR DB_UNIQUE_NAME</code>更改其配置的数据库时，RMAN将使用恢复目录中的配置元数据更新已装入的控制文件。
                                 </p>
                                 <p><span class="bold">注意：</span>可以在备用数据库上本地运行<code class="codeph">CONFIGURE</code> ，然后为同一数据库运行<code class="codeph">CONFIGURE FOR DB_UNIQUE_NAME</code> ，而RMAN未作为<code class="codeph">TARGET</code>连接到此数据库。在这种情况下，恢复目录中的配置将覆盖特定数据库的控制文件中的配置。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDIFEEE"><span class="bold"><span class="italic">delalConf</span></span> 
                  </p>
                  <p><a id="d28529e1305" class="indexterm-anchor"></a>本子条款管理归档重做日志删除策略的持久性配置。
                  </p>
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-79CFB88F-8245-40EA-9BA2-72115130030C">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes CONFIGURE command delalConf parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d28529e1318">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d28529e1321">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1326" headers="d28529e1318 ">
                                 <p><code class="codeph" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHCEEH">ARCHIVELOG删除政策</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e1326 d28529e1321 ">
                                 <p>确定归档的重做日志文件何时可以删除。</p>
                                 <p>归档日志删除策略适用于所有日志归档目标，包括快速恢复区域。该策略不适用于备份集中的归档重做日志文件。</p>
                                 <p>数据库仅自动删除快速恢复区中的归档重做日志文件。你可以执行<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code> <code class="codeph">...DELETE INPUT</code> ， <code class="codeph"><a href="DELETE.html#GUID-FB4EAC69-4978-42F7-8B09-77C6736188B3">DELETE</a></code> <code class="codeph">ARCHIVELOG</code>或<code class="codeph">DELETE OBSOLETE</code>命令可从日志归档目标（包括恢复区域）手动删除日志。如果未在删除命令上指定<code class="codeph">FORCE</code> ，则这些删除命令将遵循存档日志删除策略。如果指定了<code class="codeph">FORCE</code> ，则删除命令将忽略存档日志删除策略。
                                 </p>
                                 <p>在恢复区域中，如果可能，数据库会保留符合删除条件的日志。当需要磁盘空间时，数据库首先删除最旧的日志。当恢复区域处于磁盘压力下时，数据库可能会删除根据快速恢复区域规则可回收的归档重做日志文件。</p>
                                 <p><span class="bold">注意：</span>删除策略不适用于外部归档重做日志文件，这些文件是逻辑备用数据库为其收集的日志<a id="d28529e1369" class="indexterm-anchor"></a> LogMiner会话。这些日志是从主数据库传输的，但与普通的归档重做日志文件不同，它们具有不同的DBID。无法在逻辑备用数据库上备份或还原外部归档的重做日志文件。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1373" headers="d28529e1318 "><code class="codeph">TO APPLIED ON</code> <code class="codeph">[ALL] STANDBY</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1373 d28529e1321 ">
                                 <p>如果<span class="italic">满足</span>以下<span class="italic">两个</span>条件，则归档重做日志文件有资格删除：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>已归档的重做日志文件已应用于所需的备用数据库。</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">BACKED UP ...不需要日志<code class="codeph">BACKED UP ...TIMES TO DEVICE TYPE</code>删除策略的时间。如果未设置<code class="codeph">BACKED UP</code>策略，则始终满足此条件。
                                       </p>
                                    </li>
                                 </ul>
                                 <p></p>
                                 <p>存在有效的备用远程数据库时，此策略适用于主数据库，备用数据库和<code class="codeph">FAR SYNC</code>备用数据库。
                                 </p>
                                 <p>对于主数据库，归档重做日志文件在备用数据库上应用后可以删除。如果不存在有效的备用数据库，则RMAN使用<code class="codeph">TO NONE</code>作为策略。对于备用数据库，归档的重做日志文件在应用于备用数据库和任何级联备用数据库后都有资格删除。
                                 </p>
                                 <p>考虑哪些远程目标取决于以下标准：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果未指定<code class="codeph">ALL</code> ，则归档重做日志文件在应用于所有必需远程目标后都有资格删除。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果指定<code class="codeph">ALL</code> ，则归档重做日志文件在所有远程目标上应用或使用后都是合格的，无论是否强制。
                                       </p>
                                       <p>例如，备用数据库<code class="codeph">sby1</code>可能是唯一接收日志的远程目标，但其他远程目标可以通过引用<code class="codeph">sby1</code>上的相同位置来应用日志。使用<code class="codeph">ALL</code> ， <code class="codeph">sby1</code>在<code class="codeph">sby1</code>不需要时立即将主数据库上的日志标记为已消耗，但在引用相同位置的所有其他相关远程目标应用或使用之前，不允许删除此日志。
                                       </p>
                                    </li>
                                 </ul>
                                 <p><span class="bold">注意：</span>将<code class="codeph">TO APPLIED</code>子句与<code class="codeph">NONE</code>或<code class="codeph">TO SHIPPED</code>子句一起指定是无效的。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../sbydb/using-RMAN-in-oracle-data-guard-configurations.html#SBYDB04700" target="_blank"><span class="italic">Oracle Data Guard概念和管理</span></a>以获取详细信息</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1464" headers="d28529e1318 "><code class="codeph">BACKED UP</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">TIMES TO DEVICE</code> <code class="codeph">TYPE</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1464 d28529e1321 ">
                                 <p>如果<span class="italic">满足</span>以下<span class="italic">两个</span>条件，则归档重做日志文件有资格删除：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>指定的设备类型上存在指定数量的归档日志备份。</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">TO SHIPPED TO ...不需要日志STANDBY</code>或<code class="codeph">TO APPLIED ON ...STANDBY</code>删除政策。如果未设置<code class="codeph">TO SHIPPED TO</code>策略，则始终满足此条件。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>如果使用此子句配置删除策略，则<code class="codeph">BACKUP ARCHIVELOG</code>命令将复制日志，除非指定的设备类型上存在<span class="italic"><code class="codeph">integer</code></span>备份。如果存在日志的<span class="italic"><code class="codeph">integer</code></span>备份，则<code class="codeph">BACKUP ARCHIVELOG</code>命令会跳过日志。这样，归档日志删除策略在<code class="codeph">BACKUP ARCHIVELOG</code>命令上用作默认的<code class="codeph">NOT BACKED UP</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">TIMES</code>子句。您可以通过在<code class="codeph">BACKUP</code>命令上指定<code class="codeph">FORCE</code>选项来覆盖此删除策略。
                                 </p>
                                 <p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1549" headers="d28529e1318 ">
                                 <p><code class="codeph">没有</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e1549 d28529e1321 ">
                                 <p>禁用存档日志删除策略。这是默认设置。</p>
                                 <p>存档的重做日志文件可以位于快速恢复区域的内部或外部。可以通过手动命令删除任何位置的日志。数据库只能自动删除快速恢复区域中的日志。</p>
                                 <p></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>为目标数据库配置远程目标时，如果已将已归档的重做日志文件传输到<code class="codeph">LOG_ARCHIVE_DEST_</code> <span class="italic"><code class="codeph">n</code></span>指定的所需远程目标，则无论是在快速恢复区域还是在其外部，都可以进行删除。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果未配置远程目标，则快速恢复区中的归档重做日志文件如果已至少备份到磁盘或SBT， <span class="italic">或者</span>根据备份保留策略已过时，则可以删除快速恢复区中的归档重做日志文件。
                                       </p>
                                       <p>备份保留策略认为过时的日志<span class="italic">仅如果</span>不需要通过保证还原点日志<span class="italic">和</span>不被闪回数据库所需的日志。如果日志是在<code class="codeph">SYSDATE-'DB_FLASHBACK_RETENTION_TARGET'</code>之后创建的，则闪回数据库需要存档的重做日志文件。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>例如，假设已归档的重做日志文件已传输到所需的远程目标。根据恢复窗口保留策略，日志已过时，但尚未备份。在这种情况下，日志有资格删除。另外，假设日志是过时，并且已被备份到SBT，但还<span class="italic">没有</span>被转移到所需的远程目的地。在这种情况下，日志不符合删除条件。
                                 </p>
                                 <p>如果删除策略设置为<code class="codeph">NONE</code> ，并且对快速恢复区域外的归档重做日志文件执行删除命令，则RMAN仅遵循删除命令中指定的条件。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1597" headers="d28529e1318 "><code class="codeph">TO SHIPPED TO</code> <code class="codeph">[ALL] STANDBY</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1597 d28529e1321 ">
                                 <p>如果<span class="italic">满足</span>以下<span class="italic">两个</span>条件，则归档重做日志文件有资格删除：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>已归档的重做日志文件已传输到所需的远程目标。</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">BACKED UP ...不需要日志<code class="codeph">BACKED UP ...TIMES TO DEVICE TYPE</code>删除策略的时间。如果未设置<code class="codeph">BACKED UP</code>删除策略，则始终满足此条件。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>存在有效的备用远程数据库时，此策略适用于主数据库，备用数据库和<code class="codeph">FAR SYNC</code>备用数据库。
                                 </p>
                                 <p></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>对于主数据库：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果存在有效的备用配置，则归档的重做日志文件在发送到备用数据库后才有资格删除。</p>
                                          </li>
                                          <li>
                                             <p>如果不存在有效的备用数据库，则RMAN使用<code class="codeph">TO NONE</code>作为默认策略。
                                             </p>
                                          </li>
                                       </ul>
                                    </li>
                                    <li>
                                       <p>对于备用数据库：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>如果存在有效的级联备用配置，则归档的重做日志文件在发送到级联备用数据库后才有资格删除。</p>
                                          </li>
                                          <li>
                                             <p>如果不存在有效的级联备用配置，则RMAN使用<code class="codeph">TO NONE</code>作为默认策略。
                                             </p>
                                          </li>
                                       </ul>
                                    </li>
                                 </ul>
                                 <p>考虑哪些远程目标取决于以下标准：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果未指定<code class="codeph">ALL</code> ，则归档的重做日志文件仅在传输到强制远程目标后才有资格删除。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果指定<code class="codeph">ALL</code> ，则在传输到所有远程目标后，日志都有资格删除，无论是否强制。
                                       </p>
                                    </li>
                                 </ul>
                                 <p><span class="bold">注意：</span>将<code class="codeph">TO SHIPPED</code>子句与<code class="codeph">NONE</code>或<code class="codeph">TO APPLIED</code>子句一起指定是无效的。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../sbydb/using-RMAN-in-oracle-data-guard-configurations.html#SBYDB04700" target="_blank"><span class="italic">Oracle Data Guard概念和管理</span></a>以获取详细信息</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1017487"><span class="bold"><span class="italic">backupConf</span></span></p>
                  <p>本子条款管理与<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令相关的持久配置。一种配置是备份优化。如果启用备份优化，则如果已在设备类型上备份相同的文件，则RMAN不会将文件备份到设备类型。
                  </p>
                  <p><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__G1028761" title="描述跳过备份的标准，因为文件是相同的">表2-3</a>说明了备份优化用于确定文件是否相同且可能被跳过的标准。该表还说明了RMAN在启用备份优化时使用的算法，并且需要确定是否跳过相同文件的备份。如果RMAN没有跳过备份，那么它将完全按照指定进行备份。
                  </p>
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__G1028761">
                     <p class="titleintable">表2-3备份优化算法</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="备份优化算法" width="100%" border="1" summary="Describes criteria for skipping backups because the files are identical" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="14%" id="d28529e1720">文件类型</th>
                              <th align="left" valign="bottom" width="29%" id="d28529e1723">相同文件的标准</th>
                              <th align="left" valign="bottom" width="57%" id="d28529e1726">启用备份优化时的备份算法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d28529e1731" headers="d28529e1720 ">
                                 <p>数据文件</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d28529e1731 d28529e1723 ">
                                 <p>数据文件必须具有相同的DBID，检查点SCN，创建SCN和<code class="codeph">RESETLOGS</code> SCN以及作为备份中已有数据文件的时间。数据文件必须正常脱机，只读或正常关闭。
                                 </p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d28529e1731 d28529e1726 ">
                                 <p>如果启用了基于恢复窗口的保留策略，则RMAN是否跳过数据文件取决于备份媒体。</p>
                                 <p>对于备份到磁带，如果最新备份早于恢复窗口，则即使存在相同数据文件的备份，RMAN也会对数据文件进行另一次备份。通过这种方式，磁带可以在到期后回收利用。</p>
                                 <p>对于备份到磁盘，如果磁盘上有相同的数据文件，则RMAN会跳过备份，即使该备份早于恢复窗口的开头。基于窗口的保留策略会使RMAN在需要时保留旧备份。</p>
                                 <p><a id="d28529e1748" class="indexterm-anchor"></a>如果使用<code class="codeph">CONFIGURE</code> <code class="codeph">RETENTION</code> <code class="codeph">POLICY</code> <code class="codeph">TO</code> <code class="codeph">REDUNDANCY</code> <span class="italic"><code class="codeph">r</code></span>启用了保留策略，则仅当指定设备上存在至少<span class="italic">n</span>个相同文件的备份时，RMAN才会跳过备份，其中<span class="italic"><code class="codeph">n</code></span> = <span class="italic"><code class="codeph">r</code></span> +1。
                                 </p>
                                 <p>如果未启用保留策略，则只有在指定设备上至少存在<span class="italic">n</span>个相同文件的备份时，RMAN才会跳过备份。RMAN按此优先顺序搜索<span class="italic">n的</span>值（即，列表上的值越大，列表中的值越低）：</p>
                                 <ol>
                                    <li>
                                       <p><code class="codeph">备份......COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">SET BACKUP COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">为设备类型配置数据文件备份副本...TO</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">n</span> = 1</p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d28529e1823" headers="d28529e1720 ">
                                 <p>存档的重做日志</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d28529e1823 d28529e1723 ">
                                 <p>归档重做日志必须具有与备份中已存档的日志相同的线程，序列号和<code class="codeph">RESETLOGS</code> SCN以及时间。
                                 </p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d28529e1823 d28529e1726 ">
                                 <p>仅当指定设备上至少存在<span class="italic">n</span>个相同文件的备份时，RMAN才会跳过备份。RMAN按此优先顺序搜索<span class="italic">n的</span>值（即，列表上的值越大，列表中的值越低）：</p>
                                 <ol>
                                    <li>
                                       <p><code class="codeph">备份......COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">SET BACKUP COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">配置ARCHIVELOG备份复制设备类型...TO</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">n</span> = 1</p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d28529e1872" headers="d28529e1720 ">
                                 <p>备份集</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d28529e1872 d28529e1723 ">
                                 <p>备份集必须具有与现有备份集相同的记录ID和标记。</p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d28529e1872 d28529e1726 ">
                                 <p>仅当指定设备上至少存在<span class="italic">n</span>个相同文件的备份时，RMAN才会跳过备份。默认情况下， <span class="italic">n</span> <code class="codeph">=1</code> 。RMAN按此优先顺序搜索<span class="italic">n的</span>其他值（即，列表中较高的值覆盖列表中较低的值）：</p>
                                 <ol>
                                    <li>
                                       <p><code class="codeph">备份......COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">SET BACKUP COPIES</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">n</span> = 1</p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-5E779EDD-1DCA-47D0-AC1F-6573AF950107">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes CONFIGURE command backupConf parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d28529e1922">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d28529e1925">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e1930" headers="d28529e1922 "><code class="codeph">{ARCHIVELOG | DATAFILE}</code> <code class="codeph">BACKUP COPIES FOR DEVICE TYPE</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span> <code class="codeph">TO</code> <span class="italic"><code class="codeph">integer</code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e1930 d28529e1925 ">
                                 <p><a id="d28529e1949" class="indexterm-anchor"></a><a id="d28529e1953" class="indexterm-anchor"></a><a id="d28529e1957" class="indexterm-anchor"></a><a id="d28529e1961" class="indexterm-anchor"></a>指定指定设备类型上<code class="codeph">DATAFILE</code> （包括数据文件和控制文件）或<code class="codeph">ARCHIVELOG</code>文件的每个备份集的副本数（请参阅<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHFJJE">示例2-51</a> ）。您可以创建从<code class="codeph">1</code> （默认）到<code class="codeph">4</code>副本。
                                 </p>
                                 <p>RMAN可以将备份双工复制到磁盘或磁带，但不能同时将备份复制到磁带和磁盘。备份到磁带时，请确保副本数量不超过可用磁带设备的数量。此外，如果<code class="codeph">COPIES</code>大于1，那么<a id="d28529e1986" class="indexterm-anchor"></a><a id="d28529e1988" class="indexterm-anchor"></a><a id="d28529e1992" class="indexterm-anchor"></a>必须在目标数据库上启用<code class="codeph">BACKUP_TAPE_IO_SLAVES</code>初始化参数。
                                 </p>
                                 <p>控制文件自动备份从不双工。此外，快速恢复区域不允许双工。</p>
                                 <p>如果在<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令或<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">BACKUP</code> <code class="codeph">COPIES</code>命令中指定了双工，则会覆盖<code class="codeph">CONFIGURE</code>设置。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2021" headers="d28529e1922 "><code class="codeph">BACKUP OPTIMIZATION</code> <code class="codeph">[ON | OFF | CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2021 d28529e1925 ">
                                 <p>切换备份优化<code class="codeph">ON</code>或<code class="codeph">OFF</code> （默认值）。指定<code class="codeph">CLEAR</code>以将优化返回到其默认值<code class="codeph">OFF</code> 。</p>
                                 <p>满足以下所有条件时启用备份优化：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>已运行<code class="codeph">CONFIGURE</code> <code class="codeph">BACKUP</code> <code class="codeph">OPTIMIZATION</code> <code class="codeph">ON</code>命令。
                                       </p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">ALL</code>或<code class="codeph">LIKE</code>选项运行<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code> <code class="codeph">DATABASE</code> ， <code class="codeph">BACKUP ARCHIVELOG</code> ， <code class="codeph">BACKUP BACKUPSET ALL</code> ， <code class="codeph">BACKUP RECOVERY AREA</code> ， <code class="codeph">BACKUP RECOVERY FILES</code>或<code class="codeph">BACKUP DATAFILECOPY</code> 。</p>
                                    </li>
                                    <li>
                                       <p>RMAN作业使用仅一种设备类型的通道。</p>
                                    </li>
                                 </ul>
                                 <p>如果已在设备类型上备份相同的文件，则优化会阻止RMAN将文件备份到设备类型。如果备份优化导致在备份期间跳过所有文件，则RMAN不会发出错误信号。备份保留策略会影响备份优化跳过的文件。</p>
                                 <p><a id="d28529e2099" class="indexterm-anchor"></a><a id="d28529e2101" class="indexterm-anchor"></a>要使两个文件完全相同，其内容必须满足<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__G1028761" title="描述跳过备份的标准，因为文件是相同的">表2-3中</a>所述的要求。在磁盘上或Oracle Secure Backup管理的介质上创建备份片段时，优化会在数据不属于活动事务时从备份中排除撤消数据。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph">BACKUP ...DELETE INPUT</code>删除所有指定的归档重做日志，无论优化是否会在备份期间跳过这些文件。
                                 </p>
                                 <p><span class="bold">注意：</span> <a id="d28529e2122" class="indexterm-anchor"></a><a id="d28529e2124" class="indexterm-anchor"></a>您可以使用<code class="codeph">BACKUP</code>命令的<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50__CHDGFFBB">FORCE</a></code>选项覆盖备份优化。
                                 </p>
                                 <p><span class="bold">另请参阅：“</span> <a href="../bradv/configuring-rman-client-basic.html#BRADV113" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”</span></a> ，以获取有关RMAN如何确定可以跳过文件备份的说明</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2146" headers="d28529e1922 "><code class="codeph">EXCLUDE FOR TABLESPACE</code> <span class="italic"><code class="codeph">tablespace_name</code></span> <code class="codeph">[CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2146 d28529e1925 ">
                                 <p>从<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code> <code class="codeph">DATABASE</code>和<code class="codeph">RESTORE DATABASE</code>命令中排除指定的表空间（请参阅<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDDFAA">示例2-53</a> ）。您不能排除<code class="codeph">SYSTEM</code>表空间。
                                 </p>
                                 <p><code class="codeph">BACKUP</code>命令默认不排除表空间。您必须声明使用它的选项。排除存储为表空间的属性，而不是存储在单个数据文件中。以这种方式，排除不仅适用于当前的数据文件集，而且适用于将来添加到此表空间的任何文件。如果你运行<code class="codeph">CONFIGURE ...在排除表空间后CLEAR</code>它，然后返回默认配置nonexclusion。
                                 </p>
                                 <p>您仍然可以通过在<code class="codeph">BACKUP</code>命令中显式指定或通过在<code class="codeph">BACKUP</code> <code class="codeph">DATABASE</code>命令上指定<code class="codeph">NOEXCLUDE</code>选项来<code class="codeph">BACKUP</code>排除的表空间。同样，您可以通过在<code class="codeph">RESTORE TABLESPACE</code>命令中指定它来还原已排除的表空间。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2201" headers="d28529e1922 "><code class="codeph">EXCLUDE FOR TABLESPACE</code> <span class="italic"><code class="codeph">pdb_name:tablespace_name</code></span> <code class="codeph">[CLEAR]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2201 d28529e1925 ">
                                 <p>PDB中表空间的名称。多个PDB可以具有相同名称的表空间。名称前面的限定符唯一标识表空间。 <span class="italic"><code class="codeph">pdb-name</code></span>是PDB的名称。</p>
                                 <p>请参阅前面的<code class="codeph">EXCLUDE FOR TABLESPACE</code>描述。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2224" headers="d28529e1922 ">
                                 <p><code class="codeph">MAXSETSIZE</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2224 d28529e1925 ">
                                 <p>指定在通道上创建的每个备份集的最大大小。使用<code class="codeph">CLEAR</code>选项将<code class="codeph">MAXSETSIZE</code>返回到<code class="codeph">UNLIMITED</code>的默认值。</p>
                                 <p><span class="bold">注意：</span> <code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code> <code class="codeph">AS</code> <code class="codeph">COPY</code>忽略此选项。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2256" headers="d28529e1922 ">
                                 <p><code class="codeph">TO</code> <span class="italic"><code class="codeph">sizeSpec</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2256 d28529e1925 ">
                                 <p>将每个备份集的最大大小指定为<span class="italic"><code class="codeph">integer</code></span>千兆字节，千字节或兆字节。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2272" headers="d28529e1922 ">
                                 <p><code class="codeph">无限</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2272 d28529e1925 ">
                                 <p>指定备份集没有大小限制。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2280" headers="d28529e1922 ">
                                 <p><code class="codeph" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__BGBDJIHJ">保留政策</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2280 d28529e1925 ">
                                 <p>为RMAN标记为过时的备份集和副本指定持久的持续策略，即不需要且有资格删除。</p>
                                 <p>随着时间的推移，RMAN会根据保留策略中指定的条件将备份集和副本标记为已过时。当需要空间时，RMAN会自动删除快速恢复区域中的过时备份集和副本。RMAN不会自动删除快速恢复区域外的过时文件：您必须手动执行<code class="codeph"><a href="DELETE.html#GUID-FB4EAC69-4978-42F7-8B09-77C6736188B3">DELETE</a></code> <code class="codeph">OBSOLETE</code>才能删除它们。
                                 </p>
                                 <p>对于备份，保留策略的基本单位是备份集（不是备份片）或映像副本。例如， <code class="codeph">BACKUP AS BACKUPSET COPIES 4 TABLESPACE users</code>创建一个双工为四个相同备份件的备份集。保留策略将此视为<span class="italic">一个</span>备份，而不是四个单独的备份。
                                 </p>
                                 <p><span class="bold">注意：</span>使用<code class="codeph">CLEAR</code>选项将<code class="codeph">RETENTION POLICY</code>恢复为其默认值<code class="codeph">REDUNDANCY 1</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2319" headers="d28529e1922 ">
                                 <p><code class="codeph">没有</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2319 d28529e1925 ">
                                 <p>禁用保留策略功能。RMAN不会将任何备份集或副本视为过时的。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2327" headers="d28529e1922 "><code class="codeph">TO RECOVERY WINDOW OF</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">DAYS</code> <code class="codeph">TO RECOVERY WINDOW OF</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2327 d28529e1925 ">
                                 <p>指定RMAN可以恢复数据库的时间窗口。</p>
                                 <p>窗口从当前时间（ <code class="codeph">SYSDATE</code> ）延伸到可恢复点，这是您要恢复的最早日期。可恢复性的点是<code class="codeph">SYSDATE</code> - 过去的<span class="italic"><code class="codeph">integer</code></span>天。使用此设置可以还原或恢复已删除的表空间或数据文件。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph">REDUNDANCY</code>和<code class="codeph">RECOVERY WINDOW</code>选项是互斥的。只有一种类型的保留策略可以随时生效。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2362" headers="d28529e1922 ">
                                 <p><code class="codeph">TO REDUNDANCY</code> <span class="italic"><code class="codeph">integer</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2362 d28529e1925 ">
                                 <p>保留每个数据文件和控制文件的<span class="italic"><code class="codeph">integer</code></span>完整或0级备份。默认保留策略设置为<code class="codeph">REDUNDANCY 1</code> 。此设置仅考虑当前的数据文件集。
                                 </p>
                                 <p>如果存在多个数据文件或控制文件的<span class="italic"><code class="codeph">integer</code></span>或0级备份，则RMAN会将这些额外文件标记为过时。然后，RMAN确定最旧的保留备份，并将所有归档重做日志文件和早于此备份的日志备份标记为过时。<code class="codeph">DELETE OBSOLETE</code>命令删除过时的数据文件备份（完整或增量），控制文件备份以及归档日志备份或映像副本。
                                 </p>
                                 <p>以下方案说明了冗余备份策略中冗余的工作原理。假设冗余级别为1。您在星期一中午运行0级数据库备份，在星期二和星期三中午运行1级累积备份，在星期四中午运行0级备份。每次每日备份后立即运行<code class="codeph"><a href="DELETE.html#GUID-FB4EAC69-4978-42F7-8B09-77C6736188B3">DELETE</a></code> <code class="codeph">OBSOLETE</code> 。星期三<code class="codeph">DELETE</code>命令不会删除星期二的1级备份，因为此备份不是多余的：星期二1级备份可用于将星期一0级备份恢复到星期二中午和星期三中午之间的时间。但是，星期四的<code class="codeph">DELETE</code>命令会删除先前的0级和1级备份。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph">REDUNDANCY</code>和<code class="codeph">RECOVERY WINDOW</code>选项是互斥的。只有一种类型的保留策略可以随时生效。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1017491"><span class="bold"><span class="italic">cfauConf</span></span></p>
                  <p>本子条款创建与控制文件自动备份相关的持久配置。</p>
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-C55486B3-E675-484C-8261-AA71845F050E">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes CONFIGURE command cfauConf parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d28529e2430">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d28529e2433">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2438" headers="d28529e2430 ">
                                 <p><code class="codeph" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDCAHE">CONTROLFILE AUTOBACKUP</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2438 d28529e2433 ">
                                 <p>控制控制文件自动备份功能。</p>
                                 <p>默认情况下， <a id="d28529e2447" class="indexterm-anchor"></a><a id="d28529e2453" class="indexterm-anchor"></a>对于CDB和独立数据库，将<code class="codeph">COMPATIBLE</code>初始化参数设置为12.2或更高，将打开控制文件自动备份。
                                 </p>
                                 <p><span class="bold">注意：</span> Oracle建议您启用控制文件自动备份功能。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2466" headers="d28529e2430 ">
                                 <p><code class="codeph">上</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2466 d28529e2433 ">
                                 <p>在以下情况下执行控制文件自动备份：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>在RMAN提示符下发出每个<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>或<code class="codeph"><a href="CREATE-CATALOG.html#GUID-9CFE47C7-2273-48C4-8056-6A4042AF3CDC">CREATE CATALOG</a></code>命令之后。
                                       </p>
                                    </li>
                                    <li>
                                       <p><a id="d28529e2489" class="indexterm-anchor"></a><a id="d28529e2493" class="indexterm-anchor"></a><a id="d28529e2495" class="indexterm-anchor"></a>每当<code class="codeph"><a href="RUN.html#GUID-88250EEF-DC49-42A9-822C-4011B1345C7B">RUN</a></code>块中的<code class="codeph">BACKUP</code>命令后跟一个非<code class="codeph">BACKUP</code>的命令。</p>
                                    </li>
                                    <li>
                                       <p>如果块中的最后一个命令是<code class="codeph">BACKUP</code>则在每个<code class="codeph">RUN</code>块的末尾。</p>
                                    </li>
                                    <li>
                                       <p>在<code class="codeph">ARCHIVELOG</code>模式下对数据库进行结构更改之后。在<code class="codeph">NOARCHIVELOG</code>模式下，数据库不会发生结构更改后的自动备份。
                                       </p>
                                       <p>结构更改包括添加表空间，更改表空间或数据文件的状态（例如，使其联机），添加新的联机重做日志，重命名文件，添加新的重做线程，启用或禁用闪回数据库等等。与上述情况下发生的自动备份不同，此类自动备份仅适用于磁盘。您可以运行<code class="codeph">CONFIGURE CONTROLFILE AUTOBACKUP FOR DEVICE TYPE DISK</code>来设置非默认磁盘位置。
                                       </p>
                                       <p>从Oracle <span class="italic">11g</span>第2版开始，RMAN创建一个自动备份文件，其中包含在几分钟内发生的所有结构更改，而不是在对数据库的每次结构更改时创建控制文件的新备份。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>在备份或复制作业期间分配的第一个通道创建自动备份并将其放入其自己的备份集中;对于后结构自动备份，默认磁盘通道进行备份。RMAN将控制文件和服务器参数文件写入同一备份片。控制文件自动备份完成后，数据库会将包含备份片段的完整路径和设备类型的消息写入警报日志。</p>
                                 <p>磁盘上自动备份的默认位置是快速恢复区域（如果已配置）或特定于平台的位置（如果未配置）。RMAN使用默认格式<a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED__BABBCDDA">％F</a>自动备份当前控制文件。您可以使用<code class="codeph">CONFIGURE CONTROLFILE AUTOBACKUP FORMAT</code>和<code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">CONTROLFILE AUTOBACKUP FORMAT</code>命令更改位置和文件名格式。
                                 </p>
                                 <p>您无法配置RMAN以将自动备份写入多个位置。要创建多个控制文件备份，可以将备份作业中的最后一个命令设置为<code class="codeph">BACKUP CURRENT CONTROLFILE FORMAT</code>命令，该命令将控制文件备份到指定的<code class="codeph">FORMAT</code>位置，然后执行自动备份。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph"><a href="SET.html#GUID-BC501B5C-4CD0-485D-AA18-27E2894024C3">SET</a></code> <code class="codeph">CONTROLFILE AUTOBACKUP FORMAT</code>命令（可在<code class="codeph">RUN</code>块或RMAN提示符下指定）仅在会话中覆盖已配置的自动备份格式。优先顺序是：</p>
                                 <ol>
                                    <li>
                                       <p>在<code class="codeph">RUN</code>块内<code class="codeph">SET</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">SET</code>在<code class="codeph">RMAN</code>提示</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">配置CONTROLFILE AUTOBACKUP格式</code></p>
                                    </li>
                                 </ol>
                                 <p>即使<code class="codeph">CONFIGURE CONTROLFILE AUTOBACKUP</code>设置为<code class="codeph">OFF</code> ，您也可以配置自动备份格式，但在这种情况下RMAN不会生成自动备份。要使RMAN进行自动备份，必须将<code class="codeph">CONFIGURE CONTROLFILE AUTOBACKUP</code>设置为<code class="codeph">ON</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2614" headers="d28529e2430 ">
                                 <p><code class="codeph">关闭</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2614 d28529e2433 ">
                                 <p>禁用自动备份功能（默认）。</p>
                                 <p>包含数据文件<code class="codeph">1</code>任何<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令都自动包括备份集中的当前控制文件和服务器参数文件。否则，RMAN不包含这些文件。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2632" headers="d28529e2430 ">
                                 <p><code class="codeph">明确</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e2632 d28529e2433 ">
                                 <p>将此配置返回到其默认设置<code class="codeph">OFF</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2643" headers="d28529e2430 "><code class="codeph">DEVICE TYPE</code> <code class="codeph">FORMAT FOR</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span> <code class="codeph">TO</code> <span class="italic"><code class="codeph"><a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED">formatSpec</a></code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2643 d28529e2433 ">
                                 <p><a id="d28529e2666" class="indexterm-anchor"></a>在指定的设备类型上配置控制文件自动备份的默认位置和文件名格式（请参见<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDFCFBB">示例2-55</a> ）。
                                 </p>
                                 <p>默认情况下，所有设备的格式均为<a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED__BABBCDDA">％F</a> 。使用<code class="codeph">CONFIGURE</code>指定的任何默认格式字符串都必须包含<code class="codeph">%F</code>替换变量。使用任何其他替换变量都是错误的。指定<code class="codeph">CLEAR</code>以将格式返回到默认<code class="codeph">%F</code> 。</p>
                                 <p><a id="d28529e2689" class="indexterm-anchor"></a>如果启用了快速恢复区域，并且格式为默认值<code class="codeph">'%F'</code> ，则RMAN会在名为<code class="codeph">autobackup</code>的目录中的恢复区域中创建自动<code class="codeph">autobackup</code> 。否则，默认的自动备份位置是特定于操作系统的位置（ <code class="codeph">?UNIX，Linux和Windows上的/dbs</code> ）。
                                 </p>
                                 <p>串<code class="codeph"># default</code>在输出<code class="codeph">SHOW</code>时RMAN使用默认格式命令指示。如果手动将磁盘格式配置为<code class="codeph">'%F'</code> ，则即使启用了恢复区，RMAN也会在特定于操作系统的默认位置创建自动备份。要将格式更改回其默认值以便RMAN在恢复区域中创建自动备份，请运行“ <code class="codeph">CONFIGURE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK CLEAR</code>自动备份<code class="codeph">CONFIGURE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK CLEAR</code> 。</p>
                                 <p><span class="italic"><code class="codeph"><a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED">formatSpec</a></code></span>可以指定<a id="d28529e2725" class="indexterm-anchor"></a>自动存储管理磁盘组。以下示例为ASM磁盘组配置通道：</p><pre class="oac_no_warn" dir="ltr">配置CONTROLFILE AUTOBACKUP设备类型磁盘为'+ dgroup1';</pre><p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED">formatSpec</a></code></span> ，了解<code class="codeph">%F</code>替换变量的语义</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1019177"><span class="bold"><span class="italic">deviceConf</span></span></p>
                  <p>本子条款创建与通道和设备相关的持久配置。</p>
                  <p><span class="bold">已配置频道的名称</span></p>
                  <p><a id="d28529e2755" class="indexterm-anchor"></a> RMAN确定已配置通道的名称。RMAN使用以下约定： <code class="codeph">ORA_</code> <span class="italic"><code class="codeph">devicetype</code></span> <code class="codeph">_</code> <span class="italic"><code class="codeph">n</code></span> ，其中<span class="italic"><code class="codeph">devicetype</code></span>是指用户设备类型（例如<code class="codeph">DISK</code>或<code class="codeph">sbt_tape</code> ）， <span class="italic"><code class="codeph">n</code></span>是指通道号。以<code class="codeph">ORA_</code>前缀开头的通道名称由RMAN保留供自己使用。您无法手动分配名称以<code class="codeph">ORA_</code>开头的<code class="codeph">ORA_</code> 。
                  </p>
                  <div class="infoboxnote" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-BEB78C24-B06C-4FA2-9FAB-C02C6241D772">
                     <p class="notep1">注意：</p>
                     <p>该<code class="codeph">sbt</code>和<code class="codeph">sbt_tape</code>设备类型是同义的，但RMAN输出总是显示<code class="codeph">sbt_tape</code>输入是否是<code class="codeph">sbt</code>或<code class="codeph">sbt_tape</code> 。
                     </p>
                  </div>
                  <p>RMAN命名第一个<code class="codeph">DISK</code>通道<code class="codeph">ORA_DISK_1</code> ，第二个<code class="codeph">ORA_DISK_2</code> ，依此类推。RMAN名称第一<code class="codeph">sbt</code>通道<code class="codeph">ORA_SBT_TAPE_1</code> ，第二<code class="codeph">ORA_SBT_TAPE_2</code> ，等等。并行化通道时，RMAN始终按数字顺序分配通道，从1开始，以并行设置结束（ <code class="codeph">CONFIGURE DEVICE TYPE ...PARALLELISM</code> <span class="italic"><code class="codeph">n</code></span> ）。
                  </p>
                  <p>要在特定配置的通道上运行<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>或作业，请使用系统生成的通道名称。如果在<code class="codeph">CONFIGURE CHANNEL</code>命令中指定通道编号（请参阅<span class="italic"><code class="codeph"><a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__I1019177">deviceConf</a></code></span>子句），则RMAN在系统生成的通道名称中使用相同的编号。
                  </p>
                  <p>自动通道分配也适用于维护命令。如果RMAN分配自动维护通道，则它使用与任何其他自动分配通道相同的命名约定。</p>
                  <p><span class="bold">Oracle RAC环境中的已配置通道</span></p>
                  <p>在Oracle RAC环境中使用RMAN时，Oracle建议您指定<code class="codeph">TARGET</code>连接字符串，以在群集中的各种实例上建立会话，具体取决于其负载和可用性。
                  </p>
                  <p>Oracle建议不要使用<code class="codeph">CONNECT</code>选项配置各个通道以连接到特定的Oracle RAC实例，因为它们会使RMAN脚本依赖于通道配置中指定的特定实例。如果其中一个实例不可用，则备份脚本无法运行。使用负载平衡连接字符串可使RMAN脚本更易于编码，并且可以更好地适应单个实例故障。
                  </p>
                  <p>如果您决定使用<code class="codeph">CONNECT</code>选项将RMAN通道定向到特定节点，则Oracle强烈建议您不要在通道配置中使用密码。如果具有每个实例的<code class="codeph">SYSACKUP</code>权限的用户的密码与<code class="codeph">TARGET</code>连接中的密码相同，则只需使用<code class="codeph">CONNECT "@</code> <span class="italic"><code class="codeph">nodename</code></span> <code class="codeph">"</code>配置通道。RMAN使用<code class="codeph">TARGET</code>连接中的用户ID和密码连接到该通道。
                  </p>
                  <div class="tblformalwide" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-2C72BC97-C9F3-4967-80B2-813D2447F8E3">
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="Describes CONFIGURE command deviceConf parameters" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d28529e2900">语法元素</th>
                              <th align="left" valign="bottom" width="71%" id="d28529e2903">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e2908" headers="d28529e2900 "><code class="codeph">[AUXILIARY] CHANNEL [</code> <span class="italic"><code class="codeph">integer</code></span> <code class="codeph">]</code> <code class="codeph">DEVICE TYPE</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e2908 d28529e2903 ">
                                 <p>指定要配置或清除的标准或<code class="codeph">AUXILIARY</code>通道，以及通道的设备类型。
                                 </p>
                                 <p><span class="bold">注意：</span>在<code class="codeph">RUN</code>命令中使用<code class="codeph"><a href="ALLOCATE-CHANNEL.html#GUID-9320BFF7-0728-4B3D-85B9-2184557ECDCE">ALLOCATE CHANNEL</a></code>分配的<code class="codeph"><a href="ALLOCATE-CHANNEL.html#GUID-9320BFF7-0728-4B3D-85B9-2184557ECDCE">ALLOCATE CHANNEL</a></code>会覆盖已配置的自动通道。
                                 </p>
                                 <p>配置通用通道或指定通道编号，其中<span class="italic"><code class="codeph">integer</code></span>小于<code class="codeph">255</code> 。有关编号通道的说明，请参见<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDDFAA">例2-53</a> 。
                                 </p>
                                 <p><a id="d28529e2956" class="indexterm-anchor"></a><a id="d28529e2958" class="indexterm-anchor"></a>如果指定了<code class="codeph">AUXILIARY</code> ，则此配置仅用于在辅助实例处分配的通道。如果辅助通道需要与目标实例分配的通道不同的参数，请指定辅助通道的配置信息。如果未指定辅助设备配置，则RMAN使用目标数据库设备配置配置任何辅助通道。
                                 </p>
                                 <p>您必须至少指定一个频道选项。例如，您不能发出诸如<code class="codeph">CONFIGURE CHANNEL 2 DEVICE TYPE DISK</code>的命令，但您可以发出命令，例如<code class="codeph">CONFIGURE CHANNEL 2 DEVICE TYPE DISK MAXPIECESIZE 2500K</code> 。</p>
                                 <p>对于指定设备类型的通用通道，新命令会删除此设备类型的先前设置。假设您运行以下命令：</p><pre class="oac_no_warn" dir="ltr">配置通道设备类型sbt MAXPIECESIZE 1G; CONFIGURE CHANNEL DEVICE TYPE sbt FORMAT'bkup_％U';</pre><p>第二个命令删除第一个命令的<code class="codeph">MAXPIECESIZE</code>设置。
                                 </p>
                                 <p><span class="bold">注意：</span> RMAN不会在<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令中同时为多种设备类型分配自动通道。
                                 </p>
                                 <p><span class="bold">另请参阅：</span> <a href="../bradv/configuring-rman-client-advanced.html#BRADV134" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南</span></a> ，了解如何配置通道编号指定的自动通道</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3000" headers="d28529e2900 ">
                                 <p><code class="codeph">   </code><span class="italic"><code class="codeph"><a href="allocOperandList.html#GUID-8B6C1DAB-F27A-4DA8-BECC-5DA04F5907DA">allocOperandList</a></code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e3000 d28529e2903 ">
                                 <p>指定已配置通道的控制选项。</p>
                                 <p>如果使用非默认<code class="codeph">CONNECT</code>或<code class="codeph">PARMS</code>选项配置通道以创建备份或副本，则必须使用相同的已配置通道或手动分配具有相同选项的通道以还原或交叉检查这些备份。
                                 </p>
                                 <p><code class="codeph">FORMAT</code>参数可以指定自动存储管理磁盘组。以下示例为ASM磁盘组配置通道：</p><pre class="oac_no_warn" dir="ltr">CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT'+ dgroup1';</pre><p><span class="bold">另请参见：</span> <span class="italic"><code class="codeph"><a href="allocOperandList.html#GUID-8B6C1DAB-F27A-4DA8-BECC-5DA04F5907DA">allocOperandList</a></code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3037" headers="d28529e2900 ">
                                 <p><code class="codeph">明确</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e3037 d28529e2903 ">
                                 <p>清除指定的频道。例如， <code class="codeph">CONFIGURE CHANNEL 1 DEVICE TYPE DISK CLEAR</code>仅将通道1恢复为默认值，而<code class="codeph">CONFIGURE CHANNEL DEVICE TYPE DISK CLEAR</code>则将通用磁盘通道恢复为默认值。指定<code class="codeph">CLEAR</code>时，不能指定任何其他通道选项（例如， <code class="codeph">PARMS</code> ）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3057" headers="d28529e2900 "><code class="codeph">DEFAULT DEVICE TYPE TO</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e3057 d28529e2903 ">
                                 <p>指定自动通道的默认设备类型。默认情况下， <code class="codeph">DISK</code>是默认设备类型。<code class="codeph">CLEAR</code>将默认设备类型返回<code class="codeph">DISK</code> 。</p>
                                 <p>默认情况下， <code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令仅分配默认设备类型的通道。例如，如果为<code class="codeph">DISK</code>和<code class="codeph">sbt</code>配置自动通道并将默认设备类型设置为<code class="codeph">sbt</code> ，则RMAN仅在运行<code class="codeph">BACKUP DATABASE</code>命令时分配磁带通道。您可以通过在<code class="codeph">RUN</code>命令中手动分配通道，或通过在<code class="codeph">BACKUP</code>命令本身上指定<code class="codeph">DEVICE TYPE</code>来覆盖此行为（请参阅<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHFJJE">示例2-51</a> ）。
                                 </p>
                                 <p>无论默认设备类型如何， <code class="codeph"><a href="RESTORE.html#GUID-4491C03F-C5F8-43E5-B4C4-FE26C70F2E9B">RESTORE</a></code>命令都会分配所有已配置设备类型的自动通道。<code class="codeph">RESTORE</code>命令遵循每个已配置设备类型的<code class="codeph">PARALLELISM</code>设置。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3123" headers="d28529e2900 "><code class="codeph">DEVICE TYPE</code> <span class="italic"><code class="codeph"><a href="deviceSpecifier.html#GUID-F653748D-4AB5-4A0E-B6E5-D891A000ADAC">deviceSpecifier</a></code></span></td>
                              <td align="left" valign="top" width="71%" headers="d28529e3123 d28529e2903 ">
                                 <p>指定要应用此<code class="codeph">CONFIGURE</code>命令中指定的设置的设备类型（磁盘或sbt）。<code class="codeph">CLEAR</code>选项将此设备的备份类型和并行设置重置为其默认值。
                                 </p>
                                 <p>如果运行<code class="codeph">CONFIGURE DEVICE TYPE</code>命令<code class="codeph">CONFIGURE DEVICE TYPE</code>默认设置，并且不为此设备类型运行<code class="codeph">CONFIGURE CHANNEL</code> ，则RMAN将分配所有通道而不使用其他通道控制选项。假设您配置<code class="codeph">sbt</code>设备并运行备份，如下所示：</p><pre class="oac_no_warn" dir="ltr">配置设备类型sbt PARALLELISM 1;备份设备类型sbt数据库;</pre><p>实际上，RMAN在执行此备份时执行以下操作：</p><pre class="oac_no_warn" dir="ltr">运行{ALLOCATE CHANNEL ORA_SBT_TAPE_1设备类型sbt;备份数据库; }</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3159" headers="d28529e2900 "><code class="codeph">BACKUP TYPE TO</code> <code class="codeph">[[COMPRESSED]</code> <code class="codeph">BACKUPSET | COPY]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e3159 d28529e2903 ">
                                 <p>配置磁盘或磁带备份的默认备份类型。对于SBT设备，不支持<code class="codeph">COPY</code>选项。磁盘的默认值是<code class="codeph">BACKUPSET</code> 。</p>
                                 <p>如果<code class="codeph">BACKUP TYPE</code>设置为<code class="codeph">BACKUPSET</code> ，则<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令始终生成备份集，而不管创建备份的媒体是什么。使用<code class="codeph">COMPRESSED</code>选项，生成的备份集使用二进制压缩。
                                 </p>
                                 <p>磁盘备份的默认位置是快速恢复区域（如果已配置）;否则，RMAN将备份存储在特定于平台的位置。备份文件名的默认格式为<code class="codeph"><a href="formatSpec.html#GUID-E51F637A-57E0-4B06-803F-3F879DF5BEED__BABGHHGH">%U</a></code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3200" headers="d28529e2900 ">
                                 <p><code class="codeph">PARALLELISM</code> <span class="italic"><code class="codeph">integer</code></span></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d28529e3200 d28529e2903 ">
                                 <p>配置为RMAN作业分配的指定设备类型的自动通道数。默认情况下， <code class="codeph">PARALLELISM</code>设置为<code class="codeph">1</code> 。
                                 </p>
                                 <p><span class="bold">注意：</span> <code class="codeph">CONFIGURE ...PARALLELISM</code>参数指定通道并行度，即RMAN在备份和还原操作期间分配的通道数。<code class="codeph">RECOVERY_PARALLELISM</code>初始化参数指定实例恢复中使用的进程数。
                                 </p>
                                 <p>假设您将磁盘备份的<code class="codeph">PARALLELISM</code>设置为<code class="codeph">2</code> （请参阅<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHAFGH">示例2-52</a> ）。如果将默认设备类型设置为磁盘，则在RMAN提示符下运行<code class="codeph">BACKUP DATABASE</code>时，RMAN会分配两个磁盘通道。RMAN总是分配<code class="codeph">PARALLELISM</code>设置的通道数，尽管它可能只使用这些通道的子集。
                                 </p>
                                 <p><span class="bold">注意：</span>如果配置<span class="italic"><code class="codeph">n</code></span>手动编号的通道，则<code class="codeph">PARALLELISM</code>设置可以大于或小于<span class="italic"><code class="codeph">n</code></span> 。例如，您可以手动编号10个自动通道，并将<code class="codeph">PARALLELISM</code>配置为<code class="codeph">2</code>或<code class="codeph">12</code> 。
                                 </p>
                                 <p>要将设备类型的并行度更改为<span class="italic"><code class="codeph">n</code></span> ，请运行新的<code class="codeph">CONFIGURE DEVICE TYPE ...PARALLELISM</code> <span class="italic"><code class="codeph">n</code></span>命令。例如，您可以将<code class="codeph">sbt</code> configure <code class="codeph">PARALLELISM</code>更改为<code class="codeph">3</code> ，然后将其更改为<code class="codeph">2</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">配置设备类型sbt PARALLELISM 3;配置设备类型sbt PARALLELISM 2;</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d28529e3297" headers="d28529e2900 "><code class="codeph">SPARSE [ON | OFF]</code></td>
                              <td align="left" valign="top" width="71%" headers="d28529e3297 d28529e2903 ">在对稀疏数据文件执行备份和恢复之前，将数据库的设备类型配置为稀疏或非稀疏。仅当数据库的<code class="codeph">COMPATIBLE</code>初始化参数设置为12.2或更高时，才能使用此设置。
                                 <p>如果<code class="codeph">SPARSE</code>设置设置为<code class="codeph">ON</code> ，则<code class="codeph">BACKUP</code>命令将创建稀疏备份， <code class="codeph">RESTORE</code>命令将从稀疏备份执行还原操作。如果设备的<code class="codeph">SPARSE</code>设置设置为<code class="codeph">OFF</code> ，则RMAN将继续像以前一样执行数据库备份和还原操作。
                                 </p>
                                 <p>如果数据库的<code class="codeph">COMPATIBLE</code>设置为12.2或更高，则<code class="codeph">ON</code>是默认设置。此设置将覆盖数据库的默认稀疏模式。
                                 </p>
                                 <p>有关稀疏数据库的详细信息，请参见“ <span class="italic">Oracle数据库备份和恢复用户指南”</span></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <!-- class="section" -->
               <div class="section" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDDCBH">
                  <p class="subhead1" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-6316B87B-E743-47B5-9D45-93AE0AB4D908">例子</p>
               </div>
               <!-- class="section" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-DAA9FDB0-1FF7-4368-B901-853525704C73">
                  <p class="titleinexample">示例2-50配置设备和备份选项</p>
                  <p>此示例配置设备类型<code class="codeph">DISK</code>和<code class="codeph">sbt</code>通道，并将默认设备类型设置为<code class="codeph">sbt</code> 。该示例还启用了备份优化并配置了两周的恢复窗口。
                  </p><pre class="oac_no_warn" dir="ltr">CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT'/ disk1 / backups /％U'; CONFIGURE CHANNEL DEVICE TYPE sbt PARMS'ENV =（OB_DEVICE_1 = tape1）';配置默认设备类型为sbt;配置备份优化;配置保留政策，以恢复14天的窗口;</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHFJJE">
                  <p class="titleinexample">例2-51覆盖默认设备类型</p>
                  <p><a id="d28529e3362" class="indexterm-anchor"></a><a id="d28529e3366" class="indexterm-anchor"></a>此示例将双工配置为<code class="codeph">2</code>用于<code class="codeph">DISK</code>备份数据文件和控制文件（磁盘上的控制文件自动备份是特殊情况，并且从不双工），然后将<code class="codeph">sbt</code>配置为默认设备。
                  </p><pre class="oac_no_warn" dir="ltr">配置数据文件备份复制设备类型磁盘为2; CONFIGURE CHANNEL DEVICE TYPE sbt PARMS'ENV =（OB_DEVICE_1 = tape1）';配置默认设备类型为sbt;</pre><p>第一个<code class="codeph"><a href="BACKUP.html#GUID-73642FF2-43C5-48B2-9969-99001C52EB50">BACKUP</a></code>命令备份默认<code class="codeph">sbt</code>通道上的归档重做日志文件。第二个<code class="codeph">BACKUP</code>命令将数据库备份到磁盘位置。由于为磁盘备份启用了双工，因此会创建每个输出备份集的两个副本。
                  </p><pre class="oac_no_warn" dir="ltr">备份ARCHIVELOG ALL; BACKUP DEVICE TYPE DISK DATABASE FORMAT'/ disk1 / db_backup_％U'，'/ disk2 / db_backup_％U';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHAFGH">
                  <p class="titleinexample">示例2-52跨文件系统配置自动通道</p>
                  <p>此示例在两个文件系统中配置自动磁盘通道：</p><pre class="oac_no_warn" dir="ltr">配置设备类型磁盘并行2; CONFIGURE CHANNEL 1 DEVICE TYPE DISK FORMAT'/ disk1 /％U'; CONFIGURE CHANNEL 2 DEVICE TYPE DISK FORMAT'/ disk2 /％U';</pre><p>由于<code class="codeph">PARALLELISM</code>设置为<code class="codeph">2</code> ，因此以下命令将输出数据分为两个文件系统：</p><pre class="oac_no_warn" dir="ltr">备份设备类型磁盘数据库加ARCHIVELOG;</pre><p>以下<code class="codeph">LIST</code>命令显示如何并行化数据文件备份：</p><pre class="oac_no_warn" dir="ltr">RMAN&gt; LIST BACKUPSET 2031,2032;备份集列表=================== BS密钥类型LV大小设备类型经过时间完成时间------- ------ --- ------- ----------- ------------ --------------- 2031全401.99M磁碟00:00:57 19-JAN-13 BP密钥：2038状态：AVAILABLE压缩：否标签：TAG20130119T100532件名：/ disk1 / 24i7ssnc_1_1备份集中的数据文件列表2031文件LV类型Ckp SCN Ckp时间名称----- -  ---- ---------- --------- ---- 1 Full 973497 19-JAN-13 /disk3/oracle/dbs/t_db1.f 5 Full 973497 19 -JAN-13 /disk3/oracle/dbs/tbs_112.f BS密钥类型LV大小设备类型经过时间完成时间------- ----  -  ----------- --------- ------------ --------------- 2032 Full 133.29M DISK 00:00:57 19-JAN- 13 BP密钥：2039状态：可用压缩：否标签：TAG20130119T100532件名：/ disk2 / 25i7ssnc_1_1备份集中的数据文件列表2032文件LV类型Ckp SCN Ckp时间名称----  -  ---- ---- ------ --------- ---- 2 Full 973501 19-JAN-13 /disk3/oracle/dbs/t_ax1.f 3 Full 973501 19-JAN-13 / disk3 / oracle / D b s / t_undo1.f 4 Full 973501 19-JAN-13 /disk3/oracle/dbs/tbs_111.f</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDDDFAA">
                  <p class="titleinexample">示例2-53在Oracle Real Application Clusters（Oracle RAC）配置中配置自动通道</p>
                  <p><a id="d28529e3423" class="indexterm-anchor"></a><a id="d28529e3427" class="indexterm-anchor"></a>此示例假定具有两个节点的Oracle RAC数据库。Oracle Secure Backup是媒体管理器。磁带机<code class="codeph">tape1</code>直接连接到<code class="codeph">node1</code> ，而磁带机<code class="codeph">tape2</code>直接连接到<code class="codeph">node2</code> 。该示例为每个群集节点配置自动SBT通道。
                  </p>
                  <p>此示例说明了与Oracle RAC实例<code class="codeph">node1</code>和<code class="codeph">node2</code>通道连接。对于两个通道连接，RMAN使用为目标数据库连接输入的相同用户名和密码。
                  </p><pre class="oac_no_warn" dir="ltr">配置设备类型sbt PARALLELISM 2;配置默认设备类型为sbt; CONFIGURE CHANNEL 1 DEVICE TYPE sbt CONNECT'@ node1'PARMS'ENV =（OB_DEVICE = tape1）'; CONFIGURE CHANNEL 2 DEVICE TYPE sbt CONNECT'@ node2'PARMS'ENV =（OB_DEVICE = tape2）';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDHHHDF">
                  <p class="titleinexample">示例2-54配置辅助文件名</p>
                  <p>此示例使用<code class="codeph">CONFIGURE AUXNAME</code>为数据文件指定新文件名。<code class="codeph"><a href="DUPLICATE.html#GUID-E13D8A02-80F9-49A2-9C31-92DD3A795CE4">DUPLICATE</a></code>命令将数据库复制到具有不同目录结构的远程主机。
                  </p><pre class="oac_no_warn" dir="ltr">＃设置数据文件的辅助名称配置数据文件的AUXNAME 1到'/oracle/auxfiles/aux_1.f';将数据文件2的AUXNAME配置为'/oracle/auxfiles/aux_2.f';将DATAFILE 3的AUXNAME配置为'/oracle/auxfiles/aux_3.f';将数据文件4的AUXNAME配置为'/oracle/auxfiles/aux_4.f';运行{ALLOCATE AUXILIARY CHANNEL dupdb1 TYPE DISK; DUPLICATE TARGET DATABASE到dupdb LOGFILE GROUP 1（'？/dbs/dupdb_log_1_1.f'，'？/dbs/dupdb_log_1_2.f'）SIZE 4M，GROUP 2（'？/dbs/dupdb_log_2_1.f'，'？/dbs/dupdb_log_2_2.f'）SIZE 4M REUSE; }＃不指定数据文件的辅助名称，以免错误地覆盖它们：CONFIGURE AUXNAME FOR DATAFILE 1 CLEAR;配置数据文件的AUXNAME 2清除;配置数据文件的AUXNAME 3清除;配置数据文件的AUXNAME 4清除;</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDFCFBB">
                  <p class="titleinexample">例2-55指定控制文件自动备份的默认格式</p>
                  <p>以下示例启用自动备份功能并配置<code class="codeph">DISK</code>和<code class="codeph">sbt</code>设备的默认自动备份格式：</p><pre class="oac_no_warn" dir="ltr">配置CONTROLFILE AUTOBACKUP ON;设备类型磁盘的配置控制文件自动包装格式为'/ disk2 /％F';配置CONTROLFILE AUTOBACKUP格式为设备类型sbt为'cf_auto_％F';</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__CHDEIDFD">
                  <p class="titleinexample">示例2-56创建备用数据库的配置</p>
                  <p>假设主数据库<code class="codeph">prod</code>与两个备用数据库关联，其中<code class="codeph">DB_UNIQUE_NAME</code>命名为<code class="codeph">dgprod3</code>和<code class="codeph">dgprod4</code> 。假设您启动RMAN并连接到<code class="codeph">prod</code>作为<code class="codeph">TARGET</code>并连接到恢复目录。以下命令配置数据库<code class="codeph">dgprod3</code>和<code class="codeph">dgprod4</code>的默认设备类型。
                  </p><pre class="oac_no_warn" dir="ltr">配置默认设备类型为DB_UNIQUE_NAME dgprod3;配置设备类型sbt PARALLELISM 2 FOR DB_UNIQUE_NAME dgprod3;配置默认设备类型为DB_UNIQUE_NAME dgprod4磁盘;</pre><p>只有在从恢复目录到控制文件的反向重新同步之后，才会使用配置更新两个备用数据库的控制文件，这在用户第一次连接到<code class="codeph">dgprod3</code>和<code class="codeph">dgprod4</code> 。
                  </p>
                  <p>以下<code class="codeph"><a href="SHOW.html#GUID-6C2AF43B-FADD-41AF-9408-852A69538E2F">SHOW</a></code>命令显示唯一名称为<code class="codeph">dgprod3</code>的数据库的持久性设备类型配置：</p><pre class="oac_no_warn" dir="ltr">RMAN&gt;为DB_UNIQUE_NAME显示设备类型dgprod3;使用db_unique_name DGPROD3的数据库的RMAN配置参数是：配置设备类型'SBT_TAPE'并行2备份类型到BACKUPSET;配置设备类型磁盘并行1备份类型到BACKUPSET; #default</pre><p>以下<code class="codeph">SHOW</code>命令显示恢复目录中已知的所有数据库的持久性配置，其DBID为3257174182（由前面的<code class="codeph">SET DBID</code>命令指定的值）：</p><pre class="oac_no_warn" dir="ltr">显示所有DB_UNIQUE_NAME ALL;</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-684A4786-0167-4995-821E-B7E7B1789FA1">
                  <p class="titleinexample">示例2-57优化备份</p>
                  <p>此方案说明了<a href="CONFIGURE.html#GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__G1028761" title="描述跳过备份的标准，因为文件是相同的">表2-3中</a>描述的备份优化行为。假设禁用了备份优化。上午9点，您将所有现有归档重做日志文件的三个副本备份到磁带。将备份双工复制到磁带时， <code class="codeph">BACKUP_TAPE_IO_SLAVES</code>初始化参数必须为<code class="codeph">true</code> 。
                  </p><pre class="oac_no_warn" dir="ltr">备份设备类型sbt COPIES 3 ARCHIVELOG ALL;</pre><p>上午11点，您启用了备份优化：</p><pre class="oac_no_warn" dir="ltr">配置备份优化;</pre><p>在中午，您运行以下归档重做日志备份：</p><pre class="oac_no_warn" dir="ltr">备份设备类型sbt COPIES 2 ARCHIVELOG ALL;</pre><pre class="oac_no_warn" dir="ltr">使用通道ORA_SBT_TAPE_1在存档的日志文件/d1/db1r_605ab325_1_34_612112605.arc中存档，以19-JAN-13当前日志开始备份;已经备份了3次跳过存档日志文件/d1/db1r_605ab325_1_35_612112605.arc;已经备份了3次跳过存档日志文件/d1/db1r_605ab325_1_36_612112605.arc;已经备份了3次跳过存档日志文件/d1/db1r_605ab325_1_37_612112605.arc;已经备份了3次跳过存档日志文件/d1/db1r_605ab325_1_38_612112605.arc;已经备份了3次跳过存档日志文件/d1/db1r_605ab325_1_39_612112605.arc;已备份3次通道ORA_SBT_TAPE_1：启动归档日志备份集通道ORA_SBT_TAPE_1：指定备份集中的归档日志存档日志thread = 1 sequence = 40 RECID = 170 STAMP = 612270506 channel ORA_SBT_TAPE_1：start piece 1 at 19-JAN-13频道ORA_SBT_TAPE_1：在19-JAN-13完成第1部分，2个拷贝和标签TAG20130119T110827个句柄= 2hi7t0db_1_1评论= API版本2.0，MMS版本10.1.0.0个句柄= 2hi7t0db_1_2评论= API版本2.0，MMS版本10.1.0.0</pre><p>在这种情况下， <code class="codeph">BACKUP</code> <code class="codeph">...</code> <code class="codeph">COPIES</code>设置会覆盖<code class="codeph">CONFIGURE</code> <code class="codeph">...</code> <code class="codeph">COPIES</code>设置，因此RMAN设置<span class="italic"><code class="codeph">n</code></span> <code class="codeph">=2</code> 。仅当<code class="codeph">sbt</code>设备上至少存在两个日志副本时，RMAN才会跳过日志备份。由于在上午9点或之前生成的所有日志的<code class="codeph">sbt</code>上存在每个日志的三个副本，因此RMAN会跳过这些日志的备份。但是，RMAN备份了上午9点之后生成的所有日志的两个副本，因为这些日志尚未备份到磁带。
                  </p>
               </div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-18E85E48-0512-48C9-B05B-FA4D64436A1B">
                  <p class="titleinexample">例2-58配置默认压缩算法</p>
                  <p>此示例假定您拥有数据库的Advanced Compression Option（ACO）的许可证。</p>
                  <p>如果要使<code class="codeph">MEDIUM</code>压缩算法成为所有压缩备份的默认压缩算法，请发出以下命令：</p><pre class="oac_no_warn" dir="ltr">配置压缩算法'MEDIUM';</pre><p>从此时起，您可以通过发出以下命令来使用<code class="codeph">MEDIUM</code>压缩算法：</p><pre class="oac_no_warn" dir="ltr">备份为压缩备份数据库;</pre></div>
               <!-- class="example" -->
               <div class="example" id="GUID-B5094E73-C26C-4FED-AE39-8C2E9540050A__GUID-65CCC5D3-CEA4-4A42-A627-783D9DE85584">
                  <p class="titleinexample">示例2-59配置稀疏备份</p>
                  <p>此示例创建一个持久性配置，默认情况下，该备份配置会以磁盘和备份集格式创建稀疏备份。</p><code class="codeph">配置设备类型磁盘备份类型到BACKUPSET SPARSE ON;</code></div>
               <!-- class="example" -->
            </div>
         </div>
      </article>
   </body>
</html><html id="00928.developing-appc-client-app-sna-only.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>开发客户端应用程序（仅限SNA）</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="User&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="User&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-gateway-appc-users-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-16T18:35:49-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="F18239-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="creating-tip-oracle-database-gateway-appc.html" title="Previous" type="text/html"></link>
      <link rel="next" href="implement-appc-commit-confirm-sna-only.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Gateway for APPC User&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="APPUG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="creating-tip-oracle-database-gateway-appc.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="implement-appc-commit-confirm-sna-only.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">用户指导</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">开发客户端应用程序（仅限SNA）</li>
            </ol>
            <a id="GUID-9D1AFA3A-C1DC-4D52-AAAB-41269D6D5788" name="GUID-9D1AFA3A-C1DC-4D52-AAAB-41269D6D5788"></a><a id="APPUG400"></a>
            
            <h2 id="APPUG-GUID-9D1AFA3A-C1DC-4D52-AAAB-41269D6D5788" class="sect2"><span class="enumeration_chapter">4</span>开发客户端应用程序（仅限SNA）</h2>
         </header>
         <div class="ind">
            <div>
               <p>以下部分讨论如何调用TIP并控制远程主机事务。它还为您提供了准备和执行网关事务的步骤。做出以下假设：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>已经编写了远程主机事务（RHT）</p>
                  </li>
                  <li>
                     <p>已经使用<a href="creating-tip-oracle-database-gateway-appc.html#GUID-78D4439E-7DD6-45DF-842E-35007FCC572B">创建提示中</a>描述的步骤定义了与RHT对应<a href="creating-tip-oracle-database-gateway-appc.html#GUID-78D4439E-7DD6-45DF-842E-35007FCC572B">的提示</a></p>
                     <div class="infoboxnote" id="GUID-9D1AFA3A-C1DC-4D52-AAAB-41269D6D5788__GUID-868E1727-1517-4BC4-865D-38F73C533907">
                        <p class="notep1">注意：</p>
                        <p>如果您的网关使用IMS Connect的TCP / IP支持，请参阅<a href="developing-appc-client-app-tcpip-only.html#GUID-705991C2-2CC2-4FAB-A04C-D63485B571FC">客户端应用程序开发（仅限TCP / IP）</a>以获取有关调用TIP和控制远程主机事务的信息。
                        </p>
                     </div>
                  </li>
               </ul>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-4AF92748-25E4-4262-88D7-742CE302709D">客户端应用程序概述</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-234C85C7-BC32-4B2F-9580-9151360B3DD7">准备客户端应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-BFE11091-D32F-4B66-B48F-5569EB5FAD6E">了解远程主机事务要求</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-30316801-BD91-4799-BAB2-B145F27CD624">每个远程主机事务的自定义TIP</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E">客户申请要求</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-B264D759-308E-46B3-B303-7E651B4AF83C">确保TIP和远程交易程序通信</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-1C0A2278-D220-4DDB-888C-F691D057BB78">从客户端应用程序调用TIP</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-62418ADB-1A9B-4DCC-A2D5-70940D7ECBFC">交换数据</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-19815A38-8520-41D5-9418-2DB46AFDB9AA">执行申请</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-E02BE2D4-97BA-407C-B1D6-4503D79561D7">APPC对话共享</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-2F5FD89A-06E6-47DF-84CD-525B6515B25F">支持多字节字符集的应用程序开发</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-B118F27C-0B26-4429-8B70-3CC5B01C6A93">修改面向终端的事务以使用APPC</a></p>
                  </li>
                  <li>
                     <p><a href="developing-appc-client-app-sna-only.html#GUID-8E530425-F978-4095-8A39-B8FD8BE2A47A">使用TIP所需的权限</a></p>
                  </li>
               </ul>
            </div><a id="APPUG1299"></a><a id="APPUG970"></a><div class="props_rev_3"><a id="GUID-4AF92748-25E4-4262-88D7-742CE302709D" name="GUID-4AF92748-25E4-4262-88D7-742CE302709D"></a><h3 id="APPUG-GUID-4AF92748-25E4-4262-88D7-742CE302709D" class="sect3">客户端应用程序概述</h3>
               <div>
                  <p>程序网关管理实用程序（ <a id="d17239e161" class="indexterm-anchor"></a> PGAU）使用您提供的定义生成完整的TIP。然后，客户端应用程序可以调用TIP来访问远程主机事务。 <a href="pga-utility-oracle-database-gateway-appc.html#GUID-F73E20E7-D94C-468F-BA65-CC34F6373F19"> 程序网关管理实用程序</a> ，详细讨论了PGAU的使用。
                  </p>
                  <p>此概述说明了为调用TIP和控制远程主机事务必须执行的操作。</p>
                  <p>网关从接收PL / SQL调用<a id="d17239e172" class="indexterm-anchor"></a> Oracle数据库并发出APPC调用以与远程事务程序进行通信。以下三个应用程序使这成为可能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>启用APPC的远程主机事务程序</p>
                     </li>
                     <li>
                        <p>一个<a id="d17239e182" class="indexterm-anchor"></a>事务接口包，或TIP。 TIP是一个P L / SQL包，用于处理客户端和网关之间的通信，并执行COBOL和PL / SQL之间的数据类型转换。</p>
                        <p>PGAU生成了<a id="d17239e192" class="indexterm-anchor"></a><a id="d17239e196" class="indexterm-anchor"></a> TIP规范为您服务。在发货的样本中，PGAU生成的包称为<code class="codeph">pgadb2i.pkb</code> 。生成的TIP包括至少三个映射到远程事务程序的函数调用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">pgadb2i_init</code>初始化与远程事务程序的对话</p>
                           </li>
                           <li>
                              <p><code class="codeph">pgadb2i_main</code>与远程事务程序交换应用程序数据</p>
                           </li>
                           <li>
                              <p><code class="codeph">pgadb2i_term</code>终止与远程事务程序的对话</p>
                           </li>
                        </ul>
                        <p>如果您正在编写自己的TIP或调试，请参阅<a href="tip-internals-oracle-database-gateway-appc.html#GUID-9F4E3177-13B0-43CE-AD0A-5BCD66B3FD17">Tip Internals</a>以获取有关TIP的更多信息。
                        </p>
                     </li>
                     <li>
                        <p>调用TIP的客户端应用程序。</p>
                        <p>客户端应用程序使用输入和输出参数调用三个TIP函数。在该示例中，客户端应用程序将<code class="codeph">empno</code> ，员工编号传递给远程事务，远程事务发送回<code class="codeph">emprec</code>员工记录。
                        </p>
                     </li>
                  </ul>
                  <p><a href="developing-appc-client-app-sna-only.html#GUID-4AF92748-25E4-4262-88D7-742CE302709D__CHDDBIFA" title="这3列表描述了使用示例CICS-DB2事务演示PL / SQL驱动程序，TIP和网关之间的逻辑流程">表4-1</a>演示了使用示例CICS-DB2事务的PL / SQL驱动程序，TIP和网关之间的逻辑流程。
                  </p>
                  <div class="tblformal" id="GUID-4AF92748-25E4-4262-88D7-742CE302709D__CHDDBIFA">
                     <p class="titleintable">表4-1 CICS-DB2示例的逻辑流程</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="CICS-DB2示例的逻辑流程" width="100%" border="1" summary="This 3 column table describes demonstrates the logic flow between the PL/SQL driver, the TIP, and the gateway using the example CICS-DB2 transaction" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="24%" id="d17239e252">客户申请</th>
                              <th align="left" valign="bottom" width="30%" id="d17239e255">Oracle提示</th>
                              <th align="left" valign="bottom" width="46%" id="d17239e258">在网关和远程事务（大型机）之间建立的程序</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d17239e263" headers="d17239e252 ">
                                 <p><code class="codeph">调用tip_init</code></p>
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d17239e263 d17239e255 ">
                                 <p>打电话<code class="codeph">PGAINIT</code></p>
                              </td>
                              <td align="left" valign="top" width="46%" headers="d17239e263 d17239e258 ">
                                 <p>Gateway设置控制块并发出APPC <code class="codeph">ALLOCATE</code> 。大型机程序启动。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d17239e280" headers="d17239e252 ">
                                 <p><code class="codeph">调用tip_main</code></p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d17239e280 d17239e255 ">
                                 <p>调用<code class="codeph">PGAXFER</code>发送<code class="codeph">empno</code>并接收<code class="codeph">emprec</code></p>
                              </td>
                              <td align="left" valign="top" width="46%" headers="d17239e280 d17239e258 ">
                                 <p>Gateway向大型机发出APPC <code class="codeph">SEND</code> 。主机<code class="codeph">RECEIVE</code>完成。大型机执行应用程序逻辑并将APPC <code class="codeph">SEND</code>回网关。网关 - 发布APPC <code class="codeph">RECEIVE</code> ;收到完成。大型机问题APPC <code class="codeph">TERM</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d17239e314" headers="d17239e252 ">
                                 <p><code class="codeph">调用tip_term</code></p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d17239e314 d17239e255 ">
                                 <p>致电<code class="codeph">PGATERM</code></p>
                              </td>
                              <td align="left" valign="top" width="46%" headers="d17239e314 d17239e258 ">
                                 <p>Gateway清理控制块。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>利用网关与远程主机事务交换数据的客户端应用程序为自己执行一些任务，并指示TIP代表它执行其他任务。因此，客户端应用程序设计者必须知道远程事务的行为以及TIP如何促进交换。</p>
                  <p>以下部分概述了远程主机事务行为，客户端应用程序如何控制此行为以及TIP函数调用和数据声明如何支持客户端应用程序控制远程主机事务。这些部分还提供了有关TIP为客户端应用程序执行的操作以及TIP调用如何与远程主机事务交换数据的背景信息。</p>
               </div>
            </div><a id="APPUG971"></a><div class="props_rev_3"><a id="GUID-234C85C7-BC32-4B2F-9580-9151360B3DD7" name="GUID-234C85C7-BC32-4B2F-9580-9151360B3DD7"></a><h3 id="APPUG-GUID-234C85C7-BC32-4B2F-9580-9151360B3DD7" class="sect3">准备客户端应用程序</h3>
               <div>
                  <div class="section">
                     <p>要准备客户端应用程序以执行，您必须了解远程主机事务要求，然后执行以下步骤：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>移动相关<a id="d17239e373" class="indexterm-anchor"></a> COBOL将布局（副本）记录到网关系统以输入到PGAU。</span></li>
                     <li><span>描述远程主机事务数据并调用<a id="d17239e379" class="indexterm-anchor"></a>带有<code class="codeph">DEFINE DATA</code> ， <code class="codeph">DEFINE CALL</code>和<code class="codeph">DEFINE TRANSACTION</code>语句的PG数据字典（PG DD）。</span></li>
                     <li><span>使用<code class="codeph">GENERATE</code>在Oracle数据库中生成TIP。</span></li>
                     <li><span>创建调用TIP公共函数的客户端应用程序。</span></li>
                     <li><span>授予新创建的包的权限。</span></li>
                  </ol>
               </div>
            </div><a id="APPUG972"></a><div class="props_rev_3"><a id="GUID-BFE11091-D32F-4B66-B48F-5569EB5FAD6E" name="GUID-BFE11091-D32F-4B66-B48F-5569EB5FAD6E"></a><h3 id="APPUG-GUID-BFE11091-D32F-4B66-B48F-5569EB5FAD6E" class="sect3">了解远程主机事务要求</h3>
               <div>
                  <p>浏览远程主机事务程序（RTP）以确定：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>各种客户端应用程序对TIP调用所需的PL / SQL参数</p>
                     </li>
                     <li>
                        <p>调用的顺序</p>
                     </li>
                  </ul>
                  <p>确定要调用的远程主机事务程序（RTP）工具以及每次调用时要交换的数据。然后，您将定义以下内容，并将它们存储在PG DD中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">定义数据</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DEFINE CALL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">定义交易</code></p>
                     </li>
                  </ul>
                  <p>有关具体的定义步骤以及实际创建和生成<a href="creating-tip-oracle-database-gateway-appc.html#GUID-78D4439E-7DD6-45DF-842E-35007FCC572B">TIP</a> ，请参阅<a href="creating-tip-oracle-database-gateway-appc.html#GUID-78D4439E-7DD6-45DF-842E-35007FCC572B">创建</a>提示。</p>
               </div><a id="APPUG973"></a><div class="props_rev_3"><a id="GUID-72D8DB06-5E1C-499E-8C3F-95D5304DB401" name="GUID-72D8DB06-5E1C-499E-8C3F-95D5304DB401"></a><h4 id="APPUG-GUID-72D8DB06-5E1C-499E-8C3F-95D5304DB401" class="sect4">提示内容和目的</h4>
                  <div>
                     <p>PGAU生成的TIP的内容反映了远程主机事务可用的调用和已交换的数据。了解此内容有助于设计和调试调用TIP的客户端应用程序。</p>
                     <p>提示是一个<a id="d17239e522" class="indexterm-anchor"></a> PL / SQL包，并据此有<a id="d17239e527" class="indexterm-anchor"></a><a id="d17239e531" class="indexterm-anchor"></a>两节：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>包规范包含：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>公共函数原型和参数，以及</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>包体包含：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>私有函数和内部控制变量</p>
                              </li>
                              <li>
                                 <p>公共职能</p>
                              </li>
                              <li>
                                 <p>最后一个公共函数后的包初始化。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>TIP的目的是为每个允许的远程事务程序交互提供PL / SQL可调用公共函数。一个<a id="d17239e561" class="indexterm-anchor"></a>远程交易程序交互是通过一个或多个逻辑相关的数据交换组<a id="d17239e566" class="indexterm-anchor"></a><a id="d17239e568" class="indexterm-anchor"></a> <code class="codeph">PGAXFER</code> RPC调用。这在概念上类似于屏幕或菜单交互，其中填充了几个字段，按下了回车键，并且向用户返回了几个字段。进一步进行类比：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>用户可能被比作TIP或客户端应用程序</p>
                        </li>
                        <li>
                           <p>要填写的字段是TIP函数调用的<code class="codeph">IN</code>参数</p>
                        </li>
                        <li>
                           <p>返回的字段是TIP函数调用的<code class="codeph">OUT</code>参数</p>
                        </li>
                        <li>
                           <p>屏幕或菜单是<code class="codeph">IN</code>和<code class="codeph">OUT</code>参数组合在一起的</p>
                        </li>
                        <li>
                           <p>按下的回车键被比作<code class="codeph">PGAXFER</code>远程过程调用（RPC）</p>
                        </li>
                     </ul>
                     <p>构成交易调用的实际参数分组由用户定义。网关对远程事务程序如何对应于TIP函数调用的集合没有限制，每个调用具有许多<code class="codeph">IN</code>和<code class="codeph">OUT</code>参数。
                     </p>
                     <p>PGA用户通常每个远程交易程序有一个TIP。如何对TIP函数调用进行分组以及在每次调用时交换哪些数据参数取决于远程事务程序的大小，复杂性和行为。</p>
                     <p>有关如何操作的讨论，请参阅Oracle的<a href="../lnpls/index.html" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a> <a id="d17239e623" class="indexterm-anchor"></a> PL / SQL包工作。以下讨论涵盖了必须在TIP中执行的逻辑。请参阅针对Microsoft Windows的<code class="codeph">%ORACLE_HOME%\dg4appc\demo\CICS</code>目录中提供的示例提示和驱动程序或针对基于UNIX的系统的<code class="codeph">$ORACLE_HOME/dg4appc/demo/CICS</code>目录，位于文件中<a id="d17239e632" class="indexterm-anchor"></a><a id="d17239e634" class="indexterm-anchor"></a> <code class="codeph">pgadb2i.pkh</code> ， <a id="d17239e643" class="indexterm-anchor"></a><a id="d17239e645" class="indexterm-anchor"></a> <code class="codeph">pgadb2i.pkb</code> ，和<a id="d17239e652" class="indexterm-anchor"></a> <code class="codeph">pgadb2id.sql</code> 。
                     </p>
                  </div>
               </div><a id="APPUG974"></a><div class="props_rev_3"><a id="GUID-FD67739C-7249-466A-A492-0E43195A6D3B" name="GUID-FD67739C-7249-466A-A492-0E43195A6D3B"></a><h4 id="APPUG-GUID-FD67739C-7249-466A-A492-0E43195A6D3B" class="sect4">远程主机事务类型</h4>
                  <div>
                     <p>从数据库网关应用程序的角度来看，有三种主要类型的远程主机事务：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一次性</p>
                        </li>
                        <li>
                           <p>一贯</p>
                        </li>
                        <li>
                           <p>多对话</p>
                        </li>
                     </ul>
                  </div><a id="APPUG975"></a><div class="props_rev_3"><a id="GUID-58F456FB-9B18-4D4A-ABA9-D97863A69B2E" name="GUID-58F456FB-9B18-4D4A-ABA9-D97863A69B2E"></a><h5 id="APPUG-GUID-58F456FB-9B18-4D4A-ABA9-D97863A69B2E" class="sect5">一次性交易</h5>
                     <div>
                        <p><a id="d17239e747" class="indexterm-anchor"></a>接收一个员工编号并返回员工记录的简单远程交易程序可以具有提供一个呼叫的TIP，将员工编号作为<code class="codeph">IN</code>参数传递并将员工记录作为<code class="codeph">OUT</code>参数返回。此和每个提示必须提供另外两个函数调用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>一个远程事务程序init函数调用</p>
                           </li>
                           <li>
                              <p>远程事务程序终止函数调用</p>
                           </li>
                        </ul>
                        <p>最简单的TIP有三个公共函数，例如<code class="codeph">tip_init</code> ， <code class="codeph">tip_main</code>和<code class="codeph">tip_term</code> 。
                        </p>
                        <p>客户端应用程序连续调用<code class="codeph">tip_init</code> ， <code class="codeph">tip_main</code>和<code class="codeph">tip_term</code> 。远程站点的相应活动是远程事务程序启动，数据交换和远程事务程序结束。
                        </p>
                        <p>远程事务程序甚至可能在从网关接收到终止信号之前自行终止。这个序列很常见，通常由网关逻辑处理。这种远程交易程序被称为一次性。</p>
                     </div>
                  </div><a id="APPUG976"></a><div class="props_rev_3"><a id="GUID-6F97F428-51DD-4A44-A5E3-EFD7A07A1AAD" name="GUID-6F97F428-51DD-4A44-A5E3-EFD7A07A1AAD"></a><h5 id="APPUG-GUID-6F97F428-51DD-4A44-A5E3-EFD7A07A1AAD" class="sect5">持久交易</h5>
                     <div>
                        <p><a id="d17239e826" class="indexterm-anchor"></a>更复杂的远程事务程序有两种行为模式： <code class="codeph">INQUIRY</code>或报告模式，以及<code class="codeph">UPDATE</code>模式。这些模式可以有两个TIP数据传输函数调用：一个用于<code class="codeph">INQUIRY</code> ，另一个用于<code class="codeph">UPDATE</code> 。这样的TIP可能有五个公共职能。例如：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d17239e844" class="indexterm-anchor"></a><code class="codeph">tip_init</code></p>
                              <p>这初始化了与远程事务程序的通信。</p>
                           </li>
                           <li>
                              <p><a id="d17239e856" class="indexterm-anchor"></a><code class="codeph">tip_mode</code></p>
                              <p>这接受模式选择参数并将事务程序置于查询或更新模式。</p>
                           </li>
                           <li>
                              <p><a id="d17239e868" class="indexterm-anchor"></a><code class="codeph">tip_inqr</code> 
                              </p>
                              <p>这将返回给定员工编号的员工记录。</p>
                           </li>
                           <li>
                              <p>Ť <a id="d17239e882" class="indexterm-anchor"></a> <code class="codeph">ip_updt</code></p>
                              <p>这接受给定员工编号的员工记录。</p>
                           </li>
                           <li>
                              <p><a id="d17239e894" class="indexterm-anchor"></a><code class="codeph">tip_term</code></p>
                              <p>这终止了与远程事务程序的通信。</p>
                           </li>
                        </ul>
                        <p>客户端应用程序调用<code class="codeph">tip_init</code>然后<code class="codeph">tip_mode</code>放置在查询模式远程交易程序，然后扫描雇员记录，搜索属性的某些组合（称为客户端应用和最终用户）。然后将查询调用上的某些参数设置为表示更改为更新模式，客户端应用程序调用<code class="codeph">tip_updt</code>以更新某些记录。客户端应用程序最终调用<code class="codeph">tip_term</code>来终止远程事务程序。
                        </p>
                        <p>相应的活动在<a id="d17239e920" class="indexterm-anchor"></a>远程站点是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>远程交易程序启动</p>
                           </li>
                           <li>
                              <p>模式选择交换</p>
                           </li>
                           <li>
                              <p>循环阅读记录</p>
                           </li>
                           <li>
                              <p>切换到更新模式</p>
                           </li>
                           <li>
                              <p>更新一条记录</p>
                           </li>
                           <li>
                              <p>远程交易程序结束</p>
                           </li>
                        </ul>
                        <p>这样的远程事务程序称为持久性，因为它会进行交互，直到它被发出信号终止。</p>
                        <p>可以编写远程事务程序以允许返回查询模式并无限期地重复整个过程。</p>
                     </div>
                  </div><a id="APPUG977"></a><div class="props_rev_3"><a id="GUID-EB18C5AF-6577-4702-9893-250023FB106B" name="GUID-EB18C5AF-6577-4702-9893-250023FB106B"></a><h5 id="APPUG-GUID-EB18C5AF-6577-4702-9893-250023FB106B" class="sect5">多方会话交易</h5>
                     <div>
                        <p><a id="d17239e988" class="indexterm-anchor"></a>客户端应用程序可能需要从一个交易，获取信息<code class="codeph">tran_A</code> ，随后编写或从另一个查找信息， <code class="codeph">tran_B</code> 。通过正确编写的客户端应用程序以及<code class="codeph">tran_A</code>和<code class="codeph">tran_B</code> TIP，可以实现<code class="codeph">tran_A</code> <code class="codeph">tran_B</code> 。实际上，任何数量的事务可能由单个客户端应用程序同时控制。所有事务都可以是只读的，客户端应用程序从每个事务中检索数据并将其合并到本地Oracle数据库中或在Oracle表单中显示。
                        </p>
                        <p>或者，取决于客户端应用程序提供的输入选择，事务能够以不同模式操作或执行不同服务。例如， <code class="codeph">tran_C</code>一个实例可以执行一个服务，而<code class="codeph">tran_C</code>的第二个实例执行第二个服务。<code class="codeph">tran_C</code>每个实例<code class="codeph">tran_C</code>将与客户端应用程序具有自己唯一的对话，并且每个实例可以具有其自己的行为（一次性或持久性），这取决于正在执行的服务的性质。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="APPUG1300"></a><a id="APPUG978"></a><div class="props_rev_3"><a id="GUID-30316801-BD91-4799-BAB2-B145F27CD624" name="GUID-30316801-BD91-4799-BAB2-B145F27CD624"></a><h3 id="APPUG-GUID-30316801-BD91-4799-BAB2-B145F27CD624" class="sect3">每个远程主机事务的自定义TIP</h3>
               <div>
                  <p>每个远程主机系统可能有数百个<a id="d17239e1057" class="indexterm-anchor"></a>用户可能想要调用的远程事务程序（RTP）。每个远程事务程序都不同，传递不同的数据，并执行不同的功能。因此，用户和每个远程事务程序之间的接口必须专门化并根据用户对每个远程事务程序的要求进行定制。事务接口包提供此自定义接口。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-30316801-BD91-4799-BAB2-B145F27CD624__GUID-BA1A1ECC-D0C8-4B68-9E3D-596D66EC921F">例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>假设远程站点具有管理员工数据库或其他文件系统中的员工信息的事务程序。远程主机中的远程事务程序名称是员工跟踪的<code class="codeph">EMPT</code> 。<code class="codeph">EMPT</code>提供查询和更新功能，并且需要不同的Oracle用户访问和使用这些<code class="codeph">EMPT</code>设施。
                     </p>
                     <p>某些用户可能仅限于仅查询使用<code class="codeph">EMPT</code> ，而其他用户可能有更新要求。为了支持Oracle用户的客户端应用程序，至少可能存在三种可能的TIP：</p>
                     <ol>
                        <li>
                           <p><code class="codeph">EMP_MGMT</code>提供对<code class="codeph">EMPT</code>远程交易程序的所有设施的访问。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">EMP_UPDT</code>仅访问<code class="codeph">EMPT</code>远程事务程序的更新功能。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">EMP_INQR</code>仅访问<code class="codeph">EMPT</code>远程事务程序的查找功能。
                           </p>
                        </li>
                     </ol>
                     <p>最终用户对这些TIP的访问权限由Oracle权限控制。远程主机可能会对最终用户施加额外的安全性。</p>
                     <p>每个TIP还在其中编码远程交易程序（ <code class="codeph">EMPT</code> ）的名称和足以与<code class="codeph">EMPT</code>建立APPC对话的网络信息。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="APPUG1301"></a><a id="APPUG1302"></a><a id="APPUG1303"></a><a id="APPUG979"></a><div class="props_rev_3"><a id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E" name="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E"></a><h3 id="APPUG-GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E" class="sect3">客户申请要求</h3>
               <div>
                  <p>使用TIP，客户端应用程序必须与之对应并控制<a id="d17239e1181" class="indexterm-anchor"></a>远程主机事务。这包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>客户应用初始化</p>
                     </li>
                     <li>
                        <p>用户输入和输出</p>
                     </li>
                     <li id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__I1008983">
                        <p>使用TIP初始化函数进行远程主机事务初始化（使用和不使用覆盖）</p>
                     </li>
                     <li id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__I1008989">
                        <p>使用TIP用户功能进行远程主机事务控制和数据交换</p>
                     </li>
                     <li id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__I1008993">
                        <p>使用TIP终止功能终止远程主机事务</p>
                        <p>前三个步骤根据远程主机事务的要求而有所不同。</p>
                     </li>
                     <li>
                        <p>异常处理</p>
                     </li>
                     <li>
                        <p>客户申请终止</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__GUID-7AAE85C6-85B8-48CE-96F8-5ABD3024CCFD">一次性远程主机事务客户端应用程序必须：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>声明要交换的RHT / TIP数据类型。<a id="d17239e1218" class="indexterm-anchor"></a>所有客户端应用程序必须使用TIP声明要与RHT交换的变量。<a id="d17239e1225" class="indexterm-anchor"></a>这些变量的PL / SQL数据类型已经在每个RHT对应的TIP中定义，客户端应用程序只需要在其声明中引用TIP数据类型。有关更多信息，另请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6">声明TIP变量</a> ”</span> 。有关这些变量的确切用法的更多信息，另请参阅特定TIP / RHT的TIP内容文档文件。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP初始化函数初始化RHT <a id="d17239e1238" class="indexterm-anchor"></a> 。TIP指示网关服务器初始化具有所需RHT的会话，指定默认RHT标识参数（在PG DD中定义RHT时生成，并在生成时在TIP内编码）或覆盖由RHT提供的RHT标识参数。调用TIP初始化函数时的用户或客户端应用程序。有关更多详细信息，请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-41ABD528-5797-468E-A436-B6B3434ADF34">初始化对话</a> ”</span>和<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-125BF246-33A2-46AF-87E8-7344F3B4F573">覆盖TIP初始化</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP用户功能（一次呼叫）与RHT交换数据。 <a id="d17239e1258" class="indexterm-anchor"></a> 如前所述，一次性远程主机事务仅适用于单个数据交换，并且在完成该交换后，RHT自行终止。因此，客户端应用程序只需要对用户定义的TIP函数执行单个调用即可进行数据交换。
                           </p>
                           <p>请参阅Microsoft Windows上的<code class="codeph">%ORACLE_HOME%\dg4appc\demo\CICS\</code>或基于UNIX的系统上的<code class="codeph">$ORACLE_HOME/dg4appc/demo/CICS/</code>的TIP内容文档文件，了解此调用的确切语法的特定TIP / RHT。
                           </p>
                           <p>在调用TIP函数调用之前，客户端应用程序应将值初始化为<code class="codeph">IN</code>或<code class="codeph">IN OUT</code>参数值。当您声明要交换的RHT / TIP数据类型时，这些变量与上面声明的变量相同。
                           </p>
                           <p>所有TIP函数调用返回<code class="codeph">0</code>返回码值，并且所有返回的用户网关数据值在函数参数中交换。任何异常条件都会根据需要引发，并且可以在异常处理程序中截获。
                           </p>
                           <p>从TIP函数调用返回后，客户端应用程序可以分析并操作<code class="codeph">IN OUT</code>或<code class="codeph">OUT</code>参数值。当您声明要交换的RHT / TIP数据类型时，这些变量与上面声明的变量相同。
                           </p>
                           <p>有关TIP如何转换远程主机数据的各种类型和格式的详细信息，请参阅<a href="data-type-conversion-oracle-database-gateway-appc.html#GUID-FEB0C201-9C07-4932-A328-B048B582B18A">数据类型转换</a> 。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP终止功能终止RHT <a id="d17239e1303" class="indexterm-anchor"></a> 。无论访问的RHT类型如何，都应调用TIP终止函数来清理和终止与RHT的对话。在RHT终止之前，可以从网关服务器终止与一次性RHT的对话。TIP也必须执行清理。清理仅在客户端应用程序的终止请求时执行。
                           </p>
                           <p>客户端应用程序可以请求正常或中止终止。</p>
                           <p>参考<a id="d17239e1314" class="indexterm-anchor"></a><a id="d17239e1316" class="indexterm-anchor"></a> <span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-3CDB9504-3937-4909-A6FE-3B63FC25BF75">终止对话</a> ”</span>以获取更多信息。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__GUID-A1A87711-9449-496D-88E7-B271382F6BBD">持久远程主机事务客户端应用程序必须：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>声明要交换的RHT / TIP数据类型。<a id="d17239e1333" class="indexterm-anchor"></a>所有客户端应用程序必须使用TIP声明要与RHT交换的变量。<a id="d17239e1340" class="indexterm-anchor"></a>已经在与每个RHT对应的TIP中定义了这些变量的PL / SQL数据类型;客户端应用程序只需要在其声明中引用TIP数据类型。有关更多信息，请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6">声明TIP变量</a> ”</span> 。有关这些变量的确切用法的更多信息，另请参阅特定TIP / RHT的TIP内容文档文件。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP初始化函数初始化RHT。<a id="d17239e1353" class="indexterm-anchor"></a> TIP指示网关服务器初始化具有所需RHT的会话，指定默认RHT标识参数（在PG DD中定义RHT时生成，并在生成时在TIP内编码）或覆盖由RHT提供的RHT标识参数。调用TIP初始化函数时的用户或客户端应用程序。有关更多详细信息，请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-41ABD528-5797-468E-A436-B6B3434ADF34">初始化对话</a> ”</span>和<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-125BF246-33A2-46AF-87E8-7344F3B4F573">覆盖TIP初始化</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP用户功能与RHT重复交换数据。 <a id="d17239e1373" class="indexterm-anchor"></a> 提供或要求持续或重复控制序列的远程主机事务应由客户端应用程序控制，其方式与交互用户或其他控制程序操作RHT的方式相同。TIP和网关服务器的代理不会改变RHT行为;相反，它使用TIP中定义的各种函数调用将该行为的控制扩展到客户端应用程序。</p>
                           <p>可以使用一个或多个TIP函数调用来控制持久性RHT。例如，RHT可以设计为循环并返回每个输入的输出，直到会话被明确终止。或者它可以被设计为接受作为输入的操作的计数或列表，并且在多个交换中返回结果，其中TIP功能仅具有<code class="codeph">OUT</code>参数。
                           </p>
                           <p>持久性RHT也可以是交互式的，每个输出由先前的输入选择指定，并且仅在客户端应用程序明确终止对话时结束。</p>
                           <p>TIP函数调用可用于客户端应用程序，其特定语法记录在特定TIP / RHT的TIP内容文档文件中。</p>
                           <p>RHT解释TIP <code class="codeph">IN</code>参数并返回TIP <code class="codeph">OUT</code>参数的方式必须从RHT确定或由RHT程序员解释。TIP提供函数调用和交换的参数数据类型，以便于客户端应用程序控制RHT，并且不对RHT执行的操作序列施加任何限制或先决条件。TIP为客户端应用程序提供RHT定义为在PG DD中接受的调用和数据参数。</p>
                        </li>
                        <li>
                           <p>使用TIP终止功能终止RHT <a id="d17239e1400" class="indexterm-anchor"></a> 。无论访问的RHT类型如何，都应调用TIP终止函数来清理和终止与RHT的对话。在RHT终止之前，可以从网关服务器终止与持久性RHT的对话，或者RHT可能已经终止。TIP也必须执行其清理，并且仅在客户端应用程序的终止请求时执行此清理。
                           </p>
                           <p>客户端应用程序可以请求正常或中止终止。</p>
                           <p>有关更多信息，请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-3CDB9504-3937-4909-A6FE-3B63FC25BF75">终止对话</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__GUID-593ABAAC-F841-4C3F-9E40-C787577267B5">多会话远程主机事务客户端应用程序必须：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>声明要交换的RHT / TIP数据类型。 <a id="d17239e1424" class="indexterm-anchor"></a> 所有客户端应用程序必须使用TIP声明要与RHT交换的变量。<a id="d17239e1431" class="indexterm-anchor"></a>这些变量的PL / SQL数据类型已经在每个RHT对应的TIP中定义，客户端应用程序只需要在其声明中引用TIP数据类型。有关更多信息，请参阅<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6">声明TIP变量</a> ”</span> 。有关这些变量的确切用法的更多信息，另请参阅特定TIP / RHT的TIP内容文档文件。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP初始化函数初始化所涉及的每个RHT <a id="d17239e1444" class="indexterm-anchor"></a> 。PG DD中定义的每个RHT都有一个特定的定制TIP。控制多个RHT的客户端应用程序是多会话的，必须启动每个RHT及其关联的对话。这是通过像以前一样调用每个TIP初始化函数来完成的;但是多个TIP被初始化。
                           </p>
                           <p>如果单个RHT被设计为为一个或多个呼叫者执行多个服务，并且如果客户端应用程序被设计为使用该RHT，则客户端应用程序可以多次初始化与该RHT相对应的TIP。</p>
                           <p>客户端应用程序随后使用以下方法区分其控制下的活动RHT：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>当控制多个TIP / <code class="codeph">tipname.callname</code>时，TIP模式<code class="codeph">tipname.callname</code> 。通过在TIP用户调用上编码相同的TIP模式名称，客户端应用程序指定正在进行呼叫的RHT。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">tranuse</code> <code class="codeph">IN OUT</code>当相同TIP的多个实例/ RHT被控制参数值。这是TIP初始化函数调用返回的值，随后作为<code class="codeph">IN</code>参数传递给用户定义的TIP函数调用。返回的<code class="codeph">tranuse</code>值对应于连接到RHT的给定实例的对话。通过在TIP用户调用上提供相同的<code class="codeph">tranuse</code>值，客户端应用程序指定正在进行给定RHT调用的RHT实例。
                                 </p>
                              </li>
                           </ul>
                           <p>客户端应用程序逻辑必须跟踪哪些RHT已启动以及哪些TIP和<code class="codeph">tranuse</code>值对应于已启动的RHT。
                           </p>
                        </li>
                        <li>
                           <p>使用TIP用户功能一次或重复地与每个RHT交换数据<a id="d17239e1487" class="indexterm-anchor"></a>如果RHT是一次性的或持久性的。客户端应用程序逻辑必须按照正确的RHT操作通过其允许的步骤对RHT进行排序，用户以交互方式操作RHT也是如此。
                           </p>
                           <p>客户端应用程序逻辑还必须执行可能需要的任何跨RHT结果分析或数据传输。所有TIP都彼此隔离执行。</p>
                           <p>作为输入到另一个RHT的一个RHT的输出必须在客户端应用程序中作为来自第一个RHT的<code class="codeph">IN</code>或<code class="codeph">IN OUT</code>参数接收，并作为<code class="codeph">IN</code>或<code class="codeph">IN OUT</code>参数从客户端应用程序发送到第二个RHT。所有TIP-to-RHT函数调用必须由客户端应用程序执行，并且交换的数据参数必须已由客户端应用程序声明为变量。TIP为客户端应用程序提供所需的数据类型定义和RHT函数调用。
                           </p>
                           <p>有关TIP函数调用的确切语法和交换的参数数据类型的定义，请参阅每个特定TIP / RHT的TIP内容文档文件。</p>
                        </li>
                        <li>
                           <p>终止每个初始化的RHT <a id="d17239e1515" class="indexterm-anchor"></a> ，使用TIP终止功能。要终止RHT，必须调用其相应的TIP终止函数来终止RHT及其对话并启动TIP清理。要终止的RHT由其TIP模式名称（与其数据交换函数调用相同的模式）和当终止同一RHT的多个实例时的<code class="codeph">tranuse</code>值指定。
                           </p>
                           <p>RHT及其相应的TIP可以以客户端应用程序所需的任何顺序终止，并且不必以它们被初始化的相同顺序终止。</p>
                           <div class="infoboxnote" id="GUID-A3323A41-AEDA-48EA-90D2-4C150D708D8E__GUID-0685857D-C793-43B8-8CEC-C04933C85D14">
                              <p class="notep1">注意：</p>
                              <p>各种TIP数据交换变量函数调用的具体语法与先前在PG DD中针对特定RHT定义的相同，可以通过检查TIP内容文档文件来研究<a id="d17239e1530" class="indexterm-anchor"></a><a id="d17239e1532" class="indexterm-anchor"></a> （ <code class="codeph">tipname.doc</code> ）或生成TIP时生成的TIP规范文件。如果尚未为正在访问的RHT生成TIP，请参阅<a href="creating-tip-oracle-database-gateway-appc.html#GUID-78D4439E-7DD6-45DF-842E-35007FCC572B">创建提示</a>和<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-2EE274FF-C15C-4E8A-9245-ACE1F41D147E">数据通信</a> ”</span> ， <span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-5CB6DA00-C709-43E5-B3D1-3937D097E48F">CALL通信</a> ”</span>和<span class="q">“ <a href="developing-appc-client-app-sna-only.html#GUID-21400950-327F-4A8B-831D-3F34333C3264">事务通信</a> ”</span>以获取更多信息。但是，最好先定义并生成TIP，以便在需要时可以使用客户端应用程序参考文档。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="APPUG980"></a><div class="props_rev_3"><a id="GUID-B264D759-308E-46B3-B303-7E651B4AF83C" name="GUID-B264D759-308E-46B3-B303-7E651B4AF83C"></a><h3 id="APPUG-GUID-B264D759-308E-46B3-B303-7E651B4AF83C" class="sect3">确保TIP和远程交易程序通信</h3>
               <div>
                  <p>远程主机事务程序及其与客户端应用程序的相关TIP必须对应<a id="d17239e1605" class="indexterm-anchor"></a>两个关键要求：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>参数数据类型转换，由定义事务<code class="codeph">DATA</code>的方式产生。有关PGAU生成的TIP如何根据数据定义转换数据的讨论，请参阅<a href="data-type-conversion-oracle-database-gateway-appc.html#GUID-FEB0C201-9C07-4932-A328-B048B582B18A">数据类型转换</a> 。
                        </p>
                     </li>
                     <li>
                        <p>APPC发送/接收同步，这是由定义事务<code class="codeph">CALL</code>的方式产生的</p>
                     </li>
                  </ul>
                  <p>然后，这些<code class="codeph">DATA</code>和<code class="codeph">CALL</code>定义通过引用包含在<code class="codeph">TRANSACTION</code>定义中。
                  </p>
               </div><a id="APPUG981"></a><div class="props_rev_3"><a id="GUID-2EE274FF-C15C-4E8A-9245-ACE1F41D147E" name="GUID-2EE274FF-C15C-4E8A-9245-ACE1F41D147E"></a><h4 id="APPUG-GUID-2EE274FF-C15C-4E8A-9245-ACE1F41D147E" class="sect4">数据通讯</h4>
                  <div>
                     <p>使用以远程主机事务语言编写的数据定义， <a id="d17239e1684" class="indexterm-anchor"></a><a id="d17239e1688" class="indexterm-anchor"></a> PGAU <code class="codeph">DEFINE DATA</code>命令存储在<a id="d17239e1694" class="indexterm-anchor"></a> PG DD所需的信息<a id="d17239e1699" class="indexterm-anchor"></a><a id="d17239e1701" class="indexterm-anchor"></a> PGAU <code class="codeph">GENERATE</code>创建TIP函数逻辑来执行：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>从接收远程主机事务提供的PL / SQL <code class="codeph">IN</code>参数的所有数据转换</p>
                        </li>
                        <li>
                           <p>所有缓冲到接收远程主机事务所期望的格式</p>
                        </li>
                        <li>
                           <p>所有数据都不受发送远程主机事务提供的格式的影响</p>
                        </li>
                        <li>
                           <p>所有数据转换为发送远程主机事务提供的PL / SQL <code class="codeph">OUT</code>参数</p>
                        </li>
                     </ul>
                     <p>PGAU根据远程主机事务程序中包含的数据定义确定生成转换和缓冲逻辑所需的信息。PGAU <code class="codeph">DEFINE DATA</code>从文件中读取此信息，例如COBOL副本，或从脚本中插入，并将其保存在PG DD中以供重复使用。网关管理员需要将这些定义文件从远程主机传输到运行PGAU的Oracle主机。
                     </p>
                     <p>根据存储在PG DD中的数据定义，PGAU <code class="codeph">GENERATE</code>确定远程主机数据类型并将其与适当的数据类型匹配<a id="d17239e1739" class="indexterm-anchor"></a> PL / SQL数据类型。它还确定记录和缓冲区中的数据长度和偏移量，并在TIP中生成所需的PL / SQL逻辑。有关详细信息，请参阅<span class="q">“</span> <a href="pga-utility-oracle-database-gateway-appc.html#GUID-F73E20E7-D94C-468F-BA65-CC34F6373F19">过程网关管理实用程序</a> <span class="q">”中</span>的PGAU <span class="q">“ <a href="pga-utility-oracle-database-gateway-appc.html#GUID-A39AE344-8E2F-49EE-9791-6BAF4ECF4F6B">DEFINE DATA</a> ”</span>语句和<span class="q">“</span> <a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-AA9B8762-BDAF-4EED-A8B0-09F8A937F04E">管理实用程序示例</a> <span class="q">”</span>中的<span class="q">“ <a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-F0ACAA50-16F8-4C5C-83FE-C0D280981772">示例PGAU DEFINE DATA语句</a> ”</span> 。
                     </p>
                     <p>必须首先使用PGAU <code class="codeph">DEFINE DATA</code>定义后续调用作为参数引用的所有数据。可以定义简单数据项，例如单个数字或字符串，以及复杂的多字段数据聚合，例如记录或结构。PGAU自动生成等效的PL / SQL变量和字段或表的记录，供客户端应用程序在其对生成的TIP的调用中引用。</p>
                     <p>如上所述，参数可以是简单的数据项，例如员工编号，也可以是复杂的项目，例如员工记录。PGAU <code class="codeph">DEFINE DATA</code>自动从输入程序数据定义文件中提取所需的数据类型信息。
                     </p>
                     <p>在此示例中， <code class="codeph">empno</code>和<code class="codeph">emprec</code>是要交换的参数。
                     </p><pre class="oac_no_warn" dir="ltr">pgadb2i_main（trannum，EMPNO，emprec）</pre><p>因此，必须为每个参数发出PGAU <code class="codeph">DEFINE DATA</code>语句：</p><pre class="oac_no_warn" dir="ltr">DEFINE DATA EMPNO PLSDNAME（EMPNO）使用（通过）语言（IBMVSCOBOLII）（01 EMP-NO PIC X（6）。）; DEFINE DATA EMPREC PLSDNAME（DCLEMP）使用（通过）语言（IBMVSCOBOLII）INFILE（“emp.cob”）;</pre><p>请注意， <code class="codeph">trannum</code>参数不需要定义。这是APPC会话标识符，不需要PGAU中的定义。</p>
                  </div>
               </div><a id="APPUG982"></a><div class="props_rev_3"><a id="GUID-5CB6DA00-C709-43E5-B3D1-3937D097E48F" name="GUID-5CB6DA00-C709-43E5-B3D1-3937D097E48F"></a><h4 id="APPUG-GUID-5CB6DA00-C709-43E5-B3D1-3937D097E48F" class="sect4">CALL通讯</h4>
                  <div>
                     <p>要求同步<a id="d17239e1847" class="indexterm-anchor"></a> APPC <code class="codeph">SEND</code>和<code class="codeph">RECEIVE</code>表示当远程事务程序期望输入数据参数时，它会发出APPC <code class="codeph">RECEIVE</code>来读取数据参数。因此，TIP必须使网关发出APPC <code class="codeph">SEND</code>以将数据参数写入远程事务程序。当远程事务程序发出APPC <code class="codeph">SEND</code>时，TIP还必须使网关发出APPC <code class="codeph">RECEIVE</code> 。
                     </p>
                     <p>PGAU <code class="codeph">DEFINE CALL</code>语句指定客户端应用程序如何<code class="codeph">DEFINE CALL</code>生成的TIP以及与该调用的远程主机事务交换哪些数据参数。每个PGAU <code class="codeph">DEFINE CALL</code>语句可以指定TIP函数的名称，一个或多个数据参数以及每个数据参数的<code class="codeph">IN/OUT</code>模式。必须先使用PGAU <code class="codeph">DEFINE DATA</code>语句<code class="codeph">DEFINE DATA</code> 。有关详细信息，请参阅<span class="q">“</span> <a href="pga-utility-oracle-database-gateway-appc.html#GUID-F73E20E7-D94C-468F-BA65-CC34F6373F19">过程网关管理实用程序</a> <span class="q">”</span>中的<span class="q">“ <a href="pga-utility-oracle-database-gateway-appc.html#GUID-01EEB1ED-7AB6-4BFA-AF6F-A9D36A44C0B1">DEFINE CALL</a> ”</span>和<span class="q">“</span> <a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-AA9B8762-BDAF-4EED-A8B0-09F8A937F04E">管理实用程序示例</a> <span class="q">”</span>中的<span class="q">“ <a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-336981E2-C7F9-47C1-8B18-330187556305">示例PGAU DEFINE CALL语句</a> ”</span> 。
                     </p>
                     <p>PGAU <code class="codeph">DEFINE CALL</code>处理将指定信息存储在PG DD中，供PGAU <code class="codeph">GENERATE</code>稍后使用。然后，PGAU <code class="codeph">GENERATE</code>在TIP包规范中创建以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于在<code class="codeph">CALL</code>指定的每个<code class="codeph">DATA</code>定义使用PL / SQL参数定义的每个<code class="codeph">CALL</code>的公共PL / SQL函数的声明</p>
                        </li>
                        <li>
                           <p>公共PL / SQL数据参数的声明</p>
                        </li>
                     </ul>
                     <p>客户端应用程序使用PGAU <code class="codeph">DEFINE CALL</code>语句中指定的函数名称和参数列表将TIP公共函数作为PL / SQL函数调用进行<code class="codeph">DEFINE CALL</code> 。客户端应用程序还可以通过引用声明与TIP公共数据参数具有相同数据类型的私有变量，以便于在客户端应用程序中传递和处理数据，从而共享由PGAU <code class="codeph">GENERATE</code>创建的声明。</p>
                     <p>在此示例中，必须发出以下PGAU <code class="codeph">DEFINE CALL</code>语句来定义TIP公共函数：</p><pre class="oac_no_warn" dir="ltr">DEFINE CALL DB2IMAIN PKGCALL（pgadb2i_main）PARMS（（empno IN），（emprec OUT））;</pre></div><a id="APPUG983"></a><div class="props_rev_3"><a id="GUID-0522D9DF-E342-4451-A167-0FD0E5ADD13D" name="GUID-0522D9DF-E342-4451-A167-0FD0E5ADD13D"></a><h5 id="APPUG-GUID-0522D9DF-E342-4451-A167-0FD0E5ADD13D" class="sect5">灵活的呼叫顺序</h5>
                     <div>
                        <p><a id="d17239e1984" class="indexterm-anchor"></a><a id="d17239e1988" class="indexterm-anchor"></a>只要远程事务程序的<code class="codeph">SEND/RECEIVE</code>请求得到满足，每次调用时在TIP和网关之间交换的数据参数的数量可以由用户自行决定。例如，远程事务程序数据交换序列可能是：</p><pre class="oac_no_warn" dir="ltr">APPC SEND 5字段（field1-field5）APPC RECEIVE 1字段（field6）APPC SEND 1字段（field7）APPC RECEIVE 3字段（field8-field10）</pre><p>生成的TIP /应用程序调用序列可以是：</p><pre class="oac_no_warn" dir="ltr">tip_call1（parm1 OUT，&lt; -  APPC SEND field1来自远程TP parm2 OUT，&lt; -  APPC SEND field2来自远程TP parm3 OUT）; &lt; -  APPC SEND field3来自远程TP tip_call2（parm4 OUT，&lt; -  APPC SEND field4来自远程TP parm5 OUT）; &lt; -  APPC SEND field5来自远程TP tip_call3（parm6 IN OUT）; - &gt; APPC RECEIVE field6在远程TP &lt; -  APPC SEND field7从远程TP tip_call4（parm8 IN， - &gt; APPC RECEIVE field8到远程TP parm9 IN， - &gt; APPC RECEIVE field9到远程TP parm10 IN）; - &gt; APPC RECEIVE field10进入远程TP</pre><p>要将这四个公共函数定义到TIP，必须发出四个PGAU <code class="codeph">DEFINE CALL</code>语句，每个语句都指定其唯一的公共函数名称（ <code class="codeph">tip_callx</code> ）和要交换的数据参数列表。一旦使用<code class="codeph">DEFINE DATA</code>定义了数据项，就可以在任何模式（ <code class="codeph">IN</code> ， <code class="codeph">OUT</code>或<code class="codeph">IN OUT</code> ）中多次调用它。例如， <code class="codeph">parm5</code>可以用来代替第二时间<code class="codeph">parm6</code> 。这意味着相同的数据被在这两种情况下进行交换，接收到的TIP和应用上<code class="codeph">tip_call2</code>并返回，可能被更新，以在远程主机<code class="codeph">tip_call4</code> 。
                        </p>
                        <p>另请注意，远程事务程序的前五个写入字段由两个单独的TIP函数调用<code class="codeph">tip_call1</code>和<code class="codeph">tip_call2</code> 。这也可以通过每个<code class="codeph">OUT</code>参数的五个TIP函数调用或具有五个<code class="codeph">OUT</code>参数的单个TIP函数调用等效地完成。然后远程交易程序的第一读字段（ <code class="codeph">field6</code> ）和随后的写入字段（ <code class="codeph">field7</code> ）对应于单个TIP函数调用（ <code class="codeph">tip_call3</code> ）与单个<code class="codeph">IN OUT</code>参数（ <code class="codeph">parm6</code> ）。
                        </p>
                        <p>这种使用单一的<code class="codeph">IN OUT</code>参数意味着远程交易程序的数据类型为<code class="codeph">field6</code>和<code class="codeph">field7</code>都是相同的，并且对应于用于的数据类型执行转换<code class="codeph">parm6</code> 。如果<code class="codeph">field6</code>和<code class="codeph">field7</code>的数据类型不同，那么它们必须对应于不同的PL / SQL参数（例如， <code class="codeph">parm6</code> <code class="codeph">IN</code>和<code class="codeph">parm7</code> <code class="codeph">OUT</code> ）。但是，它们仍然可以在单个TIP呼叫上交换为两个参数，或者在两个TIP呼叫中交换为一个参数。
                        </p>
                        <p>最后，远程事务程序的剩余三个<code class="codeph">RECEIVE</code>字段由<code class="codeph">tip_call4</code>参数8-10提供。它们也可以通过三个TIP调用完成，每个参数传递一个参数，或者两个TIP调用在一个调用中传递一个参数，在另一个调用中传递两个参数，以任一顺序。这种灵活性允许用户以最适合用户的任何方式定义远程交易程序的操作和TIP函数调用之间的对应关系。
                        </p>
                     </div>
                  </div><a id="APPUG984"></a><div class="props_rev_3"><a id="GUID-14708CCA-BE3B-4571-9F1D-CA2158D51816" name="GUID-14708CCA-BE3B-4571-9F1D-CA2158D51816"></a><h5 id="APPUG-GUID-14708CCA-BE3B-4571-9F1D-CA2158D51816" class="sect5">致电通信订单限制</h5>
                     <div>
                        <p><a id="d17239e2145" class="indexterm-anchor"></a>每个TIP公共函数在接收任何<code class="codeph">OUT</code>参数之前首先发送所有<code class="codeph">IN</code>参数。因此，期望发送一个字段然后接收一个字段的远程事务程序必须对应于单独的TIP调用。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">tip_callO（parmO OUT）; &lt; -  APPC发送远程TP的外场</pre><p><code class="codeph">PGAXFER</code> RPC首先检查要发送的参数，但是找不到并继续接收参数：</p><pre class="oac_no_warn" dir="ltr">tip_callI（parmI IN）; - &gt; APPC RECEIVE内场到远程TP</pre><p><code class="codeph">PGAXFER</code> RPC处理要发送的参数，然后检查要接收的参数，但找不到并完成;因此，具有<code class="codeph">OUT</code>参数后跟<code class="codeph">IN</code>参数的单个TIP公共函数不起作用，因为首先处理<code class="codeph">IN</code>参数 - 无论其在参数列表中的位置如何。
                        </p>
                     </div>
                  </div>
               </div><a id="APPUG985"></a><div class="props_rev_3"><a id="GUID-21400950-327F-4A8B-831D-3F34333C3264" name="GUID-21400950-327F-4A8B-831D-3F34333C3264"></a><h4 id="APPUG-GUID-21400950-327F-4A8B-831D-3F34333C3264" class="sect4">交易通信</h4>
                  <div>
                     <p>该<a id="d17239e2234" class="indexterm-anchor"></a>远程主机事务使用PGAU <code class="codeph">DEFINE TRANSACTION</code>语句定义，并附加对事务支持的<code class="codeph">CALL</code>的先前定义的引用。
                     </p>
                     <p>你指定了<a id="d17239e2247" class="indexterm-anchor"></a>远程主机事务属性，例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>交易ID或名称</p>
                        </li>
                        <li>
                           <p>网络地址或位置</p>
                        </li>
                        <li>
                           <p>系统类型（例如IBM370）</p>
                        </li>
                        <li>
                           <p>Oracle National语言的远程主机</p>
                           <div class="infoboxnote" id="GUID-21400950-327F-4A8B-831D-3F34333C3264__GUID-51349B34-B64C-4BB1-9549-15EC0CACC394">
                              <p class="notep1">注意：</p>
                              <p>该<a id="d17239e2268" class="indexterm-anchor"></a>定义事务时指定PL / SQL包名称;这是引用TIP的名称，以及公共函数调用的名称包含在TIP中。每个公共函数必须先前已使用PGAU <code class="codeph">DEFINE CALL</code>语句定义，该语句已存储在PG DD中。如果未在<code class="codeph">GENERATE</code>语句中指定包名称（TIP名称），则默认情况下，您指定的事务名称将成为包名称。在这种情况下，事务名称（ <span class="italic"><code class="codeph">tname)</code></span>必须是唯一的，并且必须在包含PL / SQL包的数据库中的有效PL / SQL语法中。
                              </p>
                              <p>欲了解更多信息，请参阅<span class="q">“ <a href="pga-utility-oracle-database-gateway-appc.html#GUID-EC8B6848-0566-45CD-BA08-78F15ED0EEB4">定义事务处理</a></span>中的<span class="q">”</span> <a href="pga-utility-oracle-database-gateway-appc.html#GUID-F73E20E7-D94C-468F-BA65-CC34F6373F19">程序网关管理实用程序</a>和<span class="q">“ <a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-C8F9DE40-9DE6-4F49-A765-BFFDEC3065F9">样品PGAU定义事务处理的声明</a> ”，</span>在<a href="admin-utility-samples-oracle-database-gateway-appc.html#GUID-AA9B8762-BDAF-4EED-A8B0-09F8A937F04E">管理实用程序样本</a> 。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>在此示例中，以下<code class="codeph">DEFINE TRANSACTION</code>语句用于定义名为<code class="codeph">DB2I</code>的远程CICS事务：</p><pre class="oac_no_warn" dir="ltr">DEFINE TRANSACTION DB2I CALL（DB2IMAIN，DB2IDIAG）SIDEPROFILE（CICSPROD）TPNAME（DB2I）LOGMODE（ORAPLU62）SYNCLEVEL（0）NLS_LANGUAGE（“AMERICAN_AMERICA.WE8EBCDIC37C”）;</pre></div>
               </div>
            </div><a id="APPUG986"></a><div class="props_rev_3"><a id="GUID-1C0A2278-D220-4DDB-888C-F691D057BB78" name="GUID-1C0A2278-D220-4DDB-888C-F691D057BB78"></a><h3 id="APPUG-GUID-1C0A2278-D220-4DDB-888C-F691D057BB78" class="sect3">从客户端应用程序调用TIP</h3>
               <div>
                  <p>创建TIP后，必须编写客户端应用程序以与TIP接口。调用TIP函数的客户端应用程序必须包含五个逻辑部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>声明TIP变量</p>
                     </li>
                     <li>
                        <p>初始化对话</p>
                     </li>
                     <li>
                        <p>交换数据</p>
                     </li>
                     <li>
                        <p>终止谈话</p>
                     </li>
                     <li>
                        <p>错误处理</p>
                     </li>
                  </ul>
               </div><a id="APPUG1304"></a><a id="APPUG1305"></a><a id="APPUG987"></a><div class="props_rev_3"><a id="GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6" name="GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6"></a><h4 id="APPUG-GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6" class="sect4">声明TIP变量</h4>
                  <div>
                     <p><code class="codeph">tipname.doc</code>文件的用户声明部分记录了所需的声明。
                     </p>
                     <p>路过时<a id="d17239e2425" class="indexterm-anchor"></a>调用TIP函数时的PL / SQL参数，客户端应用程序必须使用与TIP函数参数完全相同的PL / SQL数据类型，如其规范部分中的TIP所定义。例如，假设以下是TIP规范或<code class="codeph">tipname.doc:</code></p><pre class="oac_no_warn" dir="ltr">功能<span class="italic">tip_call1</span> <span class="italic">tranuse</span> ，IN BINARY_INTEGER， <span class="italic">tip_var1 io_mode pls_type1，</span> <span class="italic">tip_record io_mode tran_rectype）</span> RETURN INTEGER; TYPE <span class="italic">tran_rectype</span>是RECORD <span class="italic">（rec_field1 pls_type1</span> ，...
      <span class="italic">rec_fieldN pls_typeN）</span> ;</pre><p><a href="developing-appc-client-app-sna-only.html#GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6__G1013935" title="这个2列表提供了函数声明的描述。">表4-2</a>提供了函数声明的说明：</p>
                     <div class="tblformal" id="GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6__G1013935">
                        <p class="titleintable">表4-2功能声明</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="功能声明" width="100%" border="1" summary="This 2 column table provides a description of the function declaration." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d17239e2472">项目</th>
                                 <th align="left" valign="bottom" width="69%" id="d17239e2475">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2480" headers="d17239e2472 ">
                                    <p><span class="italic"><code class="codeph">tip_call1</code></span> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2480 d17239e2475 ">
                                    <p>TIP函数名称，在包规范中定义。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2490" headers="d17239e2472 ">
                                    <p><span class="italic"><code class="codeph">tranuse</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2490 d17239e2475 ">
                                    <p>从TIP初始化函数返回的远程事务实例参数，用于标识此TIP调用将在其上交换数据的对话。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2499" headers="d17239e2472 ">
                                    <p><span class="italic"><code class="codeph">tran_rectype</code></span> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2499 d17239e2475 ">
                                    <p>在<code class="codeph">tipname</code>声明的PL / SQL记录数据类型<span class="italic"> </span>提示规范。这与TYPE中的值相同<span class="italic"> </span> <span class="italic"><code class="codeph">tran_rectype</code></span> <code class="codeph">is RECORD</code>语句。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2522" headers="d17239e2472 ">
                                    <p><span class="italic"><code class="codeph">pls_typeN</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2522 d17239e2475 ">
                                    <p>是PL / SQL原子数据类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2531" headers="d17239e2472 ">
                                    <p><span class="italic"><code class="codeph">rec_fieldN</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2531 d17239e2475 ">
                                    <p>PL / SQL记录字段是否对应于远程事务程序记录字段。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>在客户端应用程序中，PL / SQL原子数据类型应定义为TIP函数定义中相应参数的完全相同的数据类型。应在<code class="codeph">BEGIN</code>命令之前在客户端应用程序中编码以下内容：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">appl_var pls_type1</span> ; / *声明appl变量....* /</pre><p>无需重新定义TIP数据类型。它们必须在客户端应用程序中<code class="codeph">locally</code>声明，在<code class="codeph">BEGIN</code>之前出现在客户端应用程序中：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">appl_record tipname.tran_rectype;</span> / *声明appl记录* /</pre><p><a href="developing-appc-client-app-sna-only.html#GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6__G1013965" title="此2列表描述了命令行参数。">表4-3说明</a>了命令行参数：</p>
                     <div class="tblformal" id="GUID-26AFD2F9-2126-418D-9B71-B01D2A06E7E6__G1013965">
                        <p class="titleintable">表4-3命令行参数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="命令行参数" width="100%" border="1" summary="This 2 column table describes the command line arguments." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d17239e2576">项目</th>
                                 <th align="left" valign="bottom" width="69%" id="d17239e2579">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2584" headers="d17239e2576 ">
                                    <p><span class="italic"><code class="codeph">tip_call1</code></span> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2584 d17239e2579 ">
                                    <p>TIP函数名称，在包规范中定义。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2594" headers="d17239e2576 ">
                                    <p><span class="italic"><code class="codeph">tranuse</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2594 d17239e2579 ">
                                    <p>从TIP初始化函数返回的远程事务实例参数，用于标识此TIP调用将在其上交换数据的对话。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e2603" headers="d17239e2576 ">
                                    <p><span class="italic"><code class="codeph">tran_rectype</code></span> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e2603 d17239e2579 ">
                                    <p>在<code class="codeph">tipname</code>声明的PL / SQL记录数据类型<span class="italic"> </span>提示规范。这与<code class="codeph">TYPE</code>值相同<span class="italic">                    </span> <span class="italic"><code class="codeph">tran_rectype</code></span> <code class="codeph">is RECORD</code>语句。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>有关您可以引用的用户声明的完整说明，请参阅<span class="italic"><code class="codeph">tipname</code></span> <code class="codeph">.doc</code>内容文件。
                     </p>
                     <p>客户端应用程序调用TIP公共函数，就像它是任何本地PL / SQL函数一样：</p><pre class="oac_no_warn" dir="ltr">rc = tip_call1（tranuse，appl_var，appl_record）;</pre><p>在CICS-DB2查询示例中，PL / SQL驱动程序为<code class="codeph">pgadb2id.sql</code> ，即<span class="bold"> </span>位于<code class="codeph">%ORACLE_HOME%\dg4appc\demo\CICS</code> Windows的<code class="codeph">%ORACLE_HOME%\dg4appc\demo\CICS</code>目录和基于UNIX的系统的<code class="codeph">$ORACLE_HOME/dg4appc/demo/CICS</code>目录中，是客户端应用程序，包括以下声明：</p><pre class="oac_no_warn" dir="ltr">......创建或替换过程db2idriv（empno IN CHAR）是tranuse INTEGER：= 0 / *事务使用号* / DCLEMP PGADB2I.DCLEMP_typ; / * DB2 EMP行定义* / DB2 PGADB2I.DB2_typ; / * DB2诊断信息* / rc INTEGER：= 0 / * PGA RPC返回码* /行VARCHAR2（132）; / *工作缓冲区用于输出* / term INTEGER：= 0; / * 1如果pgadb2i_term调用* / ......</pre></div>
               </div><a id="APPUG988"></a><div class="props_rev_3"><a id="GUID-41ABD528-5797-468E-A436-B6B3434ADF34" name="GUID-41ABD528-5797-468E-A436-B6B3434ADF34"></a><h4 id="APPUG-GUID-41ABD528-5797-468E-A436-B6B3434ADF34" class="sect4">初始化对话</h4>
                  <div>
                     <p>打电话给<a id="d17239e2688" class="indexterm-anchor"></a>初始化对话有以下几个目的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使PL / SQL包，TIP加载并执行TIP初始化部分中编程的初始化逻辑。</p>
                        </li>
                        <li>
                           <p>使TIP init函数调用<code class="codeph">PGAINIT</code>远程过程调用（RPC），后者又建立与远程事务程序（RTP）的通信，并将事务实例号返回给应用程序。
                           </p>
                        </li>
                     </ul>
                     <p>（可选）初始化对话的调用可用于：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>覆盖默认的RHT / OLTP标识，网络地址属性和对话安全用户标识和密码。</p>
                        </li>
                        <li>
                           <p>指定什么诊断<a id="d17239e2712" class="indexterm-anchor"></a>跟踪TIP是为了生产。有关诊断跟踪的详细信息，请参阅<a href="troubleshooting-oracle-database-gateway-appc.html#GUID-6A2105DD-D6F0-4368-BE63-F8A85D5C959F">故障排除</a> 。
                           </p>
                        </li>
                     </ul>
                     <p>PGAU生成的TIP提供四种不同的初始化函数，客户端应用程序可以调用它们。这些是重载函数，它们都具有相同的名称，但在传递的参数类型方面有所不同。</p>
                     <p>传递三个初始化参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>RHT会话标识的事务实例编号。所有TIP初始化都需要<code class="codeph">tranuse</code>参数。
                           </p>
                        </li>
                        <li>
                           <p>TIP运行时诊断控件的TIP诊断标志。<code class="codeph">tipdiag</code>参数是可选的。有关TIP诊断的讨论，请参阅<a href="troubleshooting-oracle-database-gateway-appc.html#GUID-6A2105DD-D6F0-4368-BE63-F8A85D5C959F">故障排除</a> 。
                           </p>
                        </li>
                        <li>
                           <p>覆盖OLTP和网络属性的提示默认覆盖。<code class="codeph">override</code>参数是可选的。
                           </p>
                        </li>
                     </ul>
                     <p>显示以下四个功能，因为它们可能出现在TIP内容文档文件中。稍后提供客户端应用程序使用的示例。</p><pre class="oac_no_warn" dir="ltr">TYPE override_Typ IS RECORD（tranname VARCHAR2（255），/ * Transaction Program * / transync BINARY_INTEGER，/ * RESERVED * / trannls VARCHAR2（50），/ * RESERVED * / oltpname VARCHAR2（255），/ * Logical Unit * / oltpmode VARCHAR2 （255），/ * LOG模式条目* / netaddr VARCHAR2（255），/ * Side Profile * / oltpuser VARCHAR2（8），/ * userid用于OLTP访问* / oltppass VARCHAR2（8））; / * OLTP访问密码* / FUNCTION pgadb2i_init（/ * init standard * / tranuse IN OUT BINARY_INTEGER）RETURN INTEGER;功能pgadb2i_init（/ * init override * / tranuse IN OUT BINARY_INTEGER，覆盖IN override_Typ）RETURN INTEGER;功能pgadb2i_init（/ * init diagnostic * / tranuse IN OUT BNARY_INTEGER，tipdiag IN CHAR）RETURN INTEGER;功能pgadb2i_init（/ * init over-diag * / tranuse IN OUT BINARY_INTEGER，覆盖IN override_Typ，tipdiag IN CHAR）RETURN INTEGER;</pre></div><a id="APPUG989"></a><div class="props_rev_3"><a id="GUID-29DC252A-A067-4092-87B8-80AB1AC6AC04" name="GUID-29DC252A-A067-4092-87B8-80AB1AC6AC04"></a><h5 id="APPUG-GUID-29DC252A-A067-4092-87B8-80AB1AC6AC04" class="sect5">交易实例参数</h5>
                     <div>
                        <p>此事务实例编号（在示例中显示为<code class="codeph">tranuse</code> ）必须传递给后续的TIP交换和终止函数。它向网关标识APPC对话 - 以及远程事务程序的哪次迭代 - 数据将被传输或通信终止。
                        </p>
                        <p>单个客户端应用程序可以同时控制同一远程事务程序或多个不同远程事务程序的多个实例。事务实例编号是TIP的机制，用于通过网关将客户端应用程序调用路由到预期的远程事务程序。</p>
                        <p>客户端应用程序负责保存每个活动事务的事务实例编号，并将正确的事务传递给为该事务调用的每个TIP函数。</p>
                        <p>客户端应用程序调用TIP初始化函数，就好像它是任何本地PL / SQL函数一样。例如：</p><pre class="oac_no_warn" dir="ltr">......tranuse INTEGER：= 0; / *交易使用数* / ......BEGIN rc：= pgadb2i.pgadb2i_init（tranuse）; ......</pre></div>
                  </div><a id="APPUG990"></a><div class="props_rev_3"><a id="GUID-125BF246-33A2-46AF-87E8-7344F3B4F573" name="GUID-125BF246-33A2-46AF-87E8-7344F3B4F573"></a><h5 id="APPUG-GUID-125BF246-33A2-46AF-87E8-7344F3B4F573" class="sect5">覆盖TIP初始化</h5>
                     <div>
                        <p>请注意，在前面的示例中，客户端应用程序未指定任何远程事务程序名称，网络连接或安全信息。TIP将此类信息内部编码为默认值，客户端应用程序只是为所选的远程事务程序调用适当的TIP。但是，客户端应用程序可以选择覆盖某些TIP默认值并提供安全信息。</p>
                        <p>您无需更改任何不需要覆盖的客户端应用程序。</p>
                        <p>在PG DD中定义远程主机事务时， <code class="codeph">DEFINE TRANSACTION</code>语句指定了可以覆盖的某些默认OLTP和网络标识属性：<a id="d17239e2852" class="indexterm-anchor"></a><a id="d17239e2856" class="indexterm-anchor"></a><a id="d17239e2860" class="indexterm-anchor"></a><a id="d17239e2864" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">TPNAME</code></span></p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">LUNAME</code></span></p>
                           </li>
                           <li>
                              <p><code class="codeph">LOGMODE</code></p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">侧面轮廓</code></span></p>
                           </li>
                        </ul>
                        <p>有关<code class="codeph">DEFINE TRANSACTION</code>语句的更多信息，请参阅<a href="pga-utility-oracle-database-gateway-appc.html#GUID-F73E20E7-D94C-468F-BA65-CC34F6373F19">Procedural Gateway Administration Utility中的</a> <span class="q">“ <a href="pga-utility-oracle-database-gateway-appc.html#GUID-EC8B6848-0566-45CD-BA08-78F15ED0EEB4">DEFINE TRANSACTION</a> ”</span> 。
                        </p>
                        <p>这些PG DD定义的事务属性作为默认值生成到TIP中，并且可以在其中被覆盖<a id="d17239e2904" class="indexterm-anchor"></a>提示初始化时间。这便于使用一个TIP，该TIP可以与测试事务或系统一起使用，并且稍后可以与生产事务或系统一起使用，而不必重新生成TIP。</p>
                        <p><code class="codeph">override_Typ</code>记录数据类型描述了客户端应用程序可以覆盖的各种事务属性。目前支持以下o verrides：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">tranname</code>可以设置为覆盖<code class="codeph">DEFINE TRANSACTION</code>语句的<code class="codeph">TPNAME</code>参数指定的值</p>
                           </li>
                           <li>
                              <p><code class="codeph">oltpname</code>可以设置为覆盖<code class="codeph">DEFINE TRANSACTION</code>语句的<code class="codeph">LUNAME</code>参数指定的值</p>
                           </li>
                           <li>
                              <p><code class="codeph">oltpmode</code>可以设置为覆盖<code class="codeph">DEFINE TRANSACTION</code>语句的<code class="codeph">LOGMODE</code>参数指定的值</p>
                           </li>
                           <li>
                              <p><code class="codeph">netaddr</code>可以设置为覆盖<code class="codeph">DEFINE TRANSACTION</code>语句的<code class="codeph">SIDEPROFILE</code>参数指定的值</p>
                           </li>
                        </ul>
                        <p>除了在中定义的事务属性<a id="d17239e2968" class="indexterm-anchor"></a> PG DD，有两个与安全相关的参数，会话安全用户ID和会话安全密码，可以在TIP初始化时覆盖。这些参数的值通常来自用于访问网关的数据库链接或Oracle数据库会话。有些情况下，Oracle数据库用户标识不足以访问OLTP系统。用户标识和密码重写提供了一种向OLTP系统指定这些参数的方法。
                        </p>
                        <p>目前支持以下覆盖：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">oltpuser</code>可以设置为覆盖用于初始化OLTP对话的用户ID</p>
                           </li>
                           <li>
                              <p><code class="codeph">oltppass</code>可以设置为覆盖用于初始化OLTP对话的密码</p>
                           </li>
                        </ul>
                        <p>仅当在网关初始化文件中指定了<code class="codeph">PGA_SECURITY_TYPE=PROGRAM</code>且OLTP系统配置为接收传入会话请求的用户ID和密码时，安全覆盖才会生效。
                        </p>
                        <p><code class="codeph">transync</code> （APPC <code class="codeph">SYNCLEVEL</code> ）和<code class="codeph">trannls</code> （全球化支持字符集）在覆盖记录数据类型中定义，但保留供将来使用。无法覆盖RHT <code class="codeph">SYNCLEVEL</code>和全球化支持名称。
                        </p>
                        <p>客户端应用程序可能会在TIP初始化时覆盖默认属性，原因如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>启动不同版本的RHT（例如生产而不是测试）</p>
                           </li>
                           <li>
                              <p>更改包含RHT的OLTP的位置（如果由于迁移或切换到备份配置而移动了OLTP）</p>
                           </li>
                        </ul>
                        <p>需要覆盖的客户端应用程序可以使用覆盖和初始化参数的任意组合，并且可以随时更改组合，而无需重新生成TIP或影响不覆盖参数的应用程序。</p>
                        <p>要覆盖TIP默认值，必须将其他客户端应用程序记录变量声明为<code class="codeph">override_Typ</code>数据类型，必须将值分配给覆盖子字段，并且必须在客户端应用程序的TIP初始化调用上传递覆盖记录变量。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">......my_overrides pgadb2i.override_Typ; -  宣言 ......my_overrides.oltpname：='CICSPROD'; - 交换到生产CICS my_overrides.tranname：='TNEW'; - 新事务名称BEGIN rc：= pgadb2i.pgadb2i_init（tranuse，my_overrides）; -  在里面 ......
</pre><p>在TIP中，检查覆盖属性的语法问题并将其传递给网关服务器。</p>
                     </div>
                  </div><a id="APPUG991"></a><div class="props_rev_3"><a id="GUID-01314972-B6A2-403B-BFD0-81F5BA60F3E2" name="GUID-01314972-B6A2-403B-BFD0-81F5BA60F3E2"></a><h5 id="APPUG-GUID-01314972-B6A2-403B-BFD0-81F5BA60F3E2" class="sect5">安全考虑因素</h5>
                     <div>
                        <p>该<a id="d17239e3061" class="indexterm-anchor"></a><a id="d17239e3065" class="indexterm-anchor"></a>默认和重写的OLTP的安全要求必须相同，因为在任一对话中使用相同的网关服务器，如PGA RPC调用中的数据库链接名称所指示的那样。网关服务器启动安全模式在网关服务器初始化时设置，并在TIP或会话初始化时未更改地传递给OLTP。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="APPUG992"></a><div class="props_rev_3"><a id="GUID-62418ADB-1A9B-4DCC-A2D5-70940D7ECBFC" name="GUID-62418ADB-1A9B-4DCC-A2D5-70940D7ECBFC"></a><h3 id="APPUG-GUID-62418ADB-1A9B-4DCC-A2D5-70940D7ECBFC" class="sect3">交换数据</h3>
               <div>
                  <div class="section">
                     <p>客户端应用程序应传递从先前的<code class="codeph">tip_init</code>调用返回的事务实例号，以识别受影响的远程事务程序，并识别要与远程事务程序交换的任何客户端应用程序数据参数。
                     </p>
                     <p>在此CICS-DB2查询示例中，我们传递员工编号并接收员工记录：</p><pre class="oac_no_warn" dir="ltr">rc = pgadb2i.pgadb2i_main（tranuse，/ * transfer data * / empno，/ *员工编号* / DCLEMP）; / *返回员工记录* /</pre></div>
                  <!-- class="section" -->
               </div><a id="APPUG993"></a><div class="props_rev_3"><a id="GUID-3CDB9504-3937-4909-A6FE-3B63FC25BF75" name="GUID-3CDB9504-3937-4909-A6FE-3B63FC25BF75"></a><h4 id="APPUG-GUID-3CDB9504-3937-4909-A6FE-3B63FC25BF75" class="sect4">终止对话</h4>
                  <div>
                     <p>客户端应用程序调用TIP终止函数，就好像它是任何本地PL / SQL函数一样。例如：</p><pre class="oac_no_warn" dir="ltr">......术语：= 1; / *表示名为* * / rc的术语：= pgadb2i.pgadb2i_term（tranuse，0）; / *正常终止* / ......
</pre><p>在TIP终止调用上传递事务实例号以终止事务之后，或者在远程事务程序已经终止之后，可能忘记该特定事务实例号。</p>
                  </div>
               </div><a id="APPUG994"></a><div class="props_rev_3"><a id="GUID-4A799962-BFF3-47FD-AB6D-C99474E157D8" name="GUID-4A799962-BFF3-47FD-AB6D-C99474E157D8"></a><h4 id="APPUG-GUID-4A799962-BFF3-47FD-AB6D-C99474E157D8" class="sect4">错误处理</h4>
                  <div>
                     <p>客户端应用程序应包含一个异常处理程序，可以在客户端应用程序终止之前清除任何活动的APPC对话。<code class="codeph">pgadb2id.sql</code>中提供的示例客户端应用程序包含异常处理的示例。
                     </p>
                     <p>网关例外报告在PGA-20900至PGA-20999范围内。发生异常时，应为先前调用TIP初始化函数启动的任何活动对话调用TIP终止函数。</p>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">如果等于等于等于等于0，则终止函数尚未被调用* / rc：= pgadb2i.pgadb2i_term（tranuse，1）; / *异常终止* / END IF;提高; ......
</pre><p>远程事务还应包括错误处理和调试的规定，例如将调试信息写入CICS临时存储队列区域。有关如何拦截和处理Oracle异常的讨论，请参阅<a href="../lnpls/plsql-error-handling.html#LNPLS00701" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a> 。
                     </p>
                  </div>
               </div><a id="APPUG995"></a><div class="props_rev_3"><a id="GUID-4FFF7E49-C061-4A57-A575-3EF98E2A1E50" name="GUID-4FFF7E49-C061-4A57-A575-3EF98E2A1E50"></a><h4 id="APPUG-GUID-4FFF7E49-C061-4A57-A575-3EF98E2A1E50" class="sect4">授予执行权限</h4>
                  <div>
                     <div class="section">
                        <p>TIP是一个标准<a id="d17239e3264" class="indexterm-anchor"></a>必须向从客户端应用程序调用TIP的用户授予PL / SQL包和执行权限。在这个例子中，我们将<code class="codeph">PGADB2I</code>包的执行权授予用户<code class="codeph">SCOTT</code> ：</p><pre class="oac_no_warn" dir="ltr">授予PGADB2I到SCOTT的授权</pre><p>有关详细信息，请参阅“ <a href="../admin/getting-started-with-database-administration.html#ADMIN11062" target="_blank"><span class="italic">Oracle数据库管理员指南”</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="APPUG996"></a><div class="props_rev_3"><a id="GUID-19815A38-8520-41D5-9418-2DB46AFDB9AA" name="GUID-19815A38-8520-41D5-9418-2DB46AFDB9AA"></a><h3 id="APPUG-GUID-19815A38-8520-41D5-9418-2DB46AFDB9AA" class="sect3">执行申请</h3>
               <div>
                  <div class="section">
                     <p>在执行客户端应用程序之前，请确保已建立与主机的连接并且接收伙伴可用。在此示例中，我们使用PL / SQL驱动程序<code class="codeph">DB2IDRIV</code>来执行CICS-DB2查询。要执行此客户端应用程序，请从SQL * Plus输入：</p><pre class="oac_no_warn" dir="ltr">在执行DB2IDRIV（ <span class="italic">'nnnnnn'</span> <span class="italic"><code class="codeph">)</code></span>设置serveroutput;</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="APPUG997"></a><div class="props_rev_3"><a id="GUID-E02BE2D4-97BA-407C-B1D6-4503D79561D7" name="GUID-E02BE2D4-97BA-407C-B1D6-4503D79561D7"></a><h3 id="APPUG-GUID-E02BE2D4-97BA-407C-B1D6-4503D79561D7" class="sect3">APPC对话共享</h3>
               <div>
                  <p>多个TIP可以与一个或多个共享相同的APPC对话<a id="d17239e3375" class="indexterm-anchor"></a>远程主机事务（RHT），它们也共享同一个对话。这个功能有两个好处：<a id="d17239e3380" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Oracle Database Gateway for APPC支持依赖于对话的传递控制的现有RHT。</p>
                     </li>
                     <li>
                        <p>对于PL / SQL编译而言太大的TIP可以分成多个较小的TIP，每个TIP具有较少的用户定义函数，为客户端应用程序提供相同的函数调用和数据定义集，而无需对RHT进行任何更改。</p>
                     </li>
                  </ul>
               </div><a id="APPUG998"></a><div class="props_rev_3"><a id="GUID-7C9B4EAB-3D8C-4DF0-8E32-F45845336F1A" name="GUID-7C9B4EAB-3D8C-4DF0-8E32-F45845336F1A"></a><h4 id="APPUG-GUID-7C9B4EAB-3D8C-4DF0-8E32-F45845336F1A" class="sect4">APPC会话共享概念</h4>
                  <div>
                     <p>大型机OLTP（例如IMS）允许事务通过在事务调用另一个事务时传递它来共享单个APPC对话。RHT被定义为PGAU，作为具有调用，输入和输出的单个事务，PGAU为其生成具有与该特定RHT对应的初始化，传输和终止功能的单个TIP。</p>
                     <p>每个TIP生成的逻辑允许TIP：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在调用init函数时启动新会话，或者</p>
                        </li>
                        <li>
                           <p>在调用用户定义的函数时传输现有会话上的数据，或者</p>
                        </li>
                        <li>
                           <p>在调用其“term”函数时终止现有会话。</p>
                        </li>
                     </ul>
                     <p>APPC对话被视为由多个TIP共享和管理的资源。不要求任何TIP成为APPC对话的唯一用户。</p>
                     <p>任何<a id="d17239e3447" class="indexterm-anchor"></a>在3.4.0或更高版本生成的TIP可以执行以下任何服务组合：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>发起</p>
                        </li>
                        <li>
                           <p>启动和转移</p>
                        </li>
                        <li>
                           <p>启动，转移和终止（标准操作）</p>
                        </li>
                        <li>
                           <p>传递</p>
                        </li>
                        <li>
                           <p>转移和终止</p>
                        </li>
                        <li>
                           <p>终止</p>
                        </li>
                        <li>
                           <p>启动和终止（假设其他TIP执行转移）</p>
                        </li>
                     </ul>
                     <p>可以通过以下方式共享单个APPC对话：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>从一个TIP到多个RHT</p>
                        </li>
                        <li>
                           <p>从多个TIP到一个RHT</p>
                        </li>
                        <li>
                           <p>从多个TIP到多个RHT</p>
                        </li>
                     </ul>
                     <p>如果没有APPC会话共享，则必须定义单个TIP，其中包含客户端应用程序可能需要调用的所有RHT的所有功能和数据。使用RHT的超集创建TIP通常会导致此类TIP过大而无法编译PL / SQL。</p>
                     <p>相反，通过APPC会话共享，可以在单个TIP中定义每个RHT（甚至用于执行多个不同数据交换操作的RHT的每个RHT数据交换），该TIP更小并且不太可能超过PL / SQL编译限制。</p>
                  </div>
               </div><a id="APPUG999"></a><div class="props_rev_3"><a id="GUID-D7BCC8CE-C9A1-479E-B53E-53EFCFEB44F8" name="GUID-D7BCC8CE-C9A1-479E-B53E-53EFCFEB44F8"></a><h4 id="APPUG-GUID-D7BCC8CE-C9A1-479E-B53E-53EFCFEB44F8" class="sect4">APPC会话共享使用</h4>
                  <div>
                     <p>APPC会话共享在3.4.0或更高版本生成的每个TIP中自动可用。3.4.0之前没有生成的TIP可以参与APPC会话共享。必须使用PGAU 3.4.0重新生成3.4.0之前生成的TIP。或者以后参加APPC会话分享。PGAU向上兼容，再生应该是透明的，只要重新编译再生的TIP体（ <span class="italic"><code class="codeph">tipname</code></span> <code class="codeph">.pkb</code> ）。如果还重新编译TIP规范，则客户端应用程序也需要重新编译。有关更多详细信息，请参阅<a href="tip-internals-oracle-database-gateway-appc.html#GUID-9F4E3177-13B0-43CE-AD0A-5BCD66B3FD17">Tip Internals</a> 。
                     </p>
                     <p>如先前在第1,2和3章中讨论的那样完成TIP的定义和生成。不需要指定其他选项或参数。</p>
                     <p><a id="d17239e3541" class="indexterm-anchor"></a>运行时使用APPC会话共享受客户端应用程序的控制。它只需通过调用其中一个共享对话的TIP的init函数并将返回的<code class="codeph">tranuse</code>值传递给其他TIP函数来完成，因为每个函数都以其所需的顺序调用。可以使用任何TIP初始化函数，前提是所有TIP都使用相同的<code class="codeph">DEFINE TRANSACTION TPNAME</code>或<code class="codeph">SIDEPROFILE</code>值定义。<code class="codeph">TPNAME</code>或<code class="codeph">SIDEPROFILE</code>值指定要初始化的RHT。
                     </p>
                     <p>当调用支持APPC会话共享的TIP的init功能来初始化会话时，返回的<code class="codeph">tranuse</code>值表示启用了会话共享。通过在其他TIP中调用函数时传递相同的<code class="codeph">tranuse</code>值，那些其他TIP在已初始化的同一对话上执行传输，前提是所涉及的所有TIP都是在3.4.0或更高版本生成的。
                     </p>
                  </div>
               </div><a id="APPUG1000"></a><div class="props_rev_3"><a id="GUID-5B01C80D-5FC0-45B8-B17B-D1BDBD882BD7" name="GUID-5B01C80D-5FC0-45B8-B17B-D1BDBD882BD7"></a><h4 id="APPUG-GUID-5B01C80D-5FC0-45B8-B17B-D1BDBD882BD7" class="sect4">APPC会话共享TIP兼容性</h4>
                  <div>
                     <p>TIPs产生于3.4.0或更高版本<a id="d17239e3612" class="indexterm-anchor"></a>与3.4.0之前的TIP相比，数据库网关使用并期望不同的<code class="codeph">tranuse</code>值。如果使用3.4.0之前的TIP初始化会话并将其<code class="codeph">tranuse</code>值传递给3.4.0或更高版本的TIP，则会引发以下异常：</p><pre class="oac_no_warn" dir="ltr">ORA-20704 PGA_TIP：无法共享tranuse值</pre><p>但是，3.4.0之前生成的TIP不会检测共享对话的不同<code class="codeph">tranuse</code>值，这可能会导致不可预测的错误。
                     </p>
                     <div class="infoboxnote" id="GUID-5B01C80D-5FC0-45B8-B17B-D1BDBD882BD7__GUID-83D84FD1-D319-4532-A54A-E4A07FD62E59">
                        <p class="notep1">注意：</p>
                        <p>必须在3.4.0或更高版本生成在共享对话中调用的所有TIP。</p>
                        <p>3.4.0之前没有生成的TIP可以参与APPC会话共享。</p>
                     </div>
                     <p><code class="codeph">tranuse</code>值在3.4.0之前和3.4.0或更高版本之间不兼容。由于以下原因，这不应该对您造成问题：在3.4.0之前，必须通过该TIP函数调用TIP中定义的所有RHT函数，并且必须首先调用相同TIP的init函数来初始化会话。<code class="codeph">tranuse</code>值仅对初始化它的TIP有效。因此，除非您进行编程更改，否则现有应用程序无法意外地混合<code class="codeph">tranuse</code>值。
                     </p>
                     <p>3.4.0之前的TIP和客户端应用程序可以继续使用而无需更改，旧的客户端应用程序可以无需更改即可调用新的3.4.0或更高版本的TIP。当旧的TIP体被重新生成和编译时，这是可能的。即使旧的客户端应用程序没有改变，TIP现在也能够进行APPC会话共享。</p>
                     <p>3.4.0之前的TIP的所有功能都不能共享APPC会话。但是，一旦TIP在3.4.0或更高版本重新生成，其任何功能都可以共享APPC对话。</p>
                  </div>
               </div><a id="APPUG1306"></a><a id="APPUG1001"></a><div class="props_rev_3"><a id="GUID-CA0E1792-1F88-4DA0-BFCC-D4F40F7B5673" name="GUID-CA0E1792-1F88-4DA0-BFCC-D4F40F7B5673"></a><h4 id="APPUG-GUID-CA0E1792-1F88-4DA0-BFCC-D4F40F7B5673" class="sect4">针对过大的TIP的APPC会话共享</h4>
                  <div>
                     <p><a id="d17239e3692" class="indexterm-anchor"></a>您可以使用会话共享来规避太大而无法编译的TIP。这是由' <code class="codeph">PLS-00123 - package too large to compile</code> '或其他一些问题症状如PL / SQL编译挂起来识别的。在这种情况下，您必须选择要从之前的TIP中删除哪些函数调用并定义为新的TIP。
                     </p>
                     <p>具体来说，你必须决定哪个<a id="d17239e3704" class="indexterm-anchor"></a><a id="d17239e3708" class="indexterm-anchor"></a> PGAU <code class="codeph">DEFINE CALL</code>语句及其相关内容<a id="d17239e3714" class="indexterm-anchor"></a><a id="d17239e3716" class="indexterm-anchor"></a>应将<code class="codeph">DEFINE DATA</code>语句从旧的PGAU控制文件（ <code class="codeph">.ctl</code> ）移动到一个或多个新的PGAU控制文件中。此外，您必须决定在定义每个新TIP的每个新PGAU控制文件中应包含哪些P GAU <code class="codeph">DEFINE TRANSACTION</code>语句。</p>
                     <p>你必须考虑几个PGAU陈述;有关PGAU语句及其说明的列表，请参阅<a href="developing-appc-client-app-sna-only.html#GUID-CA0E1792-1F88-4DA0-BFCC-D4F40F7B5673__G1013981" title="这2列表列出了PGAU语句及其描述">表4-4</a> ：</p>
                     <div class="tblformal" id="GUID-CA0E1792-1F88-4DA0-BFCC-D4F40F7B5673__G1013981">
                        <p class="titleintable">表4-4 PGAU语句</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="PGAU声明" width="100%" border="1" summary="This 2 column table lists the PGAU statements and their descriptions" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d17239e3754">声明</th>
                                 <th align="left" valign="bottom" width="69%" id="d17239e3757">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e3762" headers="d17239e3754 ">
                                    <p><code class="codeph">DEFINE DATA</code>语句</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e3762 d17239e3757 ">
                                    <p>必须是独特的。它们可以由所有受影响的PGAU控制文件共享，前提是它们在被<code class="codeph">DEFINE CALL</code>语句引用之前被定义为过程网关数据字典（PG DD）。这些陈述无需更改。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e3774" headers="d17239e3754 ">
                                    <p><code class="codeph">DEFINE CALL</code>语句</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e3774 d17239e3757 ">
                                    <p>必须是独特的。它们只需要包含它们的TIP的新<code class="codeph">DEFINE TRANSACTION</code>语句引用，只要它们在被<code class="codeph">DEFINE TRANSACTION</code>语句引用之前定义到PG DD即可。可以选择将<code class="codeph">DEFINE CALL</code>语句移动到包含它们的TIP的新PGAU控制文件中。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d17239e3792" headers="d17239e3754 ">
                                    <p><code class="codeph">DEFINE TRANSACTION</code>声明</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d17239e3792 d17239e3757 ">
                                    <p>为每个期望的新TIP指定，并将引用从前一个大TIP移动到新的小TIP的那些呼叫定义。没有任何交易属性会改变。这允许任何新的TIP使用与前一个大TIP相同的RHT执行相同的初始化或终止。旧的<code class="codeph">DEFINE TRANSACTION</code>语句（以前的大型TIP）现在应该排除任何被移动到新的小TIP的调用定义。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="APPUG1307"></a><a id="APPUG1308"></a><a id="APPUG1309"></a><a id="APPUG1002"></a><div class="props_rev_3"><a id="GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F" name="GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F"></a><h4 id="APPUG-GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F" class="sect4">APPC对话共享示例</h4>
                  <div>
                     <p>假设存在RHT <code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code> ，并且RHT <code class="codeph">A</code>执行菜单选择并调用RHT <code class="codeph">B</code>用于查询函数，或调用RHT <code class="codeph">C</code>用于更新，然后是select函数。
                     </p>
                     <p>您可以定义以下<code class="codeph">DATA</code>和<code class="codeph">CALL</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DEFINE DATA</code> <span class="italic"><code class="codeph">choice ...</code></span> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE DATA</code> <span class="italic"><code class="codeph">input ...</code></span> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE DATA</code> <span class="italic"><code class="codeph">answer ...</code></span></p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE DATA</code> <span class="italic"><code class="codeph">record ...</code></span></p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE CALL menu_一个callname（pick）parms（选择）;</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE CALL query_B callname（query）parms（（输入），（answer out））;</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE CALL update_C callname（update）parms（record in）;</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DEFINE CALL select_C callname（select）parms（记录输出）;</code></p>
                        </li>
                     </ul>
                     <p>可以定义以下示例TIP：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F__GUID-5B4B8ECC-AC78-4EF8-BABB-EF572686AACE">例1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例不使用APPC会话共享，但它是在版本3.4.0之前创建的有效TIP定义，它结合了RHT <code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code> 。</p><pre class="oac_no_warn" dir="ltr">DEFINE TRANSACTION rhtABC调用（menu_A，query_B，update_C，select_C）tpname（RHTA）;</pre><p>此TIP包括所有数据定义和调用，可能太大而无法编译。此TIP不使用APPC会话共享，因为只有一个TIP， <code class="codeph">rhtABC</code> 。但是，RHT会在远程主机上执行正常的会话共享。如果TIP足够小以进行编译，则客户端应用程序调用TIP函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">rc：= rhtABC.rhtABC_init（tranuse）; rc：= rhtABC.pick（tranuse，choice）; rc：= rhtABC.query（tranuse，input，answer）; rc：= rhtABC.update（tranuse，record）; rc：= rhtABC.select（tranuse，record）; rc：= rhtABC.rhtABC_term（tranuse）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F__GUID-DD54E1E7-B689-4945-8135-44BB7EBEDE53">例2</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例演示如何使用APPC会话共享定义一组TIP，将RHT <code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code>分为三个TIP：</p><pre class="oac_no_warn" dir="ltr">DEFINE TRANSACTION rhtA调用（menu_A）tpname（RHTA）; DEFINE TRANSACTION rhtB调用（query_B）tpname（RHTA）; DEFINE TRANSACTION rhtC调用（update_C，select_C）tpname（RHTA）;</pre><p>每个TIP仅包括它所需的呼叫和数据，并且每个TIP自动执行APPC会话共享。客户端应用程序调用这些函数如下：</p><pre class="oac_no_warn" dir="ltr">rc：= rhtA.rhtA_init（tranuse）; rc：= rhtA.pick（tranuse，choice）; rc：= rhtB.query（tranuse，input，answer）; rc：= rhtC.update（tranuse，record）; rc：= rhtC.select（tranuse，record）; rc：= rhtB.rhtB_term（tranuse）;</pre><p>两个示例之间唯一的客户端应用程序区别在于每个TIP调用的模式限定符。这是因为被调用的函数位于不同的TIP中，该TIP在数据库中具有不同的包名称。</p>
                        <p>只需要新的<code class="codeph">DEFINE TRANSACTION</code>语句即可使用APPC会话共享。<code class="codeph">CALL</code>和<code class="codeph">DATA</code>定义按原样使用。这意味着旧的TIP <code class="codeph">rhtABC</code>仍然按原样定义，并且可能仍然太大而无法编译。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7194BAD8-2440-48AE-BF6C-3A9BEB8CCF8F__GUID-ED341DA9-8EA1-466F-822A-7D99BC723ABC">例3</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果您执行了示例2，但仍然认为TIP可能太大而无法编译，请尝试以下操作：</p><pre class="oac_no_warn" dir="ltr">DEFINE TRANSACTION rhtABC调用（menu_A）tpname（RHTA）; DEFINE TRANSACTION rhtB调用（query_B）tpname（RHTA）; DEFINE TRANSACTION rhtCU调用（update_C）tpname（RHTA）; DEFINE TRANSACTION rhtCS调用（select_C）tpname（RHTA）;</pre><p>提示<code class="codeph">rhtABC</code>删除了三个函数，因此它现在更小，更有可能编译。提示<code class="codeph">rhtB</code>具有一个功能，即使相应的主机功能保留在单个RHT中，TIP <code class="codeph">rhtC</code>也已被分成两个TIP。</p>
                        <p>客户端应用程序调用这些函数如下：</p><pre class="oac_no_warn" dir="ltr">rc：= rhtB.rhtB_init（tranuse）; rc：= rhtABC.pick（tranuse，choice）; rc：= rhtB.query（tranuse，input）; rc：= rhtCU.update（tranuse，record）; rc：= rhtCS.select（tranuse，record）; rc：= rhtABC.rhtABC_term（tranuse）;</pre><p>使用不同的TIP进行初始化，说明所有TIP都包含init和term函数，并且因为<code class="codeph">DEFINE TRANSACTION</code>语句都指定了相同的<code class="codeph">tpname(RHTA)</code> ，所以始终调用相同的远程主机事务进行初始化。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="APPUG1003"></a><div class="props_rev_3"><a id="GUID-B04E6B1E-4AA9-4CD2-8976-A19B782D99C1" name="GUID-B04E6B1E-4AA9-4CD2-8976-A19B782D99C1"></a><h4 id="APPUG-GUID-B04E6B1E-4AA9-4CD2-8976-A19B782D99C1" class="sect4">APPC会话共享覆盖和诊断</h4>
                  <div>
                     <p><a id="d17239e4060" class="indexterm-anchor"></a> TIP默认覆盖参数在TIP初始化函数中处理，该函数被调用以执行初始化。一旦建立了APPC会话，就不需要进一步共享覆盖参数。除了将覆盖传递给TIP初始化函数之外，您无需做任何其他事情。
                     </p>
                     <p><a id="d17239e4066" class="indexterm-anchor"></a> TIP诊断参数在共享给定对话的所有TIP之间共享。实际上，请求对TIP执行初始化的诊断导致对共享该对话的所有TIP请求相同的诊断。仅可以从一个共享对话的TIP请求诊断是不可能的。应用程序设计者或用户只需将TIP运行时跟踪控件传递给TIP初始化函数。
                     </p>
                  </div>
               </div>
            </div><a id="APPUG1004"></a><div class="props_rev_3"><a id="GUID-2F5FD89A-06E6-47DF-84CD-525B6515B25F" name="GUID-2F5FD89A-06E6-47DF-84CD-525B6515B25F"></a><h3 id="APPUG-GUID-2F5FD89A-06E6-47DF-84CD-525B6515B25F" class="sect3">支持多字节字符集的应用程序开发</h3>
               <div>
                  <p><a id="d17239e4114" class="indexterm-anchor"></a> COBOL目前只支持<a id="d17239e4119" class="indexterm-anchor"></a>双字节字符集（ <a id="d17239e4124" class="indexterm-anchor"></a> DBCS）for <a id="d17239e4129" class="indexterm-anchor"></a> <code class="codeph">PIC G</code>数据类型。
                  </p>
                  <p>PGAU将COBOLII <code class="codeph">PIC G</code>数据类型作为PL / SQL <code class="codeph">VARCHAR2</code>变量处理，并生成TIP，根据为远程主机数据和本地Oracle数据指定的Oracle <code class="codeph">NLS_LANGUAGE</code>自动转换数据。
                  </p>
                  <p>可以将这些Oracle <code class="codeph">NLS_LANGUAGE</code>指定为TIP与远程事务交换的所有<code class="codeph">PIC G</code>数据的默认值（请参阅<code class="codeph">DEFINE TRANSACTION</code> <code class="codeph">...</code><code class="codeph">REMOTE_MBCS</code>或<code class="codeph">LOCAL_MBCS</code> ）。可以进一步覆盖任何单个<code class="codeph">PIC G</code>数据项的Oracle <code class="codeph">NLS_LANGUAGE</code> （请参阅<code class="codeph">REDEFINE DATA</code> <code class="codeph">...</code><code class="codeph">REMOTE</code>或<code class="codeph">LOCAL_LANGUAGE</code> ）。
                  </p>
                  <p>DBCS数据可以以受支持的DBCS字符集的任意组合进行编码。例如，Oracle数据库网关支持一个远程主机应用程序，该应用程序允许记录中每个数据字段使用不同的代码页<a id="d17239e4186" class="indexterm-anchor"></a> MBCS <a id="d17239e4189" class="indexterm-anchor"></a>支持。
                  </p>
                  <p>使用<code class="codeph">REDEFINE DATA ...还支持<code class="codeph">PIC X</code>项目上的REMOTE_LANGUAGE</code>或<code class="codeph">LOCAL_LANGUAGE</code> 。因此，除了剩余的<code class="codeph">PIC X</code>数据字段的默认SBCS转换之外，TIP还可以对指定的<code class="codeph">PIC X</code>数据字段执行DBCS或MBCS转换。默认SBCS转换是根据<code class="codeph">DEFINE TRANSACTION...NLS_LANGUAGE</code>和本地Oracle默认<code class="codeph">LANGUAGE</code>环境值。
                  </p>
                  <p>当PGAU生成TIP时， <code class="codeph">PIC G</code>数据类型将转换为PL / SQL <code class="codeph">VARCHAR2</code>数据类型。通过TIP转换后，由于删除了shift-out和shift-in元字符，收到的<code class="codeph">'PIC G' VARCHAR2</code>数据类型的长度可以小于最大值，并且发送的<code class="codeph">'PIC G'</code> G'RAWs将具有移出和移位-in根据指定的远程主机字符集的要求插入字符。
                  </p>
                  <p>这与为<code class="codeph">PIC X</code>数据执行的转换不同，后者始终是已知的固定长度，因此<code class="codeph">CHAR</code>数据类型在TIP中用于<code class="codeph">PIC X</code>数据字段。但是，即使<code class="codeph">PIC X</code>字段包含DBCS或MBCS数据，仍然会使用<code class="codeph">CHAR</code>变量，并在需要时填充空白。
                  </p>
                  <p>某些远程主机应用程序将<code class="codeph">PIC G</code>字段与<code class="codeph">PIC X</code>字节组合在一起，用于移出，移入元字符插入。这样的COBOL定义可能如下所示：</p><pre class="oac_no_warn" dir="ltr">01 MY_RECORD。 05 SO PIC X. 05 MY_SBCS_DATA PIC G（52）。05 SI PIC X.</pre><p>PGAU无法正确处理这一点，因为在执行转换时，所有三个字段都被定义并因此被视为单独的数据项。</p>
                  <p>要正确处理，输入到PGAU的定义应为：</p><pre class="oac_no_warn" dir="ltr">01 MY_RECORD。 05 MY_MBCS_DATA PIC G（51）。
</pre><p>PGAU <code class="codeph">REDEFINE DATA</code>语句可以通过在字段<code class="codeph">SO</code>和<code class="codeph">SI</code>以及<code class="codeph">'05 MY_MBCS_DATA PIC G(51).'</code>上指定<code class="codeph">USAGE(SKIP)</code>来将3字段定义重新定义为1字段定义<code class="codeph">'05 MY_MBCS_DATA PIC G(51).'</code>重新定义<code class="codeph">MY_MBCS_DATA</code> 。三个<code class="codeph">REDEFINE</code>语句可以放在PGAU输入控制文件中，因此不需要更改远程主机定义。
                  </p>
               </div>
            </div><a id="APPUG1005"></a><div class="props_rev_3"><a id="GUID-B118F27C-0B26-4429-8B70-3CC5B01C6A93" name="GUID-B118F27C-0B26-4429-8B70-3CC5B01C6A93"></a><h3 id="APPUG-GUID-B118F27C-0B26-4429-8B70-3CC5B01C6A93" class="sect3">修改面向终端的事务以使用APPC</h3>
               <div>
                  <p><a id="d17239e4322" class="indexterm-anchor"></a><a id="d17239e4326" class="indexterm-anchor"></a>远程事务程序必须包括映射的APPC动词以启动，通信和终止APPC对话。但是，当远程事务程序面向终端时，可以使用以下选项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您可以将终端逻辑与应用程序和I / O逻辑分开。一旦实现这种分离，就可以编写一个小的前端远程事务程序，以便在网关调用和事务应用程序逻辑之间进行接口。例如，在CICS中，CICS <code class="codeph">LINK</code>用于实现此技术。
                        </p>
                     </li>
                     <li>
                        <p>您可以修改现有程序，以便嵌入APPC调用。在示例<code class="codeph">PGADB2I</code> ，我们使用CICS及其关联的映射APPC动词，如下所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>EXEC CICS <code class="codeph">ASSIGN</code>接受网关发起的对话。
                              </p>
                           </li>
                           <li>
                              <p>EXEC CICS <code class="codeph">RECEIVE</code>接收参数。
                              </p>
                           </li>
                           <li>
                              <p>EXEC CICS <code class="codeph">SEND</code>结束结果。
                              </p>
                           </li>
                           <li>
                              <p>EXEC CICS <code class="codeph">RETURN</code>终止对话。
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>如果您不想修改面向终端的事务，则可以在面向终端的程序和网关之间插入支持APPC的接口，例如IBM Corporation的面向z / OS的CICS Transaction Server的FEPI。</p>
                     </li>
                     <li>
                        <p>使用IMS / TM，可以使用隐式APPC工具通过网关访问现有的未修改IMS事务。使用隐式APPC，当通过APPC调用IMS事务时，使用I / O PCB的标准DLI GU，GN和ISRT调用将自动转换为适当的APPC发送或接收调用。<a id="d17239e4375" class="indexterm-anchor"></a></p>
                     </li>
                  </ul>
               </div>
            </div><a id="APPUG1006"></a><div class="props_rev_3"><a id="GUID-8E530425-F978-4095-8A39-B8FD8BE2A47A" name="GUID-8E530425-F978-4095-8A39-B8FD8BE2A47A"></a><h3 id="APPUG-GUID-8E530425-F978-4095-8A39-B8FD8BE2A47A" class="sect3">使用TIP所需的权限</h3>
               <div>
                  <p>必须向TIP或过程的调用者显式授予执行权限。无法通过角色授予此权限。</p>
                  <p>任何想要跟踪TIP的TIP用户都必须被授予对rtrace和ptrace过程的执行权限。有关详细信息，请参阅安装指南中适用于您的通信协议的章节中的“配置PGAU”部分。</p>
                  <p>例如，在Microsoft Windows上：</p><pre class="oac_no_warn" dir="ltr">C：\&gt; sqlplus pgaadmin \ <span class="italic">pw @ database_specification_string</span> SQL&gt;将<span class="italic">pgaadmin.purge_trace</span>上的执行权授予<span class="italic">tip_user_userid</span> ; SQL&gt;将<span class="italic">pgaadmin.read_trace</span>上的执行权限授予<span class="italic">tip_user_userid;</span> 
</pre><p>在基于UNIX的系统上：</p><pre class="oac_no_warn" dir="ltr">$ sqlplus pgaadmin / <span class="italic">pw @ database_specification_string</span> SQL&gt;将<span class="italic">pgaadmin.purge_trace</span>上的执行权授予<span class="italic">tip_user_userid</span> ; SQL&gt;将<span class="italic">pgaadmin.read_trace</span>上的执行权限授予<span class="italic">tip_user_userid;</span> 
</pre><p>在开发TIP之后，必须由TIP所有者授予TIP用户对TIP的执行权限。TIP所有者通常是<code class="codeph">PGAADMIN</code> ，但可以是另一个被授予<code class="codeph">PGDDDEF</code>或<code class="codeph">PGDDGEN</code>角色的用户。
                  </p>
                  <p>例如，在Microsoft Windows上：</p><pre class="oac_no_warn" dir="ltr">C：\&gt; sqlplus tip_owner \ <span class="italic">pw @ database_specification_string</span> SQL&gt;在tipname <span class="italic">上将</span>执行权限授予<span class="italic">tip_user_userid</span> ;</pre><p>在基于UNIX的系统上：</p><pre class="oac_no_warn" dir="ltr">$ sqlplus tip_owner / <span class="italic">pw @ database_specification_string</span> SQL&gt;将<span class="italic">tip命令</span>执行到<span class="italic">tip_user_userid</span> ;</pre><p>其中<span class="italic"><code class="codeph">database_specification_string</code></span>是<a id="d17239e4493" class="indexterm-anchor"></a>安装了网关<code class="codeph">UTL_RAW</code>和<code class="codeph">UTL_PG</code>组件的Oracle数据库的Oracle Net标识符。这与执行TIP的Oracle数据库相同，并且从TIP所有者用户ID执行TIP上的授权。</p>
                  <p>Microsoft Windows上的<code class="codeph">%ORACLE_HOME%\dg4appc\admin</code>目录和基于UNIX的系统上的<code class="codeph">$ORACLE_HOME/dg4appc/admin</code>目录中提供了用于执行这些授权的SQL脚本。该<a id="d17239e4510" class="indexterm-anchor"></a><a id="d17239e4512" class="indexterm-anchor"></a> <code class="codeph">pgddausr.sql</code>脚本执行授权，以便由单个TIP用户对包进行私有访问。如果要使用私有授权，则必须为每个TIP用户的用户ID运行一次<code class="codeph">pgddausr.sql</code>脚本。</p>
                  <p>要运行这些脚本，请使用SQL * Plus以<code class="codeph">PGAADMIN</code>用户<code class="codeph">PGAADMIN</code>连接到Oracle数据库。从SQL * Plus，在Microsoft Windows上的<code class="codeph">%ORACLE_HOME%\dg4appc\admin</code>目录或基于UNIX的系统上的<code class="codeph">$ORACLE_HOME/dg4appc/admin</code>目录中运行<code class="codeph">pgddausr.sql</code>脚本。该脚本执行必要的授权，如前所述。系统会提示您输入所需的用户标识，密码和数据库规范字符串。如果您使用的是私有授权，请对需要访问软件包的每个用户ID重复此步骤。
                  </p>
                  <p>没有提供脚本来执行公共拨款。为此，请发出以下命令：</p>
                  <p>对于Microsoft Windows：</p><pre class="oac_no_warn" dir="ltr">C：\&gt; sqlplus tip_owner \ <span class="italic">pw @ database_specification_string</span> SQL&gt;将tipname上的execute赋予PUBLIC;</pre><p>对于基于UNIX的系统：</p><pre class="oac_no_warn" dir="ltr">$ sqlplus tip_owner / <span class="italic">pw @ database_specification_string</span> SQL&gt;将tipname上的execute赋予PUBLIC;</pre></div>
            </div>
         </div>
      </article>
   </body>
</html>