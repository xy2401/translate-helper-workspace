<html id="13512.database-gateway-webspheremq-pgm-packages.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>PGM，PGM_UTL8和PGM_SUP包</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Installation and User&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Installation and User&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-gateway-websphere-mq-installation-and-users-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-16T19:05:45-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2006, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96225-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="database-gateway-webspheremq-running-environment.html" title="Previous" type="text/html"></link>
      <link rel="next" href="database-gateway-webspheremq-utl-raw-packages.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Gateway for WebSphere MQ Installation and User&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="WSMQG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="database-gateway-webspheremq-running-environment.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="database-gateway-webspheremq-utl-raw-packages.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">安装和用户指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PGM，PGM_UTL8和PGM_SUP包</li>
            </ol>
            <a id="GUID-DA9F7248-C6FD-45DE-BD68-7372F60848FF" name="GUID-DA9F7248-C6FD-45DE-BD68-7372F60848FF"></a><a id="WSMQG233"></a>
            
            <h2 id="WSMQG-GUID-DA9F7248-C6FD-45DE-BD68-7372F60848FF" class="sect2"><span class="enumeration_appendix">A</span> PGM，PGM_UTL8和PGM_SUP包</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d15338e19" class="indexterm-anchor"></a>在开发通过网关访问WebSphere MQ的应用程序时，请使用Visual Workbench。Visual Workbench定义了一个用于访问WebSphere MQ的接口，并自动为Oracle应用程序生成PL / SQL代码（MIP）以与网关连接。有关Visual Workbench的详细信息，请参阅<span class="italic">适用于WebSphere MQ安装</span>的<span class="italic">Oracle Procedural Gateway Visual Workbench和适用于Microsoft Windows的用户指南（32位）</span> 。
               </p>
               <p><a id="d15338e28" class="indexterm-anchor"></a> MIP使用来自<code class="codeph">PGM</code> ， <code class="codeph">PGM_UTL8</code>和的定义<a id="d15338e39" class="indexterm-anchor"></a> <code class="codeph">PGM_SUP</code>包。必要时，您可以更改MIP以包含Visual Workbench不支持的WebSphere MQ功能。这是通过<code class="codeph">PGM</code> ， <code class="codeph">PGM_UTL8</code>和<code class="codeph">PGM_SUP</code>包中的定义和过程完成的。
               </p>
               <p>创建Visual Workbench存储库或DG4MQ部署环境时，将安装<code class="codeph">PGM</code> ， <code class="codeph">PGM_UTL8</code>和<code class="codeph">PGM_SUP</code>软件包。
               </p>
               <p>以下主题讨论<code class="codeph">PGM</code> ， <code class="codeph">PGM_UTL8</code>和<code class="codeph">PGM_SUP</code>包：</p>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="configuring-database-gateway-webspheremq.html#GUID-73165695-D5CB-4EE0-927C-05467DA79DF4" title="按照本节中的步骤安装Oracle Visual Workbench存储库。">安装Oracle Visual Workbench存储库</a></li>
                     <li><a href="configuring-database-gateway-webspheremq.html#GUID-A6FA8628-F99D-4B20-9F3F-D2CCA16491C7" title="这些准备工作包括在生产数据库上准备，安装和删除PL / SQL包。">准备生产Oracle数据库</a></li>
                  </ul>
               </div>
            </div>
            <a id="WSMQG234"></a><div class="props_rev_3"><a id="GUID-F46B648D-6D7C-45CA-9397-F2F64856C18E" name="GUID-F46B648D-6D7C-45CA-9397-F2F64856C18E"></a><h3 id="WSMQG-GUID-F46B648D-6D7C-45CA-9397-F2F64856C18E" class="sect3">PGM包，DG4MQ网关程序和数据类型定义</h3>
               <div>
                  <p><code class="codeph">PGM</code>包的网关过程和类型定义在WebSphere MQ MQI调用之后建模。
                  </p>
                  <p><a id="d15338e123" class="indexterm-anchor"></a>对于所有相关的呼叫和结构<a id="d15338e128" class="indexterm-anchor"></a> MQI， <code class="codeph">PGM</code>存在相应的对应项， <code class="codeph">pgmobj.sql</code>存在关联的数据类型定义。网关过程和<code class="codeph">PGM</code>类型定义的名称与其MQI对应项相同。但是，参数或结构字段的数据类型将更改为相应的PL / SQL数据类型。
                  </p>
                  <p>在Oracle应用程序中使用这些过程和类型定义与编写WebSphere MQ应用程序非常相似。初始化所有<code class="codeph">PGM</code>类型定义的字段。这些初始化值基于MQI定义的默认值。</p>
                  <p>使用网关过程和<code class="codeph">PGM</code>类型定义通常需要广泛的MQI和WebSphere MQ编程知识。这些过程和记录遵循MQI流程图，语义和语法规则。
                  </p>
                  <p>创建Visual Workbench存储库或DG4MQ部署环境并授予公共访问权限时，将安装<code class="codeph">PGM</code>软件包。它没有架构，因为在描述或运行过程时，网关会省略所有架构名称。不需要为过程名称和类型定义添加模式限定符。
                  </p>
                  <div class="infoboxnotealso" id="GUID-F46B648D-6D7C-45CA-9397-F2F64856C18E__GUID-4E6CC415-3452-432B-9DEB-54D210F589F0">
                     <p class="notep1">也可以看看：</p>
                     <p>有关编写WebSphere MQ应用程序和使用MQI调用的完整信息，请参阅IBM <span class="italic">MQSeries Application Programming Reference</span> 。
                     </p>
                  </div>
               </div><a id="WSMQG342"></a><a id="WSMQG235"></a><div class="props_rev_3"><a id="GUID-A9DD3D26-932F-4912-95A4-B8337C786EB1" name="GUID-A9DD3D26-932F-4912-95A4-B8337C786EB1"></a><h4 id="WSMQG-GUID-A9DD3D26-932F-4912-95A4-B8337C786EB1" class="sect4">程序和类型定义摘要</h4>
                  <div>
                     <p>网关过程和PGM提供以下过程和类型定义。</p>
                     <div class="tblformalwide" id="GUID-A9DD3D26-932F-4912-95A4-B8337C786EB1__GUID-4A28D78B-BB83-419B-A2B2-2BF533CA8F01">
                        <p class="titleintable">表A-1程序和类型定义</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="程序和类型定义" width="100%" border="1" summary="This table describes procedures and type definitions." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d15338e197">程序</th>
                                 <th align="left" valign="bottom" width="31%" id="d15338e200">程序目的</th>
                                 <th align="left" valign="bottom" width="49%" id="d15338e203">类型过程使用的定义</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e208" headers="d15338e197 ">
                                    <p><code class="codeph">MQOPEN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e208 d15338e200 ">
                                    <p>打开队列。</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e208 d15338e203 ">
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOD</code>和<code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e229" headers="d15338e197 ">
                                    <p><code class="codeph">MQPUT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e229 d15338e200 ">
                                    <p>将消息发送到<code class="codeph">MQOPEN</code>打开的队列</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e229 d15338e203 ">
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e258" headers="d15338e197 ">
                                    <p><code class="codeph">MQPUT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e258 d15338e200 ">
                                    <p>将超过32767字节的消息发送到队列</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e258 d15338e203 ">
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPUT_BFFER</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e291" headers="d15338e197 ">
                                    <p><code class="codeph">MQGET</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e291 d15338e200 ">
                                    <p>从<code class="codeph">MQOPEN</code>打开的队列中检索或扫描消息</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e291 d15338e203 ">
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e320" headers="d15338e197 ">
                                    <p><code class="codeph">MQGET</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e320 d15338e200 ">
                                    <p>将超过32767字节的消息发送到队列</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e320 d15338e203 ">
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code></p>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGET_BFFER</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d15338e353" headers="d15338e197 ">
                                    <p><code class="codeph">MQCLOSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d15338e353 d15338e200 ">
                                    <p>关闭<code class="codeph">MQOPEN</code>打开的队列</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d15338e353 d15338e203 ">
                                    <p>不使用类型定义。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="WSMQG236"></a><div class="props_rev_3"><a id="GUID-B5BD757D-4F35-4C6B-B7B0-44D992079EF9" name="GUID-B5BD757D-4F35-4C6B-B7B0-44D992079EF9"></a><h4 id="WSMQG-GUID-B5BD757D-4F35-4C6B-B7B0-44D992079EF9" class="sect4">程序惯例</h4>
                  <div>
                     <p>网关过程在本附录中按字母顺序描述。</p>
                     <p>使用它们的过程描述类型定义。仅描述了可以更改的类型定义字段。省略了与MQI字段等效的其他字段，因为它们是为WebSphere MQ保留的，网关不支持，或包含不应更改的值。</p>
                     <p>使用与等效MQI调用关联的IBM参数名称显示过程的定义。例如：</p><pre class="oac_no_warn" dir="ltr">MQGET（hobj，mqmd，mqgmo，msg）</pre><p><code class="codeph">MQGET</code>调用的语法如下：</p><pre class="oac_no_warn" dir="ltr">MQGET（ <span class="italic">handle</span> ， <span class="italic">descript</span> ， <span class="italic">get_options</span> ， <span class="italic">message</span> ）;</pre><p>哪里：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">handle</code></span>是您在定义中指定为<code class="codeph">hobj</code>的第一个参数的名称。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">descript</code></span>是您在定义中指定为<code class="codeph">mqmd</code>的第二个参数的名称。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">get_options</code></span>是定义中指定为<code class="codeph">mqgmo</code>的第三个参数的名称。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">message</code></span>是定义中指定为<code class="codeph">msg</code>的第四个参数的名称。
                           </p>
                           <p>如果按照定义中显示的顺序对参数进行编码，则可以使用自己的名称作为这些参数。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-B5BD757D-4F35-4C6B-B7B0-44D992079EF9__NOTE-139-E24C1EC3">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/wsmqg&amp;id=LNPLS" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a></p>
                     </div>
                  </div>
               </div><a id="WSMQG237"></a><div class="props_rev_3"><a id="GUID-9E2ABDE0-8AAC-49F7-9867-9A63CA688631" name="GUID-9E2ABDE0-8AAC-49F7-9867-9A63CA688631"></a><h4 id="WSMQG-GUID-9E2ABDE0-8AAC-49F7-9867-9A63CA688631" class="sect4">网关执行MQI调用</h4>
                  <div>
                     <p>这些MQI调用在网关中没有等效的过程。</p>
                     <div class="section">
                        <p>以下MQI调用在网关中没有等效过程，因为Oracle数据库和网关自动执行这些MQI调用的功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d15338e489" class="indexterm-anchor"></a><code class="codeph">MQBACK</code></p>
                              <p>事务控制由Oracle事务协调器处理。Oracle应用程序不需要调用单独的<code class="codeph">MQBACK</code>调用来撤消发送到WebSphere MQ的更改。</p>
                           </li>
                           <li>
                              <p><a id="d15338e502" class="indexterm-anchor"></a><code class="codeph">MQCONN</code></p>
                              <p>只要Oracle应用程序引用网关过程，Oracle数据库和网关就会建立与队列管理器的连接。调用网关过程时使用的数据库链接名称确定网关连接到哪个队列管理器。</p>
                           </li>
                           <li>
                              <p><a id="d15338e512" class="indexterm-anchor"></a><code class="codeph">MQCMIT</code></p>
                              <p>事务控制由Oracle事务协调器处理。Oracle应用程序不需要调用单独的<code class="codeph">MQCMIT</code>调用来提交发送到WebSphere MQ的更改。</p>
                           </li>
                           <li>
                              <p><a id="d15338e525" class="indexterm-anchor"></a><code class="codeph">MQDISC</code></p>
                              <p>Oracle数据库和网关关闭与队列管理器的连接。Oracle应用程序不需要关闭与队列管理器的连接。结束当前Oracle会话或删除数据库链接会导致队列管理器连接结束。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="WSMQG238"></a><div class="props_rev_3"><a id="GUID-F3A47E6A-1C54-4A94-BC2E-C9356BBA1722" name="GUID-F3A47E6A-1C54-4A94-BC2E-C9356BBA1722"></a><h4 id="WSMQG-GUID-F3A47E6A-1C54-4A94-BC2E-C9356BBA1722" class="sect4">不支持的MQI调用</h4>
                  <div>
                     <p>网关不支持这些MQI调用。</p>
                     <div class="section">
                        <p><a id="d15338e557" class="indexterm-anchor"></a>他们是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d15338e565" class="indexterm-anchor"></a><code class="codeph">MQINQ</code></p>
                           </li>
                           <li>
                              <p><a id="d15338e573" class="indexterm-anchor"></a><code class="codeph">MQPUT1</code></p>
                           </li>
                           <li>
                              <p><a id="d15338e581" class="indexterm-anchor"></a><code class="codeph">MQSET</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="WSMQG343"></a><a id="WSMQG344"></a><a id="WSMQG239"></a><div class="props_rev_3"><a id="GUID-D999EA91-2240-4849-B2C9-D9A4AC328EF8" name="GUID-D999EA91-2240-4849-B2C9-D9A4AC328EF8"></a><h4 id="WSMQG-GUID-D999EA91-2240-4849-B2C9-D9A4AC328EF8" class="sect4">迁移提示</h4>
                  <div>
                     <p>本节提供有关如何升级Oracle9 <span class="italic">i</span> DG4MQ和现有自定义PL / SQL应用程序以使用Oracle Database Gateway实现WebSphere MQ功能的信息。
                     </p>
                     <div class="section">
                        <p>更改DG4MQ数据类型和RPC API原型以满足网关基础结构的要求。</p>
                        <p>将DG4MQ升级到Oracle <span class="italic">10g第</span> 2版或更高版本时，Oracle建议您在单独的开发Oracle系统上安装较新版本的DG4MQ。完成系统配置和测试后，传输所有COBOL副本并使用Oracle Visual Workbench重新生成和重新编译MIP。对于自定义代码，请进行必要的更改并重新编译。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D999EA91-2240-4849-B2C9-D9A4AC328EF8__GUID-8A60DEDB-3F8E-4698-A5BE-72838D86DC92">迁移DG4MQ版本8和9 PL / SQL应用程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要迁移DG4MQ版本8和9 PL / SQL应用程序：</p>
                        <ol>
                           <li>
                              <p>在PL / SQL声明性部分中，从以下DG4MQ数据类型中删除<code class="codeph">dblink</code>引用：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQOD</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQMD</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQPMO</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQGMO</code></p>
                                 </li>
                              </ul>
                              <p>然后删除以下<code class="codeph">PGM8</code> 。<code class="codeph">MQ</code> * <code class="codeph">RAW</code>数据类型：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQODRAW</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQMDRAW</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQPMORAW</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM8</code> 。<code class="codeph">MQGMORAW</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>在PL / SQL声明性部分中，更改队列句柄的数据类型，即<code class="codeph">PGM</code>的第三个参数。 <code class="codeph">MQOPEN</code> ，从<code class="codeph">BINARY_INTEGER</code>到<code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code>并用<code class="codeph">PGM</code>替换包名<code class="codeph">PGM8</code> 。</p>
                              <p>更改队列句柄的数据类型，即<code class="codeph">PGM</code>的第三个参数。 <code class="codeph">MQOPEN,</code>从<code class="codeph">BINARY_INTEGER</code>到<code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code> 。</p>
                              <p>例如，对于版本8和9，将以下数据类型更改为为Oracle 10 <span class="italic">g</span>列出的数据类型：</p><pre class="oac_no_warn" dir="ltr">objdesc PGM8。MQOD; msgdesc PGM8。MQMD; putmsgopts PGM8。MQPMO; getmsgopts PGM8。MQGMO; hobj BINARY_INTEGER; mqodRaw PGM8。MQODRAW; mqmdRaw PGM8。MQMDRAW; mqpmoRaw PGM8。MQPMORAW; mqgmoRaw PGM8。MQGMORAW;</pre><p>Oracle 10 <span class="italic">g第</span> 2版及更高版本的数据类型：</p><pre class="oac_no_warn" dir="ltr">objdesc PGM.MQOD; msgdesc PGM.MQMD; putmsgopts PGM.MQPMO; getmsgopts PGM.MQGMO; hobj PGM.MQOH;</pre></li>
                           <li>
                              <p>在PL / SQL可执行文件部分中，从以下DG4MQ过程中删除<code class="codeph">dblink</code>引用：</p><pre class="oac_no_warn" dir="ltr">PGM8。MQOPEN @ dblink（）PGM8。MQPUT @ dblink（）PGM8。MQGET @ dblink（）PGM8。MQCLOSE @ DBLINK（）</pre><p>然后在新的<code class="codeph">PGM.MQOD</code>类型中定义<code class="codeph">dblink</code> ，其中定义了对象队列名称。
                              </p>
                              <p>例如，对于版本8和9：</p><pre class="oac_no_warn" dir="ltr">objdesc.objectname：='QUEUE1';</pre><p>对于Oracle 10 <span class="italic">g第</span> 2版及更高版本：</p><pre class="oac_no_warn" dir="ltr">objdesc.objectname：='QUEUE1'; objdesc.dblinkname：='dblink';</pre></li>
                           <li>
                              <p>如有必要，将所有DG4MQ程序的包名<code class="codeph">PGM8</code>更改为<code class="codeph">PGM</code> 。</p>
                              <p>例如，对于版本8和9：</p><pre class="oac_no_warn" dir="ltr">PGM8。MQOPEN @ DBLINK（）; PGM8。MQPUT @ DBLINK（）; PGM8。MQGET @ DBLINK（）; PGM8。MQCLOSE @ DBLINK（）;</pre><p>对于Oracle 10 <span class="italic">g第</span> 2版及更高版本：</p><pre class="oac_no_warn" dir="ltr">PGM.MQOPEN; PGM.MQPUT; PGM.MQGET; PGM.MQCLOSE;</pre></li>
                           <li>
                              <p>在PL / SQL可执行文件部分中，删除以<code class="codeph">PGM_UTL8</code>开头的所有语句。<code class="codeph">RAW_TO_</code> *，删除所有<code class="codeph">PGM_UTL8</code> 。<code class="codeph">TO_RAW</code>语句，并使用以下DG4MQ过程中的匹配<code class="codeph">MQ</code> *数据类型替换对<code class="codeph">MQ</code> * <code class="codeph">RAW</code>数据类型的所有引用：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOPEN</code> ;</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPU</code> ;</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGET</code> ;</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQCLOSE</code> ;</p>
                                 </li>
                              </ul>
                              <p>例如，对于版本8和9：</p><pre class="oac_no_warn" dir="ltr">mqodRaw：= PGM_UTL8。TO_RAW（objdesc）; PGM8。MQOPEN @dblink（mqodRaw，options，hobj）; objdesc：= PGM_UTL8。RAW_TO_MQMD（mqodRaw）; mqmdRaw：= PGM_UTL8。TO_RAW（msgdesc）; mqpmoRaw：= PGM_UTL8。TO_RAW（putmsgopts）; PGM8。MQPUT @dblink（hobj，mqmdRaw，mqpmoRaw，putbuffer）; putmsgopts：= PGM_UTL8。RAW_TO_MQPMO（mqpmoRaw）; msgdesc：= PGM_UTL8。RAW_TO_MQMD（mqmdRaw）; mqmdRaw：= PGM_UTL8。TO_RAW（msgdesc）; mqgmoRaw：= PGM_UTL8。TO_RAW（getmsgopts）; PGM8。MQGET @dblink（hobj，mqmdRaw，mqgmoRaw，putbuffer）; getmsgopts：= PGM_UTL8。RAW_TO_MQGMO（mqgmoRaw）; msgdesc：= PGM_UTL8。RAW_TO_MQMD（mqmdRaw）;</pre><p>对于Oracle 10 <span class="italic">g第</span> 2版及更高版本：</p><pre class="oac_no_warn" dir="ltr">PGM.MQOPEN（objdesc，options，hobj）; PGM.MQPUT（hobj，msgdesc，putmsgopts，putbuffer）; PGM.MQGET（hobj，msgdesc，getmsgopts，getbuffer）;</pre></li>
                           <li>
                              <p>在PL / SQL可执行文件部分中，删除所有引用旧<code class="codeph">MQ</code> * <code class="codeph">RAW</code>数据类型的语句。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D999EA91-2240-4849-B2C9-D9A4AC328EF8__GUID-95255394-20C9-402D-8347-DDF9D03D85C8">迁移DG4MQ版本4.0.1。*。* PL / SQL应用程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要迁移应用程序：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在PL / SQL声明性部分中，从以下DG4MQ数据类型中删除<code class="codeph">dblink</code>引用：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOD</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>在PL / SQL可执行文件部分中，从以下DG4MQ过程中删除<code class="codeph">dblink</code>引用，并在新<code class="codeph">PGM</code>定义<code class="codeph">dblink</code> 。 <code class="codeph">MQOD</code>对象，其中定义了对象队列名称：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOPEN</code> <code class="codeph">@</code> <code class="codeph">dblink</code> （）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPUT</code> <code class="codeph">@</code> <code class="codeph">dblink</code> （）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQGET</code> <code class="codeph">@</code> <code class="codeph">dblink</code> （）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PGM</code> 。 <code class="codeph">MQCLOSE</code> <code class="codeph">@</code> <code class="codeph">dblink</code> （）</p>
                                 </li>
                              </ul>
                              <p>例如，对于版本4：</p><pre class="oac_no_warn" dir="ltr">PGM.MQOPEN@dblink（objdesc，options，hobj）; objdesc.objectname：='QUEUE1'; PGM.MQPUT@dblink（hobj，msgdesc，putmsgopts，putbuffer）; PGM.MQGET@dblink（hobj，msgdesc，getmsgopts，putbuffer）; PGM.MQCLOSE@dblink（hobj，期权）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="WSMQG345"></a><a id="WSMQG240"></a><div class="props_rev_3"><a id="GUID-4599606A-8CFE-4F86-8915-AE7F98C307FA" name="GUID-4599606A-8CFE-4F86-8915-AE7F98C307FA"></a><h3 id="WSMQG-GUID-4599606A-8CFE-4F86-8915-AE7F98C307FA" class="sect3">MQCLOSE程序</h3>
               <div>
                  <p><code class="codeph">MQCLOSE</code>关闭队列。
                  </p>
                  <div class="section">
                     <p><a id="d15338e1042" class="indexterm-anchor"></a><a id="d15338e1044" class="indexterm-anchor"></a>返回时，队列句柄无效，并且应用程序必须在对队列发出另一个<code class="codeph">MQPUT</code> ， <code class="codeph">MQGET</code>或<code class="codeph">MQCLOSE</code>调用之前，再次调用<code class="codeph">MQOPEN</code>来重新打开队列。
                     </p>
                     <p><code class="codeph">MQCLOSE</code>与MQI调用的区别在于以下方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">MQCLOSE</code>省略了连接句柄参数，因为网关自动负责管理队列管理器连接。
                           </p>
                        </li>
                        <li>
                           <p>MQI完成代码不包含在过程参数列表中。当网关过程因相应的MQI调用失败而失败时，则会向调用方返回Oracle错误消息。</p>
                        </li>
                        <li>
                           <p>MQI原因代码不包含在过程参数列表中。当对网关过程的相应MQI调用返回原因代码时，原因代码将包含在返回给调用者的Oracle错误消息中。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4599606A-8CFE-4F86-8915-AE7F98C307FA__GUID-37F47291-CB86-4E2E-AA05-E9567983629B">定义</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">MQCLOSE（ <span class="italic">hobj</span> ， <span class="italic"><code class="codeph">options</code></span> ）</pre><p>哪里：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">hobj</code></span>包含要关闭的队列的句柄。先前调用<code class="codeph">MQOPEN</code>返回句柄。此输入参数是一个新的<code class="codeph">PGM</code> 。 Oracle <span class="italic">10g第</span> 2版中的<code class="codeph">MQOH</code>对象。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">options</code></span>指定关闭操作。使用<code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQCO_NONE</code>或其他<code class="codeph">PGM_SUP</code>常量用于关闭选项。此输入参数属于<code class="codeph">BINARY_INTEGER</code> PL / SQL数据类型。
                           </p>
                        </li>
                     </ul>
                     <p>当参数按所需顺序时，您可以使用自己的变量名，如下所示：</p><pre class="oac_no_warn" dir="ltr">MQCLOSE（handle，close_options）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-gateway-webspheremq-pgm-packages.html#GUID-04E0A049-C68A-40C2-80C6-7CB1ACC79EA3" title="这些主题提供有关MQCLOSE值的信息。">MQCLOSE值</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="WSMQG346"></a><a id="WSMQG347"></a><a id="WSMQG348"></a><a id="WSMQG241"></a><div class="props_rev_3"><a id="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00" name="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00"></a><h3 id="WSMQG-GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00" class="sect3">MQGET程序</h3>
               <div>
                  <p><code class="codeph">MQGET</code>过程从队列中检索消息。
                  </p>
                  <div class="section">
                     <p><a id="d15338e1178" class="indexterm-anchor"></a><a id="d15338e1182" class="indexterm-anchor"></a><a id="d15338e1186" class="indexterm-anchor"></a><a id="d15338e1190" class="indexterm-anchor"></a>从先前使用<code class="codeph">PGM_SUP</code>调用<code class="codeph">MQOPEN</code> ，队列必须已经打开。 <code class="codeph">MQOO_INPUT_AS_Q_DEF</code> （或等效选项）选项集。此形式的<code class="codeph">MQGET</code>检索消息必须短于32767字节。
                     </p>
                     <p><code class="codeph">MQGET</code>与MQI调用的区别在于以下方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">MQGET</code>省略了连接句柄参数，因为网关自动负责管理队列管理器连接。
                           </p>
                        </li>
                        <li>
                           <p>MQI完成代码不包含在过程的参数列表中。当网关过程因相应的MQI调用失败而失败时，则会向调用方返回Oracle错误消息。</p>
                        </li>
                        <li>
                           <p>MQI原因代码不包含在过程的参数列表中。当对网关过程的相应MQI调用返回原因代码时，原因代码包含在返回给调用者的Oracle错误消息中。</p>
                        </li>
                        <li>
                           <p><code class="codeph">msg</code> length参数不包含在过程的参数列表中，因为Oracle数据库和网关会自动跟踪消息数据长度。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00__GUID-EFE5DC82-24A1-43FE-B879-4EED804017E1">定义</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">MQGET（ <span class="italic">hobj</span> ， <span class="italic"><code class="codeph">mqmd</code></span> ， <span class="italic"><code class="codeph">mqgmo</code></span> ， <span class="italic"><code class="codeph">msg</code></span> ）</pre><p>哪里：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">hobj</code></span>包含要打开的队列的句柄。先前调用<code class="codeph">MQOPEN</code>返回句柄。此输入参数是一个新的<code class="codeph">PGM</code> 。 Oracle <span class="italic">10g第</span> 2版中的<code class="codeph">MQOH</code>对象。
                           </p>
                        </li>
                        <li>
                           <p>输入使用<span class="italic"><code class="codeph">mqmd</code></span>来描述要检索的消息的属性。使用<code class="codeph">PGM</code>的字段。 <code class="codeph">MQMD</code>对象类型定义用于描述这些属性。
                           </p>
                           <p>在输出时， <code class="codeph">mqmd</code>包含有关如何处理请求的信息。队列管理器设置了一些<code class="codeph">PGM</code> 。返回时的<code class="codeph">MQMD</code>对象字段。
                           </p>
                           <p>此输入和输出参数是PL / SQL <code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code>数据类型。
                           </p>
                        </li>
                        <li>
                           <p>输入上使用<span class="italic"><code class="codeph">mqgmo</code></span>来描述控制检索请求的选项值。使用<code class="codeph">PGM</code>的字段。 <code class="codeph">MQGMO</code>对象类型定义用于描述这些选项。
                           </p>
                           <p>在输出时，队列管理器设置一些<code class="codeph">PGM</code> 。返回时<code class="codeph">MQGMO</code>对象字段。
                           </p>
                           <p>此输入和输出参数是PL / SQL <code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code>数据类型。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">msg</code></span>包含检索到的消息。此输出参数是PL / SQL数据类型<code class="codeph">RAW</code>或<code class="codeph">PGM</code> 。 <code class="codeph">MQGET_BUFFER</code> 。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00__GUID-975B405B-CEFF-46A6-805A-2AC6D7078FF9">例子</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ol>
                        <li>
                           <p>参数按所需顺序使用您自己的变量名称：</p><pre class="oac_no_warn" dir="ltr">MQGET（ <span class="italic">句柄</span> ， <span class="italic">描述</span> ， <span class="italic">选择</span> ， <span class="italic">消息</span> ）;</pre></li>
                        <li>
                           <p>以下示例（作为网关示例（ <code class="codeph">ORACLE_HOME\dg4mq\getsample.sql on Microsoft Windows and</code>基于UNIX的系统上的<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/dg4mq/sample/getsample.sql</code> ）提供，从WebSphere MQ队列中读取所有消息。有关更多信息，请参阅有关WebSphere MQ Application Programming的IBM出版物。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00__GUID-9EA2A1A6-620C-486A-B8B3-153E9F6A07F8">
                     <p class="titleinexample">示例A-1 getsample.sql</p><pre class="oac_no_warn" dir="ltr">----版权所有Oracle，2007保留所有权利。-   -  NAME  -  getsample.sql  -   -  DESCRIPTION  - 指定为网关创建的数据库链接名称。为此， - 使用dblink名称替换数据库链接名称“YOUR_DBLINK_NAME” - 您在创建数据库链接时选择了该名称。-   - 此脚本为MQSeries网关执行测试运行。在此脚本中，queuename为'YOUR_QUEUE_NAME'，在网关配置的队列管理器中将其替换为有效的队列名称。-   - 注意 - 从SQL * Plus命令行运行脚本。- 确保用户在包dbms_output上被授予'EXECUTE' -  SET SERVEROUTPUT ON DECLARE objdesc PGM.MQOD; msgDesc PGM.MQMD; getOptions PGM.MQGMO; objectHandle PGM.MQOH; message raw（32767）; BEGIN objdesc。OBJECTNAME：='QUEUE1'; objdesc。DBLINKNAME：='dg4mqdepdblink'; - 打开队列'YOUR_QUEUE_NAME'进行阅读。PGM.MQOPEN（objdesc，PGM_SUP.MQOO_INPUT_AS_Q_DEF，objectHandle）; - 从队列中获取所有消息。真正的循环 - 重置msgid和correlid以获取下一条消息。msgDesc。MSGID：= PGM_SUP.MQMI_NONE; msgDesc。CORRELID：= PGM_SUP.MQCI_NONE; PGM.MQGET（objectHandle，msgDesc，getOptions，message）; - 处理消息....DBMS_OUTPUT.PUT_LINE（'message read back ='|| rawtohex（message））;结束循环; PGM_SUP.NO_MORE_MESSAGES然后DBMS_OUTPUT.PUT_LINE（'警告：在队列中找不到更多消息'）的例外情况; - 再次关闭队列。PGM.MQCLOSE（objectHandle，PGM_SUP.MQCO_NONE）;当其他时间 - 重新提出错误; DBMS_OUTPUT.PUT_LINE（'错误：Oracle Database Gateway for WebSphere MQ验证脚本失败。“）; DBMS_OUTPUT.PUT_LINE（SQLERRM）;提高;结束; /</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>笔记：</p>
                     <div class="infoboxnote" id="GUID-DD4A46FC-6FD6-4985-9183-502F6D4D0C00__GUID-A34246C3-2850-4991-ACE2-530B01589352">
                        <p class="notep1">注意：</p>
                        <p>如果省略异常子句，PL / SQL块将失败。在这种情况下， <code class="codeph">PGM_SUP.NO_MORE_MESSAGES</code>错误代码。每次调用<code class="codeph">MQGET</code>后，都会设置用于<code class="codeph">MQGET</code>的<code class="codeph">MSGID</code>和<code class="codeph">CORRELID</code>字段。如果它们在每个周期都没有复位，那么<code class="codeph">MQGET</code>检查下一条与上一次读操作具有相同标识符的消息，这些消息通常不存在。PL / SQL块只能读取一条消息。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="WSMQG349"></a><a id="WSMQG242"></a><div class="props_rev_3"><a id="GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772" name="GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772"></a><h4 id="WSMQG-GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772" class="sect4">PGM.MQMD类型定义</h4>
                  <div>
                     <p><code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code>指定消息在发送和接收应用程序之间传输时随附的控制信息。
                     </p>
                     <div class="section">
                        <p>它还包含有关队列管理器或接收应用程序如何处理消息的信息。<code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code>描述了要检索的消息的属性。
                        </p>
                        <p>您可以使用<code class="codeph">PGM</code>的默认值。 <code class="codeph">MQMD</code>字段或更改应用程序要求的字段。例如，要更改字段值，请执行以下操作：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">mqmd.field_name</span> ：= <span class="italic">field_value;</span>
</pre><p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">mqmd</code></span>是<code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code>对象数据类型，它描述了要检索的消息的属性</p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">field_name</code></span>是<code class="codeph">PGM</code>的字段名称。 <code class="codeph">MQMD</code>对象类型定义。您可以根据需要设置多个字段。有关字段名称和说明，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772__G670621" title="该表描述了对象字段。">表A-2</a> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">field_value</code></span>是要分配给<span class="italic"><code class="codeph">field_name</code></span>的值。您可以指定值或使用<code class="codeph">PGM_SUP</code>常量来指定值。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772__G670621">
                        <p class="titleintable">表A-2 PGM.MQMD对象字段</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PGM.MQMD对象字段" width="100%" border="1" summary="This table describes object fields." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d15338e1523">字段名称</th>
                                 <th align="left" valign="bottom" width="34%" id="d15338e1526">描述</th>
                                 <th align="left" valign="bottom" width="19%" id="d15338e1529">PL / SQL数据类型</th>
                                 <th align="left" valign="bottom" width="23%" id="d15338e1532">初始值</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1537" headers="d15338e1523 ">
                                    <p><code class="codeph">报告</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1537 d15338e1526 ">
                                    <p>允许发送消息的应用程序指定在发生预期或意外事件时队列管理器应创建哪些报告消息（或多个消息）。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-D50D79CD-0336-4E6C-981D-8A16D662C691">报告字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1537 d15338e1529 ">
                                    <p><code class="codeph">RAW</code> （ <code class="codeph">4</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1537 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQRO_无</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1566" headers="d15338e1523 ">
                                    <p><code class="codeph">MSGTYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1566 d15338e1526 ">
                                    <p>指定消息类型：回复消息，报告消息或正常消息（数据报）。使用PGM_SUP常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-C7167F31-F7CA-45A0-9F27-F7440A110CEC">MSGTYPE字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1566 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1566 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQMT_ DATAGRAM</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1588" headers="d15338e1523 ">
                                    <p><code class="codeph">到期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1588 d15338e1526 ">
                                    <p>指定消息在队列中停留的时间量。到期时间为十分之一秒，由发送应用程序设置。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-C1A4897D-DEBD-4A88-9138-998348648323">EXPIRY字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1588 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1588 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.QMEI_ UNLIMITED</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1613" headers="d15338e1523 ">
                                    <p><code class="codeph">反馈</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1613 d15338e1526 ">
                                    <p>与<code class="codeph">REPORT</code>字段一起使用以指示<code class="codeph">REPORT</code>的类型。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-3F4CD856-3FAB-48B6-89E1-684AD43E7444">反馈字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1613 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1613 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQFB_无</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1641" headers="d15338e1523 ">
                                    <p><code class="codeph">编码</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1641 d15338e1526 ">
                                    <p>用于消息数据中的数值。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-1BA6EADD-0A8B-4B8E-A286-5A53DF95DFE5">编码字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1641 d15338e1529 ">
                                    <p><code class="codeph">RAW</code> （ <code class="codeph">4</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1641 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQENC_ NATIVE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1670" headers="d15338e1523 ">
                                    <p><code class="codeph">CODEDCHARSETID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1670 d15338e1526 ">
                                    <p>指定消息中字符的编码字符集标识符。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-0D262F0E-CD07-4EF6-85F8-62D464B07F15">CODEDCHARSETID字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1670 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1670 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQCCSI_DEFAULT</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1693" headers="d15338e1523 ">
                                    <p><code class="codeph">格式</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1693 d15338e1526 ">
                                    <p>一种自由格式名称，用于通知接收者有关消息内容的信息。指定格式或使用<code class="codeph">PGM_SUP</code>常量。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-127F18E0-5B33-410D-B4FF-9D44411A1158">格式字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1693 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">8</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1693 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQFMT_无</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1722" headers="d15338e1523 ">
                                    <p><code class="codeph">优先</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1722 d15338e1526 ">
                                    <p>指定消息优先级。指定大于或等于<code class="codeph">0</code>的值（零是最低优先级），或使用<code class="codeph">PGM_SUP</code>常量。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-3AA676EF-8B14-445A-A7E2-BF49EA90B13A">优先级字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1722 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1722 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQPRI_ PRIORITY_AS_Q_ DEF</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1752" headers="d15338e1523 ">
                                    <p><code class="codeph">PERSISTENCE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1752 d15338e1526 ">
                                    <p>发送应用程序的输入字段。重新启动队列管理器时，持久性消息仍然存在。重新启动队列管理器时，临时队列中的非持久性消息和消息将丢失。使用<code class="codeph">PGM_SUP</code>常量指定所需的持久性。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-D5AC2FE8-EA91-4854-8D4B-BBF284EB4FC3">PERSISTENCE字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1752 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1752 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQPER_ PERSISTENCE_AS_ Q_DEF</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1779" headers="d15338e1523 ">
                                    <p><code class="codeph">MSGID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1779 d15338e1526 ">
                                    <p>指定要检索的消息的消息标识符（接收消息时）。如果当发送消息（未指定值<code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQMI_NONE</code> ），则队列管理器分配一个唯一的值。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1779 d15338e1529 ">
                                    <p><code class="codeph">RAW</code> （ <code class="codeph">24</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1779 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQMI_NONE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1808" headers="d15338e1523 ">
                                    <p><code class="codeph">CORRELID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1808 d15338e1526 ">
                                    <p>指定接收消息时要检索的消息的相关标识符（请参阅<code class="codeph">MSGID</code>字段）。发送消息时，请指定任何值，或使用<code class="codeph">PGM_SUP</code> 。如果消息不需要相关ID， <code class="codeph">MQCI_NONE</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1808 d15338e1529 ">
                                    <p><code class="codeph">RAW</code> （ <code class="codeph">24</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1808 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQCI_NONE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1841" headers="d15338e1523 ">
                                    <p><code class="codeph">BACKOUTCOUNT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1841 d15338e1526 ">
                                    <p><code class="codeph">MQGET</code>过程的输出字段。它指示由于回滚操作而将消息放回队列的次数。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1841 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1841 d15338e1532 ">
                                    <p><code class="codeph">零</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1860" headers="d15338e1523 ">
                                    <p><code class="codeph">的ReplyToQ</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1860 d15338e1526 ">
                                    <p>指定回复队列的名称。这是<code class="codeph">MQPUT</code>的输入字段，允许发送应用程序指示应发送回复消息的位置。
                                    </p>
                                    <p>它也是<code class="codeph">MQGET</code>的输出字段，并告知接收应用程序在何处发送回复。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1860 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">48</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1860 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1888" headers="d15338e1523 ">
                                    <p><code class="codeph">REPLYTOQMGR</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1888 d15338e1526 ">
                                    <p>指定应将回复消息或报告发送到的队列管理器。这是<code class="codeph">MQPUT</code>的输入字段和<code class="codeph">MQGET</code>的输出字段。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1888 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">48</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1888 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1914" headers="d15338e1523 ">
                                    <p><code class="codeph">UserIdentifier的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1914 d15338e1526 ">
                                    <p>用于接收应用程序的输出字段。它标识发送消息的用户。如果<code class="codeph">MQPUT</code>的<code class="codeph">mqpmo</code>参数的<code class="codeph">CONTEXT</code>字段设置为<code class="codeph">PGM_SUP</code>则发送应用程序可以在输入时指定用户。 <code class="codeph">MQPMO_SET_IDENTITY_CONTEXT</code>或<code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQPMO_SET_ALL_CONTEXT</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1914 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">12</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1914 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1956" headers="d15338e1523 ">
                                    <p><code class="codeph">ACCOUNTINGTOKEN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1956 d15338e1526 ">
                                    <p>用于在应用程序之间传输记帐信息。发送应用程序提供会计信息或使用<code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQACT_NONE</code>指定不包含任何记帐信息。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1956 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">32</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1956 d15338e1532 ">
                                    <p><code class="codeph">PGM_SUP.MQACT_ NONE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e1984" headers="d15338e1523 ">
                                    <p><code class="codeph">APPLIDENTITYDATA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e1984 d15338e1526 ">
                                    <p>指定要与消息一起发送的更多信息，以帮助接收应用程序提供有关消息或其发件人的更多信息。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e1984 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">32</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e1984 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e2004" headers="d15338e1523 ">
                                    <p><code class="codeph">PUTAPPLTYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e2004 d15338e1526 ">
                                    <p>描述将消息放入队列的应用程序类型。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-203D5578-7EF6-4D0F-BABB-5A60D13654CA">PUTAPPLTYPE字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2004 d15338e1529 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2004 d15338e1532 ">
                                    <p><code class="codeph">PGM.MQAT_NO_背景</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e2029" headers="d15338e1523 ">
                                    <p><code class="codeph">PUTAPPLNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e2029 d15338e1526 ">
                                    <p>指定将消息放在队列中的应用程序的名称。发送应用程序指定名称或让队列管理器填写此字段。这是用于接收应用程序的输出字段。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2029 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">28</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2029 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e2049" headers="d15338e1523 ">
                                    <p><code class="codeph">PUTDATE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e2049 d15338e1526 ">
                                    <p>指定消息在队列中的放置日期。发送应用程序可以设置日期或让队列管理器处理它。队列管理器使用的日期格式为<code class="codeph">YYYYMMDD</code> 。这是用于接收应用程序的输出字段。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2049 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">8</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2049 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e2072" headers="d15338e1523 ">
                                    <p><code class="codeph">PUTTIME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e2072 d15338e1526 ">
                                    <p>指定消息在队列中的放置时间。发送应用程序可以设置时间或让队列管理器处理它。队列管理器使用的时间格式是<code class="codeph">HHMMSSTH</code> 。这是用于接收应用程序的输出字段。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2072 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">8</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2072 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15338e2095" headers="d15338e1523 ">
                                    <p><code class="codeph">APPLORIGINDATA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d15338e2095 d15338e1526 ">
                                    <p>发送应用程序用于向消息添加有关消息来源的信息。这是用于接收应用程序的输出字段。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2095 d15338e1529 ">
                                    <p><code class="codeph">CHAR</code> （ <code class="codeph">4</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2095 d15338e1532 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="WSMQG350"></a><a id="WSMQG243"></a><div class="props_rev_3"><a id="GUID-E9406A0B-ECAB-448A-84DE-579E765EA982" name="GUID-E9406A0B-ECAB-448A-84DE-579E765EA982"></a><h4 id="WSMQG-GUID-E9406A0B-ECAB-448A-84DE-579E765EA982" class="sect4">PGM.MQGMO类型定义</h4>
                  <div>
                     <p>使用<code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code>指定有关如何从队列中检索消息的选项和控制信息。
                     </p>
                     <div class="section">
                        <p>使用<code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code>指定有关如何从队列中检索消息的选项和控制信息。您可以使用<code class="codeph">PGM.MQGMO</code>字段的默认值或更改应用程序要求的字段。例如，要更改字段值：</p><pre class="oac_no_warn" dir="ltr">mqgmo <span class="italic">.field_name</span> ：= <span class="italic">field_value</span>
</pre><p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">mqgmo</code>是<code class="codeph">PGM</code> 。 <code class="codeph">MQGMO</code>对象数据类型，它指定有关如何从队列中检索消息的选项和控制信息。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_name</code>是<code class="codeph">PGM</code>的字段名称。 <code class="codeph">MQGMO</code>类型定义。您可以根据需要设置多个字段。有关名称和字段说明，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-E9406A0B-ECAB-448A-84DE-579E765EA982__G670754" title="该表描述了类型定义。">表A-3</a> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_value</code>是要分配给<span class="italic"><code class="codeph">field_name</code></span>的值。您可以指定值或使用<code class="codeph">PGM_SUP</code>常量来指定值。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-E9406A0B-ECAB-448A-84DE-579E765EA982__G670754">
                        <p class="titleintable">表A-3 PGM.MQGMO字段</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PGM.MQGMO字段" width="100%" border="1" summary="This table describes type definitions." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d15338e2224">字段名称</th>
                                 <th align="left" valign="bottom" width="36%" id="d15338e2227">描述</th>
                                 <th align="left" valign="bottom" width="19%" id="d15338e2230">PL / SQL数据类型</th>
                                 <th align="left" valign="bottom" width="23%" id="d15338e2233">初始值</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2238" headers="d15338e2224 ">
                                    <p><code class="codeph">OPTIONS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2238 d15338e2227 ">
                                    <p>指定控制<code class="codeph">MQGET</code>过程的选项。添加一个或多个<code class="codeph">PGM_SUP</code>常量来设置它。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-65EBEF7A-77AF-4DB3-8C57-F54E0BAAA65E">选项字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2238 d15338e2230 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2238 d15338e2233 ">
                                    <p><code class="codeph">PGM.MQGMO_ SYNCPOINT</code></p>
                                    <p>（从队列中检索的消息由Oracle事务协调器协调。）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2268" headers="d15338e2224 ">
                                    <p><code class="codeph">WAITINTERVAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2268 d15338e2227 ">
                                    <p>指定<code class="codeph">MQGET</code>等待消息到达队列的最长时间（以毫秒为单位）。 <code class="codeph">  WAITINTERVAL</code>应等于或大于<code class="codeph">0</code> ，或设置为<code class="codeph">PGM_SUP</code>的值。 <code class="codeph">MQWI_UNLIMITED</code> （无限等待间隔）。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2268 d15338e2230 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2268 d15338e2233 ">
                                    <p><code class="codeph">零</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2299" headers="d15338e2224 ">
                                    <p><code class="codeph">RESOLVEDQNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2299 d15338e2227 ">
                                    <p>包含从中检索消息的目标队列的已解析名称。这是队列管理器在从调用返回时设置的输出字段。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2299 d15338e2230 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2299 d15338e2233 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="WSMQG351"></a><a id="WSMQG244"></a><div class="props_rev_3"><a id="GUID-2E725936-8FBE-44C2-92EC-7BB86CB4A7BF" name="GUID-2E725936-8FBE-44C2-92EC-7BB86CB4A7BF"></a><h3 id="WSMQG-GUID-2E725936-8FBE-44C2-92EC-7BB86CB4A7BF" class="sect3">MQOPEN程序</h3>
               <div>
                  <p><code class="codeph">MQOPEN</code>建立对队列的访问权限。
                  </p>
                  <div class="section">
                     <p><a id="d15338e2342" class="indexterm-anchor"></a><a id="d15338e2346" class="indexterm-anchor"></a><a id="d15338e2350" class="indexterm-anchor"></a><a id="d15338e2352" class="indexterm-anchor"></a><a id="d15338e2356" class="indexterm-anchor"></a><a id="d15338e2360" class="indexterm-anchor"></a>根据选择用于打开队列的模式，应用程序可以发出后续<code class="codeph">MQPUT</code> ， <code class="codeph">MQGET</code>或<code class="codeph">MQCLOSE</code>调用。
                     </p>
                     <p><code class="codeph">MQOPEN</code>与MQI调用的区别在于以下方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">MQOPEN</code>省略了连接句柄参数，因为网关自动负责管理队列管理器连接。
                           </p>
                        </li>
                        <li>
                           <p>MQI完成代码不包含在过程参数列表中。当网关过程因相应的MQI调用失败而失败时，则会向调用方返回Oracle错误消息。</p>
                        </li>
                        <li>
                           <p>MQI原因代码不包含在过程参数列表中。如果对网关过程的相应MQI调用返回原因代码，则原因代码将包含在返回给调用方的Oracle错误消息中。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2E725936-8FBE-44C2-92EC-7BB86CB4A7BF__GUID-BAEE59B9-C198-4531-8A2D-B0DBE986795B">定义</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">MQOPEN（ <code class="codeph">mqod</code> ， <span class="italic">options</span> ， <span class="italic"><code class="codeph">hobj</code></span> ）</pre><p>哪里：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">mqod</code>指定要打开的队列。使用<code class="codeph">PGM</code>的字段。 <code class="codeph">MQOD</code>类型定义用于描述这些属性。在输出时，队列管理器设置一些<code class="codeph">PGM</code> 。返回时的<code class="codeph">MQOD</code>对象字段。
                           </p>
                           <p>此输入和输出参数是PL / SQL <code class="codeph">PGM</code> 。 <code class="codeph">MQOD</code>数据类型。有关<code class="codeph">PGM</code>详细信息。 <code class="codeph">MQOD</code> ，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-C56BD58A-388C-460C-A982-3D7FE3479269" title="PGM.MQOD用于定义要打开的对象。">PGM.MQOD类型定义</a> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">options</code>指定打开的类型。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-E0BCFA54-8510-495B-9B44-F5EFDB3E31AA" title="这些主题提供有关MQOPEN值的信息。">MQOPEN值</a> 。此输入参数是PL / SQL <code class="codeph">BINARY_INTEGER</code>数据类型。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">hobj</code>包含队列打开后队列的句柄，并成为后续PGM调用的输入参数。队列句柄保持有效，直到出现下列情况之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>通过调用<code class="codeph">MQCLOSE</code>关闭队列</p>
                              </li>
                              <li>
                                 <p><code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>命令使当前事务成为永久事务</p>
                              </li>
                              <li>
                                 <p>Oracle用户会话由<code class="codeph">DISCONNECT</code>命令结束。此输出参数属于<code class="codeph">PGM</code> 。 <code class="codeph">MQOH</code>数据类型。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>当参数按所需顺序时，您可以使用自己的变量名，如下所示：</p><pre class="oac_no_warn" dir="ltr">MQOPEN和（describe，open_options，handle）;</pre></div>
                  <!-- class="section" -->
               </div><a id="WSMQG352"></a><a id="WSMQG245"></a><div class="props_rev_3"><a id="GUID-C56BD58A-388C-460C-A982-3D7FE3479269" name="GUID-C56BD58A-388C-460C-A982-3D7FE3479269"></a><h4 id="WSMQG-GUID-C56BD58A-388C-460C-A982-3D7FE3479269" class="sect4">PGM.MQOD类型定义</h4>
                  <div>
                     <p><code class="codeph">PGM</code> 。 <code class="codeph">MQOD</code>用于定义要打开的对象。
                     </p>
                     <div class="section">
                        <p>您可以使用<code class="codeph">PGM</code>的默认值。 <code class="codeph">MQOD</code>字段或更改应用程序要求的字段。例如，您可以按如下方式更改字段值：</p><pre class="oac_no_warn" dir="ltr">MQOD。 <span class="italic">field_name</span> ：= <span class="italic">field_value</span>
</pre><p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">mqod</code>是<code class="codeph">PGM</code> 。 <code class="codeph">MQOD</code>数据类型并指定要打开的对象。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_name</code>是<code class="codeph">PGM</code>的字段名称。 <code class="codeph">MQOD</code>类型定义。您可以根据需要设置多个字段。有关字段名称和说明，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-C56BD58A-388C-460C-A982-3D7FE3479269__G670803" title="该表描述了对象字段。">表A-4</a> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_value</code>是要分配给<span class="italic"><code class="codeph">field_name</code></span>的值。您可以指定值或使用<code class="codeph">PGM_SUP</code>常量来指定值。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-C56BD58A-388C-460C-A982-3D7FE3479269__G670803">
                        <p class="titleintable">表A-4 PGM.MQOD对象字段</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PGM.MQOD对象字段" width="100%" border="1" summary="This table describes object fields." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d15338e2607">字段名称</th>
                                 <th align="left" valign="bottom" width="36%" id="d15338e2610">描述</th>
                                 <th align="left" valign="bottom" width="19%" id="d15338e2613">PL / SQL数据类型</th>
                                 <th align="left" valign="bottom" width="23%" id="d15338e2616">初始值</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2621" headers="d15338e2607 ">
                                    <p><code class="codeph">OBJECTTYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2621 d15338e2610 ">
                                    <p>指定要打开的对象。使用<code class="codeph">PGM_SUP</code>常量指定值。请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-02833624-3AF6-451A-A77E-BADD6A04A85D">OBJECTTYPE字段</a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2621 d15338e2613 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2621 d15338e2616 ">
                                    <p><code class="codeph">PGM_SUP.MQOT_ Q（队列）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2646" headers="d15338e2607 ">
                                    <p><code class="codeph">DBLINKNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2646 d15338e2610 ">
                                    <p>指定数据库链接名称。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2646 d15338e2613 ">
                                    <p><code class="codeph">CHAR</code> （64）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2646 d15338e2616 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2663" headers="d15338e2607 ">
                                    <p><code class="codeph">OBJECTNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2663 d15338e2610 ">
                                    <p>指定队列管理器定义的对象的本地名称。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2663 d15338e2613 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2663 d15338e2616 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2680" headers="d15338e2607 ">
                                    <p><code class="codeph">OBJECTQMGRNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2680 d15338e2610 ">
                                    <p>指定<code class="codeph">OBJECTNAME</code>定义的对象的队列管理器的名称。将<code class="codeph">OBJECTQMGRNAME</code>设置为空值，因为网关仅支持在连接的队列中打开对象。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2680 d15338e2613 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2680 d15338e2616 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2703" headers="d15338e2607 ">
                                    <p><code class="codeph">DYNAMICQNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2703 d15338e2610 ">
                                    <p>除非<code class="codeph">OBJECTNAME</code>字段指定模型队列的名称，否则将被忽略。当涉及模型队列时，该字段指定要在网关所连接的队列管理器上创建的动态队列的名称。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2703 d15338e2613 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2703 d15338e2616 ">
                                    <p><code class="codeph">AMQ。*</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d15338e2723" headers="d15338e2607 ">
                                    <p><code class="codeph">ALTERNATEUSERID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e2723 d15338e2610 ">
                                    <p>如果<code class="codeph">MQOPEN</code>的<code class="codeph">options</code>参数设置为<code class="codeph">PGM_SUP</code>的值。 <code class="codeph">MQOO_ALTERNATE_USER_AUTHORITY</code> ，然后此字段指定队列管理器用于检查正在打开的队列的授权的备用用户ID。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e2723 d15338e2613 ">
                                    <p><code class="codeph">CHAR</code> （12）</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d15338e2723 d15338e2616 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="WSMQG353"></a><a id="WSMQG354"></a><a id="WSMQG355"></a><a id="WSMQG246"></a><div class="props_rev_3"><a id="GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE" name="GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE"></a><h3 id="WSMQG-GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE" class="sect3">MQPUT程序</h3>
               <div>
                  <p><code class="codeph">MQPUT</code>将消息发送到队列。
                  </p>
                  <div class="section">
                     <p><a id="d15338e2781" class="indexterm-anchor"></a><a id="d15338e2785" class="indexterm-anchor"></a><a id="d15338e2789" class="indexterm-anchor"></a>先前对<code class="codeph">MQOPEN</code>调用必须已打开队列，并将其<code class="codeph">options</code>参数设置为<code class="codeph">PGM_SUP</code>的值。 <code class="codeph">MQOO_OUTPUT</code> 。</p>
                     <p><code class="codeph">MQPUT</code>与MQI调用的区别如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">MQPUT</code>省略了连接句柄参数，因为网关自动负责管理队列管理器连接。
                           </p>
                        </li>
                        <li>
                           <p>MQI完成代码不包含在过程参数列表中。当网关过程因相应的MQI调用失败而失败时，则会向调用方返回Oracle错误消息。</p>
                        </li>
                        <li>
                           <p>MQI原因代码不包含在过程参数列表中。当对网关过程的相应MQI调用返回原因代码时，原因代码将包含在返回给调用者的Oracle错误消息中。</p>
                        </li>
                        <li>
                           <p><code class="codeph">msg</code> length参数不包含在过程参数列表中，因为Oracle数据库和网关会自动跟踪消息数据长度。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE__GUID-0131F80C-9BDC-4E8D-9431-B7320D5E83C4">定义</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">MQPUT（ <span class="italic"><code class="codeph">hobj</code></span> ，mqmd，mqpmo， <span class="italic"><code class="codeph">msg</code></span> ）</pre><p>哪里：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">hobj</code>包含要将消息发送到的队列的句柄。先前调用<code class="codeph">MQOPEN</code>返回句柄。此输入参数是Oracle10 <span class="italic">g第</span> 2版中的新<code class="codeph">PGM.MQOH</code> 。
                           </p>
                        </li>
                        <li>
                           <p>输入使用<code class="codeph">mqmd</code>来描述要检索的消息的属性。使用<code class="codeph">PGM</code>的字段。 <code class="codeph">MQMD</code>类型定义用于描述这些属性。在输出时， <code class="codeph">mqmd</code>包含有关如何处理请求的信息。队列管理器设置了一些<code class="codeph">PGM</code> 。返回时的<code class="codeph">MQMD</code>字段。
                           </p>
                           <p>此输入和输出参数是<code class="codeph">PGM</code> 。 <code class="codeph">MQMD</code> 。有关<code class="codeph">PGM</code>详细信息。 <code class="codeph">MQMD</code> ，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-A2AB9748-A680-4BCA-9345-E0E3CAFF1772" title="PGM.MQMD指定消息在发送和接收应用程序之间传输时随附的控制信息。">PGM.MQMD类型定义</a> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">mqpmo</code>用于输入以描述控制put请求的选项值。使用<code class="codeph">PGM</code>的字段。 <code class="codeph">MQPMO</code>类型定义用于描述这些选项。在输出时，队列管理器设置一些<code class="codeph">PGM</code> 。返回时<code class="codeph">MQPMO</code>字段。
                           </p>
                           <p>此输入和输出参数是<code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code> 。有关<code class="codeph">PGM</code>详细信息。 <code class="codeph">MQPMO</code> ，请参考<a href="database-gateway-webspheremq-pgm-packages.html#GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621" title="PGM.MQPMO用于定义MQPUT的mqpmo参数。">PGM.MQPMO类型定义</a> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">msg</code>包含要发送的消息。此输入参数是PL / SQL数据类型<code class="codeph">RAW</code>或<code class="codeph">PGM</code> 。 <code class="codeph">MQPUT_BUFFER</code> 。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE__GUID-326E5A0C-6F6F-4621-AB5F-89221216BB69">例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ol>
                        <li>
                           <p>当参数按所需顺序时，您可以使用自己的变量名称：</p><pre class="oac_no_warn" dir="ltr">MQPUT（句柄，描述，选项，消息）;</pre></li>
                        <li>
                           <p>以下示例（作为网关示例提供（Microsoft Windows上为<code class="codeph">ORACLE_HOME\dg4mq\sample\putsample.sql</code> ，基于UNIX的系统上为<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/dg4mq/sample/putsample.sql</code> ），发送短于32767字节的消息：</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-9C6C227C-BBF4-44F5-BB5D-099E1F9C2BBE__GUID-5A972399-2935-4161-A587-ACFDF12364D7">
                     <p class="titleinexample">例A-2 putsample.sql</p><pre class="oac_no_warn" dir="ltr">-   - 版权所有Oracle，2005保留所有权利。-   -  NAME  -  putsample.sql  -   - 描述 -   - 指定为网关创建的数据库链接名称。为此， - 使用dblink名称替换数据库链接名称“YOUR_DBLINK_NAME” - 您在创建数据库链接时选择了该名称。-   - 此脚本为MQSeries网关执行测试运行。在此脚本中，queuename为'YOUR_QUEUE_NAME'，在网关配置的队列管理器中将其替换为有效的队列名称。-   - 注意 - 从SQL * Plus命令行运行脚本。- 确保用户在包dbms_output上被授予'EXECUTE' -  SET SERVEROUTPUT ON DECLARE objdesc PGM.MQOD; msgDesc PGM.MQMD; putOptions PGM.MQPMO; objectHandle PGM.MQOH; message raw（255）; BEGIN objdesc。OBJECTNAME：='QUEUE1'; objdesc。DBLINKNAME：='dg4mqdepdblink'; - 打开队列'YOUR_QUEUE_NAME'进行发送。PGM.MQOPEN（objdesc，PGM_SUP.MQOO_OUTPUT，objectHandle）; - 将消息缓冲区放在队列中。消息：='01020304050607080900'; PGM.MQPUT（objectHandle，msgDesc，putOptions，message）; - 打印我们放在队列dbms_output.put_line上的消息（'message put on queue ='|| rawtohex（message））; - 再次关闭队列。PGM.MQCLOSE（objectHandle，PGM_SUP.MQCO_NONE）;例外 - 出了别的问题..告诉用户。等等，而DBMS_OUTPUT.PUT_LINE（'错误：IBM MQSeries验证脚本的过程网关失败。“）; DBMS_OUTPUT.PUT_LINE（SQLERRM）; PGM.MQCLOSE（objectHandle，PGM_SUP.MQCO_NONE）;结束; /</pre></div>
                  <!-- class="example" -->
               </div><a id="WSMQG356"></a><a id="WSMQG247"></a><div class="props_rev_3"><a id="GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621" name="GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621"></a><h4 id="WSMQG-GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621" class="sect4">PGM.MQPMO类型定义</h4>
                  <div>
                     <p><code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code>用于定义<code class="codeph">MQPUT</code>的<code class="codeph">mqpmo</code>参数。</p>
                     <div class="section">
                        <p><a id="d15338e3032" class="indexterm-anchor"></a>它指定用于处理消息的选项和控制信息。
                        </p>
                        <p>您可以使用<code class="codeph">PGM</code>的默认值。 <code class="codeph">MQPMO</code>字段或更改应用程序要求的字段。例如，要更改字段值：</p><pre class="oac_no_warn" dir="ltr">mqpmo <span class="italic">.field_name</span> ：= <span class="italic">field_value</span>
</pre><p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">mqpmo</code>是<code class="codeph">PGM</code> 。 <code class="codeph">MQPMO</code>数据类型，并指定有关如何处理消息并将其放入队列的选项和控制信息。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_name</code>是<code class="codeph">PGM</code>的字段名称。 <code class="codeph">MQPMO</code>类型定义。您可以根据需要设置多个字段。有关字段名称和说明，请参阅<a href="database-gateway-webspheremq-pgm-packages.html#GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621__G670865" title="该表描述了字段。">表A-5</a> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">field_value</code>是要分配给<span class="italic"><code class="codeph">field_name</code></span>的值。您可以指定值或使用<code class="codeph">PGM_SUP</code>常量来指定值。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-7AA978BF-8C97-4AA0-A535-8A96C5128621__G670865">
                        <p class="titleintable">表A-5 PGM.MQPMO字段</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PGM.MQPMO Fields" width="100%" border="1" summary="This table describes fields." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="26%" id="d15338e3107">字段名称</th>
                                 <th align="left" valign="bottom" width="36%" id="d15338e3110">描述</th>
                                 <th align="left" valign="bottom" width="19%" id="d15338e3113">PL / SQL数据类型</th>
                                 <th align="left" valign="bottom" width="18%" id="d15338e3116">初始值</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d15338e3121" headers="d15338e3107 ">
                                    <p><code class="codeph">OPTIONS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e3121 d15338e3110 ">
                                    <p>指定控制<code class="codeph">MQPUT</code>过程的选项。通过添加一个或多个<code class="codeph">PGM_SUP</code>定义来设置该字段。请参阅<span class="q">“ <a href="database-gateway-webspheremq-pgm-packages.html#GUID-4AD9BE88-45B5-4C07-A23B-370000A75608">选项字段</a> ”</span> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e3121 d15338e3113 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d15338e3121 d15338e3116 ">
                                    <p><code class="codeph">PGM.MQPMO_ SYNCPOINT</code></p>
                                    <p>（放置在队列中的消息由Oracle事务协调器协调。）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d15338e3152" headers="d15338e3107 ">
                                    <p><code class="codeph">CONTEXT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e3152 d15338e3110 ">
                                    <p>指定输入队列的对象句柄。仅在<code class="codeph">OPTIONS</code>字段的位<code class="codeph">PGM_SUP.MQPMO_PASS_IDENTITY_ CONTEXT</code>或位<code class="codeph">PGM_SUP.MQPMO_PASS_ALL_CONTEXT</code>设置时使用。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e3152 d15338e3113 ">
                                    <p><code class="codeph">BINARY_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d15338e3152 d15338e3116 ">
                                    <p><code class="codeph">零</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d15338e3179" headers="d15338e3107 ">
                                    <p><code class="codeph">RESOLVEDQNA</code> <code class="codeph">ME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e3179 d15338e3110 ">
                                    <p>包含目标队列的已解析名称。这是队列管理器在返回时设置的输出字段。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e3179 d15338e3113 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d15338e3179 d15338e3116 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d15338e3198" headers="d15338e3107 ">
                                    <p><code class="codeph">RESOLVEDQMGRNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d15338e3198 d15338e3110 ">
                                    <p>包含<code class="codeph">RESOLVEDQNAME</code>字段中返回的队列名称的队列管理器的已解析名称。这是队列管理器在返回时设置的输出字段。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d15338e3198 d15338e3113 ">
                                    <p><code class="codeph">CHAR</code> （48）</p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d15338e3198 d15338e3116 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="WSMQG248"></a><div class="props_rev_3"><a id="GUID-2FDE0F27-B2D2-4857-8D2E-BFEFCBA411E4" name="GUID-2FDE0F27-B2D2-4857-8D2E-BFEFCBA411E4"></a><h3 id="WSMQG-GUID-2FDE0F27-B2D2-4857-8D2E-BFEFCBA411E4" class="sect3">PGM_SUP包</h3>
               <div>
                  <p><code class="codeph">PGM_SUP</code>包含用于网关过程和<code class="codeph">PGM</code>类型定义的常量和异常定义。
                  </p>
                  <div class="section">
                     <p><a id="d15338e3246" class="indexterm-anchor"></a><a id="d15338e3250" class="indexterm-anchor"></a><a id="d15338e3254" class="indexterm-anchor"></a>使用这些值通常需要广泛的MQI和WebSphere MQ编程知识。这些定义遵循MQI定义规则。有关编写WebSphere MQ应用程序的完整信息，请参阅“IBM <span class="italic">MQSeries应用程序编程参考”</span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="WSMQG249"></a><div class="props_rev_3"><a id="GUID-12DEDA9E-C144-4317-B8FC-399F911BD9B7" name="GUID-12DEDA9E-C144-4317-B8FC-399F911BD9B7"></a><h4 id="WSMQG-GUID-12DEDA9E-C144-4317-B8FC-399F911BD9B7" class="sect4">PGM.MQGMO值</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">PGM</code>信息。 <code class="codeph">MQGMO</code>值。
                     </p>
                  </div><a id="WSMQG250"></a><div class="props_rev_3"><a id="GUID-65EBEF7A-77AF-4DB3-8C57-F54E0BAAA65E" name="GUID-65EBEF7A-77AF-4DB3-8C57-F54E0BAAA65E"></a><h5 id="WSMQG-GUID-65EBEF7A-77AF-4DB3-8C57-F54E0BAAA65E" class="sect5">选项字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQGMO_NO_WAIT常量binary_integer：= 0; MQGMO_NONE常量binary_integer：= 0; MQGMO_WAIT常量binary_integer：= 1; MQGMO_SYNCPOINT常量binary_integer：= 2; MQGMO_NO_SYNCPOINT常量binary_integer：= 4; MQGMO_SET_SIGNAL常量binary_integer：= 8; MQGMO_BROWSE_FIRST常量binary_integer：= 16; MQGMO_BROWSE_NEXT常量binary_integer：= 32; MQGMO_ACCEPT_TRUNCATED_MSG常量binary_integer：= 64; MQGMO_MARK_SKIP_BACKOUT常量binary_integer：= 128; MQGMO_MSG_UNDER_CURSOR常量binary_integer：= 256; MQGMO_LOCK常量binary_integer：= 512; MQGMO_UNLOCK常量binary_integer：= 1024; MQGMO_BROWSE_MSG_UNDER_CURSOR常量binary_integer：= 2048; MQGMO_SYNCPOINT_IF_PERSISTENT常量binary_integer：= 4096; MQGMO_FAIL_IF_QUIESCING常量binary_integer：= 8192; MQGMO_CONVERT常量binary_integer：= 16384; MQGMO_LOGICAL_ORDER常量binary_integer：= 32768; MQGMO_COMPLETE_MSG常量binary_integer：= 65536; MQGMO_ALL_MSGS_AVAILABLE常量binary_integer：= 131072; MQGMO_ALL_SEGMENTS_AVAILABLE常量binary_integer：= 262144;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG251"></a><div class="props_rev_3"><a id="GUID-ED339B57-8569-423B-B98B-B432723099DC" name="GUID-ED339B57-8569-423B-B98B-B432723099DC"></a><h5 id="WSMQG-GUID-ED339B57-8569-423B-B98B-B432723099DC" class="sect5">版本字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQGMO_VERSION_1常量binary_integer：= 1; MQGMO_CURRENT_VERSION常量binary_integer：= 1; MQGMO_VERSION_2常量binary_integer：= 2; MQGMO_VERSION_3常量binary_integer：= 3;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG252"></a><div class="props_rev_3"><a id="GUID-C3187DB7-FC3F-47E4-8EB9-1AD72CAE95CD" name="GUID-C3187DB7-FC3F-47E4-8EB9-1AD72CAE95CD"></a><h5 id="WSMQG-GUID-C3187DB7-FC3F-47E4-8EB9-1AD72CAE95CD" class="sect5">匹配场</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQMO_DEFAULT常量binary_integer：= 3; MQMO_NONE常量binary_integer：= 0; MQMO_MATCH_MSG_ID常量binary_integer：= 1; MQMO_MATCH_CORREL_ID常量binary_integer：= 2; MQMO_MATCH_GROUP_ID常量binary_integer：= 4; MQMO_MATCH_MSG_SEQ_NUMBER常量binary_integer：= 8; MQMO_MATCH_OFFSET常量binary_integer：= 16; MQMO_MATCH_MSG_TOKEN常量binary_integer：= 32;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG253"></a><div class="props_rev_3"><a id="GUID-C27D1E69-E28E-47F3-B124-4B09E3D64ED3" name="GUID-C27D1E69-E28E-47F3-B124-4B09E3D64ED3"></a><h5 id="WSMQG-GUID-C27D1E69-E28E-47F3-B124-4B09E3D64ED3" class="sect5">WAITINTERVAL</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQWI_UNLIMITED CONSTANT BINARY_INTEGER：= -1; PGM_SUP.MQWI_UNITS CONSTANT BINARY_INTEGER：= 1000;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG254"></a><div class="props_rev_3"><a id="GUID-04335B81-722A-42F3-BB27-F3184B107DED" name="GUID-04335B81-722A-42F3-BB27-F3184B107DED"></a><h4 id="WSMQG-GUID-04335B81-722A-42F3-BB27-F3184B107DED" class="sect4">PGM.MQMD值</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">PGM</code>信息。 <code class="codeph">MQOD</code>值。
                     </p>
                  </div><a id="WSMQG255"></a><div class="props_rev_3"><a id="GUID-0D262F0E-CD07-4EF6-85F8-62D464B07F15" name="GUID-0D262F0E-CD07-4EF6-85F8-62D464B07F15"></a><h5 id="WSMQG-GUID-0D262F0E-CD07-4EF6-85F8-62D464B07F15" class="sect5">CODEDCHARSETID字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQCCSI_DEFAULT CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQCCSI_Q_MGR CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQCCSI_EMBEDDED CONSTANT BINARY_INTEGER：= -1;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG256"></a><div class="props_rev_3"><a id="GUID-1BA6EADD-0A8B-4B8E-A286-5A53DF95DFE5" name="GUID-1BA6EADD-0A8B-4B8E-A286-5A53DF95DFE5"></a><h5 id="WSMQG-GUID-1BA6EADD-0A8B-4B8E-A286-5A53DF95DFE5" class="sect5">编码领域</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQENC_NATIVE CONSTANT RAW（4）：='00000111';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG257"></a><div class="props_rev_3"><a id="GUID-C02D83E1-7C24-4EA9-AFB2-C82842F818D6" name="GUID-C02D83E1-7C24-4EA9-AFB2-C82842F818D6"></a><h5 id="WSMQG-GUID-C02D83E1-7C24-4EA9-AFB2-C82842F818D6" class="sect5">编码字段，二进制整数的值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQENC_INTEGER_UNDEFINED CONSTANT RAW（4）：='00000000'; PGM_SUP.MQENC_INTEGER_NORMAL CONSTANT RAW（4）：='00000001'; PGM_SUP.MQENC_INTEGER_REVERSED CONSTANT RAW（4）：='00000002';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG258"></a><div class="props_rev_3"><a id="GUID-BA24095E-1184-4022-A08D-B3DCDB756012" name="GUID-BA24095E-1184-4022-A08D-B3DCDB756012"></a><h5 id="WSMQG-GUID-BA24095E-1184-4022-A08D-B3DCDB756012" class="sect5">编码字段，浮点数的值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQENC_FLOAT_UNDEFINED CONSTANT RAW（4）：='00000000'; PGM_SUP.MQENC_FLOAT_IEEE_NORMAL CONSTANT RAW（4）：='00000100'; PGM_SUP.MQENC_FLOAT_IEEE_REVERSED CONSTANT RAW（4）：='00000200'; PGM_SUP.MQENC_FLOAT_S390 CONSTANT RAW（4）：='00000300';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG259"></a><div class="props_rev_3"><a id="GUID-872FD416-B562-40BF-86DB-9C24EEC47C50" name="GUID-872FD416-B562-40BF-86DB-9C24EEC47C50"></a><h5 id="WSMQG-GUID-872FD416-B562-40BF-86DB-9C24EEC47C50" class="sect5">编码字段，掩码值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQENC_INTEGER_MASK CONSTANT RAW（4）：='0000000f'; PGM_SUP.MQENC_DECIMAL_MASK CONSTANT RAW（4）：='000000f0'; PGM_SUP.MQENC_FLOAT_MASK CONSTANT RAW（4）：='00000f00'; PGM_SUP.MQENC_RESERVED_MASK CONSTANT RAW（4）：='fffff000';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG260"></a><div class="props_rev_3"><a id="GUID-82DB5336-FD0D-40AD-A007-9ED5247158D7" name="GUID-82DB5336-FD0D-40AD-A007-9ED5247158D7"></a><h5 id="WSMQG-GUID-82DB5336-FD0D-40AD-A007-9ED5247158D7" class="sect5">编码字段，打包的十进制整数的值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQENC_DECIMAL_UNDEFINED CONSTANT RAW（4）：='00000000'; PGM_SUP.MQENC_DECIMAL_NORMAL CONSTANT RAW（4）：='00000010'; PGM_SUP.MQENC_DECIMAL_REVERSED CONSTANT RAW（4）：='00000020';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG261"></a><div class="props_rev_3"><a id="GUID-C1A4897D-DEBD-4A88-9138-998348648323" name="GUID-C1A4897D-DEBD-4A88-9138-998348648323"></a><h5 id="WSMQG-GUID-C1A4897D-DEBD-4A88-9138-998348648323" class="sect5">EXPIRY字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQEI_UNLIMITED CONSTANT BINARY_INTEGER：= -1; PGM_SUP.MQEI_MIN_EXPIRY CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQEI_UNITS CONSTANT BINARY_INTEGER：= 10;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG262"></a><div class="props_rev_3"><a id="GUID-3F4CD856-3FAB-48B6-89E1-684AD43E7444" name="GUID-3F4CD856-3FAB-48B6-89E1-684AD43E7444"></a><h5 id="WSMQG-GUID-3F4CD856-3FAB-48B6-89E1-684AD43E7444" class="sect5">反馈场</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQFB_NONE CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQFB_SYSTEM_FIRST CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQFB_EXPIRATION常数BINARY_INTEGER：= 258; PGM_SUP.MQFB_COA CONSTANT BINARY_INTEGER：= 259; PGM_SUP.MQFB_COD CONSTANT BINARY_INTEGER：= 260; PGM_SUP.MQFB_QUIT CONSTANT BINARY_INTEGER：= 256; PGM_SUP.MQFB_CHANNEL_COMPLETED CONSTANT BINARY_INTEGER：= 262; PGM_SUP.MQFB_CHANNEL_FAIL_RETRY CONSTANT BINARY_INTEGER：= 263; PGM_SUP.MQFB_CHANNEL_FAIL CONSTANT BINARY_INTEGER：= 264; PGM_SUP.MQFB_APPL_CANNOT_BE_STARTED CONSTANT BINARY_INTEGER：= 265; PGM_SUP.MQFB_TM_ERROR CONSTANT BINARY_INTEGER：= 266; PGM_SUP.MQFB_APPL_TYPE_ERROR CONSTANT BINARY_INTEGER：= 267; PGM_SUP.MQFB_STOPPED_BY_MSG_EXIT CONSTANT BINARY_INTEGER：= 268; PGM_SUP.MQFB_XMIT_Q_MSG_ERROR CONSTANT BINARY_INTEGER：= 271; PGM_SUP.MQFB_SYSTEM_LAST CONSTANT BINARY_INTEGER：= 65535; PGM_SUP.MQFB_APPL_FIRST CONSTANT BINARY_INTEGER：= 65536; PGM_SUP.MQFB_APPL_LAST CONSTANT BINARY_INTEGER：= 999999999;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG263"></a><div class="props_rev_3"><a id="GUID-127F18E0-5B33-410D-B4FF-9D44411A1158" name="GUID-127F18E0-5B33-410D-B4FF-9D44411A1158"></a><h5 id="WSMQG-GUID-127F18E0-5B33-410D-B4FF-9D44411A1158" class="sect5">格式字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQFMT_NONE常量char（8）：=''; MQFMT_ADMIN常量char（8）：='MQADMIN'; MQFMT_CHANNEL_COMPLETED常量char（8）：='MQCHCOM'; MQFMT_CICS常量char（8）：='MQCICS'; MQFMT_COMMAND_1 constant char（8）：='MQCMD1'; MQFMT_COMMAND_2 constant char（8）：='MQCMD2'; MQFMT_DEAD_LETTER_HEADER常量char（8）：='MQDEAD'; MQFMT_DIST_HEADER常量char（8）：='MQHDIST'; MQFMT_EVENT常量char（8）：='MQEVENT'; MQFMT_IMS常量char（8）：='MQIMS'; MQFMT_IMS_VAR_STRING常量char（8）：='MQIMSVS'; MQFMT_MD_EXTENTION constant char（8）：='MQHMDE'; MQFMT_PCF常量char（8）：='MQPCF'; MQFMT_REF_MSG_HEADER常量char（8）：='MQHREF'; MQFMT_STRING常量char（8）：='MQSTR'; MQFMT_TRIGGER常量char（8）：='MQTRIG'; MQFMT_WORK_INFO_HEADER常量char（8）：='MQHWIH'; MQFMT_XMIT_Q_HEADER常量char（8）：='MQXMIT';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG264"></a><div class="props_rev_3"><a id="GUID-C7167F31-F7CA-45A0-9F27-F7440A110CEC" name="GUID-C7167F31-F7CA-45A0-9F27-F7440A110CEC"></a><h5 id="WSMQG-GUID-C7167F31-F7CA-45A0-9F27-F7440A110CEC" class="sect5">MSGTYPE字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQMT_SYSTEM_FIRST CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQMT_REQUEST CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQMT_REPLY CONSTANT BINARY_INTEGER：= 2; PGM_SUP.MQMT_DATAGRAM CONSTANT BINARY_INTEGER：= 8; PGM_SUP.MQMT_REPORT CONSTANT BINARY_INTEGER：= 4; PGM_SUP.MQMT_SYSTEM_LAST CONSTANT BINARY_INTEGER：= 65535; PGM_SUP.MQMT_APPL_FIRST CONSTANT BINARY_INTEGER：= 65536; PGM_SUP.MQMT_APPL_LAST CONSTANT BINARY_INTEGER：= 999999999;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG265"></a><div class="props_rev_3"><a id="GUID-D5AC2FE8-EA91-4854-8D4B-BBF284EB4FC3" name="GUID-D5AC2FE8-EA91-4854-8D4B-BBF284EB4FC3"></a><h5 id="WSMQG-GUID-D5AC2FE8-EA91-4854-8D4B-BBF284EB4FC3" class="sect5">持久性领域</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQPER_PERSISTENT CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQPER_NOT_PERSISTENT CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQPER_PERSISTENCE_AS_Q_DEF CONSTANT BINARY_INTEGER：= 2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG266"></a><div class="props_rev_3"><a id="GUID-3AA676EF-8B14-445A-A7E2-BF49EA90B13A" name="GUID-3AA676EF-8B14-445A-A7E2-BF49EA90B13A"></a><h5 id="WSMQG-GUID-3AA676EF-8B14-445A-A7E2-BF49EA90B13A" class="sect5">优先领域</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQPRI_PRIORITY_AS_Q_DEF CONSTANT BINARY_INTEGER：= -1; PGM_SUP.MQPRI_MIN_PRIORITY CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQPRI_MAX_PRIORITY CONSTANT BINARY_INTEGER：= 9;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG267"></a><div class="props_rev_3"><a id="GUID-203D5578-7EF6-4D0F-BABB-5A60D13654CA" name="GUID-203D5578-7EF6-4D0F-BABB-5A60D13654CA"></a><h5 id="WSMQG-GUID-203D5578-7EF6-4D0F-BABB-5A60D13654CA" class="sect5">PUTAPPLTYPE字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQAT_UNKNOWN常量binary_integer：= -1; MQAT_NO_CONTEXT常量binary_integer：= 0; MQAT_CICS常量binary_integer：= 1; MQAT_MVS常量binary_integer：= 2; MQAT_OS390常量binary_integer：= 2; MQAT_IMS常量binary_integer：= 3; MQAT_OS2常量binary_integer：= 4; MQAT_DOS常量binary_integer：= 5; MQAT_AIX常量binary_integer：= 6; MQAT_UNIX常量binary_integer：= 6; MQAT_QMGR常量binary_integer：= 7; MQAT_OS400常量binary_integer：= 8; MQAT_WINDOWS常量binary_integer：= 9; MQAT_CICS_VSE常量binary_integer：= 10; MQAT_WINDOWS_NT常量binary_integer：= 11; MQAT_VMS常量binary_integer：= 12; MQAT_GUARDIAN常量binary_integer：= 13; MQAT_NSK常量binary_integer：= 13; MQAT_VOS常量binary_integer：= 14; MQAT_IMS_BRIDGE常量binary_integer：= 19; MQAT_XCF常量binary_integer：= 20; MQAT_CICS_BRIDGE常量binary_integer：= 21; MQAT_NOTES_AGENT常量binary_integer：= 22; MQAT_USER_FIRST常量binary_integer：= 65536; MQAT_USER_LAST常量binary_integer：= 999999999; MQAT_DEFAULT常量binary_integer：= 6;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG268"></a><div class="props_rev_3"><a id="GUID-D50D79CD-0336-4E6C-981D-8A16D662C691" name="GUID-D50D79CD-0336-4E6C-981D-8A16D662C691"></a><h5 id="WSMQG-GUID-D50D79CD-0336-4E6C-981D-8A16D662C691" class="sect5">报告字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQRO_NEW_MSG_ID constant raw（4）：='00000000'; MQRO_COPY_MSG_ID_TO_CORREL_ID constant raw（4）：='00000000'; MQRO_DEAD_LETTER_Q constant raw（4）：='00000000'; MQRO_NONE constant raw（4）：='00000000'; MQRO_PAN constant raw（4）：='00000001'; MQRO_NAN constant raw（4）：='00000002'; MQRO_PASS_CORREL_ID constant raw（4）：='00000040'; MQRO_PASS_MSG_ID constant raw（4）：='00000080'; MQRO_COA常量raw（4）：='00000100'; MQRO_COA_WITH_DATA constant raw（4）：='00000300'; MQRO_COA_WITH_FULL_DATA constant raw（4）：='00000700'; MQRO_COD constant raw（4）：='00000800'; MQRO_COD_WITH_DATA constant raw（4）：='00001800'; MQRO_COD_WITH_FULL_DATA constant raw（4）：='00003800'; MQRO_EXPIRATION constant raw（4）：='00200000'; MQRO_EXPIRATION_WITH_DATA constant raw（4）：='00600000'; MQRO_EXPIRATION_WITH_FULL_DATA constant raw（4）：='00E00000'; MQRO_EXCEPTION constant raw（4）：='01000000'; MQRO_EXCEPTION_WITH_DATA constant raw（4）：='03000000'; MQRO_EXCEPTION_WITH_FULL_DATA constant raw（4）：='07000000'; MQRO_DISCARD_MSG constant raw（4）：='08000000';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG269"></a><div class="props_rev_3"><a id="GUID-9EA4A714-B6C8-485B-8C23-5C2D20AA7723" name="GUID-9EA4A714-B6C8-485B-8C23-5C2D20AA7723"></a><h5 id="WSMQG-GUID-9EA4A714-B6C8-485B-8C23-5C2D20AA7723" class="sect5">版本字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQMD_VERSION_1常量binary_integer：= 1; MQMD_VERSION_2常量binary_integer：= 2; MQMD_CURRENT_VERSION常量binary_integer：= 2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG270"></a><div class="props_rev_3"><a id="GUID-DAB2A9E7-60BA-4502-8040-85FC410BE504" name="GUID-DAB2A9E7-60BA-4502-8040-85FC410BE504"></a><h5 id="WSMQG-GUID-DAB2A9E7-60BA-4502-8040-85FC410BE504" class="sect5">报告字段，掩码值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQRO_REJECT_UNSUP_MASK CONSTANT RAW（4）：='101c0000'; PGM_SUP.MQRO_ACCEPT_UNSUP_MASK CONSTANT RAW（4）：='efe000ff'; PGM_SUP.MQRO_ACCEPT_UNSUP_IF_XMIT_MASK CONSTANT RAW（4）：='0003ff00';</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG271"></a><div class="props_rev_3"><a id="GUID-7116F529-B056-460C-A05A-7926FEC1C11B" name="GUID-7116F529-B056-460C-A05A-7926FEC1C11B"></a><h4 id="WSMQG-GUID-7116F529-B056-460C-A05A-7926FEC1C11B" class="sect4">PGM.MQOD值</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">PGM</code>信息。 <code class="codeph">MQOD</code>值。
                     </p>
                  </div><a id="WSMQG272"></a><div class="props_rev_3"><a id="GUID-02833624-3AF6-451A-A77E-BADD6A04A85D" name="GUID-02833624-3AF6-451A-A77E-BADD6A04A85D"></a><h5 id="WSMQG-GUID-02833624-3AF6-451A-A77E-BADD6A04A85D" class="sect5">OBJECTTYPE字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQOT_Q CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQOT_PROCESS CONSTANT BINARY_INTEGER：= 3; PGM_SUP.MQOT_Q_MGR常数BINARY_INTEGER：= 5; PGM_SUP.MQOT_CHANNEL CONSTANT BINARY_INTEGER：= 6;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG273"></a><div class="props_rev_3"><a id="GUID-BC475C3A-188B-43DC-AC85-EB61EB6814CB" name="GUID-BC475C3A-188B-43DC-AC85-EB61EB6814CB"></a><h5 id="WSMQG-GUID-BC475C3A-188B-43DC-AC85-EB61EB6814CB" class="sect5">OBJECTTYPE字段，扩展值</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQOT_ALL常量binary_integer：= 1001; MQOT_ALIAS_Q常量binary_integer：= 1002; MQOT_MODEL_Q常量binary_integer：= 1003; MQOT_LOCAL_Q常量binary_integer：= 1004; MQOT_REMOTE_Q常量binary_integer：= 1005; MQOT_SENDER_CHANNEL常量binary_integer：= 1007; MQOT_SERVER_CHANNEL常量binary_integer：= 1008; MQOT_REQUESTER_CHANNEL常量binary_integer：= 1009; MQOT_RECEIVER_CHANNEL常量binary_integer：= 1010; MQOT_CURRENT_CHANNEL常量binary_integer：= 1011; MQOT_SAVED_CHANNEL常量binary_integer：= 1012; MQOT_SVRCONN_CHANNEL常量binary_integer：= 1013; MQOT_CLNTCONN_CHANNEL常量binary_integer：= 1014;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG274"></a><div class="props_rev_3"><a id="GUID-DB896A37-F332-428E-8543-DFA03E8731EF" name="GUID-DB896A37-F332-428E-8543-DFA03E8731EF"></a><h5 id="WSMQG-GUID-DB896A37-F332-428E-8543-DFA03E8731EF" class="sect5">版本字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQOD_VERSION_1常量binary_integer：= 1; MQOD_VERSION_2常量binary_integer：= 2; MQOD_CURRENT_VERSION常量binary_integer：= 2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG275"></a><div class="props_rev_3"><a id="GUID-8DFFD523-FF15-4D73-A5F5-1ADED6AA3807" name="GUID-8DFFD523-FF15-4D73-A5F5-1ADED6AA3807"></a><h4 id="WSMQG-GUID-8DFFD523-FF15-4D73-A5F5-1ADED6AA3807" class="sect4">PGM.MQPMO价值观</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">PGM</code>信息。 <code class="codeph">MQPMO</code>值。
                     </p>
                  </div><a id="WSMQG276"></a><div class="props_rev_3"><a id="GUID-4AD9BE88-45B5-4C07-A23B-370000A75608" name="GUID-4AD9BE88-45B5-4C07-A23B-370000A75608"></a><h5 id="WSMQG-GUID-4AD9BE88-45B5-4C07-A23B-370000A75608" class="sect5">选项字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQPMO_NONE常量binary_integer：= 0; MQPMO_SYNCPOINT常量binary_integer：= 2; MQPMO_NO_SYNCPOINT常量binary_integer：= 4; MQPMO_DEFAULT_CONTEXT常量binary_integer：= 32; MQPMO_NEW_MSG_ID常量binary_integer：= 64; MQPMO_NEW_CORREL_ID常量binary_integer：= 128; MQPMO_PASS_IDENTITY_CONTEXT常量binary_integer：= 256; MQPMO_PASS_ALL_CONTEXT常量binary_integer：= 512; MQPMO_SET_IDENTITY_CONTEXT常量binary_integer：= 1024; MQPMO_SET_ALL_CONTEXT常量binary_integer：= 2048; MQPMO_ALTERNATE_USER_AUTHORITY常量binary_integer：= 4096; MQPMO_FAIL_IF_QUIESCING常量binary_integer：= 8192; MQPMO_NO_CONTEXT常量binary_integer：= 16384; MQPMO_LOGICAL_ORDER常量binary_integer：= 32768;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG277"></a><div class="props_rev_3"><a id="GUID-1CE8B3AC-2155-4C5F-A072-89FCAEB0EF06" name="GUID-1CE8B3AC-2155-4C5F-A072-89FCAEB0EF06"></a><h5 id="WSMQG-GUID-1CE8B3AC-2155-4C5F-A072-89FCAEB0EF06" class="sect5">版本字段</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQPMO_VERSION_1常量binary_integer：= 1; MQPMO_VERSION_2常量binary_integer：= 2; MQPMO_CURRENT_VERSION常量binary_integer：= 2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG278"></a><div class="props_rev_3"><a id="GUID-04E0A049-C68A-40C2-80C6-7CB1ACC79EA3" name="GUID-04E0A049-C68A-40C2-80C6-7CB1ACC79EA3"></a><h4 id="WSMQG-GUID-04E0A049-C68A-40C2-80C6-7CB1ACC79EA3" class="sect4">MQCLOSE值</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">MQCLOSE</code>值的信息。
                     </p>
                  </div><a id="WSMQG279"></a><div class="props_rev_3"><a id="GUID-543C43AB-8A38-449E-B3F4-2746A9B0F000" name="GUID-543C43AB-8A38-449E-B3F4-2746A9B0F000"></a><h5 id="WSMQG-GUID-543C43AB-8A38-449E-B3F4-2746A9B0F000" class="sect5"><span class="italic">hobj</span>论据</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQHO_UNUSABLE_HOBJ CONSTANT BINARY_INTEGER：= -1;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="WSMQG280"></a><div class="props_rev_3"><a id="GUID-641C1D1D-DD16-4BDA-8852-CE24B627FF08" name="GUID-641C1D1D-DD16-4BDA-8852-CE24B627FF08"></a><h5 id="WSMQG-GUID-641C1D1D-DD16-4BDA-8852-CE24B627FF08" class="sect5"><span class="italic">选项</span>参数</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">PGM_SUP.MQCO_NONE CONSTANT BINARY_INTEGER：= 0; PGM_SUP.MQCO_DELETE CONSTANT BINARY_INTEGER：= 1; PGM_SUP.MQCO_DELETE_PURGE CONSTANT BINARY_INTEGER：= 2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG281"></a><div class="props_rev_3"><a id="GUID-E0BCFA54-8510-495B-9B44-F5EFDB3E31AA" name="GUID-E0BCFA54-8510-495B-9B44-F5EFDB3E31AA"></a><h4 id="WSMQG-GUID-E0BCFA54-8510-495B-9B44-F5EFDB3E31AA" class="sect4">MQOPEN值</h4>
                  <div>
                     <p>这些主题提供有关<code class="codeph">MQOPEN</code>值的信息。
                     </p>
                  </div><a id="WSMQG282"></a><div class="props_rev_3"><a id="GUID-3D61B5E7-6431-4FDB-8578-B64677AD7964" name="GUID-3D61B5E7-6431-4FDB-8578-B64677AD7964"></a><h5 id="WSMQG-GUID-3D61B5E7-6431-4FDB-8578-B64677AD7964" class="sect5"><span class="italic">选项</span>参数</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">MQOO_BIND_AS_Q_DEF常量binary_integer：= 0; MQOO_INPUT_AS_Q_DEF常量binary_integer：= 1; MQOO_INPUT_SHARED常量binary_integer：= 2; MQOO_INPUT_EXCLUSIVE常量binary_integer：= 4; MQOO_BROWSE常量binary_integer：= 8; MQOO_OUTPUT常量binary_integer：= 16; MQOO_INQUIRE常量binary_integer：= 32; MQOO_SET常量binary_integer：= 64; MQOO_SAVE_ALL_CONTEXT常量binary_integer：= 128; MQOO_PASS_IDENTITY_CONTEXT常量binary_integer：= 256; MQOO_PASS_ALL_CONTEXT常量binary_integer：= 512; MQOO_SET_IDENTITY_CONTEXT常量binary_integer：= 1024; MQOO_SET_ALL_CONTEXT常量binary_integer：= 2048; MQOO_ALTERNATE_USER_AUTHORITY常量binary_integer：= 4096; MQOO_FAIL_IF_QUIESCING常量binary_integer：= 8192; MQOO_BIND_ON_OPEN常量binary_integer：= 16384; MQOO_BIND_NOT_FIXED常量binary_integer：= 32768; MQOO_RESOLVE_NAMES常量binary_integer：= 65536;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="WSMQG283"></a><div class="props_rev_3"><a id="GUID-EAD69F69-04DE-4102-A38F-2803F2249B73" name="GUID-EAD69F69-04DE-4102-A38F-2803F2249B73"></a><h4 id="WSMQG-GUID-EAD69F69-04DE-4102-A38F-2803F2249B73" class="sect4">PGM类型定义字段的最大长度</h4>
                  <div>
                     <p>这些常量包含PGM类型定义使用的字段允许的最大长度。</p>
                     <div class="section">
                        <p>例如，常量<code class="codeph">PGM_SUP</code> 。 <code class="codeph">MQ_ACCOUNTING_TOKEN_LENGTH</code>指定<code class="codeph">PGM</code>的最大长度。 <code class="codeph">MQMD</code> 。 <code class="codeph">ACCOUNTINGTOKEN</code>是32个字符。
                        </p><pre class="oac_no_warn" dir="ltr">MQ_ABEND_CODE_LENGTH常量binary_integer：= 4; MQ_ACCOUNTING_TOKEN_LENGTH常量binary_integer：= 32; MQ_APPL_IDENTITY_DATA_LENGTH常量binary_integer：= 32; MQ_APPL_ORIGIN_DATA_LENGTH常量binary_integer：= 4; MQ_ATTENTION_ID_LENGTH常量binary_integer：= 4; MQ_AUTHENTICATOR_LENGTH常量binary_integer：= 8; MQ_CANCEL_CODE_LENGTH常量binary_integer：= 4; MQ_CLUSTER_NAME_LENGTH常量binary_integer：= 48; MQ_CORREL_ID_LENGTH常量binary_integer：= 24; MQ_CREATION_DATE_LENGTH常量binary_integer：= 12; MQ_CREATION_TIME_LENGTH常量binary_integer：= 8; MQ_DATE_LENGTH常量binary_integer：= 12; MQ_EXIT_NAME_LENGTH常量binary_integer：= 128; MQ_FACILITY_LENGTH常量binary_integer：= 8; MQ_FACILITY_LIKE_LENGTH常量binary_integer：= 4; MQ_FORMAT_LENGTH常量binary_integer：= 8; MQ_FUNCTION_LENGTH常量binary_integer：= 4; MQ_GROUP_ID_LENGTH常量binary_integer：= 24; MQ_LTERM_OVERRIDE_LENGTH常量binary_integer：= 8; MQ_MFS_MAP_NAME_LENGTH常量binary_integer：= 8; MQ_MSG_HEADER_LENGTH常量binary_integer：= 4000; MQ_MSG_ID_LENGTH常量binary_integer：= 24; MQ_MSG_TOKEN_LENGTH常量binary_integer：= 16; MQ_NAMELIST_DESC_LENGTH常量binary_integer：= 64; MQ_NAMELIST_NAME_LENGTH常量binary_integer：= 48; MQ_OBJECT_INSTANCE_ID_LENGTH常量binary_integer：= 24; MQ_NAME_LENGTH常量binary_integer：= 48; MQ_PROCESS_APPL_ID_LENGTH常量binary_integer：= 256; MQ_PROCESS_DESC_LENGTH常量binary_integer：= 64; MQ_PROCESS_ENV_DATA_LENGTH常量binary_integer：= 128; MQ_PROCESS_NAME_LENGTH常量binary_integer：= 48; MQ_PROCESS_USER_DATA_LENGTH常量binary_integer：= 128; MQ_PUT_APPL_NAME_LENGTH常量binary_integer：= 28; MQ_PUT_DATE_LENGTH常量binary_integer：= 8; MQ_PUT_TIME_LENGTH常量binary_integer：= 8; MQ_Q_DESC_LENGTH常量binary_integer：= 64; MQ_Q_MGR_DESC_LENGTH常量binary_integer：= 64; MQ_Q_MGR_IDENTIFIER_LENGTH常量binary_integer：= 48; MQ_Q_MGR_NAME_LENGTH常量binary_integer：= 48; MQ_Q_NAME_LENGTH常量binary_integer：= 48; MQ_REMOTE_SYS_ID_LENGTH常量binary_integer：= 4; MQ_SERVICE_NAME_LENGTH常量binary_integer：= 32; MQ_SERVICE_STEP_LENGTH常量binary_integer：= 8; MQ_START_CODE_LENGTH常量binary_integer：= 4; MQ_STORAGE_CLASS_LENGTH常量binary_integer：= 8; MQ_TIME_LENGTH常量binary_integer：= 8; MQ_TRAN_INSTANCE_ID_LENGTH常量binary_integer：= 16; MQ_TRANSACTION_ID_LENGTH常量binary_integer：= 4; MQ_TP_NAME_LENGTH常量binary_integer：= 64; MQ_TRIGGER_DATA_LENGTH常量binary_integer：= 64; MQ_USER_ID_LENGTH常量binary_integer：= 12;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="WSMQG357"></a><a id="WSMQG358"></a><a id="WSMQG284"></a><div class="props_rev_3"><a id="GUID-F011266B-A2EB-43AF-83AD-EE4B547BCB86" name="GUID-F011266B-A2EB-43AF-83AD-EE4B547BCB86"></a><h4 id="WSMQG-GUID-F011266B-A2EB-43AF-83AD-EE4B547BCB86" class="sect4">错误代码定义</h4>
                  <div>
                     <p>本主题描述了一些错误代码定义。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-F011266B-A2EB-43AF-83AD-EE4B547BCB86__GUID-FCB973A8-98DC-483E-82C7-C1592FD700B4">错误代码-29400：数据盒错误</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此错误代码表示在DG4MQ中实现的MQI操作码失败。有关原因的信息，请参阅IBM WebSphere参考手册，方法是查找操作码及其完成代码和原因码。</p><pre class="oac_no_warn" dir="ltr">MQI操作码失败。完成代码= xxxx。原因代码= xxxx。</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F011266B-A2EB-43AF-83AD-EE4B547BCB86__GUID-380CBF53-5FAE-429E-853A-1452D476E4B8">
                        <p class="titleinexample">例A-3 test.sql</p><pre class="oac_no_warn" dir="ltr">-   - 版权所有Oracle，2005保留所有权利。-   -  NAME  -  test.sql  -   -  DESCRIPTION  - 指定为网关创建的数据库链接名称。为此， - 使用dblink名称替换数据库链接名称“YOUR_DBLINK_NAME” - 您在创建数据库链接时选择了该名称。-   - 此脚本为MQSeries网关执行测试运行。在此脚本中，queuename为'YOUR_QUEUE_NAME'，将queuename替换为 - 网关配置的队列管理器中的有效队列名称 -  for。-   - 首先，脚本在指定的队列上放置10个字节的原始消息。-   - 成功完成put操作后，脚本执行a  - 获取相同的队列以读回消息。-   - 从队列中放入和检索的两个消息的内容 - 打印到标准输出以供用户验证。-   - 注意 - 从SQL * Plus命令行运行脚本。- 确保用户在包dbms_output上被授予'EXECUTE' - 在declare objdesc上设置serveroutput PGM.MQOD; hobj PGM.MQOH; msgdesc PGM.MQMD; putmsgopts PGM.MQPMO; getmsgopts PGM.MQGMO; options binary_integer; putbuffer raw（10）：='10203040506070809000'; getbuffer raw（10）; begin  -   - 打印我们放在队列中的消息 -  dbms_output.put_line（'message put on queue ='|| rawtohex（putbuffer））; -   - 指定队列名称和dblink名称（替换为专有名称）。-  objdesc.objectname：='YOUR_QUEUE_NAME'; objdesc.dblinkname：='YOUR_DBLINK_NAME'; -   - 指定放置操作。- 选项：= pgm_sup。MQOO_OUTPUT; -   - 打开队列。-  PGM.MQOPEN（objdesc，options，hobj）; -   - 将消息缓冲区放在队列中。-  PGM.MQPUT（hobj，msgdesc，putmsgopts，putbuffer）; -   - 定义关闭选项。- 选项：= pgm_sup。MQCO_NONE; -   - 关闭队列。-  PGM.MQCLOSE（hobj，期权）; -   - 指定get操作。- 选项：= pgm_sup。MQOO_INPUT_AS_Q_DEF; -   - 打开队列。-  PGM.MQOPEN（objdesc，options，hobj）; -   - 从队列中获取消息。-  getmsgopts.msglength：= 10; PGM.MQGET（hobj，msgdesc，getmsgopts，getbuffer）; -   - 定义关闭选项。- 选项：= pgm_sup。MQCO_NONE; -   - 再次关闭队列。-  PGM.MQCLOSE（hobj，期权）; -   - 打印结果 -  dbms_output.put_line（'message read back ='|| rawtohex（getbuffer））; exception  -   - 当没有更多消息时...告诉用户并关闭队列。- 当pgm_sup。NO_MORE_MESSAGES然后是dbms_output.put_line（'警告：在队列中找不到消息'）; options：= pgm_sup。MQCO_NONE; PGM.MQCLOSE（hobj，期权）; -   - 出了别的问题..告诉用户。- 当其他人然后dbms_output.put_line（'错误：IBM MQSeries验证脚本的过程网关失败。“）; DBMS_OUTPUT.PUT_LINE（SQLERRM）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="00633.XML-Schema-and-query-basic.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="XML Schema is a standard for describing the content and structure of XML documents. You can register, update, and delete an XML schema used with Oracle XML DB. You can define storage structures to use for your XML schema-based data and map XML Schema data types to SQL data types."></meta>
      <meta name="description" content="XML Schema is a standard for describing the content and structure of XML documents. You can register, update, and delete an XML schema used with Oracle XML DB. You can define storage structures to use for your XML schema-based data and map XML Schema data types to SQL data types."></meta>
      <title>XML模式存储和查询：基本</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="XML Schema is a standard for describing the content and structure of XML documents. You can register, update, and delete an XML schema used with Oracle XML DB. You can define storage structures to use for your XML schema-based data and map XML Schema data types to SQL data types."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="choice-of-XMLType-storage-and-indexing.html" title="Previous" type="text/html"></link>
      <link rel="next" href="XML-Schema-and-query-object-relational-storage.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="choice-of-XMLType-storage-and-indexing.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="XML-Schema-and-query-object-relational-storage.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-Schema-and-object-relational-XMLType.html" property="item" typeof="WebPage"><span property="name">XML Schema和Object-Relational XMLType</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XML模式存储和查询：基本</li>
            </ol>
            <a id="GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" name="GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1"></a><a id="ADXDB0600"></a>
            
            <h2 id="ADXDB-GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" class="sect2"><span class="enumeration_chapter">17</span> XML Schema存储和查询：基本</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='XML-Schema-and-query-basic'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。</p>
               <p>该<a id="d81865e22" class="indexterm-anchor"></a> XML Schema Recommendation由万维网联盟（W3C）创建，用于描述XML文档的内容和结构。它包括的全部功能<a id="d81865e27" class="indexterm-anchor"></a>文档类型定义（DTD），以便可以将现有DTD转换为XML架构。与DTD相比，XML模式具有其他功能。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B">XML Schema概述</a><br>W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-CD1BA605-196D-461C-9707-6A0B870F1172">使用XML架构与Oracle XML DB的概述</a><br>Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF">使用Oracle XML DB进行XML模式注册</a><br>在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建<code class="codeph">XMLType</code>表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5">基于XML模式创建XMLType表和列</a><br>您可以创建受XML架构定义的全局元素约束的<code class="codeph">XMLType</code>表和列。在<code class="codeph">XMLType</code>列被约束到特定元素和特定模式之后，它只能包含符合该元素的模式定义的文档。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6">识别XML模式实例文档的方法</a><br>在将XML文档插入基于XML模式的<code class="codeph">XMLType</code>表或列之前，必须标识关联的XML模式。您可以在创建表或列时执行此操作，也可以使用<code class="codeph">XMLSchema-instance</code>将所需的模式标识显式添加到XML实例文档中。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4">XML模式数据类型映射到Oracle XML DB存储</a><br>符合XML模式的数据使用XML模式数据类型。当此XML数据存储在Oracle XML DB中时，其存储数据类型使用默认映射从XML架构数据类型派生，并且可选地使用您使用XML架构批注指定的映射信息。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1__GUID-977C4EA2-6C98-4748-AE8E-D345ADF363AB">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储，</a>以获取有关将XML模式与Oracle XML DB一起使用的更多高级信息</p>
                     </li>
                     <li>
                        <p>有关在Oracle XML DB中优化XPath表达式的信息，请参阅<a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                     </li>
                     <li>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">XML Schema第0部分：</a>引用XML Schema的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">Primer Second Edition</a></p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="涵盖了XML Schema的使用和XMLType数据的对象关系存储。">XML模式和对象关系XMLType</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB6296"></a><div class="props_rev_3"><a id="GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" name="GUID-DF33451A-6F65-4BBC-8834-80FBD687100B"></a><h3 id="ADXDB-GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" class="sect3"><span class="enumeration_section">17.1</span> XML Schema概述</h3>
               <div>
                  <p>W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。</p>
                  <p>本文档将XML Schema实例定义称为<strong class="term">XML模式</strong> （小写）。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-89C13D9D-C554-4080-B683-756FE129C790">架构的XML架构</a><br>W3C Schema工作组发布了一个XML模式，通常称为“Schema for Schemas”。此XML架构提供XML架构语言的定义或词汇表。可以将所有有效的XML模式视为此XML模式定义的类的成员。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-8EF2B93D-D9EF-4AEC-88EF-A14AC88F06DB">XML架构功能</a><br>XML Schema定义了47种标量数据类型，用于强类型元素和属性。它支持面向对象的继承和扩展，因此您可以使用基础数据类型设计具有复杂对象的XML模式。它包括用于定义和排序的构造，默认值，强制内容，嵌套，重复集和重新定义。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-4FB64E7A-AE63-48B9-8FC1-BFEE055E7D6C">XML实例文档</a><br>符合XML模式的文档可以视为该XML模式定义的类的实例。XML模式的一个常见用途是验证给定的此类<strong class="term">实例文档是否</strong>符合XML模式定义的规则。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-FB7F9AFB-117B-40F4-B74B-77EED9ED9511">XML命名空间和XML模式</a><br>XML模式可以指定<code class="codeph">targetNamespace</code>属性，其值为URL。如果省略，则架构没有目标命名空间。目标命名空间是XML模式中定义的所有内容的命名空间。<code class="codeph">targetNamespace</code>值通常是可以访问XML模式的URL。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4">编辑XML模式概述</a><br>您可以随意创作和编辑XML模式。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-DF33451A-6F65-4BBC-8834-80FBD687100B__GUID-9F7ECC10-F973-4A33-B611-12E817E8DDB9">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">XML Schema第0部分：</a>用于XML Schema建议的一般描述的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">入门</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6297"></a><div class="props_rev_3"><a id="GUID-89C13D9D-C554-4080-B683-756FE129C790" name="GUID-89C13D9D-C554-4080-B683-756FE129C790"></a><h4 id="ADXDB-GUID-89C13D9D-C554-4080-B683-756FE129C790" class="sect4"><span class="enumeration_section">17.1.1</span>模式的XML模式</h4>
                  <div>
                     <p>W3C Schema工作组发布了一个XML模式，通常称为“Schema for Schemas”。此XML架构提供XML架构语言的定义或词汇表。可以将所有有效的XML模式视为此XML模式定义的类的成员。</p>
                     <p>因此，XML模式是一种XML文档，它符合由<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_2001_xmlschema" target="_blank"><code class="codeph">https://www.w3.org/2001/XMLSchema</code></a>发布的XML模式定义的类。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" title="W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。">XML模式概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6298"></a><div class="props_rev_3"><a id="GUID-8EF2B93D-D9EF-4AEC-88EF-A14AC88F06DB" name="GUID-8EF2B93D-D9EF-4AEC-88EF-A14AC88F06DB"></a><h4 id="ADXDB-GUID-8EF2B93D-D9EF-4AEC-88EF-A14AC88F06DB" class="sect4"><span class="enumeration_section">17.1.2</span> XML模式功能</h4>
                  <div>
                     <p>XML Schema定义了47种标量数据类型，用于强类型元素和属性。它支持面向对象的继承和扩展，因此您可以使用基础数据类型设计具有复杂对象的XML模式。它包括用于定义和排序的构造，默认值，强制内容，嵌套，重复集和重新定义。</p>
                     <p>Oracle XML DB支持XML Schema定义的所有构造，但重新定义除外。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" title="W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。">XML模式概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6299"></a><div class="props_rev_3"><a id="GUID-4FB64E7A-AE63-48B9-8FC1-BFEE055E7D6C" name="GUID-4FB64E7A-AE63-48B9-8FC1-BFEE055E7D6C"></a><h4 id="ADXDB-GUID-4FB64E7A-AE63-48B9-8FC1-BFEE055E7D6C" class="sect4"><span class="enumeration_section">17.1.3</span> XML实例文档</h4>
                  <div>
                     <p>符合XML模式的文档可以视为该XML模式定义的类的实例。XML模式的一个常见用途是验证给定的此类<strong class="term">实例文档是否</strong>符合XML模式定义的规则。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" title="W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。">XML模式概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6300"></a><div class="props_rev_3"><a id="GUID-FB7F9AFB-117B-40F4-B74B-77EED9ED9511" name="GUID-FB7F9AFB-117B-40F4-B74B-77EED9ED9511"></a><h4 id="ADXDB-GUID-FB7F9AFB-117B-40F4-B74B-77EED9ED9511" class="sect4"><span class="enumeration_section">17.1.4</span> XML命名空间和XML模式</h4>
                  <div>
                     <p>XML模式可以指定<code class="codeph">targetNamespace</code>属性，其值为URL。如果省略，则架构没有目标命名空间。目标命名空间是XML模式中定义的所有内容的命名空间。<code class="codeph">targetNamespace</code>值通常是可以访问XML模式的URL。
                     </p>
                     <p>XML实例文档必须指定命名空间<a id="d81865e399" class="indexterm-anchor"></a>文档的根元素（与实例符合的XML模式的目标名称空间相同）和定义此根元素的XML模式的位置（URL）。此信息由属性<code class="codeph">xsi:schemaLocation</code>指定。当XML模式没有目标名称空间时，请使用属性<code class="codeph">xsi:noNamespaceSchemaLocation</code>指定模式URL。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" title="W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。">XML模式概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6302"></a><a id="ADXDB6301"></a><div class="props_rev_3"><a id="GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4" name="GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4"></a><h4 id="ADXDB-GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4" class="sect4"><span class="enumeration_section">17.1.5</span>编辑XML模式概述</h4>
                  <div>
                     <p>您可以随意创作和编辑XML模式。</p>
                     <p>例如，您可以使用以下任何一项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一个简单的文本编辑器，例如Emacs或vi</p>
                        </li>
                        <li>
                           <p>一个支持XML Schema的编辑器，例如Oracle JDeveloper附带的XML编辑器</p>
                        </li>
                        <li>
                           <p>一种显式的XML Schema创作工具，例如Altova Corporation的XMLSpy</p>
                        </li>
                     </ul>
                     <p><a href="XML-Schema-and-query-basic.html#GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4__CEGDDAHG">图17-1</a>显示了使用XMLSpy编辑的采购订单XML模式。XMLSpy是Altova Corporation的图形化XML工具，可用于创建和编辑XML模式和其他XML文档。有关详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=altova_com" target="_blank">Altova.com</a> 。<a id="fn_1" name="fn_1" href="#fn_1" xmlspy="" also="" supports="" webdav="" and="" ftp="" protocols,="" so="" you="" can="" use="" it="" to="" directly="" access="" edit="" content="" stored="" in="" oracle="" xml&nbsp;db="" repository=")" ="" onclick="footdisplay(1, "><sup>脚1</sup></a> 
                     </p>
                     <div class="figure" id="GUID-23D89612-2661-48FE-9DBD-41C37EB3BBE4__CEGDDAHG">
                        <p class="titleinfigure">图17-1采购订单XML架构的XMLSpy图形表示</p><img src="img/po_spy.gif" width="585" alt="下面是图17-1的描述" title="下面是图17-1的描述" longdesc="img_text/po_spy.html"><br><a href="img_text/po_spy.html">“图17-1采购订单XML架构的XMLSpy图形表示”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-DF33451A-6F65-4BBC-8834-80FBD687100B" title="W3C XML Schema Recommendation定义了一种标准化语言，用于指定一组XML文档的结构，内容和某些语义。可以将XML模式视为描述一类XML文档的元数据。">XML模式概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6303"></a><div class="props_rev_3"><a id="GUID-CD1BA605-196D-461C-9707-6A0B870F1172" name="GUID-CD1BA605-196D-461C-9707-6A0B870F1172"></a><h3 id="ADXDB-GUID-CD1BA605-196D-461C-9707-6A0B870F1172" class="sect3"><span class="enumeration_section">17.2</span>在Oracle XML DB中使用XML模式的概述</h3>
               <div>
                  <p>Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。</p>
                  <p>XML模式作为<code class="codeph">XMLType</code>实例存储在Oracle XML DB中，就像引用它们的XML文档一样。您必须向Oracle XML DB <span class="italic">注册</span> XML模式，以便将其与存储在数据库中的XML数据一起使用。
                  </p>
                  <p>Oracle XML DB利用XML Schema的强类型和其他功能来安全有效地处理XML数据库数据。</p>
                  <p>要在Oracle XML DB中注册，XML模式必须符合<strong class="term">根XML模式</strong> <strong class="term">XDBSchema.xsd</strong> 。这是Oracle XML DB XML模式的XML模式。您可以在Oracle XML DB存储库位置访问<code class="codeph">XDBSchema.xsd</code> <code class="codeph">/sys/schemas/PUBLIC/xmlns.oracle.com/xdb/XDBSchema.xsd</code> 。
                  </p>
                  <p>Oracle XML DB使用带<span class="italic">注释的</span> XML模式作为元数据。使用标准XML模式定义以及几个Oracle名称空间属性。这些属性确定XML实例文档如何映射到数据库。由于这些属性与XML Schema名称空间位于不同的名称空间中，因此这种带注释的XML模式遵循XML Schema标准。
                  </p>
                  <p>Oracle XML DB为以下任务提供XML Schema支持：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>注册符合W3C的XML模式，包括本地和全局。</p>
                     </li>
                     <li>
                        <p>根据已注册的XML模式定义验证XML文档。</p>
                     </li>
                     <li>
                        <p>从SQL对象类型生成XML模式。</p>
                     </li>
                     <li>
                        <p>引用其他用户拥有的XML架构。</p>
                     </li>
                     <li>
                        <p>当存在具有相同名称的本地XML架构时引用全局XML架构。</p>
                     </li>
                     <li>
                        <p>在XML模式注册期间从XML模式生成数据库映射。这包括生成SQL对象类型，集合类型和默认表，以及使用XML架构属性捕获映射信息。</p>
                     </li>
                     <li>
                        <p>在有多个允许的映射时指定特定的SQL数据类型映射。</p>
                     </li>
                     <li>
                        <p>基于已注册的XML模式创建<code class="codeph">XMLType</code>表，视图和列。
                        </p>
                     </li>
                     <li>
                        <p>操作和查询基于XML模式的<code class="codeph">XMLType</code>表。
                        </p>
                     </li>
                     <li>
                        <p>使用协议（FTP，HTTP（S）/ WebDAV）和SQL以外的语言将基于XML模式的文档插入Oracle XML DB存储库时，自动将数据插入默认表。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-A708BD08-16C2-4E67-BF64-F8213A4FBAB9">为什么在Oracle XML DB中使用XML Schema？</a><br>使用XML Schema的常见原因包括验证，约束定义，存储规范以及文档插入，存储和访问的优化。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8">注释XML模式以控制命名，映射和存储的概述</a><br>W3C XML Schema Recommendation允许将特定于供应商的注释添加到XML模式中。Oracle XML DB使用注释来控制XML模式和各种数据库功能之间的映射。您可以使用注释指定哪些表存储XML数据。注释对于对象关系存储尤其有用。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6">DOM富达</a><br>DOM保真度意味着保留XML文档中的所有信息，除了无关紧要的空白。您可以使用DOM保真度来确保存储在Oracle XML DB中的XML文档的准确性和完整性。</li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-A6A640D9-3EE9-44D0-AE9D-A3CF66466EC6">与XML Schema相关的XMLType方法</a><br>使用XML模式的最重要的<code class="codeph">XMLType</code>方法是： <code class="codeph">isSchemaBased()</code> ， <code class="codeph">getSchemaURL()</code> ， <code class="codeph">schemaValidate()</code> ， <code class="codeph">isSchemaValid()</code> ， <code class="codeph">isSchemaValidated()</code>和<code class="codeph">setSchemaValidated()</code> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6304"></a><div class="props_rev_3"><a id="GUID-A708BD08-16C2-4E67-BF64-F8213A4FBAB9" name="GUID-A708BD08-16C2-4E67-BF64-F8213A4FBAB9"></a><h4 id="ADXDB-GUID-A708BD08-16C2-4E67-BF64-F8213A4FBAB9" class="sect4"><span class="enumeration_section">17.2.1</span>为什么在Oracle XML DB中使用XML模式？
                  </h4>
                  <div>
                     <p>使用XML Schema的常见原因包括验证，约束定义，存储规范以及文档插入，存储和访问的优化。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML Schema的最常见用途是作为<span class="italic">验证</span> XML实例文档是否符合给定XML模式的机制，即验证XML数据是否符合其预期定义。此定义包括数据类型，允许的项目出现次数和允许的项目长度。
                           </p>
                        </li>
                        <li>
                           <p>在创建<code class="codeph">XMLType</code>表或列时，XML模式也可以用作<span class="italic">约束</span> 。例如，可以约束表或列以仅存储符合XML模式定义的全局元素之一的XML文档。
                           </p>
                        </li>
                        <li>
                           <p>Oracle XML DB还使用XML Schema作为定义如何将<code class="codeph">XMLType</code>实例的内容存储在数据库中的机制。<code class="codeph">XMLType</code>二进制XML和对象关系存储模型都支持使用XML Schema。当<code class="codeph">XMLType</code>数据以对象关系方式存储时，XML Schema用于有效地将XML Schema数据类型映射到SQL数据类型和对象关系表和列。
                           </p>
                        </li>
                        <li>
                           <p>使用协议FTP和HTTP（S）在Oracle XML DB中存储基于XML模式的文档时，XML模式信息还可以提高文档插入的效率。</p>
                        </li>
                        <li>
                           <p>当必须处理XML实例时，如果没有任何关于它们的先验信息，XML模式可用于预测最佳存储，保真度和访问。</p>
                        </li>
                     </ul>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="intro-to-XML-DB.html#GUID-B8507F44-B010-4384-94E6-101131DD7D88" title="XMLType是一种抽象数据类型，它提供了不同的存储模型，以最好地适应您的数据及其使用。作为抽象数据类型，您的应用程序和数据库查询可以获得灵活性：所有XMLType操作都可以使用相同的接口。">XMLType存储模型</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CD1BA605-196D-461C-9707-6A0B870F1172" title="Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。">将XML架构与Oracle XML DB一起使用的概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6309"></a><a id="ADXDB6307"></a><div class="props_rev_3"><a id="GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8" name="GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8"></a><h4 id="ADXDB-GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8" class="sect4"><span class="enumeration_section">17.2.2</span>注释XML模式以控制命名，映射和存储的概述</h4>
                  <div>
                     <p>W3C XML Schema Recommendation允许将特定于供应商的注释添加到XML模式中。Oracle XML DB使用注释来控制XML模式和各种数据库功能之间的映射。您可以使用注释指定哪些表存储XML数据。注释对于对象关系存储尤其有用。</p>
                     <p>您可以将XML架构注释与Oracle XML DB一起使用来执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>指定用于存储XML数据的数据库表。</p>
                        </li>
                        <li>
                           <p>覆盖XML Schema数据类型和SQL数据类型之间的默认映射，用于对象关系存储。</p>
                        </li>
                        <li>
                           <p>命名为存储XML数据而创建的数据库对象和属性（用于对象关系存储）。</p>
                        </li>
                     </ul>
                     <p><a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2</a>显示了带注释的购买订单XML架构。它定义了以下两个XML命名空间：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">http://www.w3c.org/2001/XMLSchema</code> 。这是由W3C保留的Schema for Schemas。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">http://xmlns.oracle.com/xdb</code> 。这是Oracle为Oracle XML DB架构注释保留的。
                           </p>
                        </li>
                     </ul>
                     <p>在注释XML模式之前， <span class="italic">必须</span>声明Oracle XML DB名称空间。Oracle XML DB命名空间是<code class="codeph">http://xmlns.oracle.com/xdb</code> 。 <a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2</a>使用名称空间<span class="italic">前缀</span> <span class="bold"><code class="codeph">xdb</code></span>来缩写Oracle XML DB名称空间。
                     </p>
                     <p><a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2</a>使用多个XML模式注释，包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">PurchaseOrder</code>元素中的<code class="codeph">defaultTable</code>注释。这指定符合此XML模式的XML文档存储在名为<code class="codeph">purchaseorder</code>的数据库表中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLType</code>注释。
                           </p>
                           <p>第一次出现注释<code class="codeph">SQLType</code>指定从<code class="codeph">complexType</code>元素<code class="codeph">PurchaseOrderType</code>生成的SQL数据类型的名称是<code class="codeph">purchaseorder_t</code> 。
                           </p>
                           <p>第二次出现注释<code class="codeph">SQLType</code>指定从<code class="codeph">complexType</code>元素<code class="codeph">LineItemType</code>生成的SQL数据类型的名称是<code class="codeph">lineitem_t</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLCollType</code>注释。这指定管理<code class="codeph">LineItem</code>元素集合的SQL varray类型的名称是<code class="codeph">lineitem_v</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLName</code>注释。这为<code class="codeph">purchaseorder_t</code>每个SQL对象属性提供了显式名称。
                           </p>
                        </li>
                     </ul>
                     <p><a href="XML-Schema-and-query-basic.html#GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8__CEGIBHEB">图17-2</a>显示了XMLSpy <span class="bold">Oracle</span>选项卡，该选项卡有助于在图形编辑器中工作时将Oracle XML DB注释添加到XML模式。
                     </p>
                     <div class="figure" id="GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8__CEGIBHEB">
                        <p class="titleinfigure">图17-2 XMLSpy支持Oracle XML DB模式注释</p><img src="img/annot_spy.gif" width="585" alt="下面是图17-2的描述" title="下面是图17-2的描述" longdesc="img_text/annot_spy.html"><br><a href="img_text/annot_spy.html">“图17-2 XMLSpy支持Oracle XML DB模式注释”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CD1BA605-196D-461C-9707-6A0B870F1172" title="Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。">将XML架构与Oracle XML DB一起使用的概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4482"></a><div class="props_rev_3"><a id="GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6" name="GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6"></a><h4 id="ADXDB-GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6" class="sect4"><span class="enumeration_section">17.2.3</span> DOM保真度</h4>
                  <div>
                     <p>DOM保真度意味着保留XML文档中的所有信息，除了无关紧要的空白。您可以使用DOM保真度来确保存储在Oracle XML DB中的XML文档的准确性和完整性。</p>
                     <p><strong class="term">文档对象模型（DOM）保真度</strong>是与<strong class="term">DOM</strong>原始XML文档相比，为DOM遍历保留检索到的XML文档结构的概念。
                     </p>
                     <p>使用DOM保真度，从数据库中检索的XML数据具有与插入数据库之前相同的信息，只有无关紧要的空白。使用术语“DOM保真度”是因为这种保真度对于DOM遍历特别重要。</p>
                     <p>利用XML数据的二进制XML存储，所有重要信息都以二进制XML格式编码，从而确保DOM保真度。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6__GUID-7B1AFA1D-52A5-4F78-A2F8-88CCF7AD2C59">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439" title="为了提供以对象关系存储的XML数据的DOM保真度，Oracle XML DB使用系统定义的二进制对象属性SYS_XDBPD $将所有无法存储在任何其他对象属性中的信息记录为实例级元数据（位置描述符或PD）。">用于对象关系存储的SYS_XDBPD $和DOM Fidelity，</a>用于获取有关DOM数据的DOM保真度和对象关系存储的信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CD1BA605-196D-461C-9707-6A0B870F1172" title="Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。">将XML架构与Oracle XML DB一起使用的概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4476"></a><a id="ADXDB4475"></a><div class="props_rev_3"><a id="GUID-A6A640D9-3EE9-44D0-AE9D-A3CF66466EC6" name="GUID-A6A640D9-3EE9-44D0-AE9D-A3CF66466EC6"></a><h4 id="ADXDB-GUID-A6A640D9-3EE9-44D0-AE9D-A3CF66466EC6" class="sect4"><span class="enumeration_section">17.2.4</span>与XML Schema相关的XMLType方法</h4>
                  <div>
                     <p>使用XML模式的最重要的<code class="codeph">XMLType</code>方法是： <code class="codeph">isSchemaBased()</code> ， <code class="codeph">getSchemaURL()</code> ， <code class="codeph">schemaValidate()</code> ， <code class="codeph">isSchemaValid()</code> ， <code class="codeph">isSchemaValidated()</code>和<code class="codeph">setSchemaValidated()</code> 。
                     </p>
                     <div class="tblformalwide" id="GUID-A6A640D9-3EE9-44D0-AE9D-A3CF66466EC6__G1048549">
                        <p class="titleintable">表17-1与XML模式相关的XMLType方法</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="与XML Schema相关的XMLType方法" width="100%" border="1" summary="This table describes XMLType API’s eight  XML Schema methods." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d81865e1121">XMLType方法</th>
                                 <th align="left" valign="bottom" width="75%" id="d81865e1124">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d81865e1129" headers="d81865e1121 "><pre class="oac_no_warn" dir="ltr">isSchemaBased（）</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d81865e1129 d81865e1124 ">
                                    <p>如果<code class="codeph">XMLType</code>实例基于XML架构，则返回<code class="codeph">TRUE</code>否则返回<code class="codeph">FALSE</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d81865e1145" headers="d81865e1121 "><pre class="oac_no_warn" dir="ltr">getSchemaURL（）</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d81865e1145 d81865e1124 ">
                                    <p><code class="codeph">XMLType</code>实例的XML架构URL。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d81865e1155" headers="d81865e1121 "><pre class="oac_no_warn" dir="ltr">schemaValidate（）isSchemaValid（）isSchemaValidated（）setSchemaValidated（）</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d81865e1155 d81865e1124 ">
                                    <p>针对已注册的XML模式验证<code class="codeph">XMLType</code>实例：验证，检查验证状态或设置记录的验证状态。请参阅<a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="有几个Oracle SQL函数和XMLType API，用于使用XSLT样式表转换XMLType数据，以及根据XML模式验证XMLType实例。">XMLType数据的转换和验证</a> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CD1BA605-196D-461C-9707-6A0B870F1172" title="Oracle XML DB支持注册XML模式，根据XML模式验证文档，从SQL对象类型生成XML模式，从XML模式映射到SQL，创建和查询基于XML模式的表，视图和列，以及在XML时自动插入数据基于模式的文档将插入Oracle XML DB Repository中。">将XML架构与Oracle XML DB一起使用的概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6310"></a><div class="props_rev_3"><a id="GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" name="GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF"></a><h3 id="ADXDB-GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" class="sect3"><span class="enumeration_section">17.3</span>使用Oracle XML DB进行XML模式注册</h3>
               <div>
                  <p>在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建<code class="codeph">XMLType</code>表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。
                  </p>
                  <p>与所有DDL操作一样，XML模式注册是非事务性的。但是，从这个意义上说，注册是<span class="italic">原子的</span> ：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果注册成功，则操作将自动提交。</p>
                     </li>
                     <li>
                        <p>如果注册失败，则数据库将回滚到注册开始之前的状态。</p>
                     </li>
                  </ul>
                  <p>由于XML模式注册可能涉及创建对象类型和表，因此错误恢复涉及删除由此创建的任何类型和表。整个XML模式注册过程保证是原子的：要么成功，要么数据库恢复到注册开始之前的状态。</p>
                  <p>使用Oracle XML DB注册XML模式需要两个项目：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>XML架构文档</p>
                     </li>
                     <li>
                        <p>在向Oracle数据库注册之后，可以将其用作XML模式的唯一标识符的字符串。XML实例文档使用此唯一标识符将自身标识为XML模式定义的类的成员。标识符通常采用URL的形式，通常称为<strong class="term">架构位置提示</strong>或<strong class="term">文档位置提示</strong> 。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF__GUID-E0C23F1A-CADE-43F8-860E-80EC3ED426C7">
                     <p class="notep1">注意：</p>
                     <p>注册XML模式的行为<span class="italic">不会影响</span> <span class="italic">已加载</span>到Oracle XML DB Repository中并引用该XML模式的任何实例文档的状态。
                     </p>
                     <p>这些实例文档在加载时被视为非基于XML模式的文档。他们仍然如此。在模式注册之后，您必须<span class="italic">删除</span>这些文档并<span class="italic">重新加载</span>它们，以获取基于XML模式的文档。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-88464A1A-32CB-40C3-A940-416E3442CF10">XML模式注册操作</a><br>作为注册XML模式的一部分，Oracle XML DB执行多个操作，以便于存储，访问和操作符合XML模式的XML实例。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660">向Oracle XML DB注册XML模式</a><br>一个示例说明了使用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>来注册XML模式。此过程的主要参数是架构URL，架构源文档，源文档编码的字符集ID以及指定架构应如何注册的选项。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F">XML模式注册期间创建的SQL类型和表</a><br>注册XML模式会导致创建对象类型和表。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-4AC085E5-5E41-42A1-8124-1D875AB69D12">全局元素的默认表</a><br>默认情况下，为所有全局元素创建具有系统生成名称的表。您可以指定要使用的名称。您可以阻止为特定元素创建默认表，这可以减少处理器时间和使用的空间，尤其是在XML模式包含许多全局元素定义的情况下。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-5F79EAA4-F8AC-4241-A18C-1B4465776460">依赖于已注册的XML模式的数据库对象</a><br>几种数据库对象可以依赖于已注册的XML模式：表，视图，其他XML模式以及引用XML模式的游标。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4">本地和全局XML模式</a><br>XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-7A661274-35C2-422B-A290-5E06D9BADAA0">完全合格的XML架构URL</a><br><span class="italic">完全限定的</span> XML模式URL允许显式引用特定的XML模式。拥有XML模式的数据库用户的名称被指定为URL的一部分。完全限定的模式URL属于Oracle XML DB名称空间。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F">删除XML模式</a><br>您可以使用过程<code class="codeph">DBMS_XMLSCHEMA.</code>删除已注册的XML模式<code class="codeph">DBMS_XMLSCHEMA.</code> <span class="bold"><code class="codeph">deleteSchema</code></span> 。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9">列出所有已注册的XML模式</a><br>示例列出了向Oracle XML DB注册的所有XML模式。</li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4460"></a><div class="props_rev_3"><a id="GUID-88464A1A-32CB-40C3-A940-416E3442CF10" name="GUID-88464A1A-32CB-40C3-A940-416E3442CF10"></a><h4 id="ADXDB-GUID-88464A1A-32CB-40C3-A940-416E3442CF10" class="sect4"><span class="enumeration_section">17.3.1</span> XML模式注册操作</h4>
                  <div>
                     <p>作为注册XML模式的一部分，Oracle XML DB执行多个操作，以便于存储，访问和操作符合XML模式的XML实例。</p>
                     <p>这些包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将XML Schema数据类型映射到Oracle XML DB存储。存储基于XML模式的数据时，其存储数据类型使用默认映射从XML模式数据类型派生，并可选择使用您使用XML模式注释指定的映射信息。对于二进制XML存储，XML Schema类型映射到二进制XML编码类型。对于对象关系存储，XML模式注册为符合文档的对象关系存储创建适当的SQL对象类型。</p>
                        </li>
                        <li>
                           <p>创建默认表。XML模式注册为所有全局元素生成默认<code class="codeph">XMLType</code>表。您可以使用XML模式注释来控制表的名称，并提供在表创建期间使用的列级和表级存储子句和约束。
                           </p>
                        </li>
                     </ul>
                     <p>在XML模式注册之后，Oracle XML DB可以自动处理使用XML模式实例机制引用XML模式的文档。对于以对象关系存储的XML数据，可以创建受XML架构定义的全局元素约束的<code class="codeph">XMLType</code>表和列。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-basic.html#GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4" title="符合XML模式的数据使用XML模式数据类型。当此XML数据存储在Oracle XML DB中时，其存储数据类型使用默认映射从XML架构数据类型派生，并且可选地使用您使用XML架构批注指定的映射信息。">XML模式数据类型映射到Oracle XML DB存储</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53" title="您可以在XML模式注册中创建默认表。使用API和协议（如FTP和HTTP（S））插入文档时，默认表最有用，它们不提供任何表规范。">XML架构注册期间创建的默认表</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML Schema Annotations</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6312"></a><a id="ADXDB6311"></a><div class="props_rev_3"><a id="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660" name="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660"></a><h4 id="ADXDB-GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660" class="sect4"><span class="enumeration_section">17.3.2</span>使用Oracle XML DB注册XML模式</h4>
                  <div>
                     <p>一个示例说明了使用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>来注册XML模式。此过程的主要参数是架构URL，架构源文档，源文档编码的字符集ID以及指定架构应如何注册的选项。
                     </p>
                     <div class="section">
                        <p><code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>的主要参数如下：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SCHEMAURL</code> -  XML架构URL。这是Oracle XML DB中XML模式的唯一标识符。它通常以URL的形式出现，但这不是必需的。通过使架构位置提示与XML架构URL相同，XML架构URL与Oracle XML DB一起用于标识实例文档。 Oracle XML DB从不尝试访问由指定URL标识的Web服务器。</p>
                              <div class="infoboxnote" id="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__GUID-950A38B2-6813-4262-9D0D-00EBEFCAEB5D">
                                 <p class="notep1">注意：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p></p>
                                       <p>您不能使用与任何系统定义的XML架构相同的<code class="codeph">SCHEMAURL</code>注册XML架构。
                                       </p>
                                    </li>
                                    <li>
                                       <p>URL的非协议部分必须是唯一的。在测试唯一性时忽略协议部分（例如， <code class="codeph">http</code>或<code class="codeph">https</code> ）。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <p><code class="codeph">SCHEMADOC</code> -  XML架构源文档。这是<code class="codeph">VARCHAR</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">BLOB</code> ， <code class="codeph">BFILE</code> ， <code class="codeph">XMLType</code>或<code class="codeph">URIType</code>值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">CSID</code> - 当<code class="codeph">schemaDoc</code>是<code class="codeph">BFILE</code>或<code class="codeph">BLOB</code>值时，源文档编码的字符集ID。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIONS</code> - 指定应如何注册XML模式的选项。最重要的选项是<code class="codeph">REGISTER_BINARYXML</code> ，它表示XML模式用于二进制XML存储。另一个选项是<code class="codeph">REGISTER_NT_AS_IOT</code> ，它强制将OCT存储为索引组织表（IOT）。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__GUID-30F39B84-5563-4270-A48E-0639502FA06B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../arpls/DBMS_XMLSCHEMA.html#ARPLS377" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__CEGDEDDF">例17-1</a>注册了<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">例A-2</a>的带注释的XML模式。
                        </p>
                        <p>在<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2中</a> ，XML模式的唯一标识符是：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：8080 /源/模式/ poSource / XSD / purchaseOrder.xsd</pre><p>之前，XML模式文档已加载到Oracle XML DB Repository中： <code class="codeph">/source/schemas/poSource/xsd/purchaseOrder.xsd</code> 。
                        </p>
                        <p>在XML模式注册期间，选项<code class="codeph">SCHEMADOC</code>指定PL / SQL构造函数<code class="codeph">XDBURIType</code>将根据其在存储库中的位置来访问XML模式文档的内容。传递给过程<code class="codeph">registerSchema</code>其他选项指定将<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2</a>中的模式注册为本地XML模式（选项<code class="codeph">LOCAL</code> ），并在注册过程中生成SQL对象和那些表（选项<code class="codeph">GENTABLES</code> ）。
                        </p>
                        <p>PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>解析并验证XML模式。</p>
                           </li>
                           <li>
                              <p>在Oracle数据字典中创建一组描述XML模式的条目。</p>
                           </li>
                           <li>
                              <p>基于XML模式中定义的<code class="codeph">complexType</code>元素创建一组SQL对象定义。
                              </p>
                           </li>
                           <li>
                              <p>为XML模式定义的每个全局元素创建<code class="codeph">XMLType</code>表。
                              </p>
                           </li>
                        </ul>
                        <p>默认情况下，注册XML模式时，Oracle XML DB会自动生成管理实例文档所需的所有SQL对象类型和<code class="codeph">XMLType</code>表。XML模式可以注册为全局或本地。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__GUID-CA96B25F-AB87-44BA-BA18-F503B82FC9AB">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>信息<a href="../arpls/DBMS_XMLSCHEMA.html#ARPLS377" target="_blank"><span><cite>，请参见Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__CEGDEDDF">
                        <p class="titleinexample">示例17-1使用DBMS_XMLSCHEMA.REGISTERSCHEMA注册XML模式</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;' <span class="bold">http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd</span> '，SCHEMADOC =&gt; XDBURIType（' <span class="bold">/ ssource /schemas / poSource / xsd</span> <span class="bold">/purchaseOrder.xsd</span> '） .getCLOB（），LOCAL =&gt; <span class="bold">TRUE</span> ，GENTYPES =&gt; <span class="bold">TRUE</span> ，GENTABLES =&gt; TRUE）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" title="XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。">本地和全局XML模式</a></li>
                           <li><a href="XML-Schema-and-query-basic.html#GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F" title="注册XML模式会导致创建对象类型和表。">XML模式注册期间创建的SQL类型和表</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6314"></a><a id="ADXDB6313"></a><div class="props_rev_3"><a id="GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F" name="GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F"></a><h4 id="ADXDB-GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F" class="sect4"><span class="enumeration_section">17.3.3</span> XML模式注册期间创建的SQL类型和表</h4>
                  <div>
                     <p>注册XML模式会导致创建对象类型和表。</p>
                     <p><a href="XML-Schema-and-query-basic.html#GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F__CEGHCACG">例17-2</a>显示了在XML模式注册期间创建的SQL类型定义，例如<a href="XML-Schema-and-query-basic.html#GUID-2758A6B4-2BE7-4597-94E7-F344FF7C9660__CEGDEDDF">示例17-1</a> 。这些SQL类型定义包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">purchaseorder_t</code> 。此类型用于保留从<code class="codeph">PurchaseOrder</code>元素生成的SQL对象。当包含<code class="codeph">PurchaseOrder</code>元素的XML文档存储在Oracle XML DB中时，文档将被分解，并且文档的内容将存储为<code class="codeph">purchaseorder_t</code>的实例。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">lineitems_t</code> ， <code class="codeph">lineitem_v</code>和<code class="codeph">lineitem_t</code> 。这些类型管理可能存在于<code class="codeph">PurchaseOrder</code>文档中的<code class="codeph">LineItem</code>元素的集合。类型<code class="codeph">lineitems_t</code>由单个属性<code class="codeph">lineitem</code> ，定义为<code class="codeph">lineitem_v</code>类型的实例。类型<code class="codeph">lineitem_v</code>被定义为<code class="codeph">linteitem_t</code>对象的<code class="codeph">linteitem_t</code> 。对于文档中的每个<code class="codeph">LineItem</code>元素，有一个<code class="codeph">lineitem_t</code>对象的实例。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-7E0BA10E-2E50-4A54-9DE1-C2C95665AB0F__CEGHCACG">
                        <p class="titleinexample">示例17-2 XML架构注册期间创建的对象</p><pre class="pre codeblock"><code>DESCRIBE purchaseorder_t purchaseorder_t不是最终名称是否为空？输入----------------------------------------- -------- ---------------------------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T REFERENCE VARCHAR2（30 CHAR）ACTIONS_TTIONS REJECTION REJECTION_T REQUESTOR VARCHAR2（128 CHAR ）USERID VARCHAR2（10 CHAR）COST_CENTER VARCHAR2（4 CHAR）SHIPPING_INSTRUCTIONS SHIPPING_INSTRUCTIONS_T SPECIAL_INSTRUCTIONS VARCHAR2（2048 CHAR）LINEITEMS LINEITEMS_T DESCRIBE lineitems_t lineitems_t is NOTAL Name Null？输入----------------------------------------- -------- ---------------------------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T LINEITEM LINEITEM_V DESCRIBE lineitem_v lineitem_v VARRAY（2147483647）LINEITEM_T LINEITEM_T不是最终版名字空？输入----------------------------------------- -------- ---------------------------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T ITEMNUMBER NUMBER（38）DESCRIPTION VARCHAR2（256 CHAR）PART PART_T</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6316"></a><div class="props_rev_3"><a id="GUID-4AC085E5-5E41-42A1-8124-1D875AB69D12" name="GUID-4AC085E5-5E41-42A1-8124-1D875AB69D12"></a><h4 id="ADXDB-GUID-4AC085E5-5E41-42A1-8124-1D875AB69D12" class="sect4"><span class="enumeration_section">17.3.4</span>全局元素的默认表</h4>
                  <div>
                     <p>默认情况下，为所有全局元素创建具有系统生成名称的表。您可以指定要使用的名称。您可以阻止为特定元素创建默认表，这可以减少处理器时间和使用的空间，尤其是在XML模式包含许多全局元素定义的情况下。</p>
                     <p>缺省情况下，向数据库注册XML模式时，Oracle XML DB会<span class="italic">为</span> XML模式定义的<span class="italic">每个全局元素</span>生成一个<span class="italic">缺省表</span> 。
                     </p>
                     <p>您可以使用属性<code class="codeph">xdb:defaultTable</code>指定给定全局元素的默认表的名称。您提供的每个<code class="codeph">xdb:defaultTable</code>属性值在给定数据库用户注册的<span class="italic">所有模式中</span>必须是<span class="italic">唯一的</span> 。如果您<span class="italic">没有</span>为某个元素提供非空的默认表名，则会自动提供唯一的名称。
                     </p>
                     <p>但实际上，您<span class="italic">不</span>希望为大多数全局元素创建默认表。从不作为XML实例文档的根元素的元素不需要默认表 - 从不使用这样的表。为所有全局元素创建缺省表可能会导致处理器时间和使用空间的显着开销，尤其是在XML模式包含大量全局元素定义的情况下。
                     </p>
                     <p>作为一般规则，那么，你要防止默认表的创建任何全局元素（或存储脱节任何本地元素），你就一定<span class="italic">不会</span>被用作任何文档中的根元素。您可以通过以下方式之一执行此操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将注释<code class="codeph">xdb:defaultTable =</code> <span class="bold"><code class="codeph">""</code></span> （空字符串）添加到<span class="italic">不会</span>显示为XML实例文档的根元素的<span class="italic">每个</span>全局元素的定义中。使用此方法，通常允许自动创建默认表，并使用<code class="codeph">xdb:defaultTable = ""</code>在需要时明确禁止它。
                           </p>
                        </li>
                        <li>
                           <p>在注册XML模式时将参数<code class="codeph">GENTABLES</code>设置为<code class="codeph">FALSE</code> ，然后为每个可以合法地显示为实例文档的根元素的全局元素<span class="italic">手动创建默认表</span> 。使用此方法，可以禁止自动创建默认表，并且只需手动创建所需的表。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4469"></a><div class="props_rev_3"><a id="GUID-5F79EAA4-F8AC-4241-A18C-1B4465776460" name="GUID-5F79EAA4-F8AC-4241-A18C-1B4465776460"></a><h4 id="ADXDB-GUID-5F79EAA4-F8AC-4241-A18C-1B4465776460" class="sect4"><span class="enumeration_section">17.3.5</span>依赖于已注册的XML模式的数据库对象</h4>
                  <div>
                     <p>几种数据库对象可以依赖于已注册的XML模式：表，视图，其他XML模式以及引用XML模式的游标。</p>
                     <p>更确切地说：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>具有符合XML模式中的元素的<code class="codeph">XMLType</code>列的表或视图。
                           </p>
                        </li>
                        <li>
                           <p>包含或导入给定XML模式的其他XML模式，作为其定义的一部分。</p>
                        </li>
                        <li>
                           <p>引用XML模式的游标。这包括<code class="codeph">DBMS_XMLGEN</code>包的功能内的引用。这种游标是纯粹的瞬态对象。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4477"></a><div class="props_rev_3"><a id="GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" name="GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4"></a><h4 id="ADXDB-GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" class="sect4"><span class="enumeration_section">17.3.6</span>本地和全局XML模式</h4>
                  <div>
                     <p>XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。</p>
                     <p>注册XML模式时，PL / SQL包<code class="codeph">DBMS_XMLSCHEMA</code>会将相应的资源添加到Oracle XML DB存储库。XML模式URL确定存储库中XML模式资源的路径名（并且它与PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>参数<code class="codeph">SCHEMAURL</code>相关联）。
                     </p>
                     <div class="infoboxnote" id="GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4__GUID-68C0ACB6-8FFF-4FC4-BFD2-6ECADB69D9AA">
                        <p class="notep1">注意：</p>
                        <p>在Oracle Enterprise Manager中，本地和全局注册的XML模式分别称为<strong class="term">私有</strong>和<strong class="term">公共</strong> 。
                        </p>
                     </div>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077">本地XML架构</a><br>默认情况下，XML模式是本地的，这意味着在向Oracle XML DB注册之后，它只属于您。对XML模式文档的引用以您的用户（数据库模式）名称存储在Oracle XML DB Repository中。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9">全局XML模式</a><br>与本地XML模式相比，特权用户可以通过指定注册函数<code class="codeph">DBMS_XMLSCHEMA</code>的参数将XML模式注册为全局模式。对<span class="italic">所有</span>用户都可见。它们存储在Oracle XML DB Repository中的文件夹<code class="codeph">/sys/schemas/PUBLIC/</code> 。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4479"></a><a id="ADXDB4478"></a><div class="props_rev_3"><a id="GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077" name="GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077"></a><h5 id="ADXDB-GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077" class="sect5"><span class="enumeration_section">17.3.6.1</span>本地XML模式</h5>
                     <div>
                        <p>默认情况下，XML模式是本地的，这意味着在您使用Oracle XML DB注册后，它只属于您。对XML模式文档的引用以您的用户（数据库模式）名称存储在Oracle XML DB Repository中。</p>
                        <p>这种XML模式称为<strong class="term">本地</strong>模式。默认情况下，它们仅供您（所有者）使用。在Oracle XML DB中，在文件夹<code class="codeph">/sys/schemas/</code> <span class="italic"><code class="codeph">username</code></span>下创建本地XML模式资源。存储库路径名的其余部分派生自架构URL。</p>
                        <p>例如，如果用户<code class="codeph">QUINE</code>将XML模式<code class="codeph">purchaseOrder.xsd</code>注册为本地模式， <code class="codeph">QUINE</code>为其指定此路径名：</p><pre class="oac_no_warn" dir="ltr">/ sys / schemas / <span class="bold">QUINE</span> /xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</pre><div class="p">数据库用户需要适当的权限和访问控制列表（ACL）来创建具有给定路径名的资源，以便将XML模式注册为本地XML模式。可以注册本地XML架构的一些方法需要以下一个或多个特权：<ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">改变会话</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">创建程序</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">创建会话</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">创建表</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">创造触发器</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">创造TYOE</code></p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnote" id="GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077__GUID-63DC23EC-2ABA-4F36-85B6-C9EE9EE80742">
                           <p class="notep1">注意：</p>
                           <p>通常，只有XML模式的所有者才能使用它来定义<code class="codeph">XMLType</code>表，列或视图，验证文档等。但是，Oracle XML DB支持完全限定的XML架构URL。例如： <code class="codeph">http://xmlns.oracle.com/xdb/schemas/QUINE/xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</code> ： <code class="codeph">http://xmlns.oracle.com/xdb/schemas/QUINE/xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</code> 。特权用户可以使用此类扩展URL来指定属于其他用户的XML模式（在本例中为用户<code class="codeph">QUINE</code> ）。
                           </p>
                        </div>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077__BJFIJHJA">
                           <p class="titleinexample">示例17-3注册本地XML架构</p><pre class="pre codeblock"><code>BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd',SCHEMADOC =&gt; bfilename（'XMLDIR'，'purchaseOrder.xsd'），LOCAL =&gt; <span class="bold">TRUE</span> ，GENTYPES =&gt; TRUE，GENTABLES =&gt; FALSE，CSID =&gt; nls_charset_id（'AL32UTF8'））;结束; /</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="repository-access-control.html#GUID-CD4A712D-CCA2-4A19-909E-AEC57849A55A" title="Oracle数据库提供经典的数据库安全性，例如数据库用户的行级和列级安全访问。它还为Oracle XML DB Repository中的资源提供了细粒度的访问控制。您可以创建，设置和修改访问控制列表（ACL）。">存储库访问控制</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" title="XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。">本地和全局XML架构</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4481"></a><a id="ADXDB4480"></a><div class="props_rev_3"><a id="GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9" name="GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9"></a><h5 id="ADXDB-GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9" class="sect5"><span class="enumeration_section">17.3.6.2</span>全局XML模式</h5>
                     <div>
                        <p>与本地XML模式相比，特权用户可以通过指定注册函数<code class="codeph">DBMS_XMLSCHEMA</code>的参数将XML模式注册为全局模式。对<span class="italic">所有</span>用户都可见。它们存储在Oracle XML DB Repository中的文件夹<code class="codeph">/sys/schemas/PUBLIC/</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9__GUID-C0712B94-5A53-469E-B836-CBC574078E8F">
                           <p class="notep1">注意：</p>
                           <p>对文件夹<code class="codeph">/sys/schemas/PUBLIC</code>的访问由访问控制列表（ACL）控制。默认情况下，此文件夹只能由数据库管理员写入。您需要对此文件夹具有写权限才能注册全局XML模式。角色<code class="codeph">XDBADMIN</code>提供对此文件夹的写访问权，假设它受默认ACL保护。请参阅<a href="repository-access-control.html#GUID-CD4A712D-CCA2-4A19-909E-AEC57849A55A" title="Oracle数据库提供经典的数据库安全性，例如数据库用户的行级和列级安全访问。它还为Oracle XML DB Repository中的资源提供了细粒度的访问控制。您可以创建，设置和修改访问控制列表（ACL）。">存储库访问控制</a> 。
                           </p>
                        </div>
                        <p>您可以使用与现有全局模式相同的URL注册本地模式。本地模式始终隐藏（隐藏）具有相同名称（URL）的任何全局模式。</p>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9__BJFBGBEJ">例17-4</a>说明了全局模式的注册。
                        </p>
                        <div class="example" id="GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9__BJFBGBEJ">
                           <p class="titleinexample">示例17-4注册全局XML架构</p><pre class="oac_no_warn" dir="ltr"><span class="bold">GRANT XDBADMIN TO QUINE;</span>格兰特成功了。CONNECT quine输入密码： <span class="italic">密码</span>已连接。BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd',SCHEMADOC =&gt; bfilename（'XMLDIR'，'purchaseOrder.xsd'），LOCAL =&gt; <span class="bold">FALSE</span> ，GENTYPES =&gt; TRUE，GENTABLES =&gt; FALSE，CSID =&gt; nls_charset_id（'AL32UTF8'））;结束; /</pre><p>如果用户<code class="codeph">QUINE</code>注册了此全局XML架构，则会为其指定此路径名：</p><pre class="oac_no_warn" dir="ltr">/ sys / schemas / <span class="bold">PUBLIC</span> /xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</pre><p>数据库用户需要适当的权限（ACL访问权限）才能创建此资源，以便将XML模式注册为全局模式。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" title="XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。">本地和全局XML架构</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4634"></a><div class="props_rev_3"><a id="GUID-7A661274-35C2-422B-A290-5E06D9BADAA0" name="GUID-7A661274-35C2-422B-A290-5E06D9BADAA0"></a><h4 id="ADXDB-GUID-7A661274-35C2-422B-A290-5E06D9BADAA0" class="sect4"><span class="enumeration_section">17.3.7</span>完全限定的XML模式URL</h4>
                  <div>
                     <p><span class="italic">完全限定的</span> XML模式URL允许显式引用特定的XML模式。拥有XML模式的数据库用户的名称被指定为URL的一部分。完全限定的模式URL属于Oracle XML DB名称空间。
                     </p>
                     <p>默认情况下，XML架构URL在当前数据库用户的范围内引用。XML模式URL首先被解析为当前用户拥有的<span class="italic">本地</span> XML模式的名称。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果没有这样的XML模式，那么它们将被解析为<span class="italic">全局</span> XML模式的名称。
                           </p>
                        </li>
                        <li>
                           <p>如果没有<span class="italic">全局</span> XML模式，则Oracle XML DB会引发错误。
                           </p>
                        </li>
                     </ul>
                     <p>Oracle XML DB命名空间是：</p><pre class="oac_no_warn" dir="ltr">http://xmlns.oracle.com/xdb/schemas/ <span class="italic"><span class="bold">&lt;database-user&gt;</span></span> / &lt;schemaURL-minus-protocol&gt;</pre><p>例如，假设存在一个注册的全局XML模式，其URL为<code class="codeph">http://www.example.com/po.xsd</code> ，而用户<code class="codeph">QUINE</code>具有一个具有相同URL的本地注册XML模式。另一个用户可以使用此完全限定的XML Schema URL引用<code class="codeph">QUINE</code>拥有的模式，如下所示：</p><pre class="oac_no_warn" dir="ltr">http://xmlns.oracle.com/xdb/schemas/ <span class="bold">QUINE</span> /www.example.com/po.xsd</pre><p>全局XML架构的完全限定URL是：</p><pre class="oac_no_warn" dir="ltr">http://xmlns.oracle.com/xdb/schemas/ <span class="bold">PUBLIC</span> /www.example.com/po.xsd</pre><div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" title="XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。">本地和全局XML模式</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4474"></a><a id="ADXDB4472"></a><div class="props_rev_3"><a id="GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F" name="GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F"></a><h4 id="ADXDB-GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F" class="sect4"><span class="enumeration_section">17.3.8</span>删除XML模式</h4>
                  <div>
                     <p>您可以使用过程<code class="codeph">DBMS_XMLSCHEMA.</code>删除已注册的XML模式<code class="codeph">DBMS_XMLSCHEMA.</code> <span class="bold"><code class="codeph">deleteSchema</code></span> 。
                     </p>
                     <p>默认情况下，这会执行以下操作：</p>
                     <ol>
                        <li>
                           <p>检查当前用户是否具有相应的权限，以删除与Oracle XML DB Repository中的XML模式相对应的资源。您可以通过在XML架构资源上设置适当的ACL来控制哪些用户可以删除哪些XML架构。</p>
                        </li>
                        <li>
                           <p>检查是否有任何表依赖于要删除的XML架构。如果是这样，则引发错误并取消删除。如果使用选项<code class="codeph">delete_invalidate</code>或<code class="codeph">delete_cascade_force</code>则不执行此检查。在这种情况下，不会引发错误。
                           </p>
                        </li>
                        <li>
                           <p>从Oracle XML DB存储库（文件夹<code class="codeph">/sys/schemas</code> ）中删除XML架构文档。
                           </p>
                        </li>
                        <li>
                           <p>从<code class="codeph">DBA_XML_SCHEMAS</code>删除XML模式文档，除非它已注册用于二进制XML实例，并且既不使用<code class="codeph">delete_invalidate</code>也不使用<code class="codeph">delete_cascade_force</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果使用<code class="codeph">delete_cascade</code>或<code class="codeph">delete_cascade_force</code> ，则删除默认表。如果指定了<code class="codeph">delete_cascade</code>并且其他表中的实例也依赖于XML模式，则会引发错误。
                           </p>
                        </li>
                     </ol>
                     <p>以下值可用于过程<code class="codeph">DBMS_XMLSCHEMA.deleteSchema</code>选项<code class="codeph">DELETE_OPTION</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DELETE_RESTRICT</code> - 如果检测到依赖关系，则引发错误并取消删除。这是默认行为。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DELETE_INVALIDATE</code> - 如果检测到依赖项，则不引发错误。而是将每个依赖项标记为无效。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DELETE_CASCADE</code> - 删除在XML模式注册期间生成的所有类型和默认表。如果存在依赖于存储在默认表以外的表中的XML架构的实例，则引发错误。但是，不要为使用<code class="codeph">ANY_SCHEMA</code>创建的<code class="codeph">XMLType</code>列中存储的任何此类实例引发错误。如果已注册XML模式以用于二进制XML，请不要将其从<code class="codeph">DBA_XML_SCHEMAS</code>删除。</p>
                        </li>
                        <li>
                           <p><code class="codeph">DELETE_CASCADE_FORCE</code> - 删除在XML模式注册期间生成的所有类型和默认表。如果存在依赖于存储在默认表以外的表中的XML模式的实例，请不要引发错误。而是将每个依赖项标记为无效。从<code class="codeph">DBA_XML_SCHEMAS</code>删除XML架构。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F__GUID-32452F70-71C2-48A7-BBDF-532A2D7A3EE3">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/DBMS_XMLSCHEMA.html#ARPLS377" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <p><a href="XML-Schema-and-query-basic.html#GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F__CHDICCDF">例17-5</a>说明了<code class="codeph">DELETE_CASCADE_FORCE</code>的使用。</p>
                     <p>如果注册了XML模式以用于二进制XML，则在使用选项<code class="codeph">DELETE_RESTRICT</code> （默认值）或<code class="codeph">DELETE_CASCADE</code>删除它时，不会从<code class="codeph">DBA_XML_SCHEMAS</code>删除它。因此，尽管您不能再使用XML模式对新的XML实例文档进行编码，但Oracle XML DB中引用XML模式的任何现有文档仍然可以使用它进行<span class="italic">解码</span> 。
                     </p>
                     <p>在使用<code class="codeph">DBMS_XMLSCHEMA.</code>从<code class="codeph">DBA_XML_SCHEMAS</code>删除XML架构之前，情况仍然如此<code class="codeph">DBMS_XMLSCHEMA.</code> <span class="bold"><code class="codeph">purgeSchema</code></span> 。Oracle建议您通常使用<code class="codeph">delete_restrict</code>或<code class="codeph">delete_cascade</code> 。当您确定不再需要XML架构时，请调用<code class="codeph">DBMS_XMLSCHEMA.purgeSchema</code> ，而不是使用<code class="codeph">DELETE_CASCADE_FORCE</code> 。
                     </p>
                     <p>过程<code class="codeph">purgeSchema</code>从Oracle XML DB中完全删除XML模式。特别是，它将其从<code class="codeph">DBA_XML_SCHEMAS</code>删除。在使用<code class="codeph">DBMS_XMLSCHEMA.purgeSchema</code>之前，请确保已转换所有引用要清除的XML模式的现有XML文档，因此它们引用不同的XML模式或不引用XML模式。否则，在清除后将无法解码它们。
                     </p>
                     <div class="example" id="GUID-96A06AFE-40DA-4544-A38B-C4577FD4762F__CHDICCDF">
                        <p class="titleinexample">示例17-5使用DBMS_XMLSCHEMA.DELETESCHEMA删除XML架构</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.deleteSchema（SCHEMAURL =&gt;'http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd'，DELETE_OPTION <span class="bold">=&gt; DBMS_XMLSCHEMA.DELETE_CASCADE_FORCE</span> ）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4471"></a><a id="ADXDB4470"></a><div class="props_rev_3"><a id="GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9" name="GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9"></a><h4 id="ADXDB-GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9" class="sect4"><span class="enumeration_section">17.3.9</span>列出所有已注册的XML模式</h4>
                  <div>
                     <p>示例列出了向Oracle XML DB注册的所有XML模式。</p>
                     <div class="section">
                        <p><a href="XML-Schema-and-query-basic.html#GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9__CHDHHBEB">例17-6</a>显示了如何使用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>来获取使用Oracle XML DB注册的所有XML模式的列表。您还可以检查视图<code class="codeph">USER_XML_SCHEMAS</code> ， <code class="codeph">ALL_XML_SCHEMAS</code> ， <code class="codeph">USER_XML_TABLES</code>和<code class="codeph">ALL_XML_TABLES</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1ADDD9A7-5636-4587-AF9D-255790EA1BF9__CHDHHBEB">
                        <p class="titleinexample">例17-6注册模式的数据字典表</p><pre class="pre codeblock"><code>DESCRIBE DBA_XML_SCHEMAS名称是否为空？类型------------ ----- ----------------------- OWNER VARCHAR2（30）SCHEMA_URL VARCHAR2（700） ）LOCAL VARCHAR2（3）SCHEMA XMLTYPE（XMLSchema“http://xmlns.oracle.com/xdb/XDBSchema.xsd”元素“模式”）INT_OBJNAME VARCHAR2（4000）QUAL_SCHEMA_URL VARCHAR2（767）HIER_TYPE VARCHAR2（11）BINARY VARCHAR2（ 3）SCHEMA_ID RAW（16）HIDDEN VARCHAR2（3）从DBA_XML_SCHEMAS中选择所有者，本地，SCHEMA_URL; OWNER LOC SCHEMA_URL ----- --- ---------------------- XDB NO http://xmlns.oracle.com/xdb/XDBSchema.xsd XDB NO http://xmlns.oracle.com/xdb/XDBResource.xsd XDB NO http://xmlns.oracle.com/xdb/acl.xsd XDB NO http://xmlns.oracle.com/xdb/dav。 xsd XDB NO http://xmlns.oracle.com/xdb/XDBStandard.xsd XDB NO http://www.w3.org/2001/xml.xsd XDB NO http://xmlns.oracle.com/xdb/stats .xsd XDB NO http://xmlns.oracle.com/xdb/xdbconfig.xsd SCOTT YES http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd选择了13行。DESCRIBE DBA_XML_TABLES名称是否为空？键入------------ ----- ----------------------- OWNER VARCHAR2（30）TABLE_NAME VARCHAR2（30 ）XMLSCHEMA VARCHAR2（700）SCHEMA_OWNER VARCHAR2（30）ELEMENT_NAME VARCHAR2（2000）STORAGE_TYPE VARCHAR2（17）ANYSCHEMA VARCHAR2（3）NONSCHEMA VARCHAR2（3）SELECT TABLE_NAME FROM DBA_XML_TABLES WHERE XMLSCHEMA ='http：//xmlns.oracle.com/xdb /documentation/purchaseOrder.xsd'; TABLE_NAME --------------------- PurchaseOrder1669_TAB选择了1行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-E27F30C8-3081-403B-B75C-4A84C3F256EF" title="在Oracle XML DB可以使用XML模式之前，您必须注册它。然后，它可用于创建XMLType表和列以及验证XML文档。如果模式注册失败，则数据库将恢复到注册尝试之前的状态。">使用Oracle XML DB进行XML模式注册</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4501"></a><a id="ADXDB4502"></a><a id="ADXDB4503"></a><a id="ADXDB4504"></a><a id="ADXDB4505"></a><a id="ADXDB4500"></a><div class="props_rev_3"><a id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5" name="GUID-A7862EBA-F10A-43BA-A540-933529E514E5"></a><h3 id="ADXDB-GUID-A7862EBA-F10A-43BA-A540-933529E514E5" class="sect3"><span class="enumeration_section">17.4</span>基于XML模式创建XMLType表和列</h3>
               <div>
                  <p>您可以创建受XML架构定义的全局元素约束的<code class="codeph">XMLType</code>表和列。在<code class="codeph">XMLType</code>列被约束到特定元素和特定模式之后，它只能包含符合该元素的模式定义的文档。
                  </p>
                  <p>通过向<code class="codeph">CREATE TABLE</code>操作添加适当的<code class="codeph">XMLSCHEMA</code>和<code class="codeph">ELEMENT</code>子句，可以将<code class="codeph">XMLType</code>表列限制为特定元素和XML模式。
                  </p>
                  <p>图<a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5__I1044839">17-3</a>到<a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5__BJFBIIIA">图17-6</a>显示了创建<code class="codeph">XMLType</code>表的语法。
                  </p>
                  <div class="infoboxnotealso" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__GUID-179239AF-6B31-4345-8E1B-E6F9874A5804">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">CREATE TABLE</code>的完整描述的<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，包括<code class="codeph">object_properties</code>等语法元素。
                     </p>
                  </div>
                  <div class="infoboxnote" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__GUID-21C67238-CA2E-4281-8372-E2A71ACFAA58">
                     <p class="notep1">注意：</p>
                     <p>要在与您自己不同的数据库模式中创建<code class="codeph">XMLType</code>表，您不仅必须具有<code class="codeph">CREATE ANY TABLE</code>权限，还必须具有<code class="codeph">CREATE ANY INDEX</code>权限。这是因为在创建表时，会在列<code class="codeph">OBJECT_ID</code>上创建唯一索引。列<code class="codeph">OBJECT_ID</code>存储系统生成的对象标识符。
                     </p>
                  </div>
                  <div class="figure" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__I1044839">
                     <p class="titleinfigure">图17-3创建XMLType表 -  CREATE TABLE语法</p><img src="img/create_table.gif" width="503" alt="下面是图17-3的描述" title="下面是图17-3的描述" longdesc="img_text/create_table.html"><br><a href="img_text/create_table.html">“图17-3创建XMLType表 -  CREATE TABLE语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__GUID-4F16853D-8E1A-42F6-8C48-6DAE2556EE32">
                     <p class="titleinfigure">图17-4创建XMLType表 -  XMLType_table语法</p><img src="img/xmltype_table.gif" width="590" alt="下面是图17-4的描述" title="下面是图17-4的描述" longdesc="img_text/xmltype_table.html"><br><a href="img_text/xmltype_table.html">“图17-4创建XMLType表 -  XMLType_table语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__GUID-D526D23F-ABB1-48C1-9159-CAB83E16EFE4">
                     <p class="titleinfigure">图17-5创建XMLType表 -  table_properties语法</p><img src="img/table_properties.gif" width="615" alt="下面是图17-5的描述" title="下面是图17-5的描述" longdesc="img_text/table_properties.html"><br><a href="img_text/table_properties.html">“图17-5创建XMLType表 -  table_properties语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__BJFBIIIA">
                     <p class="titleinfigure">图17-6创建XMLType表 -  XMLType_virtual_columns语法</p><img src="img/xmltype_virtual_columns.gif" width="371" alt="下面是图17-6的描述" title="下面是图17-6的描述" longdesc="img_text/xmltype_virtual_columns.html"><br><a href="img_text/xmltype_virtual_columns.html">“图17-6创建XMLType表 -  XMLType_virtual_columns语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnote" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__GUID-284E475A-1C17-4CA3-9765-DA471A56F9D3">
                     <p class="notep1">注意：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>子句<code class="codeph">XMLType_virtual_columns</code>仅可用于存储为<span class="italic">二进制XML的</span> <code class="codeph">XMLType</code>数据。特别是，如果将它用于以对象关系存储的数据，并且使用分区子句，则会引发错误。
                           </p>
                        </li>
                        <li>
                           <p>对于XML数据，虚拟列主要用于分区或定义SQL约束。如果您需要投射出特定的XML数据以便以关系方式访问它，那么请考虑将SQL / XML函数<code class="codeph">XMLTable</code>或<code class="codeph">XMLIndex</code>与结构化组件一起使用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>XPointer表示法的子集也可用于提供包含XML架构位置和元素名称的单个URL。另请参阅<a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a> 。
                  </p>
                  <p><a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5__CHDDJDBD">例17-7</a>显示了两个<code class="codeph">CREATE TABLE</code>语句。第一个创建<code class="codeph">XMLType</code>表<code class="codeph">purchaseorder_as_table</code> 。第二个创建关系表<code class="codeph">purchaseorder_as_column</code> ，它具有<code class="codeph">XMLType</code>列<code class="codeph">xml_document</code> 。在每个表中， <code class="codeph">XMLType</code>实例都受限于<code class="codeph">PurchaseOrder</code>元素，该元素由URL <code class="codeph">http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</code>注册的XML模式定义。</p>
                  <p>有两种方法可以指定<code class="codeph">XMLSchema</code>和<code class="codeph">Element</code> ：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>作为单独的子句， <code class="codeph">XMLSchema</code>和<code class="codeph">Element</code></p>
                     </li>
                     <li>
                        <p>仅使用带有XPointer表示法的<code class="codeph">Element</code>子句</p>
                     </li>
                  </ul>
                  <p>与<code class="codeph">XMLType</code>表或列相关联的数据受限于XML模式，可以以不同方式存储：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分解并存储对象关系</p>
                     </li>
                     <li>
                        <p>使用单个二进制XML列存储为二进制XML</p>
                     </li>
                  </ul>
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-A7862EBA-F10A-43BA-A540-933529E514E5__CHDDJDBD">
                     <p class="titleinexample">示例17-7创建基于XML模式的XMLType表和列</p><pre class="pre codeblock"><code>CREATE TABLE purchaseorder_as_table <span class="bold">OF XMLType</span> XMLSCHEMA“http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd”ELEMENT“PurchaseOrder”; CREATE TABLE purchaseorder_as_column（id NUMBER，xml_document <span class="bold">XMLType</span> ）XMLTYPE COLUMN xml_document ELEMENT“http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd#PurchaseOrder”;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5">基于XML模式的数据的XMLType存储选项规范</a><br>您可以指定在手动创建存储引用XML架构的XML实例文档的表时使用的存储选项。要指定特定的<code class="codeph">XMLType</code>存储模型，请在<code class="codeph">CREATE TABLE</code>语句中使用<code class="codeph">STORE AS</code>子句。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" title="您只能为存储为二进制XML的XMLType数据创建虚拟列。这些列可用于分区或约束数据。">在存储为二进制XML的XMLType数据上创建虚拟列</a></li>
                        <li><a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="您可以使用SQL / XML函数XMLTable将XQuery表达式求值的结果分解为新虚拟表的关系行和列。您可以将此数据插入到预先存在的数据库表中，也可以使用SQL在连接表达式中查询它。">Oracle XML DB中的XMLTABLE SQL / XML函数</a></li>
                        <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="您可以为XML内容的固定结构化岛屿项目的查询创建和使用XMLIndex索引的结构化组件，即使周围数据相对非结构化也是如此。">XMLIndex结构化组件</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4506"></a><div class="props_rev_3"><a id="GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5" name="GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5"></a><h4 id="ADXDB-GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5" class="sect4"><span class="enumeration_section">17.4.1</span>基于XML模式的数据的XMLType存储选项的规范</h4>
                  <div>
                     <p>您可以指定在手动创建存储引用XML架构的XML实例文档的表时使用的存储选项。要指定特定的<code class="codeph">XMLType</code>存储模型，请在<code class="codeph">CREATE TABLE</code>语句中使用<code class="codeph">STORE AS</code>子句。
                     </p>
                     <p>否则，将使用在注册XML模式期间指定的存储模型。如果在注册期间未指定存储模型，则使用对象关系存储。</p>
                     <p>除了为基于XML模式的数据指定存储选项外，还可以使用XML模式注释为自动创建的表指定存储选项。</p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E">基于XML模式的数据的二进制XML存储</a><br>如果指定<code class="codeph">STORE AS BINARY_XML</code>则使用二进制XML存储。如果指定文档必须符合的XML模式，则只能使用该模式创建存储为二进制XML的<code class="codeph">XMLType</code>表和列。</li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3">基于XML模式的数据的对象关系存储</a><br>注册XML模式后，您可以为符合该模式的文档创建对象关系<code class="codeph">XMLType</code>表或列。您可以选择为表或列指定对象关系存储选项。
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML Schema Annotations</a></li>
                           <li><a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="应用程序的重要设计选择包括要使用的XMLType存储模型以及要使用的索引方法。">选择XMLType存储和索引</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5" title="您可以创建受XML架构定义的全局元素约束的XMLType表和列。在XMLType列被约束到特定元素和特定模式之后，它只能包含符合该元素的模式定义的文档。">基于XML模式创建XMLType表和列</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4508"></a><a id="ADXDB4507"></a><div class="props_rev_3"><a id="GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E" name="GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E"></a><h5 id="ADXDB-GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E" class="sect5"><span class="enumeration_section">17.4.1.1</span>基于XML模式的数据的二进制XML存储</h5>
                     <div>
                        <p>如果指定<code class="codeph">STORE AS BINARY_XML</code>则使用二进制XML存储。如果指定文档必须符合的XML模式，则只能使用该模式创建存储为二进制XML的<code class="codeph">XMLType</code>表和列。</p>
                        <p>您<span class="italic">不能</span>使用相同的XML模式来创建以对象关系存储的<code class="codeph">XMLType</code>表和列。
                        </p>
                        <p>反过来也是如此：如果对已注册的XML模式使用对象关系存储，则只能使用该XML模式来创建存储为二进制XML的<code class="codeph">XMLType</code>表和列。</p>
                        <p>二进制XML存储为XML数据提供了极大的灵活性，尤其是关于XML模式的使用。二进制XML以不同的方式对XML数据进行编码，具体取决于XML模式是否用于编码，并且它可以使用不同的XML模式对不同的数据进行不同的编码。</p>
                        <p>当编写XML模式以编码二进制XML数据时，XML模式数据类型将映射到编码类型以进行存储。或者，您可以将XML数据编码为非基于模式的二进制XML，无论数据是否引用XML模式。在这种情况下，将忽略任何引用的XML模式，并且不存在XML模式数据类型的编码。</p>
                        <p>创建<code class="codeph">XMLType</code>表或列并使用二进制XML存储时，可以指定如何对列或表进行编码以使用XML模式。从以下可能性中进行选择：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将列或表数据编码<span class="italic">为非基于模式的</span>二进制XML。存储在列中的XML数据仍然可以符合XML模式，但它不需要。出于编码目的，将忽略任何引用的XML模式，并且在插入或更新文档时不会自动验证文档。
                              </p>
                              <p>但是，您可以显式验证基于XML模式的文档，该文档被编码为非基于模式的二进制XML。这代表了一个重要的用例：您不希望将文档与特定XML模式过于紧密地绑定，因为您可能会更改或删除它。</p>
                           </li>
                           <li>
                              <p>对列或表数据进行编码以符合<span class="italic">单个XML模式</span> 。所有行（文档）必须符合相同的XML模式。但是，您可以指定非基于模式的文档也可以存储在同一列中。
                              </p>
                           </li>
                           <li>
                              <p>对列或表数据进行编码以符合它引用的任何XML模式每行（文档）都可以引用<span class="italic">任何XML模式</span> ，并且该XML模式用于编码该特定XML文档。在这种情况下，您也可以指定非基于模式的文档也可以存储在同一列中。
                              </p>
                              <p>您可以通过这种方式使用同一XML模式的多个<span class="italic">版本</span> 。存储符合不同版本的文档。每个都根据它引用的XML模式进行编码。
                              </p>
                           </li>
                        </ul>
                        <p>您可以在创建表时使用选项<code class="codeph">ALLOW ANYSCHEMA</code>指定任何XML架构可用于编码。
                        </p>
                        <div class="infoboxnote" id="GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E__GUID-AAE3334F-4802-4E24-A26B-3BF67F6EEA61">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果使用选项<code class="codeph">ALLOW ANYSCHEMA</code> ，则实例文档引用的任何XML模式<span class="italic">仅用于验证</span> 。它<span class="italic">不在</span>查询时使用。对数据的查询将其视为非基于XML架构的数据。
                                 </p>
                              </li>
                              <li>
                                 <p>Oracle建议您<span class="italic">不要</span>使用选项<code class="codeph">ALLOW ANYSCHEMA</code>如果预计使用基于复制的XML模式演变（参见<a href="XML-Schema-evolution.html#GUID-0E4FC235-D8D1-4F27-85DC-A3DCCC2662AB" title="您使用PL / SQL过程DBMS_XMLSCHEMA.copyEvolve执行基于副本的XML模式演变。这会将现有实例文档备份到临时XMLType表，删除旧版本的XML架构（也会删除关联的实例文档），注册新版本，并将备份的实例文档复制到新的XMLType表。">复制为基础的架构演进</a> ）。如果使用此选项，则无法确定哪些行（文档）可能符合演进的XML架构。在基于副本的演化过程中，不会转换符合行，之后它们不可解码。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>对于使用基于XML模式的编码的表和列，您可以使用选项<code class="codeph">ALLOW NONSCHEMA</code>指定它们也可以接受非基于模式的文档。在没有关键字<code class="codeph">XMLSCHEMA</code>的情况下，编码用于非基于模式的文档。如果没有关键字<code class="codeph">ALLOW NONSCHEMA</code>但存在关键字<code class="codeph">XMLSCHEMA</code> ，则编码适用于指定的单个XML模式。如果没有关键字<code class="codeph">ALLOW NONSCHEMA</code>但存在关键字<code class="codeph">ALLOW ANYSCHEMA</code> ，则编码适用于所引用的任何XML架构。
                        </p>
                        <p>如果您尝试将XML文档插入到与该文档不对应的<code class="codeph">XMLType</code>表或列中，则会引发错误。
                        </p>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E__CHDIAFJH" title="此表总结了二进制XML的CREATE TABLE编码选项。">表17-2</a>总结了各种可能性。
                        </p>
                        <div class="tblformal" id="GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E__CHDIAFJH">
                           <p class="titleintable">表17-2二进制XML的CREATE TABLE编码选项</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="用于二进制XML的CREATE TABLE编码选项" width="100%" border="1" summary="This table summarizes the CREATE TABLE Encoding Options for Binary XML." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d81865e3248">存储选项</th>
                                    <th align="left" valign="bottom" width="75%" id="d81865e3251">编码效果</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d81865e3256" headers="d81865e3248 "><pre class="oac_no_warn" dir="ltr">存储为二进制XML</pre></td>
                                    <td align="left" valign="top" width="75%" headers="d81865e3256 d81865e3251 ">
                                       <p>使用非基于模式的编码对所有文档进行编码。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d81865e3263" headers="d81865e3248 "><pre class="oac_no_warn" dir="ltr">存储为二进制XML XMLSCHEMA ...</pre></td>
                                    <td align="left" valign="top" width="75%" headers="d81865e3263 d81865e3251 ">
                                       <p>使用基于引用的XML模式的编码对所有文档进行编码。</p>
                                       <p>尝试插入或更新不符合XML架构的文档会引发错误。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d81865e3272" headers="d81865e3248 "><pre class="oac_no_warn" dir="ltr">存储为二进制XML XMLSCHEMA ...允许NONSCHEMA</pre></td>
                                    <td align="left" valign="top" width="75%" headers="d81865e3272 d81865e3251 ">
                                       <p>使用基于引用的XML模式的编码对所有基于XML模式的文档进行编码。使用非基于模式的编码对所有非基于模式的文档进行编码。</p>
                                       <p>尝试插入或更新不符合引用的XML模式的基于XML模式的文档会引发错误。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d81865e3281" headers="d81865e3248 "><pre class="oac_no_warn" dir="ltr">存储为二进制XML允许ANYSCHEMA</pre></td>
                                    <td align="left" valign="top" width="75%" headers="d81865e3281 d81865e3251 ">
                                       <p>使用基于文档引用的XML模式的编码对所有基于XML模式的文档进行编码。</p>
                                       <p>尝试插入或更新未引用已注册XML模式的文档或不符合其引用的XML模式的文档会引发错误。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d81865e3290" headers="d81865e3248 "><pre class="oac_no_warn" dir="ltr">存储为二进制XML允许ANYSCHEMA允许NONSCHEMA</pre></td>
                                    <td align="left" valign="top" width="75%" headers="d81865e3290 d81865e3251 ">
                                       <p>使用基于文档引用的XML模式的编码对所有基于XML模式的文档进行编码。使用非基于模式的编码对所有非基于模式的文档进行编码。</p>
                                       <p>尝试插入或更新不符合其引用的已注册XML模式的基于XML模式的文档会引发错误。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnote" id="GUID-E7AB5A1F-FAAC-4463-8491-74992E49FA8E__GUID-917ECA57-9353-4220-B942-A4F730E45354">
                           <p class="notep1">注意：</p>
                           <p>如果您使用带有<code class="codeph">ALLOW NONSCHEMA</code>但不允许<code class="codeph">ALLOW ANYSCHEMA</code> <code class="codeph">CREATE TABLE</code> ，则所有文档（甚至基于XML模式的文档）都使用非基于模式的编码进行编码。如果稍后在同一个表上使用<code class="codeph">ALTER TABLE</code>和<code class="codeph">ALLOW ANYSCHEMA</code> ，这对<code class="codeph">ALTER TABLE</code>操作之前存储的文档的编码没有影响 - 所有这些文档继续使用非基于模式的编码进行编码，无论如何他们是否引用XML模式。只有在<code class="codeph">ALTER TABLE</code>操作之后插入表中的基于XML模式的文档才会使用基于XML模式的编码进行编码。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5" title="您可以指定在手动创建存储引用XML架构的XML实例文档的表时使用的存储选项。要指定特定的XMLType存储模型，请在CREATE TABLE语句中使用STORE AS子句。">基于XML模式的数据的XMLType存储选项的规范</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6366"></a><a id="ADXDB4512"></a><a id="ADXDB5836"></a><a id="ADXDB4511"></a><div class="props_rev_3"><a id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3" name="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3"></a><h5 id="ADXDB-GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3" class="sect5"><span class="enumeration_section">17.4.1.2</span>基于XML模式的数据的对象关系存储</h5>
                     <div>
                        <p>注册XML模式后，您可以为符合该模式的文档创建对象关系<code class="codeph">XMLType</code>表或列。您可以选择为表或列指定对象关系存储选项。
                        </p>
                        <p>假设您已注册采购订单XML架构，由URL <code class="codeph">http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd</code>标识。然后，创建一个对象关系<code class="codeph">XMLType</code>表<code class="codeph">purchaseorder_as_table</code> ，以存储符合XML模式的元素<code class="codeph">PurchaseOrder</code>的实例，如<a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__CEGBEEAJ">例17-8所示</a> 。
                        </p>
                        <p>这会自动创建与<code class="codeph">PurchaseOrder</code>元素已映射到的数据库对象类型相对应的隐藏列。此外， <code class="codeph">XMLEXTRA</code>创建一个<code class="codeph">XMLEXTRA</code>对象列，以存储顶级实例数据，例如命名空间声明。<code class="codeph">XMLEXTRA</code>保留供内部使用。
                        </p>
                        <p>假设XML模式<code class="codeph">purchaseOrder.xsd</code>将元素<code class="codeph">LineItems</code>定义为元素<code class="codeph">PurchaseOrder</code>的子元素，并且<code class="codeph">LineItems</code>是<code class="codeph">LineItem</code>元素的集合。
                        </p>
                        <p>使用对象关系存储，集合将映射到SQL varray值。XML <strong class="term">集合</strong>是由XML模式定义的任何元素， <code class="codeph">maxOccurs</code> &gt; 1，允许它多次出现。默认情况下，此类varray的全部内容将作为一组行存储在有序集合表（OCT）中。
                        </p>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__BJFGGABH">例17-9</a>创建表<code class="codeph">purchaseorder_as_table</code>与<a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__CEGBEEAJ">例17-8</a>不同。它指定了其他存储选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">LineItems</code>集合varray存储为LOB，而不是表。
                              </p>
                           </li>
                           <li>
                              <p>表空间<code class="codeph">USERS</code>用于存储元素<code class="codeph">Notes</code> 。
                              </p>
                           </li>
                           <li>
                              <p>该表被压缩用于在线事务处理（OLTP）。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__GUID-3E56EFF6-C688-4006-ACE1-1AAF246CFB65">
                           <p class="notep1">注意：</p>
                           <p>在Oracle Database 11gR2之前的版本中， <code class="codeph">CREATE TABLE</code>的默认行为是使用存储为LOB的varray存储集合，而不是存储为表的varray。
                           </p>
                        </div>
                        <div class="infoboxnote" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__GUID-CFA51E25-D881-4D87-B2C4-C1858A2464B5">
                           <p class="notep1">注意：</p>
                           <p>为父<code class="codeph">XMLType</code>表或列指定压缩时，所有后代<code class="codeph">XMLType</code>有序集合表（OCT）都被类似地压缩。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__GUID-621B91CD-3705-4F32-A653-5664F1A6599D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关使用XML架构注释指定存储选项的信息，请参阅<a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML Schema Annotations</a></p>
                              </li>
                              <li>
                                 <p>有关OLTP压缩的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF54484" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                        <p>为方便起见，如果您需要指定将<code class="codeph">XMLType</code>表或列中的<span class="italic">所有</span> varrays存储为LOB，或者将<span class="italic">所有</span> varrays存储为表，则可以使用语法子句<code class="codeph">STORE ALL VARRAYS AS</code> ，然后使用<code class="codeph">LOBS</code>或<code class="codeph">TABLES</code>分别为。这是使用多个<code class="codeph">VARRAY</code>的便捷替代方案......<code class="codeph">STORE AS</code>条款，每个集合一个。<a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__BJFCHIJH">例17-10</a>说明了这一点。
                        </p>
                        <div class="infoboxnotealso" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__GUID-60A4936D-FC4F-45FC-8054-B92A59E39C37">
                           <p class="notep1">也可以看看：</p>
                           <p>有关使用<code class="codeph">STORE ALL VARRAYS AS LOBS</code>信息，请参阅<a href="../sqlrf/CREATE-TABLE.html#SQLRF01709" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                        </div>
                        <div class="example" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__CEGBEEAJ">
                           <p class="titleinexample">示例17-8使用默认存储创建对象关系XMLType表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE purchaseorder_as_table OF XMLType ELEMENT“http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd#PurchaseOrder”;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__BJFGGABH">
                           <p class="titleinexample">示例17-9为XMLType表和列指定对象关系存储选项</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE purchaseorder_as_table OF XMLType（UNIQUE（“XMLDATA”。“Reference”），FOREIGN KEY（“XMLDATA”。“User”）REFERENCES hr.employees（email））ELEMENT“http://xmlns.oracle.com/xdb/ documentation / purchaseOrder.xsd＃PurchaseOrder“ <span class="bold">VARRAY</span> ”XMLDATA“。”LineItems“。”LineItem“ <span class="bold">STORE AS LOB</span> lineitem_lob <span class="bold">LOB</span> （”XMLDATA“。” <span class="bold">Notes</span> “） <span class="bold">STORE AS</span> （TABLESPACE <span class="bold">用户</span>在行存储中启用存储（初始4K下一个32K） ） <span class="bold">COMPRESS FOR OLTP</span> ; CREATE TABLE purchaseorder_as_column（id NUMBER，xml_document XMLType，UNIQUE（xml_document。“XMLDATA”。“Reference”），FOREIGN KEY（xml_document。“XMLDATA”。“User”）REFERENCES hr.employees（email））XMLTYPE COLUMN xml_document XMLSCHEMA“http ：//xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd“ELEMENT”PurchaseOrder“ <span class="bold">VARRAY</span> xml_document。”XMLDATA“。”LineItems“。”LineItem“ <span class="bold">STORE AS LOB</span> lineitem_lob <span class="bold">LOB</span> （xml_document。”XMLDATA“。” <span class="bold">Notes</span> “ <span class="bold">存储为</span> （TABLESPACE <span class="bold">用户</span>在行存储中启用存储（初始4K下一个32K）） <span class="bold">COMPRESS for OLTP</span> ;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__BJFCHIJH">
                           <p class="titleinexample">示例17-10使用STORE ALL VARRAYS AS</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE purchaseorder_as_table OF XMLType（UNIQUE（“XMLDATA”。“Reference”），FOREIGN KEY（“XMLDATA”。“User”）REFERENCES hr.employees（email））ELEMENT“http://xmlns.oracle.com/xdb/ documentation / purchaseOrder.xsd＃PurchaseOrder“ <span class="bold">STORE ALL VARRAYS AS LOBS</span> ;</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-CF8A4404-C51C-40D4-A4EE-D53DADBD63D5" title="您可以指定在手动创建存储引用XML架构的XML实例文档的表时使用的存储选项。要指定特定的XMLType存储模型，请在CREATE TABLE语句中使用STORE AS子句。">基于XML模式的数据的XMLType存储选项的规范</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4098"></a><div class="props_rev_3"><a id="GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6" name="GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6"></a><h3 id="ADXDB-GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6" class="sect3"><span class="enumeration_section">17.5</span>识别XML模式实例文档的方法</h3>
               <div>
                  <p>在将XML文档插入基于XML模式的<code class="codeph">XMLType</code>表或列之前，必须标识关联的XML模式。您可以在创建表或列时执行此操作，也可以使用<code class="codeph">XMLSchema-instance</code>将所需的模式标识显式添加到XML实例文档中。
                  </p>
                  <p>要在创建<code class="codeph">XMLType</code>表或列时显式标识XML模式，可以将XML模式的名称传递给<code class="codeph">XMLType</code>构造函数，也可以调用<code class="codeph">XMLType</code>方法<code class="codeph">createSchemaBasedXML()</code> 。
                  </p>
                  <p><code class="codeph">XMLSchema-instance</code>机制的优点是它允许Oracle XML DB协议服务器识别插入Oracle XML DB Repository的XML文档是已注册XML模式的实例。实例文档的内容自动存储在该XML模式指定的默认表中。
                  </p>
                  <p><code class="codeph">XMLSchema-instance</code>机制由W3C XML Schema工作组定义。它基于将标识目标XML模式的属性添加到实例文档的根元素。这些属性由<code class="codeph">XMLSchema-instance</code>名称空间定义。
                  </p>
                  <p>要将实例文档标识为由特定XML模式定义的类的成员，必须通过向实例文档的根元素添加名称空间声明来声明<code class="codeph">XMLSchema-instance</code>名称空间。例如：</p>
                  <p><code class="codeph">xmlns：xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
                  <p>一旦声明了<code class="codeph">XMLSchema-instance</code>名称空间并给出了<code class="codeph">namespace</code>前缀，就可以将标识XML模式的属性添加到实例文档的根元素中。在前面的示例中， <code class="codeph">XMLSchema-instance</code>命名空间的名称空间前缀定义为<code class="codeph">xsi</code> 。然后，可以在将<code class="codeph">XMLSchema-instance</code>属性添加到实例文档的根元素时使用此前缀。
                  </p>
                  <p>必须添加哪些属性取决于几个因素。有两种可能性， <code class="codeph">noNamespaceSchemaLocation</code>和<code class="codeph">schemaLocation</code> 。根据XML模式，需要这些属性中的一个或两个来标识与实例文档关联的XML模式。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-167BD6E7-2628-4A7E-B4B9-D843CFF5F055">属性noNamespaceSchemaLocation和schemaLocation</a><br>如果目标XML模式未声明目标名称空间，则使用属性<code class="codeph">noNamespaceSchemaLocation</code>标识XML模式。属性值是<span class="italic">架构位置提示</span> 。这是在向数据库注册XML模式时传递给PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>的唯一标识符。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-basic.html#GUID-75D23190-524F-4A39-BC6E-F7D4C6F3FD66">XML模式和多个命名空间</a><br>当XML模式包含在多个名称空间中定义的元素时，必须在每个XML模式的<code class="codeph">schemaLocation</code>属性中出现一个条目。每个条目都包含名称空间声明和<span class="italic">模式位置提示</span> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4099"></a><div class="props_rev_3"><a id="GUID-167BD6E7-2628-4A7E-B4B9-D843CFF5F055" name="GUID-167BD6E7-2628-4A7E-B4B9-D843CFF5F055"></a><h4 id="ADXDB-GUID-167BD6E7-2628-4A7E-B4B9-D843CFF5F055" class="sect4"><span class="enumeration_section">17.5.1</span>属性noNamespaceSchemaLocation和schemaLocation</h4>
                  <div>
                     <p>如果目标XML模式未声明目标名称空间，则使用属性<code class="codeph">noNamespaceSchemaLocation</code>标识XML模式。属性值是<span class="italic">架构位置提示</span> 。这是在向数据库注册XML模式时传递给PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>的唯一标识符。
                     </p>
                     <p>对于XML模式<code class="codeph">purchaseOrder.xsd</code> ，实例文档的根元素的正确定义如下所示：</p><pre class="pre codeblock"><code>&lt;PurchaseOrder xmlns：xsi = http：//www.w3.org/2001/XMLSchema-instance xsi：noNamespaceSchemaLocation =“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”&gt;</code></pre><p>如果目标XML模式声明了目标名称空间，则<code class="codeph">schemaLocation</code>属性用于标识XML模式。此属性的值是由空格分隔的一对值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML架构中声明的<span class="italic">目标命名空间</span>的值</p>
                        </li>
                        <li>
                           <p><span class="italic">架构位置提示</span> ，在向数据库注册架构时传递给过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>的唯一标识符</p>
                        </li>
                     </ul>
                     <p>例如，假设<code class="codeph">PurchaseOrder</code> XML模式包含目标名称空间声明。架构的根元素如下所示：</p><pre class="pre codeblock"><code>&lt;xs：schema <span class="bold">targetNamespace =“http://demo.oracle.com/xdb/purchaseOrder”</span> xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http：// xmlns .oracle.com / xdb“version =”1.0“&gt; &lt;xs：element name =”PurchaseOrder“type =”PurchaseOrderType“xdb：defaultTable =”PURCHASEORDER“/&gt;</code></pre><p>在这种情况下，实例文档的根元素的正确形式如下所示：</p><pre class="pre codeblock"><code>&lt;PurchaseOrder xnlns =“http://demo.oracle.com/xdb/purchaseOrder”xmlns：xsi = http：//www.w3.org/2001/XMLSchema-instance <span class="bold">xsi：schemaLocation =</span> “ <span class="bold">http://demo.oracle .com / xdb / purchaseOrder</span> <span class="bold">http：// mdrake-lap：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd</span> “&gt;</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6" title="在将XML文档插入基于XML模式的XMLType表或列之前，必须标识关联的XML模式。您可以在创建表或列时执行此操作，也可以使用XMLSchema-instance将所需的模式标识显式添加到XML实例文档中。">识别XML模式实例文档的方法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4100"></a><div class="props_rev_3"><a id="GUID-75D23190-524F-4A39-BC6E-F7D4C6F3FD66" name="GUID-75D23190-524F-4A39-BC6E-F7D4C6F3FD66"></a><h4 id="ADXDB-GUID-75D23190-524F-4A39-BC6E-F7D4C6F3FD66" class="sect4"><span class="enumeration_section">17.5.2</span> XML模式和多个命名空间</h4>
                  <div>
                     <p>当XML模式包含在多个名称空间中定义的元素时，必须在每个XML模式的<code class="codeph">schemaLocation</code>属性中出现一个条目。每个条目都包含名称空间声明和<span class="italic">模式位置提示</span> 。
                     </p>
                     <p>条目通过一个或多个空格字符彼此分开。</p>
                     <p>如果主XML模式未声明目标名称空间，则XML实例文档还需要包含<code class="codeph">noNamespaceSchemaLocation</code>属性，该属性提供主XML模式的<span class="italic">模式位置提示</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-43D926FC-083A-4CBB-8B3A-A157462D51F6" title="在将XML文档插入基于XML模式的XMLType表或列之前，必须标识关联的XML模式。您可以在创建表或列时执行此操作，也可以使用XMLSchema-instance将所需的模式标识显式添加到XML实例文档中。">识别XML模式实例文档的方法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4526"></a><a id="ADXDB4525"></a><div class="props_rev_3"><a id="GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4" name="GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4"></a><h3 id="ADXDB-GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4" class="sect3"><span class="enumeration_section">17.6</span> XML模式数据类型映射到Oracle XML DB存储</h3>
               <div>
                  <p>符合XML模式的数据使用XML模式数据类型。当此XML数据存储在Oracle XML DB中时，其存储数据类型使用默认映射从XML架构数据类型派生，并且可选地使用您使用XML架构批注指定的映射信息。</p>
                  <p>每当您未指定用于存储的数据类型时，Oracle XML DB都会使用默认映射在注册期间适当地注释XML模式。通过这种方式，已注册的XML模式具有一组完整的数据类型注释。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对于对象关系存储，XML Schema数据类型映射到SQL数据类型。</p>
                     </li>
                     <li>
                        <p>对于二进制XML存储，XML Schema数据类型映射到Oracle XML DB二进制XML编码类型。</p>
                     </li>
                  </ul>
                  <p><a href="XML-Schema-and-query-basic.html#GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4__I1044841">图17-7</a>显示了Oracle XML DB如何使用XML文档和XML模式中指定的映射创建基于XML模式的<code class="codeph">XMLType</code>表。根据XML模式中指定的存储方法，XML实例文档可以作为单个<code class="codeph">XMLType</code>列中的二进制XML值存储，也可以使用多个对象关系列存储。
                  </p>
                  <div class="figure" id="GUID-F5DA0566-E0D0-49C8-A846-1CE5067E15F4__I1044841">
                     <p class="titleinfigure">图17-7 Oracle XML DB如何映射基于XML模式的XMLType表</p><img src="img/adxdb025.png" width="437" alt="下面是图17-7的描述" title="下面是图17-7的描述" longdesc="img_text/adxdb025.html"><br><a href="img_text/adxdb025.html">“图17-7 Oracle XML DB如何映射基于XML模式的XMLType表”</a></div>
                  <!-- class="figure" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML架构数据类型映射到SQL数据类型</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>XMLSpy还支持WebDAV和FTP协议，因此您可以使用它直接访问和编辑存储在Oracle XML DB Repository中的内容。</p><br></div>
      </article>
   </body>
</html><html id="03569.NNO-00050.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>NNO-00050至NNO-00854</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Error Messages"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Error Messages"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-error-messages.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-16T07:32:34-07:00"></meta>
      <meta name="dcterms.title" content="Database Error Messages"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E95938-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="NNL-00001.html" title="Previous" type="text/html"></link>
      <link rel="next" href="NPL-00100.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ERRMG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="NNL-00001.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="NPL-00100.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库错误消息</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">NNO-00050至NNO-00854</li>
            </ol>
            <a id="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA" name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA"></a>
            
            <h2 id="ERRMG-GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA" class="sect2"><span class="enumeration_chapter">60</span> NNO-00050至NNO-00854</h2>
         </header>
         <div class="ind">
            <div>
               <dl>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C545EAD0-CD91-465B-989C-492E05033B7A"><!-- --></a> NNO-00050：配置数据严重错误，服务器无法运行</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置数据存在某种阻止服务器启动的问题。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>日志文件中的先前错误消息将指定导致关闭的确切问题。当网络分解为多个管理区域且委派点不正确时，最常出现此问题。阅读有关区域委派的Oracle Names文档部分，并确保正确遵循其说明。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-51E67CE0-3023-468A-9AD8-25C21F6D03F7"><!-- --></a> NNO-00051：域计数<span class="variable" translate="no">number</span>超过最大的<span class="variable" translate="no">number</span> ，第一<span class="variable" translate="no">number</span>将被加载</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含的域数多于服务器可以支持的域数。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-197DE069-78B9-4153-829C-2D2AD4E2DF05"><!-- --></a> NNO-00052：无效的域名描述列表</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含无效的域描述列表。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D6DF65A8-0D1C-4B39-B0BE-1BF6372DE46F"><!-- --></a> NNO-00053：域“ <span class="variable" translate="no">string</span> ”的重复域描述</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置在域描述列表中包含重复的域描述。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8D544E73-D24A-4CC0-95A9-C4CC6FAB538C"><!-- --></a> NNO-00054：无效的域名“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含具有无效名称的域描述。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-FFA5BD3A-3B57-4967-AC3E-1679A0264FEF"><!-- --></a> NNO-00055：无效域最小TTL“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含具有无效最小TTL的域描述。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6B2F700B-D619-415C-9F91-E03BCD558BE5"><!-- --></a> NNO-00056：警告：域最小TTL必须介于<span class="variable" translate="no">number</span>和<span class="variable" translate="no">number</span>之间，设置为<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含具有无效最小TTL的域描述。这个错误不是致命的;服务器将自动将TTL设置为适合大多数用途的默认值。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-ADE4FA18-0C8B-4524-B49E-387B4F5EF230"><!-- --></a> NNO-00057：加载和验证拓扑数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在正常服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-83215072-E327-4C66-9C22-743093846304"><!-- --></a> NNO-00058：无法从配置数据库加载拓扑数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从配置数据库加载服务器的拓扑数据时遇到错误。如果有更多信息，则会显示此错误。此错误将导致服务器关闭。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F27824E6-BD20-48A0-A6FB-81E2E805E796"><!-- --></a> NNO-00059：无法构造拓扑检查点文件名</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法构造依赖于系统的文件名。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-51579CB0-2A32-43C9-8B17-206315D6EC06"><!-- --></a> NNO-00060：从检查点文件“ <span class="variable" translate="no">string</span> ”加载服务器拓扑</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>通过将names.no_region_database参数设置为TRUE，在强制服务器从其最新拓扑检查点文件加载服务器时，将信息性消息写入日志文件。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-2CF2D417-136B-43B0-9462-ADF35538ACA5"><!-- --></a> NNO-00061：加载域“ <span class="variable" translate="no">string</span> ”的数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在正常服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-4381CC84-6820-4AA9-955D-8847A3F410BC"><!-- --></a> NNO-00062：无法从配置数据库加载域数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从配置数据库加载服务器的域数据时遇到错误。如果有更多信息，则会显示此错误。此错误将导致服务器关闭。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-14DB1929-DA33-4014-9555-8C398523AFAA"><!-- --></a> NNO-00063：无法构造域检查点文件名</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法构造依赖于系统的文件名。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-5BF97FE5-A7A8-43E3-8034-0572EA7CD700"><!-- --></a> NNO-00064：从检查点文件“ <span class="variable" translate="no">string</span> ”加载域数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>通过将names.no_region_database参数设置为TRUE，在强制服务器从其最新的域检查点文件加载时写入日志文件的信息性消息。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-677ADAFD-1FFE-4A0A-9F09-D651D7441B39"><!-- --></a> NNO-00065：从检查点文件“ <span class="variable" translate="no">string</span> ”加载缓存数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在正常服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-CCAD3851-1F44-40F7-96AB-BA3EA13B4E04"><!-- --></a> NNO-00066：服务器将执行行政区域的重新加载检查<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle网络管理器或Oracle Names控制程序向服务器发送重新加载请求，就会将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-A1456C07-3642-4834-A4C9-A9C224B1A8CC"><!-- --></a> NNO-00067：服务器重新加载检查倒计时中止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle Names控制程序暂停先前发送到服务器的重新加载请求，就会将信息性消息写入日志文件</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-9AC650FA-D28C-4512-BB82-4212167669D7"><!-- --></a> NNO-00068：警告：行政区域检查失败，在明年支票<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要服务器无法连接到配置数据库以查看是否有任何配置数据发生更改，就会发出此警告。服务器将自动开始更频繁地重新发布重新加载检查，并且如果连接连续三天失败，最终将放弃。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3C62A89D-2FF8-4F02-975D-C915E18BF1D2"><!-- --></a> NNO-00069：警告：管理区域检查失败太多，检查已禁用</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>每当服务器尝试连接到配置数据库时连续三天失败时都会发出警告。服务器禁用重新加载检查。稍后可以从Oracle网络管理器或Oracle名称控制程序重新启用重新加载检查。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1961B9B7-A77B-4F3E-A18D-A659F887E91A"><!-- --></a> NNO-00070：管理区域已更改，重新加载域数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要服务器的配置发生更改，服务器正在从配置数据库重新加载新配置，就会将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-0F2E098F-BC03-48B0-AACF-AFC65611180A"><!-- --></a> NNO-00071：无法构造缓存检查点文件名</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法构造依赖于系统的文件名。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-905D1D20-13CD-4E67-B7EE-764D29F93BAC"><!-- --></a> NNO-00072：从区域数据库加载</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>正常</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7B3A1057-1CED-4B98-9DC1-8B4737164962"><!-- --></a> NNO-00073：从区域数据库加载服务器配置</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在正常服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-01DB229E-FCEC-466E-B4BC-CA3EF7C66E9D"><!-- --></a> NNO-00074：从服务器<span class="variable" translate="no">string</span>下载区域</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在正常服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-396FB1AF-1EB4-4A49-B7F8-9B194FF391D3"><!-- --></a> NNO-00080：无法委派域“ <span class="variable" translate="no">string</span> ”，因为其父级已被委派</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>发生内部委派错误。委派由Oracle网络管理器控制，该网络管理器强制执行正确的委派规则。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7F8E2C27-8DA5-40A8-A99D-DA7187AFCDBC"><!-- --></a> NNO-00081：域“ <span class="variable" translate="no">string</span> ”没有名称服务器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>发生内部配置错误。Oracle网络管理器负责正确配置Oracle Names服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-012EF6D2-4854-4CD0-8F68-16312F1B45B6"><!-- --></a> NNO-00082：域“ <span class="variable" translate="no">string</span> ”缺少我的名字“ <span class="variable" translate="no">string</span> ”作为名称服务器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>发生内部配置错误。Oracle网络管理器负责正确配置Oracle Names服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1C34261C-8C86-4A3C-B66A-0A6EF7FDEDEB"><!-- --></a> NNO-00083：域“ <span class="variable" translate="no">string</span> ”服务器“ <span class="variable" translate="no">string</span> ”没有地址</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>发生内部配置错误。Oracle网络管理器负责正确配置Oracle Names服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-14EE414A-1F75-413E-9884-7D5A43DB5B3C"><!-- --></a> NNO-00084：域“ <span class="variable" translate="no">string</span> ”不在权威域列表中</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>发生内部配置错误。Oracle网络管理器负责正确配置Oracle Names服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C1CB11B0-D2D0-4667-AB9C-72FEA32E8DEC"><!-- --></a> NNO-00104：行<span class="variable" translate="no">string</span> ：语法错误，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器发现其域数据语法错误。如果服务器的内部检查点文件已损坏，也会显示此消息。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7C944EFD-144F-40F0-8A93-54967CAF87DA"><!-- --></a> NNO-00105：行<span class="variable" translate="no">string</span> ：无效名称“ <span class="variable" translate="no">string</span> ”，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的全局名称。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-47E5E1EF-370F-451F-AAFF-5762EE11408E"><!-- --></a> NNO-00106：行<span class="variable" translate="no">string</span> ：无效的TTL“ <span class="variable" translate="no">string</span> ”，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的TTL。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6004CD07-87FB-4753-9A67-D11439659F52"><!-- --></a> NNO-00107：行<span class="variable" translate="no">string</span> ：忽略过时的检查点数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其缓存检查点文件中检测到过时的缓存数据时，在服务器启动期间出现的信息性消息。该消息是正常服务器启动的一部分。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BC4F3F49-1EA6-4FE2-B4E9-9974D7CE2B00"><!-- --></a> NNO-00108：行<span class="variable" translate="no">number</span> ：的TTL <span class="variable" translate="no">number</span>低于最小域秒<span class="variable" translate="no">number</span> ，利用最小</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的TTL值。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E683F406-4AB5-4F5C-9335-FE82CB972B49"><!-- --></a> NNO-00109：行<span class="variable" translate="no">string</span> ：无效的数据类型名称“ <span class="variable" translate="no">string</span> ”，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的数据类型名称。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1F0A6FB6-0684-485A-B9AC-47C45C7364BC"><!-- --></a> NNO-00110：行<span class="variable" translate="no">string</span> ：未知数据类型“ <span class="variable" translate="no">string</span> ”，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了未知数据类型。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-21C3EF5B-442E-4F06-9585-8C8C36C93A8A"><!-- --></a> NNO-00111：行<span class="variable" translate="no">string</span> ：数据类型“ <span class="variable" translate="no">string</span> ”具有语法“ <span class="variable" translate="no">string</span> ”，应该是“ <span class="variable" translate="no">string</span> ”，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的数据类型语法。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-361AA4E8-8AD3-48E7-BB44-E881A708BC68"><!-- --></a> NNO-00112：行<span class="variable" translate="no">string</span> ：忽略类型为“ <span class="variable" translate="no">string</span> ”的重复数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了重复记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-EFC77AAD-D62E-4791-907E-9D3AB0B48DD0"><!-- --></a> NNO-00113：行<span class="variable" translate="no">string</span> ：别名数据已存在，所有其他数据均被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中找到了具有相同全局名称的别名和非别名数据。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F3392656-1934-4ABB-A810-5EFBAB2FE4DD"><!-- --></a> NNO-00114：行<span class="variable" translate="no">string</span> ：存在其他数据，忽略别名数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中找到了具有相同全局名称的别名和非别名数据。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-5BA44F6D-A516-4C09-81CF-6F4D0F3FB805"><!-- --></a> NNO-00115：行<span class="variable" translate="no">string</span> ：单值数据类型“ <span class="variable" translate="no">string</span> ”，忽略其他实例</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当类型仅允许具有特定名称的单个记录时，服务器找到具有相同名称和类型的多个记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-ADE814D9-6463-4074-A3B4-5513BEA988EF"><!-- --></a> NNO-00116：警告： <span class="variable" translate="no">string</span>加载中的数据类型为“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中找到了包含无效数据类型的记录。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>无需采取行动;对数据的调整将消除警告。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BD81607F-A8C2-4DD9-82CC-DFE53B2CEB3E"><!-- --></a> NNO-00117：行<span class="variable" translate="no">string</span> ：缺少数据类型，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中找到了缺少数据类型的记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B314FC64-C2EC-44E0-A50D-4E5255BF42E6"><!-- --></a> NNO-00118：行<span class="variable" translate="no">string</span> ：数据长度<span class="variable" translate="no">string</span>超过最大的<span class="variable" translate="no">string</span> ，忽略数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器找到一条长度超过内部限制的记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-47D58E84-25EF-4EFB-AF60-5F063E9DA7EE"><!-- --></a> NNO-00119：行<span class="variable" translate="no">string</span> ：服务器对名称“ <span class="variable" translate="no">string</span> ”不具有权威性，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中找到了一个不具有权威性的全局名称。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-0B984F2B-C7E6-45C6-8281-F19987102081"><!-- --></a> NNO-00120：行<span class="variable" translate="no">string</span> ：此处不允许使用拓扑名称“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-25C4D091-101F-46EB-A62E-5F722183CB38"><!-- --></a> NNO-00121：LDIF文件<span class="variable" translate="no">string</span>打开失败：错误= <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效记录。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-63256043-8A55-44B3-91F8-FCBFE428C436"><!-- --></a> NNO-00122：名称无效，数据被忽略：条目：\ n <span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在其域数据中发现了无效的全局名称。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-78748AD8-194F-4CC0-968B-1B81B836ED7B"><!-- --></a> NNO-00123：节点“ <span class="variable" translate="no">string</span> ”没有权威父级，数据被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>域数据中的对象显然不在服务器具有权威性的域中。有问题的记录未加载，但服务器继续加载数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查数据中的不一致性，并更正权威域之外的拓扑定义或域数据中的任何错误。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-9C046690-CCCE-419E-A03E-762D4BFDF452"><!-- --></a> NNO-00150：警告：无效提示列表，未加载提示</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含无效的提示说明列表。服务器将继续运行，但不会加载任何提示。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-9571F2C4-2037-4E31-8E7F-A63C87CB4EE6"><!-- --></a> NNO-00151：警告：忽略域“ <span class="variable" translate="no">string</span> ”的提示，服务器是权威的</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含服务器管理区域中的域的提示。忽略提示，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-A18EC3BD-E24F-41E6-9B2D-BC0E5D7983E7"><!-- --></a> NNO-00152：警告：提示计数<span class="variable" translate="no">number</span>超过了最大<span class="variable" translate="no">number</span> ，第一<span class="variable" translate="no">number</span>将被载入</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的提示列表中有太多提示。服务器将加载指定的最大提示数，忽略其余提示，然后继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1B8EAC96-FA70-4985-AFC6-96A2AD6ACC9B"><!-- --></a> NNO-00153：警告：提示域<span class="variable" translate="no">number</span>具有无效名称“ <span class="variable" translate="no">string</span> ”，提示域被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含一个名称无效的域。域被忽略，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-850B244A-0A18-4C4D-82BD-13D974102C15"><!-- --></a> NNO-00154：警告：提示<span class="variable" translate="no">number</span>包含无效的服务器名称“ <span class="variable" translate="no">string</span> ”，提示被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含一个带有无效服务器名称的提示。忽略提示，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-0C255DEE-74DD-4BB1-8C52-370F5630317E"><!-- --></a> NNO-00155：警告：提示<span class="variable" translate="no">number</span>缺少地址，提示被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含没有服务器地址的提示。忽略提示，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-574695DB-F604-4A4F-AE18-8F2604092D89"><!-- --></a> NNO-00156：警告：提示<span class="variable" translate="no">number</span>地址长度<span class="variable" translate="no">number</span>超过最大<span class="variable" translate="no">number</span> ，忽略提示</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含一个地址长度超过内部限制的提示。忽略提示，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-0B77EBB5-437F-4BE1-86ED-2F1B5C9FE44D"><!-- --></a> NNO-00157：警告：提示<span class="variable" translate="no">number</span>包含无效地址，提示被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含带有无效地址的提示。忽略提示，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-99125011-FDD4-47A9-808A-5A07553FD613"><!-- --></a> NNO-00158：警告：提示域计数<span class="variable" translate="no">number</span>超过最大<span class="variable" translate="no">number</span> ，第一<span class="variable" translate="no">number</span>将被载入</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的提示域列表太长。服务器将加载指定的最大提示域数，忽略其余域，然后继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3A891C7F-6387-491B-97AE-CF0B0D006D19"><!-- --></a> NNO-00159：警告：忽略重复提示域名<span class="variable" translate="no">number</span>名“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的提示域列表包含重复的域。忽略副本，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D65DA8A5-3A46-4F67-A9D0-1302DCFFC3FE"><!-- --></a> NNO-00160：警告：忽略重复的提示服务器“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的提示服务器列表包含重复的服务器。忽略副本，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-083AF82A-1B43-4E99-87B8-37276181D41A"><!-- --></a> NNO-00250：无效的管理区域描述</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在启动期间遇到无效的管理区域描述。此错误将阻止服务器启动。管理区域描述存储在服务器的names.ora配置文件中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.admin_region参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6107925A-0F96-4FC4-92DE-6F3A0C2703C6"><!-- --></a> NNO-00251：缺少管理区域参数<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的管理区域描述缺少必需参数。此错误将阻止服务器启动。管理区域描述存储在服务器的names.ora配置文件中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.admin_region参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D74CC9C8-ECCF-4D56-AF04-CABE1DFA9C0A"><!-- --></a> NNO-00252：无效的管理域参数<span class="variable" translate="no">string</span>值“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器遇到无效的管理区域参数。此错误将阻止服务器启动。管理区域描述存储在服务器的names.ora配置文件中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.admin_region参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-260E0187-D21E-4842-9602-AF86F279BBB3"><!-- --></a> NNO-00253：行政区域的参数<span class="variable" translate="no">string</span>长度<span class="variable" translate="no">string</span>超过了最大的<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器遇到一个管理区域参数，其长度超过内部限制。此错误将阻止服务器启动。管理区域描述存储在服务器的names.ora配置文件中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.admin_region参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BA85A5FD-E515-4B10-AF86-2126572A007E"><!-- --></a> NNO-00254：警告：参数<span class="variable" translate="no">string</span>值必须介于<span class="variable" translate="no">number</span>和<span class="variable" translate="no">number</span>之间，设置为<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器遇到具有无效值的管理区域参数。该值设置为适合大多数应用程序的默认值，服务器继续运行。管理区域描述存储在服务器的names.ora配置文件中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.admin_region参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-35B120DD-216E-4553-9C32-39286B596517"><!-- --></a> NNO-00255：无法初始化ROS</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法在启动期间初始化ROS。该错误会阻止服务器运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-5E37ECEC-5A67-4EDE-9EDA-14B0B97A635D"><!-- --></a> NNO-00256：使用管理区域“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在服务器启动期间显示的信息性消息，并记录管理区域的名称以供管理员将来诊断使用。该消息是正常服务器启动的一部分。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-DB099545-DFDA-4C6D-B0CA-2D79898452B0"><!-- --></a> NNO-00257：警告：无法从区域商店获取序列号</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在尝试获取配置数据库的序列号时遇到错误。几乎总是发生错误，因为服务器无法访问配置数据库的时间。如果在服务器启动期间发生错误，服务器将关闭。如果在服务器操作期间发生错误（服务器定期检查序列号以查看它是否应自行重新加载），则服务器会假定发生了瞬时故障，并在稍后重复该操作。如果重复继续失败三天，服务器将记录另一个错误并停止发出序列号加载操作。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>首先确保Netadmin程序已为此名称服务器导出服务器配置。接下来，确保数据库正在运行，Oracle Network Manager中指定的名称和密码是准确的，并且Oracle Names服务器和数据库之间存在SQL * Net连接。如果在服务器启动期间发生错误，则无论如何都可以通过启动服务器并将names.no_region_database参数设置为TRUE来强制启动检查点数据。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-90C7B160-477B-427E-82CD-997D8080A7E8"><!-- --></a> NNO-00258：无法从配置数据库加载配置</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>尝试从配置数据库加载服务器配置时遇到错误。如果有更多信息，则会显示此错误。此错误将导致服务器关闭。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B366B182-8F5C-427C-8C79-385DA3D7A6BA"><!-- --></a> NNO-00259：配置表尚未安装或无法访问</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>未正确安装配置数据库。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保已正确安装Oracle网络管理器及其数据库</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-EB269DFA-2F7D-4A60-9CBE-826C461DB5D5"><!-- --></a> NNO-00260：从检查点文件“ <span class="variable" translate="no">string</span> ”加载配置数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>通过将names.no_region_database参数设置为TRUE，在强制服务器从其最新配置检查点文件加载服务器时，将信息性消息写入日志文件。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E075134C-967F-4A2E-90C3-4AA35A31DC91"><!-- --></a> NNO-00261：无法构造配置检查点文件名</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法构造依赖于系统的文件名。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B68A4C57-98D3-442A-9649-01915FF17950"><!-- --></a> NNO-00262：警告：无法写入检查点文件“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法写入命名的检查点文件。此问题通常是由文件系统的保护设置引起的。这个错误不是致命的;它只是意味着服务器不会创建任何检查点数据。但请注意，如果配置数据库在将来的服务器启动期间始终不可用，则缺少检查点数据意味着您将无法使用names.no_region_database参数强制从检查点数据启动。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查服务器是否有权写入错误消息中指定的文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E5E29D8E-0431-4F94-9936-EF1B0B84F0CD"><!-- --></a> NNO-00263：配置数据库出错</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在访问配置数据库时遇到错误。当数据库不可用或SQL *与数据库的网络连接中断时，可能会发生此错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-205D7860-7341-404F-B254-C9F1CA46D5F0"><!-- --></a> NNO-00264：配置数据库查询未返回任何数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器尝试从配置数据库中获取数据，但未找到任何数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>错误通常出现在更具体的错误下面，该错误将告诉您问题的确切性质。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-FCA690BF-2864-400A-B65F-305E41B8727B"><!-- --></a> NNO-00265：警告：无法从检查点文件加载数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器已使用检查点数据启动，无法读取该数据。错误堆栈中低于此值的剩余错误提供有关该问题的更具体信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查命名文件是否存在以及服务器是否有权读取它。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-049A7134-AAF0-4101-A519-E4B2FD4A6C5C"><!-- --></a> NNO-00266：在配置数据库中找不到文档“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在尝试从配置数据库中获取其配置ID时遇到错误。只要服务器无法访问配置数据库，就会发生该错误。此错误将导致服务器关闭。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-2EAFE356-CF03-4239-B455-7FAACF6D5603"><!-- --></a> NNO-00267：警告：配置数据库不包含服务器“ <span class="variable" translate="no">string</span> ”的数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器已成功联系配置数据库，但无法找到与服务器名称关联的任何配置信息。该名称在服务器的names.ora配置文件中指定。几乎总是发生错误，因为尚未从Netadmin程序导出服务器配置。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保Netadmin程序已为此名称服务器导出服务器配置。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-64A0E611-D290-49B6-A261-22C4EBCE2956"><!-- --></a> NNO-00268：警告：未使用配置数据库，而是使用检查点数据</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>一条信息性消息，指示服务器已使用names.no_region_database参数设置为TRUE启动，并且它将使用检查点数据而不是尝试联系配置数据库。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BC91EE82-7D17-42D0-BB15-D96011282DEB"><!-- --></a> NNO-00269：配置数据库是版本<span class="variable" translate="no">string</span> ，服务器至少需要版本<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法使用指定的配置数据库，因为它的版本不正确。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>运行随网络管理器提供的文档转换实用程序，然后重新导出网络。转换实用程序会将旧文档升级到名称服务器可以理解的版本。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-A8B8CE83-7715-45A8-9B47-B17F85646FE8"><!-- --></a> NNO-00270：ORACLE错误<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>访问配置数据库时遇到ORACLE错误。当数据库不可用或SQL *与数据库的网络连接中断时，可能会发生此错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保数据库正在运行，Oracle网络管理器中指定的名称和密码是准确的，并且Oracle名称服务器和数据库之间存在SQL * Net连接。要强制服务器以任何方式启动，请使用其检查点数据，以names.no_region_database参数设置为TRUE启动服务器。如果没有可用的检查点数据，服务器将关闭。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E25B011B-8BE2-4F05-A497-7351CC89E01D"><!-- --></a> NNO-00271：警告：names.ora区域是版本<span class="variable" translate="no">string</span> ，网络定义是版本<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> names.ora中的区域描述与网络定义不同步。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>除非名称服务器无法使用网络定义运行，否则无需任何操作。为安全起见，应使用与网络定义一致的名称更新names.ora。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C0AB160D-399A-44C8-B551-41721DB69900"><!-- --></a> NNO-00272：行<span class="variable" translate="no">string</span> ;无效的DIT / DN</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>区域描述中提供的DIT / DN中存在语法错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>更正错误并重新启动服务器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-CA8CA185-9285-499D-B744-76AC2CEE8CC9"><!-- --></a> NNO-00300：未指定监听地址，至少需要一个</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置缺少要侦听的地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B447E4BB-7D85-4810-AECF-5107685A38D5"><!-- --></a> NNO-00301：服务器将关闭<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器从Oracle Names控制程序收到关闭请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-A5AD9440-1A8E-491F-89A4-CAA9CCE91818"><!-- --></a> NNO-00302：服务器已停止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器关闭时写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C2D5B1C6-EEA0-4DEE-928F-010B66B15119"><!-- --></a> NNO-00303：服务器“ <span class="variable" translate="no">string</span> ”以进程ID <span class="variable" translate="no">number</span>开头</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器成功启动时写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E5C1B11D-7348-4EEA-872A-D4350A0100E2"><!-- --></a> NNO-00304：监听地址<span class="variable" translate="no">string</span>长度<span class="variable" translate="no">string</span>超过了最大的<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的某个侦听地址的长度超出了内部限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BEE7268F-FBE5-4EE8-A3E2-0BAFB6F0DCDB"><!-- --></a> NNO-00305：跟踪级别从<span class="variable" translate="no">number</span>更改为<span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改其跟踪级别以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-E2D3A0D2-B665-4014-81E5-A9C3473E5467"><!-- --></a> NNO-00306：服务器关机倒计时中止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle Names控制程序暂停先前发送到服务器的关闭请求，就会将信息性消息写入日志文件</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-84664467-6994-4F8C-A057-0C5C357557B9"><!-- --></a> NNO-00307：服务器名称“ <span class="variable" translate="no">string</span> ”无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器名称无效。该名称在服务器的names.ora配置文件中指定。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.server_name参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-0D12F3D0-2B94-4E9B-99BF-4DDE2310437A"><!-- --></a> NNO-00308：服务器将重新启动<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器从Oracle Names控制程序收到重新启动请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-528D1FC1-E627-4378-A181-97A8C6A3DE5A"><!-- --></a> NNO-00309：服务器重启</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器重新启动时写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-058D798F-4EB6-4C56-A4E3-03C63215776B"><!-- --></a> NNO-00310：服务器重启倒计时中止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle Names控制程序暂停先前发送到服务器的重新启动请求，就会将信息性消息写入日志文件</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-243FD5FC-072C-4EFA-AC8E-7AEBC0E1BCCA"><!-- --></a> NNO-00311：无效的收听地址列表</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含无效的侦听地址列表。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-973312CC-3891-49F2-843B-5E58E531C602"><!-- --></a> NNO-00312：监听地址<span class="variable" translate="no">string</span>无效</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含无效的侦听地址。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BDEA47BB-A545-4531-9E1B-F71AB9251FA2"><!-- --></a> NNO-00313：服务器密码长度<span class="variable" translate="no">string</span>超过了最大的<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的密码长度超出内部限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C5B6C378-B138-40EC-AFA6-C952B2FC6ABF"><!-- --></a> NNO-00314：错误将跟踪级别从<span class="variable" translate="no">number</span>更改为<span class="variable" translate="no">number</span> ，级别更改被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在更改其跟踪级别时遇到错误，以响应来自Oracle Names控制程序的请求。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8E938D6C-8CF7-42F1-82BE-53D86ADD359A"><!-- --></a> NNO-00315：服务器正在侦听地址<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在服务器启动期间写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-21682B91-0AFE-4F14-90A4-2C3E1216B96D"><!-- --></a> NNO-00316：禁用统计计数器重置</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器禁用统计信息计数器重置以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1C5CDF2E-9F1D-41DA-A15E-987783EBD7C7"><!-- --></a> NNO-00317：统计计数器复位间隔变为<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改其统计计数器重置间隔以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7967DBD1-A088-443E-A05E-0FFDD0B3BFE0"><!-- --></a> NNO-00318：压倒一切的下一个统计计数器复位，复位在<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器重置其统计计数器以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D211B4E8-7B8E-4D04-B6A0-EA412CB760D4"><!-- --></a> NNO-00320：缺少服务器名称参数</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器找不到names.server_name参数。该名称在服务器的names.ora配置文件中指定。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>确保names.ora中的names.server_name参数正确。names.ora文件由Oracle网络管理器自动生成，但管理员可以随时编辑该文件，从而引入错误。如果文件从未更改过，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D4A5CA86-D4C7-4562-8031-B66D36A1F3E0"><!-- --></a> NNO-00321：禁用统计计数器转储</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器禁用统计信息转储以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-726B1B66-59B5-4E1F-8CB3-9EC32C528AAA"><!-- --></a> NNO-00322：统计计数器转储间隔变为<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改其统计转储间隔以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-77DF5F91-946F-4D69-BA4B-F8060865B0E8"><!-- --></a> NNO-00323：压倒一切的下一个统计计数器倾倒，倾倒在<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器转储其统计计数器以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3E484B0F-EE25-4849-B6B2-AD99F5763BCF"><!-- --></a> NNO-00326：服务器统计计数器转储如下</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在统计信息转储开始时写入日志文件的信息性消息。该消息后跟一组服务器统计信息，并以指示转储已完成的另一条信息性消息结束。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-A423E426-9EA6-4DB6-98BF-9E689353C6D9"><!-- --></a> NNO-00327：服务器统计计数器转储结束</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在统计信息转储结束时写入日志文件的信息性消息。消息前面是一组服务器统计信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-EA22340D-7D78-4509-9379-55C11A0AA6B7"><!-- --></a> NNO-00328：服务器已将统计计数器重置为零</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器将其统计计数器重置为零以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-4BF7DC08-5BE6-46DC-81B2-59B8A5127F69"><!-- --></a> NNO-00329：服务器将保存在配置文件中<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器将配置保存到配置文件以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-CB5D5E1C-F258-4736-AB06-CC1C6DEC19DE"><!-- --></a> NNO-00330：服务器保存配置文件“ <span class="variable" translate="no">string</span> ”。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器将配置保存到配置文件以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8F030B17-19C0-47B0-B8E2-07B9C3F5F22E"><!-- --></a> NNO-00331：将新值<span class="variable" translate="no">string</span> <span class="variable" translate="no">string</span>保存到保存配置表时出错。
                  </dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>执行设置操作时写入日志文件的信息性消息，并且更改无法保存在save config ptable中，但应该是。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F42038FA-96E6-4D1E-ACD2-70AEEC615499"><!-- --></a> NNO-00332：警告：区域存储序列号从<span class="variable" translate="no">number</span>减少到<span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器找到区域数据库时，写入日志文件的信息性消息的序列号设置低于服务器先前加载区域数据时的序列号。这是一种不自然的情况 - 对该地区的每次更新都应该增加序列号，因此序列号的减少可能反映了篡改或意外的手动更改，以及可能的其他区域表。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>管理员应了解序列号减少的原因/原因。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-DCD951DA-E00E-44ED-9CA6-4D56B2535806"><!-- --></a> NNO-00333：警告：ROS admin_region类型已过时;使用SQL</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> names.admin_region中设置的值是过时的ROS类型</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>不需要采取任何行动;管理员应该将值设置为正确的类型 - 可能是SQL，可能是LDAP或LDIF</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-101532EE-F14F-4885-ADEE-A5A68B3FACD3"><!-- --></a> NNO-00334：区域加载失败：ROS admin_region类型<span class="variable" translate="no">number</span>不受支持</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> names.admin_region中设置的值是过时的ROS类型</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>不需要采取任何行动;管理员应该将值设置为正确的类型 - 可能是SQL，可能是LDAP或LDIF</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B7D6CE74-303B-4AA7-827A-F8BDFD00A6D4"><!-- --></a> NNO-00600：警告：转发数<span class="variable" translate="no">number</span>超过最大<span class="variable" translate="no">number</span> ，第一<span class="variable" translate="no">number</span>将被载入</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含太多默认转发器。服务器加载指定的最大数量的转发器，忽略其余的转发器，并继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-BE430EEC-CBC6-434B-873A-3F2783F13E0B"><!-- --></a> NNO-00601：警告：没有转发器，DEFAULT-FORWARDERS-ONLY模式被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置启用DEFAULT-FORWARDERS-ONLY模式，但配置不包含默认转发器。服务器忽略该请求并继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7A2E4174-08B1-455A-A37C-AD57BE19C565"><!-- --></a> NNO-00602：警告：转发器<span class="variable" translate="no">number</span>包含无效地址，转发器被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>默认转发器列表中的一个转发器具有无效的地址。将忽略转发器定义，服务器将继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-814BAD70-0E35-4439-B2EB-0CB63BA4A35B"><!-- --></a> NNO-00603：启用所有请求处理</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求启用请求处理时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-52542C91-6388-4CB7-86F0-312C9A8C3D66"><!-- --></a> NNO-00604：禁用所有请求处理</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求而禁用请求处理时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-DEB3FC98-D56D-4690-9003-019B2D508A0F"><!-- --></a> NNO-00605：启用修改请求</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求启用修改请求处理时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8F943A8F-1ACB-47EC-930D-378741945B0F"><!-- --></a> NNO-00606：禁用修改请求</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器禁用修改请求处理以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B643E47C-B87F-4CE3-BEF3-B879036C5EDF"><!-- --></a> NNO-00607：服务器仅转发到默认转发器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器的配置启用DEFAULT-FORWARDERS-ONLY模式时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-1E7B416A-14B0-4594-80CE-91819F8B8D58"><!-- --></a> NNO-00608：收到损坏的邮件</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器收到损坏的请求。请求被忽略。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>损坏的请求通常由瞬态网络问题引起。如果收到许多损坏的消息，请打开跟踪以获取更多信息。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-39ECA89D-9814-454F-BBFD-33D878FA6FCB"><!-- --></a> NNO-00609：警告：转发<span class="variable" translate="no">number</span>地址长度<span class="variable" translate="no">number</span>超过最大<span class="variable" translate="no">number</span> ，忽视</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含转发器地址，其长度超过内部限制。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-98405161-C589-437F-AF32-9E18FDFA0DE6"><!-- --></a> NNO-00610：检测到可能的别名循环，涉及名称“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器检测到涉及指定名称的别名循环。别名“X”指向另一个别名“Y”时发生别名循环，该别名指向“X”而不是地址或其他名称服务器数据。循环可以包含更多跳，但基本思想保持不变。管理员错误输入网络数据时会发生循环，特别是当一个管理区域中的别名指向另一个管理区域中的数据时。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>使用Oracle Names控制程序查询指定的名称。控制程序将描述别名路径，您可以使用该信息查找哪些名称不正确以及错误数据属于哪些管理区域。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8AE7B40F-71BC-443C-8A81-189E571FAA51"><!-- --></a> NNO-00611：禁用请求转发</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器禁用请求转发以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-EA99DDFA-4E02-466C-ADB1-425D90213EE8"><!-- --></a> NNO-00612：启用请求转发</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求启用请求转发时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-9FCBE384-BA00-4557-8262-93FA19FCE3E2"><!-- --></a> NNO-00613：在系统查询中禁用FORWARDING-DESIRED</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器在其生成的查询上禁用FORWARDING-DESIRED属性时，将信息性消息写入日志文件。该消息是响应Oracle Names控制程序的请求而发出的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B9BA7BC5-4105-4948-AAB3-13826DF23F07"><!-- --></a> NNO-00614：在系统查询上启用FORWARDING-DESIRED</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器为其生成的查询启用FORWARDING-DESIRED属性时，将信息性消息写入日志文件。该消息是响应Oracle Names控制程序的请求而发出的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-58E93CC3-67ED-4959-A09E-5528B04BABFA"><!-- --></a> NNO-00615：禁用DEFAULT-FORWARDERS-ONLY模式</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器禁用DEFAULT-FORWARDERS-ONLY模式以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-49CE027A-F49C-4B58-85AA-E25EA11362A7"><!-- --></a> NNO-00616：启用DEFAULT-FORWARDERS-ONLY模式</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器启用DEFAULT-FORWARDERS-ONLY模式以响应来自Oracle Names控制程序的请求时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-64ABEEA7-7BC8-422D-BB19-928CAE248069"><!-- --></a> NNO-00617：在系统查询上启用AUTHORITY-REQUIRED</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器为其生成的查询启用AUTHORITY-REQUIRED属性时，将信息性消息写入日志文件。该消息是响应Oracle Names控制程序的请求而发出的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-DA3902DC-ED61-4C7D-8F3C-6E5A38B6806A"><!-- --></a> NNO-00618：在系统查询中禁用AUTHORITY-REQUIRED</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器在其生成的查询上禁用AUTHORITY-REQUIRED属性时，将信息性消息写入日志文件。该消息是响应Oracle Names控制程序的请求而发出的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C549FBAD-935D-4438-AADC-1E68DCDCBE96"><!-- --></a> NNO-00622：警告：名称为“ <span class="variable" translate="no">string</span> ”的自动刷新失败次数过多，查询已过期</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>如果发出自动刷新查询并连续三天返回错误，则会从自动刷新队列中删除查询并记录警告。可以从Oracle Names控制程序重新启动查询。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>此消息之前会有大量警告，表明相关查询失败。使用Oracle Names控制程序来描述失败的查询。确保正在查询的服务器正在运行，并且查询服务器和正在查询的服务器之间存在网络连接。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3C153C6A-716B-458C-9EAF-D026A42F0E91"><!-- --></a> NNO-00623：将自动刷新重试间隔设置<span class="variable" translate="no">number</span>秒数</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改其自动刷新重试间隔以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-2D3FD8E2-67F9-487F-AFB7-17AA09456F58"><!-- --></a> NNO-00624：设置自动刷新有效期限<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应Oracle Names控制程序的请求更改其自动刷新过期时间时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-94121550-C5E4-4E22-9167-4A194052F0F3"><!-- --></a> NNO-00625：名称“压倒一切的自动刷新<span class="variable" translate="no">string</span> ”，键入“ <span class="variable" translate="no">string</span> ”，刷新<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改下次发出自动刷新查询的时间时，将写入日志文件的信息性消息。该消息是响应Oracle Names控制程序的请求而发出的。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-428771E5-66E5-49A7-A586-EDBF5CA7E163"><!-- --></a> NNO-00626：无法启用DEFAULT-FORWARDERS-ONLY模式，不存在默认转发器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> Oracle Names控制程序发出了启用DEFAULT-FORWARDERS-ONLY模式的请求，并且忽略了请求，因为服务器没有默认转发器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-AE52DB00-7688-4050-9704-A4C7DD540719"><!-- --></a> NNO-00627：取消名称“ <span class="variable" translate="no">string</span> ”的自动刷新，输入“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器从自动刷新队列中删除查询以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B32C954D-5656-40D5-B78F-7AF709FE075F"><!-- --></a> NNO-00628：将每个查询的最大重新设置为<span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应Oracle Names控制程序的请求更改其最大重新计数时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B9E0EA32-95AD-4419-9647-DCAC46930CA0"><!-- --></a> NNO-00629：警告：转发器列表无效，未加载默认转发器</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含无效的转发器描述列表。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F85F49A1-1DF3-4317-BDE2-F9AC0E401382"><!-- --></a> NNO-00630：设置请求处理延迟<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求设置人为请求处理延迟时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6133AA47-B47B-4C1A-9ED5-919B67F78DB9"><!-- --></a> NNO-00631：警告：转发器<span class="variable" translate="no">number</span>名称无效“ <span class="variable" translate="no">string</span> ”，转发器被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含具有无效服务器名称的转发器描述。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-DD4E151E-B7B6-4A0B-97E5-529283006851"><!-- --></a> NNO-00632：警告：转发器<span class="variable" translate="no">number</span>缺少地址，转发器被忽略</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的配置包含缺少地址的转发器描述。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-898734EA-8A88-4413-B719-03FA306B5DB1"><!-- --></a> NNO-00633：检测到涉及服务器“ <span class="variable" translate="no">string</span> ”的致命委托循环</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器在转发请求时检测到致命委托循环。当服务器的拓扑数据指示它应该将请求转发给自己时，会发生循环。服务器立即关闭以响应此错误。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-716E8147-D2ED-4F9F-A93A-E4C48F659F86"><!-- --></a> NNO-00634：当我们是其权限时，收到权威名称“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器“X”对数据具有权威性时，服务器“X”从另一个服务器“Y”接收权威数据。应该永远不会出现这种情况，因为如果服务器“X”对所请求的数据具有权威性，它就不应该将请求转发给另一个服务器。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3E6F7762-AF07-4CC2-AB8E-336F88D2A6C5"><!-- --></a> NNO-00635：警告：忽略重复的转发器“ <span class="variable" translate="no">string</span> ”</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器的默认转发器列表包含重复的服务器。忽略副本，服务器继续运行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-04D013C5-AA06-4B0A-B454-CD77D8FF5AE9"><!-- --></a> NNO-00700：警告：不能检查点缓存，再次尝试<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法执行正常的定期高速缓存检查点，通常是因为无法写入高速缓存检查点文件。缓存检查点文件名在服务器启动期间显示为参考消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查服务器是否具有写入缓存检查点文件的权限，以及是否有足够的磁盘空间来写入文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F7B11F8C-8458-47B2-A308-351D236C2238"><!-- --></a> NNO-00701：警告：无法构造检查点文件名，禁用检查点</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法构造依赖于系统的文件名。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。有关更多详细信息，请启用跟踪并重新启动服务器。如果错误仍然存在，请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-16EC829B-ADD2-432E-8FAB-F25EF8B1A067"><!-- --></a> NNO-00702：禁用缓存检查点</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求而禁用缓存检查点时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-77A2B84F-0BF0-4907-82A5-3C4B7F9AE880"><!-- --></a> NNO-00703：检查点间隔变为<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器更改其缓存检查点间隔以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-ED29C29B-89D9-43C9-83EF-DE82128F67AF"><!-- --></a> NNO-00705：警告：无法打开检查点文件“ <span class="variable" translate="no">string</span> ”，检查点已禁用</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法打开命名的检查点文件进行写入。此问题通常是由文件系统的保护设置引起的。这个错误不是致命的;它只是意味着服务器不会检查其缓存。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查服务器是否有权写入错误消息中指定的文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-4D4CAD8E-CADA-4531-8BF3-1F28400DF65D"><!-- --></a> NNO-00706：覆盖下一个检查点高速缓存，在检查<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器检查其缓存以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8536B9F0-DB65-4598-B2CC-4DB50136DEB4"><!-- --></a> NNO-00707：服务器的缓存将被刷新<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器响应来自Oracle Names控制程序的请求刷新其缓存时，写入日志文件的信息性消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-74AE619B-63A1-4666-8885-E09DD595AD9D"><!-- --></a> NNO-00708：缓存刷新倒计时中止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle Names控制程序暂停先前发送到服务器的缓存刷新请求，就会将信息性消息写入日志文件</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-9985D1E1-A26F-421F-9AE0-0895DF18E4BF"><!-- --></a> NNO-00709：删除缓存检查点文件“ <span class="variable" translate="no">string</span> ”失败，缓存刷新可能无法正常工作</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器尝试刷新其缓存，这也会删除缓存检查点文件。尽管缓存刷新的其余部分成功，但文件删除失败。成功错误描述了删除失败的原因。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>当连续发出两个缓存清除操作而没有中间缓存检查点操作（这将重新创建文件）时，通常会发生此错误。第一个删除缓存文件，第二个尝试删除，但由于文件已被删除而失败。在这种情况下，该消息是无害的，可以忽略。但是，如果由于服务器缺少删除文件的权限而发生错误，则必须更改文件系统权限，以便允许服务器删除该文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-ADA3CD95-E27F-4D97-85EE-A5EE576C52E9"><!-- --></a> NNO-00710：服务器的缓存将被转储到跟踪文件中的<span class="variable" translate="no">number</span>秒</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>当服务器将其缓存转储到跟踪文件以响应来自Oracle Names控制程序的请求时，将信息性消息写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-F74ACB72-456E-44A3-B197-CCF3417BB8CA"><!-- --></a> NNO-00711：缓存转储倒计时中止</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>只要Oracle Names控制程序暂停先前发送到服务器的缓存转储请求，就会将信息写入日志文件</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-FA8AB52E-757C-4C81-9334-179665B118AB"><!-- --></a> NNO-00712：警告：组<span class="variable" translate="no">string</span>缓存检查点失败</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法执行正常的定期高速缓存检查点，通常是因为无法写入高速缓存检查点文件。缓存检查点文件名在服务器启动期间显示为参考消息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>检查服务器是否具有写入缓存检查点文件的权限，以及是否有足够的磁盘空间来写入文件。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-613BCB6B-DB81-4897-95B5-ABDF4E0B154B"><!-- --></a> NNO-00800：错误：无法从配置数据库中读取版本</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>区域数据库版本的查询失败。可能会关闭数据库，或者表名可能不存在于names.ora中指定的模式中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：相应地</span>纠正任何访问问题。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-58782E25-54F8-494A-A43E-E8A143D37C3E"><!-- --></a> NNO-00801：错误：OCI_SUCCESS_WITH_INFO： <span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>在区域数据库访问期间从OCI返回诊断信息。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-C538362A-13C1-4345-AECD-53507E54C37C"><!-- --></a> NNO-00802：错误：OCI_NEED_DATA</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>访问区域数据库时，服务器未向OCI接口提供足够的数据。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-5F39F18A-1589-48EB-93ED-40B2E3FC0CDC"><!-- --></a> NNO-00803：错误：OCI_INVALID_HANDLE</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器调用OCI，其句柄无效，访问区域数据库。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>用户通常看不到的内部错误。联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-8E7C70CF-A218-460A-AD4A-77A3C49D50A2"><!-- --></a> NNO-00804：错误：OCI_STILL_EXECUTE</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器和数据库之间的OCI操作仍在进行中。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-7EFDFF93-1964-44E1-AC39-B56B32E67D02"><!-- --></a> NNO-00805：错误：OCI_CONTINUE</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>不可能。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-09976432-11F3-482F-842C-F7EC30ACE15D"><!-- --></a> NNO-00806：错误：OCI_ERROR： <span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> OCI发生访问区域数据库。更具体的细节将写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>在日志文件中查找相应的条目，并在可能的情况下更正失败的原因。否则请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6BFD109D-69DB-44AA-9946-CB2C9C3BA17E"><!-- --></a> NNO-00807：获取结束：OCI_NO_DATA</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>已从区域表返回所有行。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-D97B3C25-105A-40F6-BEA0-774FCBF5517D"><!-- --></a> NNO-00808：连接到区域数据库时出错</dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>不可能。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-33B54496-F2ED-4E80-82D5-47C9DD76F70C"><!-- --></a> NNO-00809：未知的OCI错误： <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>不可能。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">行动：</span>没有</p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-77935B24-BA92-4FFC-B988-470BA436FF6B"><!-- --></a> NNO-00850：错误：LDAP查询返回<span class="variable" translate="no">string</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span> LDAP API返回错误。更具体的细节将写入日志文件。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>在日志文件中查找相应的条目，并在可能的情况下更正失败的原因。否则请联系全球客户支持。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-2C8D36AE-FFAA-4AF8-8F74-5E9B006BEB63"><!-- --></a> NNO-00851：LDAP打开/绑定失败：错误= <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法连接到LDAP目录。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>找出错误原因并更正错误并重新启动服务器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-B677C5A5-76EC-402B-9EBB-6DA600D4463D"><!-- --></a> NNO-00852：无法获取LDAP条目：错误= <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法从LDAP API检索查询条目。</p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>找出错误原因并更正错误并重新启动服务器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-6DF538B6-798A-4E21-81A2-5DE96D8911EF"><!-- --></a> NNO-00853：无法获取LDAP属性/值：错误= <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法连接到LDAP目录。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>找出错误原因并更正错误并重新启动服务器。

                     </p>
                     
                  </dd>
                  <dt class="dlterm"><a name="GUID-69D5F38B-0474-42FE-9DAB-16229261EBBA__GUID-3F452BB0-1B4B-4246-BB98-77626172594E"><!-- --></a> NNO-00854：错误解除绑定LDAP：错误= <span class="variable" translate="no">number</span></dt>
                  <dd>
                     
                     <p>
                        <span class="keyword">原因：</span>服务器无法连接到LDAP目录。

                     </p>
                     
                  </dd>
                  <dd class="ddexpand">
                     
                     <p>
                        <span class="keyword">操作：</span>找出错误原因并更正错误并重新启动服务器。

                     </p>
                     
                  </dd>
               </dl>
            </div>
         </div>
      </article>
   </body>
</html><html id="12667.loading-objects-oracle-sql-loader.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <meta name="description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <title>加载对象，LOB和集合</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Utilities "></meta>
      <meta property="og:description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Utilities"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96081-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-sql-loader-field-list-contents.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-sql-loader-conventional-and-direct-loads.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities"></meta>
    <meta name="dcterms.isVersionOf" content="SUTIL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-sql-loader-field-list-contents.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-sql-loader-conventional-and-direct-loads.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-sql-loader.html" property="item" typeof="WebPage"><span property="name">使用SQL * Loader</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">加载对象，LOB和集合</li>
            </ol>
            <a id="GUID-A1828462-FD32-457C-976F-C85BA3A995DA" name="GUID-A1828462-FD32-457C-976F-C85BA3A995DA"></a><a id="SUTIL007"></a>
            
            <h2 id="SUTIL-GUID-A1828462-FD32-457C-976F-C85BA3A995DA" class="sect2"><span class="enumeration_chapter">11</span>加载对象，LOB和集合</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776">加载列对象</a><br>控制文件中的列对象根据其属性进行描述。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7">加载对象表</a><br>加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8">加载REF列</a><br>SQL * Loader可以加载系统生成的OID <code class="codeph">REF</code>列，基于主键的<code class="codeph">REF</code>列和允许主键的未作用域<code class="codeph">REF</code>列。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80">加载LOB</a><br>该部分描述了加载LOB。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40">加载BFILE列</a><br><code class="codeph">BFILE</code>数据类型将非结构化二进制数据存储在数据库外的操作系统文件中。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C">加载集合（嵌套表和VARRAY）</a><br>与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737">动态与静态SDF规格</a><br>您可以静态指定SDF（指定文件的实际名称）或动态指定（使用<code class="codeph">FILLER</code>字段作为文件名源）。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34">从子表中单独加载父表</a><br>加载包含嵌套表列的表时，可以从子表中单独加载父表。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="oracle-sql-loader.html#GUID-8D037494-07FA-4226-B507-E1B2ED10C144">SQL * Loader</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1247"></a><div class="props_rev_3"><a id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" name="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776"></a><h3 id="SUTIL-GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" class="sect3"><span class="enumeration_section">11.1</span>加载列对象</h3>
               <div>
                  <p>控制文件中的列对象根据其属性进行描述。</p>
                  <p>如果列对象所基于的对象类型被声明为非最终对象，则可以根据从基础对象类型派生的任何子类型的属性（包括派生和声明的属性）来描述控制文件中的列对象。在数据文件中，对应于列对象的每个属性的数据在与对应于简单关系列的数据字段类似的数据字段中。</p>
                  <div class="infoboxnote" id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776__GUID-E2FBFA07-7E3E-40FD-9E52-C87001DF8292">
                     <p class="notep1">注意：</p>
                     <p>通过SQL * Loader支持复杂数据类型（如列对象），可能会出现控制文件中可能存在两个相同的字段名称，一个对应于列，另一个对应于列对象的属性。某些子句可以引用字段（例如， <code class="codeph">WHEN</code> ， <code class="codeph">NULLIF</code> ， <code class="codeph">DEFAULTIF</code> ， <code class="codeph">SID</code> ， <code class="codeph">OID</code> ， <code class="codeph">REF</code> ， <code class="codeph">BFILE</code>等），如果控制文件中存在相同名称的字段，则会导致命名冲突。
                     </p>
                     <p>因此，如果使用引用字段的子句，则必须指定全名。例如，如果字段<code class="codeph">fld1</code>指定为<code class="codeph">COLUMN</code> <code class="codeph">OBJECT</code>并且它包含字段<code class="codeph">fld2</code> ，那么当您在诸如<code class="codeph">NULLIF</code>的子句中指定<code class="codeph">fld2</code>时，必须使用完整字段名称<code class="codeph">fld1.fld2</code> 。
                     </p>
                  </div>
                  <p>以下部分显示了加载列对象的示例：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22">以流记录格式加载列对象</a><br>您可以以流记录格式加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166">以可变记录格式加载列对象</a><br>您可以以可变记录格式加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D">加载嵌套列对象</a><br>您可以加载嵌套的列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270">使用派生子类型加载列对象</a><br>您可以使用派生的子类型加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43">指定对象的空值</a><br>您可以为对象指定空值。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB">使用用户定义的构造函数加载列对象</a><br>您可以使用用户定义的构造函数加载列对象。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3356"></a><a id="SUTIL3355"></a><a id="SUTIL1248"></a><div class="props_rev_3"><a id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" name="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22"></a><h4 id="SUTIL-GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" class="sect4"><span class="enumeration_section">11.1.1</span>以流记录格式加载列对象</h4>
                  <div>
                     <p>您可以以流记录格式加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">例11-1</a>显示了数据处于预定大小字段的情况。换行符标志着物理记录的结束。您还可以使用操作系统文件处理子句（ <code class="codeph">os_file_proc_clause</code> ）中的自定义记录分隔符标记物理记录的结尾。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">
                        <p class="titleinexample">示例11-1以流记录格式加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE departments（dept_no POSITION（01:03）CHAR，dept_name POSITION（05:15）CHAR， <span class="bold">1</span> dept_mgr COLUMN OBJECT（名称位置（17:33）CHAR，年龄位置（35:37） ）INTEGER EXTERNAL，emp_id POSITION（40:46）INTEGER EXTERNAL））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101数学Johny Quest 30 1024 237物理阿尔伯特爱因斯坦65 0000</pre><div class="infoboxnote" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__GUID-8C044CFD-5B1C-4E33-A5F2-890D8EC8B538">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>可以递归地应用此类型的列对象规范来描述嵌套的列对象。</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3358"></a><a id="SUTIL3357"></a><a id="SUTIL1249"></a><div class="props_rev_3"><a id="GUID-6A23F378-18B9-4F60-848E-C367A9978166" name="GUID-6A23F378-18B9-4F60-848E-C367A9978166"></a><h4 id="SUTIL-GUID-6A23F378-18B9-4F60-848E-C367A9978166" class="sect4"><span class="enumeration_section">11.1.2</span>以可变记录格式加载列对象</h4>
                  <div>
                     <p>您可以以可变记录格式加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">例11-2</a>显示了数据在分隔字段中的情况。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">
                        <p class="titleinexample">示例11-2以可变记录格式加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA <span class="bold">1</span> INFILE'meample.dat'“var 6”INTO TABLE部门字段由'，''选择性地包围''' <span class="bold">2</span> （dept_no dept_name，dept_mgr COLUMN OBJECT（名称CHAR（30），年龄INTEGER EXTERNAL（5）， emp_id INTEGER EXTERNAL（5）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span> <span class="italic">000034</span> 101，Mathematics，Johny Q.， <span class="italic">30,1024,000039237</span> ，Physics，“Albert Einstein”，65,0000，</pre><div class="infoboxnote" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__GUID-84AB0DEF-B2CC-4EE9-A998-47D7B90616D0">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">"var"</code>字符串包括每个记录开头的长度字段中的字节数（在本例中，数字为6）。如果未指定任何值，则默认值为5个字节。变量记录的最大大小为2 ^ 32-1。指定较大的值将导致错误。
                                 </p>
                              </li>
                              <li>
                                 <p>虽然没有给出位置规范，但是一般语法保持不变（列对象的名称后跟括在括号中的属性列表）。另请注意，省略的类型规范默认为长度为255的<code class="codeph">CHAR</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>前6个字节（斜体）指定即将到来的记录的长度。这些长度规范包括换行符，由于<code class="codeph">emp_id</code>字段之后的终结符而被忽略。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3360"></a><a id="SUTIL3359"></a><a id="SUTIL1250"></a><div class="props_rev_3"><a id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" name="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D"></a><h4 id="SUTIL-GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" class="sect4"><span class="enumeration_section">11.1.3</span>加载嵌套列对象</h4>
                  <div>
                     <p>您可以加载嵌套的列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">例11-3</a>显示了一个描述嵌套列对象的控制文件（一个列对象嵌套在另一个列对象中）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">
                        <p class="titleinexample">示例11-3加载嵌套列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE`sample.dat'INTO TABLE departments_v2 FIELDS TERMINATED BY'，''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' 3），emp_id INTEGER EXTERNAL（7）， <span class="bold">1</span> em_contact COLUMN OBJECT（名称CHAR（30），phone_num CHAR（20））））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，Johny Q.，30,1024，“Barbie”，650-251-0010,237，Physics，“Albert Einstein”，65,0000，Wife Einstein，654-3210，</pre><div class="infoboxnote" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__GUID-B0236F5A-4D48-45FB-BE77-68B077C39CEF">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>此条目指定嵌套在列对象中的列对象。</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3362"></a><a id="SUTIL3361"></a><a id="SUTIL1251"></a><div class="props_rev_3"><a id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" name="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270"></a><h4 id="SUTIL-GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" class="sect4"><span class="enumeration_section">11.1.4</span>使用派生子类型加载列对象</h4>
                  <div>
                     <p>您可以使用派生的子类型加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">例11-4</a>显示了一个案例，其中扩展了非最终基础对象类型以创建新的派生子类型。尽管表定义中的列对象声明为基础对象类型，但SQL * Loader允许将任何子类型加载到列对象中，前提是子类型是从基础对象类型派生的。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">
                        <p class="titleinexample">示例11-4使用子类型加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5））; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），person person_type）;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE人员字段终止于'，'选择性封装'''（deptno INTEGER EXTERNAL（3），deptname CHAR， <span class="bold">1</span>人COLUMN OBJECT TREAT AS employee_type（姓名CHAR，ssn INTEGER EXTERNAL（9） ）， <span class="bold">2</span> empid INTEGER EXTERNAL（5）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，Johny Q.，301189453,10249,237，Physics，“Albert Einstein”，128606590,10030，</pre><div class="infoboxnote" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__GUID-F3D7F6D8-32B3-4C9C-908D-0AFD71F0BAB4">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TREAT</code> <code class="codeph">AS</code>子句指示SQL * Loader应该将列对象<code class="codeph">person</code>视为声明为派生类型<code class="codeph">employee_type</code> ，而不是其实际声明的类型<code class="codeph">person_type</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>此处允许使用<code class="codeph">empid</code>属性，因为它是<code class="codeph">employee_type</code>的属性。如果尚未指定<code class="codeph">TREAT</code> <code class="codeph">AS</code>子句，则此属性将导致错误，因为它不是列声明类型的属性。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1252"></a><div class="props_rev_3"><a id="GUID-C2940706-C809-4E42-886B-F13D35E54A43" name="GUID-C2940706-C809-4E42-886B-F13D35E54A43"></a><h4 id="SUTIL-GUID-C2940706-C809-4E42-886B-F13D35E54A43" class="sect4"><span class="enumeration_section">11.1.5</span>指定对象的空值</h4>
                  <div>
                     <p>您可以为对象指定空值。</p>
                     <div class="section">
                        <p>为非标量数据类型指定空值比标量数据类型稍微复杂一些。对象可以使其属性的子集为null，它可以使其所有属性为null（属性为null的对象），或者它本身可以为null（原子空对象）。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357">指定属性空值</a><br>您可以指定属性null。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3">指定原子空间</a><br>您可以指定原子空值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3364"></a><a id="SUTIL3363"></a><a id="SUTIL1253"></a><div class="props_rev_3"><a id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" name="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357"></a><h5 id="SUTIL-GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" class="sect5"><span class="enumeration_section">11.1.5.1</span>指定属性空值</h5>
                     <div>
                        <p>您可以指定属性null。</p>
                        <div class="section">
                           <p>在与列对象对应的字段中，可以使用<code class="codeph">NULLIF</code>子句指定应将特定属性初始化为<code class="codeph">NULL</code>的字段条件。 <a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">例11-5</a>说明了这一点。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">
                           <p class="titleinexample">示例11-5使用NULLIF子句指定属性空值</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE departments（dept_no POSITION（01:03）CHAR，dept_name POSITION（05:15）CHAR NULLIF dept_name = BLANKS，dept_mgr COLUMN OBJECT <span class="bold">1</span> （name POSITION（17:33）CHAR NULLIF dept_mgr。 name = BLANKS， <span class="bold">1</span> age POSITION（35:37）INTEGER EXTERNAL NULLIF dept_mgr.age = BLANKS， <span class="bold">1</span> emp_id POSITION（40:46）INTEGER EXTERNAL NULLIF dept_mgr.empid = BLANKS））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span> 101 Johny Quest 1024 237 Physics Albert Einstein 65 0000</pre><div class="infoboxnote" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__GUID-9E838423-5CA3-4238-881B-8E4BD49EF0F0">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>与每个属性对应的<code class="codeph">NULLIF</code>子句指出属性值应为<code class="codeph">NULL</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">dept_mgr</code>值的age属性为null。<code class="codeph">dept_name</code>值也为null。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="您可以为对象指定空值。">指定对象的空值</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3366"></a><a id="SUTIL3365"></a><a id="SUTIL1254"></a><div class="props_rev_3"><a id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" name="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3"></a><h5 id="SUTIL-GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" class="sect5"><span class="enumeration_section">11.1.5.2</span>指定原子空值</h5>
                     <div>
                        <p>您可以指定原子空值。</p>
                        <div class="section">
                           <p>要在控制文件中指定特定对象应采用空值（原子空值）的条件，必须使用基于任何映射字段的逻辑组合的<code class="codeph">NULLIF</code>子句跟随该对象的名称（例如，在<a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">示例中）在图11-5中</a> ，命名的映射字段将是<code class="codeph">dept_no</code> ， <code class="codeph">dept_name</code> ， <code class="codeph">name</code> ， <code class="codeph">age</code> ， <code class="codeph">emp_id</code> ，但是<code class="codeph">dept_mgr</code>将不是命名的映射字段，因为它不对应（未映射）数据文件中的任何字段）。
                           </p>
                           <p>尽管前面的内容是可行的，但是当对象应该采用null值的条件<span class="italic">独立于任何映射字段</span>时，它并不理想<span class="italic">。</span> 在这种情况下，您可以使用填充字段。
                           </p>
                           <p>您可以将填充字段映射到数据文件中的字段（指示特定对象是否在原子上为空），并在特定对象的<code class="codeph">NULLIF</code>子句的字段条件中使用填充字段。这在<a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">例11-6中显示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">
                           <p class="titleinexample">示例11-6使用填充字段加载数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_v2 FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30）， <span class="bold">1</span> is_null FILLER CHAR， <span class="bold">2</span> dept_mgr COLUMN OBJECT NULLIF is_null = BLANKS（ name CHAR（30）NULLIF dept_mgr.name = BLANKS，age INTEGER EXTERNAL（3）NULLIF dept_mgr.age = BLANKS，emp_id INTEGER EXTERNAL（7）NULLIF dept_mgr.emp_id = BLANKS，em_contact COLUMN OBJECT NULLIF is_null2 = BLANKS（name CHAR（30） ）NULLIF dept_mgr.em_contact.name = BLANKS，phone_num CHAR（20）NULLIF dept_mgr.em_contact.phone_num = BLANKS））， <span class="bold">1</span> is_null2 FILLER CHAR）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，n，Johny Q。,, 1024，“Barbie”，608-251-0010 ,, 237，Physics，“Albert Einstein”，65,0000，650-654-3210，n，</pre><div class="infoboxnote" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__GUID-2910EC31-5FC5-497B-9541-EE8BBDA98686">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>填充字段（映射的数据文件;没有对应的列）是<code class="codeph">CHAR</code>类型（因为它是分隔字段， <code class="codeph">CHAR</code>默认为<code class="codeph">CHAR(255)</code> ）。请注意， <code class="codeph">NULLIF</code>子句不适用于填充字段本身</p>
                                 </li>
                                 <li>
                                    <p>如果<code class="codeph">is_null</code>字段为空，则获取null（atomic null）的值。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="您可以为对象指定空值。">指定对象的空值</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL3368"></a><a id="SUTIL3371"></a><a id="SUTIL3367"></a><a id="SUTIL3369"></a><a id="SUTIL3370"></a><a id="SUTIL1255"></a><div class="props_rev_3"><a id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" name="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB"></a><h4 id="SUTIL-GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" class="sect4"><span class="enumeration_section">11.1.6</span>使用用户定义的构造函数加载列对象</h4>
                  <div>
                     <p>您可以使用用户定义的构造函数加载列对象。</p>
                     <div class="section">
                        <p>Oracle数据库自动为每种对象类型提供默认构造函数。此构造函数要求在调用构造函数时将该类型的所有属性指定为参数。创建对象的新实例时，其属性将采用参数列表中的相应值。此构造函数称为属性值构造函数。加载列对象时，SQL * Loader默认使用属性值构造函数。</p>
                        <p>可以通过创建一个或多个用户定义的构造函数来覆盖属性值构造函数。创建用户定义的构造函数时，必须提供一个类型体，只要创建对象的新实例，该体就会执行用户定义的逻辑。用户定义的构造函数可以具有与属性值构造函数相同的参数列表，但其类型体实现的逻辑不同。</p>
                        <p>当用户定义的构造函数的参数列表与属性值构造函数的参数列表匹配时，传统路径和直接路径SQL * Loader之间的行为存在差异。常规路径模式导致对用户定义的构造函数的调用。直接路径模式导致对属性值构造函数的调用。<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">例11-7</a>说明了这种差异。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">
                        <p class="titleinexample">示例11-7使用匹配的构造函数加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5）， - 用户定义的构造函数，看起来像属性值构造函数CONSTRUCTOR FUNCTION employee_type（名称VARCHAR2，ssn NUMBER，empid NUMBER）RETURN SELF AS RESULT）; CREATE TYPE BODY employee_type AS CONSTRUCTOR FUNCTION employee_type（名称VARCHAR2，ssn NUMBER，empid NUMBER）RETURN SELF AS RESULT AS  - 用户定义的构造函数确保name属性为大写。BEGIN SELF.name：= UPPER（姓名）; SELF.ssn：= ssn; SELF.empid：= empid;返回;结束; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），employee employee_type）;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">负载数据传输*替换为表格人员字段，由'''选择性地封装'（'deptno INTEGER EXTERNAL（3），deptname CHAR，员工COLUMN OBJECT（名称CHAR，ssn INTEGER EXTERNAL（9），empid INTEGER EXTERNAL（5） ）））BEGINDATA <span class="bold">1</span> 101，Mathematics，Johny Q.，301189453,10249,237，Physics，“Albert Einstein”，128606590,10030，</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-443036F0-BC42-46A4-BA03-67BF5AFD39D2">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>当此控制文件以常规路径模式运行时，名称字段<code class="codeph">Johny</code> <code class="codeph">Q.</code>和<code class="codeph">Albert</code> <code class="codeph">Einstein</code>都以大写形式加载。这是因为在此模式下调用了用户定义的构造函数。相反，当此控制文件以直接路径模式运行时，名称字段的加载方式与输入数据中显示的完全相同。这是因为在此模式下调用属性值构造函数。
                                 </p>
                              </li>
                           </ol>
                           <p>可以创建一个用户定义的构造函数，其参数列表与属性值构造函数的参数列表不匹配。在这种情况下，传统路径模式和直接路径模式都将导致对属性值构造函数的调用。考虑<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">例11-8中</a>的定义。
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">
                        <p class="titleinexample">示例11-8使用不匹配的构造函数加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE SEQUENCE employee_ids以1增加1000; CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5）， - 用户定义的构造函数，看起来不像属性值 - 构造函数CONSTRUCTOR FUNCTION employee_type（name VARCHAR2，ssn NUMBER）RETURN SELF AS RESULT）; CREATE TYPE BODY employee_type AS CONSTRUCTOR FUNCTION employee_type（name VARCHAR2，ssn NUMBER）RETURN SELF AS RESULT AS  - 此用户定义的构造函数确保name属性为 - 小写，并根据序列分配员工标识符。nextid NUMBER; stmt VARCHAR2（64）; BEGIN stmt：='SELECT employee_ids.nextval FROM DUAL'; EXECUTE IMMEDIATE stmt INTO nextid; SELF.name：= LOWER（名字）; SELF.ssn：= ssn; SELF.empid：= nextid;返回;结束; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），employee employee_type）;</pre><p>如果将<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">示例11-7中</a>描述的控制文件与这些定义一起使用，则名称字段的加载方式与输入数据中显示的完全相同（即大小写混合）。这是因为在常规和直接路径模式下都会调用属性值构造函数。
                        </p>
                        <p>通过在SQL表达式中显式引用用户定义的构造函数，仍然可以使用常规路径模式加载此表。<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">例11-9</a>显示了如何做到这一点。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">
                        <p class="titleinexample">示例11-9在构造函数不匹配时使用SQL加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE *替换为表格人员字段，由'''（由deptno INTEGER EXTERNAL（3），deptname CHAR，名字BOUNDFILLER CHAR，ssn BOUNDFILLER INTEGER EXTERNAL（9）， <span class="bold">1</span>名员工EXPRESSION“employee_type（： NAME，：SSN）“）BEGINDATA <span class="bold">1</span> 101，Mathematics，Johny Q.，301189453,237，Physics，”Albert Einstein“，128606590，</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-33CE2A54-788D-4ADC-ABDB-D12184DC4CBF">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>当此控制文件以常规路径模式运行时，名称字段<code class="codeph">Johny</code> <code class="codeph">Q.</code>和<code class="codeph">Albert</code> <code class="codeph">Einstein</code>都以大写形式加载。这是因为在此模式下调用了用户定义的构造函数。相反，当此控制文件以直接路径模式运行时，名称字段的加载方式与输入数据中显示的完全相同。这是因为在此模式下调用属性值构造函数。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>如果在直接路径模式下使用<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">示例11-9中</a>的控制文件，则报告以下错误：</p><pre class="oac_no_warn" dir="ltr">SQL * Loader-951：调用一次/加载初始化时出错ORA-26052：EMPLOYEE列上的SQL表达式不支持类型121。</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3374"></a><a id="SUTIL3372"></a><a id="SUTIL3373"></a><a id="SUTIL1256"></a><div class="props_rev_3"><a id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" name="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7"></a><h3 id="SUTIL-GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" class="sect3"><span class="enumeration_section">11.2</span>加载对象表</h3>
               <div>
                  <p>加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。</p>
                  <div class="section">
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">例11-10</a>演示了如何使用基于主键的对象标识符（OID）加载对象表。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">
                     <p class="titleinexample">示例11-10使用主键OID加载对象表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'DISCARDFILE'sample.dsc'BADFILE'sample.bad'REPLACE INTO TABLE员工字段终止于'，'选项封装'''（名称CHAR（30）NULLIF名称= BLANKS，年龄INTEGER EXTERNAL （3）NULLIF年龄= BLANKS，emp_id INTEGER EXTERNAL（5））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，18,007，Speed Racer，16,000，</pre><p>通过仅查看前面的控制文件，您可能无法确定正在加载的表是具有系统生成的OID的对象表，具有基于主键的OID的对象表还是关系表。</p>
                     <p>您可能希望加载已包含系统生成的OID的数据，并指定不应生成新的OID，而应使用数据文件中的现有OID。为此，您将遵循带有<code class="codeph">OID</code>子句的<code class="codeph">INTO</code> <code class="codeph">TABLE</code>子句：</p><pre class="oac_no_warn" dir="ltr">OID（ <span class="italic">字段名称</span> ）</pre><p>在此子句中， <span class="italic"><code class="codeph">fieldname</code></span>是字段规范列表中的一个字段（通常是填充字段）的名称，该字段映射到包含系统生成的OID的数据字段。SQL * Loader假定提供的OID格式正确，并且它们保留了OID全局唯一性。因此，为了确保唯一性，您应该使用Oracle OID生成器生成要加载的OID。
                     </p>
                     <p><code class="codeph">OID</code>子句只能用于系统生成的OID，而不能用于基于主键的OID。
                     </p>
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">例11-11</a>演示了如何使用行对象加载系统生成的OID。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">
                     <p class="titleinexample">示例11-11加载OID</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE employees_v2 <span class="bold">1</span> OID（s_oid）FIELDS终止于'，'选项封装'''（名称CHAR（30）NULLIF名称= BLANKS，年龄INTEGER EXTERNAL（3）NULLIF年龄= BLANKS， emp_id INTEGER EXTERNAL（5）， <span class="bold">2</span> s_oid FILLER CHAR（32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span> Johny Quest，18,007,21E978406D3E41FCE03400400B403BC3，Speed Racer，16,000,21E978406D4441FCE03400400B403BC3，</pre><div class="infoboxnote" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__GUID-27E9E7A0-00BC-4899-A68B-224F13DA73DF">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p><code class="codeph">OID</code>子句指定<code class="codeph">s_oid</code>加载程序字段包含OID。括号是必需的</p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">s_oid</code>不包含有效的十六进制数，则拒绝特定记录。
                              </p>
                           </li>
                           <li>
                              <p>数据文件中的OID是字符串，并被解释为32位十六进制数。32位十六进制数后来转换为16字节<code class="codeph">RAW</code>并存储在对象表中。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E">使用子类型加载对象表</a><br>如果对象表的行对象基于非最终类型，则SQL * Loader允许将任何派生的子类型加载到对象表中。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3376"></a><a id="SUTIL3375"></a><a id="SUTIL1257"></a><div class="props_rev_3"><a id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" name="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E"></a><h4 id="SUTIL-GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" class="sect4"><span class="enumeration_section">11.2.1</span>使用子类型加载对象表</h4>
                  <div>
                     <p>如果对象表的行对象基于非最终类型，则SQL * Loader允许将任何派生的子类型加载到对象表中。</p>
                     <div class="section">
                        <p>如前所述，使用派生子类型加载对象表所需的语法几乎与用于典型关系表的语法相同。但是，在这种情况下，必须命名要使用的实际子类型，以便SQL * Loader可以确定它是否是对象表的有效子类型。<a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">例11-12</a>说明了这个概念。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">
                        <p class="titleinexample">示例11-12使用子类型加载对象表</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employees_type AS OBJECT（名称VARCHAR2（30），年龄NUMBER（3），emp_id NUMBER（5））不是最终的; CREATE TYPE hourly_emps_type UNDER employees_type（小时NUMBER（3））; employee_type的CREATE TABLE employees_v3;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE employees_v3 <span class="bold">1</span> TREAT AS hourly_emps_type FIELDS TERMINATED BY'，'（姓名CHAR（30），年龄INTEGER EXTERNAL（3），emp_id INTEGER EXTERNAL（5）， <span class="bold">2</span>小时INTEGER EXTERNAL（2））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，18,007,32，Speed Racer，16,000，20，</pre><div class="infoboxnote" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__GUID-1DDDD770-D862-4499-AD69-7B28D777E46F">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TREAT</code> <code class="codeph">AS</code>子句指示SQL * Loader应该将对象表视为声明为类型为<code class="codeph">hourly_emps_type</code> ，而不是其实际声明的类型<code class="codeph">employee_type</code></p>
                              </li>
                              <li>
                                 <p>这里允许使用<code class="codeph">hours</code>属性，因为它是<code class="codeph">hourly_emps_type</code>的属性。如果尚未指定<code class="codeph">TREAT</code> <code class="codeph">AS</code>子句，则此属性将导致错误，因为它不是对象表的声明类型的属性。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" title="加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。">加载对象表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1258"></a><div class="props_rev_3"><a id="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" name="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8"></a><h3 id="SUTIL-GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" class="sect3"><span class="enumeration_section">11.3</span>加载REF列</h3>
               <div>
                  <p>SQL * Loader可以加载系统生成的OID <code class="codeph">REF</code>列，基于主键的<code class="codeph">REF</code>列和允许主键的未作用域<code class="codeph">REF</code>列。
                  </p>
                  <p>对于其中的每一个，指定表名的方式很重要，如以下部分所述。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02">在REF子句中指定表名</a><br>您可以在REF子句中指定表名。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E">系统生成的OID REF列</a><br>在加载系统生成的<code class="codeph">REF</code>列时，SQL * Loader假定从中构造<code class="codeph">REF</code>列的实际OID位于包含其余数据的数据文件中。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54">主键REF列</a><br>要加载主键<code class="codeph">REF</code>列，SQL * Loader控制文件字段说明必须提供列名后跟<code class="codeph">REF</code>子句。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E">允许主键的无范围REF列</a><br>允许主键的无范围<code class="codeph">REF</code>列可以引用系统生成的和主键<code class="codeph">REF</code> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1259"></a><div class="props_rev_3"><a id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" name="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02"></a><h4 id="SUTIL-GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" class="sect4"><span class="enumeration_section">11.3.1</span>在REF子句中指定表名</h4>
                  <div>
                     <p>您可以在REF子句中指定表名。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02__GUID-460B1246-3443-42E7-B86C-02669480DEDF">
                           <p class="notep1">注意：</p>
                           <p>本节中的信息仅适用于SQL * Loader和Oracle Database的发行版均为11 <span class="italic">g</span>版本1（11.1）或更高版本的环境。它不适用于SQL * Loader，Oracle数据库或两者都处于早期版本的环境。
                           </p>
                        </div>
                        <p>在SQL * Loader控制文件中，与<code class="codeph">REF</code>列对应的字段的描述由列名称后跟REF子句组成。REF子句将表名和适用于正在加载的<code class="codeph">REF</code>列类型的任何属性作为参数。表名可以动态指定（使用填充字段）或作为常量指定。也可以使用或不使用模式名称指定表名。
                        </p>
                        <p>无论REF子句中指定的表名是指定为常量还是使用填充字段，都将其解释为区分大小写。这可能会导致以下情况：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果用户<code class="codeph">SCOTT</code>在表名周围创建了一个名为<code class="codeph">table2</code> ，而且没有引号，则可以通过以下任何方式在REF子句中使用它：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">REF（常数'TABLE2'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常数'“TABLE2”'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常量'SCOTT.TABLE2'，...）</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果用户<code class="codeph">SCOTT</code>使用混合大小写名称周围的引号创建名为<code class="codeph">"Table2"</code>的表，则可以通过以下任何方式在REF子句中使用它：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">REF（常数'Table2'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常数'“表2”'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常量'SCOTT.Table2'，...）</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>在这两种情况下，如果使用填充字段替换<code class="codeph">constant</code> ，则如果将它们放在数据部分中，则示例中显示的相同值也将起作用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3378"></a><a id="SUTIL3377"></a><a id="SUTIL1260"></a><div class="props_rev_3"><a id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" name="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E"></a><h4 id="SUTIL-GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" class="sect4"><span class="enumeration_section">11.3.2</span>系统生成的OID REF列</h4>
                  <div>
                     <p>在加载系统生成的<code class="codeph">REF</code>列时，SQL * Loader假定从中构造<code class="codeph">REF</code>列的实际OID位于包含其余数据的数据文件中。
                     </p>
                     <div class="section">
                        <p>对应于<code class="codeph">REF</code>列的字段的描述由列名称后跟<code class="codeph">REF</code>子句组成。
                        </p>
                        <p><code class="codeph">REF</code>子句将表名和OID作为参数。请注意，参数可以指定为常量或动态指定（使用填充字段）。请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a>以获取适当的语法。<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">例11-13</a>演示了加载系统生成的OID <code class="codeph">REF</code>列。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">
                        <p class="titleinexample">例11-13加载系统生成的REF列</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_alt_v2 FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30）， <span class="bold">1</span> dept_mgr REF（t_name，s_oid），s_oid FILLER CHAR（32 ），t_name FILLER CHAR（30））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">22345，QuestWorld，21E978406D3E41FCE03400400B403BC3，EMPLOYEES_V2,23423，Geography，21E978406D4441FCE03400400B403BC3，EMPLOYEES_V2，</pre><div class="infoboxnote" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__GUID-C7ABDD8B-A9B0-4B5D-8FC5-229D452C0EB9">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>如果指定的表不存在，则拒绝该记录。<code class="codeph">dept_mgr</code>字段本身不映射到数据文件中的任何字段。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3379"></a><a id="SUTIL1261"></a><div class="props_rev_3"><a id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54" name="GUID-99A7B7BD-B555-4457-975C-C4E038632B54"></a><h4 id="SUTIL-GUID-99A7B7BD-B555-4457-975C-C4E038632B54" class="sect4"><span class="enumeration_section">11.3.3</span>主键REF列</h4>
                  <div>
                     <p>要加载主键<code class="codeph">REF</code>列，SQL * Loader控制文件字段说明必须提供列名后跟<code class="codeph">REF</code>子句。
                     </p>
                     <div class="section">
                        <p><code class="codeph">REF</code>子句为参数提供以逗号分隔的字段名称和常量值列表。第一个参数是表名，后跟参数，用于指定要加载的<code class="codeph">REF</code>列所基于的主键OID。请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a>以获取适当的语法。
                        </p>
                        <p>SQL * Loader假定参数的排序与构成引用表中主键OID的列的相对排序相匹配。<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">例11-14</a>演示了加载主键<code class="codeph">REF</code>列。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">
                        <p class="titleinexample">示例11-14加载主键REF列</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_alt FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30），dept_mgr REF（CONSTANT'EMPLOYEES'，emp_id），emp_id FILLER CHAR （32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">22345，QuestWorld，007,23423，Geography，000，</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1262"></a><div class="props_rev_3"><a id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" name="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E"></a><h4 id="SUTIL-GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" class="sect4"><span class="enumeration_section">11.3.4</span>允许主键的无范围REF列</h4>
                  <div>
                     <p>允许主键的无范围<code class="codeph">REF</code>列可以引用系统生成的和主键<code class="codeph">REF</code> 。
                     </p>
                     <p>加载到此类<code class="codeph">REF</code>列的语法与加载到系统生成的OID <code class="codeph">REF</code>列或基于主键的<code class="codeph">REF</code>列中的语法相同。参见<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">例11-13</a>和<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">例11-14</a> 。
                     </p>
                     <p>加载到允许主键的未作用域<code class="codeph">REF</code>列时，以下限制适用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在单表加载期间，此列只能引用一种类型的<code class="codeph">REF</code> ，系统生成的或主键，但不能同时引用这两种<code class="codeph">REF</code> 。如果您尝试引用这两种类型，那么数据行将被拒绝，并显示一条错误消息，指出引用的表名无效。
                           </p>
                        </li>
                        <li>
                           <p>如果要将未作用域的主键<code class="codeph">REF</code>加载到此列，则在单表加载期间只能引用一个对象表。也就是说，要加载未扩展的主键<code class="codeph">REF</code> ，一些指向对象表X，一些指向对象表Y，则必须执行以下操作之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>执行两个单表加载。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">WHEN</code>子句关闭数据某些方面的多个<code class="codeph">INTO</code> <code class="codeph">TABLE</code>子句执行单个加载，例如未绑定的主键<code class="codeph">REF</code>的对象表名称。例如：</p><pre class="oac_no_warn" dir="ltr">当CUST_TBL =“CUSTOMERS_PK”字段以“，”（order_no position（1）char，cust_tbl FILLER char，cust_no FILLER char，cust REF（cust_tbl，cust_no））终止时，LOAD DATA INFILE'Data.dat'INTO TABLE orders_apk APPEND NULLIF order_no = '0'）INTO TABLE orders_apk APPEND当CUST_TBL =“CUSTOMERS_PK2”字段以“，”结束时（order_no position（1）char，cust_tbl FILLER char，cust_no FILLER char，cust REF（cust_tbl，cust_no）NULLIF order_no ='0'）</pre></li>
                           </ul>
                           <p>如果不使用这些方法中的任何一种，则数据行将被拒绝，并显示一条错误消息，指出引用的表名无效。</p>
                        </li>
                        <li>
                           <p>SQL * Loader不支持集合中的无范围主键<code class="codeph">REF</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果要将系统生成的<code class="codeph">REF</code>加载到此<code class="codeph">REF</code>列中，则<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" title="在加载系统生成的REF列时，SQL * Loader假定从中构造REF列的实际OID位于包含其余数据的数据文件中。">系统生成的OID REF列中</a>描述的任何限制也适用于此处。
                           </p>
                        </li>
                        <li>
                           <p>如果要将主键<code class="codeph">REF</code>加载到此<code class="codeph">REF</code>列中，则<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54" title="要加载主键REF列，SQL * Loader控制文件字段说明必须提供列名后跟REF子句。">主键REF列中</a>描述的任何限制也适用于此处。
                           </p>
                           <div class="infoboxnote" id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E__GUID-812DC3BE-E73D-468F-A047-6A7CAC5DC4A7">
                              <p class="notep1">注意：</p>
                              <p>对于允许主键的未作用域<code class="codeph">REF</code>列，SQL * Loader获取解析的第一个有效对象表（来自<code class="codeph">REF</code>指令或数据行）并使用该对象表的OID类型来确定可在其中引用的<code class="codeph">REF</code>类型单表负载。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1263"></a><div class="props_rev_3"><a id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80" name="GUID-3637F462-436A-4F6B-B243-03FB3177CA80"></a><h3 id="SUTIL-GUID-3637F462-436A-4F6B-B243-03FB3177CA80" class="sect3"><span class="enumeration_section">11.4</span>加载LOB</h3>
               <div>
                  <p>该部分描述了加载LOB。</p>
                  <p>LOB是一种<span class="italic">大型对象类型。</span> SQL * Loader支持以下类型的LOB：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">BLOB</code> ：包含非结构化二进制数据的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOB</code> ：包含字符数据的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">NCLOB</code> ：包含来自国家字符集的字符的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">BFILE</code> ：存储在服务器端操作系统文件中的数据库表空间之外的<code class="codeph">BLOB</code></p>
                     </li>
                  </ul>
                  <p>LOB可以是列数据类型，除<code class="codeph">NCLOB</code> ，它们可以是对象的属性数据类型。LOB可以有实际值，它们可以为null，也可以为空。当存在要在LOB中存储的0长度字段时，SQL * Loader会创建一个空LOB。 （请注意，这与其他数据类型不同，其中SQL * Loader将任何0长度字符串的列设置为NULL。）这意味着将<span class="italic">NULL值加载到LOB列的唯一方法是使用NULLIF子句。</span></p>
                  <p><code class="codeph">XML</code>列是声明为<code class="codeph">SYS</code>类型的列。 <code class="codeph">XMLTYPE</code> 。 SQL * Loader将<code class="codeph">XML</code>列视为<code class="codeph">CLOB</code> 。以下各节中描述的用于从主数据文件或LOBFILE加载LOB数据的所有方法都适用于加载<code class="codeph">XML</code>列。
                  </p>
                  <div class="infoboxnote" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-06840CCC-CAEF-418F-8AB7-BC1F35FA2F30">
                     <p class="notep1">注意：</p>
                     <p>您不能为LOB字段指定SQL字符串。即使您指定<code class="codeph">LOBFILE_spec</code>也是如此。
                     </p>
                  </div>
                  <p>由于LOB可能非常大，因此SQL * Loader可以从主数据文件（与其余数据一致）或从LOBFILE加载LOB数据，如以下部分所述：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9">从主数据文件加载LOB数据</a><br>您可以从主数据文件加载LOB列。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3">从LOBFILE加载LOB数据</a><br>LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB">加载包含LLS字段的数据文件</a><br>如果数据文件中的字段是LOB位置说明符（LLS）字段，则可以使用<code class="codeph">LLS</code>子句指示此字段。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-C59A3A12-0A60-4069-BC84-B6107D75F3D6">
                     <p class="notep1">也可以看看：</p>
                     <p>有关大对象（LOB）数据类型的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50994" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1264"></a><div class="props_rev_3"><a id="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" name="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9"></a><h4 id="SUTIL-GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" class="sect4"><span class="enumeration_section">11.4.1</span>从主数据文件加载LOB数据</h4>
                  <div>
                     <p>您可以从主数据文件加载LOB列。</p>
                     <p>要从主数据文件加载内部LOB（ <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code> ）或<code class="codeph">XML</code>列，可以使用以下标准SQL * Loader格式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>预定大小的字段</p>
                        </li>
                        <li>
                           <p>划界的字段</p>
                        </li>
                        <li>
                           <p>长度 - 值对字段</p>
                        </li>
                     </ul>
                     <p>以下各节介绍了这些格式中的每一种。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0">预定大小字段中的LOB数据</a><br>您可以将LOB数据加载到预定大小的字段中。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB">分隔字段中的LOB数据</a><br>您可以将LOB数据加载到分隔字段中。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200">长度 - 值对字段中的LOB数据</a><br>您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载在长度 - 值对字段中组织的LOB数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3381"></a><a id="SUTIL3380"></a><a id="SUTIL1265"></a><div class="props_rev_3"><a id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" name="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0"></a><h5 id="SUTIL-GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" class="sect5"><span class="enumeration_section">11.4.1.1</span>预定大小字段中的LOB数据</h5>
                     <div>
                        <p>您可以将LOB数据加载到预定大小的字段中。</p>
                        <div class="section">
                           <p>这是一种非常快速且概念上简单的格式，可以在其中加载LOB，如<a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">例11-15</a>所示。
                           </p>
                           <div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-C2207E1E-1554-40A4-BD9F-4DE696F36D9D">
                              <p class="notep1">注意：</p>
                              <p>由于您加载的LOB大小可能不同，因此您可以使用空格填充LOB数据，以使LOB在特定数据字段中的长度相等。</p>
                           </div>
                           <p>要使用此格式加载LOB，应使用<code class="codeph">CHAR</code>或<code class="codeph">RAW</code>作为加载数据类型。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">
                           <p class="titleinexample">示例11-15在预定大小字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“fix 501”INTO TABLE person_table（名称POSITION（01:21）CHAR， <span class="bold">1</span> “RESUME”POSITION（23：500）CHAR DEFAULTIF“RESUME”= BLANKS）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer Julia Nayer 500示例Parkway jnayer@us.example.com ...</pre><div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-E336CB2A-06F4-4B14-B89D-D6E5AE6257F1">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>由于使用了<code class="codeph">DEFAULTIF</code>子句，如果包含resume的数据字段为空，则结果为空LOB而不是空LOB。但是，如果使用<code class="codeph">NULLIF</code>子句而不是<code class="codeph">DEFAULTIF</code> ，则空数据字段将为null。
                                    </p>
                                    <p>您可以使用<code class="codeph">CHAR</code>以外的SQL * Loader数据类型来加载LOB。例如，在加载<code class="codeph">BLOB</code> ，您可能希望使用<code class="codeph">RAW</code>数据类型。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3383"></a><a id="SUTIL3382"></a><a id="SUTIL1266"></a><div class="props_rev_3"><a id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" name="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB"></a><h5 id="SUTIL-GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" class="sect5"><span class="enumeration_section">11.4.1.2</span>分隔字段中的LOB数据</h5>
                     <div>
                        <p>您可以将LOB数据加载到分隔字段中。</p>
                        <p>此格式在同一列（数据文件字段）中处理不同大小的LOB而没有问题。但是，这种增加的灵活性会影响性能，因为SQL * Loader必须扫描数据，查找分隔符字符串。</p>
                        <p>与单字符分隔符一样，当您指定字符串分隔符时，应考虑数据文件的字符集。当数据文件的字符集与控制文件的字符集不同时，可以用十六进制表示法指定分隔符（即<span class="italic"><code class="codeph">X'hexadecimal</code></span> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">'</code> ）。如果以十六进制表示法指定分隔符，则规范必须包含在输入数据文件的字符集中有效的字符。相反，如果未使用十六进制表示法，则定界符规范被认为是在客户端（即控制文件的）字符集中。在这种情况下，在SQL * Loader搜索数据文件中的分隔符之前，分隔符将转换为数据文件的字符集。
                        </p>
                        <p>请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>字符串分隔符支持Stutter语法（也就是说，封闭的机箱分隔符可能是断断续续的）。</p>
                           </li>
                           <li>
                              <p>不允许在初始多字符机箱分隔符中使用前导空格。</p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">WHITESPACE</code>终止某个字段，则会修剪前导空格。
                              </p>
                              <div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-F57761C4-9E21-43DA-853D-881E7E4B5114">
                                 <p class="notep1">注意：</p>
                                 <p>移动<code class="codeph">CLOB</code>数据时，SQL * Loader默认为255个字节，但可以指定最多2千兆字节的值。对于分隔字段，如果指定了长度，则将该长度用作最大值。如果未指定maximum，则默认为255个字节。对于分隔且大于255个字节的<code class="codeph">CHAR</code>字段，必须指定最大长度。见<a href="oracle-sql-loader-field-list-contents.html#GUID-34A526C6-C2E6-4D17-8F53-D0CDEF38874B">CHAR</a>有关详细信息， <code class="codeph">CHAR</code>数据类型。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">例11-16</a>显示了在分隔字段中加载LOB数据的示例。
                        </p>
                        <div class="example" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">
                           <p class="titleinexample">示例11-16在分隔字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“str'|'”INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（25）， <span class="bold">1</span> “RESUME”CHAR（507）包含在'&lt;startlob&gt;'和'&lt;endlob&gt; “）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer，&lt;startlob&gt; Julia Nayer 500示例Parkway jnayer@us.example.com ... &lt;endlob&gt; <span class="bold">2</span> | Bruce Ernst，.......</pre><div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-A951C3DE-B7F4-4785-951F-559B8B4A09FF">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p><code class="codeph">&lt;startlob&gt;</code>和<code class="codeph">&lt;endlob&gt;</code>是机箱字符串。使用默认的字节长度语义，可以使用<code class="codeph">CHAR(507)</code>读取的LOB的最大长度为507个字节。如果使用了字符长度语义，则最大值为507个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a></p>
                                 </li>
                                 <li>
                                    <p>如果记录分隔符<code class="codeph">'|'</code>已经被放置在<code class="codeph">&lt;endlob&gt;</code>并且跟着换行符，然后换行符将被解释为下<code class="codeph">&lt;endlob&gt;</code>记录的一部分。另一种方法是使记录分隔符的换行符部分（例如， <code class="codeph">'|\n'</code>或以十六进制表示法， <code class="codeph">X'7C0A'</code> ）。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3385"></a><a id="SUTIL3384"></a><a id="SUTIL1267"></a><div class="props_rev_3"><a id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" name="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200"></a><h5 id="SUTIL-GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" class="sect5"><span class="enumeration_section">11.4.1.3</span>长度 - 值对字段中的LOB数据</h5>
                     <div>
                        <p>您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载在长度 - 值对字段中组织的LOB数据。
                        </p>
                        <p>这种加载方法提供了比使用分隔字段更好的性能，但可以降低灵活性（例如，您必须知道加载前每个LOB的LOB长度）。<a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">例11-17</a>演示了如何在长度 - 值对字段中加载LOB数据。
                        </p>
                        <div class="example" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">
                           <p class="titleinexample">例11-17在长度 - 值对字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA <span class="bold">1</span> INFILE'ample.dat'“str'&lt;endrec&gt; \ n'”INTO TABLE person_table FIELDS TERMINATED BY'，'（名称CHAR（25）， <span class="bold">2</span> “RESUME”VARCHARC（3,500））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer，479 Julia Nayer 500示例Parkway jnayer@us.example.com ... &lt;endrec&gt; <span class="bold">3</span> Bruce Ernst，000 &lt;endrec&gt;</pre><div class="infoboxnote" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__GUID-AEF0A144-BF31-49A5-9F67-40F8EF97BA98">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>如果不支持反斜杠转义字符，则示例中用作记录分隔符的字符串可以用十六进制表示法表示。</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">"RESUME"</code>是对应于<code class="codeph">CLOB</code>列的字段。在控制文件中，它是<code class="codeph">VARCHARC</code> ，其长度字段长度为3个字节，其最大大小为500个字节（具有字节长度语义）。如果使用字符长度语义，则长度为3个字符，最大大小为500个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">VARCHARC</code>的长度子字段为0（值子字段为空）。因此，LOB实例初始化为空。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1268"></a><div class="props_rev_3"><a id="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" name="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3"></a><h4 id="SUTIL-GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" class="sect4"><span class="enumeration_section">11.4.2</span>从LOBFILE加载LOB数据</h4>
                  <div>
                     <p>LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。</p>
                     <p>在LOBFILE中，LOB数据实例仍被认为是在字段中（预定大小，分隔符，长度值），但这些字段没有组织成记录（LOBFILE中不存在记录的概念）。因此，避免了处理记录的处理开销。这种类型的数据组织是LOB加载的理想选择。</p>
                     <p>不要求LOBFILE中的LOB适合内存。SQL * Loader以64 KB块的形式读取LOBFILE。</p>
                     <p>在LOBFILE中，数据可以是以下任何类型的字段：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>单个LOB字段，可以读取文件的全部内容</p>
                        </li>
                        <li>
                           <p>预定大小字段（固定长度字段）</p>
                        </li>
                        <li>
                           <p>分隔字段（即<code class="codeph">TERMINATED</code> <code class="codeph">BY</code>或<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code> ）</p>
                           <p><code class="codeph">PRESERVE</code> <code class="codeph">BLANKS</code>子句不适用于从LOBFILE读取的字段。</p>
                        </li>
                        <li>
                           <p>长度 - 值对字段（可变长度字段）</p>
                           <p>要从此类型的字段加载数据，请使用<code class="codeph">VARRAW</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">VARCHARC</code> SQL * Loader数据类型。
                           </p>
                        </li>
                     </ul>
                     <p>有关使用这些字段类型的示例，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据</a>的示例。所有前面提到的字段类型都可用于加载<code class="codeph">XML</code>列。
                     </p>
                     <p>有关LOBFILE语法，请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABEHEID">lobfile_spec</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E488305F-90E5-4FE8-B122-A9341F99C450">动态与静态LOBFILE规格</a><br>您可以静态指定LOBFILE（文件的名称在控制文件中指定）或动态指定（ <code class="codeph">FILLER</code>字段用作文件名的来源）。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475">从LOBFILE加载LOB数据的示例</a><br>本节包含从LOBFILE中的不同类型的字段加载数据的示例。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60">从LOBFILE加载LOB时的注意事项</a><br>从LOBFILE加载LOB时需要考虑的因素。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1269"></a><div class="props_rev_3"><a id="GUID-E488305F-90E5-4FE8-B122-A9341F99C450" name="GUID-E488305F-90E5-4FE8-B122-A9341F99C450"></a><h5 id="SUTIL-GUID-E488305F-90E5-4FE8-B122-A9341F99C450" class="sect5"><span class="enumeration_section">11.4.2.1</span>动态与静态LOBFILE规范</h5>
                     <div>
                        <p>您可以静态指定LOBFILE（文件的名称在控制文件中指定）或动态指定（ <code class="codeph">FILLER</code>字段用作文件名的来源）。
                        </p>
                        <p>在任何一种情况下，如果LOBFILE <span class="italic">没有</span>被EOF终止，那么当到达LOBFILE的末尾时，文件被关闭并且进一步尝试从该文件读取数据产生的结果相当于从空字段读取数据。
                        </p>
                        <p>但是，如果您有一个由EOF终止的LOBFILE， <span class="italic">则</span>每次尝试从该文件读取数据时都会返回整个文件。
                        </p>
                        <p>您不应该指定与两个不同字段的源相同的LOBFILE。如果这样做，那么这两个字段通常会独立读取数据。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1270"></a><div class="props_rev_3"><a id="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" name="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475"></a><h5 id="SUTIL-GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" class="sect5"><span class="enumeration_section">11.4.2.2</span>从LOBFILE加载LOB数据的示例</h5>
                     <div>
                        <p>本节包含从LOBFILE中的不同类型的字段加载数据的示例。</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E">每个文件一个LOB</a><br>每个LOBFILE在加载LOB数据时都是单个LOB的源。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6">预定尺寸LOB</a><br>您可以使用预定大小的LOB加载LOB数据。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84">定界LOB</a><br>您可以使用分隔的LOB加载LOB数据。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258">长度值对指定的LOB</a><br>您可以使用指定长度值对的LOB加载LOB数据。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="SUTIL3387"></a><a id="SUTIL3386"></a><a id="SUTIL1271"></a><div class="props_rev_3"><a id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" name="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E"></a><h6 id="SUTIL-GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" class="sect6"><span class="enumeration_section">11.4.2.2.1</span>每个文件一个LOB</h6>
                        <div>
                           <p>每个LOBFILE在加载LOB数据时都是单个LOB的源。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">例11-18中</a> ，每个LOBFILE是单个LOB的源。要加载以这种方式组织的LOB数据，列或字段名称后跟LOBFILE数据类型规范。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">
                              <p class="titleinexample">例11-18每个LOBFILE加载一个LOB的LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（名称CHAR（20）， <span class="bold">1</span> ext_fname FILLER CHAR（40）， <span class="bold">2</span> “RESUME”LOBFILE（ext_fname）由EOF终止）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，jqresume.txt，Speed Racer，'/ private / sracer / srresume.txt'，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ......</pre><p>辅助数据文件（srresume.txt）</p><pre class="oac_no_warn" dir="ltr">Speed Racer 400 Oracle Parkway ......</pre><div class="infoboxnote" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__GUID-96CCBFC1-F848-4D9F-BF58-CDF14A9C878A">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>填充字段映射到40字节数据字段，使用SQL * Loader <code class="codeph">CHAR</code>数据类型读取该数据字段。这假设使用默认的字节长度语义。如果使用了字符长度语义，则该字段将映射到40个字符的数据字段</p>
                                    </li>
                                    <li>
                                       <p>SQL * Loader从<code class="codeph">ext_fname</code>填充字段中获取LOBFILE名称。然后，它将LOBFILE（使用<code class="codeph">CHAR</code>数据类型）中的数据从第一个字节加载到EOF字符。如果未指定现有LOBFILE，则<code class="codeph">"RESUME"</code>字段初始化为空。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3389"></a><a id="SUTIL3388"></a><a id="SUTIL1272"></a><div class="props_rev_3"><a id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" name="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6"></a><h6 id="SUTIL-GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" class="sect6"><span class="enumeration_section">11.4.2.2.2</span>预定大小的LOB</h6>
                        <div>
                           <p>您可以使用预定大小的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">例11-19中</a> ，指定要加载到控制文件中特定列的LOB的大小。在加载期间，SQL * Loader假定加载到该特定列的任何LOB数据都具有指定的大小。预定大小的字段允许数据解析器最佳地执行。但是，通常很难保证所有LOB的大小相同。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">
                              <p class="titleinexample">例11-19使用预定大小的LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'/usr/private/jquest/jqresume.txt'）CHAR（2000））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ......Speed Racer 400 Oracle Parkway ......</pre><div class="infoboxnote" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__GUID-662CA784-A08B-4576-8C0E-34F3D066B87B">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>此条目指定SQL * Loader使用<code class="codeph">CHAR</code>数据类型从<code class="codeph">jqresume.txt</code> LOBFILE加载2000字节的数据，从当前加载会话期间最后加载的字节之后的字节开始。这假定使用默认的字节长度语义。如果使用了字符长度语义，则SQL * Loader将从最后加载字符后的第一个字符开始加载2000个字符的数据。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3391"></a><a id="SUTIL3390"></a><a id="SUTIL1273"></a><div class="props_rev_3"><a id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" name="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84"></a><h6 id="SUTIL-GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" class="sect6"><span class="enumeration_section">11.4.2.2.3定界</span> LOB</h6>
                        <div>
                           <p>您可以使用分隔的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">例11-20中</a> ，LOBFILE中的LOB数据实例是分隔的。在这种格式中，将不同大小的LOB加载到同一列中不是问题。但是，这种增加的灵活性会影响性能，因为SQL * Loader必须扫描数据，查找分隔符字符串。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">
                              <p class="titleinexample">示例11-20使用分隔LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'jqresume'）CHAR（2000）终止于“&lt;endlob&gt; \ n”）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ... &lt;endlob&gt; Speed Racer 400 Oracle Parkway ... &lt;endlob&gt;</pre><div class="infoboxnote" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__GUID-3471D8D4-23D6-4652-BCDA-08B9235DD881">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>因为为<code class="codeph">CHAR</code>指定了最大长度2000，所以SQL * Loader知道期望什么作为字段的最大长度，这可能导致内存使用优化。<span class="italic">如果您选择指定最大长度，那么您应该确保不要低估其值。</span> <code class="codeph">TERMINATED</code> <code class="codeph">BY</code>子句指定终止LOB的字符串。或者，您可以使用<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句。<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句允许LOBFILE中LOB的相对定位更加灵活（LOBFILE中的LOB不需要是顺序的）。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3393"></a><a id="SUTIL3392"></a><a id="SUTIL1274"></a><div class="props_rev_3"><a id="GUID-C04366D7-247F-421E-BBFC-446A61C15258" name="GUID-C04366D7-247F-421E-BBFC-446A61C15258"></a><h6 id="SUTIL-GUID-C04366D7-247F-421E-BBFC-446A61C15258" class="sect6"><span class="enumeration_section">11.4.2.2.4</span>长度 - 值对指定的LOB</h6>
                        <div>
                           <p>您可以使用指定长度值对的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">例11-21</a>中，LOBFILE中的每个LOB都以其长度开头。您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载以这种方式组织的LOB数据。
                              </p>
                              <p>这种加载方法可以提供比分隔LOB更好的性能，但代价是有一定的灵活性（例如，在加载之前必须知道每个LOB的LOB长度）。</p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">
                              <p class="titleinexample">例11-21使用长度值对指定的LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'jqresume'）VARCHARC（4,2000））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span> 0501Johny Quest 500 Oracle Parkway ...
<span class="bold">3</span> 0000</pre><div class="infoboxnote" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__GUID-91E8ACBD-800D-42C4-AF59-26ACA2BB691C">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>条目<code class="codeph">VARCHARC(4,2000)</code>告诉SQL * Loader LOBFILE中的LOB是长度 - 值对格式，前4个字节应该被解释为长度。<code class="codeph">2000</code>的值告诉SQL * Loader该字段的最大大小是2000字节。这假定使用默认的字节长度语义。如果使用了字符长度语义，则前4个字符将被解释为字符长度。字段的最大大小为2000个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">Johny</code> <code class="codeph">Quest</code>之前的条目<code class="codeph">0501</code>告诉SQL * Loader LOB由接下来的501个字符组成。
                                       </p>
                                    </li>
                                    <li>
                                       <p>此条目指定空（非空）LOB。</p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="SUTIL1275"></a><div class="props_rev_3"><a id="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" name="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60"></a><h5 id="SUTIL-GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" class="sect5"><span class="enumeration_section">11.4.2.3</span>从LOBFILE加载LOB时的注意事项</h5>
                     <div>
                        <p>从LOBFILE加载LOB时需要考虑的因素。</p>
                        <p>使用LOBFILE加载数据时请记住以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>只能从LOBFILE加载LOB和<code class="codeph">XML</code>列。
                              </p>
                           </li>
                           <li>
                              <p>加载特定LOB失败不会导致拒绝包含该LOB的记录。相反，您将拥有一个包含空LOB的记录。对于<code class="codeph">XML</code>列，如果加载LOB失败，将插入空值。</p>
                           </li>
                           <li>
                              <p>没有必要指定对应于LOB列的字段的最大长度。如果指定的最大<span class="italic">长度</span> ，则SQL * Loader使用它作为一个提示来优化存储器的使用。因此，重要的是最大长度规范不会低估真实的最大长度。
                              </p>
                           </li>
                           <li>
                              <p>从LOBFILE加载数据时，不能提供位置指定（ <code class="codeph">pos_spec</code> ）。</p>
                           </li>
                           <li>
                              <p><code class="codeph">NULLIF</code>或<code class="codeph">DEFAULTIF</code>字段条件不能基于从LOBFILE读取的字段。
                              </p>
                           </li>
                           <li>
                              <p>如果将不存在的LOBFILE指定为特定字段的数据源，则该字段将初始化为空。如果empty的概念不适用于特定字段类型，则该字段初始化为null。</p>
                           </li>
                           <li>
                              <p>表级别分隔符不会从从LOBFILE读取的字段继承。</p>
                           </li>
                           <li>
                              <p>在传统路径模式下加载<code class="codeph">XML</code>列或在SQL表达式中引用LOB列时，SQL * Loader必须将LOB数据作为临时LOB处理。要确保在这些情况下可能获得最佳负载性能，请参阅<a href="../adlob/performance-guidelines.html#ADLOB105" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide中</span></a>有关临时LOB性能<a href="../adlob/performance-guidelines.html#ADLOB105" target="_blank"><span class="italic">的指南</span></a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" name="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB"></a><h4 id="SUTIL-GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" class="sect4"><span class="enumeration_section">11.4.3</span>加载包含LLS字段的数据文件</h4>
                  <div>
                     <p>如果数据文件中的字段是LOB位置说明符（LLS）字段，则可以使用<code class="codeph">LLS</code>子句指示此字段。
                     </p>
                     <p>LLS字段包含数据文件中LOB数据的文件名，偏移量和长度。SQL * Loader使用此信息读取LOB列的数据。</p>
                     <p><code class="codeph">LLS</code>子句的语法如下：</p>
                     <div class="figure" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-709D99CC-FAD6-40E0-B11A-2639252306AC"><img src="img/lls_field_spec.gif" alt="下面是lls_field_spec.eps的描述" title="下面是lls_field_spec.eps的描述" longdesc="img_text/lls_field_spec.html"><br><a href="img_text/lls_field_spec.html">说明lls_field_spec.eps的描述</a></div>
                     <!-- class="figure" -->
                     <p>LOB可以部分或全部加载，并且可以从任意位置开始并且任意长度。SQL Loader期望LLS字段的内容为<code class="codeph"><span class="variable" translate="no">filename.ext.nnn.mmm</span> /</code> ，其中每个元素定义如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">filename.ext</span></code>是包含LOB的文件的名称。</p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">nnn</span></code>是文件中LOB的字节偏移量。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">mmm</span></code>是LOB的长度，以字节为单位。值-1表示LOB为NULL。值0表示LOB存在，但为空。
                           </p>
                        </li>
                        <li>
                           <p>正斜杠（ <code class="codeph">/</code> ）终止该字段</p>
                        </li>
                     </ul>
                     <p>如果指定了SQL * Loader参数<code class="codeph">SDF_PREFIX</code> ，则SQL * Loader将查找<code class="codeph">SDF_PREFIX</code>指定的目录中的文件。否则，SQL * Loader将查找与数据文件相同的目录。
                     </p>
                     <p>如果满足以下任何条件，则报告错误并拒绝该行：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>文件名包含相对或绝对路径规范。</p>
                        </li>
                        <li>
                           <p>找不到文件，偏移量无效，或者长度超出文件末尾。</p>
                        </li>
                        <li>
                           <p>该字段的内容与预期的格式不匹配。</p>
                        </li>
                        <li>
                           <p>与LLS字段关联的列的数据类型不是<code class="codeph">CLOB</code> ， <code class="codeph">BLOB</code>或<code class="codeph">NCLOB</code> 。</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-A951F0F5-6447-4ED5-B219-9B2C0F5FE111">使用说明</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果控制文件中的任何其他字段（例如<code class="codeph">NULLIF</code>子句）的子句引用了LLS字段，则用于计算子句的值是数据文件中的字符串，而不是指向的文件中的数据。那个字符串。
                              </p>
                           </li>
                           <li>
                              <p>假定<code class="codeph">LLS</code>子句指向的文件中数据的字符集与数据文件的字符集相同。
                              </p>
                           </li>
                           <li>
                              <p>运行SQL * Loader的用户必须具有对数据文件的读访问权。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-000E3A66-BA5E-4ED5-B102-8F2B1860AC1C">
                        <p class="titleinexample">例11-22 LLS条款的示例规范</p>
                        <p>以下是包含<code class="codeph">LLS</code>子句的SQL * Loader控制文件的示例。请注意，列规范不需要数据类型，因为该列必须是<code class="codeph">LOB</code>类型。</p><pre class="pre codeblock"><code>LOAD DATA INFILE * TRUNCATE INTO tklglls FIELDS终止'，'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3395"></a><a id="SUTIL3397"></a><a id="SUTIL3394"></a><a id="SUTIL3396"></a><a id="SUTIL1276"></a><div class="props_rev_3"><a id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" name="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40"></a><h3 id="SUTIL-GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" class="sect3"><span class="enumeration_section">11.5</span>加载BFILE列</h3>
               <div>
                  <p><code class="codeph">BFILE</code>数据类型将非结构化二进制数据存储在数据库外的操作系统文件中。
                  </p>
                  <p><code class="codeph">BFILE</code>列或属性存储指向包含数据的外部文件的文件定位器。在加载时不必存在要作为<code class="codeph">BFILE</code>加载的文件;它可以在以后创建。SQL * Loader假定已经创建了必要的目录对象（服务器文件系统上物理目录的逻辑别名）。有关更多信息，请参阅<a href="../adlob/managing-LOBs.html#ADLOB45157" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> 。
                  </p>
                  <p>与<code class="codeph">BFILE</code>列对应的控制文件字段由列名后跟<code class="codeph">BFILE</code>子句组成。<code class="codeph">BFILE</code>子句将目录对象（server_directory别名）名称作为参数，后跟<code class="codeph">BFILE</code>名称。两个参数都可以作为字符串常量提供，也可以通过其他字段动态加载。有关更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50996" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                  </p>
                  <p>在接下来的两个加载<code class="codeph">BFILE</code>的例子中， <a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">例11-23</a>只有动态指定的文件名，而<a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">例11-24</a>演示了动态指定<code class="codeph">BFILE</code>和目录对象。
                  </p>
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">
                     <p class="titleinexample">示例11-23使用BFILE加载数据：仅动态指定文件名</p>
                     <p>以下是控制文件内容。目录名<code class="codeph">scott_dir1</code>在引号中;因此，字符串按原样使用，并且不是大写的。
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE sample.dat INTO TABLE行星FIELDS TERMINATED BY'，'（pl_id CHAR（3），pl_name CHAR（20），fname FILLER CHAR（30），pl_pict BFILE（CONSTANT“scott_dir1”，fname））</pre><p>以下是数据文件<code class="codeph">sample.dat</code>的内容。
                     </p><pre class="oac_no_warn" dir="ltr">1，Mercury，mercury.jpeg，2，Venus，venus.jpeg，3，Earth，earth.jpeg，</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">
                     <p class="titleinexample">示例11-24使用BFILE加载数据：动态指定的文件名和目录</p>
                     <p>以下是控制文件内容。请注意， <code class="codeph">dname</code>映射到数据文件字段，该字段包含与正在加载的文件对应的目录名称。
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE sample.dat INTO TABLE行星FIELDS TERMINATED BY'，'选项包含'''（pl_id NUMBER（4），pl_name CHAR（20），fname FILLER CHAR（30），dname FILLER CHAR（20），pl_pict BFILE （dname，fname））</pre><p>以下是数据文件<code class="codeph">sample.dat</code>的内容。
                     </p><pre class="oac_no_warn" dir="ltr">1，Mercury，mercury.jpeg，scott_dir1,2，Venus，venus.jpeg，scott_dir1,3，Earth，earth.jpeg，scott_dir2，</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1277"></a><div class="props_rev_3"><a id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" name="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C"></a><h3 id="SUTIL-GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" class="sect3"><span class="enumeration_section">11.6</span>加载集合（嵌套表和VARRAY）</h3>
               <div>
                  <p>与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。</p>
                  <p>加载集合数据时，必须存在一种机制，SQL * Loader可以通过该机制判断属于特定集合实例的数据何时结束。您可以通过两种方式实现此目的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>要指定要加载到每个嵌套表或<code class="codeph">VARRAY</code>实例中的行数或元素数，请使用DDL <code class="codeph">COUNT</code>函数。为<code class="codeph">COUNT</code>指定的值必须是数字或包含数字的字符串，并且必须先在<code class="codeph">COUNT</code>子句本身之前的控制文件中进行描述。此位置依赖性特定于<code class="codeph">COUNT</code>子句。<code class="codeph">COUNT(0)</code>或<code class="codeph">COUNT(cnt_field)</code> ，其中当前行的<code class="codeph">cnt_field</code>为0，导致空集合（非空），除非被<code class="codeph">NULLIF</code>子句覆盖。见<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABIHJAH">count_spec</a> 。
                        </p>
                        <p>如果<code class="codeph">COUNT</code>子句指定控制文件中的字段，并且该字段对于当前行设置为null，则对于当前行，使用该计数的集合也将设置为空。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">TERMINATED</code> <code class="codeph">BY</code>和<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句指定唯一的集合分隔符。如果使用<code class="codeph">SDF</code>子句，则不能使用此方法。
                        </p>
                     </li>
                  </ul>
                  <p>在控制文件中，集合的描述与列对象类似。有一些差异：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>集合描述采用前面列表中讨论的两种机制。</p>
                     </li>
                     <li>
                        <p>集合描述可以包括辅助数据文件（SDF）规范。</p>
                     </li>
                     <li>
                        <p>除非子句位于同一SDF中的字段上，否则<code class="codeph">NULLIF</code>或<code class="codeph">DEFAULTIF</code>子句不能引用SDF中的字段。</p>
                     </li>
                     <li>
                        <p>将字段名称作为参数的子句不能使用集合中的字段名称，除非DDL规范适用于同一集合中的字段。</p>
                     </li>
                     <li>
                        <p>字段列表必须只包含一个非填充字段和任意数量的填充字段。如果<code class="codeph">VARRAY</code>是列对象的<code class="codeph">VARRAY</code> ，则每个列对象的属性将位于嵌套字段列表中。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553">嵌套表和VARRAY中的限制</a><br>嵌套表和<code class="codeph">VARRAY</code>有限制。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC">辅助数据文件（SDF）</a><br>辅助数据文件（SDF）在概念上与主数据文件类似。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C__GUID-7F1193EF-765D-458B-8AC1-910D286B5985">
                     <p class="notep1">也可以看看：</p>
                     <p>有关SDF的详细信息，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" title="辅助数据文件（SDF）在概念上与主数据文件类似。">辅助数据文件（SDF）</a> 。
                     </p>
                     <p>有关加载列对象的详细信息，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a> 。
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3398"></a><a id="SUTIL3399"></a><a id="SUTIL1278"></a><div class="props_rev_3"><a id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" name="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553"></a><h4 id="SUTIL-GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" class="sect4"><span class="enumeration_section">11.6.1</span>嵌套表和VARRAY中的限制</h4>
                  <div>
                     <p>嵌套表和<code class="codeph">VARRAY</code>有限制。
                     </p>
                     <div class="section">
                        <p>嵌套表和<code class="codeph">VARRAY</code>存在以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">field_list</code>不能包含<code class="codeph">collection_fld_spec</code> 。
                              </p>
                           </li>
                           <li>
                              <p>嵌套在<code class="codeph">VARRAY</code> <code class="codeph">col_obj_spec</code>不能包含<code class="codeph">collection_fld_spec</code> 。
                              </p>
                           </li>
                           <li>
                              <p>指定为<code class="codeph">field_list</code>一部分的<code class="codeph">column_name</code>必须与<code class="codeph">VARRAY</code>参数之前的<code class="codeph">column_name</code>相同。
                              </p>
                           </li>
                        </ul>
                        <p>另外，请注意，如果要加载到包含嵌套表的表中，则SQL * Loader不会自动将加载拆分为多个加载并生成集ID。</p>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">例11-25</a>演示了如何加载<code class="codeph">VARRAY</code>和嵌套表。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">
                        <p class="titleinexample">示例11-25加载VARRAY和嵌套表</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“str'\ n'”INTO TABLE dept REPLACE FIELDS终止'，''选择性地包含'''（dept_no CHAR（3），dname CHAR（25）NULLIF dname = BLANKS， <span class="bold">1</span> emps VARRAY终止于'：'（emps COLUMN OBJECT（名称CHAR（30），年龄INTEGER EXTERNAL（3）， <span class="bold">2</span> emp_id CHAR（7）NULLIF emps.emps.emp_id = BLANKS））， <span class="bold">3</span> proj_cnt FILLER CHAR（3）， <span class="bold">4</span>项目NESTED TABLE SDF（CONSTANT“pr.txt”“fix 57”）COUNT（proj_cnt）（项目COLUMN OBJECT（project_id POSITION（1：5）INTEGER EXTERNAL（5），project_name POSITION（7:30）CHAR NULLIF projects.projects .project_name = BLANKS）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，MATH，“Napier”，28,2828，“Euclid”，123,9999：0 210，“拓扑变换”，：2</pre><p>辅助数据文件（SDF）（pr.txt）</p><pre class="oac_no_warn" dir="ltr">21034拓扑变换77777不可能证明</pre><div class="infoboxnote" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__GUID-5C1AA2C6-2295-42AE-A072-6B83086C2A14">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TERMINATED</code> <code class="codeph">BY</code>子句指定<code class="codeph">VARRAY</code>实例终止符（请注意，不使用<code class="codeph">COUNT</code>子句）。
                                 </p>
                              </li>
                              <li>
                                 <p>全名字段引用（使用点表示法）解决由此填充字段的存在而创建的字段名称冲突。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">proj_cnt</code>是一个填充字段，用作<code class="codeph">COUNT</code>子句的参数。
                                 </p>
                              </li>
                              <li>
                                 <div class="p">此条目指定以下内容：<ul style="list-style-type:disc">
                                       <li>
                                          <p>SDF叫做<code class="codeph">pr</code> 。 <code class="codeph">txt</code>作为数据源。它还在SDF中指定固定记录格式。</p>
                                       </li>
                                       <li>
                                          <p>如果<code class="codeph">COUNT</code>为0，则集合初始化为空。将集合初始化为空的另一种方法是使用<code class="codeph">DEFAULTIF</code>子句。与嵌套表字段描述相对应的主字段名称与其嵌套非填充字段的字段名称相同，具体地，列对象字段描述的名称。
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。">加载集合（嵌套表和VARRAY）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1279"></a><div class="props_rev_3"><a id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" name="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC"></a><h4 id="SUTIL-GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" class="sect4"><span class="enumeration_section">11.6.2</span>辅助数据文件（SDF）</h4>
                  <div>
                     <p>辅助数据文件（SDF）在概念上与主数据文件类似。</p>
                     <p>与主数据文件一样，SDF是记录的集合，每个记录由字段组成。SDF是基于每个控制文件字段指定的。加载大型嵌套表和<code class="codeph">VARRAY</code>时它们很有用。
                     </p>
                     <div class="infoboxnote" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-7ECDA72B-2C94-4B04-9968-C5AE90296508">
                        <p class="notep1">注意：</p>
                        <p>只有<code class="codeph">collection_fld_spec</code>才能将SDF命名为其数据源。
                        </p>
                     </div>
                     <p>使用<code class="codeph">SDF</code>参数指定<code class="codeph">SDF</code> 。<code class="codeph">SDF</code>参数后面可以是文件规范字符串，也可以是映射到包含一个或多个文件规范字符串的数据字段的<code class="codeph">FILLER</code>字段。
                     </p>
                     <p>对于主数据文件，可以为每个SDF指定以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>记录格式（固定，流或变量）。此外，如果使用流记录格式，则可以指定记录分隔符。</p>
                        </li>
                        <li>
                           <p>记录大小。</p>
                        </li>
                        <li>
                           <p>可以使用<code class="codeph">CHARACTERSET</code>子句指定SDF的字符集（请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-E0D390F1-1078-4955-9B55-B19C971D616D" title="SQL * Loader支持不同的字符编码方案（称为字符集或代码页）。">处理不同的字符编码方案</a> ）。
                           </p>
                        </li>
                        <li>
                           <p>继承特定SDF规范的字段的默认分隔符（使用分隔符规范）（包含SDF规范的集合的所有成员字段或属性，包含其自己的LOBFILE规范的字段除外）。</p>
                        </li>
                     </ul>
                     <p>还要注意有关SDF的以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果将不存在的SDF指定为特定字段的数据源，则该字段将初始化为空。如果empty的概念不适用于特定字段类型，则该字段初始化为null。</p>
                        </li>
                        <li>
                           <p>表级别分隔符不是从SDF读取的字段继承的。</p>
                        </li>
                        <li>
                           <p>要加载大于64 KB的SDF，必须使用<code class="codeph">READSIZE</code>参数指定更大的物理记录大小。您可以从命令行或作为<code class="codeph">OPTIONS</code>子句的一部分指定<code class="codeph">READSIZE</code>参数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-FA6BCAFD-3B2E-4DDC-86EF-D0CF9ECE84CA">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="oracle-sql-loader-commands.html#GUID-846265A6-3B66-45FD-99AE-009EC9380490" title="如果您选择不使用默认值，则READSIZE SQL * Loader命令行参数指定（以字节为单位）读取缓冲区的大小。">READSIZE</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-control-file-contents.html#GUID-2BB41EA6-C94D-41C1-94DE-966B291943E6" title="可以使用OPTIONS子句指定以下命令行参数。">选项条款</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABHGFGG">sdf_spec</a></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。">加载集合（嵌套表和VARRAY）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1280"></a><div class="props_rev_3"><a id="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" name="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737"></a><h3 id="SUTIL-GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" class="sect3"><span class="enumeration_section">11.7</span>动态与静态SDF规范</h3>
               <div>
                  <p>您可以静态指定SDF（指定文件的实际名称）或动态指定（使用<code class="codeph">FILLER</code>字段作为文件名源）。
                  </p>
                  <p>在任何一种情况下，当达到SDF的EOF时，文件被关闭，并且进一步尝试从该特定文件读取数据产生的结果等同于从空字段读取数据。</p>
                  <p>在动态辅助文件规范中，此行为略有不同。每当规范更改为引用新文件时，旧文件将关闭，并从新引用的文件的开头读取数据。</p>
                  <p>动态切换数据源文件具有重置效果。例如，当SQL * Loader从当前文件切换到先前打开的文件时，将重新打开先前打开的文件，并从文件的开头读取数据。</p>
                  <p>您不应指定与两个不同字段的源相同的SDF。如果这样做，那么这两个字段通常会独立读取数据。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL3401"></a><a id="SUTIL3403"></a><a id="SUTIL3400"></a><a id="SUTIL3402"></a><a id="SUTIL1281"></a><div class="props_rev_3"><a id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34" name="GUID-2D079012-0733-4172-AD8B-E97690CDFA34"></a><h3 id="SUTIL-GUID-2D079012-0733-4172-AD8B-E97690CDFA34" class="sect3"><span class="enumeration_section">11.8</span>从子表中单独加载父表</h3>
               <div>
                  <p>加载包含嵌套表列的表时，可以从子表中单独加载父表。</p>
                  <div class="section">
                     <p>如果在加载时已知SID（系统生成的或用户定义的）（即，SID在包含数据的数据文件中），则可以单独加载父表和子表。</p>
                     <p>以下示例说明如何使用用户提供的SID加载父表和子表。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008679">
                     <p class="titleinexample">示例11-26使用用户提供的SID加载父表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'cample.dat'“str'| \ n'”INTO TABLE dept FIELDS TERMINATED by'，'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' mysid FILLER CHAR（32）， <span class="bold">1</span>个项目SID（mysid））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，数学，21E978407D4441FCE03400400B403BC3，| 210， “拓扑”，21E978408D4441FCE03400400B403BC3，|</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-E37DB40E-33DA-47D0-9FB9-E7B10BE54352">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p><code class="codeph">mysid</code>是一个填充字段，映射到包含实际集ID的数据文件字段，并作为<code class="codeph">SID</code>子句的参数提供。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008683">
                     <p class="titleinexample">示例11-27使用用户提供的SID加载子表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE dept FIELDS TERMINATED'，'''TRAILING NULLCOLS <span class="bold">1</span> SID（sidsrc）（project_id INTEGER EXTERNAL（5），project_name CHAR（20）NULLIF project_name = BLANKS，sidsrc FILLER CHAR（32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">21034，“Topological Transforms”，21E978407D4441FCE03400400B403BC3,77777，“Impossible Proof”，21E978408D4441FCE03400400B403BC3，</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-76CE1F3E-1E6A-44B8-A2D8-69863679F18D">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p>表级<code class="codeph">SID</code>子句告诉SQL * Loader它正在为嵌套表加载存储表。 <code class="codeph">sidsrc</code>是填充字段名称，它是真实集ID的来源。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA">加载VARRAY列时的内存问题</a><br>加载<code class="codeph">VARRAY</code>列时存在一些内存问题。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1282"></a><div class="props_rev_3"><a id="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" name="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA"></a><h4 id="SUTIL-GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" class="sect4"><span class="enumeration_section">11.8.1</span>加载VARRAY列时的内存问题</h4>
                  <div>
                     <p>加载<code class="codeph">VARRAY</code>列时存在一些内存问题。
                     </p>
                     <p>以下列表描述了加载<code class="codeph">VARRAY</code>列时要记住的一些问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">VARRAY</code>在加载到数据库之前在客户端的内存中创建。<code class="codeph">VARRAY</code>每个元素在加载到数据库之前需要4个字节的客户端内存。因此，当您加载<code class="codeph">VARRAY</code>万千的元素，你将需要至少4000个字节为每个客户端存储的<code class="codeph">VARRAY</code>实例，然后才能加载<code class="codeph">VARRAY</code> S插入数据库。在许多情况下，SQL * Loader需要两到三倍的内存量才能成功构建和加载<code class="codeph">VARRAY</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">BINDSIZE</code>参数指定SQL * Loader为加载记录分配的内存量。给定为<code class="codeph">BINDSIZE</code>指定的值，SQL * Loader会考虑要加载的每个字段的大小，并确定它可以在一个事务中加载的行数。行数越多，事务越少，从而产生更好的性能。但是，如果系统上的内存量有限，那么以性能为代价，可以为<code class="codeph">ROWS</code>指定比SQL * Loader计算的值更低的值。
                           </p>
                        </li>
                        <li>
                           <p>加载非常大的<code class="codeph">VARRAY</code>或大量较小的<code class="codeph">VARRAY</code>可能会导致在加载期间内存不足。如果发生这种情况，请为<code class="codeph">BINDSIZE</code>或<code class="codeph">ROWS</code>指定较小的值，然后重试加载。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34" title="加载包含嵌套表列的表时，可以从子表中单独加载父表。">从子表中单独加载父表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="09640.managing-oracle-data-guard-logical-standby-databases.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <meta name="description" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <title>管理逻辑备用数据库</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Concepts and Administration "></meta>
      <meta property="og:description" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Concepts and Administration"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-guard-concepts-and-administration.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T10:50:21-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96244-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-oracle-data-guard-physical-standby-databases.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-RMAN-in-oracle-data-guard-configurations.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Data Guard Concepts and Administration"></meta>
    <meta name="dcterms.isVersionOf" content="SBYDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-oracle-data-guard-physical-standby-databases.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-RMAN-in-oracle-data-guard-configurations.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">概念和管理</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-data-guard-concepts.html" property="item" typeof="WebPage"><span property="name">概念和管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">管理逻辑备用数据库</li>
            </ol>
            <a id="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" name="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443"></a><a id="SBYDB00800"></a>
            
            <h2 id="SBYDB-GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" class="sect2"><span class="enumeration_chapter">11</span>管理逻辑备用数据库</h2>
         </header>
         <div class="ind">
            <div>
               <p>了解这些概念将有助于您成功管理逻辑备用数据库。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" title="SQL Apply使用一组后台进程将更改从主数据库应用于逻辑备用数据库。">SQL应用程序体系结构概述</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" title="SQL ALTER DATABASE GUARD语句控制用户对逻辑备用数据库中表的访问。">控制用户对逻辑备用数据库中表的访问</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。">与管理和监视逻辑备用数据库相关的视图</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" title="使用逻辑备用数据库时，可以监视SQL Apply进度，还可以自动删除日志文件。">监视逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。">自定义逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" title="您可以在逻辑备用数据库的上下文中管理特定工作负载。">在逻辑备用数据库的上下文中管理特定工作负载</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" title="这些主题提供有关调整逻辑备用数据库的各种方法的信息。">调整逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4A691CE0-7424-4547-800E-0C9D606F0607" title="您可以使用可用的传统方法备份逻辑备用数据库，然后通过还原数据库备份并在归档日志上执行介质恢复以及备份来恢复它。">逻辑备用数据库环境下的备份和恢复</a></p>
                  </li>
               </ul>
            </div><a id="SBYDB5042"></a><a id="SBYDB4804"></a><div class="props_rev_3"><a id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" name="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93"></a><h3 id="SBYDB-GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" class="sect3"><span class="enumeration_section">11.1</span> SQL Apply体系结构概述</h3>
               <div>
                  <p>SQL Apply使用一组后台进程将更改从主数据库应用于逻辑备用数据库。</p>
                  <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">图11-1</a>显示了信息流以及每个流程执行的角色。
                  </p>
                  <div class="figure" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">
                     <p class="titleinfigure">图11-1 SQL应用处理</p><img src="img/sbydb055.gif" width="615" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/sbydb055.html"><br><a href="img_text/sbydb055.html">“图11-1 SQL应用处理”的说明</a></div>
                  <!-- class="figure" -->
                  <p>在日志挖掘和应用处理期间涉及的不同过程及其功能如下：</p>
                  <p>在日志挖掘期间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">READER</code>进程从归档的重做日志文件或备用重做日志文件中读取重做记录。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">PREPARER</code>进程将重做记录中包含的块更改转换为逻辑更改记录（LCR）。对于给定的重做日志文件，可以激活多个<code class="codeph">PREPARER</code>进程。LCR正在上演<a id="d26509e241" class="indexterm-anchor"></a><a id="d26509e245" class="indexterm-anchor"></a><a id="d26509e249" class="indexterm-anchor"></a>系统全局区域（SGA），称为<span class="italic">LCR缓存</span> 。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">BUILDER</code>进程将LCR分组为事务，并执行其他任务，例如LCR缓存中的内存管理，与SQL Apply重新启动相关的检查点以及过滤掉不感兴趣的更改。
                        </p>
                     </li>
                  </ul>
                  <p>申请处理期间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">ANALYZER</code>进程识别不同事务之间的依赖关系。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">COORDINATOR</code>过程<a id="d26509e278" class="indexterm-anchor"></a><a id="d26509e282" class="indexterm-anchor"></a><a id="d26509e286" class="indexterm-anchor"></a><a id="d26509e290" class="indexterm-anchor"></a> （LSP）将事务分配给不同的应用程序并在它们之间进行协调，以确保事务之间的依赖关系得到遵守。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">APPLIER</code>进程在协调进程的监督下将事务应用于逻辑备用数据库。
                        </p>
                     </li>
                  </ul>
                  <p>您可以查询<code class="codeph">V$LOGSTDBY_PROCESS</code>视图以检查SQL Apply进程的活动。另一个提供有关当前活动信息的视图是<code class="codeph">V$LOGSTDBY_STATS</code>视图，该视图在SQL Apply活动期间显示逻辑备用数据库的统计信息，当前状态和状态信息。在<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。">与管理和监视逻辑备用数据库</a>相关的视图中更详细地讨论了这些和其他相关视图。
                  </p>
                  <div class="infoboxnote" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__GUID-80960FAF-B556-4C59-A028-32D125305B5B">
                     <p class="notep1">注意：</p>
                     <p>所有SQL Apply进程（包括协调程序进程<code class="codeph">lsp0</code> ）都是真正的后台进程。它们不受资源管理者的监管。因此，在逻辑备用数据库中创建资源组不会影响SQL Apply进程。
                     </p>
                  </div>
               </div><a id="SBYDB4805"></a><div class="props_rev_3"><a id="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" name="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C"></a><h4 id="SBYDB-GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" class="sect4"><span class="enumeration_section">11.1.1</span> SQL Apply的各种注意事项</h4>
                  <div>
                     <p>了解有关事务大小，页面调整，重新启动，DML应用和密码验证的这些概念将帮助您最大限度地管理逻辑备用数据库。</p>
                     <p>请参阅以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" title="SQL Apply将事务分为两类：小型和大型。">交易规模考虑因素</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" title="当LCR缓存中的内存耗尽并且需要为SQL Apply释放空间以进行进度时，页面超出发生在SQL Apply的上下文中。">Pageout注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" title="在从重做日志文件挖掘并应用于逻辑备用数据库的事务的提交记录之前，对逻辑备用数据库所做的修改不会持久。">重启注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C">DML应用注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB">DDL应用注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" title="必须在SYS模式中创建用于检查密码复杂性的密码验证功能。">密码验证功能</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4806"></a><div class="props_rev_3"><a id="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" name="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3"></a><h5 id="SBYDB-GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" class="sect5"><span class="enumeration_section">11.1.1.1</span>交易规模考虑因素</h5>
                     <div>
                        <p>SQL Apply将事务分为两类：小型和大型。</p>
                        <p>每个类的定义如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>小事务 - 一旦在重做日志文件中遇到事务的提交记录，SQL Apply就会开始应用属于小事务的LCR。</p>
                           </li>
                           <li>
                              <p>大型事务-SQL Apply将大型事务分解为称为<span class="italic">事务块的</span>较小部分，并在重做日志文件中看到大事务的提交记录之前开始应用块。这样做是为了减少LCR缓存上的内存压力并减少整体故障转移时间。
                              </p>
                              <p>例如，在没有分成小块的情况下，SQL * Loader加载1000万行（每个100字节大小）将在LCR缓存中使用超过1 GB的内存。如果分配给LCR缓存的内存小于1 GB，则会导致LCR缓存中的页面输出。</p>
                              <p>除了内存考虑因素，如果SQL Apply没有开始应用与千万行SQL * Loader加载相关的更改，直到它遇到事务的<code class="codeph">COMMIT</code>记录，它可能会停止角色转换。在SQL Apply在逻辑备用数据库上应用事务之前，在事务提交之后启动的切换或故障转移无法完成。
                              </p>
                              <p>尽管使用了事务块，但在处理修改超过800万行的事务时，SQL Apply性能可能会降低。对于大于800万行的事务，SQL Apply使用临时段来暂存处理事务所需的一些内部元数据。确保在临时段中为SQL Apply分配足够的空间，以成功处理大于800万行的事务。</p>
                           </li>
                        </ul>
                        <p>所有交易都开始归类为小型交易。根据可用于LCR高速缓存的内存量以及属于事务的LCR消耗的内存量，SQL Apply确定何时将事务重新分类为大事务。</p>
                     </div>
                  </div><a id="SBYDB4807"></a><div class="props_rev_3"><a id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" name="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534"></a><h5 id="SBYDB-GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" class="sect5"><span class="enumeration_section">11.1.1.2</span>寻呼注意事项</h5>
                     <div>
                        <p>当LCR缓存中的内存耗尽并且需要为SQL Apply释放空间以进行进度时，页面超出发生在SQL Apply的上下文中。</p>
                        <p>例如，假设分配给LCR高速缓存的内存为100 MB，并且SQL Apply遇到<code class="codeph">INSERT</code>事务到具有大小为300 MB的<code class="codeph">LONG</code>列的表。在这种情况下，日志挖掘组件将<code class="codeph">LONG</code>数据的第一部分分页，以读取列修改的后半部分。在经过良好调整的逻辑备用数据库中，页面调度活动偶尔会发生，不应影响系统的整体吞吐量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534__GUID-57EEDF29-F86F-4BB0-90EF-4B30CAC038A1">
                           <p class="notep1">也可以看看：</p>
                           <p>有关如何识别有问题的页面输出和执行更正操作的详细信息，请参阅<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。">自定义逻辑备用数据库</a></p>
                        </div>
                     </div>
                  </div><a id="SBYDB4808"></a><div class="props_rev_3"><a id="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" name="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8"></a><h5 id="SBYDB-GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" class="sect5"><span class="enumeration_section">11.1.1.3</span>重启注意事项</h5>
                     <div>
                        <p>在从重做日志文件挖掘并应用于逻辑备用数据库的事务的提交记录之前，对逻辑备用数据库所做的修改不会持久。</p>
                        <p>因此，每次SQL Apply停止时，无论是由于用户指令还是由于系统故障，SQL Apply都必须返回并再次挖掘最早的未提交事务。</p>
                        <p>如果事务很少工作但长时间保持打开状态，从一开始就重新启动SQL Apply可能会非常昂贵，因为SQL Apply必须再次挖掘大量的归档重做日志文件，只是为了阅读重做一些未提交的交易的数据。为了缓解这种情况，SQL Apply定期检查旧的未提交数据。获取检查点的SCN反映在<code class="codeph">RESTART_SCN</code>列中<a id="d26509e758" class="indexterm-anchor"></a><a id="d26509e762" class="indexterm-anchor"></a> <code class="codeph">V$LOGSTDBY_PROGRESS</code>视图。重新启动后，SQL Apply将开始挖掘在SCN大于<code class="codeph">RESTART_SCN</code>列所示值的情况下生成的重做记录。SQL Apply会自动删除重新启动时不需要的存档重做日志文件。
                        </p>
                        <p>某些工作负载，例如大型DDL事务，并行DML语句（PDML） <a id="d26509e774" class="indexterm-anchor"></a><a id="d26509e778" class="indexterm-anchor"></a>和直接路径加载，防止<code class="codeph">RESTART_SCN</code>在工作负载期间前进。
                        </p>
                     </div>
                  </div><a id="SBYDB4809"></a><div class="props_rev_3"><a id="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" name="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C"></a><h5 id="SBYDB-GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" class="sect5"><span class="enumeration_section">11.1.1.4</span> DML应用注意事项</h5>
                     <div>
                        <p>应用影响的DML事务时，SQL Apply具有以下特征<a id="d26509e868" class="indexterm-anchor"></a><a id="d26509e872" class="indexterm-anchor"></a><a id="d26509e876" class="indexterm-anchor"></a>逻辑备用数据库上的吞吐量和延迟：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>批量更新<a id="d26509e885" class="indexterm-anchor"></a><a id="d26509e889" class="indexterm-anchor"></a>或删除在主数据库上执行的操作，其中单个语句导致多行被修改，作为逻辑备用数据库上的单独行修改应用。因此，每个维护的表必须具有唯一性<a id="d26509e894" class="indexterm-anchor"></a><a id="d26509e898" class="indexterm-anchor"></a><a id="d26509e902" class="indexterm-anchor"></a>索引或主键。有关详细信息，请参阅<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a> 。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e916" class="indexterm-anchor"></a>使用逻辑备用数据库上的常规<code class="codeph">INSERT</code>语句应用在主数据库上执行的直接路径插入。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e926" class="indexterm-anchor"></a><a id="d26509e930" class="indexterm-anchor"></a>并行DML（PDML）事务不在逻辑备用数据库上并行执行。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4810"></a><div class="props_rev_3"><a id="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" name="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB"></a><h5 id="SBYDB-GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" class="sect5"><span class="enumeration_section">11.1.1.5</span> DDL应用注意事项</h5>
                     <div>
                        <p>应用影响逻辑备用数据库上的through和延迟的DDL事务时，SQL Apply具有以下特征：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d26509e1035" class="indexterm-anchor"></a><a id="d26509e1039" class="indexterm-anchor"></a> DDL事务在逻辑备用数据库上串行应用。因此，在主数据库上并发应用的DDL事务在逻辑备用数据库上一次应用一个。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e1046" class="indexterm-anchor"></a><a id="d26509e1050" class="indexterm-anchor"></a> <code class="codeph">CREATE TABLE AS SELECT</code> （CTAS）语句，以便在逻辑备用数据库上抑制DML活动（属于CTAS语句的一部分）。作为CTAS语句的一部分插入新创建的表中的行是从重做日志文件中挖掘出来的，并使用<code class="codeph">INSERT</code>语句应用于逻辑备用数据库。
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply重新发出在主数据库中执行的DDL，并确保在逻辑备用数据库中不复制作为DDL操作目标的同一对象上的同一事务中发生的DML。因此，以下两种情况会导致主站点和备用站点相互分离：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>DDL包含从主数据库中的状态派生的非文字值。这种DDL的一个例子是：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.employees ADD（start_date date default sysdate）;</pre><p>因为SQL Apply在逻辑备用数据库上重新发出相同的DDL，所以在逻辑备用数据库中重新评估函数<code class="codeph">sysdate()</code> 。因此，使用与主数据库不同的默认值创建列<code class="codeph">start_date</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>DDL触发目标表上定义的DML触发器。由于触发的DML发生在与DDL相同的事务中，并且在作为DDL目标的表上运行，因此不会在逻辑备用数据库中复制这些触发的DML。</p>
                                    <p>例如，假设您创建一个表，如下所示：</p><pre class="oac_no_warn" dir="ltr">create table HR.TEMP_EMPLOYEES（emp_id number primary key，first_name varchar2（64），last_name varchar2（64），modify_date timestamp）;</pre><p>假设您然后在表上创建一个触发器，这样<code class="codeph">modify_date</code>更新表时， <code class="codeph">modify_date</code>都会更新以反映更改的时间：</p><pre class="oac_no_warn" dir="ltr">在更新HR.TEST_EMPLOYEES之前创建或替换TRIGGER TRG_TEST_MOD_DT将每个行的NEW_ROW引用为新行开始：NEW_ROW.MODIFY_DATE：= SYSTIMESTAMP;结束; /</pre><p>在通常的DML / DDL工作负载下正确维护此表。但是，如果向表中添加具有默认值的列，则<code class="codeph">ADD COLUMN</code> DDL将触发此更新触发器，并将表中所有行的<code class="codeph">MODIFY_DATE</code>列更改为新的时间戳。对<code class="codeph">MODIFY_DATE</code>列的这些更改不会在逻辑备用数据库中复制。对表的后续DML将停止SQL Apply，因为重做流中记录的<code class="codeph">MODIFY_DATE</code>列数据与逻辑备用数据库中存在的数据不匹配。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4811"></a><div class="props_rev_3"><a id="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" name="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402"></a><h5 id="SBYDB-GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" class="sect5"><span class="enumeration_section">11.1.1.6</span>密码验证功能</h5>
                     <div>
                        <p>必须在<code class="codeph">SYS</code>模式中创建用于检查密码复杂性的密码验证功能。
                        </p>
                        <p>由于SQL Apply不复制在<code class="codeph">SYS</code>模式中创建的对象，因此此类验证功能不会复制到逻辑备用数据库。您必须在逻辑备用数据库中手动创建密码验证功能，并将其与相应的配置文件相关联。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="SBYDB4812"></a><div class="props_rev_3"><a id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" name="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771"></a><h3 id="SBYDB-GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" class="sect3"><span class="enumeration_section">11.2</span>控制用户对逻辑备用数据库中表的访问</h3>
               <div>
                  <p>SQL <code class="codeph">ALTER DATABASE GUARD</code>语句控制用户对逻辑备用数据库中表的访问。
                  </p>
                  <div class="section">
                     <p>默认情况下，逻辑备用数据库上的数据库防护设置为<code class="codeph">ALL</code> 。
                     </p>
                     <p><code class="codeph">ALTER DATABASE GUARD</code>语句允许以下关键字：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">所有</code></p>
                           <p>指定<code class="codeph">ALL</code>以防止除<code class="codeph">SYS</code>之外的所有用户更改逻辑备用数据库中的任何数据。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">支持</code></p>
                           <p>指定<code class="codeph">STANDBY</code>以防止除<code class="codeph">SYS</code>之外的所有用户对通过SQL Apply维护的任何表或序列进行DML和DDL更改。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">没有</code></p>
                           <p>指定<code class="codeph">NONE</code>以对数据库中的所有数据使用典型安全性。
                           </p>
                        </li>
                     </ul>
                     <p>例如，使用以下语句使用户能够修改不由SQL Apply维护的表：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre><p>特权用户可以分别使用<code class="codeph">ALTER SESSION DISABLE GUARD</code>和<code class="codeph">ALTER SESSION ENABLE GUARD</code>语句暂时关闭和打开当前会话的数据库保护。此语句替换在Oracle9i中执行相同功能的<code class="codeph">DBMS_LOGSTDBY.GUARD_BYPASS</code> PL / SQL过程。如果要暂时禁用数据库防护以对数据库进行更改，则<code class="codeph">ALTER SESSION [ENABLE|DISABLE] GUARD</code>语句非常有用，如<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。">修改逻辑备用数据库中所述</a> 。
                     </p>
                     <div class="infoboxnote" id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771__GUID-4C32DDF1-5425-4CF7-9514-925B96119B02">
                        <p class="notep1">注意：</p>
                        <p>禁用数据库防护时，不要让主数据库和逻辑备用数据库发生分歧。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="SBYDB4813"></a><div class="props_rev_3"><a id="GUID-D6636F76-CD66-49A8-B052-503991190FBF" name="GUID-D6636F76-CD66-49A8-B052-503991190FBF"></a><h3 id="SBYDB-GUID-D6636F76-CD66-49A8-B052-503991190FBF" class="sect3"><span class="enumeration_section">11.3</span>与管理和监视逻辑备用数据库相关的视图</h3>
               <div>
                  <p>您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。</p>
                  <p>以下主题描述了可用于监视逻辑备用数据库的关键视图：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" title="DBA_LOGSTDBY_EVENTS视图记录在SQL Apply操作期间发生的有趣事件。">DBA_LOGSTDBY_EVENTS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" title="DBA_LOGSTDBY_LOG视图提供有关SQL Apply正在处理的归档日志的动态信息。">DBA_LOGSTDBY_LOG查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-76033857-52EC-41B2-B130-CC9083F3FA99">V $ DATAGUARD_STATS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D">V $ LOGSTDBY_PROCESS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DAF00126-1FDA-4980-AD24-1360472ADB49">V $ LOGSTDBY_PROGRESS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F">V $ LOGSTDBY_STATE查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7">V $ LOGSTDBY_STATS查看</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D6636F76-CD66-49A8-B052-503991190FBF__GUID-74814E29-064B-4083-8C3C-89EC7A8574AE">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=REFRN002" target="_blank">Oracle数据库参考</a>有关视图的完整参考信息</p>
                  </div>
               </div><a id="SBYDB4814"></a><div class="props_rev_3"><a id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" name="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96"></a><h4 id="SBYDB-GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" class="sect4"><span class="enumeration_section">11.3.1</span> DBA_LOGSTDBY_EVENTS视图</h4>
                  <div>
                     <p><code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图记录在SQL Apply操作期间发生的有趣事件。
                     </p>
                     <div class="section">
                        <p>默认情况下，视图记录最近的10,000个事件。但是，您可以通过调用<code class="codeph">DBMS_LOGSTDBY.APPLY_SET()</code> PL / SQL过程来更改记录事件的数量。如果SQL Apply意外停止，则问题的原因也会记录在此视图中。
                        </p>
                        <div class="infoboxnote" id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96__GUID-C576E399-F655-419E-BEB6-A3D56BAA3546">
                           <p class="notep1">注意：</p>
                           <p>导致SQL Apply停止的错误记录在事件表中。这些事件也被放入<code class="codeph">ALERT.LOG</code>文件中，文本中包含<code class="codeph">LOGSTDBY</code>关键字。查询视图时，按<code class="codeph">EVENT_TIME_STAMP</code> ， <code class="codeph">COMMIT_SCN</code>和<code class="codeph">CURRENT_SCN</code>顺序选择列，以确保所需的事件顺序。
                           </p>
                        </div>
                        <p>可以自定义视图以包含其他信息，例如应用了哪些DDL事务以及哪些事务已被跳过。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YY HH24：MI：SS';会话改变了。SQL&gt; COLUMN STATUS FORMAT A60 SQL&gt; SELECT EVENT_TIME，STATUS，EVENT FROM DBA_LOGSTDBY_EVENTS  - &gt; ORDER BY EVENT_TIMESTAMP，COMMIT_SCN，CURRENT_SCN; EVENT_TIME STATUS ------------------------------------------------ ------------------------------ EVENT ------------------- -------------------------------------------------- ---------- 23-JUL-02 18:20:12 ORA-16111：日志挖掘和应用设置23-JUL-02 18:25:12 ORA-16128：用户启动关闭成功完成23-JUL-02 18:27:12 ORA-16112：日志挖掘并应用停止23-JUL-02 18:55:12 ORA-16128：用户启动关闭成功完成23-JUL-02 18:57:09 ORA -16111：日志挖掘和应用设置23-JUL-02 20:21:47 ORA-16204：DDL成功应用create table hr.test_emp（empno number，ename varchar2（64））23-JUL-02 20:22： 55 ORA-16205：由于跳过设置而跳过DDL创建数据库链接link_to_boston连接到由change_on_inst标识的系统选择7行。
</pre><p>此查询显示SQL Apply已启动和停止几次。它还显示了应用和跳过的DDL。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4815"></a><div class="props_rev_3"><a id="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" name="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2"></a><h4 id="SBYDB-GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" class="sect4"><span class="enumeration_section">11.3.2</span> DBA_LOGSTDBY_LOG视图</h4>
                  <div>
                     <p><code class="codeph">DBA_LOGSTDBY_LOG</code>视图提供有关SQL Apply正在处理的归档日志的动态信息。
                     </p>
                     <div class="section">
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN DICT_BEGIN格式A10; SQL&gt; SET NUMF 99999999; SQL&gt; SELECT FILE_NAME，SEQUENCE＃AS SEQ＃，FIRST_CHANGE＃AS F_SCN＃， - &gt; NEXT_CHANGE＃AS N_SCN＃，TIMESTAMP， - &gt; DICT_BEGIN AS BEG，DICT_END为结束， - &gt; THREAD＃AS THR＃，应用于DBA_LOGSTDBY_LOG  - &gt;按顺序排序＃; FILE_NAME SEQ＃F_SCN N_SCN TIMESTAM BEG END THR＃APPLIED ------------------------- ---- ------- --- ---- -------- --- --- --- --------- / oracle / dbs / hq_nyc_2.log 2 101579 101588 11:02:58 NO NO 1 YES /oracle/dbs/hq_nyc_3.log 3 101588 142065 11:02:02 NO NO 1是/oracle/dbs/hq_nyc_4.log 4 142065 142307 11:02:10 NO NO 1是/oracle/dbs/hq_nyc_5.log 5 142307 142739 11:02:48是是1是/oracle/dbs/hq_nyc_6.log 6 142739 143973 12:02:10否否1是/oracle/dbs/hq_nyc_7.log 7 143973 144042 01:02:11否是1是/oracle/dbs/hq_nyc_8.log 8 144042 144051 01:02:01 NO NO 1是/oracle/dbs/hq_nyc_9.log 9 144051 144054 01:02:16 NO NO 1是/oracle/dbs/hq_nyc_10.log 10 144054 144057 01:02:21 NO NO 1是/oracle/dbs/hq_nyc_11.log 11 144057 144060 01:02:26 NO NO 1 CURRENT /oracle/dbs/hq_nyc_12.log 12 144060 144089 01:02:30 NO NO 1 CURRENT /oracle/dbs/hq_nyc_13.log 13 144089 144147 01:02:41 NO NO NO NO</pre><p><code class="codeph">BEG</code>和<code class="codeph">END</code>列中的<code class="codeph">YES</code>条目表示LogMiner字典构建从日志文件序列号5开始。最新的归档重做日志文件是序列号13，它是在01:02:41在逻辑备用数据库中接收的。<code class="codeph">APPLIED</code>列表示SQL Apply已在SCN 144057之前应用了所有重做。由于事务可以跨多个归档日志文件，因此多个归档日志文件可能会在<code class="codeph">APPLIED</code>列中显示值<code class="codeph">CURRENT</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4816"></a><div class="props_rev_3"><a id="GUID-76033857-52EC-41B2-B130-CC9083F3FA99" name="GUID-76033857-52EC-41B2-B130-CC9083F3FA99"></a><h4 id="SBYDB-GUID-76033857-52EC-41B2-B130-CC9083F3FA99" class="sect4"><span class="enumeration_section">11.3.3</span> V $ DATAGUARD_STATS查看</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供与逻辑备用数据库的故障转移特征相关的信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>故障转移的时间（ <code class="codeph">apply finish time</code> ）</p>
                           </li>
                           <li>
                              <p>逻辑备用数据库中的已提交数据的当前时间（ <code class="codeph">apply lag</code> ）</p>
                           </li>
                           <li>
                              <p>灾难发生时潜在的数据丢失（ <code class="codeph">transport lag</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COL NAME FORMAT A20 SQL&gt; COL VALUE FORMAT A12 SQL&gt; COL UNIT FORMAT A30 SQL&gt; SELECT NAME，VALUE，UNIT FROM V $ DATAGUARD_STATS; NAME VALUE UNIT -------------------- ------------ --------------- ---------------申请结束时间+00 00:00:00 day（2）to second（1）interval apply application +00 00:00:00 day（2）to second （0）间隔传输滞后+00 00:00:00天（2）到第二（0）间隔</pre><p>此输出来自逻辑备用数据库，该数据库已接收并应用从主数据库生成的所有重做。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4817"></a><div class="props_rev_3"><a id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" name="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D"></a><h4 id="SBYDB-GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" class="sect4"><span class="enumeration_section">11.3.4</span> V $ LOGSTDBY_PROCESS视图</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供有关SQL Apply涉及的各种进程的当前状态的信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>识别信息（ <code class="codeph">sid</code> | <code class="codeph">serial#</code> | <code class="codeph">spid</code> ）</p>
                           </li>
                           <li>
                              <p>SQL应用程序： <code class="codeph">COORDINATOR</code> ， <code class="codeph">READER</code> ， <code class="codeph">BUILDER</code> ， <code class="codeph">PREPARER</code> ， <code class="codeph">ANALYZER</code>或<code class="codeph">APPLIER</code> （ <code class="codeph">type</code> ）</p>
                           </li>
                           <li>
                              <p>流程当前活动的<code class="codeph">status</code> （ <code class="codeph">status_code</code> | <code class="codeph">status</code> ）</p>
                           </li>
                           <li>
                              <p>此过程处理的最高重做记录（ <code class="codeph">high_scn</code> ）</p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN SERIAL #FORMAT 9999 SQL&gt; COLUMN SID FORMAT 9999 SQL&gt; SELECT SID，SERIAL＃，SPID，TYPE，HIGH_SCN FROM V $ LOGSTDBY_PROCESS; SID SERIAL #SPID TYPE HIGH_SCN ----- ------- ----------- ---------------- ----- ----- 48 6 11074 COORDINATOR 7178242899 56 56 10858 READER 7178243497 46 1 10860 BUILDER 7178242901 45 1 10862 PREPARER 7178243295 37 1 10864 ANALYZER 7178242900 36 1 10866 APPLIER 7178239467 35 3 10868 APPLIER 7178239463 34 7 10870 APPLIER 7178239461 33 1 10872 APPLIER 7178239472选择了9行。
</pre><p><code class="codeph">HIGH_SCN</code>列显示读取器进程<code class="codeph">HIGH_SCN</code>于所有其他进程，而<code class="codeph">PREPARER</code>和<code class="codeph">BUILDER</code>进程<code class="codeph">PREPARER</code>于其他进程。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN STATUS FORMAT A40 SQL&gt; SELECT TYPE，STATUS_CODE，STATUS FROM V $ LOGSTDBY_PROCESS <a id="d26509e1963" class="indexterm-anchor"></a> ; TYPE STATUS_CODE STATUS ---------------- ----------- -------------------- --------------------- COORDINATOR 16117 ORA-16117：处理读者16127 ORA-16127：停止等待应用其他交易BUILDER 16116 ORA-16116：没有工作可用PREPARER 16116 ORA-16117：处理ANALYZER 16120 ORA-16120：为SCN上的事务计算依赖关系0x0001.abdb440a APPLIER 16124 ORA-16124：事务1 13 1427正在等待另一个事务APPLIER 16121 ORA-16121：使用提交SCN应用事务0x0001.abdb4390 APPLIER 16123 ORA-16123：事务1 23 1231正在等待提交批准APPLIER 16116 ORA-16116：没有可用的工作</pre><p>输出显示正在运行的SQL Apply的快照。在挖掘方面， <code class="codeph">READER</code>进程在可以读取更多内容之前等待额外的内存可用， <code class="codeph">PREPARER</code>进程正在处理重做记录，而<code class="codeph">BUILDER</code>进程没有可用的工作。在应用方面， <code class="codeph">COORDINATOR</code>正在为<code class="codeph">APPLIER</code>进程分配更多事务， <code class="codeph">ANALYZER</code>在SCN 7178241034处计算依赖性，一个<code class="codeph">APPLIER</code>没有可用的工作，而两个具有尚未满足的未完成依赖性。
                        </p>
                        <div class="infoboxnotealso" id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D__GUID-4A8978F2-5224-4AC8-9A29-121AB654019B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4818"></a><div class="props_rev_3"><a id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" name="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49"></a><h4 id="SBYDB-GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" class="sect4"><span class="enumeration_section">11.3.5</span> V $ LOGSTDBY_PROGRESS视图</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供有关SQL Apply所取得进展的详细信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SCN和已在主数据库上提交的所有事务已应用于逻辑备用数据库的时间（ <code class="codeph">applied_scn</code> ， <code class="codeph">applied_time</code> ）</p>
                           </li>
                           <li>
                              <p>SCN和SQL Apply在重新启动时开始读取重做记录（ <code class="codeph">restart_scn</code> ， <code class="codeph">restart_time</code> ）的时间</p>
                           </li>
                           <li>
                              <p>在逻辑备用数据库上收到的最新重做记录的SCN和时间（ <code class="codeph">latest_scn</code> ， <code class="codeph">latest_time</code> ）</p>
                           </li>
                           <li>
                              <p>SCN和<code class="codeph">BUILDER</code>流程处理的最新记录的时间（ <code class="codeph">mining_scn</code> ， <code class="codeph">mining_time</code> ）</p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN，LATEST_SCN，MINING_SCN，RESTART_SCN  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_SCN LATEST_SCN MINING_SCN RESTART_SCN ----------- ----------- ---------- ----------- 7178240496 7178240507 7178240507 7178219805</pre><p>根据输出：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL Apply已应用在SCN 7178240496之前或之前提交的所有事务</p>
                           </li>
                           <li>
                              <p>在逻辑备用数据库收到的最新重做记录在SCN 7178240507生成</p>
                           </li>
                           <li>
                              <p>挖掘组件已处理在SCN 7178240507上或之前生成的所有重做记录</p>
                           </li>
                           <li>
                              <p>如果SQL Apply因任何原因停止并重新启动，它将开始挖掘在SCN 7178219805上或之后生成的重做记录</p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='yy-mm-dd hh24：mi：ss';会话改变了SQL&gt; SELECT APPLIED_TIME，LATEST_TIME，MINING_TIME，RESTART_TIME  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_TIME LATEST_TIME MINING_TIME RESTART_TIME ----------------- ----------------- ------------ ----- ----------------- 05-05-12 10:38:21 05-05-12 10:41:53 05-05-12 10:41 ：21 05-05-12 10:09:30</pre><p>根据输出：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL Apply已应用05-05-12 10:38:21（ <code class="codeph">APPLIED_TIME</code> ）之前或之前提交的所有事务</p>
                           </li>
                           <li>
                              <p>最后一次重做是在主数据库（ <code class="codeph">LATEST_TIME</code> ）的05-05-12 10:41:53时生成的</p>
                           </li>
                           <li>
                              <p>挖掘引擎处理了05-05-12 10:41:21（ <code class="codeph">MINING_TIME</code> ）之前或之前生成的所有重做记录</p>
                           </li>
                           <li>
                              <p>如果重新启动，SQL Apply将开始挖掘05-05-12 10:09:30之后生成的重做记录</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49__GUID-35C92B00-0351-4799-9BBF-566D083AFF87">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4819"></a><div class="props_rev_3"><a id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" name="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F"></a><h4 id="SBYDB-GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" class="sect4"><span class="enumeration_section">11.3.6</span> V $ LOGSTDBY_STATE查看</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供了SQL Apply当前状态的概要，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主数据库的DBID（ <code class="codeph">primary_dbid</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>分配给SQL Apply（ <code class="codeph">session_id</code> ）的LogMiner会话ID。
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply是否<code class="codeph">realtime_apply</code>应用（ <code class="codeph">realtime_apply</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN REALTIME_APPLY FORMAT a15 SQL&gt;列状态格式a16 SQL&gt; SELECT * FROM V $ LOGSTDBY_STATE; PRIMARY_DBID SESSION_ID REALTIME_APPLY STATE ------------ ---------- --------------- --------- ------- 1562626987 1 Y申请</pre><p>输出显示SQL Apply正在实时应用模式下运行，并且当前正在应用从主数据库接收的重做数据，主数据库的<code class="codeph">DBID</code>为1562626987，与SQL Apply会话关联的LogMiner会话标识符为1。
                        </p>
                        <div class="infoboxnotealso" id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F__GUID-51C3E9CB-A493-41B8-B680-721F9D310CC9">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4820"></a><div class="props_rev_3"><a id="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" name="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7"></a><h4 id="SBYDB-GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" class="sect4"><span class="enumeration_section">11.3.7</span> V $ LOGSTDBY_STATS视图</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">V$LOGSTDBY_STATS</code>视图显示与SQL Apply相关的统计信息，当前状态和状态信息。SQL Apply未运行时，此视图不返回任何行。此视图仅在逻辑备用数据库的上下文中有意义。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='dd-mm-yyyy hh24：mi：ss';会话已更改SQL&gt; SELECT SUBSTR（name，1,40）AS NAME，SUBSTR（value，1,32）AS V值来自V $ LOGSTDBY_STATS; NAME VALUE ---------------------------------------- -------- ------------------------ logminer session id 1个编制者1个应用程序数量5个正在使用的服务器进程9 LCR缓存的最大SGA（MB）30记录的最大事件10000保留提交顺序TRUE事务一致性FULL记录跳过错误Y记录跳过DDLs Y记录应用DDLs N记录不支持的操作N实时应用Y应用延迟（分钟）0协调器状态APPLYING协调器启动时间19-06-2007 09:55 ：47协调器正常运行时间（秒）从logminer收到3593 txns 56 txns分配给应用23 txns应用22 txns在重启期间丢弃33大txns等待分配2回滚txns挖掘4 DDL txns挖掘40 CTAS txns挖掘0字节重做60164040字节寻呼0页面输出时间（秒）0字节检查点4845检查点时间（秒）0系统空闲时间（秒）2921备用重做日志已开采0存档日志已开采5间隙获取日志已开始0备用重做日志重用de tected 1 logfile open failures 0 current logfile wait（seconds）0 total logfile wait（seconds）2910 thread enable mined 0 thread disable mined 0。选择了40行。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="SBYDB4821"></a><div class="props_rev_3"><a id="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" name="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0"></a><h3 id="SBYDB-GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" class="sect3"><span class="enumeration_section">11.4</span>监控逻辑备用数据库</h3>
               <div>
                  <p>使用逻辑备用数据库时，可以监视SQL Apply进度，还可以自动删除日志文件。</p>
                  <p>请参阅以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL应用进度</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" title="外部归档日志包含从主数据库发送的重做。">自动删除日志文件</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB5043"></a><a id="SBYDB5044"></a><a id="SBYDB5045"></a><a id="SBYDB5046"></a><a id="SBYDB5047"></a><a id="SBYDB5048"></a><a id="SBYDB5049"></a><a id="SBYDB4822"></a><div class="props_rev_3"><a id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" name="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292"></a><h4 id="SBYDB-GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" class="sect4"><span class="enumeration_section">11.4.1</span>监控SQL应用进度</h4>
                  <div>
                     <p>SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。</p>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">图11-2</a>显示了这些状态的流程。
                     </p>
                     <div class="figure" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">
                        <p class="titleinfigure">图11-2 SQL应用处理期间的进度状态</p><img src="img/sbydb031.gif" alt="下面是图11-2的描述" title="下面是图11-2的描述" longdesc="img_text/sbydb031.html"><br><a href="img_text/sbydb031.html">“图11-2 SQL应用处理期间的进度状态”的说明</a></div>
                     <!-- class="figure" -->
                     <p>以下小节更详细地描述了每个州。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-4764F424-47B4-42CB-B44A-F234376BB6D5">初始化国家</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当您通过发出<code class="codeph">ALTER DATABASE START LOGICAL STANDBY APPLY</code>语句启动SQL Apply时，它将进入<span class="italic">初始化</span>状态。
                        </p>
                        <p>要确定SQL Apply的当前状态，请查询<code class="codeph">V$LOGSTDBY_STATE</code>视图<a id="d26509e2619" class="indexterm-anchor"></a> 。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID，STATE FROM V $ LOGSTDBY_STATE; SESSION_ID STATE ---------- ------------- 1 INITIALIZING</pre><p><code class="codeph">SESSION_ID</code>列标识由SQL Apply创建的持久LogMiner会话，以挖掘主数据库生成的归档重做日志文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-C7B596AA-4244-40A4-B5B3-FEA7593261A5">等待字典日志</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>第一次启动SQL Apply时，它需要加载在重做日志文件中捕获的LogMiner字典。SQL Apply保留在<a id="d26509e2635" class="indexterm-anchor"></a> <code class="codeph">WAITING FOR DICTIONARY LOGS</code>状态，直到它收到加载LogMiner字典所需的所有重做数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-E6B876F0-2298-4322-93DD-62F608873F04">加载字典状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这个<a id="d26509e2646" class="indexterm-anchor"></a><a id="d26509e2648" class="indexterm-anchor"></a> <span class="italic">加载字典</span>状态可以持续一段时间。在大型数据库上加载LogMiner字典可能需要很长时间。加载字典时，查询<code class="codeph">V$LOGSTDBY_STATE</code>视图会返回以下输出：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID，STATE FROM V $ LOGSTDBY_STATE; SESSION_ID状态---------- ------------------ 1加载字典</pre><p>只有<code class="codeph">COORDINATOR</code>进程和挖掘进程才会生成，直到LogMiner字典完全加载为止。因此，如果查询<code class="codeph">V$LOGSTDBY_PROCESS</code> <a id="d26509e2669" class="indexterm-anchor"></a>此时，您没有看到任何<code class="codeph">APPLIER</code>进程。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SID，SERIAL＃，SPID，TYPE FROM V $ LOGSTDBY_PROCESS; SID SERIAL #SPID TYPE ------ --------- --------- --------------------- 47 3 11438 COORDINATOR 50 7 11334 READER 45 1 11336 BUILDER 44 2 11338 PREPARER 43 2 11340准备工作</pre><p>您可以通过查询<code class="codeph">V$LOGMNR_DICTIONARY_LOAD</code>视图获取有关加载字典的进度的更多详细信息。字典加载分三个阶段：</p>
                        <ol>
                           <li>
                              <p>挖掘相关的归档重做日志文件或备用重做日志文件，以收集与加载LogMiner字典相关的重做更改。</p>
                           </li>
                           <li>
                              <p>更改将在数据库内的临时表中处理和加载。</p>
                           </li>
                           <li>
                              <p>通过发出一系列DDL语句来加载LogMiner字典表。</p>
                           </li>
                        </ol>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT PERCENT_DONE，COMMAND  - &gt; FROM V $ LOGMNR_DICTIONARY_LOAD  - &gt; WHERE SESSION_ID =（从V $ LOGSTDBY_STATE中选择SESSION_ID）; PERCENT_DONE COMMAND ------------- ------------------------------- 40 alter table SYSTEM .LOGMNR_CCOL $交换分区P101与表SYS.LOGMNRLT_101_CCOL $不包括索引而没有验证</pre><p>如果<code class="codeph">PERCENT_DONE</code>或<code class="codeph">COMMAND</code>列长时间未更改，请查询<code class="codeph">V$SESSION_LONGOPS</code>视图以监视相关DDL事务的进度。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-A7AAAC4A-253B-413A-A41F-4AA63BC7920F">适用国家</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在此状态下，SQL Apply已成功加载LogMiner字典的初始快照，并且当前正在将重做数据应用于逻辑备用数据库。</p>
                        <p>有关SQL Apply进度的详细信息，请查询<code class="codeph">V$LOGSTDBY_PROGRESS</code>视图：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY HH24：MI：SS'; SQL&gt; SELECT APPLIED_TIME，APPLIED_SCN，MINING_TIME，MINING_SCN  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_TIME APPLIED_SCN MINING_TIME MINING_SCN -------------------- ----------- --------------- ----- ----------- 10-JAN-2005 12:00:05 346791023 10-JAN-2005 12:10:05 3468810134</pre><p>在主数据库上<code class="codeph">APPLIED_SCN</code> （或<code class="codeph">APPLIED_TIME</code> ）处或之前看到的所有已提交事务已应用于逻辑备用数据库。挖掘引擎已处理在主数据库上<code class="codeph">MINING_SCN</code> （和<code class="codeph">MINING_TIME</code> ）之前或之前生成的所有重做记录。在稳定状态下， <code class="codeph">MINING_SCN</code> （和<code class="codeph">MINING_TIME</code> ）的值始终位于<code class="codeph">APPLIED_SCN</code> （和<code class="codeph">APPLIED_TIME</code> ）之前。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-549DF95E-2FC7-4579-9776-73FE3B8F07DB">等待差距状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当SQL Apply已经挖掘并应用了所有可用的重做记录，并且正在等待RFS进程存档新的日志文件（或缺少的日志文件）时，会出现此状态。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT STATUS FROM V $ LOGSTDBY_PROCESS WHERE TYPE ='READER';状态  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ----------------------- ORA-16240：等待日志文件（线程＃1，序列＃99）</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-3272C1A0-5C5F-408A-8590-0AEF576C1641">空闲状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>一旦应用了主数据库生成的所有重做，SQL Apply就会进入此状态。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB00810"></a><div class="props_rev_3"><a id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" name="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6"></a><h4 id="SBYDB-GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" class="sect4"><span class="enumeration_section">11.4.2</span>自动删除日志文件</h4>
                  <div>
                     <p>外部归档日志包含从主数据库发送的重做。</p>
                     <p>存储外部存档日志有两种方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在快速恢复区</p>
                        </li>
                        <li>
                           <p>在快速恢复区域之外的目录中</p>
                        </li>
                     </ul>
                     <p>存储在快速恢复区域中的外部归档日志始终由SQL Apply管理。在逻辑备用数据库中应用了日志中包含的所有重做记录之后，它们将保留<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code>参数指定的时间段（如果未指定<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> ，则保留1440分钟）。您无法覆盖存储在快速恢复区域中的外部存档日志的自动管理。
                     </p>
                     <p>未存储在快速恢复区域中的外部归档日志默认由SQL Apply管理。在自动管理下，一旦在逻辑备用数据库中应用了日志中包含的所有重做记录，则存储在快速恢复区域中的外部归档日志将保留<code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code>参数指定的时间段。您可以通过执行以下PL / SQL过程来覆盖未存储在快速恢复区域中的外部归档日志的自动管理：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'LOG_AUTO_DELETE'，'FALSE'）;</pre><div class="infoboxnote" id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6__GUID-39B195C4-D36B-40ED-BEE7-5F55692F1972">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">DBMS_LOGTSDBY.APPLY_SET</code>过程设置此参数。如果未明确指定<code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code> ，则默认为在逻辑备用数据库中设置的<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> ，或者在未设置<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code>情况下为1440分钟。
                        </p>
                     </div>
                     <p>如果要覆盖默认的自动日志删除功能，请定期执行以下步骤以标识和删除SQL Apply不再需要的归档重做日志文件：</p>
                     <ol>
                        <li>
                           <p>要清除不再需要的元数据的逻辑备用会话，请输入以下PL / SQL语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.PURGE_SESSION;</pre><p>此语句还会更新<code class="codeph">DBA_LOGMNR_PURGED_LOG</code>视图，该视图显示不再需要的归档重做日志文件。
                           </p>
                        </li>
                        <li>
                           <p>查询<code class="codeph">DBA_LOGMNR_PURGED_LOG</code>视图以列出可以删除的归档重做日志文件：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGMNR_PURGED_LOG; FILE_NAME ------------------------------------ /boston/arc_dest/arc_1_40_509538672.log / boston / arc_dest / arc_1_41_509538672.log /boston/arc_dest/arc_1_42_509538672.log /boston/arc_dest/arc_1_43_509538672.log /boston/arc_dest/arc_1_44_509538672.log /boston/arc_dest/arc_1_45_509538672.log /boston/arc_dest/arc_1_46_509538672.log / boston / arc_dest / arc_1_47_509538672。日志</pre></li>
                        <li>
                           <p>使用特定于操作系统的命令删除查询列出的归档重做日志文件。</p>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4823"></a><div class="props_rev_3"><a id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987" name="GUID-88211E8E-28BF-45AC-9230-F85B606D8987"></a><h3 id="SBYDB-GUID-88211E8E-28BF-45AC-9230-F85B606D8987" class="sect3"><span class="enumeration_section">11.5</span>自定义逻辑备用数据库</h3>
               <div>
                  <p>可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。</p>
                  <p>请参阅以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" title="可以将DBA_LOGSTDBY_EVENTS视图视为包含SQL Apply上下文中发生的最新有趣事件的循环日志。">在DBA_LOGSTDBY_EVENTS视图中自定义事件记录</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B976F237-1888-46D3-A901-F28FE362ACBC" title="默认情况下，主数据库中的所有受支持的表都将复制到逻辑备用数据库中。">使用DBMS_LOGSTDBY.SKIP来防止对特定架构对象的更改</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-28EB46A0-696D-426E-B596-225443867604" title="您可以创建一个过程来拦截某些DDL语句，并用不同的DDL语句替换原始的DDL语句。">为DDL语句设置跳过处理程序</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。">修改逻辑备用数据库</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" title="通常，您使用DBMS_LOGSTDBY.INSTANTIATE_TABLE过程在不可恢复的操作后重新创建表。">在逻辑备用数据库上添加或重新创建表</a></p>
                        <div class="infoboxnotealso" id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987__GUID-C5BD391E-AA41-4485-9BB7-1F66197DC6BF">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考中</span></a>的<code class="codeph">DBMS_LOGSTDBY</code>包</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="SBYDB5466"></a><a id="SBYDB5467"></a><a id="SBYDB4824"></a><div class="props_rev_3"><a id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" name="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A"></a><h4 id="SBYDB-GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" class="sect4"><span class="enumeration_section">11.5.1</span>在DBA_LOGSTDBY_EVENTS视图中自定义事件记录</h4>
                  <div>
                     <p>可以将<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图视为包含SQL Apply上下文中发生的最新有趣事件的循环日志。
                     </p>
                     <div class="section">
                        <p>默认情况下，在事件视图中记住最后10,000个事件。您可以通过调用<code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code>过程来更改记录的事件数。例如，要确保记录最后100,000个事件，可以发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_EVENTS_RECORDED'，'100000'）;</pre><p>导致SQL Apply停止的错误始终记录在<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图中（除非<code class="codeph">SYSTEM</code>表空间中没有足够的空间）。这些事件也始终放入警报文件中，文本中包含关键字<code class="codeph">LOGSTDBY</code> 。查询视图时，按<code class="codeph">EVENT_TIME</code> ， <code class="codeph">COMMIT_SCN</code>和<code class="codeph">CURRENT_SCN</code>顺序选择列。此排序可确保视图中最后出现关闭故障。
                        </p>
                        <p>以下示例显示了<code class="codeph">DBMS_LOGSTDBY</code>子程序，这些子程序指定要在视图中记录的事件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-DC537CD1-F13C-4FB9-BDBA-804CA5D6A035">示例1：确定是否已应用DDL语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>例如，要将已应用的DDL事务记录到<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'RECORD_APPLIED_DDL'，'TRUE'）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-A22C8A08-9156-4A15-8AD7-7585BFDCCC38">示例2：检查不受支持的操作的DBA_LOGSTDBY_EVENTS视图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要捕获有关逻辑备用数据库不支持的主数据库上运行的事务的信息，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY; SQL&gt; EXEC DBMS_LOGSTDBY.APPLY_SET（'RECORD_UNSUPPORTED_OPERATIONS'，'TRUE'）; SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre><p>然后，检查<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图是否有任何不受支持的操作。通常，SQL Apply会以静默方式忽略对不受支持的表的操作。但是，在滚动升级期间（备用数据库处于较高版本并且由较低版本的主数据库生成的挖掘重做），如果在主数据库上执行了不受支持的操作，则逻辑备用数据库可能不是您所在的数据库想要进行转换。Oracle Data Guard在<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图中为每个表记录至少一个不受支持的操作。 <a href="using-sql-apply-to-perform-rolling-upgrade.html#GUID-290F632F-5295-47F3-AEF1-2D37C69C00D7" title="您可以使用逻辑备用数据库执行Oracle数据库软件的滚动升级。"> 使用SQL Apply升级Oracle数据库</a>可提供有关滚动升级的详细信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4825"></a><div class="props_rev_3"><a id="GUID-B976F237-1888-46D3-A901-F28FE362ACBC" name="GUID-B976F237-1888-46D3-A901-F28FE362ACBC"></a><h4 id="SBYDB-GUID-B976F237-1888-46D3-A901-F28FE362ACBC" class="sect4"><span class="enumeration_section">11.5.2</span>使用DBMS_LOGSTDBY.SKIP防止对特定模式对象的更改</h4>
                  <div>
                     <p>默认情况下，主数据库中的所有受支持的表都将复制到逻辑备用数据库中。</p>
                     <div class="section">
                        <p>您可以通过指定规则来更改默认行为，以跳过对特定表应用修改。例如，要省略对<code class="codeph">HR.EMPLOYEES</code>表的更改，可以指定规则以防止将DML和DDL更改应用于特定表。例如：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>注册<code class="codeph">SKIP</code>规则：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'DML'，schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）; SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'SCHEMA_DDL'，schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4826"></a><div class="props_rev_3"><a id="GUID-28EB46A0-696D-426E-B596-225443867604" name="GUID-28EB46A0-696D-426E-B596-225443867604"></a><h4 id="SBYDB-GUID-28EB46A0-696D-426E-B596-225443867604" class="sect4"><span class="enumeration_section">11.5.3</span>为DDL语句设置跳过处理程序</h4>
                  <div>
                     <p>您可以创建一个过程来拦截某些DDL语句，并用不同的DDL语句替换原始的DDL语句。</p>
                     <div class="section">
                        <p>例如，如果逻辑备用数据库中的文件系统组织与主数据库中的文件系统组织不同，则可以编写<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程以透明地处理具有文件规范的DDL事务。
                        </p>
                        <p>只要对文件规范字符串使用特定的命名约定，以下过程就可以处理主数据库和备用数据库之间的不同文件系统组织。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建跳过程序以处理表空间DDL事务：</span><div><pre class="oac_no_warn" dir="ltr">创建或替换过程SYS.HANDLE_TBS_DDL（VARCHAR2中的OLD_STMT，VARCHAR2中的STMT_TYP，VARCHAR2中的模式，VARCHAR2中的名称，数字中的XIDUSN，数字中的XIDSLN，数字中的XIDSQN，操作数字，NEW_STMT输出VARCHAR2）AS BEGIN  - 所有主要包含目录的文件规范 -  / usr / orcl / primary / dbs  - 应该转到/ usr / orcl / stdby目录规范NEW_STMT：= REPLACE（OLD_STMT，'/ usr / orcl / primary / dbs'，'/ usr / ORCL / STDBY'）;行动：= DBMS_LOGSTDBY.SKIP_ACTION_REPLACE;除了其他行动之外的例外：= DBMS_LOGSTDBY.SKIP_ACTION_ERROR; NEW_STMT：= NULL; END HANDLE_TBS_DDL;</pre></div>
                        </li>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用SQL Apply注册跳过程序：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'TABLESPACE'， - &gt; proc_name =&gt;'sys.handle_tbs_ddl'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4827"></a><div class="props_rev_3"><a id="GUID-43971CB9-3337-4575-B4EF-D591878982F1" name="GUID-43971CB9-3337-4575-B4EF-D591878982F1"></a><h4 id="SBYDB-GUID-43971CB9-3337-4575-B4EF-D591878982F1" class="sect4"><span class="enumeration_section">11.5.4</span>修改逻辑备用数据库</h4>
                  <div>
                     <p>即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。</p>
                     <p><span class="italic">数据库保护</span>控制用户对逻辑备用数据库中表的访问， <code class="codeph">ALTER SESSION DISABLE GUARD</code>语句用于绕过数据库保护并允许修改逻辑备用数据库中的表。
                     </p>
                     <div class="infoboxnote" id="GUID-43971CB9-3337-4575-B4EF-D591878982F1__GUID-34935874-4E98-4B04-BD66-F03E13F8B9B4">
                        <p class="notep1">注意：</p>
                        <p>要使用逻辑备用数据库来托管处理从主数据库复制的数据的其他应用程序，同时创建自己的其他表，则必须将数据库防护设置为<code class="codeph">STANDBY</code> 。要使这些应用程序无缝工作，请确保在<code class="codeph">PRESERVE_COMMIT_ORDER</code>设置为<code class="codeph">TRUE</code> （SQL Apply的默认设置）的情况下运行。（有关<code class="codeph">DBMS_LOGSTDBY</code> PL / SQL包中<code class="codeph">PRESERVE_COMMIT_ORDER</code>参数的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS66830" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。）
                        </p>
                        <p>发出以下SQL语句以将数据库防护设置为<code class="codeph">STANDBY</code> ：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre><p>在此保护设置下，从主数据库复制的表受到保护而不受用户修改，但在备用数据库上创建的表可由逻辑备用数据库上运行的应用程序修改。</p>
                     </div>
                     <p>默认情况下，逻辑备用数据库在数据库保护设置为<code class="codeph">ALL</code> ，这是其最严格的设置，并且不允许对数据库执行任何用户更改。您可以通过执行<code class="codeph">ALTER SESSION DISABLE GUARD</code>语句来覆盖数据库防护以允许更改逻辑备用数据库。特权用户可以发出此语句以关闭当前会话的数据库保护。
                     </p>
                     <p>以下部分提供了一些示例。这些部分中的讨论假定数据库防护设置为<code class="codeph">ALL</code>或<code class="codeph">STANDBY</code> 。</p>
                  </div><a id="SBYDB4828"></a><div class="props_rev_3"><a id="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" name="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A"></a><h5 id="SBYDB-GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" class="sect5"><span class="enumeration_section">11.5.4.1</span>在逻辑备用数据库上执行DDL</h5>
                     <div>
                        <p>您可以向通过SQL Apply维护的表添加约束。</p>
                        <div class="section">
                           <p></p>
                           <p>默认情况下，只有具有<code class="codeph">SYS</code>权限的帐户才能在数据库防护设置为ALL或STANDBY时修改数据库。如果以<code class="codeph">SYSDG</code> ， <code class="codeph">SYSTEM</code>或其他特权帐户登录，则无法在未先绕过会话的数据库保护的情况下在逻辑备用数据库上发出DDL语句。
                           </p>
                           <p>以下示例说明如何停止SQL Apply，绕过数据库防护，在逻辑备用数据库上执行SQL语句，然后重新启用防护。在此示例中，soundex索引被添加到<code class="codeph">SCOTT.EMP</code>的姓氏列以加速部分匹配查询。soundex索引可能无法在主服务器上维护。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了SQL&gt; ALTER SESSION DISABLE GUARD; PL / SQL过程成功完成。SQL&gt; CREATE INDEX EMP_SOUNDEX ON SCOTT.EMP（SOUNDEX（ENAME））;表改变了。SQL&gt; ALTER SESSION ENABLE GUARD; PL / SQL过程成功完成。SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了SQL&gt; SELECT ENAME，MGR FROM SCOTT.EMP WHERE SOUNDEX（ENAME）= SOUNDEX（'CLARKE'）; ENAME MGR ---------- ---------- CLARK 7839</pre><p>Oracle建议您在启用数据库保护旁路时不对SQL Apply维护的表执行DML操作。这样做会引入主数据库和备用数据库之间的偏差，从而无法维护逻辑备用数据库。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB4829"></a><div class="props_rev_3"><a id="GUID-2050159A-C52F-49C2-80D2-457E62879462" name="GUID-2050159A-C52F-49C2-80D2-457E62879462"></a><h5 id="SBYDB-GUID-2050159A-C52F-49C2-80D2-457E62879462" class="sect5"><span class="enumeration_section">11.5.4.2</span>修改SQL Apply不维护的表</h5>
                     <div>
                        <div>有时，报告应用程序必须收集摘要结果并临时存储它们或跟踪报告的运行次数。虽然应用程序的主要目的是执行报告活动，但应用程序可能需要在逻辑备用数据库上发出DML（插入，更新和删除）操作。它甚至可能需要创建或删除表。<span>只要不通过SQL Apply维护数据，您就可以设置数据库防护以允许报告操作修改数据。</span></div>
                        <div class="section">
                           <p></p>
                           <p>要做到这一点，你必须：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在逻辑备用数据库上指定一组表，应用程序可以通过执行<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程将数据写入该表。不通过SQL Apply维护跳过的表。
                                 </p>
                              </li>
                              <li>
                                 <p>设置数据库防护以仅保护备用表。</p>
                              </li>
                           </ul>
                           <p>在以下示例中，假定报告所写的表也位于主数据库中。</p>
                           <p>该示例停止SQL Apply，跳过表，然后重新启动SQL Apply。报告应用程序在<code class="codeph">HR</code>写入<code class="codeph">TESTEMP%</code> 。不再通过SQL Apply维护这些表。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'SCHEMA_DDL'， -  schema_name =&gt;'HR'， -  object_name =&gt;'TESTEMP％'）; PL / SQL过程成功完成。SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（'DML'，'HR'，'TESTEMP％'）; PL / SQL过程成功完成。SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了
</pre><p>SQL Apply启动后，需要更新备用数据库上的元数据，以便在跳过规则中添加新指定的表。尝试修改新跳过的表，直到SQL Apply有机会更新元数据失败。您可以通过发出以下查询来确定SQL Apply是否已成功考虑您刚刚添加的<code class="codeph">SKIP</code>规则：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT VALUE FROM SYSTEM.LOGSTDBY $ PARAMETERS WHERE NAME ='GUARD_STANDBY'; VALUE ---------------准备好了</pre><p>当<code class="codeph">VALUE</code>列显示<code class="codeph">Ready</code> ，SQL Apply已成功更新跳过的表的所有相关元数据，并且可以安全地修改表。
                           </p>
                           <div class="infoboxnotealso" id="GUID-2050159A-C52F-49C2-80D2-457E62879462__GUID-46AC92D3-3103-4D19-AF0D-211A4EDABFF4">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考中</span></a> <a href="data-type-ddl-support-on-logical-standby-databases.html#GUID-1595A660-6790-436A-BB84-D74C9187D8AE" title="The DBMS_LOGSTDBY.SKIP procedure has several optional keywords.">的逻辑备用数据库</a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><code class="codeph">DBMS_LOGSTDBY</code></a>包<a href="data-type-ddl-support-on-logical-standby-databases.html#GUID-1595A660-6790-436A-BB84-D74C9187D8AE" title="DBMS_LOGSTDBY.SKIP过程有几个可选的关键字。">支持的DDL语句</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4830"></a><div class="props_rev_3"><a id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" name="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA"></a><h4 id="SBYDB-GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" class="sect4"><span class="enumeration_section">11.5.5</span>在逻辑备用数据库上添加或重新创建表</h4>
                  <div>
                     <p>通常，您使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>过程在不可恢复的操作后重新创建表。
                     </p>
                     <div class="section">
                        <p>您还可以使用此过程在以前跳过的表上启用SQL Apply。</p>
                        <p>在创建表之前，它必须满足<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行中所述</a>的要求。然后，您可以使用以下步骤重新创建名为<code class="codeph">HR.EMPLOYEES</code>的表并恢复SQL Apply。方向假定已经定义了一个数据库链接<code class="codeph">BOSTON</code>来访问主数据库。
                        </p>
                        <p>以下列表显示如何重新创建表并在该表上重新启动SQL Apply：</p>
                        <ol>
                           <li>
                              <p>停止SQL应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></li>
                           <li>
                              <p>通过查询<code class="codeph">DBA_LOGSTDBY_SKIP</code>视图，确保没有为相关表跳过任何操作：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGSTDBY_SKIP; ERROR STATEMENT_OPT所有者名称PROC ----- ------------------- ------------- -------- -------- ----- N SCHEMA_DDL HR员工N DML HR员工N SCHEMA_DDL OEE TEST_ORDER N DML OE TEST_ORDER</pre><p>由于您已经有与要在逻辑备用数据库上重新创建的表关联的跳过规则，因此必须先删除这些规则。您可以通过调用<code class="codeph">DBMS_LOGSTDBY.UNSKIP</code>过程来完成此操作。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP（stmt =&gt;'DML'， - &gt; schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP（stmt =&gt;'SCHEMA_DDL'， - &gt; schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre></li>
                           <li>
                              <p>使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>在逻辑备用数据库中重新创建表<code class="codeph">HR.EMPLOYEES</code>及其所有数据<a id="d26509e3978" class="indexterm-anchor"></a><a id="d26509e3982" class="indexterm-anchor"></a>程序。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.INSTANTIATE_TABLE（schema_name =&gt;'HR'， - &gt; table_name =&gt;'EMPLOYEES'， - &gt; dblink =&gt;'BOSTON'）;</pre></li>
                           <li>
                              <p>启动SQL Apply：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre><div class="infoboxnotealso" id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA__GUID-22C93637-3F30-4B1C-A919-4A7945555CD0">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>有关<code class="codeph">DBMS_LOGSTDBY.UNSKIP</code>和<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>过程的信息</p>
                              </div>
                           </li>
                        </ol>
                        <p>要确保在新实例化的表和数据库的其余部分之间保持一致的视图，请在查询此表之前等待SQL Apply赶上主数据库。您可以通过执行以下步骤来执行此操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在主数据库上，通过查询<code class="codeph">V$DATABASE</code>视图确定当前SCN：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT CURRENT_SCN来自V $ DATABASE @ BOSTON; CURRENT_SCN --------------------- 345162788</pre></div>
                        </li>
                        <li class="stepexpand"><span>确保SQL Apply已应用在上一个查询中返回的<code class="codeph">CURRENT_SCN</code>之前提交的所有事务：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN FROM V $ LOGSTDBY_PROGRESS; APPLIED_SCN -------------------------- 345161345</pre><p>当此查询中返回的<code class="codeph">APPLIED_SCN</code>大于第一个查询中返回的<code class="codeph">CURRENT_SCN</code> ，查询新重新创建的表是安全的。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4831"></a><div class="props_rev_3"><a id="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" name="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0"></a><h3 id="SBYDB-GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" class="sect3"><span class="enumeration_section">11.6</span>在逻辑备用数据库的上下文中管理特定工作负载</h3>
               <div>
                  <p>您可以在逻辑备用数据库的上下文中管理特定工作负载。</p>
                  <p>请参阅以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" title="可传输表空间可以导入主数据库。">将可传输表空间导入主数据库</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" title="逻辑备用数据库会自动跳过与物化视图相关的DDL语句。">使用物化视图</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" title="默认情况下，会在逻辑备用数据库上自动启用和处理触发器和约束。">如何在逻辑备用数据库上处理触发器和约束</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" title="在表上创建的DML触发器默认情况下将其DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY fire_once参数设置为TRUE。">使用触发器复制不支持的表</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-44D7C275-A991-4B6F-84A2-D76085E00367" title="当逻辑备用数据库收到重做数据的新分支时，SQL Apply会自动获取重做数据的新分支。">通过在主要时间执行的时间点恢复来恢复</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" title="您可以在逻辑备用数据库上运行Oracle Streams捕获进程，以捕获逻辑备用数据库上存在的任何表（无论是本地表还是从主数据库复制的维护表）中的更改。">在逻辑备用数据库上运行Oracle Streams Capture进程</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4832"></a><div class="props_rev_3"><a id="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" name="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449"></a><h4 id="SBYDB-GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" class="sect4"><span class="enumeration_section">11.6.1</span>将可传输表空间导入主数据库</h4>
                  <div>
                     <p>可传输表空间可以导入主数据库。</p>
                     <div class="section">
                        <p>执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>禁用保护设置，以便您可以修改逻辑备用数据库：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在逻辑备用数据库中导入表空间。</span></li>
                        <li class="stepexpand"><span>启用数据库防护设置：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD ALL;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在主数据库中导入表空间。</span></li>
                     </ol>
                  </div>
               </div><a id="SBYDB4833"></a><div class="props_rev_3"><a id="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" name="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3"></a><h4 id="SBYDB-GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" class="sect4"><span class="enumeration_section">11.6.2</span>使用物化视图</h4>
                  <div>
                     <p>逻辑备用数据库会自动跳过与物化视图相关的DDL语句。</p>
                     <p>例如，逻辑备用数据库会跳过以下语句：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> ， <code class="codeph">ALTER</code>或<code class="codeph">DROP MATERIALIZED VIEW</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code> ， <code class="codeph">ALTER</code>或<code class="codeph">DROP MATERIALIZED VIEW LOG</code></p>
                        </li>
                     </ul>
                     <p>在逻辑备用数据库上不会创建在创建逻辑备用数据库之后在主数据库上创建，更改或删除的新物化视图。但是，在创建逻辑备用数据库之前在主数据库上创建的物化视图存在于逻辑备用数据库上。</p>
                     <p>除了其他类型的辅助数据结构之外，Logical Standby还支持在逻辑备用数据库上本地创建和维护新的物化视图。例如，联机事务处理（OLTP）系统经常使用高度规范化的表来获得更新性能，但这些可能导致复杂决策支持查询的响应时间变慢。可以创建对复制数据进行非规范化以实现逻辑备用数据库上更高效查询支持的物化视图，如下所示（在发出这些语句之前以用户<code class="codeph">SYS</code>身份连接）：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.EMP  - &gt; WITH ROWID（EMPNO，ENAME，MGR，DEPTNO）包括新的值; SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.DEPT  - &gt; WITH ROWID（DEPTNO，DNAME）包括新值; SQL&gt; CREATE MATERIALIZED VIEW SCOTT.MANAGED_BY  - &gt; REFRESH ON DEMAND  - &gt; ENABLE QUERY REWRITE  - &gt; AS SELECT E.ENAME，M.ENAME AS MANAGER  - &gt; FROM SCOTT.EMP E，SCOTT.EMP M WHERE E.MGR = M. EMPNO; SQL&gt; CREATE MATERIALIZED VIEW SCOTT.IN_DEPT  - &gt;刷新快速执行 - &gt;启用QUERY REWRITE  - &gt;选择E.ROWID作为ERID，D.ROWID作为DRID，E.ENAME，D.DNAME  - &gt; FROM SCOTT.EMP E， SCOTT.DEPT D WHERE E.DEPTNO = D.DEPTNO;</pre><p>在逻辑备用数据库上：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>发生事务提交时，会在逻辑备用数据库上自动刷新ON-COMMIT物化视图。</p>
                        </li>
                        <li>
                           <p>ON-DEMAND物化视图不会自动刷新：必须执行<code class="codeph">DBMS_MVIEW.REFRESH</code>过程才能刷新它。
                           </p>
                        </li>
                     </ul>
                     <p>例如，发出以下命令将刷新在上一个示例中创建的ON-DEMAND物化视图：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; SQL&gt; EXECUTE DBMS_MVIEW.REFRESH（LIST =&gt;'SCOTT.MANAGED_BY'，METHOD =&gt;'C'）;</pre><p>如果使用<code class="codeph">DBMS_SCHEDULER</code>作业定期刷新按需实例化视图，则必须将数据库防护设置为<code class="codeph">STANDBY</code> 。 （无法在PL / SQL块中使用<code class="codeph">ALTER SESSION DISABLE GUARD</code>语句并使其生效。）
                     </p>
                  </div>
               </div><a id="SBYDB4834"></a><div class="props_rev_3"><a id="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" name="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D"></a><h4 id="SBYDB-GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" class="sect4"><span class="enumeration_section">11.6.3</span>如何在逻辑备用数据库上处理触发器和约束</h4>
                  <div>
                     <p>默认情况下，会在逻辑备用数据库上自动启用和处理触发器和约束。</p>
                     <p>对于SQL Apply <span class="italic">维护</span>的表的触发器和约束：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>约束 - 检查约束在主数据库上进行评估，不需要在逻辑备用数据库上重新评估。</p>
                        </li>
                        <li>
                           <p>触发器 - 记录在主数据库上执行的触发器的影响并将其应用于备用数据库。</p>
                        </li>
                     </ul>
                     <p>对于<span class="italic">不由</span> SQL Apply <span class="italic">维护</span>的表的触发器和约束：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>评估约束</p>
                        </li>
                        <li>
                           <p>触发器被触发</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="SBYDB4835"></a><div class="props_rev_3"><a id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" name="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB"></a><h4 id="SBYDB-GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" class="sect4"><span class="enumeration_section">11.6.4</span>使用触发器复制不支持的表</h4>
                  <div>
                     <p>在表上创建的DML触发器默认情况下将其<code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code> <code class="codeph">fire_once</code>参数设置为<code class="codeph">TRUE</code> 。
                     </p>
                     <p>仅当用户进程修改表时触发器才会触发。它们在SQL Apply进程中自动禁用，因此在SQL Apply进程修改表时不会触发它们。由于SQL Apply进程对维护的表进行了更改，因此有两种方法可以触发触发器：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将触发器的<code class="codeph">fire_once</code>参数设置为<code class="codeph">FALSE</code> ，这允许它在用户进程的上下文或SQL Apply进程中触发</p>
                        </li>
                        <li>
                           <p>将<code class="codeph">apply_server_only</code>参数设置为<code class="codeph">TRUE</code> ，这会导致触发器仅在SQL Apply进程的上下文中触发，而不是在用户进程的上下文中触发</p>
                        </li>
                     </ul>
                     <div class="tblformal" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-E51BED5A-8FBE-4840-8D34-45AECD58DA2C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This 3 column table shows the effect of DML Triggers. Column 1 is the fire_once parameter setting. Column 1 is the apply_server_only parameter setting. Column 3 describes the effects. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d26509e4614">fire_once</th>
                                 <th align="left" valign="bottom" width="26%" id="d26509e4617">apply_server_only</th>
                                 <th align="left" valign="bottom" width="60%" id="d26509e4620">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4625" headers="d26509e4614 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4625 d26509e4617 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4625 d26509e4620 ">
                                    <p>这是DML触发器的默认属性设置。仅当用户进程修改基表时才会触发该触发器。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4637" headers="d26509e4614 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4637 d26509e4617 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4637 d26509e4620 ">
                                    <p>触发器在用户进程的上下文中以及在修改基表的SQL Apply进程的上下文中触发。您可以使用<code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code>函数区分这两个上下文。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4652" headers="d26509e4614 ">
                                    <p><code class="codeph">TRUE</code> / <code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4652 d26509e4617 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4652 d26509e4620 ">
                                    <p>触发器仅在SQL Apply进程修改基表时触发。当用户进程修改基表时，触发器不会触发。因此， <code class="codeph">apply_server_only</code>属性会覆盖触发器的<code class="codeph">fire_once</code>参数。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>由于简单的对象类型列的表是不受支持可以通过创建触发在SQL应用过程的上下文中的触发器被复制（或者通过设定<code class="codeph">fire_once</code>这样的触发的参数到<code class="codeph">FALSE</code>或由这样的触发器的apply_server_only参数设置为<code class="codeph">TRUE</code> 。可以在主数据库上使用常规DML触发器将对象类型展平为可以支持的表。在逻辑备用数据库上的SQL Apply进程的上下文中触发的触发器将重构对象类型并以事务方式更新不支持的表。
                     </p>
                     <div class="infoboxnotealso" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-AC849AE5-38AA-4B70-90C4-6F76431D62CA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../arpls/DBMS_DDL.html#ARPLS008" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考</span></a>的的描述<code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code>程序和<code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code>功能</p>
                           </li>
                        </ul>
                     </div>
                     <p>以下示例显示如何使用触发器复制具有简单对象类型的表。此示例显示如何处理插入;相同的原则可以应用于更新和删除。嵌套表和<code class="codeph">VARRAY</code>也可以使用此技术进行复制，并使用循环的附加步骤来规范化嵌套数据。
                     </p><pre class="oac_no_warn" dir="ltr">- 简单对象类型创建或替换类型Person作为对象（FirstName varchar2（50），LastName varchar2（50），BirthDate Date） - 不支持的对象表创建表employees（IdNumber varchar2（10），Department varchar2（50），Info Person） - 通过触发器填充支持的表创建表employees_transfer（t_IdNumber varchar2（10），t_Department varchar2（50），t_FirstName varchar2（50），t_LastName varchar2（50），t_BirthDate Date） - 创建此触发器以展平对象primary上的表 - 此触发器不会在备用数据库上触发 - 在每个行上插入员工后创建或替换触发器flatten_employees声明开始插入employees_transfer（t_IdNumber，t_Department，t_FirstName，t_LastName，t_BirthDate）值（：new。IdNumber，：新的。部门：新的。Info.FirstName，新。Info.LastName，：new。Info.BirthDate）;结束 -   - 选项＃1（更好的选项：创建触发器 - 并将其apply-server-only属性设置为TRUE） - 在逻辑备用数据库中创建此触发器 - 在备用数据库上填充对象表 - 此触发器仅在应用复制行时触发 - 到备用 - 创建或替换触发器reconstruct_employees_aso在employees_transfer上插入后，每行开始插入员工（IdNumber，Department，Info）值（：new.t_IdNumber，：new.t_Department， Person（：new.t_FirstName，：new.t_LastName，：new.t_BirthDate））; end  - 将此触发器设置为从应用服务器执行dbms_ddl.set_trigger_firing_property（ -  trig_owner =&gt;'scott'， -  trig_name =&gt;'reconstruct_employees_aso'，property =&gt; dbms_ddl.apply_server_only，setting =&gt; TRUE）; -   - 选项＃2（创建一个触发器并设置 - 其fire-once属性为FALSE） - 在逻辑备用数据库中创建此触发器 - 在备用数据库上填充对象表 - 此触发器将在应用时触发将行复制到 - 备用数据库，但是我们需要确保我们 - 通过调用在SQL Apply进程内执行 -  dbms_logstdby.is_apply_server函数 - 在employees_transfer上插入后，为每行开始创建或替换触发器reconstruct_employees_nfo dbms_logstdby.is_apply_server（）然后插入员工（IdNumber，Department，Info）值（：new.t_IdNumber，：new.t_Department，Person（：new.t_FirstName，：new.t_LastName，：new.t_BirthDate））;万一; end  - 将此触发器设置为从应用服务器执行dbms_ddl.set_trigger_firing_property（ -  trig_owner =&gt;'scott'， -  trig_name =&gt;'reconstruct_employees_nfo'，property =&gt; dbms_ddl.fire_once，setting =&gt; FALSE）;</pre></div>
               </div><a id="SBYDB4836"></a><div class="props_rev_3"><a id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367" name="GUID-44D7C275-A991-4B6F-84A2-D76085E00367"></a><h4 id="SBYDB-GUID-44D7C275-A991-4B6F-84A2-D76085E00367" class="sect4"><span class="enumeration_section">11.6.5</span>通过主<span class="enumeration_section">节点</span>执行的时间点恢复进行恢复</h4>
                  <div>
                     <p>当逻辑备用数据库收到重做数据的新分支时，SQL Apply会自动获取重做数据的新分支。</p>
                     <div class="section">
                        <p>对于逻辑备用数据库，如果备用数据库未通过新的重置日志SCN（超过重做数据的新分支的开始）应用重做数据，则不需要手动干预</p>
                        <p>下表描述了如何将备用数据库与主数据库分支重新同步。</p>
                        <div class="tblformalwide" id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367__GUID-7474462F-5AF2-47BF-9E1B-681ED03EC9D7">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="This 3column table describes how to resynchronize the standby database with the primary database branch after you issue an OPEN RESETLOGS statement." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d26509e4816">如果是备用数据库。 。 。</th>
                                    <th align="left" valign="bottom" width="27%" id="d26509e4819">然后。 。 。</th>
                                    <th align="left" valign="bottom" width="41%" id="d26509e4822">执行这些步骤。 。 。</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4827" headers="d26509e4816 ">
                                       <p>尚未将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4827 d26509e4819 ">
                                       <p>SQL Apply自动获取重做数据的新分支。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4827 d26509e4822 ">
                                       <p>无需人工干预。SQL Apply自动将备用数据库与重做数据的新分支重新同步。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4837" headers="d26509e4816 ">
                                       <p>已经将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）并且在备用数据库上启用了闪回数据库</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4837 d26509e4819 ">
                                       <p>备用数据库将<span class="italic">在</span>重做数据的新分支<span class="italic">的未来</span>中恢复。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4837 d26509e4822 ">
                                       <ol>
                                          <li>
                                             <p>按照将<a href="examples-of-using-oracle-data-guard.html#GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465" title="这些步骤描述了在闪回主数据库并通过发出OPEN RESETLOGS语句打开它之后如何避免重新创建逻辑备用数据库。">逻辑备用数据库闪回到特定时间点的过程，</a>以闪回逻辑备用数据库。
                                             </p>
                                          </li>
                                          <li>
                                             <p>重新启动SQL Apply以继续将重做应用到新的重置日志分支。</p>
                                          </li>
                                       </ol>
                                       <p>SQL Apply自动将备用数据库与新分支重新同步。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4867" headers="d26509e4816 ">
                                       <p>已将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）并且备用数据库上未启用闪回数据库</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4867 d26509e4819 ">
                                       <p>主数据库已在指定的主数据库分支上与备用数据库分离。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4867 d26509e4822 ">
                                       <p>按照创建逻辑备用数据库中的过程重新<a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="创建逻辑备用数据库涉及许多步骤，包括先决条件和创建后任务。">创建逻辑备用数据库</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4884" headers="d26509e4816 ">
                                       <p>缺少从上一个重做数据分支末尾的归档重做日志文件</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4884 d26509e4819 ">
                                       <p>在检索丢失的日志文件之前，SQL Apply无法继续。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4884 d26509e4822 ">
                                       <p>从上一个分支中找到并注册缺少的归档重做日志文件。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>有关数据库化身，通过<code class="codeph">OPEN RESETLOGS</code>操作进行恢复以及闪回数据库的详细信息，请参阅“ <a href="../bradv/rman-performing-flashback-dbpitr.html#BRADV89752" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4837"></a><div class="props_rev_3"><a id="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" name="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9"></a><h4 id="SBYDB-GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" class="sect4"><span class="enumeration_section">11.6.6</span>在逻辑备用数据库上运行Oracle Streams Capture进程</h4>
                  <div>
                     <p>您可以在逻辑备用数据库上运行Oracle Streams捕获进程，以捕获逻辑备用数据库上存在的任何表（无论是本地表还是从主数据库复制的维护表）中的更改。</p>
                     <p>将更改捕获到维护的表时，与在主数据库上运行Oracle Streams捕获进程相比，存在额外的延迟。额外延迟是因为当您在逻辑备用数据库上运行时，Oracle Streams捕获进程必须等待更改从主数据库发送到逻辑备用数据库并由SQL Apply应用。在大多数情况下，如果您正在运行实时应用，则不会超过几秒钟。</p>
                     <p>Oracle Streams捕获进程与创建它的数据库相关联;数据库的作用是无关紧要的。例如，假设您有一个名为<code class="codeph">Boston</code>的主数据库和一个名为<code class="codeph">London</code>的逻辑备用数据库。在进行角色转换时，无法将Oracle Streams捕获过程从一个数据库移动到另一个数据库。例如，如果您在<code class="codeph">London</code>成为逻辑备用数据库时创建了Oracle Streams捕获进程，那么即使<code class="codeph">London</code>因角色转换操作（例如切换或故障转移）而成为主要进程，它仍会保留在<code class="codeph">London</code> 。要使Oracle Streams捕获过程在角色转换后继续工作，您必须编写角色转换触发器，如下所示：</p><pre class="oac_no_warn" dir="ltr">在DB_ROLE_CHANGE上创建或替换触发器streams_aq_job_role_change1数据库声明游标capture_aq_jobs是select job_name，database_role来自dba_scheduler_job_roles，其中job_name类似'AQ_JOB％';你capture_aq_jobs％ROWTYPE; my_db_role varchar2（16）;如果（dbms_logstdby.db_is_logstdby（）= 1）则开始，然后my_db_role：='LOGICAL STANDBY';否则my_db_role：='PRIMARY';万一;打开capture_aq_jobs;循环获取capture_aq_jobs到u;在capture_aq_jobs％NOTFOUND时退出; if（u.database_role！= my_db_role）然后是dbms_scheduler.set_attribute（u.job_name，'database_role'，my_db_role）;万一;结束循环; close capture_aq_jobs;当别人开始加薪时的例外;结束;结束;</pre></div>
               </div>
            </div><a id="SBYDB4838"></a><div class="props_rev_3"><a id="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" name="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8"></a><h3 id="SBYDB-GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" class="sect3"><span class="enumeration_section">11.7</span>调整逻辑备用数据库</h3>
               <div>
                  <p>这些主题提供有关调整逻辑备用数据库的各种方法的信息。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-10287018-12F8-4727-AB2D-C720571AF4B6" title="在主数据库上，如果表没有主键或唯一索引，并且您确定行是唯一的，则创建主键RELY约束。">创建主键RELY约束</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4DDC26F5-29CC-435E-9996-8887DA653032" title="应在备用数据库上收集统计信息，因为基于成本的优化器（CBO）使用它们来确定最佳查询执行路径。">收集基于成本的优化程序的统计信息</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" title="可以修改三个参数来控制分配给SQL Apply的进程数：MAX_SERVERS，APPLY_SERVERS和PREPARE_SERVERS。">调整进程数</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" title="对于某些工作负载，SQL Apply可能会使用大量的pageout操作，从而降低了系统的整体吞吐量。增加分配给LCR缓存的内存可能会有所帮助。">调整用于LCR缓存的内存</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" title="默认情况下，事务将按照它们在主数据库上提交的确切顺序应用于逻辑备用数据库。">调整如何在逻辑备用数据库上应用事务</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4839"></a><div class="props_rev_3"><a id="GUID-10287018-12F8-4727-AB2D-C720571AF4B6" name="GUID-10287018-12F8-4727-AB2D-C720571AF4B6"></a><h4 id="SBYDB-GUID-10287018-12F8-4727-AB2D-C720571AF4B6" class="sect4"><span class="enumeration_section">11.7.1</span>创建主键RELY约束</h4>
                  <div>
                     <p>在主数据库上，如果表没有主键或唯一索引，并且您确定行是唯一的，则创建主键<code class="codeph">RELY</code>约束。
                     </p>
                     <div class="section">
                        <p>在逻辑备用数据库上，在构成主键的列上创建索引。以下查询生成一个表列表，其中没有索引信息，逻辑备用数据库可以使用这些表来应用于唯一标识行。通过在下表中创建索引，可以显着提高性能。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT OWNER，TABLE_NAME FROM DBA_TABLES  - &gt; WHERE OWNER NOT IN（从DBA_LOGSTDBY_SKIP中选择所有者 - &gt; WHERE STATEMENT_OPT ='内部模式'） - &gt; MINUS  - &gt; SELECT DISTINCT TABLE_OWNER，TABLE_NAME FROM DBA_INDEXES  - &gt; WHERE INDEX_TYPE NOT LIKE（'FUNCTION -BASED％'） - &gt; MINUS  - &gt; SELECT OWNER，TABLE_NAME FROM DBA_LOGSTDBY_UNSUPPORTED;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>您可以将依赖主键约束添加到主数据库上的表，如下所示：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在主数据库中添加主键依赖约束：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER TABLE HR.TEST_EMPLOYEES添加主键（EMPNO）依赖禁用;</pre><p>这确保了可以用于唯一标识<code class="codeph">HR.TEST_EMPLOYEES</code>表中的行的<code class="codeph">EMPNO</code>列作为对该表执行的任何更新的一部分进行补充记录。
                              </p>
                              <p>请注意， <code class="codeph">HR.TEST_EMPLOYEES</code>表仍然没有在逻辑备用数据库上指定任何唯一索引。这可能导致<code class="codeph">UPDATE</code>语句对逻辑备用数据库执行全表扫描。您可以通过在逻辑备用数据库上的<code class="codeph">EMPNO</code>列上添加唯一索引来解决此问题。有关<code class="codeph">RELY</code>约束的详细信息，请参阅<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a>和<a href="../sqlrf/constraint.html#SQLRF52223" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                              <p>执行逻辑备用数据库上的其余步骤。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>禁用警卫，以便您可以修改逻辑备用数据库上的已维护表：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在<code class="codeph">EMPNO</code>列上添加唯一索引：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE UNIQUE INDEX UI_TEST_EMP ON HR.TEST_EMPLOYEES（EMPNO）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启用警卫：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION ENABLE GUARD;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4840"></a><div class="props_rev_3"><a id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032" name="GUID-4DDC26F5-29CC-435E-9996-8887DA653032"></a><h4 id="SBYDB-GUID-4DDC26F5-29CC-435E-9996-8887DA653032" class="sect4"><span class="enumeration_section">11.7.2</span>收集基于成本的优化器的统计信息</h4>
                  <div>
                     <p>应在备用数据库上收集统计信息，因为基于成本的优化器（CBO）使用它们来确定最佳查询执行路径。</p>
                     <p>在以先前统计信息不准确的方式修改模式对象的数据或结构之后，应收集新的统计信息。例如，在将大量行插入或删除到表中后，收集有关行数的新统计信息。</p>
                     <p>应在备用数据库上收集统计信息，因为主数据库上的DML和DDL操作是根据工作负载执行的。虽然备用数据库在逻辑上等同于主数据库，但SQL Apply可能以不同的方式执行工作负载。这就是在逻辑备用数据库上使用STATS包并且<code class="codeph">V$SYSSTAT</code>视图可用于确定哪些表占用最多资源和表扫描的原因。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032__GUID-D9C801C3-A87B-4A80-9B27-5F2EC5C3A401">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="SBYDB4841"></a><div class="props_rev_3"><a id="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" name="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB"></a><h4 id="SBYDB-GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" class="sect4"><span class="enumeration_section">11.7.3</span>调整进程数</h4>
                  <div>
                     <p>可以修改三个参数来控制分配给SQL Apply的进程数： <code class="codeph">MAX_SERVERS</code> ， <code class="codeph">APPLY_SERVERS</code>和<code class="codeph">PREPARE_SERVERS</code> 。</p>
                     <p>以下关系必须始终成立：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">APPLY_SERVERS + P</code> <code class="codeph">REPARE_SERVERS =</code> <code class="codeph">MAX_SERVERS - 3</code></p>
                           <p>这是因为SQL Apply始终为<code class="codeph">READER</code> ， <code class="codeph">BUILDER</code>和<code class="codeph">ANALYZER</code>角色分配一个进程。
                           </p>
                        </li>
                        <li>
                           <p>默认情况下， <code class="codeph">MAX_SERVERS</code>设置为9， <code class="codeph">PREPARE_SERVERS</code>设置为1， <code class="codeph">APPLY_SERVERS</code>设置为5。
                           </p>
                        </li>
                        <li>
                           <p>Oracle建议您只更改<code class="codeph">MAX_SERVERS</code>通过参数<code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code>程序，并允许SQL应用准备和应用进程之间适当地分配服务器进程。
                           </p>
                        </li>
                        <li>
                           <p>SQL应用使用该分配1个的处理分配算法<code class="codeph">PREPARE_SERVER</code>分配给SQL作为由指定的应用，每20个服务器进程<code class="codeph">MAX_SERVER</code>并限制的数量<code class="codeph">PREPARE_SERVERS</code>至5。因此，如果将<code class="codeph">MAX_SERVERS</code>设置为1到20之间的任何值，则SQL Apply将分配1个服务器进程作为<code class="codeph">PREPARER</code> ，并在满足前面描述的关系的同时将其余进程分配为<code class="codeph">APPLIERS</code> 。同样，如果将<code class="codeph">MAX_SERVERS</code>设置为21到40之间的值，则SQL Apply将分配2个服务器进程作为<code class="codeph">PREPARERS</code> ，其余部分作为<code class="codeph">APPLIERS</code> ，同时满足前面描述的关系。您可以通过直接设置<code class="codeph">APPLY_SERVERS</code>和<code class="codeph">PREPARE_SERVERS</code>来覆盖此内部进程分配算法，前提是满足前面描述的关系。
                           </p>
                        </li>
                     </ul>
                     <p>以下部分描述：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" title="在调整APPLIER进程数之前，应确定这样做是否有助于实现更高的吞吐量。">调整APPLIER进程数</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" title="您很少需要调整PREPARER进程的数量。在增加数量之前，您必须确保某些条件成立。">调整PREPARER进程数</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4842"></a><div class="props_rev_3"><a id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" name="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E"></a><h5 id="SBYDB-GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" class="sect5"><span class="enumeration_section">11.7.3.1</span>调整APPLIER进程数</h5>
                     <div>
                        <p>在调整<code class="codeph">APPLIER</code>进程数之前，应确定这样做是否有助于实现更高的吞吐量。
                        </p>
                        <div class="section">
                           <p>要确定此问题，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>通过发出以下查询来检查<code class="codeph">APPLIER</code>进程是否繁忙：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_APPLIER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='APPLIER'和status_code = 16116; IDLE_APPLIER ------------------------- 0</pre></div>
                           </li>
                           <li class="stepexpand"><span>一旦确定没有空闲的<code class="codeph">APPLIER</code>进程，请发出以下查询以确保如果您选择调整<code class="codeph">APPLIERS</code>的数量，则有足够的工作可用于其他<code class="codeph">APPLIER</code>进程：</span><div><pre class="oac_no_warn" dir="ltr">SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME ='txns applied'或NAME ='distinct txns in queue';</pre><p>这两个统计信息保留了<code class="codeph">APPLIER</code>流程准备应用的累计事务总数以及已应用的事务数。
                                 </p>
                                 <p>如果数字（ <code class="codeph">distinct txns in queue - txns applied</code> ）高于可用<code class="codeph">APPLIER</code>进程数的两倍，则如果增加<code class="codeph">APPLIER</code>进程数，则可以提高吞吐量。
                                 </p>
                                 <div class="infoboxnote" id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E__GUID-E26A3F6A-77FA-4CD9-BD1B-CBBCAAF487F7">
                                    <p class="notep1">注意：</p>
                                    <p>这个数字是对现成工作的粗略衡量。工作负载可能使得就绪事务之间的相互依赖性阻止了额外的可用<code class="codeph">APPLIER</code>进程应用它们。例如，如果准备应用的大多数事务是DDL事务，则添加更多<code class="codeph">APPLIER</code>进程不会导致更高的吞吐量。
                                    </p>
                                 </div>
                                 <p>假设您要将<code class="codeph">APPLIER</code>进程数从默认值5调整为20，同时将<code class="codeph">PREPARER</code>进程数保持为1。因为您必须满足以下等式：</p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS  -  3</pre><p>您必须先将<code class="codeph">MAX_SERVERS</code>设置为24。完成后，您可以将<code class="codeph">APPLY_SERVERS</code>的数量设置为20，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SERVERS'，24）; SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'APPLY_SERVERS'，20）;</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="SBYDB4843"></a><div class="props_rev_3"><a id="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" name="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8"></a><h5 id="SBYDB-GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" class="sect5"><span class="enumeration_section">11.7.3.2</span>调整PREPARER进程数</h5>
                     <div>
                        <p>您很少需要调整<code class="codeph">PREPARER</code>进程的数量。在增加数量之前，您必须确保某些条件成立。
                        </p>
                        <div class="section">
                           <p>必须符合的条件如下：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>所有<code class="codeph">PREPARER</code>流程都很忙</p>
                              </li>
                              <li>
                                 <p>准备应用的事务数小于可用的<code class="codeph">APPLIER</code>进程数</p>
                              </li>
                              <li>
                                 <p>有空闲的<code class="codeph">APPLIER</code>进程</p>
                              </li>
                           </ul>
                           <p>以下步骤说明如何确定这些条件为真：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>确保所有<code class="codeph">PREPARER</code>进程都忙<a id="d26509e5824" class="indexterm-anchor"></a> ：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_PREPARER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='PREPARER'和status_code = 16116; IDLE_PREPARER ------------- 0</pre></div>
                           </li>
                           <li class="stepexpand"><span>确保准备应用的事务数小于<code class="codeph">APPLIER</code>进程数：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME ='txns applied'OR  - &gt; NAME ='distinct txns in queue'; NAME VALUE --------------------- ------- txns在队列12896中应用了27892个不同的txns</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS APPLIER_COUNT  - &gt; FROM V $ LOGSTDBY_PROCESS WHERE TYPE ='APPLIER'; APPLIER_COUNT ------------- 20</pre><p>注意：多次发出此查询以确保这不是瞬态事件。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>确保有空闲的<code class="codeph">APPLIER</code>进程：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_APPLIER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='APPLIER'和status_code = 16116; IDLE_APPLIER ------------------------- 19</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>在该示例中，已经满足增加<code class="codeph">PREPARER</code>过程数量所需的所有三个条件。假设您要将<code class="codeph">APPLIER</code>进程数设置为20，并将<code class="codeph">PREPARER</code>进程数从1增加到3。因为您总是必须满足以下等式：</p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS  -  3</pre><p>首先需要将<code class="codeph">MAX_SERVERS</code>的数量从24增加到26，以适应增加的编制者数量。然后，您可以增加<code class="codeph">PREPARER</code>进程的数量，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SERVERS'，26）; SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'PREPARE_SERVERS'，3）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4844"></a><div class="props_rev_3"><a id="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" name="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F"></a><h4 id="SBYDB-GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" class="sect4"><span class="enumeration_section">11.7.4</span>调整用于LCR Cache的内存</h4>
                  <div>
                     <p>对于某些工作负载，SQL Apply可能会使用大量的pageout操作，从而降低了系统的整体吞吐量。增加分配给LCR缓存的内存可能会有所帮助。</p>
                     <div class="section">
                        <p>要确定分配给LCR缓存的增加内存是否有益，请执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>发出以下查询以获取pageout活动的快照：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME LIKE'％page％' - &gt; OR NAME LIKE'％uptime％'或NAME LIKE'％idle％';</pre><pre class="oac_no_warn" dir="ltr">NAME VALUE ---------------------------- -------------- coordinator uptime（seconds）894856页面调出20000页面时间（秒）2系统空闲时间（秒）1000</pre></div>
                        </li>
                        <li class="stepexpand"><span>在5分钟内再次发出查询：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME LIKE'％page％' - &gt; OR NAME LIKE'％uptime％'或NAME LIKE'％idle％';</pre><pre class="oac_no_warn" dir="ltr">NAME VALUE ---------------------------- -------------- coordinator uptime（seconds）895156页面调出1020000页面时间（秒）100系统空闲时间（秒）1000</pre></div>
                        </li>
                        <li class="stepexpand"><span>计算规范化的分页活动。例如：</span><div><pre class="oac_no_warn" dir="ltr">协调器正常运行时间的变化（C）=（895156  -  894856）= 300秒附加空闲时间的数量（I）=（1000  -  1000）= 0在页面输出中花费的时间的变化（P）=（100  -  2）= 98秒与正常运行时间相比的Pageout时间= P /（CI）= 98 / 300~32.67％</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>理想情况下，页面输出活动不应占用总运行时间的5％以上。如果您继续在延长的时间间隔内拍摄快照，并且发现页面输出活动继续占用应用时间的很大一部分，则增加内存大小可能会带来一些好处。您可以通过设置分配给LCR缓存的内存来增加分配给SQL Apply的内存（对于此示例，SGA设置为1 GB）：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SGA'，1024）; PL / SQL过程成功完成</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4845"></a><div class="props_rev_3"><a id="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" name="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD"></a><h4 id="SBYDB-GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" class="sect4"><span class="enumeration_section">11.7.5</span>调整如何在逻辑备用数据库上应用事务</h4>
                  <div>
                     <p>默认情况下，事务将按照它们在主数据库上提交的确切顺序应用于逻辑备用数据库。</p>
                     <div class="section">
                        <p>提交事务的严格默认顺序允许任何应用程序在逻辑备用数据库上透明地运行。</p>
                        <p>但是，许多应用程序不需要在所有事务中进行如此严格的排序。此类应用程序不需要以与在主数据库中提交的顺序相同的顺序提交包含非重叠行集的事务。这种不太严格的排序通常会导致逻辑备用数据库的应用率更高。您可以通过执行以下步骤来更改提交事务的默认顺序：</p>
                        <ol>
                           <li>
                              <p>停止SQL应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了</pre></li>
                           <li>
                              <p>发出以下命令以允许事务从主数据库上的提交方式中不按顺序应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'PRESERVE_COMMIT_ORDER'，'FALSE'）; PL / SQL过程成功完成</pre></li>
                           <li>
                              <p>启动SQL Apply：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了</pre></li>
                        </ol>
                        <p>您可以按如下方式更改应用模式：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了</pre></div>
                        </li>
                        <li class="stepexpand"><span>恢复<code class="codeph">PRESERVE_COMMIT_ORDER</code>参数的默认值：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_UNSET（'PRESERVE_COMMIT_ORDER'）; PL / SQL过程成功完成</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了</pre><p>对于典型的联机事务处理（OLTP）工作负载，非默认模式可以提供比默认应用模式高50％或更高的吞吐量改进。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB5050"></a><a id="SBYDB5051"></a><a id="SBYDB5052"></a><a id="SBYDB5053"></a><a id="SBYDB4846"></a><div class="props_rev_3"><a id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607" name="GUID-4A691CE0-7424-4547-800E-0C9D606F0607"></a><h3 id="SBYDB-GUID-4A691CE0-7424-4547-800E-0C9D606F0607" class="sect3"><span class="enumeration_section">11.8</span>逻辑备用数据库环境中的备份和恢复</h3>
               <div>
                  <p>您可以使用可用的传统方法备份逻辑备用数据库，然后通过还原数据库备份并在归档日志上执行介质恢复以及备份来恢复它。</p>
                  <p>以下各项与逻辑备用数据库的上下文相关。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-6DDCD88E-7245-4995-9DDC-DDC93FBBFA4B">创建和使用本地RMAN恢复目录时的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果计划创建RMAN恢复目录或执行修改目录的任何RMAN活动，则必须在逻辑备用数据库中将<code class="codeph">GUARD</code>设置为<code class="codeph">STANDBY</code>运行。
                     </p>
                     <p>如果本地恢复目录仅保留在逻辑备用控制文件中，则可以将<code class="codeph">GUARD</code>设置为<code class="codeph">ALL</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-0FBF01B3-2B27-446E-8860-C69FBE8B608B">控制文件备份的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle建议您在实例化逻辑备用数据库后立即进行控制文件备份。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-99B62329-B7D2-4B0A-A1E8-95506049B107">时间点恢复的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>在时间点恢复之后第一次启动SQL Apply时，它必须能够在本地系统上查找所需的存档日志或从主数据库中获取它们。使用<code class="codeph">V$LOGSTDBY_PROCESS</code>视图确定是否需要在主数据库上还原任何已归档日志。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-9D5B3032-D8AB-4889-BA73-B0DB1A478B95">表空间时间点恢复的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果对逻辑备用数据库中的表空间执行时间点恢复，则必须确保满足以下条件之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表空间不包含SQL Apply进程正在维护的表或分区</p>
                        </li>
                        <li>
                           <p>如果表空间包含由SQL Apply进程维护的表或分区，则使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABL</code> E过程重新实例化逻辑备用数据库中恢复的表空间中包含的所有维护表，或使用<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程注册要从逻辑备用数据库的维护表列表中跳过的已恢复表空间中包含的所有表。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>