<html id="04998.host-arrays.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>主机阵列</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="embedded-PL-SQL.html" title="Previous" type="text/html"></link>
      <link rel="next" href="handling-run-time-errors.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-PL-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="handling-run-time-errors.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">主机阵列</li>
            </ol>
            <a id="GUID-6B57FBAE-0303-41B9-9056-5C20384442B7" name="GUID-6B57FBAE-0303-41B9-9056-5C20384442B7"></a>
            
            <h2 id="LNPCC-GUID-6B57FBAE-0303-41B9-9056-5C20384442B7" class="sect2"><span class="enumeration_chapter">8个</span>主机阵列</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d40176e6" class="indexterm-anchor"></a>本章介绍如何使用数组来简化编码并提高程序性能。您将学习如何使用数组操作Oracle数据，如何使用单个SQL语句操作数组的所有元素，以及如何限制处理的数组元素的数量。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="host-arrays.html#GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF">为什么要使用数组？</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-C0A64DDB-0282-46F6-ABAB-13047958B085">关于声明主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D103007D-E544-4516-A1CB-826978F67C2B">关于在SQL语句中使用数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147">关于选择数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2">关于使用数组插入</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-755F6669-A311-454A-A561-93FA79BF6BDD">关于使用数组更新</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD">关于使用数组删除</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0">关于使用FOR子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3">关于使用WHERE子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4">结构数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿当前的</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-989279AF-E176-41C7-A2D0-84685367DA54">关于使用sqlca.sqlerrd [2]</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408">关于使用其他数组插入/选择语法</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786">关于使用隐式缓冲插入</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3434"></a><div class="props_rev_3"><a id="GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF" name="GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF"></a><h3 id="LNPCC-GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF" class="sect3"><span class="enumeration_section">8.1</span>为什么要使用数组？
               </h3>
               <div>
                  <p>阵列减少了编程时间并提高了性能。 <a id="d40176e94" class="indexterm-anchor"></a> 
                  </p>
                  <p>对于数组，您可以使用单个SQL语句操作整个数组。因此，Oracle通信开销显着降低，尤其是在网络环境中。运行时的主要部分用于客户端程序和服务器数据库之间的网络往返。数组减少往返次数。</p>
                  <p>例如，假设您要将有关300名员工的信息插入EMP表。如果没有数组，您的程序必须执行300个单独的INSERT  - 每个员工一个。对于数组，只需要完成一个INSERT。</p>
               </div>
            </div><a id="LNPCC3435"></a><div class="props_rev_3"><a id="GUID-C0A64DDB-0282-46F6-ABAB-13047958B085" name="GUID-C0A64DDB-0282-46F6-ABAB-13047958B085"></a><h3 id="LNPCC-GUID-C0A64DDB-0282-46F6-ABAB-13047958B085" class="sect3"><span class="enumeration_section">8.2</span>关于声明主机阵列</h3>
               <div>
                  <p>以下示例声明了三个主机阵列，每个阵列最多包含50个元素： <a id="d40176e114" class="indexterm-anchor"></a><a id="d40176e118" class="indexterm-anchor"></a><a id="d40176e122" class="indexterm-anchor"></a><a id="d40176e126" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [10]; int emp_number [50];浮动工资[50];</pre><p>VARCHAR的数组也是允许的。以下声明是有效的宿主语言声明：<a id="d40176e135" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">VARCHAR v_array [10] [30];</pre></div><a id="LNPCC3436"></a><div class="props_rev_3"><a id="GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531" name="GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531"></a><h4 id="LNPCC-GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531" class="sect4"><span class="enumeration_section">8.2.1</span>限制（声明主机阵列）</h4>
                  <div>
                     <p>除对象类型外，您不能声明指针的主机数组。<a id="d40176e152" class="indexterm-anchor"></a></p>
                     <p>除字符数组（字符串）外，可能在SQL语句中引用的主机数组仅限于一个维度。因此，以下示例中声明的二维数组<span class="italic">无效</span> ： <a id="d40176e161" class="indexterm-anchor"></a><a id="d40176e165" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int hi_lo_scores [25] [25]; /* 不允许 */</pre></div>
               </div><a id="LNPCC3437"></a><div class="props_rev_3"><a id="GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A" name="GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A"></a><h4 id="LNPCC-GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A" class="sect4"><span class="enumeration_section">8.2.2</span>阵列的最大尺寸</h4>
                  <div>
                     <p>在一次获取中可访问的SQL语句中的最大数组元素数是32K（或者可能更大，具体取决于平台和可用内存）。如果您尝试访问超过最大值的数字，则会出现“参数超出范围”运行时错误。如果该语句是匿名PL / SQL块，则可访问的数组元素数限制为32512除以数据类型的大小。</p>
                  </div>
               </div>
            </div><a id="LNPCC3438"></a><div class="props_rev_3"><a id="GUID-D103007D-E544-4516-A1CB-826978F67C2B" name="GUID-D103007D-E544-4516-A1CB-826978F67C2B"></a><h3 id="LNPCC-GUID-D103007D-E544-4516-A1CB-826978F67C2B" class="sect3"><span class="enumeration_section">8.3</span>关于在SQL语句中使用数组</h3>
               <div>
                  <p>您可以在INSERT，UPDATE和DELETE语句中将主机数组用作输入变量，在SELECT和FETCH语句的INTO子句中使用输出变量。 <a id="d40176e195" class="indexterm-anchor"></a><a id="d40176e200" class="indexterm-anchor"></a> 
                  </p>
                  <p>用于主机阵列和简单主机变量的嵌入式SQL语法几乎相同。一个区别是可选的FOR子句，它允许您控制数组处理。此外，在SQL语句中混合主机数组和简单主机变量存在限制。</p>
                  <p>以下部分说明了在数据操作语句中使用主机数组。</p>
               </div><a id="LNPCC3439"></a><div class="props_rev_3"><a id="GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54" name="GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54"></a><h4 id="LNPCC-GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54" class="sect4"><span class="enumeration_section">8.3.1</span>关于引用主机阵列</h4>
                  <div>
                     <p>如果在单个SQL语句中使用多个主机数组，则它们的元素数应相同。否则，在预编译时发出“数组大小不匹配”警告消息。如果忽略此警告，预编译器将使用<span class="italic">最少</span>数量的元素进行SQL操作。 <a id="d40176e223" class="indexterm-anchor"></a> 
                     </p>
                     <p>在此示例中，只有25行<a id="d40176e230" class="indexterm-anchor"></a><a id="d40176e234" class="indexterm-anchor"></a>插入<a id="d40176e239" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [50]; char emp_name [50] [10]; int dept_number [25]; / *在这里填充主机数组。* / EXEC SQL INSERT INTO emp（empno，ename，deptno）VALUES（：emp_number，：emp_name，：dept_number）;</pre><p>可以在SQL语句中下标主机数组，并在循环中使用它们来INSERT或获取数据。例如，您可以使用循环插入数组中的每个第五个元素，例如：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i + = 5）EXEC SQL INSERT INTO emp（empno，deptno）VALUES（：emp_number [i]，：dept_number [i]）;</pre><p>但是，如果需要处理的数组元素是连续的，则不应在循环中处理主机数组。只需在SQL语句中使用非脚本化数组名称即可。Oracle将包含元素编号为<span class="italic">n的</span>主机数组的SQL语句视为使用<span class="italic">n个</span>不同标量变量执行<span class="italic">n</span>次的相同语句。
                     </p>
                  </div>
               </div><a id="LNPCC3440"></a><div class="props_rev_3"><a id="GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF" name="GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF"></a><h4 id="LNPCC-GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF" class="sect4"><span class="enumeration_section">8.3.2</span>关于使用指标数组</h4>
                  <div>
                     <p>您可以使用指示符数组将NULL分配给输入主机数组，并检测输出主机数组中的NULL或截断值（仅限字符列）。以下示例显示如何使用指示符数组进行INSERT： <a id="d40176e276" class="indexterm-anchor"></a><a id="d40176e280" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [50]; int dept_number [50];浮动佣金[50];简短的comm_ind [50]; / * indicator array * / / *填充主机和指示器阵列。要在comm列中插入null，请将-1分配给指示符数组中的相应元素。* / EXEC SQL INSERT INTO emp（empno，deptno，comm）VALUES（：emp_number，：dept_number，：Commission INDICATOR：comm_ind）;</pre></div>
               </div><a id="LNPCC3441"></a><div class="props_rev_3"><a id="GUID-15264290-896F-4D4A-90DF-ABABECD6A337" name="GUID-15264290-896F-4D4A-90DF-ABABECD6A337"></a><h4 id="LNPCC-GUID-15264290-896F-4D4A-90DF-ABABECD6A337" class="sect4"><span class="enumeration_section">8.3.3</span> Oracle限制（针对主机阵列）</h4>
                  <div>
                     <p>混合主机阵列标主机变量中的值，SET，进入或WHERE子句是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e302" class="indexterm-anchor"></a><a id="d40176e306" class="indexterm-anchor"></a> 
                     </p>
                     <p>你不能使用主机阵列<a id="d40176e313" class="indexterm-anchor"></a><a id="d40176e315" class="indexterm-anchor"></a> UPDATE或DELETE语句中的CURRENT OF子句。
                     </p>
                  </div>
               </div><a id="LNPCC3442"></a><div class="props_rev_3"><a id="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456" name="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456"></a><h4 id="LNPCC-GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456" class="sect4"><span class="enumeration_section">8.3.4</span> ANSI限制和要求</h4>
                  <div>
                     <p>阵列接口是ANSI / ISO嵌入式SQL标准的Oracle扩展。但是，当您使用MODE = ANSI进行预编译时，仍然允许使用数组SELECT和FETCH。如果需要，可以使用FIPS flagger预编译器选项标记数组的使用。<a id="d40176e331" class="indexterm-anchor"></a></p>
                     <p>在执行数组SELECT和FETCH时，始终使用指示符数组。这样，您可以在关联的输出主机阵列中测试NULL。</p>
                     <p>如果<code class="codeph">DBMS=V7</code>或<code class="codeph">DBMS=v8</code>并且<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>将<code class="codeph">NULL</code>列值转换为与指标数组无关的主机数组，则Oracle停止处理，将<code class="codeph">sqlerrd[2]</code>为已处理的行数，并返回错误信息。当<code class="codeph">DBMS=V7</code>或<code class="codeph">DBMS=v8</code> ，Oracle不会将截断视为错误。
                     </p>
                     <p>此外，如果由于使用<code class="codeph">NULL</code>而导致<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>导致任何警告（如<code class="codeph">ORA-24347</code> ，并且如果任何列没有指示符数组，则Oracle将停止处理。
                     </p>
                     <div class="infoboxnote" id="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456__GUID-86603649-D6F9-4CDC-A732-433F7EE87304">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <p>对<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>中的所有列使用指示符变量。如果所有列都没有指示符，则可以使用预编译器选项<code class="codeph">unsafe_null=yes</code>作为替代。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3443"></a><div class="props_rev_3"><a id="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147" name="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147"></a><h3 id="LNPCC-GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147" class="sect3"><span class="enumeration_section">8.4</span>关于选择数组</h3>
               <div>
                  <p>您可以在SELECT语句中将主机数组用作输出变量。如果您知道SELECT将返回的最大行数，则只需使用该数量的元素声明主机数组。在以下示例中，您可以直接选择三个主机阵列。知道SELECT将返回不超过50行，您声明数组有50个元素： <a id="d40176e402" class="indexterm-anchor"></a><a id="d40176e407" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [20]; int emp_number [50];浮动工资[50]; EXEC SQL SELECT ENAME，EMPNO，SAL INTO：emp_name，：emp_number，：salary FROM EMP WHERE SAL&gt; 1000;</pre><p>在前面的示例中，SELECT语句最多返回50行。如果符合条件的行少于50个，或者您只想检索50行，则此方法就足够了。但是，如果有超过50个符合条件的行，则无法以这种方式检索所有行。如果重新执行SELECT语句，它只会再次返回前50行，即使更多符合条件。您必须声明一个更大的数组或声明一个游标以用于FETCH语句。</p>
                  <p>如果SELECT INTO语句返回的行数多于您声明的元素数，则Oracle会发出错误消息，除非您指定SELECT_ERROR = NO。</p>
                  <div class="infoboxnotealso" id="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147__GUID-88CD57E2-44B7-44BF-9C60-3BAF4FA0E274">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="precompiler-options.html#GUID-FC726DCD-2AAE-4A4B-A293-C8C23382A9B5">预编译器选项</a> ”</span>有关SELECT_ERROR选项的更多信息。
                     </p>
                  </div>
               </div><a id="LNPCC3444"></a><div class="props_rev_3"><a id="GUID-997A0050-15EB-4D71-A957-AAB790331092" name="GUID-997A0050-15EB-4D71-A957-AAB790331092"></a><h4 id="LNPCC-GUID-997A0050-15EB-4D71-A957-AAB790331092" class="sect4"><span class="enumeration_section">8.4.1</span>光标提取</h4>
                  <div>
                     <p>如果您不知道SELECT将返回的最大行数，您可以声明并打开游标，然后在“批处理”中从中获取它。</p>
                     <p>循环内的批量提取可让您轻松检索大量行。每个FETCH返回当前活动集中的下一批行。在以下示例中，您将获取20行批处理： <a id="d40176e438" class="indexterm-anchor"></a><a id="d40176e442" class="indexterm-anchor"></a><a id="d40176e446" class="indexterm-anchor"></a><a id="d40176e450" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [20];浮动工资[20]; EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT empno，sal FROM emp; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND会破坏; for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_number，：salary; / *处理批次行* / ...} ...
</pre><p>不要忘记检查上次获取中实际返回的行数，并处理它们。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D">提取的行数</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3445"></a><div class="props_rev_3"><a id="GUID-989279AF-E176-41C7-A2D0-84685367DA54" name="GUID-989279AF-E176-41C7-A2D0-84685367DA54"></a><h4 id="LNPCC-GUID-989279AF-E176-41C7-A2D0-84685367DA54" class="sect4"><span class="enumeration_section">8.4.2</span>关于使用sqlca.sqlerrd [2]</h4>
                  <div>
                     <p>对于INSERT，UPDATE，DELETE和SELECT INTO语句， <code class="codeph">sqlca.sqlerrd[2]</code>记录处理的行数。对于FETCH语句，它记录已处理的行的累积总和。 <a id="d40176e482" class="indexterm-anchor"></a> 
                     </p>
                     <p>当使用具有FETCH的主机数组时，要查找最近迭代返回的行数，请从其先前的值（存储在另一个变量中）中减去<code class="codeph">sqlca.sqlerrd[2]</code>的当前值。在以下示例中，您确定最近一次提取返回的行数：</p><pre class="oac_no_warn" dir="ltr">int emp_number [100]; char emp_name [100] [20]; int rows_to_fetch，rows_before，rows_this_time; EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT empno，ename FROM emp WHERE deptno = 30; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND CONTINUE; / *初始化循环变量* / rows_to_fetch = 20; / *每个“批处理”中的行数* / rows_before = 0; / * sqlerrd的前一个值[2] * / rows_this_time = 20; while（rows_this_time == rows_to_fetch）{EXEC SQL FOR：rows_to_fetch FETCH emp_cursor INTO：emp_number，：emp_name; rows_this_time = sqlca.sqlerrd [2]  -  rows_before; rows_before = sqlca.sqlerrd [2]; } ...
</pre><p>当数组操作期间发生错误时， <code class="codeph">sqlca.sqlerrd[2]</code>也很有用。处理在导致错误的行停止，因此<code class="codeph">sqlerrd[2]</code>给出成功处理的行数。
                     </p>
                  </div>
               </div><a id="LNPCC3446"></a><div class="props_rev_3"><a id="GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D" name="GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D"></a><h4 id="LNPCC-GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D" class="sect4"><span class="enumeration_section">8.4.3</span>提取的行数</h4>
                  <div>
                     <p>每个FETCH最多返回数组中的总行数。在以下情况下返回的行数较少： <a id="d40176e513" class="indexterm-anchor"></a> 
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>达到活动集的结尾。“无数据发现”Oracle错误代码返回到SQLCA中的SQLCODE。例如，如果您获取多个元素数组100但仍返回20行，则会发生这种情况。</p>
                        </li>
                        <li>
                           <p>仍然需要获取完整批次的行。例如，如果您将70个行提取到20个数字元素的数组中，则会发生这种情况，因为在第三个FETCH之后，只剩下10行要提取。</p>
                        </li>
                        <li>
                           <p>处理行时检测到错误。FETCH失败，适用的Oracle错误代码返回给SQLCODE。</p>
                        </li>
                     </ul>
                     <p>返回的累计行数可以在SQLCA的<span class="italic">sqlerrd</span>的第三个元素中<span class="italic">找到</span> ，在本指南中称为<code class="codeph">sqlerrd[2]</code> 。这适用于每个打开的游标。在以下示例中，请注意如何单独维护每个游标的状态： <a id="d40176e536" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor1; EXEC SQL OPEN cursor2; EXEC SQL FETCH cursor1 INTO：array_of_20; / *现在在sqlerrd [2]中运行总计是20 * / EXEC SQL FETCH cursor2 INTO：array_of_30; / *现在在sqlerrd [2]中运行总计是30，而不是50 * / EXEC SQL FETCH cursor1 INTO：array_of_20; / *现在在sqlerrd [2]中运行总计是40（20 + 20）* / EXEC SQL FETCH cursor2 INTO：array_of_30; / *现在在sqlerrd [2]中运行总计为60（30 + 30）* /</pre></div>
               </div><a id="LNPCC3447"></a><div class="props_rev_3"><a id="GUID-91517D50-1ACB-4191-9198-05D0F8EE3111" name="GUID-91517D50-1ACB-4191-9198-05D0F8EE3111"></a><h4 id="LNPCC-GUID-91517D50-1ACB-4191-9198-05D0F8EE3111" class="sect4"><span class="enumeration_section">8.4.4可</span>滚动光标提取</h4>
                  <div>
                     <p>您还可以将主机数组与可滚动游标一起使用。使用可滚动游标， <code class="codeph">sqlca.sqlerrd[2]</code>表示处理的最大（绝对）行数。由于应用程序可以在可滚动模式下任意定位提取，因此不必是处理的总行数。
                     </p>
                     <p>在可滚动模式下使用具有FETCH语句的主机数组时，不能从其先前的值中减去<code class="codeph">sqlca.sqlerrd[2]</code>的当前值，以查找最近一次迭代返回的行数。应用程序通过执行FETCH LAST确定结果集中的总行数。 <code class="codeph">sqlca.sqlerrd[2]</code>的值提供结果集中的总行数。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-F4032B0F-2816-4A08-8622-3C8E7725981D">示例程序：使用可滚动光标的主机阵列</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3448"></a><div class="props_rev_3"><a id="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069" name="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069"></a><h4 id="LNPCC-GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069" class="sect4"><span class="enumeration_section">8.4.5</span>示例程序3：主机阵列</h4>
                  <div>
                     <div class="section">
                        <p>本节中的演示程序显示了在Pro * C / C ++中编写查询时如何使用主机数组。特别注意在SQLCA（ <code class="codeph">sqlca.sqlerrd[2]</code> ）中使用“行处理计数”。该程序可在您的<code class="codeph">demo</code>目录中的<code class="codeph">sample3.pc</code>文件中<code class="codeph">sample3.pc</code>获得。
                        </p><pre class="oac_no_warn" dir="ltr">/ * * sample3.pc * Host Arrays * *此程序连接到ORACLE，声明并打开游标，*使用数组批量获取，并使用* print_rows（）函数打印结果。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sqlca.h&gt; #define NAME_LENGTH 20 #define ARRAY_LENGTH 5 / *另一种连接方式。* / char * username =“SCOTT”; char *密码=“TIGER”; / *声明主机结构标记。* / struct {int emp_number [ARRAY_LENGTH]; char emp_name [ARRAY_LENGTH] [NAME_LENGTH];浮动工资[ARRAY_LENGTH]; } emp_rec; / *声明该程序的功能。* / void print_rows（）; / *产生程序输出* / void sql_error（）; / *处理不可恢复的错误* / main（）{int num_ret; / *返回的行数* / / *连接到ORACLE。 * / EXEC SQL WHENEVER SQLERROR DO sql_error（“连接错误：”）; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; printf（“\ n以用户身份连接到ORACLE：％s \ n”，用户名）;执行SQL WHENEVER SQLERROR DO sql_error（“Oracle错误：”）; / *声明FETCH的游标。 * / EXEC SQL DECLARE c1 CURSOR FOR SELECT empno，ename，sal FROM emp; EXEC SQL OPEN c1; / *初始化行数。* / num_ret = 0; / *数组获取循环 - 当NOT FOUND变为true时结束。* / EXEC SQL WHENEVER NOT FOUND DO break; for（;;）{EXEC SQL FETCH c1 INTO：emp_rec; / *打印但返回了很多行。* / print_rows（sqlca.sqlerrd [2]  -  num_ret）; num_ret = sqlca.sqlerrd [2]; / *重置号码。* /} / *打印上次提取的剩余行（如果有）。* / if（（sqlca.sqlerrd [2]  -  num_ret）&gt; 0）print_rows（sqlca.sqlerrd [2]  -  num_ret）; EXEC SQL CLOSE c1; printf（“\ nAuu revoir。\ n \ n \ n”）; / *断开与数据库的连接。* / EXEC SQL COMMIT WORK RELEASE;出口（0）; } void print_rows（n）int n; {int i; printf（“\ nNumber Employee Salary”）; printf（“\ n ------ -------- ------ \ n”）; for（i = 0; i &lt;n; i ++）printf（“％ -  9d％-15.15s％9.2f \ n”，emp_rec.emp_number [i]，emp_rec.emp_name [i]，emp_rec.salary [i]） ; } void sql_error（msg）char * msg; {EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“\ n％s”，msg）; printf（“\ n％.70s \ n”，sqlca.sqlerrm.sqlerrmc）; EXEC SQL ROLLBACK工作版;出口（1）; }</pre><div class="infoboxnotealso" id="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069__GUID-E15D2ED0-8789-4F65-9545-9C8E5B00E9DC">
                           <p class="notep1">也可以看看：</p>
                           <p>有关SQLCA的更多信息，请<span class="q">“ <a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">处理运行时错误</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3449"></a><div class="props_rev_3"><a id="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D" name="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D"></a><h4 id="LNPCC-GUID-F4032B0F-2816-4A08-8622-3C8E7725981D" class="sect4"><span class="enumeration_section">8.4.6</span>示例程序：使用可滚动光标的主机阵列</h4>
                  <div>
                     <div class="section">
                        <p>该程序描述了如何使用具有可滚动游标的主机阵列。该程序可在您的演示目录中的<code class="codeph">scdemo2.pc</code>文件中<code class="codeph">scdemo2.pc</code>获得。
                        </p>
                        <div class="infoboxnote" id="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D__GUID-A676AAD6-7951-4AC5-A8FE-1EFCEBF1F3C4">
                           <p class="notep1">注意：</p>
                           <p>请注意，我们执行FETCH LAST来确定结果集中的行数。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3450"></a><div class="props_rev_3"><a id="GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA" name="GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA"></a><h5 id="LNPCC-GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA" class="sect5"><span class="enumeration_section">8.4.6.1</span> scdemo2.pc</h5>
                     <div><pre class="oac_no_warn" dir="ltr">/ * *一个示例程序，用于演示如何使用带有主机数组的可滚动*游标。* *此程序使用hr / hr架构。在执行此程序之前确保*该模式存在* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; #define ARRAY_LENGTH 4 / * user and passwd * / char * username =“hr”; char * password =“hr”; / *声明主机结构标记。* / struct emp_rec_array {int emp_number; char emp_name [20];浮动工资; } emp_rec [ARRAY_LENGTH]; / *打印查询结果* / void print_rows（）{int i; for（i = 0; i &lt;ARRAY_LENGTH; i ++）printf（“％d％s％8.2f \ n”，emp_rec [i] .emp_number，emp_rec [i] .emp_name，emp_rec [i] .salary）; / * Oracle错误处理程序* / void sql_error（char * msg）{EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“\ n％s”，msg）; printf（“\ n％.70s \ n”，sqlca.sqlerrm.sqlerrmc）; EXEC SQL ROLLBACK工作版;出口（EXIT_FAILURE）; } void main（）{int noOfRows; / *结果集中的行数* / / *错误处理程序* / EXEC SQL WHENEVER SQLERROR DO sql_error（“连接错误：”）; / *连接到数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password; / *错误句柄* / EXEC SQL WHENEVER SQLERROR DO sql_error（“Oracle error：”）; / *以可滚动模式声明游标* / EXEC SQL DECLARE c1 SCROLL CURSOR FOR SELECT employee_id，first_name，salary FROM employees; EXEC SQL OPEN c1;执行SQL WHENEVER SQLERROR DO sql_error（“获取错误：”）; / *这是一个虚拟提取，用于查找结果集中的行数* / EXEC SQL FETCH LAST c1 INTO：emp_rec; / *结果集中的行数由sqlca.sqlerrd [2] * / noOfRows = sqlca的值给出。 SQLERRD [2]; printf（“结果集中的总行数％d：\ n”，noOfRows）; / *获取第一个ARRAY_LENGTH行数* / EXEC SQL FETCH FIRST c1 INTO：emp_rec; printf（“******************** DEFAULT：\ n”）; print_rows（）; / *获取下一组ARRAY_LENGTH行* / EXEC SQL FETCH NEXT c1 INTO：emp_rec; printf（“******************** NEXT：\ n”）; print_rows（）; / *从第3行开始获取一组ARRAY_LENGTH行* / EXEC SQL FETCH ABSOLUTE 3 c1 INTO：emp_rec; printf（“******************** ABSOLUTE 3：\ n”）; print_rows（）; / *获取当前ARRAY_LENGTH行的行* / EXEC SQL FETCH CURRENT c1 INTO：emp_rec; printf（“******************** CURRENT：\ n”）; print_rows（）; / *从当前光标位置的第二个偏移量中获取一组ARRAY_LENGTH行* / EXEC SQL FETCH RELATIVE 2 c1 INTO：emp_rec; printf（“******************** RELATIVE 2：\ n”）; print_rows（）; / *再次获取第一个ARRAY_LENGTH行数* / EXEC SQL FETCH ABSOLUTE 0 c1 INTO：emp_rec; printf（“******************** ABSOLUTE 0：\ n”）; print_rows（）; / *关闭游标* / EXEC SQL CLOSE c1; / *断开与数据库的连接。* / EXEC SQL COMMIT WORK RELEASE;出口（EXIT_SUCCESS）; }</pre></div>
                  </div>
               </div><a id="LNPCC3452"></a><a id="LNPCC3451"></a><div class="props_rev_3"><a id="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763" name="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763"></a><h4 id="LNPCC-GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763" class="sect4"><span class="enumeration_section">8.4.7</span>主机阵列限制</h4>
                  <div>
                     <p>SELECT语句的WHERE子句中使用主机数组是<span class="italic">不允许</span>的，除非子查询。有关示例，请参阅<span class="q">“ <a href="host-arrays.html#GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3">关于使用WHERE子句</a> ”</span> 。
                     </p>
                     <p>此外，您不能在SELECT或FETCH语句的INTO子句中将简单主机变量与主机数组混合使用。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e662" class="indexterm-anchor"></a><a id="d40176e667" class="indexterm-anchor"></a> 
                     </p>
                     <p><a href="host-arrays.html#GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763__g14498" title="SELECT INTO的有效数组">表8-1</a>显示了主机数组在SELECT INTO语句中的哪些用途有效：</p>
                     <div class="tblformal" id="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763__g14498">
                        <p class="titleintable">表8-1 SELECT INTO的有效主机数组</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SELECT INTO的有效主机数组" width="100%" border="1" summary="Valid Arrays for SELECT INTO" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d40176e689">INTO条款</th>
                                 <th align="left" valign="bottom" width="30%" id="d40176e692">条款</th>
                                 <th align="left" valign="bottom" width="30%" id="d40176e695">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e700" headers="d40176e689 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e700 d40176e692 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e700 d40176e695 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e710" headers="d40176e689 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e710 d40176e692 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e710 d40176e695 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e720" headers="d40176e689 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e720 d40176e692 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e720 d40176e695 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e730" headers="d40176e689 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e730 d40176e692 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e730 d40176e695 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3453"></a><div class="props_rev_3"><a id="GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A" name="GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A"></a><h4 id="LNPCC-GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A" class="sect4"><span class="enumeration_section">8.4.8</span>关于获取NULL</h4>
                  <div>
                     <p>在执行数组SELECT和FETCH时，始终使用指示符数组。这样，您可以在关联的输出主机阵列中测试NULL。</p>
                     <p>当DBMS = V7或DBMS = v8时，如果SELECT或FETCH将NULL列值转换为与指标数组无关的主机数组，则Oracle停止处理，将<code class="codeph">sqlerrd[2]</code>为已处理的行数，并发出错误信息。
                     </p>
                     <p>此外，如果由于使用NULL而导致SELECT或FETCH导致任何警告（如<span class="italic">ORA-24347）</span> ，并且如果任何列没有指示符数组，则Oracle将停止处理。在SELECT或FETCH的所有列中使用指示符变量。如果所有列都没有指示符，则可以使用预编译器选项<code class="codeph">unsafe_null=yes</code>作为替代。
                     </p>
                  </div>
               </div><a id="LNPCC3454"></a><div class="props_rev_3"><a id="GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0" name="GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0"></a><h4 id="LNPCC-GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0" class="sect4"><span class="enumeration_section">8.4.9</span>关于获取截断值</h4>
                  <div>
                     <p>当DBMS = V7时，截断会产生警告消息，但Oracle会继续处理。</p>
                     <p>同样，在执行数组SELECT和FETCH时，始终使用指示符数组。这样，如果Oracle将一个或多个截断的列值分配给输出主机数组，您可以在关联的指标数组中找到列值的原始长度。</p>
                  </div>
               </div>
            </div><a id="LNPCC3455"></a><div class="props_rev_3"><a id="GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2" name="GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2"></a><h3 id="LNPCC-GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2" class="sect3"><span class="enumeration_section">8.5</span>关于使用数组插入</h3>
               <div>
                  <p>您可以在INSERT语句中将主机数组用作输入变量。只需确保程序在执行INSERT语句之前使用数据填充数组。</p>
                  <p>如果数组中的某些元素不相关，则可以使用FOR子句来控制插入的行数。 <a id="d40176e790" class="indexterm-anchor"></a><a id="d40176e794" class="indexterm-anchor"></a> 
                  </p>
                  <p>下面是使用主机数组插入的示例：</p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [20]; int emp_number [50];浮动工资[50]; / *填充主机数组* / ...EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：emp_name，：emp_number，：salary）;</pre><p>插入的累计行数可以在行处理的计数<code class="codeph">sqlca.sqlerrd[2]</code> 。
                  </p>
                  <p>在以下示例中，INSERT一次完成一行。这比前一个示例效率低得多，因为必须为插入的每一行调用服务器。</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;array_size; i ++）EXEC SQL INSERT INTO emp（ename，empno，sal）VALUES（：emp_name [i]，：emp_number [i]，：salary [i]）;</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-arrays.html#GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0">关于使用FOR子句</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3456"></a><div class="props_rev_3"><a id="GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871" name="GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871"></a><h4 id="LNPCC-GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871" class="sect4"><span class="enumeration_section">8.5.1</span>关于使用数组插入限制</h4>
                  <div>
                     <p>您不能在INSERT语句的VALUES子句中使用指针数组;所有数组元素都必须是数据项。 <a id="d40176e832" class="indexterm-anchor"></a><a id="d40176e836" class="indexterm-anchor"></a> 
                     </p>
                     <p>混合INSERT语句的VALUES子句中的主机阵列标主机变量是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3457"></a><div class="props_rev_3"><a id="GUID-755F6669-A311-454A-A561-93FA79BF6BDD" name="GUID-755F6669-A311-454A-A561-93FA79BF6BDD"></a><h3 id="LNPCC-GUID-755F6669-A311-454A-A561-93FA79BF6BDD" class="sect3"><span class="enumeration_section">8.6</span>关于使用数组更新</h3>
               <div>
                  <p>您还可以在UPDATE语句中将主机数组用作输入变量，如以下示例所示： <a id="d40176e858" class="indexterm-anchor"></a><a id="d40176e862" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">int emp_number [50];浮动工资[50]; / *填充主机数组* / EXEC SQL UPDATE emp SET sal =：salary WHERE EMPNO =：emp_number;</pre><p>更新的累积行数可以在<code class="codeph">sqlerrd[2]</code> 。这个数字<span class="italic">不</span>包括通过级联更新处理的行。
                  </p>
                  <p>如果数组中的某些元素不相关，则可以使用嵌入式SQL FOR子句来限制更新的行数。</p>
                  <p>最后一个示例显示了使用唯一键（EMP_NUMBER）的典型更新。每个数组元素只限一行进行更新。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">char job_title [10] [20];浮动佣金[10]; ...EXEC SQL UPDATE emp SET comm =：Commission WHERE job =：job_title;</pre></div><a id="LNPCC3459"></a><a id="LNPCC3458"></a><div class="props_rev_3"><a id="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30" name="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30"></a><h4 id="LNPCC-GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30" class="sect4"><span class="enumeration_section">8.6.1</span>关于使用数组限制进行更新</h4>
                  <div>
                     <p>建议<span class="italic">不要</span>在UPDATE语句的SET或WHERE子句中将简单主机变量与主机数组混合。如果任何主机变量是一个数组，则所有主变量都应该是数组。 <a id="d40176e898" class="indexterm-anchor"></a><a id="d40176e902" class="indexterm-anchor"></a> 此外，如果在SET子句中使用主机数组，请在WHERE子句中使用相同数量的元素之一。
                     </p>
                     <p>您不能在UPDATE语句中将主机数组与CURRENT OF子句一起使用。</p>
                     <p><a href="host-arrays.html#GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30__G14454" title="主机阵列在UPDATE中有效">表8-2</a>显示了主机数组在UPDATE语句中的有效使用情况：</p>
                     <div class="tblformal" id="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30__G14454">
                        <p class="titleintable">表8-2主机阵列在UPDATE中有效</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机阵列在UPDATE中有效" width="100%" border="1" summary="Host Arrays Valid in an UPDATE" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d40176e926">SET子句</th>
                                 <th align="left" valign="bottom" width="40%" id="d40176e929">条款</th>
                                 <th align="left" valign="bottom" width="31%" id="d40176e932">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e937" headers="d40176e926 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e937 d40176e929 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e937 d40176e932 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e947" headers="d40176e926 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e947 d40176e929 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e947 d40176e932 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e957" headers="d40176e926 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e957 d40176e929 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e957 d40176e932 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e967" headers="d40176e926 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e967 d40176e929 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e967 d40176e932 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿当前的</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3460"></a><div class="props_rev_3"><a id="GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD" name="GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD"></a><h3 id="LNPCC-GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD" class="sect3"><span class="enumeration_section">8.7</span>关于使用数组删除</h3>
               <div>
                  <p>您还可以在DELETE语句中将主机数组用作输入变量。这就像在WHERE子句中使用主机数组的连续元素重复执行DELETE语句一样。因此，每次执行都可能从表中删除零个，一个或多个行。 <a id="d40176e992" class="indexterm-anchor"></a><a id="d40176e996" class="indexterm-anchor"></a> 
                  </p>
                  <p>下面是使用主机数组删除的示例：</p><pre class="oac_no_warn" dir="ltr">...int emp_number [50]; / *填充主机数组* / ...EXEC SQL DELETE FROM emp WHERE empno =：emp_number;</pre><p>删除的累计行数可以在<code class="codeph">sqlerrd[2]</code> 。数字<span class="italic">不</span>包括被删除级联处理的行。
                  </p>
                  <p>最后一个示例显示了使用唯一键（EMP_NUMBER）的典型删除。每个数组元素只限一行进行删除。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">...char job_title [10] [20]; / *填充主机数组* / ...EXEC SQL DELETE FROM emp WHERE job =：job_title; ...</pre></div><a id="LNPCC3461"></a><div class="props_rev_3"><a id="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D" name="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D"></a><h4 id="LNPCC-GUID-98A91B07-113F-4CB5-8788-741AD1216C9D" class="sect4"><span class="enumeration_section">8.7.1</span>关于使用数组限制进行删除</h4>
                  <div>
                     <p>混合DELETE语句的WHERE子句中的主机阵列简单的主机变量是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e1031" class="indexterm-anchor"></a><a id="d40176e1035" class="indexterm-anchor"></a> 
                     </p>
                     <p>您不能在DELETE语句中将主机数组与CURRENT OF子句一起使用。</p>
                     <div class="infoboxnotealso" id="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D__GUID-3D2555DA-0D5D-4350-A8AD-AD33E70815A5">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿CURRENT OF</a> ”</span>替代方案。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3462"></a><div class="props_rev_3"><a id="GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0" name="GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0"></a><h3 id="LNPCC-GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0" class="sect3"><span class="enumeration_section">8.8</span>关于使用FOR子句</h3>
               <div>
                  <p>您可以使用可选的嵌入式SQL FOR子句来设置由以下任何SQL语句处理的数组元素的数量：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>删除</p>
                     </li>
                     <li>
                        <p>执行</p>
                     </li>
                     <li>
                        <p>取</p>
                     </li>
                     <li>
                        <p>插入</p>
                     </li>
                     <li>
                        <p>打开</p>
                     </li>
                     <li>
                        <p>UPDATE</p>
                     </li>
                  </ul>
                  <p>FOR子句在UPDATE，INSERT和DELETE语句中特别有用。使用这些语句，您可能不想使用整个数组。FOR子句允许您将所使用的元素限制为所需的数字，如以下示例所示： <a id="d40176e1081" class="indexterm-anchor"></a><a id="d40176e1085" class="indexterm-anchor"></a><a id="d40176e1089" class="indexterm-anchor"></a><a id="d40176e1093" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [100] [20];浮动工资[100]; int rows_to_insert; / *填充主机数组* / rows_to_insert = 25; / *设置FOR子句变量* / EXEC SQL FOR：rows_to_insert / *只处理25行* / INSERT INTO \ temp（ename，sal）VALUES（：emp_name，：salary）;</pre><p>FOR子句可以使用整数主机变量来计算数组元素或整数文字。<span class="italic">不能</span>使用解析为整数的复杂C表达式。例如，以下使用整数表达式的语句是非法的： <a id="d40176e1105" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：rows_to_insert + 5 / * illegal * / INSERT INTO emp（ename，empno，sal）VALUES（：emp_name，：emp_number，：salary）;</pre><p>FOR子句变量指定要处理的数组元素的数量。确保数字不超过最小的数组维度。在内部，该值被视为无符号数量。尝试通过使用已签名的主机变量传递负值将导致不可预测的行为。 <a id="d40176e1114" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCC3463"></a><div class="props_rev_3"><a id="GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E" name="GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E"></a><h4 id="LNPCC-GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E" class="sect4"><span class="enumeration_section">8.8.1</span> FOR条款限制</h4>
                  <div>
                     <p>两个限制使FOR子句语义清晰：您不能在SELECT语句中使用FOR子句或使用CURRENT OF子句。 <a id="d40176e1130" class="indexterm-anchor"></a><a id="d40176e1134" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC3464"></a><div class="props_rev_3"><a id="GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD" name="GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD"></a><h5 id="LNPCC-GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD" class="sect5"><span class="enumeration_section">8.8.1.1</span>在SELECT语句中</h5>
                     <div>
                        <p>如果在SELECT语句中使用FOR子句，则会收到错误消息。</p>
                        <p>SELECT语句中不允许使用FOR子句，因为它的含义不清楚。这是否意味着“执行此SELECT语句<span class="italic">n</span>次”？或者，它是否意味着“执行此SELECT语句一次，但返回<span class="italic">n</span>行”？前一种情况的问题是每次执行都可能返回多行。在后一种情况下，最好声明一个游标并在FETCH语句中使用FOR子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：限制FETCH emp_cursor INTO ...</pre></div>
                  </div><a id="LNPCC3465"></a><div class="props_rev_3"><a id="GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864" name="GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864"></a><h5 id="LNPCC-GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864" class="sect5"><span class="enumeration_section">8.8.1.2</span>使用CURRENT OF子句</h5>
                     <div>
                        <p>您可以使用UPDATE或DELETE语句中的CURRENT OF子句来引用FETCH语句返回的最新行，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal FROM emp WHERE empno =：emp_number; ...EXEC SQL OPEN emp_cursor; ...EXEC SQL FETCH emp_cursor INTO：emp_name，：salary; ...EXEC SQL UPDATE emp SET sal =：new_salary WHERE CURRENT OF emp_cursor;</pre><p>但是，您不能将FOR子句与CURRENT OF子句一起使用。以下语句无效，因为<span class="italic">limit</span>的唯一逻辑值为1（您只能更新或删除当前行一次）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：limit UPDATE emp SET sal =：new_salary WHERE CURRENT OF emp_cursor; ...EXEC SQL FOR：限制DELETE FROM emp WHERE CURRENT OF_ emprsor;</pre></div>
                  </div>
               </div>
            </div><a id="LNPCC3466"></a><div class="props_rev_3"><a id="GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3" name="GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3"></a><h3 id="LNPCC-GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3" class="sect3"><span class="enumeration_section">8.9</span>关于使用WHERE子句</h3>
               <div>
                  <p>甲骨文对待包含元素的数量<span class="italic">n</span>的等执行相同的SQL语句主机阵列SQL语句<span class="italic">n，</span>其中<span class="italic">n个</span>不同的标量变量（各个数组元素）次。只有当这种处理方式不明确时，预编译器才会发出错误消息。 <a id="d40176e1201" class="indexterm-anchor"></a><a id="d40176e1205" class="indexterm-anchor"></a> 
                  </p>
                  <p>例如，假设声明</p><pre class="oac_no_warn" dir="ltr">int mgr_number [50]; char job_title [50] [20];</pre><p>如果声明，这将是模棱两可的</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT mgr INTO：mgr_number FROM emp WHERE job =：job_title;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i ++）SELECT mgr INTO：mgr_number [i] FROM emp WHERE job =：job_title [i];</pre><p>因为多行可能符合WHERE子句搜索条件，但只有一个输出变量可用于接收数据。因此，会发出错误消息。</p>
                  <p>另一方面，如果声明如此，则不会含糊不清</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE emp SET mgr =：mgr_number WHERE empno IN（SELECT empno FROM emp WHERE job =：job_title）;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i ++）UPDATE emp SET mgr =：mgr_number [i] WHERE empno IN（SELECT empno FROM emp WHERE job =：job_title [i]）;</pre><p>因为每一行匹配<span class="italic">JOB_TITLE</span>的SET子句中<span class="italic">mgr_number</span> WHERE子句中，即使每个<span class="italic">JOB_TITLE</span>多行匹配。匹配每个<span class="italic">job_title的</span>所有行可以设置为相同的<span class="italic">mgr_number</span> 。因此，不会发出错误消息。
                  </p>
               </div>
            </div><a id="LNPCC3467"></a><div class="props_rev_3"><a id="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4" name="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4"></a><h3 id="LNPCC-GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4" class="sect3"><span class="enumeration_section">8.10</span>结构数组</h3>
               <div>
                  <p>使用标量数组，您可以执行仅涉及单个列的多行操作。使用标量的结构允许用户执行涉及多个列的单行操作。</p>
                  <p>但是，为了执行涉及多列的多行操作，您以前需要单独分配几个并行的标量数组，或者在单个结构中封装。在许多情况下，更容易重新组织此数据结构作为单个结构数组。</p>
                  <p>Pro * C / C ++支持使用<span class="italic">结构数组，</span>这使得应用程序编程人员可以使用C结构数组执行多行，多列操作。通过此增强功能，Pro * C / C ++可以将简单的标量结构数组作为嵌入式SQL语句中的绑定变量处理，以便于处理用户数据。这使编程更加直观，并使用户可以更灵活地组织数据。
                  </p>
                  <p>除了支持结构数组作为绑定变量之外，Pro * C / C ++还支持与结构声明数组结合使用时的指示符结构数组。</p>
                  <div class="infoboxnote" id="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4__GUID-CC043255-DB83-4863-B7A7-E649FE177B4D">
                     <p class="notep1">注意：</p>
                     <p>将结构绑定到PL / SQL记录并将结构数组绑定到记录的PL / SQL表<span class="italic">不是</span>此新功能的一部分。结构数组也可能不在嵌入式PL / SQL块中使用。
                     </p>
                  </div>
                  <p>由于在执行涉及多列的多行操作时打算使用结构数组，因此通常预期它们将以下列方式使用。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>作为SELECT语句或FETCH语句中的输出绑定变量。</p>
                     </li>
                     <li>
                        <p>作为INSERT语句的VALUES子句中的输入绑定变量。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-arrays.html#GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3">对结构数组的限制</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3468"></a><div class="props_rev_3"><a id="GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C" name="GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C"></a><h4 id="LNPCC-GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C" class="sect4"><span class="enumeration_section">8.10.1</span>结构用法数组</h4>
                  <div>
                     <p>结构数组的概念对C程序员来说并不陌生。但是，当它与并行数组的结构进行比较时，它确实为数据存储提供了概念上的差异。</p>
                     <p>在并行数组的结构中，各列的数据是连续存储的。另一方面，在结构数组中，列数据是<span class="italic"><span class="bold">交错的</span></span> ，因此数组中每列出现的列由结构中其他列所需的空格分隔。这个空间被称为<span class="italic"><span class="bold">步伐</span></span> 。
                     </p>
                  </div>
               </div><a id="LNPCC3469"></a><div class="props_rev_3"><a id="GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3" name="GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3"></a><h4 id="LNPCC-GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3" class="sect4"><span class="enumeration_section">8.10.2</span>对结构阵列的限制</h4>
                  <div>
                     <p>以下限制适用于在Pro * C / C ++中使用结构数组：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>嵌入式PL / SQL块中不允许使用结构数组（与普通结构一样）。</p>
                        </li>
                        <li>
                           <p>禁止在WHERE或FROM子句中使用结构数组。</p>
                        </li>
                        <li>
                           <p>Oracle Dynamic SQL方法4不允许使用结构数组。ANSI动态SQL允许使用它们。</p>
                        </li>
                        <li>
                           <p>UPDATE语句的SET子句中不允许使用结构数组。</p>
                        </li>
                     </ul>
                     <p>声明结构数组的语法不会更改。但是，在使用结构数组时，需要记住一些事项。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3470"></a><div class="props_rev_3"><a id="GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A" name="GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A"></a><h4 id="LNPCC-GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A" class="sect4"><span class="enumeration_section">8.10.3</span>关于声明结构数组</h4>
                  <div>
                     <p>在声明将在Pro * C / C ++应用程序中使用的结构数组时，程序员必须牢记以下要点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>结构必须具有结构标记。例如，在以下代码段中</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">struct person {char name [15];年龄;人[10];</pre><p><code class="codeph">person</code>变量是结构标记。这样预编译器就可以使用结构的名称来计算步幅的大小。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>结构的成员不能是数组。此规则的唯一例外是字符类型，例如<span class="bold">char</span>或<span class="bold">VARCHAR，</span>因为在声明这些类型的变量时使用了数组语法。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">char</span>和<span class="bold">VARCHAR</span>成员可能不是二维的。
                           </p>
                        </li>
                        <li>
                           <p>嵌套结构不允许作为结构数组的成员。这不是新的限制，因为先前版本的Pro * C / C ++不支持嵌套结构。</p>
                        </li>
                        <li>
                           <p>结构的大小不得超过有符号4字节数量可能代表的最大值。这通常是2千兆字节。</p>
                        </li>
                     </ul>
                     <p>鉴于使用结构数组的这些限制，以下声明在Pro * C / C ++中是合法的</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } dept [4];</pre><p>而以下声明是非法的。</p><pre class="oac_no_warn" dir="ltr">struct {/ * struct缺少结构标记* / int empno [15]; / * struct members可能不是数组* / char ename [15] [10]; / *字符类型可能不是2维* / struct嵌套{int salary; / *结构数组中不允许使用嵌套结构* /} sal_struct;不好[15];</pre><p>同样重要的是要注意，您不能将数据类型等同应用于结构本身数组或结构中的任何单个字段。例如，假设<code class="codeph">empno</code>未在先前的非法结构中声明为数组，则以下内容是非法的：</p><pre class="oac_no_warn" dir="ltr">exec sql var bad [3] .empno是整数（4）;</pre><p>预编译器无法跟踪结构数组中的各个结构元素。另一方面，可以做以下事情以实现期望的效果。</p><pre class="oac_no_warn" dir="ltr">typedef int myint; exec sql类型myint是整数（4）; struct equiv {myint empno; / *现在合法地认为是整数（4）数据类型* / ...好的[15];</pre><p>这应该不足为奇，因为先前版本的Pro * C / C ++不支持等效单个数组项。例如，以下标量数组声明说明了什么是合法的，什么不合法。</p><pre class="oac_no_warn" dir="ltr">int empno [15]; exec sql var empno [3]是整数（4）; / *违法* / myint empno [15]; / * legal * /</pre><p>总之，您可能无法等同于任何单个数组项。</p>
                  </div>
               </div><a id="LNPCC3471"></a><div class="props_rev_3"><a id="GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5" name="GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5"></a><h4 id="LNPCC-GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5" class="sect4"><span class="enumeration_section">8.10.4</span>变量指南</h4>
                  <div>
                     <p>结构体声明数组的指示符变量与普通结构声明的工作方式大致相同。结构声明的指示符数组必须遵守结构数组的规则，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>指示符结构中的字段数必须小于或等于相应结构数组中的字段数。</p>
                        </li>
                        <li>
                           <p>字段的顺序必须与结构数组的相应成员的顺序匹配。</p>
                        </li>
                        <li>
                           <p>指标结构中所有元素的数据类型必须很<span class="bold">短</span> 。
                           </p>
                        </li>
                        <li>
                           <p>指标数组的大小必须至少与主机变量声明的大小相同。它可能更大，但可能不会更小。</p>
                        </li>
                     </ul>
                     <p>这些规则通常反映了在先前版本的Pro * C / C ++中实现的使用结构的规则。数组限制也与先前用于标量数组的限制相同。</p>
                     <p>根据这些规则，假设以下结构声明：</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } dept [4];</pre><p>以下是法律指标变量结构声明：</p><pre class="oac_no_warn" dir="ltr">struct department_ind {short deptno_ind;短dname_ind; short loc_ind; } dept_ind [4];</pre><p>而以下是非法的指标变量</p><pre class="oac_no_warn" dir="ltr">struct {/ *缺少指标结构标记* / int deptno_ind; / *指示符变量不是short * / short dname_ind [15]; / *数组元素禁止在指示符struct * / short loc_ind [14]; / *数组元素禁用指标struct * /} bad_ind [2]; / *指标数组大小小于主机数组* /</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3472"></a><div class="props_rev_3"><a id="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815" name="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815"></a><h4 id="LNPCC-GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815" class="sect4"><span class="enumeration_section">8.10.5</span>关于声明指向一组结构的指针</h4>
                  <div>
                     <p>在某些情况下，可能需要声明指向结构数组的指针。这允许将结构数组的指针传递给其他函数或直接在嵌入式SQL语句中使用。</p>
                     <div class="infoboxnote" id="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815__GUID-BC2A29C3-615F-4650-8B6B-78CAF7706140">
                        <p class="notep1">注意：</p>
                        <p>在预编译期间，无法知道由指向结构数组的指针引用的数组的长度。因此，当在任何嵌入式SQL语句中使用其类型是指向结构数组的指针的绑定变量时，必须使用显式FOR子句。</p>
                     </div>
                     <p>请记住，FOR子句可能不会在嵌入式SQL SELECT语句中使用。因此，要将数据检索到指向结构数组的指针，必须在FOR子句中使用显式游标和FETCH语句。</p>
                  </div>
               </div><a id="LNPCC3473"></a><div class="props_rev_3"><a id="GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1" name="GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1"></a><h4 id="LNPCC-GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1" class="sect4"><span class="enumeration_section">8.10.6</span>示例</h4>
                  <div>
                     <p>以下示例演示了Pro * C / C ++中结构体数组的不同用法。</p>
                  </div><a id="LNPCC3474"></a><div class="props_rev_3"><a id="GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF" name="GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF"></a><h5 id="LNPCC-GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF" class="sect5"><span class="enumeration_section">8.10.6.1</span>示例1：Scalars结构的简单数组</h5>
                     <div>
                        <div class="section">
                           <p>鉴于以下结构声明，</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } my_dept [4];</pre><p>然后，用户可以将<code class="codeph">dept</code>数据选择到<code class="codeph">my_dept</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：my_dept from dept;</pre><p>或者用户可以首先填充<code class="codeph">my_dept</code> ，然后将其批量插入到<code class="codeph">dept</code>表中：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into dept values（：my_dept）;</pre><p>要使用指示符变量，可以声明结构的并行指示符数组。</p><pre class="oac_no_warn" dir="ltr">struct deptartment_ind {short deptno_ind;短dname_ind; short loc_ind; } my_dept_ind [4];</pre><p>然后使用相同的查询选择数据，但添加指示符变量除外：</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：my_dept indicator：my_dept_ind from dept;</pre><p>同样，插入数据时也可以使用指标：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into dept values（：my_dept indicator：my_dept_ind）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3475"></a><div class="props_rev_3"><a id="GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9" name="GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9"></a><h5 id="LNPCC-GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9" class="sect5"><span class="enumeration_section">8.10.6.2</span>示例2：使用具有结构数组的混合标量数组</h5>
                     <div>
                        <div class="section">
                           <p>与Pro * C / C ++的早期版本一样，当使用多个数组批量处理用户数据时，数组的大小必须相同。如果不是，则选择最小的阵列大小，使阵列的其余部分不受影响。</p>
                           <p>鉴于以下声明，</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [11]; } emp [14]; float sal [14]; float comm [14];</pre><p>可以在一个简单查询中为所有列选择多行：</p><pre class="oac_no_warn" dir="ltr">exec sql select empno，ename，sal，comm into：emp，：sal，：comm from emp;</pre><p>我们还想知道佣金的列值是否为NULL。在给出以下声明的情况下，可以使用单个指标数组：</p><pre class="oac_no_warn" dir="ltr">简短的comm_ind [14]; ...exec sql select empno，ename，sal，comm into：emp，：sal，：comm indicator：comm_ind from emp;</pre><p>您不能声明封装查询中所有指示符信息的结构的单个指示符数组。因此：</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {/ *非法使用的例子* / short empno_ind;简短的ename_ind;短sal_ind;简短的comm_ind; } illegal_ind [15]; exec sql select empno，ename，sal，comm into：emp，：sal，：comm indicator：illegal_ind from emp;</pre><p>是非法的（也是不受欢迎的）。早期的语句仅将指标数组与<code class="codeph">comm</code>列相关联，而不是整个SELECT ...INTO列表。
                           </p>
                           <p>假设结构数组和<code class="codeph">sal</code> ， <code class="codeph">comm</code>和<code class="codeph">comm_ind</code>数组填充了所需的数据，插入很简单：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into emp（empno，ename，sal，comm）values（：emp，：sal，：comm indicator：comm_ind）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3476"></a><div class="props_rev_3"><a id="GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99" name="GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99"></a><h5 id="LNPCC-GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99" class="sect5"><span class="enumeration_section">8.10.6.3</span>示例3：使用带有光标的多个结构数组</h5>
                     <div>
                        <p>对于此示例，我们进行以下声明：</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [11]; char job [10]; } emp [14];结构补偿{int sal; int comm;工资[14]; struct compensation_ind {short sal_ind;简短的comm_ind; } wage_ind [14];</pre><p>然后我们的程序可以使用这些结构数组，如下所示：</p><pre class="oac_no_warn" dir="ltr">exec sql声明c光标用于选择empno，ename，job，sal，comm来自emp; exec sql open c; exec sql什么都没找到做破坏; while（1）{exec sql fetch c into：emp，：wage indicator：wage_ind; ...处理获取返回的批处理行...} printf（“％d rows selected。\ n”，sqlca.sqlerrd [2]）; exec sql close c;</pre></div><a id="LNPCC3477"></a><div class="props_rev_3"><a id="GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1" name="GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1"></a><h6 id="LNPCC-GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1" class="sect6"><span class="enumeration_section">8.10.6.3.1</span>关于使用FOR子句</h6>
                        <div>
                           <p>或者，我们可以使用FOR子句来指示获取要检索的行数。回想一下，在使用SELECT语句时禁止使用FOR子句，而不是INSERT或FETCH语句。</p>
                           <p>我们在原始声明中添加以下内容</p><pre class="oac_no_warn" dir="ltr">int limit = 10;</pre><p>并相应地编码我们的例子。</p><pre class="oac_no_warn" dir="ltr">exec sql for：limit fetch c into：emp，：wage indicator：wage_ind;</pre></div>
                     </div>
                  </div><a id="LNPCC3478"></a><div class="props_rev_3"><a id="GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152" name="GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152"></a><h5 id="LNPCC-GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152" class="sect5"><span class="enumeration_section">8.10.6.4</span>示例4：单个阵列和结构成员引用</h5>
                     <div>
                        <p>Pro * C / C ++的早期版本允许对结构数组中的单个结构进行数组引用。因此，以下内容是合法的，因为绑定表达式解析为一个简单的标量结构。</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：dept [3] from emp;</pre><p>用户可以在结构数组中引用特定结构的单个标量成员，如以下示例所示。</p><pre class="oac_no_warn" dir="ltr">exec sql选择dname into：dept [3] .dname from dept where ...;</pre><p>当然，这要求查询是单行查询，因此只有一行被选择到此绑定表达式表示的变量中。</p>
                     </div>
                  </div><a id="LNPCC3479"></a><div class="props_rev_3"><a id="GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E" name="GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E"></a><h5 id="LNPCC-GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E" class="sect5"><span class="enumeration_section">8.10.6.5</span>示例5：使用指标变量，特殊情况</h5>
                     <div>
                        <p>Pro * C / C ++的早期版本要求指标结构与其关联的绑定结构具有相同数量的字段。一般使用结构时，这种限制已经放宽。通过遵循前面提到的结构指示器数组的指导原则，可以构造以下示例。</p><pre class="oac_no_warn" dir="ltr">struct employee {float comm;漂浮int empno; char ename [10]; } emp [14]; struct employee_ind {short comm; } emp_ind [14]; exec sql select comm，sal，empno，ename into：emp indicator：emp_ind from emp;</pre><p>指标变量到绑定值的映射是一对一的。它们以第一个字段开始的关联顺序映射。</p>
                        <p>但请注意，如果任何其他字段的读取值为NULL且未提供指示符，则会引发以下错误：</p><pre class="oac_no_warn" dir="ltr">ORA-1405：获取的列值为NULL</pre><p>例如，如果<code class="codeph">sal</code>为空，那就是这种情况，因为没有<code class="codeph">sal</code>指示。
                        </p>
                        <p>假设我们更改结构数组如下，</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [10];漂浮浮动通讯; } [15];</pre><p>但仍然使用相同的结构指标数组。</p>
                        <p>因为指示符以关联顺序顺序映射，所以<code class="codeph">comm</code>指示符映射到<code class="codeph">empno</code>字段，而没有指示符的<code class="codeph">comm</code>绑定变量再次导致ORA-1405错误。
                        </p>
                        <p>为了避免ORA-1405在使用字段少于其关联绑定变量结构的指示符结构时，可以为空的属性首先出现并按顺序出现。</p>
                        <p>我们可以通过使用非数组结构轻松地将其更改为涉及多个列的单行提取，并期望它的工作方式就像指示器结构声明如下。</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {short comm;短sal;简短的;短暂的; } emp_ind;</pre><p>因为Pro * C / C ++不再要求指标结构与其关联的值结构具有相同数量的字段，所以前面的示例现在在Pro * C / C ++中是合法的，而之前它不是。</p>
                        <p>我们的指标结构现在看起来像下面的简单结构。</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {short comm; } emp_ind;</pre><p>使用非数组<code class="codeph">emp</code>和<code class="codeph">emp_ind</code>结构，我们能够执行如下的单行提取。
                        </p><pre class="oac_no_warn" dir="ltr">exec sql fetch comm，sal，empno，ename into：emp indicator：emp_ind from emp;</pre><p>再次注意在这种情况下<code class="codeph">comm</code>指示符如何映射到<code class="codeph">comm</code>绑定变量。
                        </p>
                     </div>
                  </div><a id="LNPCC3480"></a><div class="props_rev_3"><a id="GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5" name="GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5"></a><h5 id="LNPCC-GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5" class="sect5"><span class="enumeration_section">8.10.6.6</span>示例6：使用指向结构数组的指针</h5>
                     <div>
                        <p>此示例演示如何使用指向结构数组的指针。</p>
                        <p>给出以下类型声明：</p><pre class="oac_no_warn" dir="ltr">typedef struct dept {int deptno; char dname [15]; char loc [14]; } dept;</pre><p>我们可以执行各种操作，操作指向该类型结构数组的指针。例如，我们可以将指向结构数组的指针传递给其他函数。</p><pre class="oac_no_warn" dir="ltr">void insert_data（d，n）dept * d; int n; {exec sql for：n insert into dept values（：d）; } void fetch_data（d，n）dept * d; int n; {exec sql声明c光标用于选择deptno，dname，loc来自dept; exec sql open c; exec sql for：n fetch c into：d; exec sql close c; }</pre><p>通过传递结构数组的地址来调用这些函数，如这些示例所示。</p><pre class="oac_no_warn" dir="ltr">部门[4]; dept * dptr =＆d [0]; const int n = 4; fetch_data（dptr，n）; insert_data（d，n）; / *我们将'＆d [0]'视为等于'd'* /</pre><p>或者我们可以直接在某些嵌入式SQL语句中使用这些指针到结构数组。</p><pre class="oac_no_warn" dir="ltr">exec sql for：n insert into dept values（：dptr）;</pre><p>要记住的最重要的事情是使用FOR子句。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3481"></a><div class="props_rev_3"><a id="GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E" name="GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E"></a><h3 id="LNPCC-GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E" class="sect3"><span class="enumeration_section">8.11</span>关于模仿CURRENT OF</h3>
               <div>
                  <p>您可以在DELETE或UPDATE语句中使用CURRENT OF <span class="italic">游标</span>子句来引用游标中的最新行FETCHed。但是，您不能将CURRENT OF与主机阵列一起使用。而是选择每行的ROWID，然后使用该值在更新或删除期间标识当前行。
                  </p>
                  <p>例如： <a id="d40176e1780" class="indexterm-anchor"></a><a id="d40176e1786" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [20] [10]; char job_title [20] [10]; char old_title [20] [10]; char row_id [20] [19]; ...EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，job，rowid FROM emp FOR UPDATE; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND会破坏; for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name，：job_title，：row_id; ...EXEC SQL DELETE FROM emp WHERE job =：old_title AND rowid =：row_id; EXEC SQL COMMIT WORK; }</pre><p></p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-SQL.html#GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6">条款的当前条款</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3484"></a><a id="LNPCC3485"></a><a id="LNPCC3486"></a><a id="LNPCC3482"></a><div class="props_rev_3"><a id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408" name="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408"></a><h3 id="LNPCC-GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408" class="sect3"><span class="enumeration_section">8.12</span>关于使用附加阵列插入/选择语法</h3>
               <div>
                  <p>Oracle预编译器还支持主机表的DB2插入和获取语法。支持的附加阵列插入和获取语法分别在下图中示出。</p>
                  <div class="figure" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-0C4CB3AC-E244-4C9C-9433-9DE1F5DE5BB5">
                     <p class="titleinfigure">图8-1其他插入语法</p><img src="img/insert2.png" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/insert2.html"><br><a href="img_text/insert2.html">“图8-1附加插入语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-2085F504-60BB-4ED4-A488-C94E3329CBE9">
                     <p class="titleinfigure">图8-2其他提取语法</p><img src="img/fetch2.png" alt="下面是图8-2的描述" title="下面是图8-2的描述" longdesc="img_text/fetch2.html"><br><a href="img_text/fetch2.html">“图8-2附加提取语法”的说明</a></div>
                  <!-- class="figure" -->
                  <p>可选的ROWSET和ROWSET STARTING AT子句用于获取方向（FIRST，PRIOR，NEXT，LAST，CURRENT，RELATIVE和ABSOLUTE）。请考虑以下示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>第一行</p>
                     </li>
                     <li>
                        <p>先前的行</p>
                     </li>
                     <li>
                        <p>下一行</p>
                     </li>
                     <li>
                        <p>最后一行</p>
                     </li>
                     <li>
                        <p>当前行</p>
                     </li>
                     <li>
                        <p>ROWSET在RELATIVEn开始</p>
                     </li>
                     <li>
                        <p>在ABSOLUTEn开始的ROWSET</p>
                     </li>
                  </ul>
                  <p><a href="host-arrays.html#GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__BABHDBHI" title="DB2与Oracle预编译器语法">表8-3</a>中显示了DB2数组插入/获取语法的示例以及它们与相应的Oracle预编译器语法的比较：</p>
                  <div class="tblformal" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__BABHDBHI">
                     <p class="titleintable">表8-3 DB2阵列语法与Oracle预编译器语法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DB2阵列语法与Oracle预编译器语法" width="100%" border="1" summary="DB2 vs. Oracle Precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="47%" id="d40176e1869">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="53%" id="d40176e1872">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d40176e1877" headers="d40176e1869 "><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO dsn8810.act（actno，actkwd，actdesc）VALUES（：hva1，：hva2，：hva3）FOR：NUM_ROWS ROWS;</pre></td>
                              <td align="left" valign="top" width="53%" headers="d40176e1877 d40176e1872 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：num_rows INSERT INTO dsn8810.act（actno，actkwd，actdesc）VALUES（：hva1，：hva2，：hva3）;</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d40176e1884" headers="d40176e1869 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH NEXT ROWSET from c1 FOR 20 ROWS INTO：hva_empno，：hva_lastname，：hva_salary;</pre></td>
                              <td align="left" valign="top" width="53%" headers="d40176e1884 d40176e1872 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：二十二个FETCH c1 INTO：hva_empno，：hva_lastname，：hva_salary;</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>在DB2语法中，应在检索行数据集之前首先声明行集定位游标。要使游标能够获取行集，必须在DECLARE CURSOR语句中使用'WITH ROWSET POSITIONING'子句，这在Oracle预编译器语法中不是必需且相关的，如下表所示。</p>
                  <div class="tblformal" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-92D03384-5B5C-452F-A456-18FECA776FEC">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table for difference between DB2 and Oracle precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d40176e1900">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="57%" id="d40176e1903">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d40176e1908" headers="d40176e1900 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE c1 CURSOR，带有ROWSET POSITIONING FOR SELECT empno，lastname，salary FROM dsn8810.emp;</pre></td>
                              <td align="left" valign="top" width="57%" headers="d40176e1908 d40176e1903 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE c1 CURSOR FOR SELECT empno，lastname，salary FROM dsn8810.emp;</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>可以使用预编译器选项<code class="codeph">db2_array</code>启用此DB2数组语法支持，该选项的默认选项为<code class="codeph">no</code> 。DB2数组语法支持不能与Oracle预编译器语法一起使用;只支持一种语法，一次只支持语法，Oracle预编译器或DB2语法。
                  </p>
                  <div class="example" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-CCF37220-D9B8-406F-A60C-999622BEEABF">
                     <p class="titleinexample">示例8-1使用DB2数组语法插入和获取行</p>
                     <p>此程序使用DB2数组插入语法将INSCNT行插入EMP表，然后使用DB2数组提取语法提取插入的行。</p><pre class="oac_no_warn" dir="ltr">/ * * db2arrdemo.pc * / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlcpr.h&gt; #include &lt;sqlca.h&gt; / *一次性插入的行数* / #define INSCNT 100 / *一次性获取的行数* / #define FETCHCNT 20 / *定义用于将数据插入表中以及用于获取数据的主机结构来自表* / struct emprec {int empno; varchar ename [10]; varchar job [9]; int mgr; char hiredate [10];漂浮浮动通讯; int deptno; }; typedef struct emprec empdata; / *函数原型* / void sql_error（char *）; void insertdata（）; void fetchdata（）; void printempdata（empdata *）; void main（）{exec sql begin declare section; char * uid =“scott / tiger”; exec sql end declare section; exeler sql每当sqlerror执行sql_error（“ORACLE error  -  \ n”）; exec sql connect：uid; printf（“使用DB2数组插入语法将％d行插入EMP表。\ n”，INSCNT）; insertdata（）; printf（“\ n使用DB2数组获取语法获取数据。\ n”）; fetchdata（）; exec sql rollback工作版;出口（EXIT_SUCCESS）;使用DB2数组插入语法将数据插入表中* / void insertdata（）{int i，cnt; char * str; empdata emp_in [INSCNT]; / *存储临时字符串* / str =（char *）malloc（25 * sizeof（char））; / *填充数组元素以插入* / for（i = 0; i &lt;INSCNT; i ++）{emp_in [i] .empno = i + 1; sprintf（str，“EMP_％03d”，i + 1）; strcpy（emp_in [i] .ename.arr，str）; emp_in [i] .ename.len = strlen（emp_in [i] .ename.arr）; sprintf（str，“JOB_％03d”，i + 1）; strcpy（emp_in [i] .job.arr，str）; emp_in [i] .job.len = strlen（emp_in [i] .job.arr）; emp_in [i] .mgr = i + 1001; sprintf（str，“％02d-MAY-06”，（i％30）+1）; strcpy（emp_in [i] .hiredate，str）; emp_in [i] .sal =（i + 1）* 10; emp_in [i] .comm =（i + 1）* 0.1; emp_in [i] .deptno = 10; } free（str）; / *使用DB2数组插入语法插入数据* / exec sql insert into emp values（：emp_in）FOR：INSCNT rows; exec sql select count（*）into：cnt from emp where ename like'EMP_％'; printf（“成功插入emp表的行数：％d \ n”，cnt）; / *使用DB2数组获取语法从表中获取数据* / void fetchdata（）{empdata emp_out [FETCHCNT]; / *声明可滚动游标以获取数据* / exec sql声明c1使用行集定位滚动游标以选择empno，ename，job，mgr，hiredate，sal，comm，deptno来自emp，其中ename类似'EMP_％'命令由empno; exec sql open c1; exec sql什么都没找到做破坏; while（1）{/ *使用DB2数组获取语法获取数据* / exec sql从c1获取下一行集：FETCHCNT行：emp_out; printempdata（emp_out）;每当找不到exec sql sql_error（“ORACLE ERROR”）; exec sql close c1; } / *打印获取的员工数据* / void printempdata（empdata * emp_out）{int i; for（i = 0; i &lt;FETCHCNT; i ++）{emp_out [i] .ename.arr [emp_out [i] .ename.len] ='\ 0'; emp_out [i] .job.arr [emp_out [i] .job.len] ='\ 0'; printf（“Empno =％d，Ename =％s，Job =％s，Mgr =％d，Hiredate =％s，Sal =％6.2f，\ n”“Comm =％5.2f，Deptno =％d \ n “，emp_out [i] .empno，emp_out [i] .ename.arr，emp_out [i] .job.arr，emp_out [i] .mgr，emp_out [i] .hiredate，emp_out [i] .sal，emp_out [我] .comm，emp_out [i] .deptno）;错误处理函数。* / void sql_error（char * msg）{exec sql每当sqlerror继续; printf（“\ n％s \ n”，msg）; printf（“％。70s \ n”，sqlca.sqlerrm.sqlerrmc）; exec sql rollback release;出口（EXIT_FAILURE）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCC3488"></a><a id="LNPCC3487"></a><div class="props_rev_3"><a id="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786" name="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786"></a><h3 id="LNPCC-GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786" class="sect3"><span class="enumeration_section">8.13</span>关于使用隐式缓冲插入</h3>
               <div>
                  <p>为了提高性能，Pro * C / C ++应用程序开发人员可以在其嵌入式SQL语句中引用主机数组。这提供了一种通过单次往返数据库来执行SQL语句数组的方法。尽管阵列执行提供了显着的性能改进，但一些开发人员选择不使用此功能，因为它不是ANSI标准。例如，使用IBM的预编译器无法预编译在Oracle中利用数组执行编写的应用程序。</p>
                  <p>一种解决方法是使用缓冲的INSERT语句，这使您可以在保留ANSI标准嵌入式SQL语法的同时获得性能优势。</p>
                  <p>命令行选项“max_row_insert”控制在执行INSERT语句之前要缓冲的行数。默认情况下，它为零，并且禁用该功能。要启用此功能，请指定任何大于零的数字。</p>
                  <p>如果启用了插入缓冲，则预编译器运行时将标记相应的光标并：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分配或重新分配额外的内存以保存绑定值（仅首先执行）。</p>
                     </li>
                     <li>
                        <p>将绑定值从程序主机变量复制到内部运行时绑定结构。</p>
                     </li>
                     <li>
                        <p>增加行缓冲计数。</p>
                     </li>
                     <li>
                        <p>如果MAX_INSERT_ROWS已被缓冲，则刷新缓冲的INSERT语句。</p>
                     </li>
                     <li>
                        <p>如果尚未命中MAX_INSERT_ROWS，则在将值复制到内部绑定缓冲区而不刷新后返回。</p>
                     </li>
                  </ul>
                  <p>如果执行新的嵌入式SQL语句并导致刷新缓冲的插入语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>冲洗缓冲区。</p>
                     </li>
                     <li>
                        <p>继续提示刷新的调用。</p>
                     </li>
                  </ul>
                  <p>通过标准预编译器错误机制（例如Pro * C中的sqlca）通知应用程序错误。</p>
                  <p>“implicit_svpt”选项控制是否在新批处理插入的开始之前采用隐式保存点。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果是，则在开始新批次行之前获取保存点。如果插入时发生错误，则执行隐式“回滚到保存点”。</p>
                     </li>
                     <li>
                        <p>如果不是，则不会采用隐式保存点。如果缓冲插入时发生错误，则会将其报告回应用程序，但不会执行回滚。缓冲区插入异步报告错误。在应用程序中执行INSERT语句时，不会报告插入行的错误。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当执行除INSERT之外的第一个语句时，稍后将报告插入行的某些错误。这可能包括DELETE，UPDATE，INSERT（进入不同的表），COMMIT和ROLLBACK。任何关闭缓冲插入语句的语句都可以报告错误。在这种情况下，不会执行报告错误的语句。您需要首先处理错误并重新执行报告缓冲插入错误的语句。否则，您可以回滚事务并重新执行它。</p>
                              <p>例如，考虑使用COMMIT语句来关闭缓冲的插入循环。COMMIT可以报告错误，因为来自先前插入的重复键。在这种情况下，不执行提交。您应该首先处理错误，然后重新执行COMMIT。否则，您可以回滚事务并重新执行它。</p>
                           </li>
                           <li>
                              <p>插件本身会报告一些错误，并且可能反映先前插入的行的错误。在这种情况下，不会执行进一步的插入。您需要处理先前插入的行的错误并继续插入当前插入，这是一个漫长的过程。相反，您可以回滚并重新执行该事务。</p>
                              <p>例如，考虑内部缓冲区的限制为10行，应用程序在循环中插入15行。假设第8行有错误。第11行插入发生时报告错误，并且不再执行插入操作。</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>以下是缓冲插入期间可能遇到的一些错误：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>ORA-00001：索引中的重复键</p>
                     </li>
                     <li>
                        <p>ORA-01400：在插入期间缺少必需（非空）列或Null</p>
                     </li>
                     <li>
                        <p>ORA-01401：插入的值对于列太大</p>
                     </li>
                     <li>
                        <p>ORA-01438：大于指定精度的值允许此列</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786__GUID-F968B692-F649-4EC6-B492-A813A14BFEBD">
                     <p class="titleinexample">示例8-2将缓冲行插入表中</p>
                     <p>该程序将LOOPCNT行数插入EMP表。在循环计数器= 5时，此程序尝试插入无效的empno。如果没有max_row_insert选项，程序将插入除无效行之外的所有行。当max_row_insert选项设置为LOOPCNT时，仅插入前四行。</p>
                     <p>使用max_row_insert选项，当删除错误语句时，程序执行与数组插入程序相同的方式。</p><pre class="oac_no_warn" dir="ltr">/ * * bufinsdemo.pc * / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlcpr.h&gt; #include &lt;sqlca.h&gt; / *要插入表中的行数* / #define LOOPCNT 100 / *定义一个主机结构，用于将数据插入表中以及从表中获取数据* / struct emprec {int empno; varchar ename [10]; varchar job [9]; int mgr; char hiredate [10];漂浮浮动通讯; int deptno; }; typedef struct emprec buffinstyp; / *函数原型* / void sql_error（）; void insertdata（）; void fetchdata（）; void printempdata（buffinstyp）; void main（）{exec sql begin declare section; char * uid =“scott / tiger”; exec sql end declare section;每当sqlerror执行sql_error（）时exec sql; exec sql connect：uid; printf（“\ n将％d行插入EMP表。\ n”，LOOPCNT）; insertdata（）; printf（“\ n从EMP表中获取插入的数据。\ n”）; fetchdata（）; exec sql从emp删除，其中empno &lt;1000; exec sql commit work release;出口（EXIT_SUCCESS）; / *将数据插入表* / void insertdata（）{int i，cnt; char * str; buffinstyp emp_in; / *存储临时字符串* / str =（char *）malloc（25 * sizeof（char））; / * *当max_row_insert选项设置为LOOPCNT并且删除errorneous *语句时，所有行将在*一段中插入数据库，因此将实现最大性能增益。* / for（i = 1; i &lt;= LOOPCNT; i ++）{if（i！）= 5）emp_in.empno = i; else / *错误的陈述。在emp表中，empno被定义为数字（4）。* / emp_in.empno = 10000; sprintf（str，“EMP_％03d”，i）; strcpy（emp_in.ename.arr，str）; emp_in.ename.len = strlen（emp_in.ename.arr）; sprintf（str，“JOB_％03d”，i）; strcpy（emp_in.job.arr，str）; emp_in.job.len = strlen（emp_in.job.arr）; emp_in.mgr = i + 1001; sprintf（str，“％02d-MAY-06”，（i％30））; strcpy（emp_in.hiredate，str）; emp_in.sal =（i）* 10; emp_in.comm =（i）* 0.1; emp_in.deptno = 10; exec sql insert into emp values（：emp_in）; } free（str）; exec sql commit; exec sql select count（*）into：cnt from emp where ename like'EMP_％'; printf（“成功插入emp表的行数：％d \ n”，cnt）; / *从表中获取数据* / void fetchdata（）{buffinstyp emp_out; / *声明游标只获取插入的行* / exec sql声明c1游标用于选择empno，ename，job，mgr，hiredate，sal，comm，deptno来自emp，其中ename类似'EMP_％'命令由empno; exec sql open c1; exec sql什么都没找到做破坏; while（1）{/ *在每次调用时获取单行* / exec sql fetch c1 into：emp_out; printempdata（emp_out）;每当找不到exec sql sql_error（）; exec sql close c1; } / *打印获取的员工数据* / void printempdata（buffinstyp emp_out）{emp_out.ename.arr [emp_out.ename.len] ='\ 0'; emp_out.job.arr [emp_out.job.len] ='\ 0'; printf（“Empno =％d，Ename =％s，Job =％s，Mgr =％d，Hiredate =％s，Sal =％6.2f，\ n”“Comm =％5.2f，Deptno =％d \ n “，emp_out.empno，emp_out.ename.arr，emp_out.job.arr，emp_out.mgr，emp_out.hiredate，emp_out.sal，emp_out.comm，emp_out.deptno）; } / *错误处理函数。* / void sql_error（）{printf（“Error％s \ n”，sqlca.sqlerrm.sqlerrmc）; printf（“Rows Processed：％d \ n”，sqlca.sqlerrd [2]）; printf（“Rows Rolled Back：％d \ n”，sqlca.sqlerrd [0]）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCC3489"></a><div class="props_rev_3"><a id="GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5" name="GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5"></a><h3 id="LNPCC-GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5" class="sect3"><span class="enumeration_section">8.14可</span>滚动游标</h3>
               <div>
                  <p>可滚动游标是Oracle执行SQL语句并存储在执行期间处理的信息的工作区。执行游标时，查询结果将放入一组称为结果集的行中。结果集可以按顺序或非顺序获取。非顺序结果集称为可滚动游标。可滚动游标使用户能够以前向，后向和随机方式访问数据库结果集的行。这使程序能够获取结果集中的任何行。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="04994.embedded-PL-SQL.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>嵌入式PL / SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="embedded-SQL.html" title="Previous" type="text/html"></link>
      <link rel="next" href="host-arrays.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="host-arrays.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">嵌入式PL / SQL</li>
            </ol>
            <a id="GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654" name="GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654"></a><a id="LNPCC3397"></a>
            
            <h2 id="LNPCC-GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654" class="sect2"><span class="enumeration_chapter">7</span>嵌入式PL / SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何通过在程序中嵌入PL / SQL事务处理块来提高性能。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-F181104F-663F-4D4E-9BB8-9F0E9B93C82A">PL / SQL的优点</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-5BEE764D-014F-4677-AB9B-78A2DDCB39FB">嵌入式PL / SQL块</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-5E215CB6-82C4-4BA5-8D12-636BE005227E">主机变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-BC7145CA-5296-4287-B7E4-0D2A52CE2B70">指标变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2">主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-117968E7-E597-4448-AC5D-581BF1361E2C">嵌入式PL / SQL中的游标用法</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-65965251-9158-442D-A69B-D52A33B35E22">存储的PL / SQL和Java子程序</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-2191B843-36C4-4936-B0F5-97AB0AB8CDEA">外部程序</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PL-SQL.html#GUID-A147B827-C733-47AD-944F-BEA87FC7CAD3">关于使用动态SQL</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="embedded-PL-SQL.html#GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654">嵌入式PL / SQL</a></li>
                  </ul>
               </div>
            </div>
            <a id="LNPCC3398"></a><div class="props_rev_3"><a id="GUID-F181104F-663F-4D4E-9BB8-9F0E9B93C82A" name="GUID-F181104F-663F-4D4E-9BB8-9F0E9B93C82A"></a><h3 id="LNPCC-GUID-F181104F-663F-4D4E-9BB8-9F0E9B93C82A" class="sect3"><span class="enumeration_section">7.1</span> PL / SQL的优点</h3>
               <div>
                  <p>本节介绍PL / SQL提供的一些功能和优点，例如：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-06339EB1-7966-4F9D-8593-4DD7F53D2BDB">更好的性能</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-02AD4583-9307-4B4B-B67E-385274CD5A1B">与Oracle集成</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-B5D728FA-C238-4F28-AF1C-06920ED39036">光标FOR循环</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-CE9D6002-9C8D-430F-A518-54C7C3DAD322">程序和功能</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-D5C9AB9A-C065-4B82-AD99-E29908B93170">包</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-00730E73-71A2-4FB0-960E-97C2FADF9C20">PL / SQL表</a></p>
                     </li>
                     <li>
                        <p><a href="embedded-PL-SQL.html#GUID-C2B7D923-800B-4361-88DC-06FA50488F85">用户定义的记录</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../lnpls/index.html" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3399"></a><div class="props_rev_3"><a id="GUID-06339EB1-7966-4F9D-8593-4DD7F53D2BDB" name="GUID-06339EB1-7966-4F9D-8593-4DD7F53D2BDB"></a><h4 id="LNPCC-GUID-06339EB1-7966-4F9D-8593-4DD7F53D2BDB" class="sect4"><span class="enumeration_section">7.1.1</span>更好的表现</h4>
                  <div>
                     <p>PL / SQL可以帮助您减少开销，提高性能并提高工作效率。例如，如果没有PL / SQL，Oracle必须一次处理一个SQL语句。每个SQL语句都会导致对服务器的另一次调用以及更高的开销。但是，使用PL / SQL，您可以将整个SQL语句块发送到服务器。这可以最大限度地减少应用程序与Oracle之间的通<a id="d33328e129" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC3400"></a><div class="props_rev_3"><a id="GUID-02AD4583-9307-4B4B-B67E-385274CD5A1B" name="GUID-02AD4583-9307-4B4B-B67E-385274CD5A1B"></a><h4 id="LNPCC-GUID-02AD4583-9307-4B4B-B67E-385274CD5A1B" class="sect4"><span class="enumeration_section">7.1.2</span>与Oracle集成</h4>
                  <div>
                     <p>PL / SQL与Oracle Server紧密集成。例如，大多数PL / SQL数据类型是Oracle数据字典的原生数据类型。此外，您可以使用％TYPE属性将变量声明基于存储在数据字典中的列定义，如以下示例所示： <a id="d33328e146" class="indexterm-anchor"></a><a id="d33328e150" class="indexterm-anchor"></a><a id="d33328e154" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">job_title emp.job％TYPE;</pre><p>这样，您无需知道列的确切数据类型。此外，如果列定义发生更改，则变量声明会相应地自动更改。这提供了数据独立性，降低了维护成本，并允许程序随着数据库的变化而适应。</p>
                  </div>
               </div><a id="LNPCC3401"></a><div class="props_rev_3"><a id="GUID-B5D728FA-C238-4F28-AF1C-06920ED39036" name="GUID-B5D728FA-C238-4F28-AF1C-06920ED39036"></a><h4 id="LNPCC-GUID-B5D728FA-C238-4F28-AF1C-06920ED39036" class="sect4"><span class="enumeration_section">7.1.3</span>游标FOR循环</h4>
                  <div>
                     <p>使用PL / SQL，您无需使用DECLARE，OPEN，FETCH和CLOSE语句来定义和操作游标。相反，您可以使用游标FOR循环，它隐式声明其循环索引作为记录，打开与给定查询关联的游标，重复从游标中取出数据到记录中，然后关闭游标。一个例子如下： <a id="d33328e174" class="indexterm-anchor"></a><a id="d33328e178" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">宣布 ...BEGIN FOR emprec IN（SELECT empno，sal，comm FROM emp）LOOP IF emprec.comm / emprec.sal&gt; 0.25 THEN ......结束循环;结束;</pre><p>请注意，您使用点表示法来引用记录中的组件。</p>
                  </div>
               </div><a id="LNPCC3402"></a><div class="props_rev_3"><a id="GUID-CE9D6002-9C8D-430F-A518-54C7C3DAD322" name="GUID-CE9D6002-9C8D-430F-A518-54C7C3DAD322"></a><h4 id="LNPCC-GUID-CE9D6002-9C8D-430F-A518-54C7C3DAD322" class="sect4"><span class="enumeration_section">7.1.4</span>程序和功能</h4>
                  <div>
                     <p>PL / SQL有两种类型的子程序，称为<span class="italic">过程</span>和<span class="italic">函数</span> ，它们通过让您隔离操作来帮助开发应用程序。通常，您使用过程来执行操作，使用函数来计算值。 <a id="d33328e204" class="indexterm-anchor"></a><a id="d33328e208" class="indexterm-anchor"></a> 
                     </p>
                     <p>程序和功能提供了<span class="italic">可扩展性</span> 。也就是说，它们可以让您定制PL / SQL语言以满足您的需求。例如，如果您需要一个创建新部门的过程，请按如下方式编写自己的部门：</p><pre class="oac_no_warn" dir="ltr">PROCEDURE create_dept（new_dname IN CHAR（14），new_loc IN CHAR（13），new_deptno OUT NUMBER（2））IS BEGIN SELECT deptno_seq。NEXTVAL INTO new_deptno FROM dual; INSERT INTO dept VALUES（new_deptno，new_dname，new_loc）; END create_dept;</pre><p>调用时，此过程接受新的部门名称和位置，选择部门编号数据库序列中的下一个值，将新编号，名称和位置插入到<span class="italic">dept</span>表中，然后将新编号返回给调用者。
                     </p>
                     <p>您可以使用<span class="italic">参数模式</span>来定义形式参数的行为。有三种参数模式：IN（默认值），OUT和IN OUT。 IN参数允许您将值传递给被调用的子程序。OUT参数允许您将值返回给子程序的调用者。IN OUT参数允许您将初始值传递给被调用的子程序，并将更新的值返回给调用者。 <a id="d33328e230" class="indexterm-anchor"></a><a id="d33328e232" class="indexterm-anchor"></a><a id="d33328e234" class="indexterm-anchor"></a><a id="d33328e236" class="indexterm-anchor"></a><a id="d33328e238" class="indexterm-anchor"></a> 
                     </p>
                     <p>每个实际参数的数据类型必须可转换为其相应形式参数的数据类型。<a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2__CHDDCCFE" title="法律数据类型转换">表7-1</a>显示了数据类型之间的合法转换。
                     </p>
                  </div>
               </div><a id="LNPCC3403"></a><div class="props_rev_3"><a id="GUID-D5C9AB9A-C065-4B82-AD99-E29908B93170" name="GUID-D5C9AB9A-C065-4B82-AD99-E29908B93170"></a><h4 id="LNPCC-GUID-D5C9AB9A-C065-4B82-AD99-E29908B93170" class="sect4"><span class="enumeration_section">7.1.5</span>包</h4>
                  <div>
                     <p>PL / SQL允许您将逻辑上相关的类型，程序对象和子程序捆绑到一个<span class="italic">包中</span> 。通过Procedural Database Extension，可以编译包并将其存储在Oracle数据库中，其中的内容可以由许多应用程序共享。 <a id="d33328e263" class="indexterm-anchor"></a><a id="d33328e267" class="indexterm-anchor"></a><a id="d33328e271" class="indexterm-anchor"></a> 
                     </p>
                     <p>包通常包含两部分：规范和正文。<span class="italic">规范</span>是应用程序的接口;它声明了可供使用的类型，常量，变量，异常，游标和子程序。<span class="italic">正文</span>定义了游标和子程序;它实现了规范。在以下示例中，您“打包”了两个雇佣程序：</p><pre class="oac_no_warn" dir="ltr">PACKAGE emp_actions IS  - 包规范PROCEDURE hire_employee（empno NUMBER，ename CHAR，...）;程序fire_employee（emp_id NUMBER）; END emp_actions; PACKAGE BODY emp_actions IS  - 包体PROCEDURE hire_employee（empno NUMBER，ename CHAR，...）是开始插入emp VALUES（empno，ename，...）; END hire_employee;程序fire_employee（emp_id NUMBER）从emp WHERE empno = emp_id开始删除;结束fire_employee; END emp_actions;</pre><p>只有包规范中的声明可见且可供应用程序访问。包体中的实现细节是隐藏的，无法访问。</p>
                  </div>
               </div><a id="LNPCC3404"></a><div class="props_rev_3"><a id="GUID-00730E73-71A2-4FB0-960E-97C2FADF9C20" name="GUID-00730E73-71A2-4FB0-960E-97C2FADF9C20"></a><h4 id="LNPCC-GUID-00730E73-71A2-4FB0-960E-97C2FADF9C20" class="sect4"><span class="enumeration_section">7.1.6</span> PL / SQL表</h4>
                  <div>
                     <p>PL / SQL提供名为TABLE的复合数据类型。 TABLE类型的对象称为<span class="italic">PL / SQL表</span> ，它们被建模为（但不是相同的）数据库表。PL / SQL表只有一列，并使用主键为您提供类似行的行访问。该列可以属于任何标量类型（例如CHAR，DATE或NUMBER），但主键必须属于BINARY_INTEGER，PLS_INTEGER或VARCHAR2类型。<a id="d33328e300" class="indexterm-anchor"></a><a id="d33328e304" class="indexterm-anchor"></a></p>
                     <p>您可以在任何块，过程，函数或包的声明部分中声明PL / SQL表类型。在以下示例中，您声明了一个名为<span class="italic">NumTabTyp</span>的TABLE类型：</p><pre class="oac_no_warn" dir="ltr">...DECLARE TYPE NumTabTyp是BINARY_INTEGER的数字索引表; ...开始 ...结束; ...
</pre><p>定义类型<span class="italic">NumTabTyp后</span> ，可以声明该类型的PL / SQL表，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">num_tab NumTabTyp;</pre><p>标识符<span class="italic">num_tab</span>表示整个PL / SQL表。
                     </p>
                     <p>使用类似数组的语法引用PL / SQL表中的行以指定主键值。例如，您引用名为<span class="italic">num_tab</span>的PL / SQL表中的第九行，如下所示：</p><pre class="oac_no_warn" dir="ltr">num_tab（9）......</pre></div>
               </div><a id="LNPCC3405"></a><div class="props_rev_3"><a id="GUID-C2B7D923-800B-4361-88DC-06FA50488F85" name="GUID-C2B7D923-800B-4361-88DC-06FA50488F85"></a><h4 id="LNPCC-GUID-C2B7D923-800B-4361-88DC-06FA50488F85" class="sect4"><span class="enumeration_section">7.1.7</span>用户定义的记录</h4>
                  <div>
                     <p>您可以使用％ROWTYPE属性声明一条记录，该记录表示表中的行或游标提取的行。但是，您无法在记录中指定组件的数据类型或定义自己的组件。复合数据类型RECORD解除了这些限制。 <a id="d33328e345" class="indexterm-anchor"></a><a id="d33328e347" class="indexterm-anchor"></a><a id="d33328e349" class="indexterm-anchor"></a><a id="d33328e353" class="indexterm-anchor"></a> 
                     </p>
                     <p>RECORD类型的对象称为<span class="italic">记录</span> 。与PL / SQL表不同，记录具有唯一命名的组件，这些组件可以属于不同的数据类型。例如，假设您有关于员工的不同类型的数据，例如姓名，工资，雇用日期等。这些数据在类型上不同但在逻辑上相关。包含员工姓名，工资和雇用日期等组件的记录可让您将数据视为逻辑单元。
                     </p>
                     <p>您可以在任何块，过程，函数或包的声明部分中声明记录类型和对象。在以下示例中，您声明了一个名为<span class="italic">DeptRecTyp</span>的RECORD类型：</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE DeptRecTyp是RECORD（deptno NUMBER（4）NOT NULL， - 默认为NULL允许dname CHAR（9），loc CHAR（14））;</pre><p>请注意，组件声明与变量声明类似。每个组件都有唯一的名称和特定的数据类型。您可以将NOT NULL选项添加到任何组件声明中，从而防止将NULL分配给该组件。</p>
                     <p>一旦定义了类型<span class="italic">DeptRecTyp</span> ，就可以声明该类型的记录，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">dept_rec DeptRecTyp;</pre><p>标识符<span class="italic">dept_rec</span>表示整个记录。
                     </p>
                     <p>您可以使用点表示法来引用记录中的各个组件。例如，您在<span class="italic">dept_rec</span>记录中引用<span class="italic">dname</span>组件，如下所示：</p><pre class="oac_no_warn" dir="ltr">dept_rec.dname ...</pre></div>
               </div>
            </div><a id="LNPCC3406"></a><div class="props_rev_3"><a id="GUID-5BEE764D-014F-4677-AB9B-78A2DDCB39FB" name="GUID-5BEE764D-014F-4677-AB9B-78A2DDCB39FB"></a><h3 id="LNPCC-GUID-5BEE764D-014F-4677-AB9B-78A2DDCB39FB" class="sect3"><span class="enumeration_section">7.2</span>嵌入式PL / SQL块</h3>
               <div>
                  <p>Pro * C / C ++预编译器将PL / SQL块视为单个嵌入式SQL语句。因此，您可以将PL / SQL块放在可以放置SQL语句的程序中的任何位置。 <a id="d33328e406" class="indexterm-anchor"></a><a id="d33328e410" class="indexterm-anchor"></a> 
                  </p>
                  <p>要在Pro * C / C ++程序中嵌入PL / SQL块，只需将PL / SQL块与关键字EXEC SQL EXECUTE和END-EXEC括在一起，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE DECLARE ...开始 ...结束; END-EXEC;</pre><p>关键字END-EXEC必须后跟分号。 <a id="d33328e421" class="indexterm-anchor"></a> 
                  </p>
                  <p>编写程序后，以常规方式预编译源文件。</p>
                  <p>当程序包含嵌入式PL / SQL时，必须使用SQLCHECK = SEMANTICS命令行选项，因为必须由Oracle Server解析PL / SQL。SQLCHECK = SEMANTICS也需要USERID选项才能连接到服务器。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-1FB02C5F-DCC0-453C-A6AB-246421712F74">关于使用预编译器选项</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3407"></a><div class="props_rev_3"><a id="GUID-5E215CB6-82C4-4BA5-8D12-636BE005227E" name="GUID-5E215CB6-82C4-4BA5-8D12-636BE005227E"></a><h3 id="LNPCC-GUID-5E215CB6-82C4-4BA5-8D12-636BE005227E" class="sect3"><span class="enumeration_section">7.3</span>主机变量</h3>
               <div>
                  <p>主机变量是主机语言和PL / SQL块之间通信的关键。主机变量可以与PL / SQL共享，这意味着PL / SQL可以设置和引用主机变量。</p>
                  <p>例如，您可以提示用户输入信息并使用主机变量将该信息传递给PL / SQL块。然后，PL / SQL可以访问数据库并使用主机变量将结果传递回主机程序。<a id="d33328e452" class="indexterm-anchor"></a></p>
                  <p>在PL / SQL块中，主变量被视为整个块的全局变量，可以在允许PL / SQL变量的任何地方使用。与SQL语句中的主变量一样，PL / SQL块中的主机变量必须以冒号为前缀。冒号设置除PL / SQL变量和数据库对象之外的主变量。</p>
                  <div class="infoboxnote" id="GUID-5E215CB6-82C4-4BA5-8D12-636BE005227E__GUID-6482F7B7-91A4-419B-86E8-F84FAB0613E3">
                     <p class="notep1">注意：</p>
                     <p>要将VARCHAR，CHARZ或STRING类型用作PL / SQL块中的输出主机变量，必须<span class="italic">在</span>进入块<span class="italic">之前</span>初始化长度。将长度设置为VARCHAR，CHARZ或STRING的声明（最大）长度。</p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="datatypes-and-host-variables.html#GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8">指针变量</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3408"></a><div class="props_rev_3"><a id="GUID-DB613125-638D-4254-9EA1-E81158B6D5DD" name="GUID-DB613125-638D-4254-9EA1-E81158B6D5DD"></a><h4 id="LNPCC-GUID-DB613125-638D-4254-9EA1-E81158B6D5DD" class="sect4"><span class="enumeration_section">7.3.1</span>示例：将主机变量与PL / SQL一起使用</h4>
                  <div>
                     <div class="section">
                        <p>以下示例说明了使用PL / SQL的主机变量。程序会提示用户输入员工编号，然后显示该员工的职位，雇用日期和工资。<a id="d33328e485" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">char username [100]，密码[20]; char job_title [20]，hire_date [9]，temp [32]; int emp_number;浮动工资; #include &lt;sqlca.h&gt; printf（“用户名？\ n“）;获取（用户名）; printf（”密码？\ n“）;获取（密码）; EXEC SQL WHENEVER SQLERROR GOTO sql_error; EXEC SQL CONNECT：username IDENTIFIED BY：password; printf（”Connected to Oracle \ n“）; for（;;）{printf（”Employee Number（ 0到结束）？“）; gets（temp）; emp_number = atoi（temp）; if（emp_number == 0）{EXEC SQL COMMIT WORK RELEASE; printf（”退出程序\ n“）; break;} / * ------ --------开始PL / SQL块----------------- * / EXEC SQL EXECUTE BEGIN SELECT job，hiredate，sal INTO：job_title，：hire_date，： salary FROM emp WHERE empno =：emp_number; END; END-EXEC; / * --------------结束PL / SQL块-------------- --- * / printf（“Number Job Title Hire Date Salary \ n”）; printf（“---------------------------- -------- \ n“）; printf（”％6d％8.8s％9.9s％6.2f \ n“，emp_number，job_title，hire_date，salary）;} ...出口（0）; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版; printf（“处理错误\ n”）;出口（1）;</pre><p>请注意，在进入PL / SQL块之前主机变量<span class="italic">emp_number</span>被设定，并且主机变量<span class="italic"><span class="italic">JOB_TITLE，HIRE_DATE，</span></span>和<span class="italic">工资</span>所设置的块内。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3409"></a><div class="props_rev_3"><a id="GUID-46B51FA3-E1B5-4D42-A51D-E50E9DEA4339" name="GUID-46B51FA3-E1B5-4D42-A51D-E50E9DEA4339"></a><h4 id="LNPCC-GUID-46B51FA3-E1B5-4D42-A51D-E50E9DEA4339" class="sect4"><span class="enumeration_section">7.3.2</span>复杂的例子</h4>
                  <div>
                     <div class="section">
                        <p>在稍后的示例中，您提示用户输入银行帐号，交易类型和交易金额，然后借记或贷记帐户。如果该帐户不存在，则引发异常。交易完成后，您将显示其状态。 <a id="d33328e518" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; #include &lt;sqlca.h&gt; char username [20]; char密码[20]; char status [80]; char temp [32]; int acct_num; double trans_amt; void sql_error（）; main（）{char trans_type; strcpy（密码，“TIGER”）; strcpy（用户名，“SCOTT”）;执行SQL WHENEVER SQLERROR DO sql_error（）; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; printf（“连接到Oracle \ n”）; for（;;）{printf（“帐号（0到结尾）？“）; gets（temp）; acct_num = atoi（temp）; if（acct_num == 0）{EXEC SQL COMMIT WORK RELEASE; printf（”退出程序\ n“）; break;} printf（”Transaction Type  -  D） ebit还是C）redit？“）;获取（temp）; trans_type = temp [0]; printf（”交易金额？“）; gets（temp）; trans_amt = atof（temp）; / * ----------------- begin PL / SQL block ----------- -------- * / EXEC SQL EXECUTE DECLARE old_bal NUMBER（9,2）; err_msg CHAR（70）;不存在EXCEPTION; BEGIN：trans_type：= UPPER（：trans_type）; IF：trans_type ='C'THEN - 贷记帐户UPDATE accts SET bal = bal +：trans_amt WHERE acctid =：acct_num; IF SQL％ROWCOUNT = 0 THEN  - 没有受影响的行RAISE不存在; ELSE：status：='Credit applied'; END IF; ELSIF： trans_type ='D'那么 - 借记帐户SELECT bal INTO old_bal FROM accts WHERE acctid =：acct_num; IF old_bal&gt; =：trans_amt那么 - 足够的资金UPDATE accts SET bal = bal  - ：trans_amt WHERE acctid =：acct_num;： status：='Debit applied'; ELSE：status：='资金不足'; END IF; ELSE：status：='无效类型：'||：trans_type; END IF; COMMIT; EXCEPTION NO_DATA_FOUND或不存在那么：状态： ='不存在的帐户';等等，然后err_msg：= SUBSTR（SQLERRM，1,70）;: status：='错误：'|| err_msg; END; END-EXEC; / * ---- -------------结束PL / SQL块----------------------- * / printf（“\ nStatus：％ s \ n“，状态）; } exit（0）; } void sql_error（）{EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版; printf（“处理错误\ n”）;出口（1）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3410"></a><div class="props_rev_3"><a id="GUID-41DF2AB2-FCB7-4C3D-B394-26D09F376697" name="GUID-41DF2AB2-FCB7-4C3D-B394-26D09F376697"></a><h4 id="LNPCC-GUID-41DF2AB2-FCB7-4C3D-B394-26D09F376697" class="sect4"><span class="enumeration_section">7.3.3</span> VARCHAR Pseudotype</h4>
                  <div>
                     <p>您可以使用VARCHAR数据类型声明可变长度字符串。如果VARCHAR是输入主变量，则必须告诉Oracle预期的长度。因此，将length组件设置为存储在字符串组件中的值的实际长度。</p>
                     <p>如果VARCHAR是输出主机变量，Oracle会自动设置长度组件。但是，要在PL / SQL块中使用VARCHAR（以及CHARZ和STRING）输出主机变量，必须<span class="italic">在</span>进入块<span class="italic">之前</span>初始化长度组件。因此，将length组件设置为VARCHAR的声明（最大）长度，如下所示：<a id="d33328e541" class="indexterm-anchor"></a><a id="d33328e545" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">int emp_number; varchar emp_name [10];浮动工资; ...emp_name.len = 10; / * initialize length component * / EXEC SQL EXECUTE BEGIN SELECT ename，sal INTO：emp_name ,: salary FROM emp WHERE empno =：emp_number; ...结束; END-EXEC; ...
</pre></div>
               </div><a id="LNPCC3411"></a><div class="props_rev_3"><a id="GUID-5B101D5D-041A-42BA-8EC7-BDED4155BEA7" name="GUID-5B101D5D-041A-42BA-8EC7-BDED4155BEA7"></a><h4 id="LNPCC-GUID-5B101D5D-041A-42BA-8EC7-BDED4155BEA7" class="sect4"><span class="enumeration_section">7.3.4</span>限制</h4>
                  <div>
                     <p>不要在PL / SQL块中使用C指针或数组语法。PL / SQL编译器不理解C主机变量表达式，因此无法解析它们。例如，以下内容<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE BEGIN：x [5] .name：='SCOTT'; ...结束; END-EXEC;</pre><p>要避免语法错误，请使用占位符（临时变量）来保存结构字段的地址以填充结构，如以下<span class="italic">有效</span>示例所示：</p><pre class="oac_no_warn" dir="ltr">name = x [5] .name; EXEC SQL EXECUTE BEGIN：name：= ...; ...结束; END-EXEC;</pre></div>
               </div>
            </div><a id="LNPCC3412"></a><div class="props_rev_3"><a id="GUID-BC7145CA-5296-4287-B7E4-0D2A52CE2B70" name="GUID-BC7145CA-5296-4287-B7E4-0D2A52CE2B70"></a><h3 id="LNPCC-GUID-BC7145CA-5296-4287-B7E4-0D2A52CE2B70" class="sect3"><span class="enumeration_section">7.4</span>指标变量</h3>
               <div>
                  <p>PL / SQL不需要指示符变量，因为它可以操作NULL。例如，在PL / SQL中，您可以使用IS NULL运算符来测试NULL，如下所示： <a id="d33328e585" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">IF变量IS NULL那么......
</pre><p>并且，您可以使用赋值运算符（：=）来分配NULL，如下所示：</p><pre class="oac_no_warn" dir="ltr">变量：= NULL;</pre><p>但是，诸如C之类的宿主语言需要指示符变量，因为它无法操作NULL。嵌入式PL / SQL通过让您使用指示符变量来满足此需求</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>接受来自主程序的NULL输入</p>
                     </li>
                     <li>
                        <p>将NULL或截断值输出到宿主程序</p>
                     </li>
                  </ul>
                  <p>在PL / SQL块中使用时，指示符变量遵循以下规则：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您不能单独引用指标变量;它必须附加到其关联的主变量。</p>
                     </li>
                     <li>
                        <p>如果您使用其指示符变量引用主变量，则必须始终在同一块中以该方式引用它。</p>
                     </li>
                  </ul>
                  <p>在下面的示例中，指示符变量<span class="italic">ind_comm</span>在SELECT语句中显示其主机变量<span class="italic">Commission</span> ，因此它必须以这种方式出现在IF语句中：</p><pre class="oac_no_warn" dir="ltr">...EXEC SQL EXECUTE BEGIN SELECT ename，comm INTO：emp_name，：commission：ind_comm FROM emp WHERE empno =：emp_number; IF：佣金：ind_comm IS NULL那么.........结束; END-EXEC;</pre><p>请注意，PL / SQL对待<span class="italic">：委托：ind_comm</span>与任何其他简单变量一样。虽然您不能直接引用PL / SQL块中的指示符变量，但PL / SQL在进入块时会检查指示符变量的值，并在退出块时正确设置值。
                  </p>
               </div><a id="LNPCC3413"></a><div class="props_rev_3"><a id="GUID-1A79CE80-DA07-456B-BE0E-435E8FB087AA" name="GUID-1A79CE80-DA07-456B-BE0E-435E8FB087AA"></a><h4 id="LNPCC-GUID-1A79CE80-DA07-456B-BE0E-435E8FB087AA" class="sect4"><span class="enumeration_section">7.4.1</span> NULL处理</h4>
                  <div>
                     <p>输入块时，如果指示符变量的值为-1，则PL / SQL会自动为主变量分配NULL。退出块时，如果主变量为NULL，PL / SQL会自动为指示符变量赋值-1。在下一个示例中，如果在输入PL / SQL块之前<span class="italic">ind_sal</span>的值为-1，则引发<span class="italic">salary_missing</span>异常。一个<span class="italic">例外</span>是命名错误条件。 <a id="d33328e649" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">...EXEC SQL EXECUTE BEGIN IF：salary：ind_sal IS NULL THEN RAISE salary_missing;万一; ...结束; END-EXEC; ...</pre></div>
               </div><a id="LNPCC3414"></a><div class="props_rev_3"><a id="GUID-67B13CF9-7E1D-4635-8026-BB2A91A792D8" name="GUID-67B13CF9-7E1D-4635-8026-BB2A91A792D8"></a><h4 id="LNPCC-GUID-67B13CF9-7E1D-4635-8026-BB2A91A792D8" class="sect4"><span class="enumeration_section">7.4.2</span>截断值</h4>
                  <div>
                     <p>将截断的字符串值分配给主机变量时，PL / SQL不会引发异常。但是，如果使用指示符变量，PL / SQL会将其设置为字符串的原始长度。在以下示例中，主机程序将能够通过检查<span class="italic">ind_name</span>的值来<span class="italic">判断</span>是否为<span class="italic">emp_name</span>分配了截断值： <a id="d33328e673" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">...EXEC SQL EXECUTE DECLARE ...new_name CHAR（10）;开始 ...：\ temp_name：ind_name：= new_name; ...结束; END-EXEC;</pre></div>
               </div>
            </div><a id="LNPCC3416"></a><a id="LNPCC3433"></a><a id="LNPCC3415"></a><div class="props_rev_3"><a id="GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2" name="GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2"></a><h3 id="LNPCC-GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2" class="sect3"><span class="enumeration_section">7.5</span>主机阵列</h3>
               <div>
                  <p>您可以将输入主机数组和指示符数组传递给PL / SQL块。它们可以由BINARY_INTEGER或PLS_INTEGER类型的PL / SQL变量索引;不允许使用VARCHAR2键类型。通常，整个主机数组都会传递给PL / SQL，但您可以使用ARRAYLEN语句（稍后讨论）来指定较小的数组维度。</p>
                  <p>此外，您可以使用过程调用将主机数组中的所有值分配给PL / SQL表中的行。假设数组下标范围是<span class="italic">m</span> .. <span class="italic">n</span> ，则相应的PL / SQL表索引范围始终为1 .. <span class="italic">n</span> - <span class="italic">m</span> + 1。例如，如果数组下标范围是5 .. 10，则相应的PL / SQL表索引范围是1 ..（10  -  5 + 1）或1 ..6。
                  </p>
                  <p>在下面的示例中，将名为<span class="italic">salary</span>的数组传递给PL / SQL块，该块在函数调用中使用该数组。该函数名为<span class="italic">median，</span>因为它在一系列数字中找到中间值。其形式参数包括名为<span class="italic">num_tab</span>的PL / SQL表。函数调用将实际参数<span class="italic">salary</span>中的所有值分配给formal参数<span class="italic">num_tab</span>中的行。
                  </p><pre class="oac_no_warn" dir="ltr">...浮动工资[100]; / *填充主机数组* / EXEC SQL EXECUTE DECLARE TYPE NumTabTyp IS BINARY_INTEGER的真实索引表; median_salary REAL; n BINARY_INTEGER; ...功能中位数（num_tab NumTabTyp，n INTEGER）返回实际开始 - 计算中位数END;开始n：= 100; median_salary：=中位数（：salary，n）; ...结束; END-EXEC; ...
</pre><div class="infoboxnote" id="GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2__GUID-AE98BE81-D407-4837-ACF5-8087FBB3E840">
                     <p class="notep1">注意：</p>
                     <p>在动态SQL方法4中，您无法使用类型为“table”的参数将主机数组绑定到PL / SQL过程。</p>
                  </div>
                  <p>您还可以使用过程调用将PL / SQL表中的所有行值分配给主机数组中的相应元素。</p>
                  <p><a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2__CHDDCCFE" title="法律数据类型转换">表7-1</a>显示了PL / SQL表中的行值与主机数组中的元素之间的合法转换。例如，类型为LONG的主机数组与VARCHAR2，LONG，RAW或LONG RAW类型的PL / SQL表兼容。值得注意的是，它与CHAR类型的PL / SQL表不兼容。</p>
                  <div class="tblformal" id="GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2__CHDDCCFE">
                     <p class="titleintable">表7-1 Legal数据类型转换</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="法律数据类型转换" width="100%" border="1" summary="Legal Datatype Conversions" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="15%" id="d33328e755">PL / SQL表 - &gt;主机阵列</th>
                              <th align="left" valign="bottom" width="10%" id="d33328e762">CHAR</th>
                              <th align="left" valign="bottom" width="10%" id="d33328e766">日期</th>
                              <th align="left" valign="bottom" width="10%" id="d33328e770">长</th>
                              <th align="left" valign="bottom" width="11%" id="d33328e774">LONG RAW</th>
                              <th align="left" valign="bottom" width="11%" id="d33328e778">数</th>
                              <th align="left" valign="bottom" width="8%" id="d33328e782">生的</th>
                              <th align="left" valign="bottom" width="11%" id="d33328e786">ROWID</th>
                              <th align="left" valign="bottom" width="13%" id="d33328e790">VARCHAR2</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e796" headers="d33328e755 ">
                                 <p>CHARF</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e796 d33328e762 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e796 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e796 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e796 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e796 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e796 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e796 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e796 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e824" headers="d33328e755 ">
                                 <p>CHARZ</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e824 d33328e762 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e824 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e824 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e824 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e824 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e824 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e824 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e824 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e852" headers="d33328e755 ">
                                 <p>日期</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e852 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e852 d33328e766 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e852 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e852 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e852 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e852 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e852 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e852 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e880" headers="d33328e755 ">
                                 <p>DECIMAL</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e880 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e880 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e880 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e880 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e880 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e880 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e880 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e880 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e908" headers="d33328e755 ">
                                 <p>显示</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e908 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e908 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e908 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e908 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e908 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e908 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e908 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e908 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e936" headers="d33328e755 ">
                                 <p>浮动</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e936 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e936 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e936 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e936 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e936 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e936 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e936 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e936 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e964" headers="d33328e755 ">
                                 <p>整数</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e964 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e964 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e964 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e964 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e964 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e964 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e964 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e964 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e992" headers="d33328e755 ">
                                 <p>长</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e992 d33328e762 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e992 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e992 d33328e770 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e992 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e992 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e992 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e992 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e992 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1020" headers="d33328e755 ">
                                 <p>LONG VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1020 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1020 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1020 d33328e770 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1020 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1020 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1020 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1020 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1020 d33328e790 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1048" headers="d33328e755 ">
                                 <p>LONG VARRAW</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1048 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1048 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1048 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1048 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1048 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1048 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1048 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1048 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1076" headers="d33328e755 ">
                                 <p>数</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1076 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1076 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1076 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1076 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1076 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1076 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1076 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1076 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1105" headers="d33328e755 ">
                                 <p>生的</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1105 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1105 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1105 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1105 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1105 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1105 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1105 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1105 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1133" headers="d33328e755 ">
                                 <p>ROWID</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1133 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1133 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1133 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1133 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1133 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1133 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1133 d33328e786 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1133 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1161" headers="d33328e755 ">
                                 <p>串</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1161 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1161 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1161 d33328e770 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1161 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1161 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1161 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1161 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1161 d33328e790 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1189" headers="d33328e755 ">
                                 <p>UNSIGNED</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1189 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1189 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1189 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1189 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1189 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1189 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1189 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1189 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1217" headers="d33328e755 ">
                                 <p>VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1217 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1217 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1217 d33328e770 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1217 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1217 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1217 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1217 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1217 d33328e790 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1245" headers="d33328e755 ">
                                 <p>VARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1245 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1245 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1245 d33328e770 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1245 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1245 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1245 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1245 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1245 d33328e790 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1273" headers="d33328e755 ">
                                 <p>VARNUM</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1273 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1273 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1273 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1273 d33328e774 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1273 d33328e778 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1273 d33328e782 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1273 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1273 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d33328e1301" headers="d33328e755 ">
                                 <p>VARRAW</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1301 d33328e762 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1301 d33328e766 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d33328e1301 d33328e770 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1301 d33328e774 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1301 d33328e778 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d33328e1301 d33328e782 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d33328e1301 d33328e786 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d33328e1301 d33328e790 ">
                                 <p>-</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2__GUID-C4253D89-9342-423A-9969-49A5BAB10AB6">
                     <p class="notep1">注意：</p>
                     <p>Pro * C / C ++预编译器不会检查您对主机阵列的使用情况。例如，不进行索引范围检查。</p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">使用方法4</a></li>
                        <li><a href="embedded-PL-SQL.html#GUID-65965251-9158-442D-A69B-D52A33B35E22">存储的PL / SQL和Java子程序</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3417"></a><div class="props_rev_3"><a id="GUID-F20E0407-E9BF-4160-8E75-7CE21CCF5C64" name="GUID-F20E0407-E9BF-4160-8E75-7CE21CCF5C64"></a><h4 id="LNPCC-GUID-F20E0407-E9BF-4160-8E75-7CE21CCF5C64" class="sect4"><span class="enumeration_section">7.5.1</span> ARRAYLEN声明</h4>
                  <div>
                     <p>假设您必须将输入主机数组传递给PL / SQL块进行处理。默认情况下，绑定此类主机阵列时，Pro * C / C ++预编译器将使用其声明的维度。但是，您可能不想处理整个阵列。在这种情况下，您可以使用ARRAYLEN语句指定较小的数组维度。ARRAYLEN将主机数组与主变量相关联，主变量存储较小的维度。语句语法是<a id="d33328e1357" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL ARRAYLEN host_array（dimension）[EXECUTE];</pre><p>其中<span class="italic">dimension</span>是一个4字节的整数主变量， <span class="italic">而不是</span>文字或表达式。
                     </p>
                     <p>EXECUTE是一个可选的关键字。</p>
                     <p>ARRAYLEN语句必须与<span class="italic">host_array</span>和<span class="italic">dimension</span>的声明一起出现，但在其后的某处。您无法在主机阵列中指定偏移量。但是，您可以将C功能用于此目的。以下示例使用ARRAYLEN覆盖名为<span class="italic">bonus</span>的C主机数组的默认维度：</p><pre class="oac_no_warn" dir="ltr">浮动奖金[100]; int维; EXEC SQL ARRAYLEN奖金（维度）; / *填充主机数组* / ...维度= 25; / *设置较小的数组维度* / EXEC SQL EXECUTE DECLARE TYPE NumTabTyp是真实索引表BINARY_INTEGER; median_bonus REAL;功能中位数（num_tab NumTabTyp，n INTEGER）返回实际开始 - 计算中位数END; BEGIN median_bonus：=中位数（：奖金，：维度）; ...结束; END-EXEC;</pre><p>只有25个数组元素传递给PL / SQL块，因为ARRAYLEN将数组从100个元素减少到25个元素。因此，当PL / SQL块被发送到Oracle执行时，会发送一个小得多的主机阵列。这节省了时间，并且在网络环境中减少了网络流量。</p>
                  </div>
               </div><a id="LNPCC3418"></a><div class="props_rev_3"><a id="GUID-71BE5189-C875-4180-8B39-A16887CD27C2" name="GUID-71BE5189-C875-4180-8B39-A16887CD27C2"></a><h4 id="LNPCC-GUID-71BE5189-C875-4180-8B39-A16887CD27C2" class="sect4"><span class="enumeration_section">7.5.2</span>可选关键字EXECUTE</h4>
                  <div>
                     <p>动态SQL方法中使用的主机数组2 EXEC SQL EXECUTE语句可能有两种不同的解释，基于可选关键字EXECUTE的存在与否。</p>
                     <p>默认情况下（如果ARRAYLEN语句中不存在EXECUTE关键字）：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在确定PL / SQL块执行的次数时，会考虑主机阵列。（使用最小数组维度。）</p>
                        </li>
                        <li>
                           <p>主机数组不得绑定到PL / SQL索引表。</p>
                        </li>
                     </ul>
                     <p>如果存在关键字EXECUTE：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>主机数组必须绑定到索引表。</p>
                        </li>
                        <li>
                           <p>PL / SQL块将被执行一次。</p>
                        </li>
                        <li>
                           <p>EXEC SQL EXECUTE语句中指定的所有主机变量都必须</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在ARRAYLEN中指定......执行声明</p>
                              </li>
                              <li>
                                 <p>是标量。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>例如，给定以下PL / SQL过程：</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AS TYPE选项卡是数字表（5）索引由BINARY_INTEGER; PROCEDURE proc1（parm1 tab，parm2 NUMBER，parm3 tab）;结束;</pre><p>以下Pro * C / C ++函数演示了如何使用主机数组来确定给定PL / SQL块的执行次数。在这种情况下，PL / SQL块将被执行3次，导致<code class="codeph">emp</code>表中有3个新行。
                     </p><pre class="oac_no_warn" dir="ltr">func1（）{int empno_arr [5] = {1111,2222,3333,4444,5555}; char * ename_arr [3] = {“MICKEY”，“MINNIE”，“GOOFY”}; char * stmt1 =“BEGIN INSERT INTO emp（empno，ename）VALUES：b1，：b2; END;”; EXEC SQL PREPARE s1 FROM：stmt1; EXEC SQL EXECUTE s1使用：empno_arr，：ename_arr; }</pre><p>以下Pro * C / C ++函数演示了如何通过动态方法2将主机数组绑定到PL / SQL索引表。注意ARRAYLEN的存在......EXECUTE语句，用于EXEC SQL EXECUTE语句中指定的所有主机数组。</p><pre class="oac_no_warn" dir="ltr">func2（）{int ii = 2; int int_tab [3] = {1,2,3}; int dim = 3; EXEC SQL ARRAYLEN int_tab（dim）EXECUTE; char * stmt2 =“begin pkg.proc1（：v1，：v2，：v3）; end;”; EXEC SQL PREPARE s2 FROM：stmt2; EXEC SQL EXECUTE s2使用：int_tab，：ii，：int_tab; }</pre><p>但是，以下Pro * C / C ++函数将导致预编译时警告，因为没有ARRAYLEN ...<code class="codeph">int_arr</code> EXECUTE语句。
                     </p><pre class="oac_no_warn" dir="ltr">func3（）{int int_arr [3]; int int_tab [3] = {1,2,3}; int dim = 3; EXEC SQL ARRAYLEN int_tab（dim）EXECUTE; char * stmt3 =“begin pkg.proc1（：v1，：v2，：v3）; end;”; EXEC SQL PREPARE s3 FROM：stmt3; EXEC SQL EXECUTE s3使用：int_tab，：int_arr，：int_tab; }</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2">使用方法2</a></li>
                           <li><a href="host-arrays.html#GUID-6B57FBAE-0303-41B9-9056-5C20384442B7">主机阵列</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3419"></a><div class="props_rev_3"><a id="GUID-117968E7-E597-4448-AC5D-581BF1361E2C" name="GUID-117968E7-E597-4448-AC5D-581BF1361E2C"></a><h3 id="LNPCC-GUID-117968E7-E597-4448-AC5D-581BF1361E2C" class="sect3"><span class="enumeration_section">7.6</span>嵌入式PL / SQL中的游标用法</h3>
               <div>
                  <p>程序可以同时使用的最大游标数由数据库初始化参数OPEN_CURSORS确定。执行嵌入式PL / SQL块时，一个游标。父光标与整个块相关联，一个光标（子光标）与嵌入式PL / SQL块中的每个SQL语句相关联。父级和子级游标都计入<code class="codeph">OPEN_CURSORS</code>限制。
                  </p>
                  <p>以下计算显示如何确定使用的最大游标数。使用的游标总和不得超过<code class="codeph">OPEN_CURSORS</code> 。</p><pre class="oac_no_warn" dir="ltr">SQL语句游标PL / SQL父游标PL / SQL子游标+ 6个游标用于开销--------------------------正在使用的游标总和</pre><p>如果您的程序超出了<code class="codeph">OPEN_CURSORS</code>强加的限制，Oracle会给您一个错误。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="performance-tuning.html#GUID-989DD868-1723-48B9-B153-0233ED8BA776">嵌入式PL / SQL注意事项</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3420"></a><div class="props_rev_3"><a id="GUID-65965251-9158-442D-A69B-D52A33B35E22" name="GUID-65965251-9158-442D-A69B-D52A33B35E22"></a><h3 id="LNPCC-GUID-65965251-9158-442D-A69B-D52A33B35E22" class="sect3"><span class="enumeration_section">7.7</span>存储的PL / SQL和Java子程序</h3>
               <div>
                  <p>与匿名块不同，PL / SQL子程序（过程和函数）和Java方法可以单独编译，存储在Oracle数据库中，然后调用。</p>
                  <p>使用Oracle工具（如SQL * Plus）显式创建的子程序称为<span class="italic">存储</span>子程序。一旦编译并存储在数据字典中，它就是一个数据库对象，可以在不重新编译的情况下重新执行。<a id="d33328e1520" class="indexterm-anchor"></a></p>
                  <p>当PL / SQL块或存储过程中的子程序由应用程序发送到Oracle时，它称为<span class="italic">内联</span>子程序。Oracle编译内联子程序并将其缓存在系统全局区域（SGA）中，但不将源代码或目标代码存储在数据字典中。<a id="d33328e1529" class="indexterm-anchor"></a></p>
                  <p>程序包中定义的子程序被视为程序包的一部分，因此称为<span class="italic">打包的</span>子程序。未在包中定义的存储子程序称为<span class="italic">独立</span>子程序。 <a id="d33328e1539" class="indexterm-anchor"></a> 
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../jjdev/Java-applications-in-database.html#JJDEV-GUID-E7EEC053-2CAC-4A5D-8C90-EBFD047D32F7" target="_blank"><span class="italic">Oracle数据库上的Java应用程序</span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3421"></a><div class="props_rev_3"><a id="GUID-90FFC7F7-C299-48BF-BFB1-A7850F46D486" name="GUID-90FFC7F7-C299-48BF-BFB1-A7850F46D486"></a><h4 id="LNPCC-GUID-90FFC7F7-C299-48BF-BFB1-A7850F46D486" class="sect4"><span class="enumeration_section">7.7.1</span>关于创建存储的子程序</h4>
                  <div>
                     <p>您可以在宿主程序中嵌入SQL语句CREATE FUNCTION，CREATE PROCEDURE和CREATE PACKAGE，如以下示例所示：<a id="d33328e1561" class="indexterm-anchor"></a><a id="d33328e1565" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE FUNCTION sal_ok（salary REAL，title CHAR）RETURN BOOLEAN as min_sal REAL; max_sal REAL; BEGIN SELECT losal，hisal INTO min_sal，max_sal FROM sals WHERE job = title;返回（工资&gt; = min_sal）AND（工资&lt;= max_sal）;结束sal_ok; END-EXEC;</pre><p>请注意嵌入的CREATE {FUNCTION |程序| PACKAGE}语句是混合语句。与所有其他嵌入式CREATE语句一样，它以关键字EXEC SQL（不是EXEC SQL EXECUTE）开头。但是，与其他嵌入式CREATE语句不同，它以PL / SQL终止符END-EXEC结束。</p>
                     <p>在稍后的示例中，您将创建一个包含名为<span class="italic">get_employees</span>的过程的包，该过程从EMP表中提取一批行。批量大小由过程的调用者确定，该调用者可能是另一个存储的子程序或客户端应用程序。
                     </p>
                     <p>该过程将三个PL / SQL表声明为OUT形式参数，然后将一批员工数据提取到PL / SQL表中。匹配的实际参数是主机阵列。该过程完成后，它会自动将PL / SQL表中的所有行值分配给主机阵列中的相应元素。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE或REPLACE PACKAGE emp_actions AS TYPE CharArrayTyp IS TABLE OF VARCHAR2（10）INDEX BY BINARY_INTEGER; TYPE NumArrayTyp是BINARY_INTEGER的FLOAT INDEX表;程序get_employees（dept_number IN INTEGER，batch_size IN INTEGER，找到IN OUT INTEGER，done_fetch OUT INTEGER，emp_name OUT CharArrayTyp，job_title OUT CharArrayTyp，salary OUT NumArrayTyp）; END emp_actions; END-EXEC; EXEC SQL CREATE或REPLACE PACKAGE BODY emp_actions AS CURSOR get_emp（dept_number IN INTEGER）是SELECT ename，job，sal FROM emp WHERE deptno = dept_number;程序get_employees（dept_number IN INTEGER，batch_size IN INTEGER，找到IN OUT INTEGER，done_fetch OUT INTEGER，emp_name OUT CharArrayTyp，job_title OUT CharArrayTyp，salary OUT NumArrayTyp）如果不是get_emp％ISOPEN则打开get_emp（dept_number）;万一; done_fetch：= 0;发现：= 0; FOR i IN 1..batch_size LOOP FETCH get_emp INTO emp_name（i），job_title（i），salary（i）;如果get_emp％NOTFOUND那么关闭get_emp; done_fetch：= 1;出口; ELSE发现：=找到+ 1;万一;结束循环; END get_employees; END emp_actions; END-EXEC;</pre><p>您在CREATE语句中指定REPLACE子句以重新定义现有包，而不必删除包，重新创建它，并重新授予它。有关CREATE语句的完整语法，请参阅<a href="../sqlrf/SQL-Statements-COMMIT-to-CREATE-JAVA.html#SQLRF-GUID-A087EE75-DE65-4AA6-A479-280413DB74C8" target="_blank">SQL语句：COMMIT to CREATE JAVA</a> 。</p>
                     <p>如果是嵌入式CREATE {FUNCTION |程序| PACKAGE}语句失败，Oracle生成警告，而不是错误。</p>
                  </div>
               </div><a id="LNPCC3422"></a><div class="props_rev_3"><a id="GUID-F20A70DA-AF53-41CB-82CA-D2DA5B77E4A5" name="GUID-F20A70DA-AF53-41CB-82CA-D2DA5B77E4A5"></a><h4 id="LNPCC-GUID-F20A70DA-AF53-41CB-82CA-D2DA5B77E4A5" class="sect4"><span class="enumeration_section">7.7.2</span>关于调用存储的PL / SQL或Java子程序</h4>
                  <div>
                     <div class="section">
                        <p>要从宿主程序中调用存储的子程序，可以使用匿名PL / SQL块或CALL嵌入式SQL语句。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3423"></a><div class="props_rev_3"><a id="GUID-50FAE0D7-E6EB-48FE-9440-A88FA27E8C34" name="GUID-50FAE0D7-E6EB-48FE-9440-A88FA27E8C34"></a><h5 id="LNPCC-GUID-50FAE0D7-E6EB-48FE-9440-A88FA27E8C34" class="sect5"><span class="enumeration_section">7.7.2.1</span>匿名PL / SQL块</h5>
                     <div>
                        <p>在以下示例中，您将调用名为<span class="italic">raise_salary</span>的独立过程： <a id="d33328e1617" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE BEGIN raise_salary（：emp_id，：increase）;结束; END-EXEC;</pre><p>请注意，存储的子程序可以采用参数。在此示例中，实际参数<span class="italic">emp_id</span>和<span class="italic">increase</span>是C主变量。
                        </p>
                        <p>在下一个示例中，过程<span class="italic">raise_salary</span>存储在名为<span class="italic">emp_actions</span>的包中，因此必须使用点表示法来完全限定过程调用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE BEGIN emp_actions.raise_salary（：emp_id，：increase）;结束; END-EXEC;</pre><p>实际的IN参数可以是文字，标量主变量，主机数组，PL / SQL常量或变量，PL / SQL表，PL / SQL用户定义记录，过程调用或表达式。但是，实际的OUT参数不能是文字，过程调用或表达式。</p>
                        <p>必须将预编译器选项SQLCHECK = SEMANTICS与嵌入式PL / SQL块一起使用。</p>
                        <p>在以下示例中，三个形式参数是PL / SQL表，相应的实际参数是主机数组。程序重复调用存储过程<span class="italic">get_employees</span> ，显示每批员工数据，直到找不到更多数据。该程序可在<code class="codeph">demo</code>目录中的<code class="codeph">sample9.pc</code>文件中<code class="codeph">sample9.pc</code> 。一个SQL脚本来创建存储CALLDEMO包是在文件中提供<code class="codeph">calldemo.sql</code> 。 <a id="d33328e1660" class="indexterm-anchor"></a><a id="d33328e1664" class="indexterm-anchor"></a><a id="d33328e1669" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">/ ******************* ************示例程序9：调用存储过程该程序使用SCOTT / TIGER帐户连接到ORACLE。程序声明了几个主机数组，然后调用填充表OUT参数的PL / SQL存储过程（CALLDEMO包中的GET_EMPLOYEES）。PL / SQL过程返回ASIZE值。Sample9不断调用GET_EMPLOYEES，每次都获取ASIZE数组，并打印值，直到检索完所有行。GET_EMPLOYEES设置done_flag以指示“不再有数据”。 ************************************************** *********** / #include &lt;stdio.h&gt; #include &lt;string.h&gt; EXEC SQL INCLUDE sqlca.h; typedef char asciz [20]; typedef char vc2_arr [11]; EXEC SQL BEGIN DECLARE SECTION; / *以null结尾的字符串的用户定义类型* / EXEC SQL TYPE asciz IS STRING（20）REFERENCE; / * VARCHAR数组元素的用户定义类型。* / EXEC SQL TYPE vc2_arr IS VARCHAR2（11）参考; asciz用户名; asciz密码; int dept_no; / *哪个部门要查询？* / vc2_arr emp_name [10]; / *返回名称数组* / vc2_arr job [10];浮动工资[10]; int done_flag; int array_size; int num_ret; / *返回的行数* / EXEC SQL END DECLARE SECTION;长SQLCODE; void print_rows（）; / *产生程序输出* / void sql_error（）; / *处理不可恢复的错误* / main（）{int i; char temp_buf [32]; / *连接到ORACLE。 * / EXEC SQL WHENEVER SQLERROR DO sql_error（）; strcpy（用户名，“scott”）; strcpy（密码，“老虎”）; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; printf（“\ n以用户身份连接到ORACLE：％s \ n \ n”，用户名）; printf（“输入部门编号：”）;得到（temp_buf）; dept_no = atoi（temp_buf）; / *打印列标题。* / printf（“\ n \ n”）; printf（“％ -  10.10s％-10.10s％s \ n”，“员工”，“工作”，“薪水”）; printf（“％ -  10.10s％-10.10s％s \ n”，“--------”，“---”，“------”）; / *设置数组大小。* / array_size = 10; done_flag = 0; num_ret = 0; / *数组获取循环。*循环继续，直到OUT参数done_flag被设置。*传入部门编号，数组大小 -  *获取姓名，工作和工资。* / for（;;）{EXEC SQL EXECUTE BEGIN calldemo.get_employees（：dept_no，：array_size，：num_ret，：done_flag，：emp_name，：job，：salary）;结束; END-EXEC; print_rows（num_ret）;如果（done_flag）中断; } / *断开与数据库的连接。* / EXEC SQL COMMIT WORK RELEASE;出口（0）; } void print_rows（n）int n; {int i; if（n == 0）{printf（“没有检索到的行。\ n”）;返回; } for（i = 0; i &lt;n; i ++）printf（“％10.10s％10.10s％6.2f \ n”，emp_name [i]，job [i]，salary [i]）; } / *处理错误。退出任何错误。* / void sql_error（）{char msg [512]; int buf_len，msg_len; EXEC SQL WHENEVER SQLERROR CONTINUE; buf_len = sizeof（msg）; sqlglm（msg，＆buf_len，＆msg_len）; printf（“检测到\ nORACLE错误：”）; printf（“\ n％。* s \ n”，msg_len，msg）; EXEC SQL ROLLBACK工作版;出口（1）; }</pre><p>请记住，每个实际参数的数据类型必须可以转换为其相应形式参数的数据类型。此外，在退出存储过程之前，必须为所有OUT形式参数分配值。否则，相应的实际参数的值是不确定的。</p>
                        <p>使用匿名PL / SQL块时需要SQLCHECK = SEMANTICS。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-PL-SQL.html#GUID-90FFC7F7-C299-48BF-BFB1-A7850F46D486">关于创建存储的子程序</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC3424"></a><div class="props_rev_3"><a id="GUID-563E1A04-F241-4617-AA62-AC3E75377A00" name="GUID-563E1A04-F241-4617-AA62-AC3E75377A00"></a><h5 id="LNPCC-GUID-563E1A04-F241-4617-AA62-AC3E75377A00" class="sect5"><span class="enumeration_section">7.7.2.2</span>远程访问</h5>
                     <div>
                        <p>PL / SQL允许您使用<span class="italic">数据库链接</span>访问远程数据库。通常，数据库链接由DBA建立并存储在Oracle数据字典中。数据库链接告诉Oracle远程数据库的位置，路径，以及要使用的Oracle用户名和密码。在以下示例中，您使用数据库链接<span class="italic">dallas</span>来调用<span class="italic">raise_salary</span>过程：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE BEGIN raise_salary @dallas（：emp_id，：increase）;结束; END-EXEC;</pre><p>您可以创建同义词以提供远程子程序的位置透明度，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">CREATE PUBLIC SYNONYM raise_salary FOR raise_salary @dallas;</pre></div>
                  </div><a id="LNPCC3425"></a><div class="props_rev_3"><a id="GUID-034F0DCE-9061-4DAA-9941-6E2E543C0F34" name="GUID-034F0DCE-9061-4DAA-9941-6E2E543C0F34"></a><h5 id="LNPCC-GUID-034F0DCE-9061-4DAA-9941-6E2E543C0F34" class="sect5"><span class="enumeration_section">7.7.2.3</span> CALL声明</h5>
                     <div>
                        <p>前面介绍的嵌入式PL / SQL块的概念也适用于CALL语句。CALL嵌入式SQL语句具有以下形式：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CALL [schema。] [package。] stored_proc [@db_link]（arg1，...）[INTO：ret_var [[INDICATOR]：ret_ind]];</pre><p>哪里</p>
                        <p>模式</p>
                        <p>包含该过程的模式</p>
                        <p>包</p>
                        <p>包含程序的包</p>
                        <p>stored_proc</p>
                        <p>是要调用的Java或PL / SQL存储过程</p>
                        <p>db_link</p>
                        <p>是可选的远程数据库链接</p>
                        <p>ARG1 ...</p>
                        <p>是传递的参数（变量，文字或表达式）的列表，</p>
                        <p>ret_var</p>
                        <p>是接收结果的可选主变量</p>
                        <p>ind_var</p>
                        <p>ret_var的可选指示符变量。</p>
                        <p>您可以使用SQLCHECK = SYNTAX或SEMANTICS与CALL语句。</p>
                     </div>
                  </div><a id="LNPCC3426"></a><div class="props_rev_3"><a id="GUID-E828F0DF-6DFF-489D-953C-078654DFECEF" name="GUID-E828F0DF-6DFF-489D-953C-078654DFECEF"></a><h5 id="LNPCC-GUID-E828F0DF-6DFF-489D-953C-078654DFECEF" class="sect5"><span class="enumeration_section">7.7.2.4</span> CALL示例</h5>
                     <div>
                        <p>如果您已经创建了一个PL / SQL函数<code class="codeph">fact</code> （保存在包装<code class="codeph">mathpkg</code> ），其采用整数作为输入和一个整数返回其阶乘：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE或REPLACE PACKAGE BODY mathpkg as function fact（n IN INTEGER）RETURN INTEGER as BEGIN IF（n &lt;= 0）然后返回1; ELSE返回n * fact（n  -  1）;万一;结论;结束mathpkge; END-EXEC。</pre><p>然后使用CALL语句在Pro * C / C ++应用程序中使用<code class="codeph">fact</code> ：</p><pre class="oac_no_warn" dir="ltr">...int num，fact; ...EXEC SQL CALL mathpkge.fact（：num）INTO：fact; ...
</pre><div class="infoboxnotealso" id="GUID-E828F0DF-6DFF-489D-953C-078654DFECEF__GUID-CFAAEAA5-3C2C-45BA-A279-95753BFEC767">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="embedded-SQL-statements-and-directives.html#GUID-F28B8E6F-1CF5-49D1-86F4-13CD01475BB1">CALL（可执行嵌入式SQL）</a> ”</span>以获取有关CALL语句的更多信息。
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../adfns/index.html" target="_blank"><span class="italic">Oracle数据库高级应用程序开发人员指南</span></a> ，有关传递参数和其他问题的完整说明。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCC3427"></a><div class="props_rev_3"><a id="GUID-57F71170-7A70-4938-9F1F-F3B6DFEA88A3" name="GUID-57F71170-7A70-4938-9F1F-F3B6DFEA88A3"></a><h4 id="LNPCC-GUID-57F71170-7A70-4938-9F1F-F3B6DFEA88A3" class="sect4"><span class="enumeration_section">7.7.3</span>关于获取存储子程序的信息</h4>
                  <div>
                     <div class="infoboxnote" id="GUID-57F71170-7A70-4938-9F1F-F3B6DFEA88A3__GUID-02B7881D-07F3-463B-91C2-8C19964E34E6">
                        <p class="notep1">注意：</p>
                        <p>Oracle <span class="italic">不再支持</span>登录数据区（LDA）。在Pro * C / C ++程序中嵌入OCI Release 7调用的能力将在下一个主要的Oracle版本中逐步淘汰。
                        </p>
                     </div>
                     <p><a href="datatypes-and-host-variables.html#GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC">数据类型和主机变量</a>描述了如何在主机程序中嵌入OCI调用。在调用库例程SQLLDA以设置LDA之后，使用OCI调用<span class="italic">odessp</span>获取有关存储的子程序的有用信息。当你调用<span class="italic">odessp时</span> ，你必须传递一个有效的LDA和子程序的名称。对于打包的子程序，还必须传递包的名称。 <span class="italic">odessp</span>返回有关每个子程序参数的信息，例如其数据类型，大小，位置等。
                     </p>
                     <p>您还可以在DBMS_DESCRIBE包中使用DESCRIBE_PROCEDURE存储过程。</p>
                  </div>
               </div>
            </div><a id="LNPCC3428"></a><div class="props_rev_3"><a id="GUID-2191B843-36C4-4936-B0F5-97AB0AB8CDEA" name="GUID-2191B843-36C4-4936-B0F5-97AB0AB8CDEA"></a><h3 id="LNPCC-GUID-2191B843-36C4-4936-B0F5-97AB0AB8CDEA" class="sect3"><span class="enumeration_section">7.8</span>外部程序</h3>
               <div>
                  <p>PL / SQL可以调用外部过程的C函数。外部过程（也称为外部过程）存储在动态链接库（DLL）中，或者存储在Solaris下的<span class="italic">.so</span>库中。
                  </p>
                  <p>如果外部过程在服务器端执行，它可以回调到服务器以在同一事务中执行SQL和PL / SQL。服务器上的外部过程执行速度快于客户端，并且可以将数据库服务器与外部系统和数据源连接。</p>
                  <p>为了执行服务器端外部C函数，必须在该函数内使用REGISTER CONNECT嵌入式SQL语句。该语句的语法是：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL REGISTER连接使用：epctx [RETURNING：host_context];</pre><p>其中<code class="codeph">epctx</code>是外部过程上下文（指向<code class="codeph">OCIExtProcContext</code>的类型指针）。 <code class="codeph">epctx</code>通过PL / SQL传递给过程。</p>
                  <p><code class="codeph">host_context</code>是外部过程返回的运行时上下文。目前，它是默认（全局）上下文。
                  </p>
                  <p>REGISTER CONNECT语句将返回与当前Oracle连接和事务关联的OCI句柄集（OCIEnv，OCISvcCtx和OCIError）。然后，这些句柄用于为全局SQLLIB运行时上下文定义Pro * C / C ++默认的未命名连接。因此，使用REGISTER CONNECT语句<span class="italic">而不是</span> CONNECT语句。
                  </p>
                  <p>后续嵌入式SQL语句将使用这组OCI句柄。它们针对全局SQLLIB运行时上下文和未命名的连接执行，即使是那些处于单独预编译单元中的连接。未见未提交的更改。将来，可以在可选的RETURNING子句中返回（非默认）运行时上下文。</p>
                  <p>全局运行时上下文不能存在任何活动的默认连接。如果在连接已存在时尝试使用REGISTER CONNECT，则会返回运行时错误。</p>
                  <p>在实际情况中，外部过程应该是可以从许多不同应用程序重用的过程。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../lnoci/index.html" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3429"></a><div class="props_rev_3"><a id="GUID-1FC8608C-A8FD-4801-BC99-0AEC2DA1470C" name="GUID-1FC8608C-A8FD-4801-BC99-0AEC2DA1470C"></a><h4 id="LNPCC-GUID-1FC8608C-A8FD-4801-BC99-0AEC2DA1470C" class="sect4"><span class="enumeration_section">7.8.1</span>对外部程序的限制</h4>
                  <div>
                     <p>遵循这些外部程序规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>外部过程只能在C中。不支持C ++外部过程。</p>
                        </li>
                        <li>
                           <p>连接到外部过程上下文时，不允许任何其他连接，从而导致运行时错误。</p>
                        </li>
                        <li>
                           <p>不支持多线程外部过程。不允许执行EXEC SQL ENABLE THREADS语句，并且将返回运行时错误。Pro * C / C ++确实支持不使用我们描述的外部过程方法的应用程序中的多线程。</p>
                        </li>
                        <li>
                           <p>您不能使用DDL语句。它们会导致运行时错误。</p>
                        </li>
                        <li>
                           <p>您不能使用事务控制语句，例如EXEC SQL COMMIT和EXEC SQL ROLLBACK。</p>
                        </li>
                        <li>
                           <p>您不能使用对象导航语句，例如EXEC SQL OBJECT ....</p>
                        </li>
                        <li>
                           <p>您不能使用轮询EXEC SQL LOB语句。</p>
                        </li>
                        <li>
                           <p>您不能使用EXEC TOOLS语句。它们将导致运行时错误。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3430"></a><div class="props_rev_3"><a id="GUID-3AA95FAE-B30C-4AB8-8AD8-EA6D6DC69828" name="GUID-3AA95FAE-B30C-4AB8-8AD8-EA6D6DC69828"></a><h4 id="LNPCC-GUID-3AA95FAE-B30C-4AB8-8AD8-EA6D6DC69828" class="sect4"><span class="enumeration_section">7.8.2</span>关于创建外部过程</h4>
                  <div>
                     <p>这是一个创建外部过程<code class="codeph">extp1</code>的简单示例。
                     </p>
                     <p>要存储外部C过程，请编译代码并将其链接到DLL等库。</p>
                     <p>参考NT删除了用户评论9561</p>
                     <p>然后使用以下SQL命令注册外部过程<code class="codeph">extp1</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换程序extp1作为外部名称“extp1”具有上下文参数的LIBRARY mylib（上下文）;</pre><p>其中<span class="italic">mylib</span>是存储过程<span class="italic">extp1</span>的库的名称。WITH CONTEXT表示使用类型为<code class="codeph">OCIExtProcContext*</code>参数隐式调用此过程。您的调用中省略了上下文，但无论如何都会传递给过程。但是，关键字CONTEXT显示在CREATE语句中，作为位置标记。
                     </p>
                     <p>此上下文参数是<code class="codeph">extp1</code> EXEC SQL REGISTER CONNECT语句中引用的参数。
                     </p>
                     <p>以这种方式从SQL * Plus调用外部过程：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; BEGIN INSERT INTO emp VALUES（9999，'JOHNSON'，'SALESMAN'，7782，sysdate，1200,150,10）; extp1;结束;</pre><p><a id="d33328e2009" class="indexterm-anchor"></a>这是<code class="codeph">extp1.pc</code>的列表：</p><pre class="oac_no_warn" dir="ltr">void extp1（epctx）OCIExtProcContext * epctx; {char name [15]; EXEC SQL REGISTER连接使用：epctx;执行SQL WHENEVER SQLERROR转到错误; EXEC SQL SELECT ename INTO：name FROM emp WHERE empno = 9999;返回;错误：SQLExtProcError（SQL_SINGLE_RCTX，sqlca.sqlerrm.sqlerrmc，sqlca.sqlerrm.sqlerrml）;返回; }</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../lnpls/plsql-subprograms.html#LNPLS-GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8" target="_blank"><span class="italic">外部子程序</span></a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCC3431"></a><div class="props_rev_3"><a id="GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF" name="GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF"></a><h4 id="LNPCC-GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF" class="sect4"><span class="enumeration_section">7.8.3</span> SQLExtProcError（）</h4>
                  <div>
                     <p>SQLLIB函数<code class="codeph">SQLExtProcError()</code>提供了在外部C过程中发生错误时将控制权返回给PL / SQL的功能。函数及其参数是：</p>
                     <p>SQLExtProcError（ctx，msg，msglen）</p>
                     <p>哪里：</p>
                     <p>ctx（IN）sql_context *</p>
                     <p>这是REGISTER CONNECT语句的目标SQLLIB运行时上下文，必须在调用此函数之前执行。现在只支持全局运行时上下文。</p>
                     <p>msg（OUT）字符*</p>
                     <p>错误消息的文本。</p>
                     <p>msglen（OUT）size_t</p>
                     <p>消息的字节长度。</p>
                     <p>执行此函数时，SQLLIB调用OCI服务函数OCIExtProcRaiseExcpWithMsg。</p>
                     <p>该消息来自SQLCA中的结构<code class="codeph">sqlerrm</code> 。</p>
                     <p>这是一个显示<code class="codeph">SQLExtProcError()</code>使用的<code class="codeph">SQLExtProcError()</code> ：</p><pre class="oac_no_warn" dir="ltr">void extp1（epctx）OCIExtProcContext * epctx; {char name [15]; EXEC SQL REGISTER连接使用：epctx;执行SQL WHENEVER SQLERROR转到错误; EXEC SQL SELECT ename INTO：name FROM emp WHERE smpno = 9999;返回;错误：SQLExtProcError（SQL_SINGLE_RCTX，sqlca.sqlerrm.sqlerrmc，sqlca.sqlerrm.sqlerrml）; printf（“\ n％* s \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）;返回; }</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="handling-run-time-errors.html#GUID-08A1E4F0-7B6F-4166-BB8C-E9F23F6C355E">SQLCA结构</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3432"></a><div class="props_rev_3"><a id="GUID-A147B827-C733-47AD-944F-BEA87FC7CAD3" name="GUID-A147B827-C733-47AD-944F-BEA87FC7CAD3"></a><h3 id="LNPCC-GUID-A147B827-C733-47AD-944F-BEA87FC7CAD3" class="sect3"><span class="enumeration_section">7.9</span>关于使用动态SQL</h3>
               <div>
                  <p>回想一下，预编译器将整个PL / SQL块视为单个SQL语句。因此，您可以将PL / SQL块存储在字符串主变量中。然后，如果块不包含主机变量，则可以使用动态SQL方法1来执行PL / SQL字符串。或者，如果块包含已知数量的主机变量，则可以使用动态SQL方法2来PREPARE和EXECUTE PL / SQL字符串。如果块包含未知数量的主机变量，则必须使用动态SQL方法4。</p>
                  <div class="infoboxnote" id="GUID-A147B827-C733-47AD-944F-BEA87FC7CAD3__GUID-CCBA43F3-B71D-4C2E-B2E5-7D266E17B50C">
                     <p class="notep1">注意：</p>
                     <p>在动态SQL方法4中，您无法使用类型为“table”的参数将主机数组绑定到PL / SQL过程。</p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        <li><a href="Oracle-dynamic-SQL.html#GUID-3B9E253A-F03D-431D-A77E-84C02C43F494">Oracle动态SQL</a></li>
                        <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                        <li><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">使用方法4</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html><html id="04883.precompiler-concepts.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>预编译器概念</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="introduction.html" title="Previous" type="text/html"></link>
      <link rel="next" href="database-concepts.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="database-concepts.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">预编译器概念</li>
            </ol>
            <a id="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" name="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D"></a><a id="LNPCB002"></a>
            
            <h2 id="LNPCB-GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" class="sect2"><span class="enumeration_chapter">2</span>预编译器概念</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍嵌入式SQL程序如何完成其工作。它介绍了重要单词的定义，基本概念的解释和关键规则。</p>
               <p>涉及的主题是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8">嵌入式SQL编程的关键概念</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3">编程指南</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C01E658A-1EAE-4497-82DB-347217694E78">申报部分</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-A0BFB23E-4234-409F-906A-3185E866F7BC">嵌套程序</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0">条件预编译</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153">单独的预编译</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC">编译和链接</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA">样本DEPT和EMP表</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D">样本EMP计划：SAMPLE1。PCO</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB126"></a><div class="props_rev_3"><a id="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" name="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8"></a><h3 id="LNPCB-GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" class="sect3"><span class="enumeration_section">2.1</span>嵌入式SQL编程的关键概念</h3>
               <div>
                  <p>本节为后面的章节构建了概念基础。<a id="d7799e94" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB128"></a><a id="LNPCB127"></a><div class="props_rev_3"><a id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869" name="GUID-E7AE6605-2B20-49C4-90C6-173567C42869"></a><h4 id="LNPCB-GUID-E7AE6605-2B20-49C4-90C6-173567C42869" class="sect4"><span class="enumeration_section">2.1.1</span>开发嵌入式SQL应用程序的步骤</h4>
                  <div>
                     <p>预编译会生成可以正常编译的源文件。虽然预编译为传统开发过程增加了一个步骤，但这一步非常值得，因为它可以让您编写非常灵活的应用程序。</p>
                     <p><a href="precompiler-concepts.html#GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">图2-1</a>引导您完成嵌入式SQL应用程序开发过程：</p>
                     <div class="figure" id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">
                        <p class="titleinfigure">图2-1应用程序开发过程</p><img src="img/pco81050.gif" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/pco81050.html"><br><a href="img_text/pco81050.html">“图2-1应用程序开发过程”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPCB129"></a><div class="props_rev_3"><a id="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" name="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013"></a><h4 id="LNPCB-GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" class="sect4"><span class="enumeration_section">2.1.2</span>嵌入式SQL语句</h4>
                  <div>
                     <p>术语<span class="italic">嵌入式SQL</span>是指放置在应用程序中的SQL语句。因为应用程序包含SQL语句，所以它被称为<span class="italic">宿主程序</span> ，其编写<span class="italic">语言</span>称为<span class="italic">宿主语言</span> 。例如，使用Pro * COBOL，您可以在COBOL主机程序中嵌入SQL语句。 <a id="d7799e168" class="indexterm-anchor"></a><a id="d7799e170" class="indexterm-anchor"></a> 
                     </p>
                     <p>要操作和查询Oracle数据，请使用INSERT，UPDATE，DELETE和SELECT语句。INSERT向数据库表添加数据行，UPDATE修改行，DELETE删除不需要的行，SELECT检索符合搜索条件的行。</p>
                     <p>只有SQL语句 - 而不是SQL * Plus语句 - 在应用程序中才有效。（SQL * Plus具有用于设置环境参数，编辑和报告格式的其他语句。）</p>
                  </div><a id="LNPCB131"></a><a id="LNPCB130"></a><div class="props_rev_3"><a id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" name="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331"></a><h5 id="LNPCB-GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" class="sect5"><span class="enumeration_section">2.1.2.1</span>可执行语句与声明语句</h5>
                     <div>
                        <p>嵌入式SQL包括所有交互式SQL语句以及允许您在Oracle和宿主程序之间传输数据的其他语句。嵌入式SQL语句有两种类型： <span class="italic">可执行语句</span>和<span class="italic">指令</span> 。
                        </p>
                        <p>可执行SQL语句生成对数据库的调用。它们包括几乎所有查询，数据操作语言（DML），数据定义语言（DDL）和数据控制语言（DCL）语句。</p>
                        <p>另一方面， <span class="italic">指令</span>不会导致对SQLLIB的调用，也不会对Oracle数据进行操作。
                        </p>
                        <p><a id="d7799e215" class="indexterm-anchor"></a><a id="d7799e219" class="indexterm-anchor"></a>您可以使用指令声明Oracle对象，通信区域和SQL变量。它们可以放在可以放置COBOL声明的任何位置。 <a id="d7799e224" class="indexterm-anchor"></a> 
                        </p>
                        <p><a href="precompiler-concepts.html#GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502" title="该表列出了指令及其用途">表2-1</a>列出了嵌入式SQL语句的一些示例（不是完整列表。）
                        </p>
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502">
                           <p class="titleintable">表2-1嵌入式SQL语句 - 指令</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="嵌入式SQL语句 - 指令" width="100%" border="1" summary="This table lists directives and their purposes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d7799e243">声明</th>
                                    <th align="left" valign="bottom" width="69%" id="d7799e247">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e253" headers="d7799e243 ">
                                       <p>ARRAYLEN *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e253 d7799e247 ">
                                       <p>将主机表与PL / SQL一起使用</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e260" headers="d7799e243 ">
                                       <p>开始声明部分*</p>
                                       <p>END DECLARE SECTION *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e260 d7799e247 ">
                                       <p>声明宿主变量</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e269" headers="d7799e243 ">
                                       <p>宣布*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e269 d7799e247 ">
                                       <p>命名Oracle对象</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e276" headers="d7799e243 ">
                                       <p>包括*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e276 d7799e247 ">
                                       <p>复制文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e283" headers="d7799e243 ">
                                       <p>VAR *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e283 d7799e247 ">
                                       <p>对等价变量</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e290" headers="d7799e243 ">
                                       <p>每当*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e290 d7799e247 ">
                                       <p>处理运行时错误</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__EMBEDDEDSQLSTATEMENTSEXECUTABLESQL-040CB223">
                           <p class="titleintable">表2-2嵌入式SQL语句 - 可执行SQL</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="嵌入式SQL语句 - 可执行SQL" width="100%" border="1" summary="This table lists executable SQL statements and their purposes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d7799e306">声明</th>
                                    <th align="left" valign="bottom" width="20%" id="d7799e309">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e314" headers="d7799e306 ">
                                       <p>分配*</p>
                                       <p>改变</p>
                                       <p>CONNECT *</p>
                                       <p>创建</p>
                                       <p>下降</p>
                                       <p>GRANT</p>
                                       <p>NOAUDIT</p>
                                       <p>改名</p>
                                       <p>撤消</p>
                                       <p>截短</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e314 d7799e309 ">
                                       <p>定义和控制Oracle数据</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e339" headers="d7799e306 ">
                                       <p>关*</p>
                                       <p>删除</p>
                                       <p>解释计划</p>
                                       <p>取*</p>
                                       <p>插入</p>
                                       <p>锁表</p>
                                       <p>打开*</p>
                                       <p>选择</p>
                                       <p>UPDATE</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e339 d7799e309 ">
                                       <p>查询和操作Oracle数据</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e362" headers="d7799e306 ">
                                       <p>承诺</p>
                                       <p>ROLLBACK</p>
                                       <p>SAVEPOINT</p>
                                       <p>设置交易</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e362 d7799e309 ">
                                       <p>处理交易</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e375" headers="d7799e306 ">
                                       <p>描述*</p>
                                       <p>执行*</p>
                                       <p>准备*</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e375 d7799e309 ">
                                       <p>要使用动态SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e386" headers="d7799e306 ">
                                       <p>改变会话</p>
                                       <p>设置角色</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e386 d7799e309 ">
                                       <p>控制会话</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>*没有互动对手</p>
                        <div class="infoboxnotealso" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__GUID-285354C6-E895-4238-A0CC-563F33B25C43">
                           <p class="notep1">也可以看看：</p><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-F5251483-48EC-4B39-8E14-68F65480B16B">嵌入式SQL语句和预编译器指令</a>包含最重要的语句和指令的表示。
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB135"></a><div class="props_rev_3"><a id="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" name="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE"></a><h4 id="LNPCB-GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" class="sect4"><span class="enumeration_section">2.1.3</span>嵌入式SQL语法</h4>
                  <div>
                     <p>在应用程序中，您可以自由地将SQL语句与主机语言语句混合，并在SQL语句中使用主机语言变量。将SQL语句构建到宿主程序中的唯一特殊要求是，您可以使用EXEC SQL开头，并以令牌END-EXEC结束它们。 Pro * COBOL将所有可执行的EXEC SQL语句转换为对运行时库SQLLIB的调用。 <a id="d7799e426" class="indexterm-anchor"></a><a id="d7799e430" class="indexterm-anchor"></a><a id="d7799e434" class="indexterm-anchor"></a><a id="d7799e436" class="indexterm-anchor"></a> 
                     </p>
                     <p>大多数嵌入式SQL语句与其交互式对应语句的区别仅在于添加了新子句或使用了程序变量。比较以下交互式和嵌入式ROLLBACK语句： <a id="d7799e441" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">ROLLBACK WORK; - 交互式*嵌入式EXEC SQL ROLLBACK WORK END-EXEC。</pre><p>句点或任何其他终止符可以遵循SQL语句。允许以下任一情况：</p><pre class="oac_no_warn" dir="ltr">执行SQL ...END-EXEC，EXEC SQL ......END-EXEC。</pre></div>
               </div><a id="LNPCB136"></a><div class="props_rev_3"><a id="GUID-D0456446-014D-4569-AD48-BCCB0E54169A" name="GUID-D0456446-014D-4569-AD48-BCCB0E54169A"></a><h4 id="LNPCB-GUID-D0456446-014D-4569-AD48-BCCB0E54169A" class="sect4"><span class="enumeration_section">2.1.4</span>静态与动态SQL语句</h4>
                  <div>
                     <p>大多数应用程序旨在处理<span class="italic">静态</span> SQL <span class="italic"> </span>报表和固定交易。在这种情况下，您知道运行时之前每个SQL语句和事务的组成。也就是说，您知道将发出哪些SQL命令，哪些数据库表可能会更改，哪些列将更新，等等。 <a id="d7799e482" class="indexterm-anchor"></a><a id="d7799e486" class="indexterm-anchor"></a> 
                     </p>
                     <p>但是，某些应用程序需要在运行时接受和处理任何有效的SQL语句。在这种情况下，您可能直到运行时才知道所涉及的所有SQL命令，数据库表和列。</p>
                     <p><span class="italic">动态</span> SQL是一种高级编程技术，它允许程序在运行时接受或构建SQL语句，并对数据类型转换进行显式控制。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC">嵌入式SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-C325218F-3DFF-4551-A5EB-483ADB24E324">Oracle动态SQL</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-D6E9ACBE-EFF4-42F6-A855-B510004F4164">ANSI动态SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle动态SQL：方法4</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB137"></a><div class="props_rev_3"><a id="GUID-743ED7AF-E1FB-4570-9309-448E462C511A" name="GUID-743ED7AF-E1FB-4570-9309-448E462C511A"></a><h4 id="LNPCB-GUID-743ED7AF-E1FB-4570-9309-448E462C511A" class="sect4"><span class="enumeration_section">2.1.5</span>嵌入式PL / SQL块</h4>
                  <div>
                     <p>Pro * COBOL将PL / SQL块视为单个嵌入式SQL语句，因此您可以将PL / SQL块放在可以放置SQL语句的应用程序中的任何位置。要在主机程序中嵌入PL / SQL，只需声明要与PL / SQL共享的变量，并将PL / SQL块与关键字EXEC SQL EXECUTE和END-EXEC括起来。<a id="d7799e538" class="indexterm-anchor"></a></p>
                     <p>从嵌入式PL / SQL块，您可以灵活，安全地操作Oracle数据，因为PL / SQL支持所有SQL数据操作和事务处理命令。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-PLSQL.html#GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F">嵌入式PL / SQL</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB138"></a><div class="props_rev_3"><a id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" name="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A"></a><h4 id="LNPCB-GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" class="sect4"><span class="enumeration_section">2.1.6</span>主机变量和指标变量</h4>
                  <div>
                     <p><span class="italic">主变量</span>是以COBOL语言声明并与Oracle共享的标量或表变量或组项，这意味着您的程序和Oracle都可以引用其值。主机变量是Oracle与程序之间通信的关键。<a id="d7799e579" class="indexterm-anchor"></a></p>
                     <p>您使用<span class="italic">输入</span>主机变量将数据传递到数据库。您使用<span class="italic">输出</span>主机变量将数据和状态信息从数据库传递到您的程序。<a id="d7799e591" class="indexterm-anchor"></a></p>
                     <p>可以在可以使用表达式的任何地方使用主机变量。在SQL语句中，主机变量必须以冒号'：'为前缀，以将它们与数据库模式名称区分开来。 <a id="d7799e597" class="indexterm-anchor"></a><a id="d7799e601" class="indexterm-anchor"></a> 
                     </p>
                     <p>您可以将任何主机变量与可选的指示符变量相关联。<span class="italic">指示符变量</span>是一个整数变量，表示其主变量的值或条件。<span class="italic">NULL</span>是缺失的，未知的或不适用的值。您可以使用指示符变量将NULL分配给输入主变量，并检测输出变量中的NULL或输出字符主变量中的截断值。<a id="d7799e614" class="indexterm-anchor"></a></p>
                     <p>主变量<span class="italic">不能</span>是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在COBOL语句中以冒号为前缀</p>
                        </li>
                        <li>
                           <p>用于数据定义（DDL）语句，如ALTER和CREATE</p>
                        </li>
                     </ul>
                     <p>在SQL语句中，指示符变量必须以冒号为前缀并附加到其关联的主变量（为了提高可读性，可以在指示符变量前面加上可选的关键字INDICATOR）。</p>
                     <p>必须根据COBOL语言的规则声明SQL语句中使用的每个程序变量。正常的范围规则适用。COBOL变量名称可以是任意长度，但只有前30个字符对Pro * COBOL很重要<a id="d7799e634" class="indexterm-anchor"></a><a id="d7799e638" class="indexterm-anchor"></a><a id="d7799e642" class="indexterm-anchor"></a><a id="d7799e646" class="indexterm-anchor"></a><a id="d7799e650" class="indexterm-anchor"></a><a id="d7799e654" class="indexterm-anchor"></a> 。任何有效的COBOL标识符都可以用作主机变量标识符，包括以数字开头的标识符。
                     </p>
                     <p>主机变量的外部数据类型及其源或目标数据库列的内部数据类型不必相同，但它们必须兼容。</p>
                     <div class="infoboxnotealso" id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A__GUID-6EAF10E2-2520-4604-B436-CA97C82FDCD5">
                        <p class="notep1">也可以看看：</p><a href="datatypes-and-host-variables.html#GUID-E35BBCF1-FA1C-4DA4-A522-C17CF57E910F">数据类型转换</a>以获取Oracle在必要时自动<a href="datatypes-and-host-variables.html#GUID-E35BBCF1-FA1C-4DA4-A522-C17CF57E910F">转换</a>的兼容数据类型的列表。
                     </div>
                  </div>
               </div><a id="LNPCB139"></a><div class="props_rev_3"><a id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" name="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE"></a><h4 id="LNPCB-GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" class="sect4"><span class="enumeration_section">2.1.7</span> Oracle数据类型</h4>
                  <div>
                     <p>通常，主机程序将数据输入到数据库，数据库将数据输出到程序。Oracle将输入数据插入数据库表，并将输出数据选择到程序主机变量中。要存储数据项，Oracle必须知道其<span class="italic">数据类型</span> ，该<span class="italic">数据类型</span>指定存储格式和有效值范围。
                     </p>
                     <p>Oracle识别两种数据类型： <span class="italic">内部</span>和<span class="italic">外部</span> 。内部数据类型指定Oracle如何在数据库列中存储数据。Oracle还使用内部数据类型来表示数据库伪列，这些列返回特定数据项但不是表中的实际列。<a id="d7799e701" class="indexterm-anchor"></a><a id="d7799e705" class="indexterm-anchor"></a></p>
                     <p>外部数据类型指定数据在主机变量中的存储方式。当主机程序向Oracle输入数据时，它会在输入主机变量的外部数据类型与数据库列的内部数据类型之间进行任何转换。当Oracle将数据输出到主机程序时，如有必要，Oracle会在数据库列的内部数据类型和输出主机变量的外部数据类型之间进行转换。<a id="d7799e711" class="indexterm-anchor"></a></p>
                     <div class="infoboxnote" id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE__GUID-BE943CDB-1BE9-4883-9364-B297DC64000B">
                        <p class="notep1">注意：</p>
                        <p>您可以使用动态SQL方法4或数据类型等效来覆盖默认数据类型转换。有关数据类型等效的信息，请参阅<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-646C583F-AFD5-4F6D-8627-8BB344F8B721">对DATE字符串格式的显式控制</a> ”</span> 。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB140"></a><div class="props_rev_3"><a id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" name="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1"></a><h4 id="LNPCB-GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" class="sect4"><span class="enumeration_section">2.1.8</span>表</h4>
                  <div>
                     <p>Pro * COBOL允许您定义表主机变量（称为<span class="italic">主机表</span> ）并使用单个SQL语句对它们进行操作。使用SELECT，FETCH，DELETE，INSERT和UPDATE语句，您可以轻松查询和操作大量数据。<a id="d7799e750" class="indexterm-anchor"></a></p>
                     <div class="infoboxnotealso" id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1__GUID-37FC9185-3F74-4734-8ECD-ABD81F1842B8">
                        <p class="notep1">也可以看看：</p><a href="host-tables.html#GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6">主机表，</a>用于完整讨论主机表。
                     </div>
                  </div>
               </div><a id="LNPCB141"></a><div class="props_rev_3"><a id="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" name="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303"></a><h4 id="LNPCB-GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" class="sect4"><span class="enumeration_section">2.1.9</span>错误和警告</h4>
                  <div>
                     <div class="section">
                        <p>执行嵌入式SQL语句时，它会成功或失败，并可能导致错误或警告。您需要一种方法来处理这些结果。Pro * COBOL提供以下错误处理机制：<a id="d7799e785" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQLCODE状态变量</p>
                           </li>
                           <li>
                              <p>SQLSTATE状态变量</p>
                           </li>
                           <li>
                              <p>SQL通信区（SQLCA）</p>
                           </li>
                           <li>
                              <p>WHENEVER声明</p>
                           </li>
                           <li>
                              <p>Oracle通信区域（ORACA）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB142"></a><div class="props_rev_3"><a id="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" name="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5"></a><h5 id="LNPCB-GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" class="sect5"><span class="enumeration_section">2.1.9.1</span> SQLCODE / SQLSTATE状态变量</h5>
                     <div>
                        <p>执行SQL语句后，Oracle Server会将状态代码返回给名为SQLCODE或SQLSTATE的变量。状态代码指示SQL语句是成功执行还是导致错误或警告条件。</p>
                     </div>
                  </div><a id="LNPCB144"></a><a id="LNPCB143"></a><div class="props_rev_3"><a id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" name="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B"></a><h5 id="LNPCB-GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" class="sect5"><span class="enumeration_section">2.1.9.2</span> SQLCA状态变量</h5>
                     <div>
                        <p>SQLCA是一种数据结构，它定义了Oracle用于将运行时状态信息传递给程序的程序变量。使用SQLCA，您可以根据Oracle对刚尝试的工作的反馈采取不同的操作。例如，您可以检查DELETE语句是否成功，如果是，则删除了多少行。 <a id="d7799e854" class="indexterm-anchor"></a> 
                        </p>
                        <p>SQLCA提供诊断检查和事件处理。在运行时，SQLCA保存Oracle传递给您的程序的状态信息。执行SQL语句后，Oracle会设置SQLCA变量以指示结果， <a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">如图2-2所示</a> 。
                        </p>
                        <div class="figure" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">
                           <p class="titleinfigure">图2-2更新SQLCA</p><img src="img/pco81051.gif" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/pco81051.html"><br><a href="img_text/pco81051.html">“图2-2更新SQLCA”的说明</a></div>
                        <!-- class="figure" -->
                        <p>您可以检查INSERT，UPDATE或DELETE语句是否成功，如果成功，则影响了多少行。或者，如果语句失败，您可以获得有关所发生情况的更多信息。<a id="d7799e870" class="indexterm-anchor"></a><a id="d7799e872" class="indexterm-anchor"></a></p>
                        <p>当MODE = {ANSI13 | ORACLE}，您必须通过硬编码或使用INCLUDE语句将其复制到程序中来声明SQLCA。</p>
                        <div class="infoboxnotealso" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__GUID-A3BC2422-6F60-44C4-9604-CB4F1A1D1F61">
                           <p class="notep1">也可以看看：</p><span class="q">“ <a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">使用SQL通信区域</a> ”</span>获取有关如何声明和使用SQLCA的更多信息。</div>
                     </div>
                  </div><a id="LNPCB145"></a><div class="props_rev_3"><a id="GUID-603301A3-66B3-43DE-A23E-1F5F82024371" name="GUID-603301A3-66B3-43DE-A23E-1F5F82024371"></a><h5 id="LNPCB-GUID-603301A3-66B3-43DE-A23E-1F5F82024371" class="sect5"><span class="enumeration_section">2.1.9.3</span> WHENEVER声明</h5>
                     <div>
                        <p>使用WHENEVER语句，您可以指定Oracle检测到错误或警告条件时要自动执行的操作。这些操作包括继续下一个语句，调用子程序，分支到带标签的语句，执行段落或停止。 <a id="d7799e909" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div><a id="LNPCB146"></a><div class="props_rev_3"><a id="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" name="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982"></a><h5 id="LNPCB-GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" class="sect5"><span class="enumeration_section">2.1.9.4</span> ORACA</h5>
                     <div>
                        <div class="section">
                           <p>如果需要有关运行时错误的更多信息，而不是SQLCA提供的信息，则可以使用ORACA。 ORACA是一种处理Oracle通信的数据结构。它包含游标统计信息，有关当前SQL语句的信息，选项设置和系统统计信息。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB147"></a><div class="props_rev_3"><a id="GUID-7A159038-7A6F-4C11-8F21-31B702004524" name="GUID-7A159038-7A6F-4C11-8F21-31B702004524"></a><h5 id="LNPCB-GUID-7A159038-7A6F-4C11-8F21-31B702004524" class="sect5"><span class="enumeration_section">2.1.9.5</span>预编译器选项和错误处理</h5>
                     <div>
                        <div class="section">
                           <p>Oracle在状态变量SQLSTATE和SQLCODE中返回SQL语句的成功或失败。使用预编译器选项MODE = ORACLE，使用SQLCODE，通过包含SQLCA声明。如果MODE = ANSI，则必须声明SQLSTATE或SQLCODE，但不需要SQLCA。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="error-handling-and-diagnostics.html#GUID-AE77299F-16B6-4896-817B-ACC5F7B68A2E">错误处理和诊断</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB148"></a><div class="props_rev_3"><a id="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" name="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7"></a><h4 id="LNPCB-GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" class="sect4"><span class="enumeration_section">2.1.10</span> SQL99语法支持</h4>
                  <div>
                     <p>SQL标准支持SQL应用程序在所有符合标准的软件产品中的可移植性。Oracle功能符合ANSI / ISO SQL99标准，包括符合ANSI标准的连接。Pro * Cobol支持Oracle数据库支持的所有SQL99功能，这意味着支持SELECT，INSERT，DELETE和UPDATE语句的SQL99语法以及DECLARE CURSOR语句中的游标主体。</p>
                  </div>
               </div>
            </div><a id="LNPCB149"></a><div class="props_rev_3"><a id="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" name="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3"></a><h3 id="LNPCB-GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" class="sect3"><span class="enumeration_section">2.2</span>编程指南</h3>
               <div>
                  <div class="section">
                     <p>本节介绍嵌入式SQL语法，编码约定以及Pro * COBOL特定的功能和限制。主题按字母顺序排列，以供快速参考。 <a id="d7799e1018" class="indexterm-anchor"></a><a id="d7799e1020" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB150"></a><div class="props_rev_3"><a id="GUID-97346464-5A87-4195-8EDF-AA1734B48C74" name="GUID-97346464-5A87-4195-8EDF-AA1734B48C74"></a><h4 id="LNPCB-GUID-97346464-5A87-4195-8EDF-AA1734B48C74" class="sect4"><span class="enumeration_section">2.2.1</span>缩写</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用标准COBOL缩写，例如PIC for PICTURE IS和COMP for USAGE IS COMPUTATIONAL。 <a id="d7799e1048" class="indexterm-anchor"></a><a id="d7799e1050" class="indexterm-anchor"></a><a id="d7799e1054" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB151"></a><div class="props_rev_3"><a id="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" name="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8"></a><h4 id="LNPCB-GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" class="sect4"><span class="enumeration_section">2.2.2</span>不<span class="enumeration_section">区分</span>大小写</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL预编译器选项和值以及所有EXEC SQL语句，内联命令和COBOL语句都不区分大小写。预编译器接受大写和小写令牌。<a id="d7799e1084" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB152"></a><div class="props_rev_3"><a id="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" name="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9"></a><h4 id="LNPCB-GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" class="sect4"><span class="enumeration_section">2.2.3</span>支持的COBOL版本</h4>
                  <div>
                     <div class="section">
                        <p><a id="d7799e1116" class="indexterm-anchor"></a> Pro * COBOL支持为您的操作系统（通常为COBOL-85或COBOL-74）标准实施COBOL。某些平台可能同时支持COBOL实现。有关更多信息，请参阅Oracle系统特定的文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB153"></a><div class="props_rev_3"><a id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" name="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1"></a><h4 id="LNPCB-GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" class="sect4"><span class="enumeration_section">2.2.4</span>编码区域</h4>
                  <div>
                     <div class="section">
                        <p><a id="d7799e1143" class="indexterm-anchor"></a><a id="d7799e1147" class="indexterm-anchor"></a><a id="d7799e1151" class="indexterm-anchor"></a><a id="d7799e1155" class="indexterm-anchor"></a>预编译器选项FORMAT指定源代码的格式。如果指定FORMAT = ANSI（默认值），则尽可能符合ANSI标准。在此格式中，第1列到第6列可以包含可选的序列号，第7列（指示符区域）可以指示注释或连续行。
                        </p>
                        <p>分区标题，节标题，段落名称，FD和01语句从第8列到第11列（区域A）开始。其他语句（包括EXEC SQL和EXEC ORACLE语句）必须放在区域B（第12列到第72列）中。源代码格式的这些准则可以由编译器规则覆盖。</p>
                        <p>如果指定FORMAT = TERMINAL，则COBOL语句可以从第1列（最左侧的列）开始，或者第1列可以是指示符区域。此格式也受编译器规则的约束。</p>
                        <p>您可以指定FORMAT = VARIABLE以允许灵活B区域长度。</p>
                        <p>请参阅您自己平台的COBOL编译器文档，以确定COBOL语句的实际可接受格式。</p>
                        <div class="infoboxnote" id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1__GUID-01FF5274-B5BE-47D2-B222-32614BCBE3A9">
                           <p class="notep1">注意：</p>
                           <p>在本手册中，COBOL代码示例使用FORMAT = TERMINAL设置。演示目录中的在线示例程序使用FORMAT = ANSI。 <a id="d7799e1171" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB154"></a><div class="props_rev_3"><a id="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" name="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87"></a><h4 id="LNPCB-GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" class="sect4"><span class="enumeration_section">2.2.5</span>逗号</h4>
                  <div>
                     <div class="section">
                        <p>在SQL中，必须使用逗号分隔列表项，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB，SAL INTO：EMP-NAME，：JOB-TITLE，：来自EMP的SALARY EMPNO =：EMP-NUMBER END-EXEC。</pre><p>在COBOL中，您可以使用逗号或空格分隔列表项。例如，以下两个语句是等效的：</p><pre class="oac_no_warn" dir="ltr">将AMT1，AMT2，AMT3添加到TOTAL-AMT。将AMT1 AMT2 AMT3添加到TOTAL-AMT。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB155"></a><div class="props_rev_3"><a id="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" name="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60"></a><h4 id="LNPCB-GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" class="sect4"><span class="enumeration_section">2.2.6</span>评论</h4>
                  <div>
                     <div class="section">
                        <p>您可以在SQL语句中放置COBOL注释行。COBOL注释行以指标区域中的星号（*）开头。</p>
                        <p>您还可以在行末尾的SQL语句中放置以“ -   - ”开头的ANSI SQL样式注释（但不能在SQL语句的最后一行之后）。</p>
                        <p>在这两个字符后面的其余部分继续COBOL注释：“*&gt;”。</p>
                        <p>您可以在SQL语句中放置C风格的注释（/ * ... * /）。</p>
                        <p>以下示例显示了所有四种注释样式：<a id="d7799e1247" class="indexterm-anchor"></a><a id="d7799e1251" class="indexterm-anchor"></a><a id="d7799e1255" class="indexterm-anchor"></a><a id="d7799e1259" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">移动12到DEPT-NUMBER。 *&gt;这是软件开发小组。EXEC SQL SELECT ENAME，SAL *分配列值以输出主机变量INTO：EMP-NAME，：SALARY  - 输出主机变量/ *分配给输出主机变量的列值* / FROM EMP WHERE DEPTNO =：DEPT-NUMBER END-EXEC 。 - 非法评论</pre><p>在终止符END-EXEC之后，您不能嵌套注释或将它们放在SQL语句的最后一行。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB156"></a><div class="props_rev_3"><a id="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" name="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA"></a><h4 id="LNPCB-GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" class="sect4"><span class="enumeration_section">2.2.7</span>延续线</h4>
                  <div>
                     <div class="section">
                        <p>根据COBOL的规则，您可以将SQL语句从一行继续到下一行，如下例所示：<a id="d7799e1296" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL INTO：EMP-NAME，：来自EMP的SALARY DEPTNO =：DEPT-NUMBER END-EXEC。</pre><p>不需要延续指标。</p>
                        <p>要将字符串文字从一行继续到下一行，请通过第72列对文字进行编码。在下一行，在第7列中编码连字符（ - ），在第12列或更高版本中编写引号，然后在文字的其余部分编码。一个例子如下：<a id="d7799e1306" class="indexterm-anchor"></a><a id="d7799e1310" class="indexterm-anchor"></a><a id="d7799e1314" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">工作储存部分。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 UPDATE-STATEMENT PIC X（80）VALUE“UPDATE EMP SET BON  - ”US = 500，其中DEPTNO = 20“。EXEC SQL END DECLARE SECTION END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB157"></a><div class="props_rev_3"><a id="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" name="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E"></a><h4 id="LNPCB-GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" class="sect4"><span class="enumeration_section">2.2.8</span>复制声明</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL不会解析复制语句。因此，COPY命令附带的文件不应包含Host变量的定义或包含嵌入的SQL语句。而是使用<span class="q">“ <a href="precompiler-concepts.html#GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473">使用INCLUDE语句</a> ”中</span>记录的INCLUDE预编译器语句。使用INCLUDE并使用DECLARE_SECTION = YES时要小心。组项目应放在声明部分的全部内部或全部。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB158"></a><div class="props_rev_3"><a id="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" name="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2"></a><h4 id="LNPCB-GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" class="sect4"><span class="enumeration_section">2.2.9</span>小数点是逗号</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL支持ENVIRONMENT DIVISION中的DECIMAL-POINT IS COMMA子句。如果源文件中出现DECIMAL-POINT IS COMMA子句，则逗号将被允许作为从VALUE子句中任何数字文字的小数部分开始的符号。</p>
                        <p>例如，允许以下内容：</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。FOO环境部门。配置部分。 SPECIAL-名。 DECIMAL-POINT很难玩。 *&gt; &lt; -  ** DATA DIVISION。工作储存部分。 ...01 WDATA1 PIC S9V999 VALUE +，567。 *&gt; &lt;--- ** 01 WDATA2 PIC S9V999值 - ，234。 *&gt; &lt;--- ** ...</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB159"></a><div class="props_rev_3"><a id="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" name="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC"></a><h4 id="LNPCB-GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" class="sect4"><span class="enumeration_section">2.2.10</span>分隔符</h4>
                  <div>
                     <div class="section">
                        <p>LITDELIM选项指定COBOL字符串常量和文字的分隔符。如果指定LITDELIM = APOST，则Pro * COBOL在生成COBOL代码时使用撇号。如果指定LITDELIM = QUOTE（默认值），则使用引号，如<a id="d7799e1405" class="indexterm-anchor"></a><a id="d7799e1409" class="indexterm-anchor"></a><a id="d7799e1411" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">使用SQL-TMP0调用“SQLROL”。
</pre><p>在SQL语句中，必须使用引号来分隔包含特殊或小写字符的标识符，如</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE TABLE“Emp2”END-EXEC。</pre><p>但是，您必须使用撇号来分隔字符串常量，如</p><pre class="oac_no_warn" dir="ltr">来自EMP的EXEC SQL SELECT ENAME，其中JOB ='CLERK'END-EXEC。</pre><p>无论Pro * COBOL源文件中使用哪个分隔符，Pro * COBOL都会生成由LITDELIM值指定的分隔符。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB160"></a><div class="props_rev_3"><a id="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" name="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368"></a><h4 id="LNPCB-GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" class="sect4"><span class="enumeration_section">2.2.11</span>可选的分区标题</h4>
                  <div>
                     <div class="section">
                        <p>以下分区标题是可选的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>识别部门</p>
                           </li>
                           <li>
                              <p>环境部门</p>
                           </li>
                           <li>
                              <p>数据部门</p>
                           </li>
                        </ul>
                        <p>请注意，PROCEDURE DIVISION标头不是可选的。可以预编译以下源代码：</p><pre class="oac_no_warn" dir="ltr">* IDENTIFICATION DIVISION标头是可选的PROGRAM-ID。你好。 * ENVIRONMENT DIVISION标题是可选的CONFIGURATION SECTION。 * DATA DIVISION标题是可选的WORKING-STORAGE SECTION。程序部门。显示“你好世界！”。停止运行。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB161"></a><div class="props_rev_3"><a id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" name="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765"></a><h4 id="LNPCB-GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" class="sect4"><span class="enumeration_section">2.2.12</span>嵌入式SQL语法</h4>
                  <div>
                     <div class="section">
                        <p>要在Pro * COBOL程序中使用SQL语句，请在SQL语句前面加上EXEC SQL子句，并使用END-EXEC关键字结束语句。 <a id="d7799e1496" class="indexterm-anchor"></a><a id="d7799e1500" class="indexterm-anchor"></a><a id="d7799e1504" class="indexterm-anchor"></a><a id="d7799e1508" class="indexterm-anchor"></a> 
                        </p>
                        <div class="infoboxnotealso" id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765__GUID-C6D923C0-7F18-4E98-8676-D31D4F149D45">
                           <p class="notep1">也可以看看：</p><a href="../sqlrf/index.html" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span> 。</a>有关嵌入式SQL语法的更多信息。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB162"></a><div class="props_rev_3"><a id="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" name="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D"></a><h4 id="LNPCB-GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" class="sect4"><span class="enumeration_section">2.2.13</span>比喻常数</h4>
                  <div>
                     <div class="section">
                        <p>在SQL语句中不能使用诸如HIGH-VALUE，ZERO和SPACE之类的图形常量。例如，以下内容<span class="italic">无效</span> ：<a id="d7799e1546" class="indexterm-anchor"></a><a id="d7799e1550" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE COMM = ZERO END-EXEC。</pre><p>相反，请使用以下内容：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE COMM = 0 END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB163"></a><div class="props_rev_3"><a id="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" name="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4"></a><h4 id="LNPCB-GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" class="sect4"><span class="enumeration_section">2.2.14</span>文件长度</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL无法处理任意长的源文件。内部使用的一些变量限制了生成的文件的大小。允许的行数没有绝对限制，但源文件的以下方面是文件大小约束的影响因素：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌入式SQL语句的复杂性（例如，绑定和定义变量的数量）</p>
                           </li>
                           <li>
                              <p>是否使用数据库名称（例如，使用AT子句连接到数据库）</p>
                           </li>
                           <li>
                              <p>嵌入式SQL语句的数量</p>
                           </li>
                        </ul>
                        <p>要防止与此限制相关的问题，请使用多个程序单元来充分减小源文件的大小。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB164"></a><div class="props_rev_3"><a id="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" name="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432"></a><h4 id="LNPCB-GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" class="sect4"><span class="enumeration_section">2.2.15</span>允许填充</h4>
                  <div>
                     <div class="section">
                        <p>主机变量声明中允许使用单词FILLER。单词FILLER用于指定无法明确引用的组的基本项。以下声明有效：</p><pre class="oac_no_warn" dir="ltr">01股票。 05 DIVIDEND PIC X（5）。05 FILLER PIC X. 05价格PIC X（6）。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB165"></a><div class="props_rev_3"><a id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" name="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865"></a><h4 id="LNPCB-GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" class="sect4"><span class="enumeration_section">2.2.16</span>主机变量名称</h4>
                  <div>
                     <div class="section">
                        <p>任何有效的标准COBOL标识符都可以用作主机变量。变量名称可以是任意长度，但只有前30个字符才有意义。COBOL编译器识别的最大重要字符数为30。<a id="d7799e1654" class="indexterm-anchor"></a><a id="d7799e1658" class="indexterm-anchor"></a><a id="d7799e1662" class="indexterm-anchor"></a></p>
                        <p>为了便于移植，您可能希望将主机变量名称的长度限制为18个或更少的字符（SQL标准规定的长度）。</p>
                        <div class="infoboxnotealso" id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865__GUID-D5B758B4-E645-4A95-8259-92CE85A1BF2E">
                           <p class="notep1">也可以看看：</p><a href="reserved-words-keywords-and-namespaces.html#GUID-A408EC88-567F-4D54-8359-ABCFF421CDD7">保留字_关键字_和命名空间，</a>用于限制在应用程序中使用它们的单词列表。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB166"></a><div class="props_rev_3"><a id="GUID-167590B9-9985-4779-AFCF-B29D24D858BC" name="GUID-167590B9-9985-4779-AFCF-B29D24D858BC"></a><h4 id="LNPCB-GUID-167590B9-9985-4779-AFCF-B29D24D858BC" class="sect4"><span class="enumeration_section">2.2.17</span>连字符名称</h4>
                  <div>
                     <div class="section">
                        <p>您可以在静态SQL语句中使用带连字符的主机变量名称，但<span class="italic">不能</span>在动态SQL中使用。例如，以下用法<span class="italic">无效</span> ：<a id="d7799e1706" class="indexterm-anchor"></a><a id="d7799e1710" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">将“从EMP中删除EMPNO = EMP-NUMBER”移到SQLSTMT。从SQLSTMT END-EXEC EXEC SQL PREPARE STMT1。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB167"></a><div class="props_rev_3"><a id="GUID-0B6A0DF7-A963-480F-B112-913658099FC7" name="GUID-0B6A0DF7-A963-480F-B112-913658099FC7"></a><h4 id="LNPCB-GUID-0B6A0DF7-A963-480F-B112-913658099FC7" class="sect4"><span class="enumeration_section">2.2.18</span>级别编号</h4>
                  <div>
                     <div class="section">
                        <p>声明主变量时，可以使用级别编号01到49和77。Pro * COBOL不允许将包含VARYING子句或伪类型变量的变量（这些数据类型以“SQL-”为前缀）声明为级别49或77。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB168"></a><div class="props_rev_3"><a id="GUID-5F903960-5E5F-4739-8564-303E130B7518" name="GUID-5F903960-5E5F-4739-8564-303E130B7518"></a><h4 id="LNPCB-GUID-5F903960-5E5F-4739-8564-303E130B7518" class="sect4"><span class="enumeration_section">2.2.19</span> MAXLITERAL默认值</h4>
                  <div>
                     <div class="section">
                        <p>使用MAXLITERAL选项，您可以指定Pro * COBOL生成的字符串文字的最大长度，以便不超过编译器限制。对于Pro * COBOL，默认值为256，但您可能必须指定较低的值。在IBM专有的S370操作系统上，它是120。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB169"></a><div class="props_rev_3"><a id="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" name="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784"></a><h4 id="LNPCB-GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" class="sect4"><span class="enumeration_section">2.2.20</span>多字节数据类型</h4>
                  <div>
                     <div class="section">
                        <p>支持ANSI标准国家字符集数据类型来处理多字节字符数据。如果编译器支持PIC N或PIC G子句，则定义存储固定长度NCHAR字符串的变量。您可以使用由长度字段和字符串字段组成的COBOL组项来存储可变长度，多字节的国家字符集字符串。<a id="d7799e1792" class="indexterm-anchor"></a></p>
                        <p>环境变量NLS_NCHAR可用于指定客户端全球化支持国家字符集。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-B7D9C340-75B1-4B84-B44E-F4CB1748262E">VARCHAR变量</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB170"></a><div class="props_rev_3"><a id="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" name="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED"></a><h4 id="LNPCB-GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" class="sect4"><span class="enumeration_section">2.2.21</span> SQL中的NULL</h4>
                  <div>
                     <div class="section">
                        <p>在SQL中，NULL表示缺失，未知或不适用的列值;它既不等于零也不等于空白。使用NVL函数将NULL转换为非NULL值，使用IS [NOT] NULL比较运算符搜索NULL，并使用指示符变量插入和测试NULL。<a id="d7799e1835" class="indexterm-anchor"></a><a id="d7799e1839" class="indexterm-anchor"></a><a id="d7799e1843" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB171"></a><div class="props_rev_3"><a id="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" name="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965"></a><h4 id="LNPCB-GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" class="sect4"><span class="enumeration_section">2.2.22</span>段落和章节名称</h4>
                  <div>
                     <div class="section">
                        <p>您可以将标准COBOL段落和节名称与SQL语句关联，如以下示例所示：<a id="d7799e1872" class="indexterm-anchor"></a><a id="d7799e1876" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">LOAD-DATA。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）值（：EMP-NUMBER，：EMP-NAME，：DEPT-NUMBER）END-EXEC。</pre><p>此外，您可以在WHENEVER中引用段落和部分名称...做什么或者什么时候......GOTO语句，如下一个例子所示：</p><pre class="oac_no_warn" dir="ltr">程序部门。主要。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。 ...SQL-ERROR部分。 ...</pre><p>您必须在区域A中开始所有段落名称。 <a id="d7799e1888" class="indexterm-anchor"></a><a id="d7799e1892" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB172"></a><div class="props_rev_3"><a id="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" name="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D"></a><h4 id="LNPCB-GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" class="sect4"><span class="enumeration_section">2.2.23</span> REDEFINES条款</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用COBOL REDEFINES子句重新定义组或基本项。例如，以下声明有效：<a id="d7799e1922" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 REC-ID PIC X（4）。01 REC-NUM重新定义REC-ID PIC S9（4）COMP。 EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>和：<a id="d7799e1930" class="indexterm-anchor"></a><a id="d7799e1934" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01股票。 05 DIVIDEND PIC X（5）。05 PRICE PIC X（6）。01 BOND REDEFINES股票。 05 COUPON-RATE PIC X（4）。05 PRICE PIC X（7）。EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>如果单个INTO子句使用来自组项主机变量和重新定义的项目，则Pro * COBOL不会发出警告或错误。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB174"></a><a id="LNPCB173"></a><div class="props_rev_3"><a id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37" name="GUID-63C7C12C-A978-448C-89F7-809A89B96F37"></a><h4 id="LNPCB-GUID-63C7C12C-A978-448C-89F7-809A89B96F37" class="sect4"><span class="enumeration_section">2.2.24</span>关系运算符</h4>
                  <div>
                     <div class="section">
                        <p>COBOL关系运算符与它们的SQL等价物不同，如<a href="precompiler-concepts.html#GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966">关系运算符中</a>所示。此外，COBOL允许使用单词而不是符号，而SQL则不然。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__GUID-B2BDCFB5-8771-4650-91BA-F541ED830079">
                        <p class="titleintable">表2-3 <span class="italic" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966"><span class="bold">关系运算符</span></span></p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="关系运算符" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d7799e1984">SQL运算符</th>
                                 <th align="left" valign="bottom" width="69%" id="d7799e1987">COBOL运营商</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1992" headers="d7799e1984 ">
                                    <p>=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1992 d7799e1987 ">
                                    <p>=，等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1999" headers="d7799e1984 ">
                                    <p>&lt;&gt; ,!=，^ =</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1999 d7799e1987 ">
                                    <p>NOT =，不等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2006" headers="d7799e1984 ">
                                    <p>&gt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2006 d7799e1987 ">
                                    <p>&gt;，大于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2013" headers="d7799e1984 ">
                                    <p>&lt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2013 d7799e1987 ">
                                    <p>&lt;，不过</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2020" headers="d7799e1984 ">
                                    <p>&gt; =</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2020 d7799e1987 ">
                                    <p>&gt; =，大于或等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2027" headers="d7799e1984 ">
                                    <p>&lt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2027 d7799e1987 ">
                                    <p>&lt;=，少于或等于</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCB175"></a><div class="props_rev_3"><a id="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" name="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235"></a><h4 id="LNPCB-GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" class="sect4"><span class="enumeration_section">2.2.25</span>句子终结者</h4>
                  <div>
                     <div class="section">
                        <p>COBOL <span class="italic">语句</span>包括一个或多个COBOL或SQL语句，或两者都包含，并以句点结束。在条件语句中，只有最后一个语句必须以句点结束，如下例所示。 <a id="d7799e2071" class="indexterm-anchor"></a><a id="d7799e2075" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">如果EMP-NUMBER =零移动错误有效数据执行GET-EMP-NUM直到有效数据= TRUE EXEC EXEC SQL从EMP删除EMPNO =：EMP-NUMBER END-EXEC ADD 1 DELETE-TOTAL。万一。</pre><p>SQL语句可以用逗号，句点或其他COBOL语句结束。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB176"></a><div class="props_rev_3"><a id="GUID-C01E658A-1EAE-4497-82DB-347217694E78" name="GUID-C01E658A-1EAE-4497-82DB-347217694E78"></a><h3 id="LNPCB-GUID-C01E658A-1EAE-4497-82DB-347217694E78" class="sect3"><span class="enumeration_section">2.3</span>申报部分</h3>
               <div>
                  <p>在数据库服务器和应用程序之间传递数据需要主机变量和错误处理。本节介绍如何满足这些要求。</p>
               </div><a id="LNPCB177"></a><div class="props_rev_3"><a id="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" name="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161"></a><h4 id="LNPCB-GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" class="sect4"><span class="enumeration_section">2.3.1</span>申报部分的内容</h4>
                  <div>
                     <div class="section">
                        <p>声明部分以声明开头<a id="d7799e2132" class="indexterm-anchor"></a><a id="d7799e2136" class="indexterm-anchor"></a><a id="d7799e2140" class="indexterm-anchor"></a> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。</pre><p>并以声明结束：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>在这两个语句之间只允许以下内容：<a id="d7799e2153" class="indexterm-anchor"></a><a id="d7799e2157" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主变量和指标变量声明</p>
                           </li>
                           <li>
                              <p>非主机COBOL变量</p>
                           </li>
                           <li>
                              <p>EXEC SQL DECLARE语句</p>
                           </li>
                           <li>
                              <p>EXEC SQL INCLUDE语句</p>
                           </li>
                           <li>
                              <p>EXEC SQL VAR语句</p>
                           </li>
                           <li>
                              <p>EXEC ORACLE声明</p>
                           </li>
                           <li>
                              <p>COBOL评论</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB178"></a><div class="props_rev_3"><a id="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" name="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB"></a><h5 id="LNPCB-GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" class="sect5"><span class="enumeration_section">2.3.1.1</span>一个例子</h5>
                     <div>
                        <div class="section">
                           <p>在以下示例中，您将声明四个主机变量，以便稍后在程序中使用。 <a id="d7799e2208" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">工作储存部分。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 EMP-NUMBER PIC 9（4）COMP VALUE ZERO。 01 EMP-NAME PIC X（10）变化。 01 SALARY PIC S9（5）V99 COMP-3 VALUE ZERO。 01委员会PIC S9（5）V99 COMP-3 VALUE ZERO。 EXEC SQL END DECLARE SECTION END-EXEC。</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB179"></a><div class="props_rev_3"><a id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" name="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE"></a><h4 id="LNPCB-GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" class="sect4"><span class="enumeration_section">2.3.2</span>预编译器选项DECLARE_SECTION</h4>
                  <div>
                     <div class="section">
                        <p>声明部分是可选的。为了向后兼容8.0之前的版本，Pro * COBOL提供了一个命令行预编译器选项，用于显式控制是否只允许声明部分中的声明作为主机变量。这个选项是：</p>
                        <p>DECLARE_SECTION = {YES | NO}（默认为NO）</p>
                        <p>您必须在命令行或配置文件中使用DECLARE_SECTION选项。</p>
                        <p>当MODE = ORACLE和DECLARE_SECTION = YES时，只允许在Declare Section内声明的变量作为主变量。当MODE = ANSI时，DECLARE_SECTION隐式设置为YES。</p>
                        <p>如果DECLARE_SECTION设置为YES，那么必须声明Declare Section中SQL语句中使用的所有程序变量。如果DECLARE_SECTION设置为NO，则可以选择使用Declare Section。在这种情况下，主机变量和指示符变量的声明可以在Declare Section内部或外部进行。此可选行为是对8.0版和早期版本的更改。</p>
                        <p>每个预编译单元允许多个声明部分。此外，主程序可以包含几个独立预编译的单元。<a id="d7799e2256" class="indexterm-anchor"></a></p>
                        <div class="infoboxnotealso" id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE__GUID-5688F9A4-25D3-4F3F-B4FD-7FAD330A0259">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="precompiler-options.html#GUID-B8F5D2F9-D077-4CC0-B8A5-0B4CB1D6425D">宏观和微观选项</a> ”</span>有关宏观和微观选项的更多信息。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="precompiler-options.html#GUID-A4AB5DC2-8F05-47BD-8299-3A50DE9C6A5E">DECLARE_SECTION</a> ”</span>有关该选项的更多详细信息。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB180"></a><div class="props_rev_3"><a id="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" name="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473"></a><h4 id="LNPCB-GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" class="sect4"><span class="enumeration_section">2.3.3</span>使用INCLUDE语句</h4>
                  <div>
                     <p>INCLUDE语句允许您将文件复制到主机程序中，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">*复制SQL通信区域（SQLCA）EXEC SQL INCLUDE SQLCA END-EXEC。 *复制到Oracle通信区域（ORACA）EXEC SQL INCLUDE ORACA END-EXEC。</pre><p>您可以包含任何文件。预编译Pro * COBOL程序时，每个EXEC SQL INCLUDE语句都将替换为语句中指定的文件的副本。<a id="d7799e2305" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB181"></a><div class="props_rev_3"><a id="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" name="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D"></a><h5 id="LNPCB-GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" class="sect5"><span class="enumeration_section">2.3.3.1</span>文件名扩展名</h5>
                     <div>
                        <div class="section">
                           <p>如果您的系统使用文件扩展名但未指定文件扩展名，Pro * COBOL将采用源文件的默认扩展名（通常为COB）。有关更多信息，请参阅Oracle系统特定的文档。 <a id="d7799e2334" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB182"></a><div class="props_rev_3"><a id="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" name="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12"></a><h5 id="LNPCB-GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" class="sect5"><span class="enumeration_section">2.3.3.2</span>搜索路径</h5>
                     <div>
                        <p>如果系统使用目录，则可以使用INCLUDE选项为包含的文件设置搜索路径，如下所示：</p><pre class="oac_no_warn" dir="ltr">INCLUDE = <span class="italic">路径</span> 
</pre><p>其中<span class="italic">path</span>默认为当前目录。
                        </p>
                        <p>Pro * COBOL首先搜索当前目录，然后搜索INCLUDE选项指定的目录，最后搜索标准INCLUDE文件的目录。您无需为标准文件指定路径，例如SQLCA和ORACA。但是，非标准文件需要一个路径，除非它们存储在当前目录中。<a id="d7799e2375" class="indexterm-anchor"></a></p>
                        <p>您还可以在命令行上指定多个路径，如下所示：</p><pre class="oac_no_warn" dir="ltr">...INCLUDE = &lt;path1&gt; INCLUDE = &lt;path2&gt; ...
</pre><p>指定多个路径时，Pro * COBOL首先搜索当前目录，然后搜索<span class="italic">path1</span>目录，然后搜索<span class="italic">path2</span>目录，依此类推。最后搜索包含标准INCLUDE文件的目录。路径语法是特定于系统的。有关更多信息，请参阅Oracle系统特定的文档。
                        </p>
                        <p>请记住，即使您指定了搜索路径，Pro * COBOL也会首先在当前目录中搜索文件。如果要包含的文件位于另一个目录中，请确保当前目录或搜索路径中位于其前面的任何其他目录中没有相同名称的文件。如果您的操作系统区分大小写，请确保指定存储文件的相同大小/小写文件名。<a id="d7799e2393" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB183"></a><div class="props_rev_3"><a id="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" name="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC"></a><h3 id="LNPCB-GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" class="sect3"><span class="enumeration_section">2.4</span>嵌套程序</h3>
               <div>
                  <p>将程序嵌套在COBOL中意味着将一个程序放在另一个程序中。包含的程序可能会引用包含它们的程序的一些资源。高级程序和嵌套程序中的名称可以相同，并且描述不同的数据项而不会发生冲突，因为名称仅在程序中是已知的。但是，可以在嵌套程序中引用更高级别程序的“配置”部分中描述的名称。</p>
                  <p>有些编译器不支持GLOBAL子句。Pro * COBOL通过生成包含GLOBAL子句的代码来支持嵌套程序。要避免无条件地生成GLOBAL子句，请指定预编译器选项NESTED = NO。 NESTED（= YES或NO）默认为YES，可以在配置文件中使用，也可以在命令行中使用，但不能内联（EXEC ORACLE语句）。</p>
                  <p>更高级别的程序可以包含多个嵌套程序。同样，嵌套程序可以嵌套在它们中的程序。必须将嵌套程序直接放在嵌套程序的END PROGRAM标头之前。</p>
                  <p>您只能通过直接或间接嵌套的程序调用嵌套程序。如果希望任何程序（甚至是嵌套树结构的不同分支上的程序）调用嵌套程序，则可以在嵌套程序的PROGRAM-ID段落中编写COMMON子句。您只能为嵌套程序编写COMMON代码：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 &lt;nested-program-name&gt; COMMON。</pre><p>您可以为文件定义和级别01数据项编码GLOBAL短语（任何从属项自动变为全局）。这使得它们可以在所有子程序中直接或间接地包含在它们中。您在更高级别的程序上编码GLOBAL。如果嵌套程序定义的名称与更高级别程序中声明的GLOBAL名称相同，则COBOL使用嵌套程序中的声明。如果数据项包含REDEFINES子句，则GLOBAL必须遵循它。</p><pre class="oac_no_warn" dir="ltr">FD文件名GLOBAL ...01 data-name1 GLOBAL ...01 data-name2 REDEFINES data-name3 GLOBAL ...</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-8FA5E1B2-2B76-4BBF-BA9B-CF31814BB2D0">嵌套</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB184"></a><div class="props_rev_3"><a id="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" name="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB"></a><h4 id="LNPCB-GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" class="sect4"><span class="enumeration_section">2.4.1</span>支持嵌套程序</h4>
                  <div>
                     <p>Pro * COBOL使您可以将嵌套SQL的嵌套程序存储在单个源文件中。所有01级别项目在包含程序中标记为全局，并且是包含程序级别的有效主变量，可用作包含程序直接或间接包含的任何程序中的有效主变量。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。 MAINPROG。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 REC1 GLOBAL。 05 VAR1 PIC X（10）。05 VAR2 PIC X（10）。01 VAR1 PIC X（10）GLOBAL。 EXEC SQL END DECLARE SECTION END-EXEC。程序部门。 ...&lt;主要程序声明&gt; ......识别部门。 PROGRAM-ID。 NESTEDPROG。环境部门。数据部门。工作储存部分。 01 VAR1 PIC S9（4）。程序部门。 ...EXEC SQL SELECT X，Y INTO：REC1 FROM ...END-EXEC。 EXEC SQL SELECT X INTO：VAR1 FROM ...END-EXEC。 EXEC SQL SELECT X INTO：REC1。VAR1 FROM ...END-EXEC。 ...结束计划NESTEDPROG。 END PROGRAM MAINPROG。</pre><p>主程序将主机变量REC1声明为全局，因此嵌套程序可以在第一个select语句中使用REC1，而不必声明它。由于VAR1被声明为全局变量并且也是嵌套程序中的局部变量，因此第二个select语句将使用声明为S9（4）的VAR1，从而覆盖全局声明。在第三个select语句中，使用声明为PIC X（10）的REC1的全局VAR1。</p>
                     <p>上一段描述了使用DECLARE_SECTION = NO时的结果。当DECLARE_SECTION = YES时，Pro * COBOL将无法识别主变量， <span class="italic">除非</span>它们在Declare Section中声明。如果使用DECLARE_SECTION = YES预编译前面的程序，则第二个select语句将导致不明确的主变量错误。第一个和第三个select语句的功能相同。
                     </p>
                     <p>注意：不支持递归嵌套程序</p>
                  </div><a id="LNPCB185"></a><div class="props_rev_3"><a id="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" name="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88"></a><h5 id="LNPCB-GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" class="sect5"><span class="enumeration_section">2.4.1.1</span>声明SQLCA</h5>
                     <div>
                        <p>有关为嵌套程序声明SQLCA的信息，所提供的SQLCA定义将被声明为全局，因此仅在更高级别的程序中需要声明SQLCA。每次执行新的SQL语句时，SQLCA都可以更改。如果要在嵌套程序中声明其他SQLCA区域，则始终可以修改提供的SQLCA以删除全局规范。这也适用于SQLDA和ORACA。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B">SQLCA状态变量</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCB186"></a><div class="props_rev_3"><a id="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" name="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33"></a><h5 id="LNPCB-GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" class="sect5"><span class="enumeration_section">2.4.1.2</span>嵌套程序示例</h5>
                     <div>
                        <p>见SAMPLE13。PCO在演示目录中<a id="d7799e2532" class="indexterm-anchor"></a> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB187"></a><div class="props_rev_3"><a id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" name="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0"></a><h3 id="LNPCB-GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" class="sect3"><span class="enumeration_section">2.5</span>条件预编译</h3>
               <div>
                  <p>条件预编译包括（或排除）主机程序中基于特定条件的代码段。例如，您可能希望在UNIX下进行预编译时包含一段代码，而在VMS下进行预编译时则需要包含另一部分代码。条件预编译允许您编写可在不同环境中运行的程序。<a id="d7799e2561" class="indexterm-anchor"></a><a id="d7799e2565" class="indexterm-anchor"></a></p>
                  <p>条件的条件部分由定义环境和要采取的操作的语句标记。您可以在这些部分中编写主机语言语句以及EXEC SQL语句。以下语句允许您对预编译执行条件控制：<a id="d7799e2569" class="indexterm-anchor"></a><a id="d7799e2571" class="indexterm-anchor"></a><a id="d7799e2573" class="indexterm-anchor"></a><a id="d7799e2575" class="indexterm-anchor"></a><a id="d7799e2577" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">*  - 定义符号EXEC ORACLE DEFINE符号END-EXEC。 *  - 如果符号定义为EXEC ORACLE IFDEF符号END-EXEC。 *  - 如果未定义符号，则EXEC ORACLE IFNDEF符号END-EXEC。 *  - 否则EXEC ORACLE ELSE END-EXEC。 *  - 结束此控制块EXEC ORACLE ENDIF END-EXEC。</pre><p>必须使用<code class="codeph">END-EXEC</code>终止条件语句。</p>
                  <div class="infoboxnote" id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0__GUID-7BCA471F-CE66-466A-BB6B-5B253873EC90">
                     <p class="notep1">注意：</p>
                     <p>Pro * COBOL可能不支持编译器的条件编译功能。</p>
                  </div>
               </div><a id="LNPCB188"></a><div class="props_rev_3"><a id="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" name="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9"></a><h4 id="LNPCB-GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" class="sect4"><span class="enumeration_section">2.5.1</span>一个例子</h4>
                  <div>
                     <div class="section">
                        <p>在以下示例中，仅在定义符号<span class="italic">SITE2</span>时预编译SELECT语句：<a id="d7799e2617" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF SITE2 END-EXEC。 EXEC SQL SELECT DNAME INTO：DEPT-NAME FROM DEPT，DEPTNO =：DEPT-NUMBER EXEC ORACLE ENDIF END-EXEC。</pre><p>条件块可以嵌套，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF OUTER END-EXEC。执行ORACLE IFDEF INNER END-EXEC。 ...EXEC ORACLE ENDIF END-EXEC。 EXEC ORACLE ENDIF END-EXEC。</pre><p>您可以通过将它放在IFDEF和ENDIF之间并且<span class="italic">不</span>定义符号来“注释掉”主机语言或嵌入式SQL代码。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB189"></a><div class="props_rev_3"><a id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" name="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5"></a><h4 id="LNPCB-GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" class="sect4"><span class="enumeration_section">2.5.2</span>定义符号</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过两种方式定义符号。要么包括声明<a id="d7799e2657" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE符号END-EXEC。</pre><p>在您的主机程序中或使用语法在命令行上定义符号</p><pre class="oac_no_warn" dir="ltr">...INAME =文件名...DEFINE =符号</pre><p><span class="italic">符号</span>不区分大小写。
                        </p>
                        <p>在系统上安装Pro * COBOL时，会为您预定义某些特定于端口的符号。例如，预定义的操作系统符号包括CMS，MVS，UNIX和VMS。</p>
                        <div class="infoboxnote" id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5__GUID-A1F9FCF9-D2D5-4031-B1F1-71AF37E85CA6">
                           <p class="notep1">注意：</p>
                           <p>DEFINE SYMBOL名称以数字开头，或者包含破折号，在预编译期间会导致不可恢复的错误。您可以使用下划线，并且可以使用除DEFINE SYMBOL名称开头之外的数字。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB190"></a><div class="props_rev_3"><a id="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" name="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153"></a><h3 id="LNPCB-GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" class="sect3"><span class="enumeration_section">2.6</span>单独的预编译</h3>
               <div>
                  <p>您可以单独预编译多个COBOL程序模块，然后将它们链接到一个可执行程序中。这支持模块化编程，当程序的功能组件由不同的程序员编写和调试时，这是必需的。各个程序模块不需要用同一种语言编写。<a id="d7799e2702" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB191"></a><div class="props_rev_3"><a id="GUID-1812416E-8E90-45F4-A219-13175B8E66E5" name="GUID-1812416E-8E90-45F4-A219-13175B8E66E5"></a><h4 id="LNPCB-GUID-1812416E-8E90-45F4-A219-13175B8E66E5" class="sect4"><span class="enumeration_section">2.6.1</span>指南</h4>
                  <div>
                     <p>以下指南将帮助您避免一些常见问题。<a id="d7799e2730" class="indexterm-anchor"></a><a id="d7799e2734" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB192"></a><div class="props_rev_3"><a id="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" name="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6"></a><h5 id="LNPCB-GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" class="sect5"><span class="enumeration_section">2.6.1.1</span>引用游标</h5>
                     <div>
                        <p>游标名称是SQL标识符，其范围是预编译单元。因此，游标操作不能跨越预编译单元（文件）。也就是说，您不能在一个文件中声明游标并在另一个文件中打开或从中获取游标，因此在进行单独的预编译时，请确保对给定游标的所有定义和引用都在一个文件中。<a id="d7799e2762" class="indexterm-anchor"></a><a id="d7799e2766" class="indexterm-anchor"></a></p>
                     </div>
                  </div><a id="LNPCB193"></a><div class="props_rev_3"><a id="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" name="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B"></a><h5 id="LNPCB-GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" class="sect5"><span class="enumeration_section">2.6.1.2</span>指定MAXOPENCURSORS</h5>
                     <div>
                        <div class="section">
                           <p>预编译连接到Oracle的程序模块时，请为MAXOPENCURSORS指定一个足以支持任何程序模块的值。如果将其用于其他程序模块，则忽略MAXOPENCURSORS。在运行时仅使用对连接有效的值。<a id="d7799e2795" class="indexterm-anchor"></a><a id="d7799e2799" class="indexterm-anchor"></a></p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB194"></a><div class="props_rev_3"><a id="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" name="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D"></a><h5 id="LNPCB-GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" class="sect5"><span class="enumeration_section">2.6.1.3</span>使用单个SQLCA</h5>
                     <div>
                        <div class="section">
                           <p><a id="d7799e2828" class="indexterm-anchor"></a><a id="d7799e2832" class="indexterm-anchor"></a>如果您只想为SQLCA使用一个内存区域，则执行此操作的过程取决于您使用的Pro * COBOL版本。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div><a id="LNPCB195"></a><div class="props_rev_3"><a id="GUID-F85437B3-C029-4711-8999-33530662242D" name="GUID-F85437B3-C029-4711-8999-33530662242D"></a><h6 id="LNPCB-GUID-F85437B3-C029-4711-8999-33530662242D" class="sect6"><span class="enumeration_section">2.6.1.3.1</span>版本1.8及更低版本</h6>
                        <div>
                           <div class="section">
                              <p>您必须在全球范围内声明SQLCA。您可以通过修改SQLCA.COB文件，更改行来完成此操作</p><pre class="oac_no_warn" dir="ltr">01 SQLCA。</pre><p>至</p><pre class="oac_no_warn" dir="ltr">01 SQLCA EXTERNAL。</pre><p>或者，您可以包含SQLCA的硬编码定义，从SQLCA.cob复制并进行上述更改。请注意，您仍需要在每个预编译单元中包含SQLCA的定义。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="LNPCB196"></a><div class="props_rev_3"><a id="GUID-AC037535-1828-4372-9148-EFE2FBBA1501" name="GUID-AC037535-1828-4372-9148-EFE2FBBA1501"></a><h6 id="LNPCB-GUID-AC037535-1828-4372-9148-EFE2FBBA1501" class="sect6"><span class="enumeration_section">2.6.1.3.2</span>版本2及更高版本</h6>
                        <div>
                           <div class="section">
                              <p>在Pro * COBOL的更高版本中，不会从文件系统复制SQLCA。它由预编译器生成。如果您需要在这些版本中共享SQLCA结构，而不是此声明：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL包含SQLCA END-EXEC</pre><p>你应该使用以下代码：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL包含SQLCA.ANX END-EXEC</pre><p>这会导致预编译器生成SQLCA结构，并自动添加EXTERNAL关键字。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNPCB197"></a><div class="props_rev_3"><a id="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" name="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462"></a><h5 id="LNPCB-GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" class="sect5"><span class="enumeration_section">2.6.1.4</span>使用单个DATE_FORMAT</h5>
                     <div>
                        <p>您必须在每个程序模块中为DATE使用相同的格式字符串。</p>
                     </div>
                  </div>
               </div><a id="LNPCB198"></a><div class="props_rev_3"><a id="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" name="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9"></a><h4 id="LNPCB-GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" class="sect4"><span class="enumeration_section">2.6.2</span>限制</h4>
                  <div>
                     <p>对显式游标的所有引用必须位于同一程序文件中。您不能对在其他模块中声明的游标执行操作。有关游标的更多信息，请参见第4章。<a id="d7799e2951" class="indexterm-anchor"></a></p>
                     <p>此外，任何包含SQL语句的程序文件都必须具有本地SQL语句范围内的SQLCA。</p>
                  </div>
               </div>
            </div><a id="LNPCB199"></a><div class="props_rev_3"><a id="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" name="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC"></a><h3 id="LNPCB-GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" class="sect3"><span class="enumeration_section">2.7</span>编译和链接</h3>
               <div>
                  <p>要获得可执行程序，必须编译Pro * COBOL生成的源文件，然后将生成的对象模块与SQLLIB和系统特定的Oracle库所需的任何模块相链接。 <a id="d7799e2981" class="indexterm-anchor"></a><a id="d7799e2983" class="indexterm-anchor"></a> 
                  </p>
                  <p>链接器解析对象模块中的符号引用。如果这些引用冲突，则链接失败。当您尝试将第三方软件链接到预编译程序时，可能会发生此类冲突。并非所有第三方软件都与Oracle兼容，因此您可能会遇到问题。请与Oracle支持服务部门联系，了解该软件是否受支持。</p>
                  <p>编译和链接是系统相关的。例如，在某些系统上，必须在编译宿主语言程序时关闭编译器优化。有关说明，请参阅特定于系统的Oracle手册。</p>
               </div>
            </div><a id="LNPCB200"></a><div class="props_rev_3"><a id="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" name="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA"></a><h3 id="LNPCB-GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" class="sect3"><span class="enumeration_section">2.8</span>样本DEPT和EMP表</h3>
               <div>
                  <p>本指南中的大多数完整程序示例使用两个示例数据库表：DEPT和EMP。如果它们不在您的演示目录中，请在运行示例程序之前创建它们。他们的定义如下：<a id="d7799e3014" class="indexterm-anchor"></a><a id="d7799e3018" class="indexterm-anchor"></a><a id="d7799e3022" class="indexterm-anchor"></a><a id="d7799e3024" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CREATE TABLE DEPT（DEPTNO NUMBER（2），DNAME VARCHAR2（14），LOC VARCHAR2（13））; CREATE TABLE EMP（EMPNO NUMBER（4）主键，ENAME VARCHAR2（10），JOB VARCHAR2（9），MGR NUMBER（4），HIREDATE DATE，SAL NUMBER（7,2），COMM COMMBER（7,2），DEPTNO 2号））;</pre></div><a id="LNPCB201"></a><div class="props_rev_3"><a id="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" name="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2"></a><h4 id="LNPCB-GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" class="sect4"><span class="enumeration_section">2.8.1</span>样本DEPT和EMP数据</h4>
                  <div>
                     <p>DEPT和EMP表分别包含以下数据行：</p><pre class="oac_no_warn" dir="ltr">DEPTNO DNAME LOC ------- ---------- --------- 10会计纽约20研究DALLAS 30销售芝加哥40运营波士顿EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO ----- ------- --------- ------ --------- ------ ------  - ----- 7369 SMITH CLERK 7902 17-DEC-80 800 20 7499 ALLEN SALESMAN 7698 20-FEB-81 1600 300 30 7521 WARD SALESMAN 7698 22-FEB-81 1250 500 30 7566 JONES MANAGER 7839 02-APR-81 2975 20 7654 MARTIN SALESMAN 7698 28-SEP-81 1250 1400 30 7698 BLAKE MANAGER 7839 01-MAY-81 2850 30 7782 CLARK MANAGER 7839 09-JUN-81 2450 10 7788 SCOTT ANALYST 7566 19-APR-87 3000 20 7839 KING PRESIDENT 17 -NOV-81 5000 10 7844 TURNER SALESMAN 7698 08-SEP-81 1500 30 7876 ADAMS CLERK 7788 23-MAY-87 1100 20 7900 JAMES CLERK 7698 03-DEC-81 950 30 7902 FORD ANALYST 7566 03-DEC-81 3000 20 7934 MILLER CLERK 7782 23-JAN-82 1300 10</pre></div>
               </div>
            </div><a id="LNPCB202"></a><div class="props_rev_3"><a id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" name="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D"></a><h3 id="LNPCB-GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" class="sect3"><span class="enumeration_section">2.9</span>样本EMP计划：SAMPLE1。PCO</h3>
               <div>
                  <p>熟悉嵌入式SQL的一个好方法是查看程序示例。该程序是SAMPLE1。PCO在<code class="codeph">demo</code>目录中。
                  </p>
                  <p>程序登录到数据库，提示用户输入员工编号，在数据库表EMP中查询员工姓名，工资和佣金。选定的结果存储在主机变量EMP-NAME，SALARY和COMMISSION中。该程序使用主机指示符变量COMM-IND来检测列COMMISSION中的NULL值。</p>
                  <p>然后段落DISPLAY-INFO显示结果。</p>
                  <p>错误7225844  - 以下替代EMP-NAME的替代EMP-NAME</p>
                  <p>COBOL变量USERNAME，PASSWD和EMP-NAME使用VARYING子句声明，这使您可以使用名为VARCHAR的可变长度字符串外部Oracle数据类型。</p>
                  <p>包含SQLCA通信区域以处理错误。如果发生错误，则执行段落SQL-ERROR。</p>
                  <p>除非您将预编译器选项DECLARE_SECTION设置为YES，或选项MODE设置为ANSI，否则使用的BEGIN DECLARE SECTION和END DECLARE SECTION语句是可选的。</p>
                  <p>WHENEVER语句用于处理错误。</p>
                  <p>当用户输入零员工编号时，程序结束<a id="d7799e3104" class="indexterm-anchor"></a> 。
                  </p>
                  <div class="infoboxnote" id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D__GUID-C2DFA7D5-EA8F-4EAF-912C-7AE2EA4AA981">
                     <p class="notep1">注意：</p>
                     <p>为了简化演示此功能，此示例不执行已部署系统通常使用的密码管理技术。在生产环境中，请遵循Oracle数据库密码管理准则，并禁用任何示例帐户。有关密码管理指南和其他安全建议，请参阅<a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span class="italic">Oracle数据库安全指南</span></a> 。
                     </p>
                  </div><pre class="oac_no_warn" dir="ltr">*此程序登录到ORACLE，提示用户输入员工编号，*在数据库中查询员工的姓名，工资和佣金，然后*显示结果。当用户输入0时程序终止。* ID DIVISION。 PROGRAM-ID。 QUERY。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 EMP-REC-VARS。 05 EMP-NAME PIC X（10）变化。 05 EMP-NUMBER PIC S9（4）COMP VALUE ZERO。 05 SALARY PIC S9（5）V99 COMP-3 VALUE ZERO。 05委员会PIC S9（5）V99 COMP-3 VALUE ZERO。 05 COMM-IND PIC S9（4）COMP VALUE ZERO。 EXEC SQL END DECLARE SECTION END-EXEC。 EXEC SQL包含SQLCA END-EXEC。 01 DISPLAY-VARIABLES。 05 D-EMP-NAME PIC X（10）。05 D-SALARY PIC Z（4）9.99。05 D-COMMISSION PIC Z（4）9.99。05 D-EMP-NUMBER PIC 9（4）。01 D-TOTAL-QUERIED PIC 9（4）VALUE ZERO。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。查询循环。显示“”。显示“输入EMP编号（0退出）：”没有进展。接受D-EMP-NUMBER。将D-EMP-NUMBER移至EMP-NUMBER。 IF（EMP-NUMBER = 0）执行签名。向EMP-NAME-ARR移动空间。 EXEC SQL WHENEVER未找到GOTO NO-EMP END-EXEC。 EXEC SQL SELECT ENAME，SAL，NVL（COMM，0）INTO：EMP-NAME，：SALARY，：COMMISSION：COMM-IND from EMP WHERE EMPNO =：EMP-NUMBER END-EXEC。执行显示信息。添加1到D-TOTAL-QUERIED。转到QUERY-LOOP。 NO-EMP。显示“不是有效的员工人数 - 再试一次。”转到QUERY-LOOP。登录。将“SCOTT”移至USERNAME-ARR。移动5到USERNAME-LEN。将“TIGER”转移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE作为用户：”，USERNAME-ARR。 DISPLAY-INFO。显示“”。展示“员工薪酬委员会”。显示“-------- ------ ----------”。将EMP-NAME-ARR移动到D-EMP-NAME。将薪酬转移到D-SALARY。如果COMM-IND = -1显示D-EMP-NAME，D-SALARY，“NULL”ELSE将委托转移到D-COMMISSION显示D-EMP-NAME，D-SALARY，“”，D-COMMISSION END-IF。登出。显示“”。显示“TULLAL NUMBER QUERIED WAS”，D-TOTAL-QUERIED，“。”。显示“”。显示“有一个好日子。”显示“”。EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。 SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">使用SQL通信区域</a></li>
                        <li><a href="precompiler-options.html#GUID-976DED3A-3840-48A5-B5A8-35FB91BF2A0D">模式</a></li>
                        <li><a href="error-handling-and-diagnostics.html#GUID-A947AF06-314B-46B3-9940-A3002EC04039">WHENEVER指令</a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="13259.SDO_NFE-reference.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The MDSYS.SDO_NFE package contains subprograms (functions and procedures) for performing network feature editing."></meta>
      <meta name="description" content="The MDSYS.SDO_NFE package contains subprograms (functions and procedures) for performing network feature editing."></meta>
      <title>SDO_NFE包子程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Topology Data Model and Network Data Model Graph Developer&#39;s Guide"></meta>
      <meta property="og:description" content="The MDSYS.SDO_NFE package contains subprograms (functions and procedures) for performing network feature editing."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Topology Data Model and Network Data Model Graph Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-topology-data-model-and-network-data-model-graph-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T12:24:53-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2003, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94802-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="SDO_NET-reference.html" title="Previous" type="text/html"></link>
      <link rel="next" href="book-index.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph Topology Data Model and Network Data Model Graph Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="TOPOL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="SDO_NET-reference.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="book-index.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">拓扑数据模型和网络数据模型图开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="network-data-model.html" property="item" typeof="WebPage"><span property="name">网络数据模型</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SDO_NFE包子程序</li>
            </ol>
            <a id="GUID-3839A614-3E16-4EC3-B449-68B105AF9136" name="GUID-3839A614-3E16-4EC3-B449-68B105AF9136"></a>
            
            <h2 id="TOPOL-GUID-3839A614-3E16-4EC3-B449-68B105AF9136" class="sect2"><span class="enumeration_chapter">7</span> SDO_NFE封装子程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。</p>
               <p><a id="d64691e22" class="indexterm-anchor"></a><a id="d64691e26" class="indexterm-anchor"></a>要使用这些子程序，您必须了解<a href="network-data-model-graph-overview.html#GUID-D34F1A0C-4D9B-4185-B965-43B218D3F382" title="本章介绍与网络数据模型相关的概念和操作，用于表示在图形中建模为节点和链接（顶点和边）的功能或对象。">网络数据模型图概述中</a>的概念信息，尤其是<a href="network-data-model-graph-overview.html#GUID-ADC9EC6C-A95C-4FEA-93E9-6BE8D79C1403" title="网络功能编辑（NFE）允许您创建和管理NFE模型。NFE模型通过使用Java Swing组件和PL / SQL API可视化和操作功能，扩展了功能建模功能。">使用网络特征编辑（NFE）的特征建模</a> 。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670">SDO_NFE.APPLY_RULE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE">SDO_NFE.CLASSIFY_LINES_BY_SIDE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43">SDO_NFE.CREATE_MODEL_SEQUENCE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-DC7C187A-25F1-4E80-ADBF-33125A654307">SDO_NFE.CREATE_MODEL_STRUCTURE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83">SDO_NFE.CREATE_MODEL_UNDERLYING_NET</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42">SDO_NFE.CREATE_MODEL_WORKSPACE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1">SDO_NFE.DELETE_ALL_FT_LAYERS</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595">SDO_NFE.DELETE_ALL_WORKSPACES</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-D0F828D8-819E-4616-A6DD-91C586E809B5">SDO_NFE.DELETE_MODEL_STRUCTURE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32">SDO_NFE.DELETE_MODEL_WORKSPACE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739">SDO_NFE.DROP_MODEL_SEQUENCE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-260EC3EE-8582-41FD-A52D-10797DB9C943">SDO_NFE.DROP_MODEL_UNDERLYING_NETWORK</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3">SDO_NFE.GET_CONNECTION_POINT_GEOM</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">SDO_NFE.GET_INTERACTION_GROUPS</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-B969999E-63A7-4741-A2A6-B53260B7AD72">SDO_NFE.GET_LINES_MATCH_LP_RULE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A">SDO_NFE.GET_LL_CONN_INTERSECTIONS</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB">SDO_NFE.GET_LP_CONN_INTERSECTIONS</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4">SDO_NFE.GET_MODEL_SEQUENCE_NAME</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC">SDO_NFE.GET_MODEL_TABLE_NAME</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B">SDO_NFE.GET_MODEL_UNDERLYING_NETWORK</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1">SDO_NFE.GET_NEXT_SEQUENCE_VALUE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2">SDO_NFE.GET_POINTS_MATCH_LP_RULE</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A">SDO_NFE.IMPORT_NETWORK</a><br></li>
                  <li class="ulchildlink"><a href="SDO_NFE-reference.html#GUID-0C792CC6-11A7-4434-9B85-18124880E37B">SDO_NFE.SET_MODEL_UNDERLYING_NETWORK</a><br></li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="network-data-model.html#GUID-090C37E3-4092-40A6-8E29-D84DF16765BA" title="本部分介绍Oracle Spatial and Graph的网络数据模型图功能。">网络数据模型</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670" name="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670"></a><h3 id="TOPOL-GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670" class="sect3"><span class="enumeration_section">7.1</span> SDO_NFE.APPLY_RULE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.APPLY_RULE（model_id IN NUMBER，rule_type IN VARCHAR2，rule_id IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>对指定NFE模型中包含的所有功能应用连接规则。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> rule_type</dt>
                        <dd>
                           <p>要应用的连接规则类型： <code class="codeph">RULE_TYPE_LINE</code>或<code class="codeph">RULE_TYPE_POINT</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a> rule_id</dt>
                        <dd>
                           <p>连接规则的ID。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>必须在指定的模型中注册指定的规则。您可以在模型表中或通过Java API注册连接规则。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2A513DB4-E182-43CC-9B55-0EC6699D0670__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例将折线规则应用于NFE模型中符合规则ID 1标识的连接规则的任何交互行。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; rule_type VARCHAR2（1）：= sdo_nfe。RULE_TYPE_LINE_LINE; rule_id NUMBER：= 1; BEGIN sdo_nfe.apply_rule（model_id，rule_type，rule_id）;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE" name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE"></a><h3 id="TOPOL-GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE" class="sect3"><span class="enumeration_section">7.2</span> SDO_NFE.CLASSIFY_LINES_BY_SIDE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CLASSIFY_LINES_BY_SIDE（model_id IN NUMBER，ll_rule_id IN NUMBER，行IN NUMBER，lhs_indexes OUT DBMS_SQL，NUMBER_TABLE，rhs_indexes OUT DBMS_SQL，NUMBER_TABLE）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组与连接线 - 线规则匹配的线要素，此过程将对哪些线位于规则的左侧以及哪些线位于右侧进行分类。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> ll_rule_id</dt>
                        <dd>
                           <p>连接线 - 线规则标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-08A649F4-EA26-4EA8-98A6-0A92280810AF"><!-- --></a>行</dt>
                        <dd>
                           <p>符合规则的线要素集</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-7F84E2FD-61C6-4FDD-9373-6DCB6927C917"><!-- --></a> lhs_indexes</dt>
                        <dd>
                           <p>关联数组，其中将存储位于规则左侧的行的索引（以（索引，索引）的形式）。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a> rhs_indexes</dt>
                        <dd>
                           <p>关联数组，其中将存储位于规则右侧的行的索引。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>必须在指定的模型中注册指定的规则。您可以在模型表中或通过Java API注册连接规则。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例首先获取符合ID为1的规则的所有交互组，然后对这些行进行分类。左侧边线以lhs_indexes输出，而rhs_indexes包含规则的右侧边线。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; ll_rule_id NUMBER：= 1;行SDO_INTERACT_LINE_FEAT_ARRAY; lhs_indexes dbms_sql。NUMBER_TABLE; rhs_indexes dbms_sql。NUMBER_TABLE; inter_grps SDO_INTERACTION_ARRAY; BEGIN  - 获取符合LL规则的交互功能组inter_grps：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_LINE，ll_rule_id）; FOR i IN 1..inter_grps.count循环行：= inter_grps（i）.lines; - 对于每个组，按规则侧对行进行分类。sdo_nfe.classify_lines_by_side（model_id，ll_rule_id，lines，lhs_indexes，rhs_indexes）; END循环;结束;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43" name="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43"></a><h3 id="TOPOL-GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43" class="sect3"><span class="enumeration_section">7.3</span> SDO_NFE.CREATE_MODEL_SEQUENCE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CREATE_MODEL_SEQUENCE（model_id IN NUMBER，owner_name IN VARCHAR2，aequence_name IN VARCHAR2）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>创建并注册模型的序列。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> owner_name</dt>
                        <dd>
                           <p>序列的相关表格。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a> aequence_name</dt>
                        <dd>
                           <p>要创建的序列的名称。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>基表的所有序列都是由<a href="SDO_NFE-reference.html#GUID-DC7C187A-25F1-4E80-ADBF-33125A654307">SDO_NFE.CREATE_MODEL_STRUCTURE</a>函数创建的，但您可能需要创建其他序列（例如功能）。
                     </p>
                     <p>必须存在NFE模型和序列的相关表。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例为ID 1标识的NFE模型和名为FEATURES的表创建序列。</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CREATE_MODEL_SEQUENCE（ '1'， '特征'， 'features_seq'）</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307" name="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307"></a><h3 id="TOPOL-GUID-DC7C187A-25F1-4E80-ADBF-33125A654307" class="sect3"><span class="enumeration_section">7.4</span> SDO_NFE.CREATE_MODEL_STRUCTURE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CREATE_MODEL_STRUCTURE（model_name IN VARCHAR2，edition_mode IN NUMBER，versionable in IN VARCHAR2）RETURN NUMBER;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>创建NFE模型的表和元数据。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_name</dt>
                        <dd>
                           <p>要给lNFE模型的名称。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> edition_mode</dt>
                        <dd>
                           <p>版本模式。必须是<code class="codeph">SDO_NFE.FROM_SCRATCH</code>或<code class="codeph">SDO_NFE.OVER_EXIST_NETWORK</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a>版本化</dt>
                        <dd>
                           <p>如果模型是可版本化的字符串值<code class="codeph">Y</code> ，否则为<code class="codeph">N</code></p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数返回新模型的ID值。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DC7C187A-25F1-4E80-ADBF-33125A654307__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例使用<code class="codeph">SDO_NFE.FROM_SCRATCH</code>编辑模式创建名为<code class="codeph">MODEL01</code>的可版本化模型。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER; model_name VARCHAR2（50）：='MODEL01'; edition_mode NUMBER：= SDO_NFE.FROM_SCRATCH; versionable VARCHAR2（1）：='Y'; BEGIN model_id：= SDO_NFE.create_model_structure（model_name，edition_mode，versionable）;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83" name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83"></a><h3 id="TOPOL-GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83" class="sect3"><span class="enumeration_section">7.5</span> SDO_NFE.CREATE_MODEL_UNDERLYING_NET</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CREATE_MODEL_UNDERLYING_NET（model_id IN NUMBER，network_name IN VARCHAR2，num_hierarchy_levels IN NUMBER，is_directed IN BOOLDEAN，node_with_costs IN BOOLEAN）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>创建空间网络并将其与指定的NFE模型相关联。它还为其节点，链接和路径创建序列，并将它们注册到模型的元数据中。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> network_name</dt>
                        <dd>
                           <p>要创建的网络的名称。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-71F3A836-99A4-4CDC-8939-19039353E501"><!-- --></a> num_hierarchy_levels</dt>
                        <dd>
                           <p>网络的层次级别数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-2500ECA9-0BF6-4BF9-94E6-AACF9513AE5C"><!-- --></a> is_directed</dt>
                        <dd>
                           <p>如果网络是定向的，则为<code class="codeph">TRUE</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a> node_with_costs</dt>
                        <dd>
                           <p>如果网络节点包含成本值，则为<code class="codeph">TRUE</code> 。
                           </p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>必须存在具有指定ID的NFE模型。必须为新创建的网络节点和链接表注册几何元数据。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例为NFE模型创建基础网络，并为网络的链接和节点表注册几何元数据。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; network_name VARCHAR2（50）：='MODEL01'; num_hierarchy_levels NUMBER：= 1; is_directed VARCHAR2（10）：='TRUE'; node_with_costs VARCHAR2（10）：='TRUE'; BEGIN  - 创建底层网络SDO_NFE.create_model_underlying_net（model_id，network_name，num_hierarchy_levels，is_directed，node_with_costs）; - 注册链接和节点表geom元数据SDO_NET.insert_geom_metadata（network_name，SDO_DIM_ARRAY（SDO_DIM_ELEMENT（'LONGITUDE'，-180,180,0.5），SDO_DIM_ELEMENT（'LATITUDE'， -  90,90,0.5）），8307）;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42" name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42"></a><h3 id="TOPOL-GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42" class="sect3"><span class="enumeration_section">7.6</span> SDO_NFE.CREATE_MODEL_WORKSPACE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.CREATE_MODEL_WORKSPACE（model_id IN NUMBER，parent_workspace_name IN VARCHAR2，workspace_name IN VARCHAR2，is_mbr IN VARCHAR2，is_locked IN VARCHAR2，lower_x IN NUMBER，lower_y IN NUMBER，upper_x IN NUMBER，upper_y IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>创建新工作区并将其与NFE模型相关联。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-2EA60F65-5009-4CD3-9B40-CB603D0CCE05"><!-- --></a> parent_workspace_name</dt>
                        <dd>
                           <p>父工作空间的名称。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-9041E46E-F554-4159-AE4B-1A0FF90EC64A"><!-- --></a> workspace_name</dt>
                        <dd>
                           <p>工作区的名称。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-13CEEFF2-8B1B-4B7B-BF69-F7467C9C5909"><!-- --></a> is_mbr</dt>
                        <dd>
                           <p>如果为模型的最小边界矩形（MBR）矩形区域创建工作空间，则字符串为<code class="codeph">TRUE</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-7B48BE16-5E6C-4F72-ACC9-31F7F426CF22"><!-- --></a> is_locked</dt>
                        <dd>
                           <p>如果工作空间已锁定，则字符串为<code class="codeph">TRUE</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-AED9778B-DD12-431A-992E-B6B373ABC283"><!-- --></a> lower_x</dt>
                        <dd>
                           <p>工作空间MBR的下方x纵坐标。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-0BE6CDC7-CCE3-4C9D-B346-549FB000515D"><!-- --></a> lower_y</dt>
                        <dd>
                           <p>工作空间MBR的下y坐标。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-D2A9056C-8C7F-436D-981F-F2A81D8402E9"><!-- --></a> upper_x</dt>
                        <dd>
                           <p>工作空间MBR的上部x纵坐标。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-B639566D-A209-40C3-B884-5CBFB13D5753"><!-- --></a> upper_y</dt>
                        <dd>
                           <p>工作空间MBR的上y坐标。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>必须在启用<code class="codeph">versionable</code>选项的情况下创建NFE模型。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D68977D6-C1D0-4287-8F4E-3E074D01DF42__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例为NFE模型创建工作空间。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; parent_ws_name VARCHAR2（30）：='LIVE'; workspace_name VARCHAR2（30）：='PROJECT_V1'; is_mbr VARCHAR2（1）：='Y'; is_locked VARCHAR2（1）：='N'; lower_x NUMBER：=  -  15.575; lower_y NUMBER：= 15.575; upper_x NUMBER：= -12.825; upper_y NUMBER：= 28.975; BEGIN SDO_NFE.create_model_workspace（model_id，parent_ws_name，workspace_name，is_mbr，is_locked，lower_x，lower_y，upper_x，upper_y）;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1" name="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1"></a><h3 id="TOPOL-GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1" class="sect3"><span class="enumeration_section">7.7</span> SDO_NFE.DELETE_ALL_FT_LAYERS</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DELETE_ALL_FT_LAYERS（model_id IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>删除指定NFE模型中的所有内容。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此过程主要在从数据库中删除模型及其结构之前使用。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例从ID值为1的模型中删除所有内容。</p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DELETE_ALL_FT_LAYERS（1）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595" name="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595"></a><h3 id="TOPOL-GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595" class="sect3"><span class="enumeration_section">7.8</span> SDO_NFE.DELETE_ALL_WORKSPACES</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DELETE_ALL_WORKSPACES（model_id IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>Dropa与指定NFE模型相关的所有工作空间，以及它们与模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此过程主要在从数据库中删除模型及其结构之前使用。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例删除与ID值为1的模型相关的所有工作空间。</p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DELETE_ALL_WORKSPACES（1）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5" name="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5"></a><h3 id="TOPOL-GUID-D0F828D8-819E-4616-A6DD-91C586E809B5" class="sect3"><span class="enumeration_section">7.9</span> SDO_NFE.DELETE_MODEL_STRUCTURE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DELETE_MODEL_STRUCTURE（model_id IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>删除指定NFE模型中的所有表，并删除模型的元数据记录。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>在使用此过程之前，您可能需要执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过执行<a href="SDO_NFE-reference.html#GUID-85CAFF90-9833-4EB2-9CBD-349783FDB595">SDO_NFE.DELETE_ALL_WORKSPACES</a>过程删除模型的工作空间。
                           </p>
                        </li>
                        <li>
                           <p>通过执行<a href="SDO_NFE-reference.html#GUID-A1CD2E4B-30FB-46E6-B94A-5FC1423075B1">SDO_NFE.DELETE_ALL_FT_LAYERS</a>过程删除模型的要素图层。
                           </p>
                        </li>
                        <li>
                           <p>如果模型的编辑模式为<code class="codeph">SDO_NFE.FROM_SCRATCH</code> ，则删除基础网络。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D0F828D8-819E-4616-A6DD-91C586E809B5__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例为ID值为1的模型的结构。</p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DELETE_MODEL_STRUCTURE（1）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32" name="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32"></a><h3 id="TOPOL-GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32" class="sect3"><span class="enumeration_section">7.10</span> SDO_NFE.DELETE_MODEL_WORKSPACE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DELETE_MODEL_WORKSPACE（model_id IN NUMBER，workspace_name IN VARCHAR2）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>删除工作空间及其与指定NFE模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-CB27054E-3A6D-4689-95D7-460B1367E0CF"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> workspace_name</dt>
                        <dd>
                           <p>工作区的名称。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p><code class="codeph">workspace_name</code>必须是指定NFE模型下现有工作空间的名称。工作区的所有分支都将被删除。
                     </p>
                     <p>从xxx_SDO_NFE_MODEL_WORKSPACE视图中删除与模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FEC2D124-5DCB-41B4-9A6A-5E37ADB3DF32__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例从ID为1的NFE模型中删除名为<code class="codeph">PROJECT_V4</code>的工作空间</p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DELETE_MODEL_WORKSPACE（1，'PROJECT_V4'）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739" name="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739"></a><h3 id="TOPOL-GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739" class="sect3"><span class="enumeration_section">7.11</span> SDO_NFE.DROP_MODEL_SEQUENCE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DROP_MODEL_SEQUENCE（model_id IN NUMBER，seq_name IN VARCHAR2）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>删除序列及其与指定NFE模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-CB27054E-3A6D-4689-95D7-460B1367E0CF"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型的ID。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> seq_name</dt>
                        <dd>
                           <p>序列的名称。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>从xxx_SDO_NFE_MODEL_METADATA视图中的SEQUENCE_REG_TAB中注册的表中删除序列与模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B9D5FD6B-13FE-4624-B51E-8E60EADCB739__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例从ID为1的NFE模型中删除名为<code class="codeph">PIPES_FTLAY_ID_SEQ</code>的序列。
                     </p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DROP_MODEL_SEQUENCE（1，'PIPES_FTLAY_ID_SEQ'）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943" name="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943"></a><h3 id="TOPOL-GUID-260EC3EE-8582-41FD-A52D-10797DB9C943" class="sect3"><span class="enumeration_section">7.12</span> SDO_NFE.DROP_MODEL_UNDERLYING_NETWORK</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.DROP_MODEL_UNDERLYING_NETWORK network_name IN VARCHAR2）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>删除网络并删除其与任何NFE模型的关系。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> network_name</dt>
                        <dd>
                           <p>网络名称。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>网络必须绑定至少一个NFE模型..</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-260EC3EE-8582-41FD-A52D-10797DB9C943__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例删除名为<code class="codeph">PIPES</code>的网络，并删除其与任何现有NFE模型的关系。
                     </p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.DROP_MODEL_UNDERLYING_NETWORK（'PIPES'）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3" name="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3"></a><h3 id="TOPOL-GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3" class="sect3"><span class="enumeration_section">7.13</span> SDO_NFE.GET_CONNECTION_POINT_GEOM</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_CONNECTION_POINT_GEOM（conn_intersection IN SDO_INTERACTION）RETURN SDO_GEOMETRY;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组相互作用的特征（线和/或点），计算并返回必须连接它们的点的几何。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> conn_intersection</dt>
                        <dd>
                           <p>交互组功能。在公共空间点处相互作用的线和/或点要素集。（SDO_INTERACTION类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                           </p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此功能主要用于必须连接的经过验证的功能组，因为需要连接规则（请参阅<a href="network-data-model-graph-overview.html#GUID-F473BF70-6DCB-4169-AE4D-A7B8B5382EFB">NFE规则</a> ）。要获得这组功能，请使用<a href="SDO_NFE-reference.html#GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB">SDO_NFE.GET_LP_CONN_INTERSECTIONS</a>作为线路点规则，或使用<a href="SDO_NFE-reference.html#GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A">SDO_NFE.GET_LL_CONN_INTERSECTIONS</a>作为线路规则。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-C559241E-2991-461F-92D7-5D2E7AA8CBC3__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取满足给定线点规则的每个交互组的连接点几何。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; lp_rule_id NUMBER：= 1; inter_grps SDO_INTERACTION_ARRAY; conn_point_geom SDO_GEOMETRY; BEGIN  - 在模型inter_grps中获取符合LP规则的交互功能组：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_POINT，lp_rule_id）; - 遍历交互组FOR i IN 1..inter_grps.count loop  - 获取每个交互组的连接点几何conn_point_geom：= sdo_nfe.get_connection_point_geom（inter_groups（i））; END循环;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78" name="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78"></a><h3 id="TOPOL-GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78" class="sect3"><span class="enumeration_section">7.14</span> SDO_NFE.GET_INTERACTION_GROUPS</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_INTERACTION_GROUPS（model_id IN SDO_NUMBER，rule_type IN VARCHAR2，rule_id IN NUMBER）RETURN SDO_INTERACTION_ARRAY;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>返回在满足指定连接规则的空间点处进行交互的所有要素的组的数组。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> rule_type</dt>
                        <dd>连接规则类型。可能的值： <code class="codeph">SDO_NFE.RULE_TYPE_LINE_LINE</code>或<code class="codeph">SDO_NFE.RULE_TYPE_LINE_POINT</code> 。</dd>
                        <dt class="dlterm"><a name="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a> rule_id</dt>
                        <dd>规则标识符。必须是LINE_LINE_RULE或LINE_POINT_RULE表中的值。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数返回SDO_INTERACTION_ARRAY类型的对象，该对象在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中进行了</a>描述。
                     </p>
                     <p>此函数返回的每组交互特征由在满足指定规则的特定空间点处交互的所有线和点要素组成。</p>
                     <p>通过在特定点返回整组所有交互功能，如果要创建自定义连接功能的方式，此功能可以帮助您，具体取决于哪些其他功能（符合规则或不符合规则）参与指定的交互点。（参见<a href="network-data-model-graph-overview.html#GUID-F473BF70-6DCB-4169-AE4D-A7B8B5382EFB">NFE规则</a>下关于规则决策处理程序的讨论。）
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取满足给定线点规则的交互组。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; lp_rule_id NUMBER：= 1; inter_grps SDO_INTERACTION_ARRAY; BEGIN inter_grps：= sdo_nfe.get_interaction_groups（model_id，END; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72" name="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72"></a><h3 id="TOPOL-GUID-B969999E-63A7-4741-A2A6-B53260B7AD72" class="sect3"><span class="enumeration_section">7.15</span> SDO_NFE.GET_LINES_MATCH_LP_RULE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_LINES_MATCH_LP_RULE（model_id IN SDO_NUMBER，lp_rule_id IN NUMBER，行IN SDO_INTERACT_LINE_FEAT_ARRAY，）RETURN DBMS_SQL.NUMBER_TABLE;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组线要素，计算与连接线点规则匹配的一组线要素。返回DBMS_SQL.NUMBER_TABLE对象，其中输入数组中与行匹配规则匹配的行的索引。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> lp_rule_id</dt>
                        <dd>连接线点规则标识符。必须存在于LINE_POINT_RULE表中。</dd>
                        <dt class="dlterm"><a name="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a>行</dt>
                        <dd>搜索将在其中进行搜索的一系列线要素。（SDO_INTERACT_LINE_FEAT_ARRAY类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数主要在<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">SDO_NFE.GET_INTERACTION_GROUPS</a>函数之后使用，该函数返回一组混合线<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">要素</a> ，其中某些线<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">要素</a>与特定连接规则匹配，而有些则没有。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B969999E-63A7-4741-A2A6-B53260B7AD72__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例从交互组中查找符合连接线点规则的行。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; lp_rule_id NUMBER：= 1;行SDO_INTERACT_LINE_FEAT_ARRAY; match_lines dbms_sql。NUMBER_TABLE; inter_grps SDO_INTERACTION_ARRAY; BEGIN  - 查找交互组inter_grps：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_LINE，1）; FOR i IN 1..inter_grps.count循环行：= inter_grps（i）.lines; match_lines：= sdo_nfe.get_lines_match_lp_rule（model_id，lp_rule_id，lines）; END循环;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A" name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A"></a><h3 id="TOPOL-GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A" class="sect3"><span class="enumeration_section">7.16</span> SDO_NFE.GET_LL_CONN_INTERSECTIONS</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_LL_CONN_INTERSECTIONS（model_id IN SDO_NUMBER，ll_rule_id IN NUMBER，interaction_grp IN OUT SDO_INTERACTION，rule_lhs_lines_indexes IN DBMS_SQL.NUMBER_TABLE，rule_rhs_lines_indexes IN DBMS_SQL.NUMBER_TABLE，rule_points_indexes IN DBMS_SQL.NUMBER_TABLE，）RETURN SDO_INTERACTION_ARRAY;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组交互特征（线和点），此函数计算可根据指定的连接线条规则连接的这些特征的子组，并返回可连接特征组的集合。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> ll_rule_id</dt>
                        <dd>连接线路规则标识符..必须存在于LINE_LINE_RULE表中。</dd>
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a> interaction_grp</dt>
                        <dd>一组交互功能。（SDO_INTERACTION类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                        </dd>
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-EC85E513-86ED-4AC4-A711-91F6AF3532CF"><!-- --></a> rule_lhs_lines_indexes</dt>
                        <dd>在交互组中的线要素中，与线条线规则的左侧匹配的线的索引。</dd>
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-BDEFFE9B-8D18-40C0-B4D5-5AF0B62CC3AE"><!-- --></a> rule_rhs_lines_indexes</dt>
                        <dd>在交互组中的线要素中，与线条线规则的右侧匹配的线的索引。</dd>
                        <dt class="dlterm"><a name="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-23308EC3-191E-4768-9851-F92C27301686"><!-- --></a> rule_points_indexes</dt>
                        <dd>在交互组中的点要素中，与线条线规则中的点要素规范匹配的点的索引。这些点是可连接组的构造中要考虑的点。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数返回SDO_INTERACTION_ARRAY对象。（SDO_INTERACTION_ARRAY类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                     </p>
                     <p>可以使用<a href="SDO_NFE-reference.html#GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE">SDO_NFE.CLASSIFY_LINES_BY_SIDE</a>过程获得LHS和RHS行的索引。可以使用<a href="SDO_NFE-reference.html#GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2">SDO_NFE.GET_POINTS_MATCH_LP_RULE</a>函数获取点的索引。
                     </p>
                     <p>当在模型中创建折线规则（使用Java API）时，此功能默认注册在<a href="network-data-model-graph-overview.html#GUID-19DD0793-146A-47E2-97C9-8FF8867A29A2" title="规则决策处理程序表包含有关在执行连接规则（行 - 行或行 - 点）时作为决策处理程序执行的Java类和/或PL / SQL过程的名称的信息。">规则决策处理程序表中</a> 。但是，此功能可以由任何其他用户功能替换，该功能以自定义方式计算可连接功能组。有关自定义连接（规则决策处理程序）的信息，请参阅<a href="network-data-model-graph-overview.html#GUID-F473BF70-6DCB-4169-AE4D-A7B8B5382EFB">NFE规则</a>下有关规则决策处理程序的信息。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D4B82E71-D6C2-48C0-9B94-1AFD7522E22A__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例为每个与给定换行符规则匹配的交互组获取可连接要素组的集合。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; ll_rule_id NUMBER：= 1; rule_lhs_lines_indexes dbms_sql。NUMBER_TABLE; rule_rhs_lines_indexes dbms_sql。NUMBER_TABLE; rule_points_indexes dbms_sql。NUMBER_TABLE; conn_interacs SDO_INTERACTION_ARRAY; inter_grps SDO_INTERACTION_ARRAY; BEGIN  - 在模型inter_grps中获取符合LL规则的交互功能组：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_LINE，ll_rule_id）; FOR i IN 1..inter_grps.count循环 - 在LL规则（LHS，RHS）中对线要素进行分类。sdo_nfe.classify_lines_by_side（model_id，ll_rule_id，inter_grps（i）.lines，rule_lhs_lines_indexes，rule_rhs_lines_indexes）; - 获取与LL规则匹配的特定点要素。rule_points_indexes：= sdo_nfe.get_points_match_lp_rule（model_id，1，inter_grps（i）.points）; - 获取可根据LL规则连接的功能组。conn_interacs：= sdo_nfe.get_ll_conn_intersections（model_id，ll_rule_id，inter_grps（i），rule_lhs_lines_indexes，rule_rhs_lines_indexes，rule_points_indexes）; END循环;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB" name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB"></a><h3 id="TOPOL-GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB" class="sect3"><span class="enumeration_section">7.17</span> SDO_NFE.GET_LP_CONN_INTERSECTIONS</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_LP_CONN_INTERSECTIONS（model_id IN SDO_NUMBER，lp_rule_id IN NUMBER，interaction_grp IN OUT SDO_INTERACTION，rule_lhs_lines_indexes IN DBMS_SQL.NUMBER_TABLE，rule_rhs_lines_indexes IN DBMS_SQL.NUMBER_TABLE，rule_points_indexes IN DBMS_SQL.NUMBER_TABLE，）RETURN SDO_INTERACTION_ARRAY;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组交互特征（线和点），此函数计算可根据指定的连接线点规则连接的这些特征的子组，并返回可连接特征组的集合。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> lp_rule_id</dt>
                        <dd>连接线点规则标识符..必须存在于LINE_POINT_RULE表中。</dd>
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a> interaction_grp</dt>
                        <dd>一组交互功能。（SDO_INTERACTION类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                        </dd>
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-EC85E513-86ED-4AC4-A711-91F6AF3532CF"><!-- --></a> rule_lhs_lines_indexes</dt>
                        <dd>在交互组中的线要素中，与线点规则的左侧匹配的线的索引。</dd>
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-BDEFFE9B-8D18-40C0-B4D5-5AF0B62CC3AE"><!-- --></a> rule_rhs_lines_indexes</dt>
                        <dd>在交互组中的线要素中，与线点规则的右侧匹配的线的索引。</dd>
                        <dt class="dlterm"><a name="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-23308EC3-191E-4768-9851-F92C27301686"><!-- --></a> rule_points_indexes</dt>
                        <dd>在交互组中的点要素中，与线点规则中的点要素规范匹配的点的索引。这些点是可连接组的构造中要考虑的点。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数返回SDO_INTERACTION_ARRAY对象。（SDO_INTERACTION_ARRAY类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                     </p>
                     <p>可以使用<a href="SDO_NFE-reference.html#GUID-6BE8BF53-A98E-430F-AE86-01BA8991A3AE">SDO_NFE.CLASSIFY_LINES_BY_SIDE</a>过程获得LHS和RHS行的索引。可以使用<a href="SDO_NFE-reference.html#GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2">SDO_NFE.GET_POINTS_MATCH_LP_RULE</a>函数获取点的索引。
                     </p>
                     <p>当在模型中创建线点规则（使用Java API）时，此功能默认注册在<a href="network-data-model-graph-overview.html#GUID-19DD0793-146A-47E2-97C9-8FF8867A29A2" title="规则决策处理程序表包含有关在执行连接规则（行 - 行或行 - 点）时作为决策处理程序执行的Java类和/或PL / SQL过程的名称的信息。">规则决策处理程序表中</a> 。但是，此功能可以由任何其他用户功能替换，该功能以自定义方式计算可连接功能组。有关自定义连接（规则决策处理程序）的信息，请参阅<a href="network-data-model-graph-overview.html#GUID-F473BF70-6DCB-4169-AE4D-A7B8B5382EFB">NFE规则</a>下有关规则决策处理程序的信息。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-36E3EEF6-B073-4225-A9B8-1A443D38DAFB__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取可以根据每个交互组的给定线点规则连接的功能组。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; lp_rule_id NUMBER：= 1; rule_lines_indexes dbms_sql。NUMBER_TABLE; rule_points_indexes dbms_sql。NUMBER_TABLE; conn_interacs SDO_INTERACTION_ARRAY; inter_grps SDO_INTERACTION_ARRAY; BEGIN  - 在模型inter_grps中获取符合LP规则的交互功能组：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_POINT，lp_rule_id）; - 对于每个组：FOR i IN 1..inter_grps.count loop  - 获取与LP规则匹配的特定线要素。rule_lines_indexes：= sdo_nfe.get_lines_match_lp_rule（model_id，lp_rule_id，inter_grps（i）.lines）; - 获取与LP规则匹配的特定点要素。rule_points_indexes：= sdo_nfe.get_points_match_lp_rule（model_id，lp_rule_id，inter_grps（i）.points）; - 获取可根据LP规则连接的功能组。conn_interacs：= sdo_nfe.get_lp_conn_intersections（model_id，lp_rule_id，inter_grps（i），rule_lines_indexes，rule_points_indexes）; END循环;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4" name="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4"></a><h3 id="TOPOL-GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4" class="sect3"><span class="enumeration_section">7.18</span> SDO_NFE.GET_MODEL_SEQUENCE_NAME</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_MODEL_SEQUENCE_NAME（model_id IN SDO_NUMBER，tab_name IN VARCHAR2）RETURN VARCHAR2;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>返回指定模型表的序列名称。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>NFE模型标识符。</dd>
                        <dt class="dlterm"><a name="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> tab_name</dt>
                        <dd>模型的表名称。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>表名必须存在于TABLE_REG_TAB表中，其序列名必须存在于SEQUENCE_REG_TAB表中。使用<a href="SDO_NFE-reference.html#GUID-DC7C187A-25F1-4E80-ADBF-33125A654307">SDO_NFE.CREATE_MODEL_STRUCTURE</a>创建新模型时，所有模型的表和序列都会自动注册到相应的视图和表中。执行<a href="SDO_NFE-reference.html#GUID-2C77945F-3AE4-4477-8E2C-75DF7211CB43">SDO_NFE.CREATE_MODEL_SEQUENCE时</a> ，将注册模型表的序列。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EBA0A97C-043E-43E2-A4AE-547B6BF5E5B4__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取为包含ID为1的NFE模型的要素类的表定义的序列名称。</p><pre class="oac_no_warn" dir="ltr">SELECT SDO_NFE.GET_MODEL_SEQUENCE_NAME（1，sdo_nfe.get_model_table_name（1，SDO_NFE.FT_CLASS））;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC" name="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC"></a><h3 id="TOPOL-GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC" class="sect3"><span class="enumeration_section">7.19</span> SDO_NFE.GET_MODEL_TABLE_NAME</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_MODEL_TABLE_NAME（model_id IN SDO_NUMBER，table_type IN VARCHAR2）RETURN VARCHAR2;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>返回NFE模型的指定类型的表的名称。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>NFE模型标识符。</dd>
                        <dt class="dlterm"><a name="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> table_type</dt>
                        <dd>要返回其名称的表的类型。例如，要素类表的值为<code class="codeph">SDO_NFE.FT_CLASS</code> 。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>表名必须存在于TABLE_REG_TAB表中，其序列名必须存在于SEQUENCE_REG_TAB表中。使用<a href="SDO_NFE-reference.html#GUID-DC7C187A-25F1-4E80-ADBF-33125A654307">SDO_NFE.CREATE_MODEL_STRUCTURE</a>创建新模型时，所有模型的表和序列的名称将自动注册到相应的视图和表中。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8BB7170D-31C2-4207-9FB6-684C3C75F8FC__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取包含ID为1的NFE模型中要素类的表的名称。</p><pre class="oac_no_warn" dir="ltr">SELECT SDO_NFE.GET_MODEL_TABLE_NAME（1，SDO_NFE.FT_CLASS）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B" name="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B"></a><h3 id="TOPOL-GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B" class="sect3"><span class="enumeration_section">7.20</span> SDO_NFE.GET_MODEL_UNDERLYING_NETWORK</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_MODEL_UNDERLYING_NETWORK（model_id IN SDO_NUMBER）RETURN VARCHAR2;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>返回与NFE模型关联的网络的名称。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>在创建过程中，网络与NFE模型相关联，对<a href="SDO_NFE-reference.html#GUID-AF7A7031-4BC0-4552-81FD-0CBEE68E3D83">SDO_NFE.FROM_SCRATCH</a>模式中的模型使用<a href="SDO_NFE-reference.html#GUID-0C792CC6-11A7-4434-9B85-18124880E37B">SDO_NFE.CREATE_MODEL_UNDERLYING_NET</a> ，或者对SDO_NFE.OVER_EXIST_NETWORK模式中的模型使用<a href="SDO_NFE-reference.html#GUID-0C792CC6-11A7-4434-9B85-18124880E37B">SDO_NFE.SET_MODEL_UNDERLYING_NETWORK</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取与现有NFE模型关联的基础网络。</p><pre class="oac_no_warn" dir="ltr">SELECT SDO_NFE.get_model_underlying_network（1）FROM DUAL;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1" name="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1"></a><h3 id="TOPOL-GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1" class="sect3"><span class="enumeration_section">7.21</span> SDO_NFE.GET_NEXT_SEQUENCE_VALUE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_NEXT_SEQUENCE_VALUE（sequence_name IN VARCHAR2，seq_value_increment IN NUMBER）返回号码;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>返回将第二个参数的值添加到指定序列的当前值所得的值。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> sequence_name</dt>
                        <dd>序列的名称。</dd>
                        <dt class="dlterm"><a name="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> seq_value_increment</dt>
                        <dd>要添加到<code class="codeph">sequence_name</code>的当前值的整数值。（如果指定的值为负数，则从当前值中减去。）
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数不会更改指定序列的INCREMENT BY值或该序列的当前值。</p>
                     <p>此功能可用于管理连续序列号的块。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4F3499C2-B246-41E5-B1E4-8F51CC6F7CB1__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例返回将10添加到名为MY_SEQ的序列的当前值所导致的值。</p><pre class="oac_no_warn" dir="ltr">SELECT SDO_NFE.GET_NEXT_SEQUENCE_VALUE（'my_seq'，10）FROM DUAL;</pre><p>如果MY_SEQ的当前值为100，则此示例返回值110（100 + 10）。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2" name="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2"></a><h3 id="TOPOL-GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2" class="sect3"><span class="enumeration_section">7.22</span> SDO_NFE.GET_POINTS_MATCH_LP_RULE</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.GET_POINTS_MATCH_LP_RULE（model_id IN SDO_NUMBER，lp_rule_id IN NUMBER，指向SDO_INTERACT_POINT_FEAT_ARRAY，）RETURN DBMS_SQL.NUMBER_TABLE;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>给定一组点要素，此函数计算与连接线点规则匹配的一组点要素。返回DBMS_SQL.NUMBER_TABLE对象，其中输入数组中与线点规则匹配的点的索引。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> lp_rule_id</dt>
                        <dd>连接线点规则标识符。必须存在于LINE_POINT_RULE表中。</dd>
                        <dt class="dlterm"><a name="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a>分</dt>
                        <dd>搜索将发生的点要素数组。（SDO_INTERACT_POINT_FEAT_ARRAY类型在<a href="network-data-model-graph-overview.html#GUID-CE45084C-810E-431D-95CE-F7BDBF500C39">用于NFE连接规则的数据类型中</a>描述。）
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>此函数主要在<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">SDO_NFE.GET_INTERACTION_GROUPS</a>函数之后使用，该函数返回一组混合线<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">要素</a> ，其中某些线<a href="SDO_NFE-reference.html#GUID-D42EBC7A-5846-40C3-9CA5-CB57420C5B78">要素</a>与特定连接规则匹配，而有些则没有。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-A1D43879-584C-4BA6-8D26-EEB91AFD6EE2__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例获取与线点规则匹配的特定点要素。</p><pre class="oac_no_warn" dir="ltr">DECLARE model_id NUMBER：= 1; lp_rule_id NUMBER：= 1; rule_points_indexes dbms_sql。NUMBER_TABLE; inter_grps SDO_INTERACTION_ARRAY; BEGIN  - 在模型inter_grps中获取符合LP规则的交互功能组：= sdo_nfe.get_interaction_groups（model_id，sdo_nfe。RULE_TYPE_LINE_POINT，lp_rule_id）; - 对于每个组：FOR i IN 1..inter_grps.count循环 - 获取与LP规则匹配的特定点要素。rule_points_indexes：= sdo_nfe.get_points_match_lp_rule（model_id，lp_rule_id，inter_grps（i）.points）; END循环;结束; /</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A" name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A"></a><h3 id="TOPOL-GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A" class="sect3"><span class="enumeration_section">7.23</span> SDO_NFE.IMPORT_NETWORK</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.IMPORT_NETWORK（model_id IN NUMBER，model_id IN NUMBER，network_from IN VARCHAR2，line_ft_layer_id IN NUMBER，line_ft_class_id IN NUMBER，point_ft_layer_id IN NUMBER，point_ft_class_id IN NUMBER）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>将网络元素从现有网络复制到NFE模型的基础网络（在SDO_NFE.FROM_SCRATCH模式下创建），从线要素类（ <span class="italic">line_ft_class_id</span> ）转换线要素中的每个链接，并从该点转换点要素中的每个节点要素类（ <span class="italic">point_ft_class_id</span> ）..
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>NFE模型标识符。</dd>
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-C129E55A-71B8-43F2-8924-93D5BD1E067B"><!-- --></a> network_from</dt>
                        <dd>要导入的网络的名称。</dd>
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-39AB1612-495C-47E3-BE60-0C5E7A796B3B"><!-- --></a> line_ft_layer_id</dt>
                        <dd>新创建的线要素的要素图层ID（从链接元素创建）。</dd>
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-A7933277-EE7A-41A9-B125-DA852676E7F6"><!-- --></a> line_ft_class_id</dt>
                        <dd>新创建的线要素的要素类ID。</dd>
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-1F08A5F0-66FD-49F5-8E30-296AE156BF0C"><!-- --></a> point_ft_layer_id</dt>
                        <dd>新创建的点要素的要素图层ID（从节点元素创建）。</dd>
                        <dt class="dlterm"><a name="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-6C426787-AEA9-45B3-A4D1-DDCF541346B0"><!-- --></a> point_ft_class_id</dt>
                        <dd>新创建的点要素的要素类ID。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>线和点要素的要素类必须已存在于NFE模型中。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3897E271-BCBE-4E7C-A17E-EDD73766290A__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例将名为<code class="codeph">NET01</code>的网络导入由ID 1标识的模型。将使用要素图层10和11以及要素类5和6为每个链接和节点创建线和点要素。
                     </p><pre class="oac_no_warn" dir="ltr">EXECUTE SDO_NFE.import_network（1，'NET01'，10,5,11,6）;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B" name="GUID-0C792CC6-11A7-4434-9B85-18124880E37B"></a><h3 id="TOPOL-GUID-0C792CC6-11A7-4434-9B85-18124880E37B" class="sect3"><span class="enumeration_section">7.24</span> SDO_NFE.SET_MODEL_UNDERLYING_NETWORK</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-4030836E-F658-4122-AC3F-38587B1FD56E">格式</p><pre class="oac_no_warn" dir="ltr">SDO_NFE.SET_MODEL_UNDERLYING_NETWORK（model_id IN SDO_NUMBER network_name IN VARCHAR2）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-799B2C9C-5F1B-416E-B8EE-DB618B8D3C2B">描述</p>
                     <p>将网络关联为NFE模型的底层网络。（必须已在SDO_NFE.OVER_EXIST_NETWORK模式下创建模型。）</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-97F0D5EE-F1F3-47E5-BF7E-EBEFCF8B1D93">参数</p>
                     <dl class="0.76* 3.24*">
                        <dt class="dlterm"><a name="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-997CC9BE-D871-4838-8C1A-9566DB754C7E"><!-- --></a> model_id</dt>
                        <dd>
                           <p>NFE模型标识符。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-2494A28B-AB53-4AE1-BF19-813CFC427AC1"><!-- --></a> network_name</dt>
                        <dd>与模型关联的网络的名称。</dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-CEEB314B-F4C5-4925-93C5-B2983D227F2C">使用说明</p>
                     <p>另请参见<a href="SDO_NFE-reference.html#GUID-FE8C662E-FD2F-468E-AC19-CA1B75A02A9B">SDO_NFE.GET_MODEL_UNDERLYING_NETWORK</a>函数。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0C792CC6-11A7-4434-9B85-18124880E37B__GUID-97FF0F35-C69B-42AF-A424-7375CC217BEA">例子</p>
                     <p>以下示例....</p><pre class="oac_no_warn" dir="ltr">执行 ...;</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="SDO_NFE-reference.html#GUID-3839A614-3E16-4EC3-B449-68B105AF9136" title="MDSYS.SDO_NFE程序包包含用于执行网络功能编辑的子程序（函数和过程）。">SDO_NFE包子程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html><html id="01108.DBMS_SQLPA.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The DBMS_SQLPA package provides the interface to implement the SQL Performance Analyzer."></meta>
      <meta name="description" content="The DBMS_SQLPA package provides the interface to implement the SQL Performance Analyzer."></meta>
      <title>DBMS_SQLPA</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="PL/SQL Packages and Types Reference"></meta>
      <meta property="og:description" content="The DBMS_SQLPA package provides the interface to implement the SQL Performance Analyzer."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="PL/SQL Packages and Types Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-packages-and-types-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-25T11:24:34-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96430-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="DBMS_SQLDIAG.html" title="Previous" type="text/html"></link>
      <link rel="next" href="DBMS_SQLQ.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference"></meta>
    <meta name="dcterms.isVersionOf" content="ARPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="DBMS_SQLDIAG.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="DBMS_SQLQ.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">PL / SQL包和类型参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">DBMS_SQLPA</li>
            </ol>
            <a id="GUID-9AAF3672-1CF3-4354-AF41-5BA50BA295F8" name="GUID-9AAF3672-1CF3-4354-AF41-5BA50BA295F8"></a><a id="ARPLS229"></a><a id="ARPLS229"></a>
            
            <h2 id="ARPLS-GUID-9AAF3672-1CF3-4354-AF41-5BA50BA295F8" class="sect2"><span class="enumeration_chapter">160</span> DBMS_SQLPA</h2>
         </header>
         <div class="ind">
            <div>
               <p>DBMS_SQLPA包提供了实现SQL Performance Analyzer的接口。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="DBMS_SQLPA.html#GUID-667CF74A-E86B-4265-A724-1C2E0DD15C8E" title="DBMS_SQLPA包提供了一个容量，可帮助用户预测系统环境更改对SQL工作负载性能的影响。该界面允许用户构建并比较两个不同版本的工作负载性能，分析两个版本之间的差异，并取消屏蔽可能受更改影响的SQL语句。">概观</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_SQLPA.html#GUID-B9BAEC64-7F97-4D22-BA48-0CE7B16F6DFB" title="该程序包可供PUBLIC使用，并执行自己的安全检查。所有分析任务接口（XXX_ANALYSIS_TASK）都需要特权ADVISOR。">安全模型</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_SQLPA.html#GUID-69B40030-0C63-4666-B139-F2028AA1DC80" title="该表列出了DBMS_SQLPA子程序并简要描述了它们。">DBMS_SQLPA子程序摘要</a></p>
                  </li>
               </ul>
            </div><a id="ARPLS68346"></a><a id="ARPLS68346"></a><div class="props_rev_3"><a id="GUID-667CF74A-E86B-4265-A724-1C2E0DD15C8E" name="GUID-667CF74A-E86B-4265-A724-1C2E0DD15C8E"></a><h3 id="ARPLS-GUID-667CF74A-E86B-4265-A724-1C2E0DD15C8E" class="sect3"><span class="enumeration_section">160.1</span> DBMS_SQLPA概述</h3>
               <div>
                  <p><code class="codeph">DBMS_SQLPA</code>包提供了一个容量，可帮助用户预测系统环境更改对SQL工作负载性能的影响。该界面允许用户构建并比较两个不同版本的工作负载性能，分析两个版本之间的差异，并取消屏蔽可能受更改影响的SQL语句。
                  </p>
                  <div class="section">
                     <p>该软件包提供了一个面向任务的接口来实现SQL Performance Analyzer。例如</p>
                     <ol>
                        <li>
                           <p>您可以使用<a href="DBMS_SQLPA.html#GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655" title="这些函数创建一个顾问程序任务来处理和分析一个或多个SQL语句。">CREATE_ANALYSIS_TASK函数</a>为单个语句或一组SQL语句创建分析任务</p>
                        </li>
                        <li>
                           <p><a href="DBMS_SQLPA.html#GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" title="此函数和过程执行先前创建的分析任务，函数版本返回新的执行名称。">EXECUTE_ANALYSIS_TASK函数和过程</a>执行先前创建的分析任务。
                           </p>
                        </li>
                        <li>
                           <p><a href="DBMS_SQLPA.html#GUID-8524B515-E14F-4F76-9458-F2E579D5A08B" title="此过程显示分析任务的结果。">REPORT_ANALYSIS_TASK函数</a>显示分析任务的结果。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ARPLS68347"></a><a id="ARPLS68347"></a><div class="props_rev_3"><a id="GUID-B9BAEC64-7F97-4D22-BA48-0CE7B16F6DFB" name="GUID-B9BAEC64-7F97-4D22-BA48-0CE7B16F6DFB"></a><h3 id="ARPLS-GUID-B9BAEC64-7F97-4D22-BA48-0CE7B16F6DFB" class="sect3"><span class="enumeration_section">160.2</span> DBMS_SQLPA安全模型</h3>
               <div>
                  <p>该程序包可供<code class="codeph">PUBLIC</code>使用，并执行自己的安全检查。所有分析任务接口（ <code class="codeph">XXX_ANALYSIS_TASK</code> ）都需要特权<code class="codeph">ADVISOR</code> 。</p>
               </div>
            </div><a id="ARPLS68348"></a><a id="ARPLS68349"></a><a id="ARPLS68349"></a><a id="ARPLS68348"></a><div class="props_rev_3"><a id="GUID-69B40030-0C63-4666-B139-F2028AA1DC80" name="GUID-69B40030-0C63-4666-B139-F2028AA1DC80"></a><h3 id="ARPLS-GUID-69B40030-0C63-4666-B139-F2028AA1DC80" class="sect3"><span class="enumeration_section">160.3</span> DBMS_SQLPA子程序摘要</h3>
               <div>
                  <p>该表列出了<code class="codeph">DBMS_SQLPA</code>子程序并简要描述了它们。
                  </p>
                  <div class="tblformal" id="GUID-69B40030-0C63-4666-B139-F2028AA1DC80__GUID-83A07D8B-E294-489E-AA42-8E4170417739">
                     <p class="titleintable">表160-1 DBMS_SQLPA包子程序</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_SQLPA包子程序" width="100%" border="1" summary="This table lists the DBMS_SQLPA subprograms in alphabetical order and briefly describes them." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d911026e450">子程序</th>
                              <th align="left" valign="bottom" width="57%" id="d911026e453">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e458" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94" title="此过程取消当前正在执行的分析任务。从任务中删除所有中间结果数据。">CANCEL_ANALYSIS_TASK程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e458 d911026e453 ">
                                 <p>取消当前正在执行的一个或多个SQL语句的任务分析</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e470" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655" title="这些函数创建一个顾问程序任务来处理和分析一个或多个SQL语句。">CREATE_ANALYSIS_TASK函数</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e470 d911026e453 ">
                                 <p>创建顾问程序任务以处理和分析一个或多个SQL语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e482" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE" title="此过程将删除SQL分析任务。该任务及其所有结果数据将被删除。">DROP_ANALYSIS_TASK程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e482 d911026e453 ">
                                 <p>删除SQL分析任务</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e494" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" title="此函数和过程执行先前创建的分析任务，函数版本返回新的执行名称。">EXECUTE_ANALYSIS_TASK功能和程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e494 d911026e453 ">
                                 <p>执行以前创建的分析任务</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e506" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63" title="此过程将中断当前正在执行的分析任务。不会从任务中删除所有中间结果数据。">INTERRUPT_ANALYSIS_TASK程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e506 d911026e453 ">
                                 <p>中断当前正在执行的分析任务</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e518" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-8524B515-E14F-4F76-9458-F2E579D5A08B" title="此过程显示分析任务的结果。">REPORT_ANALYSIS_TASK功能</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e518 d911026e453 ">
                                 <p>显示分析任务的结果</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e530" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-AAC78840-3899-479E-BA89-D5688A118244" title="在当前未执行的分析任务上调用此过程以准备重新执行。">RESET_ANALYSIS_TASK程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e530 d911026e453 ">
                                 <p>将当前正在执行的分析任务重置为其初始状态</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e542" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878" title="此过程恢复先前中断或FAILED（有致命错误）任务执行。">RESUME_ANALYSIS_TASK程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e542 d911026e453 ">
                                 <p>恢复先前中断的分析任务，该任务是为处理SQL调优集而创建的。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e557" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-24792620-7642-48DA-9154-37D10AE58AC2" title="此过程设置SQL分析任务参数值。">SET_ANALYSIS_TASK_PARAMETER程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e557 d911026e453 ">
                                 <p>设置SQL分析任务参数值</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d911026e569" headers="d911026e450 ">
                                 <p><a href="DBMS_SQLPA.html#GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8" title="此过程设置SQL分析任务参数的默认值。">SET_ANALYSIS_DEFAULT_PARAMETER程序</a></p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d911026e569 d911026e453 ">
                                 <p>设置SQL分析任务参数的默认值</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="ARPLS68350"></a><a id="ARPLS68351"></a><a id="ARPLS68351"></a><a id="ARPLS68350"></a><div class="props_rev_3"><a id="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94" name="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94"></a><h4 id="ARPLS-GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94" class="sect4"><span class="enumeration_section">160.3.1</span> CANCEL_ANALYSIS_TASK程序</h4>
                  <div>
                     <p>此过程取消当前正在执行的分析任务。从任务中删除所有中间结果数据。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94__GUID-C0CFCF29-0C47-48E8-AA7B-29BCCEF8901F">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.CANCEL_ANALYSIS_TASK（task_name IN VARCHAR2）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94__GUID-6C5B722E-7E0C-47A9-867F-E778BE13F644">参数</p>
                        <div class="tblformal" id="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94__GUID-F28D40BC-6241-46B5-9436-1316B467F119">
                           <p class="titleintable">表160-2 CANCEL_ANALYSIS_TASK过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="CANCEL_ANALYSIS_TASK过程参数" width="100%" border="1" summary="This table describes Parameters used by the DBMS_SQLPA.CANCEL_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e690">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e693">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e698" headers="d911026e690 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e698 d911026e693 ">
                                       <p>要取消的任务的名称</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CBC17582-41B4-4856-986F-7F08FEDFFF94__GUID-90E53C72-1215-4B52-AF3A-426C1C03C323">例子</p>
                        <p>在需要停止执行任务时取消任务，并且不需要查看任何已完成的结果：</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.CANCEL_ANALYSIS_TASK（：my_task）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68352"></a><a id="ARPLS68353"></a><a id="ARPLS68353"></a><a id="ARPLS68352"></a><div class="props_rev_3"><a id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655" name="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655"></a><h4 id="ARPLS-GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655" class="sect4"><span class="enumeration_section">160.3.2</span> CREATE_ANALYSIS_TASK函数</h4>
                  <div>
                     <p>这些函数创建一个顾问程序任务来处理和分析一个或多个SQL语句。</p>
                     <div class="section">
                        <p>您可以使用此功能的不同形式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在给定文本的情况下为单个语句创建分析任务。</p>
                           </li>
                           <li>
                              <p>在给定其标识符的情况下，从游标缓存为单个语句创建分析任务。</p>
                           </li>
                           <li>
                              <p>在给定一系列快照标识符的情况下，从工作负载存储库为单个语句创建分析任务。</p>
                           </li>
                           <li>
                              <p>为SQL调优集创建分析任务。</p>
                           </li>
                        </ul>
                        <p>在所有情况下，该函数都会创建一个顾问程序任务并设置其参数。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655__GUID-DB6FE5E3-E778-4DAB-B11D-E6B6340D232E">句法</p>
                        <p>SQL文本格式。调用此函数的形式以准备对给定其文本的单个语句的分析。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.CREATE_ANALYSIS_TASK（sql_text IN CLOB，bind_list IN sql_binds：= NULL，parsing_schema IN VARCHAR2：= NULL，task_name IN VARCHAR2：= NULL，description IN VARCHAR2：= NULL）RETURN VARCHAR2;</pre><p>SQL ID格式。调用此函数形式以准备从给定其标识符的游标缓存中分析单个语句。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.CREATE_ANALYSIS_TASK（sql_id IN VARCHAR2，plan_hash_value IN NUMBER：= NULL，task_name IN VARCHAR2：= NULL，con_name IN VARCHAR2 DEFAULT，description IN VARCHAR2：= NULL）RETURN VARCHAR2;</pre><p>工作负载存储库格式。调用此函数形式以在给定一系列快照标识符的情况下准备分析来自工作负载存储库的单个语句。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.CREATE_ANALYSIS_TASK（dbid IN NUMBER DEFAULT，begin_snap IN NUMBER，end_snap IN NUMBER，sql_id IN VARCHAR2，plan_hash_value IN NUMBER：= NULL，task_name IN VARCHAR2：= NULL，description IN VARCHAR2：= NULL）con_name IN VARCHAR2 DEFAULT，RETURN VARCHAR2;</pre><p>SQLSET格式。调用此函数形式以准备SQL调优集的分析。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.CREATE_ANALYSIS_TASK（sqlset_name IN VARCHAR2，basic_filter IN VARCHAR2：= NULL，con_name IN VARCHAR2 DEFAULT，order_by IN VARCHAR2：= NULL，top_sql IN VARCHAR2：= NULL，task_name IN VARCHAR2：= NULL，description IN VARCHAR2：= NULL sqlset_owner IN VARCHAR2 ：= NULL）RETURN VARCHAR2;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655__GUID-1C402A38-AC69-4FE8-A84D-AFCA99A9726A">参数</p>
                        <div class="tblformal" id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655__GUID-A9C192F9-7D02-4C56-B101-020A3C4391A1">
                           <p class="titleintable">表160-3 <span class="italic"><span class="bold">CREATE_ANALYSIS_TASK函数参数</span></span></p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="CREATE_ANALYSIS_TASK函数参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.CREATE_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e857">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e860">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e865" headers="d911026e857 ">
                                       <p><code class="codeph">SQL_TEXT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e865 d911026e860 ">
                                       <p>SQL语句的文本</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e873" headers="d911026e857 ">
                                       <p><code class="codeph">bind_list</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e873 d911026e860 ">
                                       <p>一组绑定值</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e881" headers="d911026e857 ">
                                       <p><code class="codeph">parsing_schema</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e881 d911026e860 ">
                                       <p>可以编译语句的模式的名称</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e889" headers="d911026e857 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e889 d911026e860 ">
                                       <p>可选的分析任务名称</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e897" headers="d911026e857 ">
                                       <p><code class="codeph">DBID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e897 d911026e860 ">
                                       <p>导入或<code class="codeph">PDB-level AWR</code>数据的<code class="codeph">DBID</code> 。如果为<code class="codeph">NULL</code> ，则使用当前数据库<code class="codeph">DBID</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e917" headers="d911026e857 ">
                                       <p><code class="codeph">con_name</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e917 d911026e860 ">
                                       <p>SPA任务的容器。语义取决于函数格式：</p>
                                       <p>对于SQL ID格式，此参数指定数据库从中获取SQL语句以供SPA使用的容器。 SPA将分析此容器中的语句。如果为null，则数据库使用当前PDB进行SPA分析。</p>
                                       <p>对于AWR格式，此参数指定数据库从其AWR数据中获取用于SPA的SQL语句的容器。 SPA将分析此容器中的语句。如果为null，则数据库使用当前PDB进行SPA分析。</p>
                                       <p>以下陈述适用于所有函数格式：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>在非CDB中，将忽略此参数。</p>
                                          </li>
                                          <li>
                                             <p>在PDB中，此参数必须为null或与PDB的容器名称匹配。否则，会发生错误。</p>
                                          </li>
                                          <li>
                                             <p>在CDB根目录中，此参数必须为null或与此CDB中容器的容器名称匹配。否则，会发生错误。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e941" headers="d911026e857 ">
                                       <p><code class="codeph">描述</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e941 d911026e860 ">
                                       <p>SQL分析任务的说明，最多256个字符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e949" headers="d911026e857 ">
                                       <p><code class="codeph">SQL_ID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e949 d911026e860 ">
                                       <p>SQL语句的标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e957" headers="d911026e857 ">
                                       <p><code class="codeph">plan_hash_value</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e957 d911026e860 ">
                                       <p>SQL执行计划的哈希值</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e965" headers="d911026e857 ">
                                       <p><code class="codeph">begin_snap</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e965 d911026e860 ">
                                       <p>开始快照标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e973" headers="d911026e857 ">
                                       <p><code class="codeph">end_snap</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e973 d911026e860 ">
                                       <p>结束快照标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e982" headers="d911026e857 ">
                                       <p><code class="codeph">sqlset_name</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e982 d911026e860 ">
                                       <p>SQL调整集名称</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e990" headers="d911026e857 ">
                                       <p><code class="codeph">basic_filter</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e990 d911026e860 ">
                                       <p>SQL谓词用于从SQL调优集中过滤SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e998" headers="d911026e857 ">
                                       <p><code class="codeph">ORDER_BY</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e998 d911026e860 ">
                                       <p>所选SQL的Order-by子句</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1006" headers="d911026e857 ">
                                       <p><code class="codeph">top_sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1006 d911026e860 ">
                                       <p>过滤和排名后的前N SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1014" headers="d911026e857 ">
                                       <p><code class="codeph">sqlset_owner</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1014 d911026e860 ">
                                       <p>SQL调优集的所有者，或当前架构所有者的<code class="codeph">NULL</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655__GUID-FBE8A5BB-C9C6-4841-A96C-2997D01918C8">返回值</p>
                        <p>用户唯一的SQL分析任务名称（两个不同的用户可以为其顾问任务指定相同的名称）。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655__GUID-0B436275-F8E3-499F-82C7-FA7A998490ED">例子</p><pre class="oac_no_warn" dir="ltr">变量stmt_task VARCHAR2（64）;变量sts_task VARCHAR2（64）; -  Sql文本格式EXEC：stmt_task：= DBMS_SQLPA.CREATE_ANALYSIS_TASK（sql_text =&gt;'从sales s中选择quantity_sold，时间t，其中s.time_id = t.time_id和s.time_id = TO_DATE（'''24-NOV-00'' ）'）; -  Sql id格式（游标缓存）EXEC：stmt_task：= DBMS_SQLPA.CREATE_ANALYSIS_TASK（sql_id =&gt;'ay1m3ssvtrh24'）; - 工作负载存储库格式exec：stmt_task：= DBMS_SQLPA.CREATE_ANALYSIS_TASK（begin_snap =&gt; 1，end_snap =&gt; 2，sql_id =&gt;'ay1m3ssvtrh24'）; -  Sql调整集格式（首先我们需要加载STS，然后分析它）EXEC：sts_task：= DBMS_SQLPA.CREATE_ANALYSIS_TASK（ -  sqlset_name =&gt;'my_workload'， -  order_by =&gt;'BUFFER_GETS'， -  description =&gt;'process缓冲区排序的工作量得到'）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68354"></a><a id="ARPLS68355"></a><a id="ARPLS68355"></a><a id="ARPLS68354"></a><div class="props_rev_3"><a id="GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE" name="GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE"></a><h4 id="ARPLS-GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE" class="sect4"><span class="enumeration_section">160.3.3</span> DROP_ANALYSIS_TASK过程</h4>
                  <div>
                     <p>此过程将删除SQL分析任务。该任务及其所有结果数据将被删除。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE__GUID-049750D2-B9A4-447A-989D-4F593428B540">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.DROP_ANALYSIS_TASK（task_name IN VARCHAR2）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE__GUID-79930DD2-A607-489A-8CEB-FDBFFDE198EC">参数</p>
                        <div class="tblformal" id="GUID-8E2AFE1D-300A-49B5-8AD2-BA26FBD74AEE__GUID-98722473-9441-4DBC-A308-D23AC3EB74D0">
                           <p class="titleintable">表160-4 DROP_ANALYSIS_TASK过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DROP_ANALYSIS_TASK过程参数" width="100%" border="1" summary="This table describes Parameters used by the DBMS_SQLPA.DROP_TUNING_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e1144">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e1147">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1152" headers="d911026e1144 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1152 d911026e1147 ">
                                       <p>要删除的分析任务的名称</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68356"></a><a id="ARPLS68357"></a><a id="ARPLS68358"></a><a id="ARPLS68359"></a><a id="ARPLS68360"></a><a id="ARPLS68361"></a><a id="ARPLS68362"></a><a id="ARPLS68357"></a><a id="ARPLS68358"></a><a id="ARPLS68359"></a><a id="ARPLS68360"></a><a id="ARPLS68361"></a><a id="ARPLS68362"></a><a id="ARPLS68356"></a><div class="props_rev_3"><a id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" name="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058"></a><h4 id="ARPLS-GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" class="sect4"><span class="enumeration_section">160.3.4</span> EXECUTE_ANALYSIS_TASK功能和过程</h4>
                  <div>
                     <p>此函数和过程执行先前创建的分析任务，函数版本返回新的执行名称。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058__GUID-C3899DEC-3C8D-4114-B9BE-675ED16B8F45">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name IN VARCHAR2，execution_type IN VARCHAR2：='test execute'，execution_name IN VARCHAR2：= NULL，execution_params IN dbms_advisor.argList：= NULL，execution_desc IN VARCHAR2：= NULL）RETURN VARCHAR2;</pre><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name IN VARCHAR2，execution_type IN VARCHAR2：='test execute'，execution_name IN VARCHAR2：= NULL，execution_params IN dbms_advisor.argList：= NULL，execution_desc IN VARCHAR2：= NULL）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058__GUID-09A451B3-AE9E-4B2C-ABB6-606DBB38A2BB">参数</p>
                        <div class="tblformal" id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058__GUID-230162A8-05B9-49F2-AB3E-23E335EDA6F7">
                           <p class="titleintable">表160-5 EXECUTE_ANALYSIS_TASK函数和过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="EXECUTE_ANALYSIS_TASK函数和过程参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.EXECUTE_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e1282">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e1285">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1290" headers="d911026e1282 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1290 d911026e1285 ">
                                       <p>要执行的任务的标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1298" headers="d911026e1282 ">
                                       <p><code class="codeph">execution_type</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1298 d911026e1285 ">
                                       <p>该功能要执行的操作的类型。如果为<code class="codeph">NULL</code> ，则默认为<code class="codeph">DEFAULT_EXECUTION_TYPE</code>参数的值。可能的值是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">[TEST]</code> <code class="codeph">EXECUTE</code> - 测试执行每个SQL语句并收集其执行计划和执行统计信息。生成的计划和统计信息将存储在顾问程序框架中。这是默认值。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> - 为SQL工作负载中的每个语句生成解释计划。这类似于<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>命令。生成的计划将与任务相关联地存储在顾问程序框架中。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">COMPARE</code> <code class="codeph">[PERFORMANCE]</code> - 分析和比较两个版本的SQL性能数据。性能数据是通过测试执行或生成SQL语句的解释计划生成的。当任务中已存在两次<code class="codeph">EXPLAIN_PLAN</code>或<code class="codeph">TEST_EXECUTE</code>类型的执行时，请使用此选项</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">CONVERT SQLSET</code> - 用于读取SQL调优集中捕获的统计信息，并将其建模为任务执行。当您希望避免执行SQL语句时，可以使用此方法，因为实验的有效数据已存在于SQL调整集中。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1354" headers="d911026e1282 ">
                                       <p><code class="codeph">execution_name</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1354 d911026e1285 ">
                                       <p>用于限定和识别执行的名称。如果未指定，它将由顾问程序生成并由函数返回。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1362" headers="d911026e1282 ">
                                       <p><code class="codeph">execution_params</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1362 d911026e1285 ">
                                       <p>指定执行的参数列表（名称，值）。执行参数仅对指定它们的执行有效。它们将覆盖存储在任务中的参数的值（通过<a href="DBMS_SQLPA.html#GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8" title="此过程设置SQL分析任务参数的默认值。">SET_ANALYSIS_DEFAULT_PARAMETER过程</a>设置）。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1377" headers="d911026e1282 ">
                                       <p><code class="codeph">execution_desc</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1377 d911026e1285 ">
                                       <p>描述执行的256长度字符串</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058__GUID-FE18B944-E4C6-4C75-B5B7-F78DE1254D4F">使用说明</p>
                        <p>SQL性能分析器任务可以执行多次，而无需重置它。例如，创建任务以对SQL工作负载执行更改影响分析时，必须先执行创建的任务，然后再对系统环境进行任何更改，以构建将用作性能参考的工作负载版本分析。完成更改后，需要第二次执行才能构建工作负载的更改后版本。最后，必须第三次执行任务，让顾问分析并比较两个版本中工作负载的性能。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058__GUID-7CFE7E17-473D-4BBF-A164-8A5D63ED08EF">例子</p>
                        <p>1。创建一个旨在进行变更影响分析的任务</p><pre class="oac_no_warn" dir="ltr">EXEC：tname：= DBMS_SQLPA.CREATE_ANALYSIS_TASK（sqlset_name =&gt;'my_sts'）;</pre><p>2。制作基线或更改前执行</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name =&gt;：tname，execution_type =&gt;'test execute'，execution_name =&gt;'before_change'）;</pre><p>3。做出改变</p><pre class="oac_no_warn" dir="ltr">...</pre><p>4。制作工作负载性能的更改后版本</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name =&gt;：tname， -  execution_type =&gt;'test execute'，execution_name =&gt;'after_change'）</pre><p>5。比较两个版本的工作负载</p>
                        <p>默认情况下，我们总是比较最后两次执行的结果。SQL Performance Analyzer使用<code class="codeph">elapsed_time</code>作为默认度量标准进行比较。这里我们将其更改为<code class="codeph">buffer_gets</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.SET_ANALYSIS_TASK_PARAMETER（：tname，'comparison_metric'，'buffer_gets'）; EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name =&gt;：tname， -  execution_type =&gt;'compare performance'， -  execution_name =&gt;'after_change'）;</pre><p>如果要显式指定要比较的两个执行以及要使用的比较度量，请使用以下调用。</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（task_name =&gt;：tname， -  execution_type =&gt;'compare performance'，execution_params =&gt; dbms_advisor.arglist（'execution_name1'，'before_change'，'execution_name2'，'after_change'，'comparison_metric'，'buffer_gets' ））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68363"></a><a id="ARPLS68364"></a><a id="ARPLS68364"></a><a id="ARPLS68363"></a><div class="props_rev_3"><a id="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63" name="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63"></a><h4 id="ARPLS-GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63" class="sect4"><span class="enumeration_section">160.3.5</span> INTERRUPT_ANALYSIS_TASK程序</h4>
                  <div>
                     <p>此过程将中断当前正在执行的分析任务。不会从任务中删除所有中间结果数据。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63__GUID-F2621991-F87B-457B-81FB-D9CF7E28FE01">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.INTERRUPT_ANALYSIS_TASK（task_name IN VARCHAR2）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63__GUID-69242DFE-EBBC-447B-A321-AE1D77C29F0F">参数</p>
                        <div class="tblformal" id="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63__GUID-2E416B00-C10A-41AF-A1A4-4A15F03C40C7">
                           <p class="titleintable">表160-6 INTERRUPT_ANALYSIS_TASK过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="INTERRUPT_ANALYSIS_TASK过程参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.INTERRUPT_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e1536">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e1539">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1544" headers="d911026e1536 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1544 d911026e1539 ">
                                       <p>要中断的分析任务的标识符</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BE5A3E82-13D5-4046-BA0B-C0A029911C63__GUID-0E2AA1EC-DFF1-4F2D-9029-45796DDBD001">例子</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_SQLPA.INTERRUPT_ANALYSIS_TASK（：my_task）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68365"></a><a id="ARPLS68366"></a><a id="ARPLS68366"></a><a id="ARPLS68365"></a><div class="props_rev_3"><a id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B" name="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B"></a><h4 id="ARPLS-GUID-8524B515-E14F-4F76-9458-F2E579D5A08B" class="sect4"><span class="enumeration_section">160.3.6</span> REPORT_ANALYSIS_TASK功能</h4>
                  <div>
                     <p>此过程显示分析任务的结果。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-855FA38B-CB63-462B-809E-F18996BD8DCC">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.REPORT_ANALYSIS_TASK（task_name IN VARCHAR2，输入IN VARCHAR2：='TEXT'，级别IN VARCHAR2：='TYPICAL'，部分IN VARCHAR2：='SUMMARY'，object_id IN NUMBER：= NULL，top_sql IN NUMBER：= 100，execution_name IN VARCHAR2：= NULL，task_owner IN VARCHAR2：= NULL，order_by IN VARCHAR2：= NULL）RETURN CLOB;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-6B965F29-D226-4D73-91E8-44FEA041DAFE">参数</p>
                        <div class="tblformal" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-3BF7830F-2A69-4F29-8B9D-3D78DCDFDC61">
                           <p class="titleintable">表160-7 REPORT_ANALYSIS_TASK函数参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="REPORT_ANALYSIS_TASK函数参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.REPORT_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e1666">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e1669">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1674" headers="d911026e1666 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1674 d911026e1669 ">
                                       <p>要报告的任务的名称</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1682" headers="d911026e1666 ">
                                       <p><code class="codeph">类型</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1682 d911026e1669 ">
                                       <p>要生成的报告的类型。可能的值为<code class="codeph">TEXT</code> （默认）， <code class="codeph">HTML</code> ， <code class="codeph">XML</code>和<code class="codeph">ACTIVE</code> （请参阅使用说明）。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1702" headers="d911026e1666 ">
                                       <p><code class="codeph">水平</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1702 d911026e1669 ">
                                       <p>报告中的详细程度：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">ALL</code> - 所有SQL的详细信息</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">BASIC</code> - 目前与典型相同</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">CHANGED</code> - 仅具有更改性能的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">CHANGED_PLANS</code> - 仅包含计划更改的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ERRORS</code> - 仅包含错误的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">IMPROVED</code> - 只改进了SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">REGRESSED</code> - 只回归SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TIMEOUT</code> - 仅在执行期间超时的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TYPICAL</code> （默认） - 显示有关所分析的每个语句的信息，包括更改和错误</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">UNCHANGED</code> - 只有性能不变的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">UNCHANGED_PLANS</code> - 仅包含未更改计划的SQL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">UNSUPPORTED</code> - 仅SPA不支持SQL</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1772" headers="d911026e1666 ">
                                       <p><code class="codeph">部分</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1772 d911026e1669 ">
                                       <p>（可选）将报告限制为单个部分（所有部分均为<code class="codeph">ALL</code> ）：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">SUMMARY</code> （默认） - 仅限工作负载摘要</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ALL</code> - 关于SQL的摘要和详细信息</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1794" headers="d911026e1666 ">
                                       <p><code class="codeph">OBJECT_ID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1794 d911026e1669 ">
                                       <p>表示调优集（STS）中给定SQL的顾问程序框架对象的标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1802" headers="d911026e1666 ">
                                       <p><code class="codeph">top_sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1802 d911026e1669 ">
                                       <p>生成报告的STS中的SQL语句数</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1810" headers="d911026e1666 ">
                                       <p><code class="codeph">execution_name</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1810 d911026e1669 ">
                                       <p>要使用的任务执行的名称。如果为<code class="codeph">NULL</code> ，则将为上次执行任务生成报告。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1821" headers="d911026e1666 ">
                                       <p><code class="codeph">task_owner</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1821 d911026e1669 ">
                                       <p>相关分析任务的所有者。默认为当前架构所有者。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e1829" headers="d911026e1666 ">
                                       <p><code class="codeph">ORDER_BY</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e1829 d911026e1669 ">
                                       <p>如何在报表中对SQL语句进行排序（摘要和正文）。可能的值：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">CHANGE_DIFF</code> - 根据比较度量标准，通过SQL性能的变化差异对SQL语句进行排序</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">NULL</code> （默认值） - 通过影响工作负载来排序SQL语句</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_IMPACT</code> - 通过更改对SQL的影响来排序SQL语句</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">WORKLOAD_IMPACT</code> - 与<code class="codeph">NULL</code>相同</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">METRIC_DELTA</code> - 与<code class="codeph">CHANGE_DIFF</code>相同</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-A86FA6C0-D33F-47B0-85F2-9E42412B9D09">返回值</p>
                        <p>包含所需报告的<code class="codeph">CLOB</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-5656B555-4504-4225-80F0-34F2B8C74886">使用说明</p>
                        <p><code class="codeph">ACTIVE</code>报告具有类似于Enterprise Manager的丰富交互式用户界面，而不需要任何EM安装。构建的报告文件是<code class="codeph">HTML</code>格式，因此大多数现代浏览器都可以解释它。首次查看报告时，Web浏览器会透明地下载为活动报告供电的代码，因此查看它需要外部连接。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8524B515-E14F-4F76-9458-F2E579D5A08B__GUID-735CB16F-CF2A-444E-822E-C352AFDB184C">例子</p><pre class="oac_no_warn" dir="ltr">- 获取单一陈述案例的整个报告。从双重中选择DBMS_SQLPA.REPORT_ANALYSIS_TASK（：stmt_task）; - 显示sts案例的摘要。SELECT DBMS_SQLPA.REPORT_ANALYSIS_TASK（：sts_task，'TEXT'，'TYPICAL'，'SUMMARY'）FROM DUAL; - 告诉我对我感兴趣的陈述的调查结果。从双重中选择DBMS_SQLPA.REPORT_ANALYSIS_TASK（：sts_task，'TEXT'，'TYPICAL'，'ALL'，5）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68367"></a><a id="ARPLS68368"></a><a id="ARPLS68368"></a><a id="ARPLS68367"></a><div class="props_rev_3"><a id="GUID-AAC78840-3899-479E-BA89-D5688A118244" name="GUID-AAC78840-3899-479E-BA89-D5688A118244"></a><h4 id="ARPLS-GUID-AAC78840-3899-479E-BA89-D5688A118244" class="sect4"><span class="enumeration_section">160.3.7</span> RESET_ANALYSIS_TASK程序</h4>
                  <div>
                     <p>在当前未执行的分析任务上调用此过程以准备重新执行。</p>
                     <div class="section">
                        <p>将删除所有中间结果数据。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AAC78840-3899-479E-BA89-D5688A118244__GUID-797F1B97-87DA-458C-AC83-D2D55547210A">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.RESET_ANALYSIS_TASK（task_name IN VARCHAR2）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AAC78840-3899-479E-BA89-D5688A118244__GUID-91B7BE5A-A98F-4BA4-9671-59D45105FD57">参数</p>
                        <div class="tblformal" id="GUID-AAC78840-3899-479E-BA89-D5688A118244__GUID-4487F3DB-8C14-439F-9C29-96C89D1BFC34">
                           <p class="titleintable">表160-8 RESET_ANALYSIS_TASK过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RESET_ANALYSIS_TASK过程参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.RESET_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e2002">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e2005">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2010" headers="d911026e2002 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2010 d911026e2005 ">
                                       <p>要重置的分析任务的标识符</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AAC78840-3899-479E-BA89-D5688A118244__GUID-0D8BCA69-7C69-43B3-A3F8-5D872836A162">例子</p><pre class="oac_no_warn" dir="ltr">- 重置并重新执行任务EXEC DBMS_SQLPA.RESET_ANALYSIS_TASK（：sts_task）; - 重新执行任务EXEC DBMS_SQLPA.EXECUTE_ANALYSIS_TASK（：sts_task）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68369"></a><a id="ARPLS68370"></a><a id="ARPLS68370"></a><a id="ARPLS68369"></a><div class="props_rev_3"><a id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878" name="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878"></a><h4 id="ARPLS-GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878" class="sect4"><span class="enumeration_section">160.3.8</span> RESUME_ANALYSIS_TASK程序</h4>
                  <div>
                     <p>此过程恢复先前中断或<code class="codeph">FAILED</code> （有致命错误）任务执行。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878__GUID-23222FEB-6143-4252-AC3E-1943D0230CE4">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.RESUME_ANALYSIS_TASK（task_name IN VARCHAR2，basic_filter IN VARCHAR2：= NULL）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878__GUID-C4459150-D4F7-4B2C-A7B3-8C1FBD48F658">参数</p>
                        <div class="tblformal" id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878__GUID-FEF1B95E-2319-44B9-9E8B-5A3DE8DF3408">
                           <p class="titleintable">表160-9 RESUME_ANALYSIS_TASK过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="RESUME_ANALYSIS_TASK过程参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.RESUME_ANALYSIS_TASK subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e2136">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e2139">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2144" headers="d911026e2136 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2144 d911026e2139 ">
                                       <p>要恢复的分析任务的标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2152" headers="d911026e2136 ">
                                       <p><code class="codeph">basic_filter</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2152 d911026e2139 ">
                                       <p>用于从SQL调优集中过滤SQL的SQL谓词。请注意，此过滤器将与调用<a href="DBMS_SQLPA.html#GUID-9C3DB798-3F19-4467-8582-1AAFC32EC655" title="这些函数创建一个顾问程序任务来处理和分析一个或多个SQL语句。">CREATE_ANALYSIS_TASK函数</a>时指定的基本过滤器（参数<code class="codeph">basic_filter</code> ）一起应用。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878__GUID-24F0A25B-8FF6-4805-968D-6EA3756A60FC">使用说明</p>
                        <p>不支持恢复单个SQL分析任务（创建用于分析单个SQL语句与SQL调整集相比的任务）。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DA06D2F1-EFFC-4C50-A607-887FAE238878__GUID-BA88BF06-388D-4CB3-91D1-0E804C0011C7">例子</p><pre class="oac_no_warn" dir="ltr">- 中断任务EXEC DBMS_SQLPA.INTERRUPT_ANALYSIS_TASK（：conc_task）; - 一旦任务中断，我们可以选择重置，恢复或检查结果，然后决定。对于这个例子，我们将恢复。EXEC DBMS_SQLPA.RESUME_ANALYSIS_TASK（：conc_task）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68371"></a><a id="ARPLS68372"></a><a id="ARPLS68372"></a><a id="ARPLS68371"></a><div class="props_rev_3"><a id="GUID-24792620-7642-48DA-9154-37D10AE58AC2" name="GUID-24792620-7642-48DA-9154-37D10AE58AC2"></a><h4 id="ARPLS-GUID-24792620-7642-48DA-9154-37D10AE58AC2" class="sect4"><span class="enumeration_section">160.3.9</span> SET_ANALYSIS_TASK_PARAMETER程序</h4>
                  <div>
                     <p>此过程设置SQL分析任务参数值。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-24792620-7642-48DA-9154-37D10AE58AC2__GUID-A39BF69B-F174-4D7E-B9DB-DB03BDE799F3">句法</p>
                        <p>此过程形式更新<code class="codeph">VARCHAR2</code>类型的SQL分析参数的值。
                        </p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.SET_ANALYSIS_TASK_PARAMETER（task_name IN VARCHAR2，参数IN VARCHAR2，值IN VARCHAR2，test_execute_dop IN NUMBER DEFAULT 0，compare_resultset IN BOOLEAN DEFAULT TRUE）;</pre><p>此过程形式更新<code class="codeph">NUMBER</code>类型的SQL分析参数的值。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.SET_ANALYSIS_TASK_PARAMETER（task_name IN VARCHAR2，参数IN VARCHAR2，值IN NUMBER test_execute_dop IN NUMBER DEFAULT 0，compare_resultset IN BOOLEAN DEFAULT TRUE）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-24792620-7642-48DA-9154-37D10AE58AC2__GUID-B51B8919-A176-4E3E-BAB6-437858EB82A2">参数</p>
                        <div class="tblformal" id="GUID-24792620-7642-48DA-9154-37D10AE58AC2__GUID-7E219FE3-09A6-4EBE-835E-BC43BCC71FE8">
                           <p class="titleintable">表160-10 SET_ANALYSIS_TASK_PARAMETER过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SET_ANALYSIS_TASK_PARAMETER过程参数" width="100%" border="1" summary="This table describes the parameters used by the DBMS_SQLPA.SET_ANALYSIS_TASK_PARAMETER subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e2301">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e2304">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2309" headers="d911026e2301 ">
                                       <p><code class="codeph">任务名称</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2309 d911026e2304 ">
                                       <p>要执行的任务的标识符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2317" headers="d911026e2301 ">
                                       <p><code class="codeph">参数</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2317 d911026e2304 ">
                                       <p>要设置的参数的名称。可以通过此过程设置的可能分析参数是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">APPLY_CAPTURED_COMPILENV</code> ：指示顾问程序是否可以使用SQL语句捕获的编译环境。默认值为0（即<code class="codeph">NO</code> ）。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">BASIC_FILTER</code> ：SQL调优集的基本过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">CELL_SIMULATION_ENABLED</code> ：有关更多详细信息，请参阅<code class="codeph">ADMIN</code>目录中的帮助程序脚本<code class="codeph">tcellsim.sql</code> 。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">COMPARISON_METRIC</code> ：指定要在性能比较中使用的执行统计信息的表达式（示例： <code class="codeph">buffer_gets</code> ， <code class="codeph">cpu_time</code> + <code class="codeph">buffer_gets</code> * 10）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DATABASE_LINK</code> ：可以设置为<code class="codeph">PUBLIC</code>数据库链接的全局名称。设置后，SQL Performance Analyzer将通过将SQL语句发送到远程数据库进行远程处理，将数据库链接用于所有<code class="codeph">TEST EXECUTE</code>和<code class="codeph">EXPLAIN PLAN</code>操作。分析结果仍将存储在本地数据库中。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DAYS_TO_EXPIRE</code> ：删除任务之前的天数</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DEFAULT_EXECUTION_TYPE</code> ：当<a href="DBMS_SQLPA.html#GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" title="此函数和过程执行先前创建的分析任务，函数版本返回新的执行名称。">EXECUTE_ANALYSIS_TASK函数和过程</a>未指定任何任务时，任务将默认为此类执行。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2395" headers="d911026e2301 ">
                                       <p><code class="codeph">parameter</code> （续）
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2395 d911026e2304 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">DISABLE_MULTI_EXEC</code> ：多次执行SQL语句，然后对运行时统计信息求平均值。将此参数设置为<code class="codeph">TRUE</code>可禁用此功能。在这种情况下，SQL调优集中的每个SQL只执行一次。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTE_TRIGGERS</code> ：将此参数设置为<code class="codeph">TRUE</code>以在FULLDML模式下执行所有语句级触发器。如果参数设置为<code class="codeph">FALSE</code> ，则即使在测试执行的FULLDML模式下也不会执行触发器。由于可能执行触发器而导致的任何更改始终由SPA回滚。此参数的默认值为<code class="codeph">FALSE</code> 。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_DAYS_TO_EXPIRE</code> ：删除任务执行前的天数（不删除任务）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTE_FULLDML</code> ： <code class="codeph">TRUE</code>完全执行DML语句，包括获取行锁和修改行; <code class="codeph">FALSE</code> （默认值）仅执行DML的查询部分而不修改数据。如果为<code class="codeph">TRUE</code> ，SQL Performance Analyzer将在DML执行后发出回滚，以防止DML进行持久更改。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_NAME1</code> ：要分析的第一个任务执行的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_NAME2</code> ：要分析的第二个任务执行的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">LOCAL_TIME_LIMIT</code> ：每语句超时（秒）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">METRIC_DELTA_THRESHOLD</code> ：更改前后SQL性能指标之间差异的阈值。默认值为零。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">NUM_ROWS_TO_FETCH</code> ：指定要为SQL查询提取的行数。您可以使用以下值之一：</p>
                                             <ul style="list-style-type:disc">
                                                <li>
                                                   <p><code class="codeph">ALL_ROWS</code> ：获取SQL查询的所有行</p>
                                                </li>
                                                <li>
                                                   <p><code class="codeph">AVERAGE</code> ：结果行数计算为STS中每个SQL处理的总行数与总执行次数之比</p>
                                                </li>
                                                <li>
                                                   <p><code class="codeph">AUTO</code> ：结果行数使用STS中捕获的优化器环境的<code class="codeph">optimizer_mode</code>参数值确定。如果<code class="codeph">optimizer_mode</code>值为<code class="codeph">ALL_ROWS</code> ，则将获取所有结果行。如果其值为<code class="codeph">FIRST_ROWS_n</code> ，则SPA将获取<code class="codeph">n</code>结果行。</p>
                                                </li>
                                                <li>
                                                   <p><code class="codeph">A valid number</code> ：获取SQL查询中指定的确切行数</p>
                                                </li>
                                             </ul>
                                             <p>默认值为<code class="codeph">ALL_ROWS</code> 。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">PLAN_FILTER</code> ：SQL调优集的计划过滤器（有关可能的值，请参阅<code class="codeph">SELECT_SQLSET</code> ）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">PLAN_LINES_COMPARISON</code> ：</p>
                                             <p>- <code class="codeph">ALWAYS</code> - 在所有情况下逐行比较计划<code class="codeph">phv2</code> <code class="codeph">AUTO</code> -Line by line比较计划仅当<code class="codeph">phv2</code>不可用且<code class="codeph">phv1</code>不同时 - <code class="codeph">NONE</code> （默认） - 仅当<code class="codeph">phv</code>未知时逐行比较计划</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE1</code> ：SQL调优集的第一个排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE2</code> ：SQL调优集的第二种可能的排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE3</code> ：SQL调优集的第三种可能的排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">REPLACE_SYSDATE_WITH</code> ：返回SPA任务执行中对<code class="codeph">SYSDATE</code>所有调用的固定日期。您可以使用以下值之一：</p>
                                             <ul style="list-style-type:disc">
                                                <li>
                                                   <p><code class="codeph">CURRENT_SYSDATE</code> ： <code class="codeph">SYSDATE</code>调用返回当前日期。
                                                   </p>
                                                </li>
                                                <li>
                                                   <p><code class="codeph">SQLSET_SYSDATE</code> ： <code class="codeph">SYSDATE</code>调用返回STS中列<code class="codeph">LAST_EXEC_START_TIME</code>的值</p>
                                                </li>
                                             </ul>
                                             <p>默认值为<code class="codeph">CURRENT_SYSDATE</code> 。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RESUME_FILTER</code> ：除<code class="codeph">BASIC_FILTER</code>之外的SQL调优集的额外过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_IMPACT_THRESHOLD</code> ：对SQL语句的更改影响的阈值。与上一个参数相同，但在SQL语句的级别。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_LIMIT</code> ：要处理的最大SQL语句数</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_PERCENTAGE</code> ：SQL调优集语句的百分比过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQLSET_NAME</code> ：要与指定任务或任务执行关联的SQL调整集的名称。此参数主要用于比较使用SPA的两个SQL调优集。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQLSET_OWNER</code> ：使用任务参数<code class="codeph">SQLSET_NAME</code>指定的SQL调优集的<code class="codeph">SQLSET_NAME</code> 。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TIME_LIMIT</code> ：全球超时（秒）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2633" headers="d911026e2301 ">
                                       <p><code class="codeph">parameter</code> （续）
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2633 d911026e2304 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">WORKLOAD_IMPACT_THRESHOLD</code> ：SQL语句对工作负载影响的阈值。工作量变化影响低于此阈值绝对值的陈述将被忽略，不予考虑改进或回归。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">CON_DBID_MAPPING</code> ：提供多租户容器数据库（CDB）ID的映射。设置后，SQL Performance Analyzer会在找到旧CDB ID的匹配项时使用新的CDB ID，并在该容器中执行SQL。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2651" headers="d911026e2301 ">
                                       <p><code class="codeph">值</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2651 d911026e2304 ">
                                       <p>指定参数的新值</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2659" headers="d911026e2301 ">
                                       <p><code class="codeph">test_execute_dop</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2659 d911026e2304 ">
                                       <p>指定应执行SPA任务的请求的并发级别。</p>
                                       <p>值<code class="codeph">0</code>或<code class="codeph">1</code>表示SPA任务将在没有其他进程的情况下运行，因为它在<code class="codeph">Oracle Database 18c Release</code>版之前的版本中运行。值<code class="codeph">n</code> （大于1）表示正在请求<code class="codeph">n</code>后台SPA进程同时处理输入工作负载。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2684" headers="d911026e2301 ">
                                       <p><code class="codeph">compare_resultset</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2684 d911026e2304 ">
                                       <p>指示SPA检测被比较的两个试验之间的结果集是否不同。如果在比较的两个试验之间的任何SQL语句的结果集中看到差异，则SPA比较报告将为每个此类SQL语句指示此情况。</p>
                                       <div class="p">
                                          <ul style="list-style-type:disc">
                                             <li>
                                                <p>如果设置为<code class="codeph">TRUE</code> ，则将执行结果集比较</p>
                                             </li>
                                             <li>
                                                <p>如果设置为<code class="codeph">FALSE</code>则不会执行结果集比较。
                                                </p>
                                             </li>
                                          </ul>
                                       </div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-24792620-7642-48DA-9154-37D10AE58AC2__GUID-C947C93F-BD56-45FD-9F55-068523284B66">使用说明</p>
                        <p>授予的实际进程数可能等于或低于使用<code class="codeph">test_execute_dop</code>参数请求的数量。此参数仅适用于处理SQL调整集的<code class="codeph">test-execute</code>或<code class="codeph">explain plan type</code>的试验。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-24792620-7642-48DA-9154-37D10AE58AC2__GUID-8E149226-3121-427F-B062-B5796A1BD613">例子</p>
                        <p>要请求两个并发进程来执行SPA任务：</p><pre class="pre codeblock"><code>dbms_sqlpa.set_analysis_task_parameter（：TNAME， 'TEST_EXECUTE_DOP'，2）</code></pre><p>启用结果集验证</p><pre class="pre codeblock"><code>exec dbms_sqlpa.set_analysis_task_parameter（：atname，'COMPARE_RESULTSET'，'TRUE'）</code></pre><p>要禁用结果集验证：</p><pre class="pre codeblock"><code>exec dbms_sqlpa.set_analysis_task_parameter（：atname，'COMPARE_RESULTSET'，'FALSE'）</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS68373"></a><a id="ARPLS68374"></a><a id="ARPLS68374"></a><a id="ARPLS68373"></a><div class="props_rev_3"><a id="GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8" name="GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8"></a><h4 id="ARPLS-GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8" class="sect4"><span class="enumeration_section">160.3.10</span> SET_ANALYSIS_DEFAULT_PARAMETER过程</h4>
                  <div>
                     <p>此过程设置SQL分析任务参数的默认值。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8__GUID-BF94953D-4727-4934-BF45-8984C176834A">句法</p>
                        <p>此过程形式更新<code class="codeph">VARCHAR2</code>类型的分析器参数的默认值。
                        </p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.SET_ANALYSIS_DEFAULT_PARAMETER（参数IN VARCHAR2，值IN VARCHAR2）;</pre><p>此过程形式更新<code class="codeph">NUMBER</code>类型的分析器参数的<code class="codeph">default</code>值。</p><pre class="oac_no_warn" dir="ltr">DBMS_SQLPA.SET_ANALYSIS_DEFAULT_PARAMETER（参数IN VARCHAR2，值IN NUMBER）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8__GUID-DFA56151-71B6-41B3-A4C6-EEF6CEC2666F">参数</p>
                        <div class="tblformal" id="GUID-CFE070C1-80F3-4A20-96B0-3B38139338D8__GUID-4E604043-CCB2-46AF-8524-F5A81CBE7AF7">
                           <p class="titleintable">表160-11 SET_ANALYSIS_DEFAULT_PARAMETER过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SET_ANALYSIS_DEFAULT_PARAMETER过程参数" width="100%" border="1" summary="This table describes Parameters used by the DBMS_SQLPA.SET_ANALYSIS_DEFAULT_PARAMETER subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d911026e2859">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d911026e2862">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2867" headers="d911026e2859 ">
                                       <p><code class="codeph">参数</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2867 d911026e2862 ">
                                       <p>要设置的参数的名称。可以通过此过程设置的可能分析参数是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">APPLY_CAPTURED_COMPILENV</code> ：指示顾问程序是否可以使用SQL语句捕获的编译环境。默认值为0（即<code class="codeph">NO</code> ）。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">BASIC_FILTER</code> ：SQL调优集的基本过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">COMPARISON_METRIC</code> ：指定要在性能比较中使用的执行统计信息的表达式（示例： <code class="codeph">buffer_gets</code> ， <code class="codeph">cpu_time</code> + <code class="codeph">buffer_gets</code> * 10）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DATABASE_LINK</code> ：可以设置为<code class="codeph">PUBLIC</code>数据库链接的全局名称。设置后，SQL Performance Analyzer将通过将SQL语句发送到远程数据库进行远程处理，将数据库链接用于所有<code class="codeph">TEST EXECUTE</code>和<code class="codeph">EXPLAIN PLAN</code>操作。分析结果仍将存储在本地数据库中。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DAYS_TO_EXPIRE</code> ：删除任务之前的天数</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DEFAULT_EXECUTION_TYPE</code> ：当<a href="DBMS_SQLPA.html#GUID-7A8BB3B0-89B5-49A7-99A8-59AA0F939058" title="此函数和过程执行先前创建的分析任务，函数版本返回新的执行名称。">EXECUTE_ANALYSIS_TASK函数和过程</a>未指定任何任务时，任务将默认为此类执行。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTE_FULLDML</code> ： <code class="codeph">TRUE</code>完全执行DML语句，包括获取行锁和修改行; <code class="codeph">FALSE</code> （默认值）仅执行DML的查询部分而不修改数据。如果为<code class="codeph">TRUE</code> ，SQL Performance Analyzer将在DML执行后发出回滚，以防止DML进行持久更改。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_DAYS_TO_EXPIRE</code> ：删除任务执行前的天数（不删除任务）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_NAME1</code> ：要分析的第一个任务执行的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTION_NAME2</code> ：要分析的第二个任务执行的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">LOCAL_TIME_LIMIT</code> ：每语句超时（秒）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e2968" headers="d911026e2859 ">
                                       <p><code class="codeph">parameter</code> （续）
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e2968 d911026e2862 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">PLAN_FILTER</code> ：SQL调优集的计划过滤器（有关可能的值，请参阅<code class="codeph">SELECT_SQLSET</code> ）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE1</code> ：SQL调优集的第一个排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE2</code> ：SQL调优集的第二种可能的排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RANK_MEASURE3</code> ：SQL调优集的第三种可能的排名度量</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">RESUME_FILTER</code> ：除<code class="codeph">BASIC_FILTER</code>之外的SQL调优集的额外过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_IMPACT_THRESHOLD</code> ：对SQL语句的更改影响的阈值。与上一个参数相同，但在SQL语句的级别。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_LIMIT</code> ：要处理的最大SQL语句数</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SQL_PERCENTAGE</code> ：SQL调优集语句的百分比过滤器</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TIME_LIMIT</code> ：全球超时（秒）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">WORKLOAD_IMPACT_THRESHOLD</code> ：SQL语句对工作负载影响的阈值。工作量变化影响低于此阈值绝对值的陈述将被忽略，不予考虑改进或回归。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d911026e3031" headers="d911026e2859 ">
                                       <p><code class="codeph">值</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d911026e3031 d911026e2862 ">
                                       <p>指定参数的新值</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="01523.configuring-rman-client-advanced.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>配置RMAN环境：高级主题</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Backup and Recovery User&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Backup and Recovery User&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-backup-and-recovery-users-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T05:20:45-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2003, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96241-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="configuring-rman-client-basic.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-flasback-database-restore-points.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Backup and Recovery User&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="BRADV"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="configuring-rman-client-basic.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-flasback-database-restore-points.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">备份和恢复用户指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-starting-configuring-rman.html" property="item" typeof="WebPage"><span property="name">启动和配置RMAN和闪回数据库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">配置RMAN环境：高级主题</li>
            </ol>
            <a id="GUID-2210B194-FDA8-4BB4-BC1E-DBE7DBEACB4A" name="GUID-2210B194-FDA8-4BB4-BC1E-DBE7DBEACB4A"></a><a id="BRADV006"></a>
            
            <h2 id="BRADV-GUID-2210B194-FDA8-4BB4-BC1E-DBE7DBEACB4A" class="sect2"><span class="enumeration_chapter">6</span>配置RMAN环境：高级主题</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何执行设置和配置任务。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-EF072AB8-AE89-4847-90B1-2214FD2336B3" title="CONFIGURE CHANNEL命令用于配置RMAN通道选项。">配置高级频道选项</a></p>
                  </li>
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-AC052271-068A-4E4B-8001-525D417DE865" title="备份选项使您可以控制备份大小，备份压缩和备份加密等方面。">配置高级备份选项</a></p>
                  </li>
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-9C633A44-5533-467E-9108-14BC088A1F82" title="在执行诸如数据文件表空间时间点恢复（TSPITR）或使用RMAN进行数据传输等操作时，您可能希望在辅助实例中设置数据文件的名称。在启动TSPITR或数据库复制之前设置这些名称。">配置辅助实例数据文件名</a></p>
                  </li>
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-B7B61600-6DED-413D-B134-1DAE79627A01" title="当RMAN需要控制文件的读取一致版本时，它会创建临时快照控制文件。在与恢复目录重新同步时或在备份当前控制文件时，RMAN需要快照控制文件。">配置快照控制文件位置</a></p>
                  </li>
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE" title="RMAN无法通过共享服务器调度程序连接到目标数据库。RMAN需要专用的服务器进程。">配置RMAN以与共享服务器一起使用</a></p>
                  </li>
                  <li>
                     <p><a href="configuring-rman-client-advanced.html#GUID-AE80F99C-5368-4FC3-83C5-7261BF9174F0" title="当I / O子系统确认块写入完成时，会发生数据块丢失写入，但写入未在持久存储中发生。在随后的块读取中，I / O子系统返回数据块的陈旧版本，该版本可能用于更新数据库的其他块，从而破坏它。">启用丢失写入检测</a></p>
                  </li>
               </ul>
            </div><a id="BRADV134"></a><div class="props_rev_3"><a id="GUID-EF072AB8-AE89-4847-90B1-2214FD2336B3" name="GUID-EF072AB8-AE89-4847-90B1-2214FD2336B3"></a><h3 id="BRADV-GUID-EF072AB8-AE89-4847-90B1-2214FD2336B3" class="sect3"><span class="enumeration_section">6.1</span>配置高级频道选项</h3>
               <div>
                  <p><code class="codeph">CONFIGURE CHANNEL</code>命令用于配置RMAN通道选项。
                  </p>
                  <p>本节包含有关高级频道选项的以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-42F31F53-07AF-4A81-9387-849D17F90C9A" title="无论是手动分配通道还是使用自动通道分配，都可以使用通道命令和选项来控制行为。">关于频道控制选项</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-F4DDECAD-AC08-4BBF-A27C-2E045BF89366" title="除了配置适用于特定类型的所有通道的参数外，还可以使用CONFIGURE命令配置适用于特定通道的参数。">配置特定通道参数</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-EF072AB8-AE89-4847-90B1-2214FD2336B3__GUID-1B604FFD-B09E-4195-B889-E47D89A4D9F1">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="rman-architecture.html#GUID-282FD0B6-8593-4775-9965-DB47534D349C" title="RMAN信道表示到设备的一个数据流，并且对应于一个数据库服务器会话。在备份或恢复操作期间，通道从输入设备读取数据，对其进行处理，并将其写入输出设备。">关于RMAN通道，</a>用于配置和分配通道的概念性概述</p>
                        </li>
                        <li>
                           <p><a href="configuring-rman-client-basic.html#GUID-911248BA-A742-426C-9B90-51214CFAF36B" title="An RMAN channel is a connection to a database server session. RMAN uses channels to perform most tasks.">配置频道</a>是<a href="configuring-rman-client-basic.html#GUID-911248BA-A742-426C-9B90-51214CFAF36B" title="RMAN通道是与数据库服务器会话的连接。RMAN使用通道执行大多数任务。">配置频道</a>的基础</p>
                        </li>
                        <li>
                           <p><code class="codeph">CONFIGURE</code>语法的<a href="../rcmrf/CONFIGURE.html#RCMRF113" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="BRADV578"></a><a id="BRADV89456"></a><div class="props_rev_3"><a id="GUID-42F31F53-07AF-4A81-9387-849D17F90C9A" name="GUID-42F31F53-07AF-4A81-9387-849D17F90C9A"></a><h4 id="BRADV-GUID-42F31F53-07AF-4A81-9387-849D17F90C9A" class="sect4"><span class="enumeration_section">6.1.1</span>关于通道控制选项</h4>
                  <div>
                     <p>无论是手动分配通道还是使用自动通道分配，都可以使用通道命令和选项来控制行为。</p>
                     <p><a href="configuring-rman-client-advanced.html#GUID-42F31F53-07AF-4A81-9387-849D17F90C9A__CHDHFEBJ" title="总结了通道控制选项">表6-1</a>总结了控制通道行为的方法。除非另有说明，否则<code class="codeph">CONFIGURE CHANNEL</code>和<code class="codeph">ALLOCATE CHANNEL</code>命令均支持所有通道参数。
                     </p>
                     <div class="tblformal" id="GUID-42F31F53-07AF-4A81-9387-849D17F90C9A__CHDHFEBJ">
                        <p class="titleintable">表6-1通道控制选项</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="频道控制选项" width="100%" border="1" summary="Summarizes channel control options" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d30457e375">通道控制的类型</th>
                                 <th align="left" valign="bottom" width="69%" id="d30457e378">命令</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d30457e383" headers="d30457e375 ">
                                    <p>限制I / O带宽消耗</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d30457e383 d30457e378 ">
                                    <p>使用<code class="codeph">RATE</code>通道参数充当备份的限制机制。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d30457e393" headers="d30457e375 ">
                                    <p>限制备份集和部分</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d30457e393 d30457e378 ">
                                    <p>使用<code class="codeph">MAXPIECESIZE</code>通道参数设置备份件大小的限制。您还可以使用<code class="codeph">BACKUP</code>和<code class="codeph">CONFIGURE</code>命令上的<code class="codeph">MAXSETSIZE</code>参数来设置备份集大小的限制。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d30457e412" headers="d30457e375 ">
                                    <p>供应商特定说明</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d30457e412 d30457e378 ">
                                    <p>使用<code class="codeph">PARMS</code>通道参数指定<a href="glossary.html#GUID-26FF62D0-5938-481D-B7B9-929BC971813E"><span class="xrefglossterm">介质管理软件</span></a>的特定于供应商的信息。您还可以使用<code class="codeph">SEND</code>命令将特定于供应商的命令发送到媒体管理器。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d30457e428" headers="d30457e375 ">
                                    <p>通道并行备份和还原操作</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d30457e428 d30457e378 ">
                                    <p>使用<code class="codeph">CONFIGURE DEVICE TYPE ...用于持久性通道并行的PARALLELISM</code>或用于作业级并行的多个<code class="codeph">ALLOCATE CHANNEL</code>命令。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d30457e441" headers="d30457e375 ">
                                    <p>数据库实例的连接设置</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d30457e441 d30457e378 ">
                                    <p>指定哪个实例使用<code class="codeph">CONNECT</code>通道参数执行操作。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-42F31F53-07AF-4A81-9387-849D17F90C9A__GUID-55E2EF58-DBDA-4DC7-8C0E-4F7AD8C454B4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>适用于<code class="codeph">ALLOCATE</code> <code class="codeph">CHANNEL</code>语法的<a href="../rcmrf/ALLOCATE-CHANNEL.html#RCMRF102" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><code class="codeph">CONFIGURE</code>语法的<a href="../rcmrf/CONFIGURE.html#RCMRF113" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="BRADV89457"></a><div class="props_rev_3"><a id="GUID-F4DDECAD-AC08-4BBF-A27C-2E045BF89366" name="GUID-F4DDECAD-AC08-4BBF-A27C-2E045BF89366"></a><h4 id="BRADV-GUID-F4DDECAD-AC08-4BBF-A27C-2E045BF89366" class="sect4"><span class="enumeration_section">6.1.2</span>配置特定通道参数</h4>
                  <div>
                     <p>除了配置适用于特定类型的所有通道的参数外，还可以使用<code class="codeph">CONFIGURE</code>命令配置适用于特定通道的参数。
                     </p>
                     <div class="section">
                        <p>当需要分别控制为每个通道设置的参数时，按编号配置特定通道。在以下情况下，此技术是必需的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行Oracle Real Application Clusters（Oracle RAC）数据库时，其中各个节点无法访问完整的备份集。必须为每个通道配置特定于节点的连接字符串，以便至少可以通过一个通道访问所有备份。</p>
                           </li>
                           <li>
                              <p>使用每个通道需要不同<code class="codeph">PARMS</code>设置的媒体管理器时。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要配置特定通道参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行<code class="codeph">CONFIGURE CHANNEL</code> <span class="italic"><code class="codeph">n</code></span>命令（其中<span class="italic"><code class="codeph">n</code></span>是小于255的正整数）以配置特定通道。
                              </p>
                              <p>手动编号通道时，必须为每个通道指定一个或多个通道选项（例如， <code class="codeph">MAXPIECESIZE</code>或<a href="../rcmrf/formatSpec.html#RCMRF195" target="_blank"><code class="codeph">FORMAT</code></a> ）。在备份中使用该特定编号通道时，将使用该通道的已配置设置，而不是已配置的通用通道设置。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-F4DDECAD-AC08-4BBF-A27C-2E045BF89366__GUID-3EBDC58F-B3B5-4BC5-B488-7B7BA9A46895">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../racad/configuring-recovery-manager-and-archiving.html#RACAD320" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a>了解Oracle RAC环境中的RMAN备份</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="BRADV183"></a><a id="BRADV89458"></a><div class="props_rev_3"><a id="GUID-45919A66-85EE-4197-BD54-FE6D15DE6958" name="GUID-45919A66-85EE-4197-BD54-FE6D15DE6958"></a><h5 id="BRADV-GUID-45919A66-85EE-4197-BD54-FE6D15DE6958" class="sect5"><span class="enumeration_section">6.1.2.1</span>配置特定通道：示例</h5>
                     <div>
                        <div class="example" id="GUID-45919A66-85EE-4197-BD54-FE6D15DE6958__GUID-7E4C837D-D338-4B45-BB84-98F3480F4B74">
                           <p class="titleinexample">例6-1配置磁盘设备的通道并行性</p>
                           <p>此示例将磁盘备份发送到两个不同的磁盘。配置磁盘通道如下：</p><pre class="pre codeblock"><code>配置默认设备类型到磁盘; #backup转到磁盘CONFIGURE DEVICE TYPE磁盘PARALLELISM 2; ＃并行使用的两个通道配置通道1设备类型磁盘格式'/ disk1 /％U'＃第一通道到磁盘1配置通道2设备类型磁盘格式'/ disk2 /％U'＃第二通道到磁盘2 BACKUP DATABASE; #backup  - 第一个通道进入disk1，第二个进入disk2</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-45919A66-85EE-4197-BD54-FE6D15DE6958__CHDFCEGA">
                           <p class="titleinexample">例6-2为磁带设备配置通道并行性</p>
                           <p>此示例配置通道以创建并行数据库备份。您有两个磁带驱动器，并希望每个驱动器使用来自不同磁带介质系列的磁带。备份数据在两个磁带设备之间分配。每个配置的通道备份大约一半的总数据。</p><pre class="pre codeblock"><code>配置默认设备类型为sbt; #backup转到sbt CONFIGURE DEVICE TYPE sbt PARALLELISM 2; ＃默认分配的两个sbt通道＃将通道1配置为名为first_pool的池配置通道1设备类型sbt PARMS'ENV =（OB_MEDIA_FAMILY = first_pool）'; ＃配置通道2到池名为second_pool配置通道2设备类型sbt PARMS'ENV =（OB_MEDIA_FAMILY = second_pool）';备份数据库; #first stream转到'first_pool'，第二个转到'second_pool'</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="BRADV89459"></a><div class="props_rev_3"><a id="GUID-CD9FE2BB-4F7E-46DA-A4FA-70D3F992A154" name="GUID-CD9FE2BB-4F7E-46DA-A4FA-70D3F992A154"></a><h5 id="BRADV-GUID-CD9FE2BB-4F7E-46DA-A4FA-70D3F992A154" class="sect5"><span class="enumeration_section">6.1.2.2</span>配置信道与并行设置之间的关系</h5>
                     <div>
                        <p><code class="codeph">PARALLELISM</code>设置不受特定配置通道数量的限制。
                        </p>
                        <p>例如，如果您备份最多20个不同的磁带设备，则可以配置20个不同的SBT通道，每个通道都有一个手动分配的编号（从1到20），每个通道选项都有一组不同的通道选项。在这种情况下，您可以将<code class="codeph">PARALLELISM</code>设置为最多为设备数量的任何值，在本例中为20。
                        </p>
                        <p>RMAN始终为从<code class="codeph">1</code>开始并以<code class="codeph">PARALLELISM</code>设置结束的并行通道编号。例如，如果默认设备是SBT且并行度设置为3，则RMAN按如下方式命名通道：</p><pre class="pre codeblock"><code>ORA_SBT_TAPE_1 ORA_SBT_TAPE_2 ORA_SBT_TAPE_3</code></pre><p>RMAN始终使用名称<code class="codeph">ORA_SBT_TAPE_</code> <span class="italic">n为</span>偶数，如果您配置<code class="codeph">DEVICE</code> <code class="codeph">TYPE</code> <code class="codeph">sbt</code> （非同义<code class="codeph">sbt_tape</code> ）。RMAN总是分配<code class="codeph">PARALLELISM</code>指定的通道数，如果已配置，则使用专门配置的通道，如果没有，则使用通用通道。如果您使用高于并行度设置的数字配置特定通道，则此设置会阻止RMAN使用它们。
                        </p>
                        <div class="infoboxnotealso" id="GUID-CD9FE2BB-4F7E-46DA-A4FA-70D3F992A154__GUID-38745B78-0E3B-4418-A239-18EC55845E33">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="rman-architecture.html#GUID-282FD0B6-8593-4775-9965-DB47534D349C" title="RMAN信道表示到设备的一个数据流，并且对应于一个数据库服务器会话。在备份或恢复操作期间，通道从输入设备读取数据，对其进行处理，并将其写入输出设备。">关于RMAN频道</a> ，了解频道</p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="BRADV89460"></a><div class="props_rev_3"><a id="GUID-AC052271-068A-4E4B-8001-525D417DE865" name="GUID-AC052271-068A-4E4B-8001-525D417DE865"></a><h3 id="BRADV-GUID-AC052271-068A-4E4B-8001-525D417DE865" class="sect3"><span class="enumeration_section">6.2</span>配置高级备份选项</h3>
               <div>
                  <p>备份选项使您可以控制备份大小，备份压缩和备份加密等方面。</p>
                  <p><span class="q">“ <a href="configuring-rman-client-basic.html#GUID-AD92E09D-0788-4AB5-8792-5F969C8D237A" title="RMAN为执行基本备份和恢复所需的大多数参数提供合理的默认值。您可以修改默认参数的值或覆盖特定会话的这些值。">关于为RMAN备份配置环境</a> ”</span>介绍了配置RMAN以进行备份的基础知识。本节介绍更多高级配置选项。本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-0A131C1F-85F1-4FED-8EFB-D747679A184A" title="CONFIGURE MAXSETSIZE命令限制在通道上创建的备份集的大小。当使用BACKUP命令创建备份集时，此CONFIGURE设置适用于任何通道，无论是手动分配还是已配置。默认值以字节为单位，向下舍入为最低千字节值。">配置备份集的最大大小</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33" title="当备份片大小超过文件系统或媒体管理软件允许的最大文件大小时，它是一个问题。您可以使用CONFIGURE CHANNEL或ALLOCATE CHANNEL命令的MAXPIECESIZE参数来限制备份片的大小。">配置备份片的最大大小</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B" title="使用配置...BACKUP COPIES命令指定在指定类型的文件的指定设备类型上创建每个备份片的副本数。此类备份称为双工备份集。">配置备份双工</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-9E83A7FF-6D4B-4385-8BF0-D5E65E808078" title="有时，您可能希望从常规备份计划的一部分中省略指定的表空间。使用CONFIGURE命令配置表空间排除。">配置表空间以从整个数据库备份中排除</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-3117DA93-EC34-488D-A4FB-29E6CD4D168A" title="RMAN支持预压缩处理和备份集的二进制压缩。CONFIGURE COMPRESSION ALGORITHM命令可以配置压缩选项。">配置压缩选项</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-21D5FCCE-7AF1-4CF8-BC53-2496ECE3C56E" title="为了提高安全性，您可以为RMAN备份集配置备份加密。如果未经授权的用户获取加密备份，则无法读取这些备份。">配置备份加密</a></p>
                     </li>
                  </ul>
               </div><a id="BRADV137"></a><div class="props_rev_3"><a id="GUID-0A131C1F-85F1-4FED-8EFB-D747679A184A" name="GUID-0A131C1F-85F1-4FED-8EFB-D747679A184A"></a><h4 id="BRADV-GUID-0A131C1F-85F1-4FED-8EFB-D747679A184A" class="sect4"><span class="enumeration_section">6.2.1</span>配置备份集的最大大小</h4>
                  <div>
                     <p><code class="codeph">CONFIGURE MAXSETSIZE</code>命令限制在通道上创建的备份集的大小。当使用<code class="codeph">BACKUP</code>命令创建备份集时，此<code class="codeph">CONFIGURE</code>设置适用于任何通道，无论是手动分配还是已配置。默认值以字节为单位，向下舍入为最低千字节值。
                     </p>
                     <div class="section">
                        <p>在磁带备份中， <a href="glossary.html#GUID-EA6CE3E8-6986-4512-AF66-710D80376093"><span class="xrefglossterm">多路复用备份集</span></a>可以跨多个磁带，这意味着备份集中每个数据文件的块都会写入多个磁带。如果多卷备份集中的一个磁带发生故障，则会丢失所有磁带上的数据而不是一个磁带上的数据。如果备份不是<a href="glossary.html#GUID-6D6DDA5E-F1EF-4273-8649-137F1FC89EB6"><span class="xrefglossterm">多节备份</span></a> ，则备份集始终包含整个数据文件而不是部分数据文件。您可以使用<code class="codeph">MAXSETSIZE</code>指定每个备份集适合一个磁带而不是跨越多个磁带。
                        </p>
                        <p><code class="codeph">CONFIGURE MAXSETSIZE</code>命令设置的值是给定通道的默认值。您可以通过为单个<code class="codeph">BACKUP</code>命令指定<code class="codeph">MAXSETSIZE</code>选项来覆盖已配置的<code class="codeph">MAXSETSIZE</code>值。
                        </p>
                        <p>假设您在RMAN提示符下发出以下命令：</p><pre class="pre codeblock"><code>配置默认设备类型为sbt; CONFIGURE CHANNEL DEVICE TYPE sbt PARMS'ENV =（OB_MEDIA_FAMILY = first_pool）';配置MAXSETSIZE至7500K; BACKUP TABLESPACE用户; BACKUP TABLESPACE工具MAXSETSIZE 5G;</code></pre><p>结果如下：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">users</code>表空间的备份使用配置的<a href="glossary.html#GUID-2E48CE71-9547-4196-B715-5CE59033262E"><span class="xrefglossterm">SBT</span></a>通道和配置的默认<code class="codeph">MAXSETSIZE</code>设置<code class="codeph">7500K</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">tools</code>表空间的备份使用<code class="codeph">BACKUP</code>命令中指定的<code class="codeph">5G</code>的<code class="codeph">MAXSETSIZE</code>设置。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-0A131C1F-85F1-4FED-8EFB-D747679A184A__GUID-904019A7-E3C3-4411-A4A1-9C578F9CA731">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="backing-up-database-advanced.html#GUID-DD5D76A0-2C93-4847-8E79-8E75ACAF4119" title="在超过文件系统或媒体管理软件的最大文件大小的情况下，备份大小是一个问题。使用CONFIGURE CHANNEL或ALLOCATE CHANNEL命令的MAXSETSIZE参数来限制备份片的大小。">使用BACKUP限制备份集的大小...MAXSETSIZE</a></p>
                              </li>
                              <li>
                                 <p>用于<code class="codeph">BACKUP</code>语法的<a href="../rcmrf/BACKUP.html#RCMRF107" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV89461"></a><div class="props_rev_3"><a id="GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33" name="GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33"></a><h4 id="BRADV-GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33" class="sect4"><span class="enumeration_section">6.2.2</span>配置备份片的最大大小</h4>
                  <div>
                     <p>当备份片大小超过文件系统或媒体管理软件允许的最大文件大小时，它是一个问题。您可以使用<code class="codeph">CONFIGURE</code> <code class="codeph">CHANNEL</code>或<code class="codeph">ALLOCATE</code> <code class="codeph">CHANNEL</code>命令的<code class="codeph">MAXPIECESIZE</code>参数来限制备份片的大小。
                     </p>
                     <div class="section">
                        <p>例如，要将备份片段大小限制为2千兆字节或更小，可以按如下方式配置自动<code class="codeph">DISK</code>通道，然后运行<code class="codeph">BACKUP</code> <code class="codeph">DATABASE</code> ：</p><pre class="oac_no_warn" dir="ltr">配置通道设备类型磁盘最大化2G;备份数据库;</pre><div class="infoboxnote" id="GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33__GUID-2A536D8D-18F6-4FC5-9C50-440F54755CAA">
                           <p class="notep1">注意：</p>
                           <p>在媒体管理API的2.0版本中，媒体管理供应商可以指定可以写入其媒体管理器的备份片段的最大大小。无论您为<code class="codeph">MAXPIECESIZE</code>配置的设置如何，RMAN都会遵守此限制。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-B5C38414-33DD-4A0F-B0FD-B63F1AC74B33__GUID-CC7629E9-40D9-4931-A07D-A59EB0412F9D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../rcmrf/CONFIGURE.html#RCMRF113" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a> ，了解<code class="codeph">CONFIGURE CHANNEL ...MAXPIECESIZE</code>命令</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV139"></a><div class="props_rev_3"><a id="GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B" name="GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B"></a><h4 id="BRADV-GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B" class="sect4"><span class="enumeration_section">6.2.3</span>配置备份双工</h4>
                  <div>
                     <p>使用<code class="codeph">CONFIGURE ...BACKUP COPIES</code>命令指定在指定类型的文件的指定设备类型上创建每个备份片的副本数。此类备份称为双工备份集。
                     </p>
                     <div class="section">
                        <p>RMAN可以将备份双工复制到磁盘或磁带，但不能同时将备份复制到磁带和磁盘。备份到磁带时，请确保副本数量不超过可用磁带设备的数量。双面打印的<code class="codeph">CONFIGURE</code>设置仅影响数据文件，控制文件和存档日志的备份到备份集中，不会影响映像副本。
                        </p>
                        <div class="infoboxnote" id="GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B__GUID-412DEA7F-0BEA-48AD-B474-5D98BD527CB3">
                           <p class="notep1">注意：</p>
                           <p><a href="glossary.html#GUID-7CDA6567-DFB0-450D-8771-B033E9872AF7"><span class="xrefglossterm">控制文件自动备份</span></a> <span class="italic">从不</span>双工。
                           </p>
                        </div>
                        <p>默认情况下， <code class="codeph">CONFIGURE</code> <code class="codeph">...</code> 对于每种设备类型， <code class="codeph">BACKUP</code> <code class="codeph">COPIES</code>设置为<code class="codeph">1</code> 。
                        </p>
                        <p>以下示例显示了可能的双工配置：</p><pre class="pre codeblock"><code>＃制作每个数据文件和控制文件备份集的2个磁盘副本＃（不包括自动备份）配置数据文件备份复制设备类型磁盘为2; ＃将每个归档重做日志备份的3个副本复制到磁带配置ARCHIVELOG备份复制设备类型sbt到3;</code></pre><p>要将<code class="codeph">BACKUP</code> <code class="codeph">COPIES</code>配置恢复为其默认值，请使用<code class="codeph">CLEAR</code>选项运行相同的<code class="codeph">CONFIGURE</code>命令，如以下示例所示：</p><pre class="pre codeblock"><code>配置数据文件备份复制设备类型sbt CLEAR;</code></pre><div class="infoboxnote" id="GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B__GUID-159A0982-84C5-47A6-88FC-64F3164DA28B">
                           <p class="notep1">注意：</p>
                           <p>如果您不想创建持久性副本配置，则可以使用<code class="codeph">BACKUP</code> <code class="codeph">COPIES</code>和<a href="../rcmrf/SET.html#RCMRF153" target="_blank"><code class="codeph">SET BACKUP COPIES</code></a>命令指定副本。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-2A285F87-552A-4F36-A5B9-F25A69611B4B__GUID-3EDB47F1-2AB9-42B7-8EA2-503CF6CCE585">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="rman-backup-concepts.html#GUID-763A9C75-90A5-48FD-9CB6-707D030A00F5" title="RMAN使您可以创建多个相同的备份副本。">关于RMAN备份的多个副本，</a>以获取双工备份的概述</p>
                              </li>
                              <li>
                                 <p><a href="backing-up-database-advanced.html#GUID-4CFE9BA0-E298-42B8-9FB6-D36751C09D54" title="RMAN最多可以同时备份四个备份集，每个副本与其他备份集完全相同。">双工备份集</a>以了解如何创建双工备份</p>
                              </li>
                              <li>
                                 <p>用于<code class="codeph">BACKUP</code>语法的<a href="../rcmrf/BACKUP.html#RCMRF107" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><code class="codeph">CONFIGURE</code>语法的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF113" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>用于<code class="codeph">SET</code>语法的<a href="../rcmrf/SET.html#RCMRF153" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV140"></a><div class="props_rev_3"><a id="GUID-9E83A7FF-6D4B-4385-8BF0-D5E65E808078" name="GUID-9E83A7FF-6D4B-4385-8BF0-D5E65E808078"></a><h4 id="BRADV-GUID-9E83A7FF-6D4B-4385-8BF0-D5E65E808078" class="sect4"><span class="enumeration_section">6.2.4</span>配置表空间以排除整个数据库备份</h4>
                  <div>
                     <p>有时，您可能希望从常规备份计划的一部分中省略指定的表空间。使用<code class="codeph">CONFIGURE</code>命令配置表空间排除。
                     </p>
                     <div class="p">
                        <p>以下是一些可能需要考虑的方案：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>表空间很容易重建，因此重建它比每天备份更具成本效益。</p>
                           </li>
                           <li>
                              <p>表空间包含您不需要备份的临时数据或测试数据。</p>
                           </li>
                           <li>
                              <p>表空间不会经常更改，因此应该以与其他备份不同的计划进行备份。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您可以运行<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF113" target="_blank"><code class="codeph">CONFIGURE EXCLUDE FOR TABLESPACE</code></a>以从<a href="../rcmrf/BACKUP.html#RCMRF107" target="_blank"><code class="codeph">BACKUP DATABASE</code></a>命令中排除指定的表空间。排除条件适用于将来添加到此表空间的任何数据文件。
                        </p>
                        <p>例如，您可以从整个数据库备份中排除测试表空间<code class="codeph">cwmlite</code>和<code class="codeph">example</code> ，如下所示：</p><pre class="pre codeblock"><code>为TABLESPACE cwmlite配置排除;配置排除TABLESPACE示例;</code></pre><p>如果运行以下命令，则RMAN将备份数据库中的所有表空间，但<code class="codeph">cwmlite</code>和<code class="codeph">example</code>除外：</p><pre class="pre codeblock"><code>备份数据库;</code></pre><p>您仍然可以通过在<code class="codeph">BACKUP</code>命令中显式指定它们或通过在<code class="codeph">BACKUP</code> <code class="codeph">DATABASE</code>命令上指定<code class="codeph">NOEXCLUDE</code>选项来<code class="codeph">BACKUP</code>已配置的表空间。例如，您可以输入以下命令之一：</p><pre class="pre codeblock"><code>备份数据库NOEXCLUDE; #backs up database，包括cwmlite和示例BACKUP TABLESPACE cwmlite，例子; ＃仅备份cwmlite和示例</code></pre><p>您可以为<code class="codeph">cwmlite</code>禁用排除功能， <code class="codeph">example</code>如下：</p><pre class="pre codeblock"><code>配置排除TABLESPACE cwmlite CLEAR;配置排除TABLESPACE示例CLEAR;</code></pre><p>RMAN在将来的整个数据库备份中包含这些表空间。</p>
                        <div class="infoboxnotealso" id="GUID-9E83A7FF-6D4B-4385-8BF0-D5E65E808078__GUID-5AB38908-B940-4228-B8B5-94F4788302F5">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>用于<code class="codeph">BACKUP</code>和<code class="codeph">CONFIGURE</code>语法的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF107" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV89466"></a><div class="props_rev_3"><a id="GUID-3117DA93-EC34-488D-A4FB-29E6CD4D168A" name="GUID-3117DA93-EC34-488D-A4FB-29E6CD4D168A"></a><h4 id="BRADV-GUID-3117DA93-EC34-488D-A4FB-29E6CD4D168A" class="sect4"><span class="enumeration_section">6.2.5</span>配置压缩选项</h4>
                  <div>
                     <p>RMAN支持预压缩处理和备份集的二进制压缩。<code class="codeph">CONFIGURE COMPRESSION ALGORITHM</code>命令可以配置压缩选项。
                     </p>
                     <p>以下主题包含有关压缩的其他信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="configuring-rman-client-advanced.html#GUID-1715CC25-E958-4AA1-B362-1818468DC290" title="通过合并每个数据块中的可用空间并将该空闲空间设置为二进制零来实现更好的备份压缩比。对于已经成为许多删除和插入操作主题的数据块，此预压缩处理阶段具有最大优势。相反，它对仍处于初始加载状态的数据块没有影响。">关于RMAN预压缩块处理</a></p>
                        </li>
                        <li>
                           <p><a href="configuring-rman-client-advanced.html#GUID-1E61757C-0A4D-4407-BF8E-7D048B216278" title="Oracle数据库提供两类压缩算法：默认压缩算法和Oracle Advanced Compression选项提供的一组压缩算法。">关于RMAN支持的压缩级别</a></p>
                        </li>
                     </ul>
                  </div><a id="BRADV184"></a><div class="props_rev_3"><a id="GUID-1715CC25-E958-4AA1-B362-1818468DC290" name="GUID-1715CC25-E958-4AA1-B362-1818468DC290"></a><h5 id="BRADV-GUID-1715CC25-E958-4AA1-B362-1818468DC290" class="sect5"><span class="enumeration_section">6.2.5.1</span>关于RMAN预压缩块处理</h5>
                     <div>
                        <p>通过合并每个数据块中的可用空间并将该空闲空间设置为二进制零来实现更好的备份压缩比。对于已经成为许多删除和插入操作主题的数据块，此预压缩处理阶段具有最大优势。相反，它对仍处于初始加载状态的数据块没有影响。</p>
                        <p><code class="codeph">OPTIMIZE FOR LOAD</code>选项控制预压缩处理。通过指定默认值<code class="codeph">OPTIMIZE FOR LOAD TRUE</code> ，可以确保RMAN优化CPU使用率并避免预压缩块处理。通过指定<code class="codeph">OPTIMIZE FOR LOAD FALSE</code> ，RMAN使用额外的CPU资源来执行预压缩块处理。
                        </p>
                        <div class="infoboxnotealso" id="GUID-1715CC25-E958-4AA1-B362-1818468DC290__GUID-27579522-1054-419B-A250-4823EB94E2B6">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">CONFIGURE</code>和<code class="codeph">SET</code>语法的<a href="../rcmrf/CONFIGURE.html#RCMRF113" target="_blank"><span><cite>Oracle数据库备份和恢复参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="BRADV834"></a><div class="props_rev_3"><a id="GUID-1E61757C-0A4D-4407-BF8E-7D048B216278" name="GUID-1E61757C-0A4D-4407-BF8E-7D048B216278"></a><h5 id="BRADV-GUID-1E61757C-0A4D-4407-BF8E-7D048B216278" class="sect5"><span class="enumeration_section">6.2.5.2</span>关于RMAN支持的压缩级别</h5>
                     <div>
                        <p>Oracle数据库提供两类压缩算法：默认压缩算法和Oracle Advanced Compression选项提供的一组压缩算法。</p>
                        <p>默认算法是Oracle数据库的标准功能，而Oracle Advanced Compression选项是单独购买的选项。</p>
                        <div class="infoboxnotealso" id="GUID-1E61757C-0A4D-4407-BF8E-7D048B216278__GUID-13296A82-18A2-4CB8-AD09-957A18486D82">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="configuring-rman-client-advanced.html#GUID-57B1288E-F426-4C65-AAF4-6D0F7D5C9BA6" title="使用CONFIGURE命令配置默认压缩算法，该算法不需要Oracle Advanced Compression选项。">关于RMAN默认压缩</a></p>
                              </li>
                              <li>
                                 <p><a href="configuring-rman-client-advanced.html#GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45">关于Oracle Advanced Compression选件</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="BRADV186"></a><a id="BRADV185"></a><div class="props_rev_3"><a id="GUID-57B1288E-F426-4C65-AAF4-6D0F7D5C9BA6" name="GUID-57B1288E-F426-4C65-AAF4-6D0F7D5C9BA6"></a><h6 id="BRADV-GUID-57B1288E-F426-4C65-AAF4-6D0F7D5C9BA6" class="sect6"><span class="enumeration_section">6.2.5.2.1</span>关于RMAN默认压缩</h6>
                        <div>
                           <p>使用CONFIGURE命令配置默认压缩算法，该算法不需要Oracle Advanced Compression选项。</p>
                           <div class="example" id="GUID-57B1288E-F426-4C65-AAF4-6D0F7D5C9BA6__GUID-6A01D728-D528-4E28-A6DD-83B818DB1BDA">
                              <p class="titleinexample">示例6-3配置备份的基本压缩</p>
                              <p>以下示例为RMAN备份配置基本压缩。</p><pre class="pre codeblock"><code>配置压缩算法'基本';</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="BRADV187"></a><div class="props_rev_3"><a id="GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45" name="GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45"></a><h6 id="BRADV-GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45" class="sect6"><span class="enumeration_section">6.2.5.2.2</span>关于Oracle Advanced Compression选件</h6>
                        <div>
                           <p>如果已启用Oracle Advanced Compression选项，则可以从下表中列出的压缩级别中进行选择。</p>
                           <div class="tblformal" id="GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45__GUID-547DA1BE-7E85-4A76-AA8E-FE99000E07B2">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="List of compression values" frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="40%" id="d30457e2208">压缩等级</th>
                                       <th align="left" valign="bottom" width="60%" id="d30457e2211">绩效优势和权衡取舍</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d30457e2216" headers="d30457e2208 ">
                                          <p><code class="codeph">高</code></p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d30457e2216 d30457e2211 ">
                                          <p>最适合在较慢网络上进行备份，其中限制因素是网络速度。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d30457e2224" headers="d30457e2208 ">
                                          <p><code class="codeph">介质</code></p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d30457e2224 d30457e2211 ">
                                          <p>推荐用于大多数环境。压缩比和速度的良好组合。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d30457e2232" headers="d30457e2208 ">
                                          <p><code class="codeph">低</code></p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d30457e2232 d30457e2211 ">
                                          <p>对备份吞吐量影响最小。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>压缩比通常从低到高增加，可能会消耗更多的CPU资源。</p>
                           <p>由于各种压缩级别的性能取决于数据库中的数据性质，网络配置，系统资源以及计算机系统的类型及其功能，因此Oracle无法记录普遍适用的性能统计信息。哪种级别最适合您的环境取决于系统与CPU带宽的平衡程度以及CPU的实际速度。强烈建议您对环境中的数据运行具有不同压缩级别的测试。根据您的环境，网络流量特征（工作负载）和数据集选择压缩级别是确保备份集压缩级别能够满足组织的性能要求和适用的服务级别协议的唯一方法。</p>
                           <div class="infoboxnote" id="GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45__GUID-6CFDEBFC-604D-47EB-A82D-B5FECDDEAE91">
                              <p class="notep1">注意：</p>
                              <p>恢复压缩备份是内联执行的，不需要解压缩。</p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-0AA6DB13-ABA9-4BFB-9E42-38DADB9A0B45__GUID-C14595EF-0F14-4A6C-9920-EA024E372473">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=DBLIC-GUID-60BD93ED-D100-4F84-94DC-3AAB2D466E34" target="_blank"><span><cite>Oracle</cite></span></a> Advanced Compression选项的更多信息，请参见“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=DBLIC-GUID-60BD93ED-D100-4F84-94DC-3AAB2D466E34" target="_blank"><span><cite>Oracle数据库许可信息用户手册</cite></span></a> ”。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果要备份到磁带并且磁带设备执行自己的压缩，则不要同时使用RMAN备份集压缩和媒体管理器供应商的压缩。请参阅调整RMAN性能中<a href="tuning-rman-performance.html#GUID-33D81037-2310-4021-8039-1A2C579AAA5A" title="RMAN调整的目的是识别给定作业的瓶颈，并使用RMAN命令，初始化参数或对物理介质的调整来提高性能。当RMAN通道从磁盘读取数据时，多个因素会影响性能。在备份期间，RMAN通道将输入文件中的块读入I / O磁盘缓冲区。磁盘子系统上的数据库文件可以由自动存储管理（ASM）或备用卷管理器或文件系统管理。备份调整的注意事项会根据您是否使用ASM管理数据库文件而更改。当通道读取或写入磁盘时，I / O可以是同步I / O或异步I / O.在不支持本机异步I / O的操作系统上，数据库可以使用特殊的I / O从属进程对其进行仿真。这些过程专门用于代表另一个进程执行I / O.您可以使用RATE参数设置读取的字节数的上限，以便RMAN不会消耗过多的磁盘带宽并降低在线性能。从本质上讲，RATE充当备用节流阀。在复制阶段，通道将块从输入缓冲区复制到输出缓冲区并执行其他处理。备份到SBT时，RMAN为媒体管理软件提供字节流，并将唯一名称与此流关联。存储流的方式和位置的所有细节完全由媒体管理器处理。因此，备份到磁带涉及RMAN和媒体管理器的交互。影响SBT写入阶段的RMAN特定因素类似于影响磁盘读取的因素。在这两种情况下，缓冲区分配，从属进程以及同步或异步I / O都会影响性能。多种因素会影响备份到磁带的速度。如果磁带设备是远程的，则介质管理器必须通过网络传输数据。磁带本机传输速率是在没有压缩的情况下写入磁带的速度。此速度表示备份速率的上限。磁带压缩级别对备份性能非常重要。如果磁带具有良好的压缩性，则持续备份速率更快。写入操作期间的磁带流对磁带备份性能有重大影响。物理磁带块大小会影响备份性能。影响磁盘写入阶段的主要因素是缓冲区大小。通常，您可以使用V $视图开始调整过程，以确定RMAN备份和还原操作遇到问题的位置。您可以通过查询视图V $ SESSION_LONGOPS来监视备份和还原作业的进度。 RMAN在V $ SESSION_LONGOPS中使用两种类型的行：详细信息行和聚合行。您可以使用V $ BACKUP_SYNC_IO和V $ BACKUP_ASYNC_IO视图来确定备份或还原瓶颈的来源，并查看备份作业的详细进度。查询V $ BACKUP_SYNC_IO视图以识别具有同步I / O的瓶颈。查询V $ BACKUP_ASYNC_IO以识别异步I / O的瓶颈。许多因素都会影响备份性能。通常，找到缓慢备份的解决方案是一个反复试验的过程。通道上的RATE参数旨在减少而不是增加备份吞吐量，以便为其他数据库操作提供更多磁盘带宽。如果备份未流式传输到磁带，则确认未设置RATE参数。某些操作系统支持本机异步I / O.当且仅当您的磁盘不支持异步I / O时，请设置DBWR_IO_SLAVES。 DBWR_IO_SLAVES的任何非零值都会导致使用固定数量的磁盘I / O从站进行备份和还原，从而模拟异步I / O.如果数据库在警报日志中报告错误，则说明它不是，那么请设置LARGE_POOL_SIZE初始化参数。有足够的内存，无法启动I / O从属。您可以执行多项任务来识别和修复影响备份性能的瓶颈。确定输出设备或输入磁盘I / O是否是给定备份作业的瓶颈的一种可靠方法是将运行备份任务所需的时间与运行相同任务的BACKUP VALIDATE所需的时间进行比较。备份的BACKUP VALIDATE执行与真实备份相同的磁盘读取，但不对输出设备执行I / O.调整读取阶段有助于提高RMAN性能。如果读取阶段表现良好，那么复制或写入阶段可能是瓶颈。特别是，如果RMAN正在以足够快的速度向磁带驱动器发送数据块以支持流式传输，但磁带不是流式传输，那么SBT写入阶段就是瓶颈。">调整RMAN</a>磁带备份性能的讨论。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="BRADV89467"></a><div class="props_rev_3"><a id="GUID-21D5FCCE-7AF1-4CF8-BC53-2496ECE3C56E" name="GUID-21D5FCCE-7AF1-4CF8-BC53-2496ECE3C56E"></a><h4 id="BRADV-GUID-21D5FCCE-7AF1-4CF8-BC53-2496ECE3C56E" class="sect4"><span class="enumeration_section">6.2.6</span>配置备份加密</h4>
                  <div>
                     <p>为了提高安全性，您可以为RMAN备份集配置备份加密。如果未经授权的用户获取加密备份，则无法读取这些备份。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="configuring-rman-client-advanced.html#GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC" title="V $ RMAN_ENCRYPTION_ALGORITHMS视图包含RMAN支持的加密算法列表。如果未指定加密算法，则默认加密算法为128位高级加密标准（AES）。">关于备份加密</a></p>
                        </li>
                        <li>
                           <p><a href="configuring-rman-client-advanced.html#GUID-BAA3CFF0-C95C-4AF2-90DD-764754325D73" title="您可以使用CONFIGURE命令持久配置备份的透明加密。">配置RMAN备份加密模式</a></p>
                        </li>
                        <li>
                           <p><a href="configuring-rman-client-advanced.html#GUID-97ED7AA5-476C-4068-9C6C-97A0C0353864" title="您可以使用CONFIGURE命令持久配置在编写备份集时用于加密的默认算法。">配置备份加密算法</a></p>
                        </li>
                     </ul>
                  </div><a id="BRADV89468"></a><div class="props_rev_3"><a id="GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC" name="GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC"></a><h5 id="BRADV-GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC" class="sect5"><span class="enumeration_section">6.2.6.1</span>关于备份加密</h5>
                     <div>
                        <p><code class="codeph">V$RMAN_ENCRYPTION_ALGORITHMS</code>视图包含RMAN支持的加密算法列表。如果未指定加密算法，则默认加密算法为128位高级加密标准（AES）。
                        </p>
                        <p>RMAN加密要求目标数据库中的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=REFRN10019" target="_blank"><code class="codeph">COMPATIBLE</code></a>初始化参数至少为10.2.0。
                        </p>
                        <p><a href="glossary.html#GUID-8879C26C-4DF5-4040-BC7A-37CF7C482C56"><span class="xrefglossterm">Oracle Secure Backup</span></a> <a href="glossary.html#GUID-26FF62D0-5938-481D-B7B9-929BC971813E"><span class="xrefglossterm">介质管理软件</span></a>是唯一支持将加密RMAN备份直接发送到磁带的接口。如果您尝试使用Oracle Secure Backup以外的介质管理器创建加密的RMAN备份，则RMAN会发出<code class="codeph">ORA-19919</code>错误。
                        </p>
                        <p>将<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF107" target="_blank"><code class="codeph">BACKUP</code></a> <code class="codeph">BACKUPSET</code>命令与加密备份集一起使用时，备份集将以加密形式备份。由于<code class="codeph">BACKUP BACKUPSET</code>将已加密的备份集复制到磁盘或磁带，因此在<code class="codeph">BACKUP BACKUPSET</code>期间不需要解密密钥。在操作的任何部分期间，数据永远不会被解密。<code class="codeph">BACKUP BACKUPSET</code>命令既不能加密也不能解密备份集。
                        </p>
                        <p>如果所需的解密密钥可用，则在恢复和恢复期间会自动解密加密的备份。每个备份集都有一个单独的密钥。密钥以加密形式存储在备份片中。使用用户提供的密码或Oracle软件密钥库获取的密钥对备份进行解密。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC__GUID-0D13CE7B-061B-46E6-AA7D-3AF6EFA51CBB">RMAN加密模式</p>
                           <p>RMAN提供以下加密模式：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>透明加密</p>
                                 <p>这是默认模式，使用Oracle软件密钥库。密钥库是受密码保护的容器，用于存储透明数据加密（TDE）密钥。在以前的版本中，此容器称为钱包。</p>
                              </li>
                              <li>
                                 <p>密码加密</p>
                                 <p>此模式仅使用密码保护。创建和还原加密备份时，必须提供密码。</p>
                              </li>
                              <li>
                                 <p>双模加密</p>
                                 <p>此模式需要密钥库或密码。</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC__GUID-DFB3F9BF-87A5-4E6A-ABB6-2711A7BB9432">
                              <p class="notep1">注意：</p>
                              <p>基于密钥库的加密比基于密码的加密更安全，因为不涉及密码。仅在绝对必要时才使用基于密码的加密，因为备份必须是可传输的。</p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-6ED708C7-1092-45FC-80C6-236F062D0DAC__GUID-9C3073D0-226D-4529-85EB-C8BEE2FF1315">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="configuring-rman-client-advanced.html#GUID-00CCDDB4-E999-4956-AF30-15E7D622908B" title="如果所需的Oracle密钥管理基础结构可用，则透明加密可以在没有DBA干预的情况下创建和恢复加密备份。">备份的透明加密</a></p>
                                 </li>
                                 <li>
                                    <p><a href="configuring-rman-client-advanced.html#GUID-8D85E7DF-53FE-4AF8-811B-CA836B737B36" title="密码加密要求DBA在创建和还原加密备份时提供密码。恢复密码加密的备份需要使用与创建备份相同的密码。">备份的密码加密</a></p>
                                 </li>
                                 <li>
                                    <p><a href="configuring-rman-client-advanced.html#GUID-433BCC86-BA70-4D37-B9C3-92BACFAE72E8" title="可以透明地或通过指定密码来恢复双模式加密备份。">备份的双模式加密</a></p>
                                 </li>
                                 <li>
                                    <p>有关配置Oracle密钥库的详细信息，请参见<a href="../asoag/asopart1.html#ASOAG600" target="_blank"><span><cite>Oracle数据库高级安全性指南</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="BRADV89469"></a><div class="props_rev_3"><a id="GUID-00CCDDB4-E999-4956-AF30-15E7D622908B" name="GUID-00CCDDB4-E999-4956-AF30-15E7D622908B"></a><h6 id="BRADV-GUID-00CCDDB4-E999-4956-AF30-15E7D622908B" class="sect6"><span class="enumeration_section">6.2.6.1.1</span>备份的透明加密</h6>
                        <div>
                           <p>如果所需的Oracle密钥管理基础结构可用，则透明加密可以在没有DBA干预的情况下创建和恢复加密备份。</p>
                           <p>透明加密最适合日常备份操作，其中备份将还原到创建它们的同一数据库。透明加密是RMAN加密的默认设置。</p>
                           <p>使用透明加密时，必须首先为每个数据库配置Oracle软件密钥库。透明备份加密支持自动登录软件密钥库和基于密码的软件密钥库。使用自动登录软件密钥库时，可以随时执行加密备份操作，因为自动登录密钥库始终处于打开状态。使用基于密码的软件密钥库时，必须先打开密钥库，然后才能执行备份加密。</p>
                           <div class="infoboxnote" id="GUID-00CCDDB4-E999-4956-AF30-15E7D622908B__GUID-604DB61F-B710-4E6C-A560-A2135C536A70">
                              <p class="notep1">警告：</p>
                              <p>如果使用自动登录密钥库，请不要将其与加密备份数据一起备份，因为如果加密备份同时获得备份和自动登录密钥库，则用户可以读取加密备份。备份Oracle密钥库是安全的，因为如果没有密钥库密码，则无法使用该密钥库形式。</p>
                           </div>
                           <p>配置Oracle密钥库后，可以创建和还原加密备份，而无需进一步的DBA干预。如果数据库中的某些列使用透明数据加密（TDE）列加密进行加密，并且如果使用备份加密备份这些列，则在备份期间会再次对这些列进行加密。在还原操作期间解密备份集时，加密列将返回其原始加密形式。</p>
                           <p>由于Oracle密钥管理基础结构将归档Oracle密钥库中的所有先前主密钥，因此更改或重置当前数据库主密钥不会影响您使用较旧的主密钥还原加密备份的能力。您可以随时重置数据库主密钥。RMAN可以还原此数据库创建的所有加密备份。</p>
                           <div class="infoboxnote" id="GUID-00CCDDB4-E999-4956-AF30-15E7D622908B__GUID-37439C97-6B49-461B-9D69-6A5A2722218D">
                              <p class="notep1">警告：</p>
                              <p>如果丢失了Oracle密钥库，则无法还原任何透明加密的备份。</p>
                           </div>
                           <div class="infoboxnote" id="GUID-00CCDDB4-E999-4956-AF30-15E7D622908B__GUID-0FCA219B-5A49-4235-9D60-402C107B3BBA">
                              <p class="notep1">注意：</p>
                              <p>有关配置Oracle软件密钥库的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=ASOAG600" target="_blank"><span><cite>参见“Oracle数据库高级安全指南”</cite></span></a></p>
                           </div>
                        </div>
                     </div><a id="BRADV89470"></a><div class="props_rev_3"><a id="GUID-8D85E7DF-53FE-4AF8-811B-CA836B737B36" name="GUID-8D85E7DF-53FE-4AF8-811B-CA836B737B36"></a><h6 id="BRADV-GUID-8D85E7DF-53FE-4AF8-811B-CA836B737B36" class="sect6"><span class="enumeration_section">6.2.6.1.2</span>备份的密码加密</h6>
                        <div>
                           <p>密码加密要求DBA在创建和还原加密备份时提供密码。恢复密码加密的备份需要使用与创建备份相同的密码。</p>
                           <p>密码加密对于在远程位置还原但在传输过程中必须保持安全的备份非常有用。密码加密无法持久配置。如果仅使用密码加密，则无需配置Oracle密钥库。</p>
                           <div class="infoboxnote" id="GUID-8D85E7DF-53FE-4AF8-811B-CA836B737B36__GUID-7D76607A-D4F7-49FC-9ACA-3A595CC669BC">
                              <p class="notep1">警告：</p>
                              <p>如果您忘记或丢失了用于加密密码加密备份的密码，则无法恢复备份。</p>
                           </div>
                           <p>要使用密码加密，请在RMAN脚本中使用<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF153" target="_blank"><code class="codeph">SET</code></a> <code class="codeph">ENCRYPTION ON IDENTIFIED BY</code> <span class="italic"><code class="codeph">password</code></span> <code class="codeph">ONLY</code>命令。
                           </p>
                        </div>
                     </div><a id="BRADV89471"></a><div class="props_rev_3"><a id="GUID-433BCC86-BA70-4D37-B9C3-92BACFAE72E8" name="GUID-433BCC86-BA70-4D37-B9C3-92BACFAE72E8"></a><h6 id="BRADV-GUID-433BCC86-BA70-4D37-B9C3-92BACFAE72E8" class="sect6"><span class="enumeration_section">6.2.6.1.3</span>备份的双模式加密</h6>
                        <div>
                           <p>可以透明地或通过指定密码来恢复双模式加密备份。</p>
                           <p>当您创建通常使用Oracle密钥库在现场还原的备份时，双模式加密备份非常有用，但有时必须在异地还原Oracle密钥库不可用的备份。</p>
                           <p>还原双模式加密备份时，可以使用Oracle密钥库或密码进行解密。</p>
                           <div class="infoboxnote" id="GUID-433BCC86-BA70-4D37-B9C3-92BACFAE72E8__GUID-CE254F20-989F-4BEF-81F6-25EBC150E798">
                              <p class="notep1">警告：</p>
                              <p>如果您忘记或丢失了用于加密双模加密备份的密码，并且还丢失了Oracle密钥库，则无法还原备份。</p>
                           </div>
                           <p>要创建双模加密备份集，请在RMAN脚本中指定<code class="codeph">SET ENCRYPTION ON IDENTIFIED BY</code> <span class="italic"><code class="codeph">password</code></span>命令。
                           </p>
                        </div>
                     </div>
                  </div><a id="BRADV579"></a><a id="BRADV89472"></a><div class="props_rev_3"><a id="GUID-BAA3CFF0-C95C-4AF2-90DD-764754325D73" name="GUID-BAA3CFF0-C95C-4AF2-90DD-764754325D73"></a><h5 id="BRADV-GUID-BAA3CFF0-C95C-4AF2-90DD-764754325D73" class="sect5"><span class="enumeration_section">6.2.6.2</span>配置RMAN备份加密模式</h5>
                     <div>
                        <p>您可以使用<code class="codeph">CONFIGURE</code>命令持久配置备份的透明加密。
                        </p>
                        <div class="section">
                           <p>您可以使用该命令指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>是否对所有数据库文件的备份使用透明加密</p>
                              </li>
                              <li>
                                 <p>是否对特定表空间的备份使用透明加密</p>
                              </li>
                              <li>
                                 <p>用于加密备份的算法</p>
                              </li>
                           </ul>
                           <p>您还可以使用<code class="codeph">SET</code> <code class="codeph">ENCRYPTION</code>命令执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>覆盖<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF113" target="_blank"><code class="codeph">CONFIGURE</code></a> <code class="codeph">ENCRYPTION</code>命令指定的加密设置。例如，即使为加密备份配置了数据库，也可以使用<code class="codeph">SET</code> <code class="codeph">ENCRYPTION</code> <code class="codeph">OFF</code>创建未加密的备份。
                                 </p>
                              </li>
                              <li>
                                 <p>设置备份加密的密码，持续到RMAN客户端退出。由于密码的敏感性，RMAN不允许配置跨RMAN会话持久存在的密码。</p>
                              </li>
                           </ul>
                           <p>使用或不使用持久性配置设置可控制是否对已归档的重做日志备份进行加密。如果满足以下任何条件，则包含归档重做日志文件的备份集将被加密：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">SET</code> <code class="codeph">ENCRYPTION</code> <code class="codeph">ON</code>在创建存档日志备份时生效。
                                 </p>
                              </li>
                              <li>
                                 <p>加密配置为备份整个数据库或至少一个表空间。</p>
                              </li>
                           </ul>
                           <p>此行为可确保与数据文件的任何加密备份关联的重做也已加密。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-BAA3CFF0-C95C-4AF2-90DD-764754325D73__GUID-5BD7E370-C0BC-4ED1-952C-469333C563E3">要配置环境以便加密所有RMAN备份：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>按照<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=ASOAG600" target="_blank"><span><cite>Oracle数据库高级安全性指南中的</cite></span></a>说明设置Oracle密钥库。</span></li>
                           <li class="stepexpand"><span>发出以下RMAN命令：</span><div><pre class="oac_no_warn" dir="ltr">配置加密数据库;</pre><p>在此阶段，此数据库创建的所有RMAN备份集默认使用透明加密。</p>
                              </div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>您可以使用以下命令显式覆盖<a href="glossary.html#GUID-01D29658-41E1-4D45-9C7F-A761D56885B9"><span class="xrefglossterm">RMAN会话</span></a>的持久加密配置：</p><pre class="oac_no_warn" dir="ltr">SET ENCRYPTION ON;</pre><p>在RMAN会话期间发出<code class="codeph">SET</code> <code class="codeph">ENCRYPTION</code> <code class="codeph">OFF</code>命令，或使用以下命令再次更改持久设置之前，加密设置仍然有效：</p><pre class="oac_no_warn" dir="ltr">配置加密数据库加密;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="BRADV580"></a><a id="BRADV90077"></a><div class="props_rev_3"><a id="GUID-97ED7AA5-476C-4068-9C6C-97A0C0353864" name="GUID-97ED7AA5-476C-4068-9C6C-97A0C0353864"></a><h5 id="BRADV-GUID-97ED7AA5-476C-4068-9C6C-97A0C0353864" class="sect5"><span class="enumeration_section">6.2.6.3</span>配置备份加密算法</h5>
                     <div>
                        <p>您可以使用<code class="codeph">CONFIGURE</code>命令持久配置在编写备份集时用于加密的默认算法。
                        </p>
                        <div class="section">
                           <p>可能的值列在<code class="codeph">V$RMAN_ENCRYPTION_ALGORITHMS</code> 。默认算法是AES 128位。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-97ED7AA5-476C-4068-9C6C-97A0C0353864__GUID-4250D7C9-075E-416D-B0CA-95B5BA79912A">配置默认备份加密算法：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>启动RMAN并连接到目标数据库和恢复目录（如果使用）。</span></li>
                           <li class="stepexpand"><span>确保已装入或打开目标数据库。</span></li>
                           <li class="stepexpand"><span>执行<code class="codeph">CONFIGURE ENCRYPTION ALGORITHM</code>命令，从<code class="codeph">V$RMAN_ENCRYPTION_ALGORITHMS.ALGORITHM_NAME</code>指定有效值。</span><div>
                                 <p>以下示例将算法配置为AES 256位加密：</p><pre class="pre codeblock"><code>配置加密算法'AES256';</code></pre></div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
            </div><a id="BRADV14011"></a><div class="props_rev_3"><a id="GUID-9C633A44-5533-467E-9108-14BC088A1F82" name="GUID-9C633A44-5533-467E-9108-14BC088A1F82"></a><h3 id="BRADV-GUID-9C633A44-5533-467E-9108-14BC088A1F82" class="sect3"><span class="enumeration_section">6.3</span>配置辅助实例数据文件名</h3>
               <div>
                  <p>在执行诸如数据文件表空间时间点恢复（TSPITR）或使用RMAN进行数据传输等操作时，您可能希望在辅助实例中设置数据文件的名称。在启动TSPITR或数据库复制之前设置这些名称。</p>
                  <div class="section">
                     <p>该命令如下，其中<span class="italic"><code class="codeph">datafileSpec</code></span>通过其原始名称或数据文件编号标识某个数据文件， <span class="italic"><code class="codeph">filename</code></span>是指定文件的新路径：</p><pre class="pre codeblock"><code>CONFIGURE AUXNAME FOR <span class="italic">datafileSpec</span> TO ' <span class="italic"><code class="codeph">filename</code></span> ';</code></pre><p>例如，您可以为数据文件<code class="codeph">2</code>配置新的辅助名称，如下所示：</p><pre class="pre codeblock"><code>将DATAFILE 2的AUXNAME配置为'/newdisk/datafiles/df2.df';</code></pre><p>与其他设置一样， <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF113" target="_blank"><code class="codeph">CONFIGURE</code></a>命令设置在RMAN会话中保持不变，直到使用<code class="codeph">CONFIGURE</code>清除<code class="codeph">...</code> <code class="codeph">CLEAR</code> ，如以下示例所示：</p><pre class="pre codeblock"><code>配置数据文件的AUXNAME 2清除;</code></pre><p>如果您正在执行TSPITR或运行<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF126" target="_blank"><code class="codeph">DUPLICATE</code></a>命令，那么通过使用<code class="codeph">CONFIGURE AUXNAME</code>您可以预先配置文件名以便在辅助数据库上使用，而无需在过程中手动指定辅助文件名。
                     </p>
                     <p>使用<code class="codeph">DUPLICATE</code>命令重命名文件时， <code class="codeph">CONFIGURE AUXNAME</code>是<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RCMRF153" target="_blank"><code class="codeph">SET NEWNAME</code></a>命令的替代方法。不同之处在于，第一次设置<code class="codeph">AUXNAME</code>后，在发出另一个<code class="codeph">DUPLICATE</code>命令时无需重置文件名。在您发出<code class="codeph">CONFIGURE AUXNAME</code>之前， <code class="codeph">AUXNAME</code>设置仍然有效<code class="codeph">...</code> <code class="codeph">CLEAR</code> 。相反，每次重命名文件时都必须重新<code class="codeph">SET NEWNAME</code>命令。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9C633A44-5533-467E-9108-14BC088A1F82__GUID-E9229148-E15A-47D9-8CDC-3DF7E7D723A5">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="performing-rman-tspitr.html#GUID-CAACDB53-7C3A-45B4-8249-C5D855D47571" title="要有效地使用RMAN表空间时间点恢复（TSPITR），了解它可以解决的问题类型，组件，RMAN在TSPITR期间所执行的操作以及对何时以及如何进行的各种限制和限制很有帮助。跑。本节介绍运行RMAN的基本概念，准备任务和运行模式TSPITR。恢复管理器（RMAN）TSPITR可以将数据库中的一个或多个表空间快速恢复到较早的时间，而不会影响数据库中的其余表空间和对象。了解RMAN TSPITR的概念，例如使用的术语和模式。本节定义了RMAN TSPITR使用的一些常见实体。有几种运行RMAN TSPITR的模式。各种操作模式之间的差异对应于您的环境中需要多少自动化与自定义。在执行完全自动化的RMAN TSPITR（默认）之前，从恢复集，辅助目标和目标时间中选择表空间。由于某些限制和限制，TSPITR无法解决某些数据库问题。在执行TSPITR时需要考虑一些限制。在TSPITR期间不使用恢复目录时要注意某些预防措施。准备执行TSPITR时必须完成某些步骤。为您选择正确的目标时间或SCN非常重要。 TSPITR。请注意，在TSPITR之后将表空间联机后，您不能在使表空间联机的时间之前使用任何备份。最初，恢复集包括要恢复的表空间的数据文件。但是，如果表空间中的对象需要与其他表空间中的对象建立关系（例如约束），则必须先考虑这些关系才能执行TSPITRRMAN TSPITR要求正在恢复的表空间是自包含的，并且没有SYS拥有的对象驻留在表空间中。在表空间上执行RMAN TSPITR时，在目标恢复时间之后创建的对象将丢失。您可以通过在TSPITR之前使用数据泵导出实用程序导出这些对象并在之后使用数据泵导入重新导入这些对象来保留这些对象。在默认模式下，RMAN在目标数据库上尽可能多地使用TSPITR的配置。您可以自定义RMAN TSPITR的某些方面，同时仍然主要执行完全自动化的RMAN TSPITR的过程。您可能不希望恢复集数据文件在其原始位置恢复和恢复。SET NEWNAME命令可用于指定新目标。为恢复集指定新目标时，RMAN不会删除表空间的原始数据文件。与通常存储在其原始位置的恢复集数据文件不同，辅助集数据文件不得覆盖目标数据库中的相应原始文件。如果未指定与其原始位置不同的辅助集文件位置，则TSPITR将失败。当RMAN尝试覆盖原始数据库中的相应文件并发现正在使用的文件时，会发生故障。辅助集数据文件可以在目标中具有Oracle管理文件（OMF），并且可以使用自动存储管理（ASM）或非ASM存储。当设置了DB_FILE_NAME_CONVERT初始化参数且OMF文件位于ASM或非ASM存储中时，TSPITR以不同方式执行名称转换。您可以使用辅助数据库的DB_FILE_NAME_CONVERT和LOG_FILE_NAME_CONVERT初始化参数来指定磁盘组的转换。RMAN使用该模式转换ASM磁盘组名称，并在转换后的磁盘组中生成有效的OMF文件名。有多种方法可用于重命名辅助数据库的OMF（非ASM）文件名。要为辅助集数据文件指定新名称，可以将RECOVER TABLESPACE包含在RUN命令中，并使用RUN块中的SET NEWNAME命令重命名该文件。如果您不想为所有辅助集数据文件使用辅助目标，但又不想单独命名每个文件，则可以在辅助数据库使用的初始化参数文件中包含DB_FILE_NAME_CONVERT初始化参数。临时文件被视为数据库辅助集的一部分。在实例化辅助数据库时，RMAN将重新创建目标数据库的临时表空间，并使用辅助数据文件名的常规规则生成其名称。通过重定向RMAN以使用恢复集和辅助集数据文件的现有映像副本，可以增强TSPITR性能。在这种情况下，RMAN不需要从备份还原数据文件。使用SET NEWNAME命令可以在使用映像副本执行TSPITR时指定映像副本的位置。CONFIGURE AUXNAME命令为辅助集数据文件映像副本设置持久备用位置，而SET NEWNAME命令为RUN命令的持续时间设置备用位置。使用映像副本执行TSPITR时，此过程使用CONFIGURE AUXNAME。自动辅助数据库使用一组默认初始化参数。如果需要，您可以添加其他参数。如果使用初始化参数文件，则可以使用CONTROL_FILES初始化参数为辅助数据库的控制文件指定自己的位置要在辅助数据库上恢复它们后对辅助和恢复集执行恢复，RMAN可能需要还原存档日志。使用辅助目标时，存档日志将还原到该位置。如果在辅助数据库参数文件中指定LOG_FILE_NAME_CONVERT初始化参数，并且参数成功转换目标的联机重做日志的名称，则此参数将确定联机重做日志位置。虽然Oracle建议您让RMAN管理辅助数据库的所有方面，但有时您可能必须创建和管理自己的辅助数据库。如果选择此模式，则负责设置，启动，停止和清理TSPITR中使用的辅助数据库。创建适合用作辅助数据库的Oracle实例需要执行一组步骤。有多种方法可以为辅助数据库创建密码文件。使用文本编辑器为目标数据库主机上的辅助数据库创建初始化参数文件。辅助数据库必须具有有效的网络服务名称。在继续之前，请使用SQL * Plus确保您可以与辅助数据库建立SYSBACKUP或SYSDBA连接。使用您自己的辅助实例执行TSPITR时，请记住某些准则。可以覆盖使用自己的辅助数据库进行TSPITR时通道的默认行为。您可能希望使用SET NEWNAME命令来引用辅助集文件的现有映像副本以提高TSPITR性能，或者为TSPITR之后的恢复集文件分配新名称。如有必要，请计划这些命令，并将它们添加到为TSPITR运行的命令序列中。完成先决条件，然后按照本节中的步骤使用您自己的辅助数据库执行TSPITR。在开始RMAN TSPITR之前，必须启动辅助数据库。由于辅助数据库还没有控制文件，因此只能以NOMOUNT模式启动实例。启动RMAN并连接到目标数据库和手动创建的辅助数据库。使用RECOVER TABLESPACE命令使用您自己的辅助实例执行TSPITR。此过程使用RECOVER TABLESPACE ...UNTIL命令执行TSPITR。各种问题都可能导致RMAN TSPITR失败。必须确定并修复问题。目标数据库中的文件，SET NEWNAME或CONFIGURE AUXNAME命令分配的文件名以及DB_FILE_NAME_CONVERT参数的效果生成的文件名之间可能会发生名称冲突。在TSPITR期间，RMAN需要有关哪些表空间在TSPITR目标时间具有还原段的信息。如果使用此信息，通常可在恢复目录中使用此信息。如果您正在管理自己的辅助数据库并且TSPITR失败，请不要尝试在不解决错误的情况下重新运行TSPITR。">执行RMAN表空间时间点恢复（TSPITR）</a>以获取有关对<code class="codeph">CONFIGURE AUXNAME</code>使用<code class="codeph">CONFIGURE AUXNAME</code>更多详细信息</p>
                           </li>
                           <li>
                              <p><a href="rman-duplicating-databases.html#GUID-F31F9FCE-B610-49EB-B9DB-44B9AA4E838F" title="本章介绍如何使用DUPLICATE命令创建独立运行的数据库副本。">复制数据库</a>以获取有关在执行数据库复制时使用<code class="codeph">CONFIGURE AUXNAME</code>更多详细信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="BRADV141"></a><div class="props_rev_3"><a id="GUID-B7B61600-6DED-413D-B134-1DAE79627A01" name="GUID-B7B61600-6DED-413D-B134-1DAE79627A01"></a><h3 id="BRADV-GUID-B7B61600-6DED-413D-B134-1DAE79627A01" class="sect3"><span class="enumeration_section">6.4</span>配置快照控制文件位置</h3>
               <div>
                  <p>当RMAN需要控制文件的读取一致版本时，它会创建临时快照控制文件。在与恢复目录重新同步时或在备份当前控制文件时，RMAN需要快照控制文件。</p>
                  <p>快照控制文件的默认位置是特定于平台的，取决于每个目标数据库的Oracle主目录。例如，某些Linux平台上的默认文件名是<code class="codeph">$ORACLE_HOME/dbs/snapcf_@.f</code> 。如果为目标数据库配置了<a href="glossary.html#GUID-6E3CDD76-A573-4E5C-B12D-59C232C96C19"><span class="xrefglossterm">快速恢复区域</span></a> ，则快照控制文件的默认位置<span class="italic">不是</span>快速恢复区域。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-E6B5F469-175A-43F2-8021-EBCFAF53454E" title="您可以通过运行SHOW命令查看当前快照位置。">查看快照控制文件的已配置位置</a></p>
                     </li>
                     <li>
                        <p><a href="configuring-rman-client-advanced.html#GUID-8A31E7A9-A606-4535-A317-6DAD2E1AAE39" title="使用CONFIGURE SNAPSHOT CONTROLFILE NAME命令&#39;filepath&#39;命令更改快照控制文件的名称和路径。RMAN创建的后续快照控制文件使用指定的名称和路径。">设置快照控制文件的位置</a></p>
                     </li>
                  </ul>
               </div><a id="BRADV89474"></a><div class="props_rev_3"><a id="GUID-E6B5F469-175A-43F2-8021-EBCFAF53454E" name="GUID-E6B5F469-175A-43F2-8021-EBCFAF53454E"></a><h4 id="BRADV-GUID-E6B5F469-175A-43F2-8021-EBCFAF53454E" class="sect4"><span class="enumeration_section">6.4.1</span>查看快照控制文件的已配置位置</h4>
                  <div>
                     <p>您可以通过运行<code class="codeph">SHOW</code>命令查看当前快照位置。
                     </p>
                     <div class="section">
                        <p>此示例显示由默认规则确定的快照位置：</p><pre class="pre codeblock"><code>RMAN&gt; SHOW SNAPSHOT CONTROLFILE NAME;配置SNAPSHOT CONTROLFILE NAME为'/oracle/dbs/snapcf_trgt.f'; #default</code></pre><p>此示例显示具有非默认文件名的快照控制文件：</p><pre class="pre codeblock"><code>RMAN&gt; SHOW SNAPSHOT CONTROLFILE NAME;配置SNAPSHOT CONTROLFILE NAME为'/oracle/oradata/trgt/snap_trgt.ctl';</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="BRADV89475"></a><div class="props_rev_3"><a id="GUID-8A31E7A9-A606-4535-A317-6DAD2E1AAE39" name="GUID-8A31E7A9-A606-4535-A317-6DAD2E1AAE39"></a><h4 id="BRADV-GUID-8A31E7A9-A606-4535-A317-6DAD2E1AAE39" class="sect4"><span class="enumeration_section">6.4.2</span>设置快照控制文件的位置</h4>
                  <div>
                     <p>使用<code class="codeph">CONFIGURE SNAPSHOT CONTROLFILE NAME TO '</code>命令<code class="codeph">CONFIGURE SNAPSHOT CONTROLFILE NAME TO '</code> <span class="italic"><code class="codeph">filepath</code></span> <code class="codeph">'</code>命令更改快照控制文件的名称和路径。RMAN创建的后续快照控制文件使用指定的名称和路径。
                     </p>
                     <div class="section">
                        <p>在Oracle Real Application Clusters（Oracle RAC）环境中，快照控制文件位置必须位于共享存储上，即所有Oracle RAC实例均可访问的存储。</p>
                        <p>例如，启动RMAN，连接到目标数据库，然后输入：</p><pre class="pre codeblock"><code>配置SNAPSHOT CONTROLFILE NAME为'/oracle/oradata/trgt/snap_trgt.ctl';</code></pre><p>您还可以将快照控制文件名设置为<a href="glossary.html#GUID-D6545038-B176-4D0E-9B4B-E4187A063984"><span class="xrefglossterm">原始设备</span></a> 。
                        </p>
                        <p>要将快照控制文件位置重置为默认值，请运行<code class="codeph">CONFIGURE SNAPSHOT CONTROLFILE NAME CLEAR</code>命令。
                        </p>
                        <div class="infoboxnotealso" id="GUID-8A31E7A9-A606-4535-A317-6DAD2E1AAE39__GUID-B19AEA8A-A449-40C3-A0E3-1B2C5E0B3FAC">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="managing-recovery-catalog.html#GUID-87642B50-AF67-482E-A93D-291B8D2EED92" title="当RMAN执行重新同步时，它会将恢复目录与目标数据库的当前或备份控制文件进行比较，并使用缺少或更改的元数据更新目录。">重新同步恢复目录</a></p>
                              </li>
                              <li>
                                 <p>有关在Oracle RAC配置中处理快照控制文件的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=RACAD320" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="BRADV190"></a><a id="BRADV142"></a><div class="props_rev_3"><a id="GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE" name="GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE"></a><h3 id="BRADV-GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE" class="sect3"><span class="enumeration_section">6.5</span>配置RMAN以与共享服务器一起使用</h3>
               <div>
                  <p>RMAN无法通过共享服务器调度程序连接到目标数据库。RMAN需要专用的服务器进程。</p>
                  <div class="section">
                     <p>如果为共享服务器配置了目标数据库，则必须修改Oracle Net配置以为RMAN连接提供专用服务器进程。</p>
                     <p>为了确保在为共享服务器配置目标数据库时RMAN不连接到调度程序，RMAN使用的网络服务名称必须在连接字符串的<code class="codeph">CONNECT_DATA</code>属性中包含<code class="codeph">(SERVER=DEDICATED)</code> 。
                     </p>
                     <p>Oracle Net配置因系统而异。以下过程仅说明了一种方法。此方案假定<code class="codeph">tnsnames.ora</code>文件中的以下服务名称使用共享服务器体系结构连接到目标数据库，其中<code class="codeph">inst1</code>是<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=REFRN10194" target="_blank"><code class="codeph">SERVICE_NAMES</code></a>初始化参数的值：</p><pre class="pre codeblock"><code>inst1_shs =（DESCRIPTION =（ADDRESS =（PROTOCOL = tcp）（HOST = inst1_host）（port = 1521））（CONNECT_DATA =（SERVICE_NAME = inst1）（SERVER = shared）））</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE__GUID-E536EFA9-9E91-40E2-9052-5516BEE07822">要将RMAN与共享服务器一起使用：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>在<code class="codeph">tnsnames.ora</code>文件中创建一个连接到非共享SID的网络服务名称。例如，输入：</span><div><pre class="pre codeblock"><code>inst1_ded =（DESCRIPTION =（ADDRESS =（PROTOCOL = tcp）（HOST = inst1_host）（port = 1521））（CONNECT_DATA =（SERVICE_NAME = inst1）（SERVER = dedicated）））</code></pre></div>
                     </li>
                     <li class="stepexpand"><span>启动SQL * Plus，然后使用共享服务器和专用服务器服务名称进行连接，以确认每个会话的模式。</span><div>
                           <p>例如，使用<code class="codeph">SYSBACKUP</code>或<code class="codeph">SYSDBA</code>权限连接到<code class="codeph">inst1_ded</code> ，然后执行以下<code class="codeph">SELECT</code>语句（包括示例输出）：</p><pre class="pre codeblock"><code>SQL&gt; SELECT SERVER 2 FROM V $ SESSION 3 WHERE SID =（从V $ MYSTAT中选择DISTINCT SID）; SERVER --------- DEDICATED 1行选中。
</code></pre><p>要连接到共享服务器会话，请使用<code class="codeph">SYSBACKUP</code>或<code class="codeph">SYSDBA</code>权限连接到<code class="codeph">inst1_shs</code> ，然后执行以下<code class="codeph">SELECT</code>语句（包括示例输出）：</p><pre class="pre codeblock"><code>SQL&gt; SELECT SERVER 2 FROM V $ SESSION 3 WHERE SID =（从V $ MYSTAT中选择DISTINCT SID）; SERVER ---------共享1行选中。
</code></pre></div>
                     </li>
                     <li class="stepexpand"><span>启动RMAN并使用专用服务名称连接到目标数据库。（可选）连接到恢复目录。</span><div>
                           <div class="infoboxnotealso" id="GUID-58576D80-BCC4-45EC-B048-AB23A78A7AEE__GUID-61A96258-EE48-4955-9739-C0421D000A02">
                              <p class="notep1">也可以看看：</p>
                              <p>有关Oracle Net连接字符串语法的完整说明，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=NETRF005" target="_blank"><span><cite>参见</cite></span></a>特定于平台的Oracle文档和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=NETRF005" target="_blank"><span><cite>Oracle数据库网络服务参考</cite></span></a></p>
                           </div>
                        </div>
                     </li>
                  </ol>
               </div>
            </div><a id="BRADV89476"></a><div class="props_rev_3"><a id="GUID-AE80F99C-5368-4FC3-83C5-7261BF9174F0" name="GUID-AE80F99C-5368-4FC3-83C5-7261BF9174F0"></a><h3 id="BRADV-GUID-AE80F99C-5368-4FC3-83C5-7261BF9174F0" class="sect3"><span class="enumeration_section">6.6</span>启用丢失写入检测</h3>
               <div>
                  <p>当I / O子系统确认块写入完成时，会发生数据块丢失写入，但写入未在持久存储中发生。在随后的块读取中，I / O子系统返回数据块的陈旧版本，该版本可能用于更新数据库的其他块，从而破坏它。</p>
                  <p>您可以将<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=REFRN10268" target="_blank"><code class="codeph">DB_LOST_WRITE_PROTECT</code></a>初始化参数设置为<code class="codeph">TYPICAL</code>或<code class="codeph">FULL</code>以便数据库在重做日志中记录缓冲区高速缓存块读取。默认设置为<code class="codeph">NONE</code> 。当参数设置为<code class="codeph">TYPICAL</code> ，实例会在重做日志中记录缓存读取/写入表空间的缓存读取，但不会读取只读表空间。设置为<code class="codeph">FULL</code> ，实例还会记录只读表空间的读取。<code class="codeph">TYPICAL</code>模式的性能开销约为5到10％，对于<code class="codeph">FULL</code>模式可能更高。
                  </p>
                  <p>与Data Guard一起使用时，丢失写入检测最有效。在这种情况下，您在主数据库和备用数据库中都设置了<code class="codeph">DB_LOST_WRITE_PROTECT</code> 。当备用数据库在托管恢复期间应用重做时，它会读取相应的块并将SCN与重做日志中的SCN进行比较。如果主数据库上的块SCN低于备用数据库上的块SCN，则它会检测主数据库上的写入丢失并引发外部错误（ <code class="codeph">ORA-752</code> ）。如果SCN较高，则会检测到备用数据库上的写入丢失并引发内部错误（ <code class="codeph">ORA-600 [3020]</code> ）。在任何一种情况下，备用数据库都会在警报日志和跟踪文件中写入失败的原因。
                  </p>
                  <p>要修复主数据库上的丢失写入，必须启动到备用数据库的故障转移。要修复备用数据库上的丢失写入，必须重新创建整个备用数据库或仅还原受影响文件的备份。</p>
                  <p>当您不使用Data Guard时，启用丢失写入检测也很有用。在这种情况下，您可以通过两种方式遇到丢失写入：在正常数据库操作期间或在介质恢复期间。在第一种情况下，没有直接的方法来检测错误。诸如不一致表之间的间接症状无法明确地追溯到丢失的写入。但是，如果您在怀疑丢失写入<span class="italic">之前</span>保留了备份，则可以将此备份还原到备用位置并将其恢复。要诊断问题，请将数据库或表空间恢复到过时块读取的SCN，然后生成丢失的写入错误（ <code class="codeph">ORA-752</code> ）。
                  </p>
                  <p>如果在介质恢复期间遇到丢失的写入错误，则唯一的响应是使用<code class="codeph">RESETLOGS</code>选项打开数据库。数据库处于一致状态，但<code class="codeph">RESETLOGS</code> SCN之后的所有数据都将丢失。如果恢复数据库创建后创建的备份，则无法保证其他过时块未损坏数据库。存在这种可能性是因为恢复的备份可能是在较早丢失写入之后进行的。为了保证没有丢失的写入损坏数据库，您必须从数据库创建执行介质恢复，这对于大多数数据库环境来说不是一个实用的策略。
                  </p>
                  <div class="infoboxnotealso" id="GUID-AE80F99C-5368-4FC3-83C5-7261BF9174F0__GUID-81D36D44-3763-4BBC-A650-8C162F526B28">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=SBYDB00930" target="_blank"><span><cite>Oracle Data Guard概念和管理</cite></span></a> ，了解如何使用备用数据库进行丢失写入检测和修复</p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/bradv&amp;id=REFRN10268" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">DB_LOST_WRITE_PROTECT</code>初始化参数</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-00FAAA65-A77A-40B6-AA1E-E12BE274758E" name="GUID-00FAAA65-A77A-40B6-AA1E-E12BE274758E"></a><h3 id="BRADV-GUID-00FAAA65-A77A-40B6-AA1E-E12BE274758E" class="sect3"><span class="enumeration_section">6.7</span>启用暗影丢失写保护</h3>
               <div>
                  <p>影子丢失写保护提供快速检测和对数据块丢失重写的即时响应，从而最大限度地减少数据丢失和数据库修复时间。使用影子丢失写保护不是必需的备用数据库。</p>
                  <div class="section">
                     <p></p>
                     <p>当I / O子系统确认块写入完成时，会发生数据块丢失写入，但写入未在存储中发生。随后的块读取将返回数据块的陈旧版本，该版本可用于更新其他数据块，从而破坏数据。阴影丢失写保护使用影子表空间仅存储跟踪数据文件的SCN。当从磁盘读取跟踪数据块时，阴影丢失写保护通过将影子表空间中的块的SCN与正在读取的块中的最近写入的SCN进行比较来检测丢失的写入。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="p">
                     <p>可以在数据库级别，PDB级别，表空间级别或数据文件级别启用阴影丢失写保护。数据库兼容级别必须为18.0.0或更高。</p>
                     <p>要使用阴影丢失写保护：</p>
                  </div>
                  <!-- class="section" -->
                  <ul>
                     <li><span>使用带有<code class="codeph">LOST WRITE PROTECTION</code>子句的<code class="codeph">CREATE BIGFILE TABLESPACE</code>命令为阴影丢失写保护创建一个或多个影子表空间。</span></li>
                     <li><span>在所需级别（数据库，PDB，表空间或数据文件）启用阴影丢失写保护。使用带有<code class="codeph">ENABLE LOST WRITE PROTECTION</code>子句的<code class="codeph">ALTER</code>命令启用阴影丢失写保护。</span></li>
                  </ul>
                  <div class="section">
                     <p>当启用了阴影丢失写保护时，RMAN会检查正在读取的块是否存在丢失写入。如果找到任何丢失的写入，则会显示错误并中止备份操作。</p>
                     <div class="infoboxnote" id="GUID-00FAAA65-A77A-40B6-AA1E-E12BE274758E__GUID-8E738ACF-CD4B-447C-BC53-A1481937E169">
                        <p class="notep1">注意：</p>阴影丢失写保护与使用<code class="codeph">DB_LOST_WRITE_PROTECT</code>初始化参数配置的丢失写保护<code class="codeph">DB_LOST_WRITE_PROTECT</code> 。
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../admin/managing-tablespaces.html#ADMIN-GUID-23154DE0-B2AA-4D73-BBCA-73ED5786FF2B" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="01400.overview-oracle-database-qos-management.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This section provides a basic description of how Oracle Database QoS Management works, and of how it evaluates the performance of workloads on your system."></meta>
      <meta name="description" content="This section provides a basic description of how Oracle Database QoS Management works, and of how it evaluates the performance of workloads on your system."></meta>
      <title>Oracle数据库QoS管理概述</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="User’s Guide"></meta>
      <meta property="og:description" content="This section provides a basic description of how Oracle Database QoS Management works, and of how it evaluates the performance of workloads on your system."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="User’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="autonomous-health-framework-users-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-21T23:14:30-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96320-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="benefits-using-qos-management.html" title="Previous" type="text/html"></link>
      <link rel="next" href="what-does-qos-management-manage.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Autonomous Health Framework User’s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ATNMS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="benefits-using-qos-management.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="what-does-qos-management-manage.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">用户指导</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-database-qos-management.html" property="item" typeof="WebPage"><span property="name">监视和管理数据库工作负载性能</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-oracle-database-qos-management.html" property="item" typeof="WebPage"><span property="name">Oracle数据库QoS管理简介</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Oracle数据库QoS管理概述</li>
            </ol>
            <a id="GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" name="GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2"></a>
            
            <h2 id="ATNMS-GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" class="sect2"><span class="enumeration_section">6.3</span> Oracle数据库QoS管理概述</h2>
         </header>
         <div class="ind">
            <div>
               <p>本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E">Oracle数据库QoS管理如何工作？</a><br>使用Oracle数据库，您可以使用服务来管理系统上的工作负载，方法是在专用于特定工作负载的服务器组上启动服务。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD">策略集概述</a><br>通过策略集，您可以指定资源，性能类（工作负载）以及为每个性能类指定性能目标的一个或多个性能策略。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8">服务器池概述</a><br>通过引入服务器池来逻辑划分集群，您可以在保持工作负载隔离的同时实现物理整合和资源灵活性的优势。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-D1481603-2C0A-4EEA-8363-D4E7CF569D43">Oracle数据库QoS管理如何使用服务器池</a><br>您应该根据需要管理的工作负载创建一个或多个服务器池。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F">性能类概述</a><br>策略集包含在群集上运行的各种性能类或工作负载的性能目标。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4">绩效政策和绩效目标概述</a><br>要管理各种性能目标，请定义一个或多个性能策略。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C">Oracle数据库QoS管理如何收集和分析性能数据</a><br>Oracle数据库QoS管理服务器从群集中的Oracle Real Application Clusters（Oracle RAC）和Oracle RAC One Node数据库中检索度量数据。
                  </li>
                  <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87">建议概述</a><br>Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="introduction-oracle-database-qos-management.html#GUID-8CB70EEB-3E9E-4417-ACA3-90A99CC83962" title="本章概述了Oracle数据库服务质量管理（Oracle数据库QoS管理）。">Oracle数据库QoS管理简介</a></p>
                  </div>
               </div>
            </div>
            <a id="APQOS115"></a><div class="props_rev_3"><a id="GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E" name="GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E"></a><h3 id="ATNMS-GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E" class="sect3"><span class="enumeration_section">6.3.1</span> Oracle数据库QoS管理如何工作？
               </h3>
               <div>
                  <p>使用Oracle数据库，您可以使用服务来管理系统上的工作负载，方法是在专用于特定工作负载的服务器组上启动服务。</p>
                  <p>例如，在数据库层，您可以将一组服务器专用于联机事务处理（OLTP），将另一组服务器专用于应用程序测试，并将第三组服务器专用于内部应用程序。系统管理员可以通过手动更改允许运行数据库服务的服务器数量，将资源分配给特定工作负载。</p>
                  <p>以这种方式使用服务器组将工作负载彼此隔离，以防止一个工作负载中的需求激增，故障和其他问题影响其他工作负载。但是，在此类部署中，您必须单独为每个组配置服务器，以满足每个工作负载的峰值需求，因为资源不会共享。</p>
                  <p>Oracle数据库QoS管理执行以下操作：</p>
                  <ol>
                     <li>
                        <p>使用QoS管理员创建的策略执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用传入工作请求的属性（例如应用程序连接的数据库服务）将每个工作请求分配给<a href="glossary.html#GUID-9170758C-1211-4A7B-B8A0-0E80316F5D2B"><span class="xrefglossterm">Performance Class</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>确定每个Performance Class的目标响应时间（ <a href="glossary.html#GUID-01F7E040-A79E-4934-80EF-DBD8A9D6F24B"><span class="xrefglossterm">Performance Objectives</span></a> ）。
                              </p>
                           </li>
                           <li>
                              <p>确定哪些绩效类对您的业务最重要</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>监视所有Performance Classes的资源使用和资源等待时间。</p>
                     </li>
                     <li>
                        <p>分析性能等级对针对该性能等级有效的性能目标的平均响应时间</p>
                     </li>
                     <li>
                        <p>生成重新分配资源的建议，以提高超出其目标响应时间的性能类的性能，并提供对实施该建议时每个性能类的性能级别的预测影响的分析。</p>
                     </li>
                     <li>
                        <p>在Oracle数据库QoS管理管理员指示时实施建议中列出的操作，然后在重新分配资源后评估系统以验证每个性能类是否满足其性能目标。</p>
                     </li>
                  </ol>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-83F3B2AF-3943-45EB-8264-779C4E3CFE26">Oracle数据库QoS管理和服务器池</a><br>您可以使用服务器池在群集中创建服务器组以提供工作负载隔离。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-8047A7B0-E167-4691-857D-12C05E417AB7">Oracle数据库QoS管理和实例囚笼</a><br>当多个数据库实例共享一个服务器时，它们必须共享其CPU，内存和I / O带宽。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-90C63BA2-680D-400E-A883-9269AF1EB4B3">Oracle数据库QoS管理和服务</a><br>Oracle数据库QoS管理使用数据库服务来监视和管理客户端和应用程序工作负载。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="APQOS357"></a><div class="props_rev_3"><a id="GUID-83F3B2AF-3943-45EB-8264-779C4E3CFE26" name="GUID-83F3B2AF-3943-45EB-8264-779C4E3CFE26"></a><h4 id="ATNMS-GUID-83F3B2AF-3943-45EB-8264-779C4E3CFE26" class="sect4"><span class="enumeration_section">6.3.1.1</span> Oracle数据库QoS管理和服务器池</h4>
                  <div>
                     <p>您可以使用服务器池在群集中创建服务器组以提供工作负载隔离。</p>
                     <p>服务器任何时候都只能属于一个服务器池。您可以在单个服务器池中或跨多个服务器池创建Oracle数据库。Oracle数据库QoS管理可以根据测量和预计的需求，提出将服务器从一个服务器池移动到另一个服务器池的建议。Oracle数据库QoS管理还可以重新定位服务器以满足当前有效的性能目标。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../cwadd/policy-based-cluster-and-capacity-management.html#CWADD92105" target="_blank"><span><cite>“Oracle Clusterware管理和部署指南”</cite></span></a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E" title="使用Oracle数据库，您可以使用服务来管理系统上的工作负载，方法是在专用于特定工作负载的服务器组上启动服务。">Oracle数据库QoS管理如何工作？</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="APQOS359"></a><a id="APQOS358"></a><div class="props_rev_3"><a id="GUID-8047A7B0-E167-4691-857D-12C05E417AB7" name="GUID-8047A7B0-E167-4691-857D-12C05E417AB7"></a><h4 id="ATNMS-GUID-8047A7B0-E167-4691-857D-12C05E417AB7" class="sect4"><span class="enumeration_section">6.3.1.2</span> Oracle数据库QoS管理和实例囚笼</h4>
                  <div>
                     <p>当多个数据库实例共享一个服务器时，它们必须共享其CPU，内存和I / O带宽。</p>
                     <p>Instance Caging通过使用Oracle数据库资源管理器和<code class="codeph">CPU_COUNT</code>数据库初始化参数来限制Oracle数据库实例消耗的CPU量。使用Oracle数据库QoS管理时，服务器的所有实例的<code class="codeph">CPU_COUNT</code>值的总和必须小于或等于物理CPU的总数。此外，每个CPU分区或<span class="bold">切片</span>在服务器池中的每个数据库实例的厚度（CPU数）必须一致。这些要求有助于确保每个数据库的可预测和隔离性能。
                     </p>
                     <div class="figure" id="GUID-8047A7B0-E167-4691-857D-12C05E417AB7__GUID-0EF6AEF0-52E6-4B6E-88AF-82381132E8A4">
                        <p class="titleinfigure">图6-1实例囚笼和CPU片</p><img src="img/apqos008.png" alt="下面是图6-1的描述" title="下面是图6-1的描述" longdesc="img_text/apqos008.html"><br><a href="img_text/apqos008.html">“图6-1实例囚笼和CPU片”的说明</a></div>
                     <!-- class="figure" -->
                     <p>实施实例监视时，Oracle数据库QoS管理可以提供建议，以便将CPU资源从一个片重新分配到同一服务器池中的另一个片。如果您选择实施修改实例分区设置的建议，则Oracle数据库QoS管理会统一修改服务器池中服务器上运行的所有数据库实例的<code class="codeph">CPU_COUNT</code>参数。
                     </p>
                     <p>修改<code class="codeph">CPU_COUNT</code>参数并配置Oracle数据库QoS管理以激活资源计划可启用实例囚笼功能。使用Instance Caging约束实例的CPU使用情况时，该实例可能会受CPU限制。这是资源管理器开始工作时，根据活动资源计划在各种数据库会话之间分配CPU份额。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E" title="使用Oracle数据库，您可以使用服务来管理系统上的工作负载，方法是在专用于特定工作负载的服务器组上启动服务。">Oracle数据库QoS管理如何工作？</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS360"></a><div class="props_rev_3"><a id="GUID-90C63BA2-680D-400E-A883-9269AF1EB4B3" name="GUID-90C63BA2-680D-400E-A883-9269AF1EB4B3"></a><h4 id="ATNMS-GUID-90C63BA2-680D-400E-A883-9269AF1EB4B3" class="sect4"><span class="enumeration_section">6.3.1.3</span> Oracle数据库QoS管理和服务</h4>
                  <div>
                     <p>Oracle数据库QoS管理使用数据库服务来监视和管理客户端和应用程序工作负载。</p>
                     <p>在Oracle RAC集群中，Oracle数据库QoS管理监视提供数据库服务的服务器池和节点。服务只能在一个服务器池中运行。如果数据库跨多个服务器池，则必须创建多个服务才能访问所有服务器池中的实例。</p>
                     <p>对于管理员管理的数据库，所有实例都在通用服务器池中运行，并且服务在特定实例上运行，但仍在单个池中。</p>
                     <p>使用由Oracle Clusterware管理的数据库服务监视连接到数据库的客户端和应用程序的工作负载。连接必须使用Java数据库连接（JDBC）（粗或细）或Oracle调用接口（OCI）。连接应使用服务及其运行时目标，以将负载平衡通知设置为<code class="codeph">SERVICE_TIME</code> ，并将连接负载平衡目标设置为<code class="codeph">LONG</code> 。例如：</p><pre class="pre codeblock"><code>srvctl修改服务-db <span class="variable" translate="no">db_name</span> -service <span class="variable" translate="no">service_name</span> -rlbgoal SERVICE_TIME -clbgoal LONG-cardinality UNIFORM</code></pre><p>您必须按如下方式定义数据库服务的基数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果运行服务的服务器池的最大大小大于1（或UNLIMITED），则将服务的基数设置为<code class="codeph">UNIFORM</code> 。</p>
                        </li>
                        <li>
                           <p>如果运行服务的服务器池的最大大小为1，则将服务的基数设置为<code class="codeph">SINGLETON</code> 。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../racad/workload-management-with-dynamic-database-services.html#RACAD076" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-63EFF0CB-F2AF-4738-8C5F-AD2AC6062F4E" title="使用Oracle数据库，您可以使用服务来管理系统上的工作负载，方法是在专用于特定工作负载的服务器组上启动服务。">Oracle数据库QoS管理如何工作？</a></p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="APQOS315"></a><a id="APQOS314"></a><div class="props_rev_3"><a id="GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD" name="GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD"></a><h3 id="ATNMS-GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD" class="sect3"><span class="enumeration_section">6.3.2</span>策略集概述</h3>
               <div>
                  <p>通过策略集，您可以指定资源，性能类（工作负载）以及为每个性能类指定性能目标的一个或多个性能策略。</p>
                  <p>Oracle数据库QoS管理的核心概念是<a href="glossary.html#GUID-2D3BCFE5-121C-4126-863C-053B6BECB7B9"><span class="xrefglossterm">策略集</span></a> 。通过策略集，您可以指定资源，性能类（工作负载）以及为每个性能类指定性能目标的一个或多个性能策略。策略集还可以指定资源可用性的约束。Oracle数据库QoS管理性能策略管理每个性能类的系统资源可用性，以便系统能够满足您在性能策略中设置的性能目标。
                  </p>
                  <p>使用Oracle Enterprise Manager为系统创建新的默认策略时，Oracle数据库QoS管理提供默认分类规则和关联的性能类名称。例如，在创建初始策略集时，Oracle数据库QoS管理会发现群集中的所有数据库服务，并为每个服务创建一个性能类。通过将<code class="codeph">_pc</code>附加到服务名称来命名性能类。例如，如果服务名称是<code class="codeph">sales</code> ，则分配给该服务的Performance Class的名称为<code class="codeph">sales_pc</code> 。
                  </p>
                  <p>策略集中只有一个性能策略可以随时处于活动状态。您可以使用日历计划，维护窗口，事件等激活性能策略以响应特定要求。</p>
                  <p>创建策略集时，您可以指定群集中的哪些服务器池应由Oracle数据库QoS管理进行管理。您还可以定义性能类（用于对具有类似性能要求的工作负载进行分类）。然后，您可以创建性能策略，以指定哪些性能类具有最高优先级以及每个性能类的性能目标。为了满足性能目标，Oracle数据库QoS管理提出了在需要时重新分配资源的建议，并预测建议的操作将对每个性能类满足其性能目标的能力产生什么影响。</p>
                  <p>例如，您可以创建一个策略来在工作时间管理应用程序工作负载。在此期间，客户用于购买产品或服务的应用程序是您的业务的最高优先级。您还高度重视订单履行和结算应用程序。在此期间，人力资源和企业资源规划（ERP）应用程序的优先级较低。如果您的在线销售应用程序需求激增，那么Oracle数据库QoS管理可能会建议将更多资源分配给销售应用程序，并从不太重要的应用程序中删除。该建议还包括对每个绩效类别的绩效变化（正面或负面）的预测。</p>
                  <p>策略集<a href="overview-oracle-database-qos-management.html#GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD__CHDHHCEI">如图6-2</a>所示，包含以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>由Oracle数据库QoS管理管理的服务器池</p>
                     </li>
                     <li>
                        <p>性能类，具有类似性能目标的工作请求组</p>
                     </li>
                     <li>
                        <p>性能策略，描述如何使用以下方法将资源分配给Performance Classes：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="glossary.html#GUID-01F7E040-A79E-4934-80EF-DBD8A9D6F24B"><span class="xrefglossterm">绩效目标</span></a></p>
                           </li>
                           <li>
                              <p><a href="glossary.html#GUID-6203C43A-9092-4EA1-B30F-DC59028390B1"><span class="xrefglossterm">绩效等级排名</span></a></p>
                           </li>
                           <li>
                              <p><a href="glossary.html#GUID-3413500E-0636-4512-A864-E55D564FA9A7"><span class="xrefglossterm">服务器池指令覆盖</span></a></p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <div class="figure" id="GUID-B13CD38F-885A-4CF4-BB18-E9C3D5C4E9FD__CHDHHCEI">
                     <p class="titleinfigure">图6-2 Oracle数据库QoS管理策略集的元素</p><br><div class="imagecenter"><img class="imagecenter" src="img/apqos005.png" alt="下面是图6-2的描述" title="下面是图6-2的描述" longdesc="img_text/apqos005.html"><br><a href="img_text/apqos005.html">“图6-2 Oracle数据库QoS管理策略集的元素”的说明</a></div><br></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" title="要管理各种性能目标，请定义一个或多个性能策略。">绩效政策和绩效目标概述</a></li>
                        <li><a href="overview-oracle-database-qos-management.html#GUID-5E13E0A5-AD14-4FC9-953F-A9E75C5053D7" title="分类发生在新工作进入系统的任何地方。">将分类器应用于工作请求</a></li>
                        <li><a href="configuring-qos-management-manage-db-workloads.html#GUID-30E4E30E-67A2-4CE8-874C-98959D5F4280">创建初始策略集</a></li>
                        <li><a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></li>
                        <li><a href="administering-policy-set.html#GUID-B461C1AD-F467-4F5E-BE7E-AE7C8D8E87C3" title="无论您是第一次配置Oracle数据库QoS管理系统，还是想要创建新的策略集，都可以使用“创建策略集”向导来创建策略集。">管理策略集</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="APQOS316"></a><a id="APQOS361"></a><a id="APQOS117"></a><div class="props_rev_3"><a id="GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8" name="GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8"></a><h3 id="ATNMS-GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8" class="sect3"><span class="enumeration_section">6.3.3</span>服务器池概述</h3>
               <div>
                  <p>通过引入服务器池来逻辑划分集群，您可以在保持工作负载隔离的同时实现物理整合和资源灵活性的优势。</p>
                  <p>在决定为您的企业创建多少个集群时，您需要通过整合服务器来比较可能节省的成本，以及整合工作负载以某种重要方式相互干扰的风险。通过引入服务器池来逻辑划分集群，您可以在保持工作负载隔离的同时实现物理整合和资源灵活性的优势。</p>
                  <p>作为管理员，您可以定义可在各种服务器池中运行的工作负载， <a href="overview-oracle-database-qos-management.html#GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8__BABDAFHF">如图6-3</a>所示。连接到Oracle RAC数据库的应用程序使用仅在当前分配给该服务器池的服务器上运行的服务。例如，在<a href="overview-oracle-database-qos-management.html#GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8__BABDAFHF">图6-3中</a> ，使用OS服务的连接和应用程序仅访问HR服务器池中的服务器，因此这些连接完成的工作不会干扰使用Sales服务的应用程序。Oracle数据库QoS管理可以帮助您管理每个组中的资源分配以满足您的服务级别，并可以自动重新分配资源以满足业务需求的变化。
                  </p>
                  <div class="figure" id="GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8__BABDAFHF">
                     <p class="titleinfigure">图6-3服务器池，Oracle数据库和数据库服务图</p><img src="img/apqos003.png" alt="下面是图6-3的描述" title="下面是图6-3的描述" longdesc="img_text/apqos003.html"><br><a href="img_text/apqos003.html">“图6-3服务器池，Oracle数据库和数据库服务图”的说明</a></div>
                  <!-- class="figure" -->
                  <p>使用服务器池，您现在可以创建可作为单个实体进行管理的服务器组。可以创建数据库以在这些服务器池中运行。如果每个服务器仅运行数据库的单个实例，那么如果数据库需要更多资源，则可以将另外的服务器分配给服务器池。如果在单个服务器上运行多个数据库实例，则它们必须竞争该服务器的共享资源，例如内存和CPU。如果其中一个数据库实例的工作负载远远高于其他实例，则该数据库实例可能会显着降低在同一服务器上运行的其他实例的性能。</p>
                  <p>您可以使用Instance Caging来限制Oracle Database实例消耗的CPU量。通过设置<code class="codeph">CPU_COUNT</code>参数来限制实例可以使用的最大CPU数，可以在服务器上的数据库实例之间对CPU进行分区，从而防止它们使用过多的CPU资源。对于服务器池中的每个数据库实例， <code class="codeph">CPU_COUNT</code>设置必须相同。Oracle数据库QoS管理可以监视服务器池中所有数据库实例的CPU使用情况，并在需要时建议更改当前设置。
                  </p>
                  <div class="figure" id="GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8__GUID-11ED9A94-E915-41ED-AFCB-1D9E3DF02D3D">
                     <p class="titleinfigure">图6-4服务器池和CPU片</p><img src="img/apqos009.png" alt="下面是图6-4的描述" title="下面是图6-4的描述" longdesc="img_text/apqos009.html"><br><a href="img_text/apqos009.html">“图6-4服务器池和CPU片”的说明</a></div>
                  <!-- class="figure" -->
                  <p>Oracle建议您通过创建多个服务器池来管理服务，并在它们之间重新定位服务，而不是使用单个服务器池。使用此配置可提供以下好处：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不同类型的工作负载需要不同的配置，并且具有不同的调整目标。例如，使用您的OLTP应用程序购买商品或服务的客户希望运输和付款信息屏幕能够快速响应。如果您的申请需要很长时间来处理订单，那么客户可能会失去兴趣，您的公司可能会失去销售。相比之下，使用内部人力资源应用程序的员工有动力继续使用人力资源屏幕，即使他们没有快速响应。如果您的人力资源应用程序需要比预期更长的时间来处理在线任务，则员工不太可能退出。</p>
                     </li>
                     <li>
                        <p>应用程序可以在一天，一周或一个月内满足您的业务目标。您可以使用服务器池在应用程序工作负载之间划分资源。要满足给定时间段的性能目标，可以在性能策略中使用服务器池指令覆盖来更改服务器池的默认属性（如Max或Min）。</p>
                        <p>例如，如果您的公司有在线纳税申请，那么申请必须在政府规定的截止日期之前为您的客户准备并提交税务报表。在申请截止日期之前的时间范围内，与税务报表编制和备案相关的申请需要比一年中其他时间更多的资源。为确保满足此服务要求，您可以创建名为QuarterlyFilings的性能策略以覆盖标准服务器池指令，并指定当QuarterlyFilings处于活动状态时，税务准备应用程序使用的服务器池应至少具有四个服务器而不是两个来处理额外的工作量。当QuarterlyFilings性能策略未生效时，您的默认性能策略生效，并且该服务器池中的最小服务器数为2。</p>
                     </li>
                     <li>
                        <p>由于Oracle数据库QoS管理规范了支持工作负载的服务器数量，因此即使存在不断变化的需求级别，应用程序用户也会体验到一致的性能水平。这可以防止在工作负载级别从低需求变为高需求时重置客户的性能预期。</p>
                        <p>例如，假设您的公司销售一种需求量很大的新消费产品，而您的公司宣称他们以较低的价格销售大量该产品。因此，许多新客户为此产品创建订单，并且您的OLTP应用程序必须处理快速增加的交易数量（需求激增）。新客户不知道对OLTP应用程序性能的期望。但是，如果他们的在线购物体验受到大量新客户的影响，现有客户可能会做出负面反应。此外，如果您的OLTP应用程序无法处理所有传入的订单，则某些新客户可能会退出该应用程序并将订单发送到其他公司，或者访问零售商店。</p>
                        <p>Oracle数据库QoS管理可帮助您管理可用资源的重新分配，以满足需求激增，而不会牺牲其他应用程序的服务质量。</p>
                     </li>
                     <li>
                        <p>某些工作负载不能很好地扩展，但仍然可以从集群环境的高可用性中受益。在固定大小的服务器池中部署这些工作负载可提供性能可管理性和高可用性。</p>
                        <p>例如，如果在具有固定大小的一个服务器的服务器池中运行ERP应用程序，则服务器池的最大大小和服务器池的最小大小都将设置为1。如果该服务器池中的服务器出现故障，则Oracle Clusterware会自动将新服务器分配给服务器池，以维护一台服务器的最小大小。位于故障服务器上的任何实例和服务都将在新服务器上重新启动，因此使用这些实例和服务的应用程序仍然可用。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-2C9A450E-5303-4F4B-9FCB-8D81D6A861C8__GUID-DBED03E3-20F7-41E9-BED3-0FAA986D3289">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关服务器池的详细信息，请参阅<a href="../cwadd/policy-based-cluster-and-capacity-management.html#CWADD92105" target="_blank"><span><cite>“Oracle Clusterware管理和部署指南”</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关策略管理的Oracle RAC数据库的详细信息<a href="../racad/introduction-to-oracle-rac.html#RACAD8889" target="_blank"><span><cite>，请参见“Oracle Real Application Clusters管理和部署指南”</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../cncpt/topics-for-database-administrators-and-developers.html#CNCPT1453" target="_blank"><span><cite>Oracle Database Concepts，</cite></span></a>用于描述OLTP系统</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="APQOS269"></a><div class="props_rev_3"><a id="GUID-D1481603-2C0A-4EEA-8363-D4E7CF569D43" name="GUID-D1481603-2C0A-4EEA-8363-D4E7CF569D43"></a><h3 id="ATNMS-GUID-D1481603-2C0A-4EEA-8363-D4E7CF569D43" class="sect3"><span class="enumeration_section">6.3.4</span> Oracle数据库QoS管理如何使用服务器池</h3>
               <div>
                  <p>您应该根据需要管理的工作负载创建一个或多个服务器池。</p>
                  <p>首次为群集安装Oracle Grid Infrastructure时，将创建默认服务器池（ <span class="bold">空闲池</span> ）。所有服务器最初都放在此服务器池中。创建新服务器池时，分配给该服务器池的服务器将自动移出空闲池并放置在新创建的服务器池中。此时，您可以安装要在该服务器池中运行的数据库，并创建由Oracle Clusterware管理的数据库服务，以便应用程序连接到该数据库。
                  </p>
                  <p>要使Oracle RAC数据库利用服务器池的灵活性，必须使用策略管理的部署选项创建数据库，该选项将数据库放在一个或多个服务器池中。</p>
                  <p>在Oracle Database 12 <span class="italic">c第</span> 1版（12.1.0.2）中，Oracle数据库服务质量（QoS）管理支持仅限测量和监控模式下的管理员管理的Oracle RAC和Oracle RAC One Node数据库。从Oracle Database 12 <span class="italic">c第</span> 2版（12.2.0.1）开始，您可以在管理模式下将Oracle数据库QoS管理与Oracle RAC和Oracle RAC One Node数据库一起使用，这些数据库由策略管理或管理员管理。
                  </p>
                  <div class="infoboxnote" id="GUID-D1481603-2C0A-4EEA-8363-D4E7CF569D43__GUID-76E29369-171F-4219-A1DB-C8089F301C28">
                     <p class="notep1">警告：</p>
                     <p>如果在创建服务器池时使用候选服务器列表（ <code class="codeph">server_names</code>属性）或类别，则Oracle数据库服务质量（QoS）管理扩展服务器池的能力将受到这些限制的限制，因为无法使用不符合条件的服务器。
                     </p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../rilin/using-server-pools-with-oracle-rac.html#RILIN1063" target="_blank"><span><cite>适用于Linux和UNIX的Oracle Real Application Clusters安装指南</cite></span></a></li>
                        <li><a href="../racad/administering-database-instances-and-cluster-databases.html#RACAD8211" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
            </div><a id="APQOS317"></a><div class="props_rev_3"><a id="GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" name="GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F"></a><h3 id="ATNMS-GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" class="sect3"><span class="enumeration_section">6.3.5</span>性能类概述</h3>
               <div>
                  <p>策略集包含在群集上运行的各种性能类或工作负载的性能目标。</p>
                  <p>Oracle数据库QoS管理使用策略集中定义的一组分类规则将工作请求分类为性能类。用于将工作请求分配给Performance Classes的基本分类器是用于连接到数据库的服务的名称。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-57E1B40A-CCB3-4969-AFBF-A7E01F6DE7BE">性能类标签</a><br>工作请求的分类应用用户定义的名称标记，该标记标识工作请求所属的性能类。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-5E13E0A5-AD14-4FC9-953F-A9E75C5053D7">将分类器应用于工作请求</a><br>分类发生在新工作进入系统的任何地方。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-9D59A65B-A912-4D46-8889-EBF9868309AA">使用其他过滤器对工作请求进行分类</a><br>单个应用程序可以支持多种类型的工作请求，具有一系列性能特征。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-2F550155-3660-454F-B014-F0DFF5D6CAFC">决定创建新的性能类</a><br>随着时间的推移，您的工作量和性能目标可能会发
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="APQOS318"></a><div class="props_rev_3"><a id="GUID-57E1B40A-CCB3-4969-AFBF-A7E01F6DE7BE" name="GUID-57E1B40A-CCB3-4969-AFBF-A7E01F6DE7BE"></a><h4 id="ATNMS-GUID-57E1B40A-CCB3-4969-AFBF-A7E01F6DE7BE" class="sect4"><span class="enumeration_section">6.3.5.1</span>性能类标签</h4>
                  <div>
                     <p>工作请求的分类应用用户定义的名称标记，该标记标识工作请求所属的性能类。</p>
                     <p>分组到特定性能类的所有工作请求具有相同的<a href="glossary.html#GUID-C5412B8A-7CB1-4801-AD0D-E8451A3B8E9D"><span class="xrefglossterm">性能目标</span></a> 。实际上，（ <a href="glossary.html#GUID-657A3F9B-BCA2-4BE3-B725-213D0337E743"><span class="xrefglossterm">标记</span></a> ）将工作请求连接到关联的性能类的性能目标。Oracle数据库QoS管理为每个工作请求分配标签，以便系统的每个组件都可以进行测量，并向Oracle数据库QoS管理提供数据，以便根据适用的性能目标进行评估。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" title="策略集包含在群集上运行的各种性能类或工作负载的性能目标。">性能类概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS319"></a><div class="props_rev_3"><a id="GUID-5E13E0A5-AD14-4FC9-953F-A9E75C5053D7" name="GUID-5E13E0A5-AD14-4FC9-953F-A9E75C5053D7"></a><h4 id="ATNMS-GUID-5E13E0A5-AD14-4FC9-953F-A9E75C5053D7" class="sect4"><span class="enumeration_section">6.3.5.2</span>将分类器应用于工作请求</h4>
                  <div>
                     <p>分类发生在新工作进入系统的任何地方。</p>
                     <p>当工作请求到达服务器时，将检查工作请求是否有标签。如果工作请求具有标记，则服务器断定该工作请求已被分类，并且标记未被更改。如果工作请求不包含标记，则检查<a href="glossary.html#GUID-FC682538-F072-4209-AAFE-064BFAB386FE"><span class="xrefglossterm">分类</span></a>器，并将匹配的性能类的标记附加到工作请求。</p>
                     <p>为了说明工作请求的分类方式，请考虑连接到Oracle RAC数据库的应用程序。该应用程序使用数据库服务<code class="codeph">sales</code> 。Oracle数据库QoS管理管理员在Oracle数据库QoS管理的初始配置期间指定<code class="codeph">sales_pc</code>性能类应包含使用<code class="codeph">sales</code>服务的工作请求。当数据库收到连接请求时，Oracle数据库QoS管理会检查标记。如果未找到标记，则Oracle数据库QoS管理会按照性能策略中指定的顺序将连接请求中的信息与为每个性能类指定的分类器进行比较。如果要分类的连接请求正在使用<code class="codeph">sales</code>服务，那么当<code class="codeph">sales_pc</code>性能类中的分类器与连接请求信息进行比较时，会找到匹配项，并为数据库工作请求分配<code class="codeph">sales_pc</code>性能类的标记。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" title="策略集包含在群集上运行的各种性能类或工作负载的性能目标。">性能类概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS320"></a><div class="props_rev_3"><a id="GUID-9D59A65B-A912-4D46-8889-EBF9868309AA" name="GUID-9D59A65B-A912-4D46-8889-EBF9868309AA"></a><h4 id="ATNMS-GUID-9D59A65B-A912-4D46-8889-EBF9868309AA" class="sect4"><span class="enumeration_section">6.3.5.3</span>使用附加过滤器对工作请求进行分类</h4>
                  <div>
                     <p>单个应用程序可以支持多种类型的工作请求，具有一系列性能特征。</p>
                     <p>通过扩展和优化默认分类规则，Oracle数据库QoS管理员可以为单个应用程序编写多个性能目标。例如，管理员可以决定基于Web的应用程序应该具有与登录，浏览，搜索和购买相关的工作请求的单独性能目标。</p>
                     <p>Oracle数据库QoS管理支持用户定义的连接参数组合，以将性能类映射到数据库中运行的实际工作负载。这些连接参数属于两个通用类，可以组合以创建细粒度的布尔表达式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">配置参数：</span>支持的配置参数是<code class="codeph">SERVICE_NAME</code>和<code class="codeph">USERNAME</code> 。性能类中的每个分类器都必须指定数据库服务的名称。通过识别从客户端或中间层建立数据库连接的用户的名称，可以实现额外的粒度。使用这些分类器的优点是，它们不需要更改应用程序代码，以将不同的工作负载与单独的性能类关联起来。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">应用程序参数：</span>支持的应用程序参数是<code class="codeph">MODULE</code> ， <code class="codeph">ACTION</code>和<code class="codeph">PROGRAM</code> 。这些是可选参数。必须在应用程序中设置<code class="codeph">MODULE</code>和<code class="codeph">ACTION</code>的值。根据应用程序的类型，您可以按如下方式设置这些参数：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>OCI：使用<code class="codeph">OCI_ATTR_MODULE</code>和<code class="codeph">OCI_ATTR_ACTION</code> 。</p>
                              </li>
                              <li>
                                 <p>Oracle Data Provider for .NET（ODP.NET）：在<code class="codeph">OracleConnection</code>对象上指定<code class="codeph">ModuleName</code>和<code class="codeph">ActionName</code>属性。
                                 </p>
                              </li>
                              <li>
                                 <p>JDBC：在<code class="codeph">SYS_CONTEXT</code>设置<code class="codeph">MODULE</code>和<code class="codeph">ACTION</code> 。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>为每个数据库驱动程序和平台设置或导出<code class="codeph">PROGRAM</code>参数的方式不同。有关更多详细信息和示例，请参阅相应的Oracle数据库开发人员指南。
                     </p>
                     <p>为了管理应用程序的工作负载，应用程序代码使用特定服务建立数据库连接。为了更精确地控制应用程序各个部分生成的工作负载，您可以创建其他性能类，并使用除服务或用户名之外的包括<code class="codeph">PROGRAM</code> ， <code class="codeph">MODULE</code>或<code class="codeph">ACTION</code>分类器。例如，您可以指定使用<code class="codeph">sales</code>服务的群集的所有连接都属于<code class="codeph">sales_pc</code> Performance Class，但使用<code class="codeph">sales</code>服务且用户名为<code class="codeph">APPADMIN</code>属于<code class="codeph">sales_admin</code> Performance Class。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../lnoci/handle-and-descriptor-attributes.html#LNOCI-GUID-FB263210-118E-4DB3-A840-1769EF0CB977" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/atnms&amp;id=ODPNT805" target="_blank"><span><cite>适用于Microsoft Windows的Oracle数据提供程序开发人员指南</cite></span></a></li>
                           <li><a href="../jjdbc/JDBC-DMS-Metrics.html#JJDBC28899" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" title="策略集包含在群集上运行的各种性能类或工作负载的性能目标。">性能类概述</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="APQOS321"></a><div class="props_rev_3"><a id="GUID-2F550155-3660-454F-B014-F0DFF5D6CAFC" name="GUID-2F550155-3660-454F-B014-F0DFF5D6CAFC"></a><h4 id="ATNMS-GUID-2F550155-3660-454F-B014-F0DFF5D6CAFC" class="sect4"><span class="enumeration_section">6.3.5.4</span>决定创建新的性能类</h4>
                  <div>
                     <p>随着时间的推移，您的工作量和性能目标可能会发</p>
                     <p>预计特定数据中心使用的性能类会随着时间的推移而发生变化。例如，您可能需要修改应用程序的一部分的性能目标。在这种情况下，您将创建一个新的性能类，其中包含其他分类器以标识目标工作请求，并更新性能策略以为此性能类添加新的性能目标。换句话说，您将一个性能目标替换为一个或多个更细粒度的性能目标，并将一个性能类的工作请求划分为多个性能类。</p>
                     <p>应用程序开发人员可以建议使用哪些性能类。具体而言，应用程序开发人员可以建议识别不同应用程序工作负载的方法，您可以使用这些建议为Performance Classes创建分类器，以便单独管理每种类型的工作请求。</p>
                     <p>您可以创建其他性能类，以指定不同应用程序工作负载的可接受响应时间。例如，性能目标可能表明执行<code class="codeph">sales_pc_checkout</code>性能类的<code class="codeph">checkout</code>操作的工作请求不应超过一毫秒完成，并且执行<code class="codeph">sales_pc_browse</code>性能类的<code class="codeph">browse</code>操作的工作请求可能需要100毫秒秒才能完成完成。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-performance-classes.html#GUID-29ADED46-F0D4-45A0-906D-85621AE36602" title="每个策略集都包含一个或多个性能类。每个性能类都定义了服务器上的一种工作负载。">管理性能类</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-A382BCE6-E610-4E4F-87C4-20999B60A22F" title="策略集包含在群集上运行的各种性能类或工作负载的性能目标。">性能类概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="APQOS119"></a><div class="props_rev_3"><a id="GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" name="GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4"></a><h3 id="ATNMS-GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" class="sect3"><span class="enumeration_section">6.3.6</span>绩效政策和绩效目标概述</h3>
               <div>
                  <p>要管理各种性能目标，请定义一个或多个性能策略。</p>
                  <p><a href="glossary.html#GUID-8D5353A6-D732-4ADD-AD1E-F29DDD36E047"><span class="xrefglossterm">绩效政策</span></a>是绩效目标的集合，衡量它们对您的业务的重要程度。例如，您可以为正常工作时间定义性能策略，为工作日非工作时间定义另一个性能策略，为周末操作定义一个性能策略，在季度末财务结算的处理期间使用另一个性能策略。在任何给定时间，单个性能策略都是由Oracle数据库QoS管理管理员指定的。在每个性能策略中，性能目标的关键性或排名可以不同，使您能够在特定时间段内为某些工作负载提供更多优先级。
                  </p>
                  <p>绩效政策同时有一系列绩效目标;对于在群集上运行的每个应用程序或工作负载，都有一个或多个性能目标。有些工作负载及其性能目标对业务而言比其他工作负载更重要。某些性能目标在某些时候可能更为关键，而在其他时间则不那么重要。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-1773CDE9-6B2A-4918-9C00-53D658F65F2A">绩效目标概述</a><br>您可以为每个性能类创建性能目标，以指定分配给每个性能类的所有工作请求的目标性能级别。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86">服务器池指令覆盖概述</a><br>当性能策略生效时，服务器池指令覆盖设置服务器池的最小，最大和重要性的可用性属性。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-215DAB6C-8D4A-459D-AB6F-7DAB4A555FC8">绩效等级概述</a><br>为Performance Classes指定排名有助于确定工作的优先级。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-ABDD3B4F-5FF8-462D-AFB7-119365E4143C">Oracle数据库QoS管理策略工作负载关键性确定数据库启动顺序</a><br>如果用户创建的Oracle数据库QoS管理策略处于活动状态，则性能类的排序顺序将确定关联的Oracle RAC数据库启动或请求实时LMS进程槽的顺序。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="APQOS322"></a><div class="props_rev_3"><a id="GUID-1773CDE9-6B2A-4918-9C00-53D658F65F2A" name="GUID-1773CDE9-6B2A-4918-9C00-53D658F65F2A"></a><h4 id="ATNMS-GUID-1773CDE9-6B2A-4918-9C00-53D658F65F2A" class="sect4"><span class="enumeration_section">6.3.6.1</span>性能目标概述</h4>
                  <div>
                     <p>您可以为每个性能类创建性能目标，以指定分配给每个性能类的所有工作请求的目标性能级别。</p>
                     <p><a href="glossary.html#GUID-01F7E040-A79E-4934-80EF-DBD8A9D6F24B"><span class="xrefglossterm">性能目标</span></a>指定业务需求（目标性能级别）和性能目标适用的工作（性能级别）。例如，性能目标可以指定<code class="codeph">hr_pc</code>性能类中的工作请求的平均响应时间应小于0.2秒。
                     </p>
                     <p>性能目标通过性能策略指定。除非性能等级标记为仅限测量，否则每个性能策略都包含每个性能等级的性能目标。在此版本中，Oracle数据库QoS管理仅支持一种类型的性能目标，即<a href="glossary.html#GUID-622303AA-B794-46E0-9429-6BE523075C46"><span class="xrefglossterm">平均响应时间</span></a> 。
                     </p>
                     <p>工作负载的响应时间基于数据库客户端请求。响应时间测量从群集通过网络接收请求到请求离开群集的时间。响应时间不包括通过网络向客户端发送信息或从客户端发送信息所需的时间。对性能类中所有数据库客户端请求的响应时间进行平均，并将其显示为平均响应时间（以秒为单位，以数据库请求为单位）。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-performance-policies.html#GUID-D5A91407-FDF1-4AB7-818E-FCB1158B27C0" title="使用Oracle Enterprise Manager Cloud Control创建性能策略。">创建绩效政策并指定绩效目标</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" title="要管理各种性能目标，请定义一个或多个性能策略。">性能策略和性能目标概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS324"></a><a id="APQOS323"></a><div class="props_rev_3"><a id="GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86" name="GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86"></a><h4 id="ATNMS-GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86" class="sect4"><span class="enumeration_section">6.3.6.2</span>服务器池指令覆盖概述</h4>
                  <div>
                     <p>当性能策略生效时，服务器池指令覆盖设置服务器池的最小，最大和重要性的可用性属性。</p>
                     <p>性能策略可以包括一组<a href="glossary.html#GUID-3413500E-0636-4512-A864-E55D564FA9A7"><span class="xrefglossterm">服务器池指令覆盖</span></a> 。服务器池指令覆盖用作Oracle数据库QoS管理建议的分配更改的约束，因为在性能策略的激活期间遵循服务器池指令覆盖。例如，Oracle数据库QoS管理从不建议将服务器移出服务器池，如果这样做会导致服务器池的服务器池数少于其指定的最小数量。
                     </p>
                     <p>您可以为系统创建性能策略，以根据一年中的时间或一天中的时间来管理工作负载， <a href="overview-oracle-database-qos-management.html#GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86__CHDBHIII">如图6-5</a>所示。在正常情况下，这些性能策略可使您的数据库工作负载以稳定的速率运行。如果数据库的工作负载请求突然增加，则特定服务器池可能需要超出性能策略指定的额外资源。
                     </p>
                     <div class="figure" id="GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86__CHDBHIII">
                        <p class="titleinfigure">图6-5按性能策略分列的基线资源管理</p><img src="img/apqos004.gif" alt="下面是图6-5的描述" title="下面是图6-5的描述" longdesc="img_text/apqos004.html"><br><a href="img_text/apqos004.html">“图6-5按性能政策划分的基线资源管理”的说明</a></div>
                     <!-- class="figure" -->
                     <p>例如，假设您的企业通过电话接受订单，并使用销售应用程序创建订单。您的电话销售部门仅在正常工作时间开放，但客户也可以通过互联网自行下订单。在白天，更多订单被放置，因此销售应用程序需要更多资源来处理工作量。通过创建“营业时间性能策略”并指定后台服务器池最多可以包含两个服务器来管理此配置，从而使Oracle数据库QoS管理可以根据需要将服务器移动到联机服务器池。电话销售部门关闭后，销售应用程序的工作量会减少。要管理此配置，请创建After Hours性能策略，并指定后台服务器池最多可以有四台服务器，使您的内部应用程序能够获取在下一个工作日之前完成其工作负载所需的其他资源。</p>
                     <p>在此方案中，“营业时间”和“工作时间后性能策略”可以包含服务器池指令覆盖。当性能策略包含服务器池指令覆盖时，在该性能策略生效时，将覆盖指定服务器池的当前Max，Min和Importance设置。这使得其他服务器可以放置在Sales服务器池中，以便为在线销售应用程序提供所需的资源，并限制后台服务器池使用的资源，以便其工作负载不会干扰Sales工作负载。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-performance-policies.html#GUID-52905BAD-1B74-4D64-9685-C4A72DD1E758" title="服务器池指令覆盖使您能够对服务器池大小强制执行不同的设置，或更改服务器池的重要性。">设置服务器池指令覆盖</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" title="要管理各种性能目标，请定义一个或多个性能策略。">性能策略和性能目标概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS325"></a><div class="props_rev_3"><a id="GUID-215DAB6C-8D4A-459D-AB6F-7DAB4A555FC8" name="GUID-215DAB6C-8D4A-459D-AB6F-7DAB4A555FC8"></a><h4 id="ATNMS-GUID-215DAB6C-8D4A-459D-AB6F-7DAB4A555FC8" class="sect4"><span class="enumeration_section">6.3.6.3</span>性能等级概述</h4>
                  <div>
                     <p>为Performance Classes指定排名有助于确定工作的优先级。</p>
                     <p>在性能策略中，您可以为每个性能类别分配一个业务关键性级别（ <span class="italic">级别</span> ），以优先满足性能目标，从而在不太关键的性能级别上实现更关键的性能级别。如果没有足够的资源可以同时满足所有性能类的所有性能目标，则必须满足更关键的性能级别的性能目标，但代价是性能目标不太重要。性能策略指定每个性能等级的<span class="italic">业务关键性</span> ，可以是最高，高，中，低或最低。</p>
                     <div class="infoboxnote" id="GUID-215DAB6C-8D4A-459D-AB6F-7DAB4A555FC8__GUID-729D7A17-00F4-4177-9730-31D361DC6FEF">
                        <p class="notep1">注意：</p>
                        <p>基于排名的资源优先级访问不适用于单实例Oracle RAC数据库或Oracle RAC One节点。</p>
                     </div>
                     <p>例如，使用<a href="overview-oracle-database-qos-management.html#GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86__CHDBHIII">图6-5</a>中<a href="overview-oracle-database-qos-management.html#GUID-E6B0421C-B374-47AB-BCC2-76677C5DAB86__CHDBHIII">所示</a>的性能策略，当营业时间性能策略生效时，访问联机服务器池的销售应用程序具有最高排名。如果没有足够的资源来满足所有性能类的性能目标，则使用联机服务器池的应用程序将获得对任何可用资源的优先访问权限，即使使用后台服务器池的应用程序未满足其绩效目标。
                     </p>
                     <p>您可以在同一级别拥有多个性能类。如果Oracle数据库QoS管理检测到多个性能类未达到其性能目标且性能类在活动性能策略中被分配相同的级别，则Oracle数据库QoS管理建议进行更改以使性能类最接近其性能目标更多资源。实施建议的操作后，当Performance Class不再低于其目标性能级别时，Oracle Database QoS Management会对系统性能执行新的评估。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-performance-classes.html#GUID-29ADED46-F0D4-45A0-906D-85621AE36602" title="每个策略集都包含一个或多个性能类。每个性能类都定义了服务器上的一种工作负载。">管理性能类</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" title="要管理各种性能目标，请定义一个或多个性能策略。">性能策略和性能目标概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS382"></a><div class="props_rev_3"><a id="GUID-ABDD3B4F-5FF8-462D-AFB7-119365E4143C" name="GUID-ABDD3B4F-5FF8-462D-AFB7-119365E4143C"></a><h4 id="ATNMS-GUID-ABDD3B4F-5FF8-462D-AFB7-119365E4143C" class="sect4"><span class="enumeration_section">6.3.6.4</span> Oracle数据库QoS管理策略工作负载<span class="enumeration_section">严重性</span>确定数据库启动顺序</h4>
                  <div>
                     <p>如果用户创建的Oracle数据库QoS管理策略处于活动状态，则性能类的排序顺序将确定关联的Oracle RAC数据库启动或请求实时LMS进程槽的顺序。</p>
                     <p>使用性能类排名可确保在整合环境中运行的关键任务数据库使其LMS进程实时运行，从而消除节点间通信中的资源瓶颈。由于Oracle数据库QoS管理策略指定了每个工作负载的等级，因此使用每个数据库的Max（Ranks）值可以提供每个数据库表达的业务关键性的一致表达式。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-F4AC7149-1DDB-4372-8198-A9063E9E4BA4" title="要管理各种性能目标，请定义一个或多个性能策略。">性能策略和性能目标概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="APQOS326"></a><a id="APQOS270"></a><div class="props_rev_3"><a id="GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C" name="GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C"></a><h3 id="ATNMS-GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C" class="sect3"><span class="enumeration_section">6.3.7</span> Oracle数据库QoS管理如何收集和分析性能数据</h3>
               <div>
                  <p>Oracle数据库QoS管理服务器从群集中的Oracle Real Application Clusters（Oracle RAC）和Oracle RAC One Node数据库中检索度量数据。</p>
                  <p>数据按性能等级每五秒进行一次关联。数据包括许多指标，如数据库请求到达率，CPU使用率，CPU等待时间，I / O使用，I / O等待时间，全局缓存使用和全局缓存等待时间。有关群集的当前拓扑和服务器运行状况的信息将添加到数据中。Oracle数据库QoS管理的策略和性能管理引擎（ <a href="overview-oracle-database-qos-management.html#GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C__BABGICBA">如图6-6所示</a> ）分析数据，以确定由活动性能策略建立的当前性能目标的系统总体性能配置文件。
                  </p>
                  <p>性能评估每分钟发生一次，如果任何性能等级不符合其目标，则会产生建议。该建议指定哪个资源是<a href="glossary.html#GUID-440F0A8F-5CCB-4A14-B67E-39A20954F6F7"><span class="xrefglossterm">瓶颈</span></a> 。如果可能，建议中包含具体的纠正措施。如果您决定实施建议的操作，该建议还包括对系统中所有性能类的预计影响的列表。
                  </p>
                  <p><a href="overview-oracle-database-qos-management.html#GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C__BABGICBA">图6-6</a>显示了来自各种数据源的数据集合，并显示了Oracle Enterprise Manager如何使用该信息。在此图中，CHM是指Oracle Cluster Health Monitor，而服务器管理器（SRVM）是Oracle Clusterware的一个组件。
                  </p>
                  <div class="figure" id="GUID-E5CC78F2-6704-4358-B9A5-64483FF57F0C__BABGICBA">
                     <p class="titleinfigure">图6-6 Oracle数据库QoS管理服务器体系结构图</p><img src="img/apqos002.png" alt="下面是图6-6的描述" title="下面是图6-6的描述" longdesc="img_text/apqos002.html"><br><a href="img_text/apqos002.html">“图6-6 Oracle数据库QoS管理服务器体系结构图”的说明</a></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="using-qos-management-dashboard.html#GUID-09D9F38A-CCDB-4F50-9855-393B9754CDAB">解释性能概览图</a></li>
                        <li><a href="reviewing-performance-metrics.html#GUID-0BDF2F2D-56FE-45B4-AADC-130A497C9599" title="您可以查看整个Oracle数据库QoS管理系统或各个性能类的各种性能指标。">查看性能指标</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="APQOS271"></a><div class="props_rev_3"><a id="GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" name="GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87"></a><h3 id="ATNMS-GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" class="sect3"><span class="enumeration_section">6.3.8</span>建议概述</h3>
               <div>
                  <p>Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。</p>
                  <p>如果您的业务遇到定期需求激增或必须支持<a href="glossary.html#GUID-C3654AAB-1F8F-4870-9EE7-7C42C4423565"><span class="xrefglossterm">开放式工作负载</span></a> ，那么为了保持应用程序的性能级别，您可以设计系统以满足高峰工作负载。创建能够处理峰值工作负载的系统通常意味着在需要时获取可用的额外硬件，并在不需要时保持空闲。除非发生需求激增，否则您可以决定使用这些服务器来运行其他应用程序工作负载，而不是让服务器保持空闲状态。但是，如果服务器在需求激增时忙于运行其他应用程序，那么您的系统可能无法满足峰值工作负载，并且您的主要业务应用程序无法按预期执行。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-8A546B3E-83C6-493E-9BBC-BD19A0579AE1">Oracle数据库QoS管理如何生成建议</a><br>如果未达到性能目标，则Oracle数据库QoS管理会评估几种可能的解决方案，并提供最有效的解决方案作为建议。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-C71D1179-9631-4859-B393-5D0ADCF0F513">建议类型</a><br>如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-8F232523-6A2D-4C44-AFE9-381AD7630FBD">选择最佳推荐标准</a><br>Oracle数据库服务质量管理可以提供多种建议来改善工作负载性能。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57">建议书的内容</a><br>每项建议都包含几条信息。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-D484368F-C4D8-4E0C-8432-642B34C2AC15">实施建议概述</a><br>Oracle数据库QoS管理不会自动实施建议。
                     </li>
                     <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-4A7C1057-FEB1-40E0-B0D5-66632C3B25AA">示例：如何生成建议</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C3692906-7594-42DB-96D7-DF9F50EA2FE2" title="本节提供Oracle数据库QoS管理如何工作的基本描述，以及它如何评估系统上工作负载的性能。">Oracle数据库QoS管理概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="APQOS327"></a><div class="props_rev_3"><a id="GUID-8A546B3E-83C6-493E-9BBC-BD19A0579AE1" name="GUID-8A546B3E-83C6-493E-9BBC-BD19A0579AE1"></a><h4 id="ATNMS-GUID-8A546B3E-83C6-493E-9BBC-BD19A0579AE1" class="sect4"><span class="enumeration_section">6.3.8.1</span> Oracle数据库QoS管理如何生成建议</h4>
                  <div>
                     <p>如果未达到性能目标，则Oracle数据库QoS管理会评估几种可能的解决方案，并提供最有效的解决方案作为建议。</p>
                     <p>使用Oracle数据库QoS管理时，将在迭代过程中持续监视系统，以查看是否满足活动性能策略中的性能目标。性能数据将发送到Oracle Enterprise Manager，以显示在Oracle数据库QoS管理仪表板（仪表板）和性能历史记录页面中。</p>
                     <p>当一个或多个性能目标未得到满足时，在评估系统性能之后，Oracle数据库QoS管理旨在提高单个性能目标的性能：通常是目前尚未满足的排名最高的性能目标。如果所有性能目标都满足当前和预计工作负载的备用容量，则Oracle数据库QoS管理会发出信号“无需执行任何操作：正在满足所有性能目标”。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-qos-management-dashboard.html#GUID-6BE297A8-C57F-48CF-8B57-C4322D98A61E">查看建议</a></li>
                           <li><a href="using-qos-management-dashboard.html#GUID-45691387-364A-41F4-9FDD-463FB50158B7" title="Oracle数据库QoS管理仪表板（仪表板）提供了一个易于使用的界面，用于管理Oracle数据库QoS管理系统。">使用Oracle数据库QoS管理仪表板</a></li>
                           <li><a href="reviewing-performance-metrics.html#GUID-0BDF2F2D-56FE-45B4-AADC-130A497C9599" title="您可以查看整个Oracle数据库QoS管理系统或各个性能类的各种性能指标。">查看性能指标</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS328"></a><div class="props_rev_3"><a id="GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" name="GUID-C71D1179-9631-4859-B393-5D0ADCF0F513"></a><h4 id="ATNMS-GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" class="sect4"><span class="enumeration_section">6.3.8.2</span>建议书的类型</h4>
                  <div>
                     <p>如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。</p>
                     <p>Oracle数据库QoS管理评估几种可能的解决方案，然后选择以下解决方案：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>提供最佳的整体系统改进</p>
                        </li>
                        <li>
                           <p>导致系统中断最少</p>
                        </li>
                        <li>
                           <p>帮助排名最高的违规性能等级</p>
                        </li>
                     </ul>
                     <p>Oracle数据库QoS管理可以提出的建议类型包括：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-3B57F595-EE30-4FA5-88F5-313EDBB35CA1">促进和消除消费者群体</a><br>如果性能类未满足性能目标，并且性能类访问与其他性能类相同的数据库，则Oracle数据库QoS管理可以建议使用者组映射更改。
                        </li>
                        <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-61A41E22-1B82-4E0E-B82F-AD32E279558B">修改CPU计数</a><br>如果在服务器池中的服务器上运行多个数据库实例，Oracle数据库QoS管理可以建议将服务器上一个片中的数据库实例使用的CPU资源捐赠给需要更多CPU资源的片。
                        </li>
                        <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-38083EC8-119E-4233-87DF-84496B008F2B">在服务器池之间移动服务器</a><br>Oracle数据库QoS管理可以显示的另一个建议操作是将服务器从一个服务器池移动到另一个服务器池，以提供额外的资源来满足性能类的性能目标。
                        </li>
                        <li class="ulchildlink"><a href="overview-oracle-database-qos-management.html#GUID-2F14A82B-73CF-483F-945C-5A008A91B961">修改分配给可插拔数据库的CPU份额</a><br>Oracle数据库服务质量（QoS）管理管理多租户数据库中可插拔数据库（PDB）中使用的CPU资源。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="APQOS362"></a><div class="props_rev_3"><a id="GUID-3B57F595-EE30-4FA5-88F5-313EDBB35CA1" name="GUID-3B57F595-EE30-4FA5-88F5-313EDBB35CA1"></a><h5 id="ATNMS-GUID-3B57F595-EE30-4FA5-88F5-313EDBB35CA1" class="sect5"><span class="enumeration_section">6.3.8.2.1</span>促进和<span class="enumeration_section">消除</span>消费者群体</h5>
                     <div>
                        <p>如果性能类未满足性能目标，并且性能类访问与其他性能类相同的数据库，则Oracle数据库QoS管理可以建议使用者组映射更改。</p>
                        <p>更改使用者组映射可以更多地访问未满足的性能类的CPU资源，即性能目标。Oracle数据库QoS管理仅针对在同一数据库和服务器池中竞争资源的性能类发布使用者组映射建议。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" title="如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。">建议类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="APQOS363"></a><div class="props_rev_3"><a id="GUID-61A41E22-1B82-4E0E-B82F-AD32E279558B" name="GUID-61A41E22-1B82-4E0E-B82F-AD32E279558B"></a><h5 id="ATNMS-GUID-61A41E22-1B82-4E0E-B82F-AD32E279558B" class="sect5"><span class="enumeration_section">6.3.8.2.2</span>修改CPU计数</h5>
                     <div>
                        <p>如果在服务器池中的服务器上运行多个数据库实例，Oracle数据库QoS管理可以建议将服务器上一个片中的数据库实例使用的CPU资源捐赠给需要更多CPU资源的片。</p>
                        <p></p>
                        <p>如果某个性能类不符合其性能目标，并且系统上有另一个具有可用余量的片，或者使用该片的性能类的级别较低，则Oracle数据库QoS管理可以建议移动CPU从空闲切片到重载切片。如果实施此建议，则对于空闲实例向下调整<code class="codeph">CPU_COUNT</code>参数，对于服务器池中所有服务器上的过度工作实例向上调整<code class="codeph">CPU_COUNT</code>参数。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" title="如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。">建议类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="APQOS364"></a><div class="props_rev_3"><a id="GUID-38083EC8-119E-4233-87DF-84496B008F2B" name="GUID-38083EC8-119E-4233-87DF-84496B008F2B"></a><h5 id="ATNMS-GUID-38083EC8-119E-4233-87DF-84496B008F2B" class="sect5"><span class="enumeration_section">6.3.8.2.3</span>在服务器池之间移动服务器</h5>
                     <div>
                        <p>Oracle数据库QoS管理可以显示的另一个建议操作是将服务器从一个服务器池移动到另一个服务器池，以提供额外的资源来满足性能类的性能目标。</p>
                        <p>如果群集中的所有服务器池都处于其指定的最小大小，或者需要该资源的服务器池处于其最大大小，则Oracle数据库QoS管理不再建议从服务器池中删除服务器。在这种情况下，仪表板显示“此时没有建议的操作”。</p>
                        <div class="infoboxnote" id="GUID-38083EC8-119E-4233-87DF-84496B008F2B__GUID-A0537C91-0B64-498A-BB28-536B291650A3">
                           <p class="notep1">注意：</p>此类建议不适用于管理员管理的数据库。
                        </div>
                        <p>服务器池的最小大小是该服务器池需要具有的服务器数。如果为群集中的每个服务器池添加服务器池最小属性的值，则此总和与群集中服务器总数之间的差异表示可以在服务器池（或<span class="italic">浮点数</span> ）之间移动以满足更改的共享服务器需求。例如，如果您的群集有10个服务器和两个服务器池，并且每个服务器池的最小大小为4，那么您的系统有两个可以在服务器池之间移动的服务器。如果目标服务器池未达到其最大大小，则可以移动这些服务器。在生成Move Server建议时，Oracle数据库QoS管理始终遵循策略中设置的最小和最大大小约束。
                        </p>
                        <p>如果将服务器池的最小大小设置为零并且系统遇到需求激增，则Oracle数据库QoS管理可以建议将所有服务器移出该服务器池，以使服务器池达到其最小大小。这导致使用该服务器池的性能类完全缺乏资源，并且基本上被关闭。最小大小为零的服务器池应仅承载业务关键性较低的应用程序和性能策略中分配较低级别的性能类。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" title="如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。">建议类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-2F14A82B-73CF-483F-945C-5A008A91B961" name="GUID-2F14A82B-73CF-483F-945C-5A008A91B961"></a><h5 id="ATNMS-GUID-2F14A82B-73CF-483F-945C-5A008A91B961" class="sect5"><span class="enumeration_section">6.3.8.2.4</span>修改分配给可插拔数据库的CPU份额</h5>
                     <div>
                        <p>Oracle数据库服务质量（QoS）管理管理多租户数据库中可插拔数据库（PDB）中使用的CPU资源。</p>
                        <p>每个可插拔数据库都是独立管理的。如果使用可插拔数据库的性能类不满足性能目标，则Oracle数据库QoS管理可以建议增加分配给可插拔数据库的CPU份额。CPU份额的分配是通过资源计划中的数据库资源管理器使用者组映射实现的。管理CDB时，每个PDB的份额从1增加到50。然后根据需要从那里重新分配它们。</p>
                        <p>CDB的资源管理器计划管理两个级别的资源：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在所有PDB之间分配CPU份额</p>
                           </li>
                           <li>
                              <p>优先考虑每个PDB中的消费者组之间的CPU访问</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-C71D1179-9631-4859-B393-5D0ADCF0F513" title="如果性能等级未达到性能目标，则Oracle数据库服务质量管理会发布重新平衡资源使用以缓解瓶颈的建议。">建议类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="APQOS329"></a><div class="props_rev_3"><a id="GUID-8F232523-6A2D-4C44-AFE9-381AD7630FBD" name="GUID-8F232523-6A2D-4C44-AFE9-381AD7630FBD"></a><h4 id="ATNMS-GUID-8F232523-6A2D-4C44-AFE9-381AD7630FBD" class="sect4"><span class="enumeration_section">6.3.8.3</span>选择最佳建议</h4>
                  <div>
                     <p>Oracle数据库服务质量管理可以提供多种建议来改善工作负载性能。</p>
                     <p>在尝试减轻特定性能类的资源瓶颈时，Oracle数据库QoS管理建议为该性能类添加更多资源（例如CPU时间），或者使资源更快地用于Performance Class中的工作请求。这些建议采取以下形式：将目标性能等级提升到更高的消费者组，降低资源计划中的竞争性能类，调整服务器池中不同片之间共享的CPU资源，或者在服务器池之间移动服务器。</p>
                     <p>实施建议的操作会使资源对其他Performance Classes的可用性降低。在生成建议时，Oracle数据库QoS管理会评估整体对系统性能的影响。如果更改资源分配的可能建议在一个性能类的响应时间方面提供了小幅改进，但导致另一个性能类的响应时间大幅减少，那么Oracle数据库QoS管理报告性能增益也是如此小，并不建议改变。</p>
                     <p>如果出现以下情况，Oracle数据库QoS管理可以发布对性能类性能产生负面影响的建议：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>预计从中获取资源的性能等级的负面影响不会导致性能目标违规，并且预计性能等级会产生积极影响，从而更好地访问资源</p>
                        </li>
                        <li>
                           <p>从中获取资源的Performance Class排名较低，因此对您的业务不太重要，而不是正在帮助的Performance Class</p>
                        </li>
                     </ul>
                     <p>如果可以通过多种方式解决资源瓶颈，那么Oracle数据库QoS管理会建议采取一项措施，以提高违反其目标的排名最高的性能等级的性能。您还可以查看Oracle数据库QoS管理生成的备选建议，并查看是否建议将该操作用于实施。例如，解决CPU资源瓶颈的一种可能解决方案是降级与使用CPU最多的性能类关联的使用者组。通过限制对此Performance Class中的工作请求的CPU访问，该数据库的其他Performances Classes中的工作请求获得更大的CPU时间份额。但是，Oracle数据库QoS管理可能决定不建议此操作，因为目标性能类的响应时间增益太小。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-qos-management-dashboard.html#GUID-6BE297A8-C57F-48CF-8B57-C4322D98A61E">查看建议</a></li>
                           <li><a href="using-qos-management-dashboard.html#GUID-F67C544D-5666-47FC-BADD-DCC400C9DA1D">查看推荐细节</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS331"></a><a id="APQOS330"></a><div class="props_rev_3"><a id="GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57" name="GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57"></a><h4 id="ATNMS-GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57" class="sect4"><span class="enumeration_section">6.3.8.4</span>建议书的内容</h4>
                  <div>
                     <p>每项建议都包含几条信息。</p>
                     <p>建议的分析数据包括每个性能等级的响应时间的预计变化，每个性能等级的<a href="glossary.html#GUID-0C57D5A7-7249-423F-A852-3E7F9BCCB006"><span class="xrefglossterm">性能满意度量</span></a> （PSM）的预计变化，以及在其他备选操作中选择此操作的原因， <a href="overview-oracle-database-qos-management.html#GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57__CHDBEHCD">如图6-7</a> 。在此示例中，如果您实施建议的操作，则Oracle数据库QoS管理预测具有最高排名的<code class="codeph">sales cart</code>性能等级的响应时间将从0.00510秒（对于数据库请求）提高到0.00426秒，这相当于其PSM增长11.6％。其他性能类不受更改的影响，因为它们使用不同的服务器池。
                     </p>
                     <div class="figure" id="GUID-A7E7E5AE-1732-4488-97F9-60BB5E7E1E57__CHDBEHCD">
                        <p class="titleinfigure">图6-7推荐操作的分析示例</p><img src="img/apqos_recmnd_detail2a_02.gif" height="384" width="563" alt="下面是图6-7的描述" title="下面是图6-7的描述" longdesc="img_text/apqos_recmnd_detail2a_02.html"><br><a href="img_text/apqos_recmnd_detail2a_02.html">“图6-7推荐操作分析示例”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="overview-metrics.html#GUID-5A2EB75D-0ED3-44E8-9404-9604C38ACE4D" title="分析工作负载性能的有用指标是对性能类中的工作请求如何针对该性能类的当前性能目标执行的常见且一致的数字度量。">绩效满意度指标</a></li>
                           <li><a href="overview-metrics.html#GUID-80C195E4-A4AE-41C2-9BD1-75DBF427F19D" title="Oracle数据库QoS管理使用它收集的指标来识别性能瓶颈。">使用度量标准识别性能问题</a></li>
                           <li><a href="using-qos-management-dashboard.html#GUID-6BE297A8-C57F-48CF-8B57-C4322D98A61E">查看建议</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS332"></a><div class="props_rev_3"><a id="GUID-D484368F-C4D8-4E0C-8432-642B34C2AC15" name="GUID-D484368F-C4D8-4E0C-8432-642B34C2AC15"></a><h4 id="ATNMS-GUID-D484368F-C4D8-4E0C-8432-642B34C2AC15" class="sect4"><span class="enumeration_section">6.3.8.5</span>实施建议书概述</h4>
                  <div>
                     <p>Oracle数据库QoS管理不会自动实施建议。</p>
                     <p>仅在QoS管理员单击“ <span class="uicontrol bold">实施”</span>按钮后才会执行建议的操作。在Oracle数据库QoS管理员管理员实施建议后，系统性能将在指定的建立时间之前重新评估，然后再提出任何新建议。您还可以将Enterprise Manager配置为根据Performance Class未达到其目标的持续时间生成警报。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-qos-management-dashboard.html#GUID-6BE297A8-C57F-48CF-8B57-C4322D98A61E">查看建议</a></li>
                           <li><a href="using-qos-management-dashboard.html#GUID-45691387-364A-41F4-9FDD-463FB50158B7" title="Oracle数据库QoS管理仪表板（仪表板）提供了一个易于使用的界面，用于管理Oracle数据库QoS管理系统。">使用Oracle数据库QoS管理仪表板</a></li>
                           <li><a href="reviewing-performance-metrics.html#GUID-0BDF2F2D-56FE-45B4-AADC-130A497C9599" title="您可以查看整个Oracle数据库QoS管理系统或各个性能类的各种性能指标。">查看性能指标</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="APQOS333"></a><div class="props_rev_3"><a id="GUID-4A7C1057-FEB1-40E0-B0D5-66632C3B25AA" name="GUID-4A7C1057-FEB1-40E0-B0D5-66632C3B25AA"></a><h4 id="ATNMS-GUID-4A7C1057-FEB1-40E0-B0D5-66632C3B25AA" class="sect4"><span class="enumeration_section">6.3.8.6</span>示例：如何生成建议</h4>
                  <div>
                     <p>考虑一个系统在联机服务器池中有两个服务器，后台服务器池中有两个服务器。联机服务器池承载两个工作负载： <code class="codeph">sales_pc</code>性能类和<code class="codeph">sales_cart</code>性能类。联机服务器池的最小大小为两个。后台服务器池托管两个内部应用程序：人力资源（HR）应用程序和企业资源规划（ERP）应用程序。后台服务器池的最小大小为1。<code class="codeph">sales_cart</code> Performance Class的排名最高， <code class="codeph">erp_pc</code> Performance Class的排名最低。<code class="codeph">sales_pc</code> Performance Class的排名高于<code class="codeph">hr_pc</code> Performance Class。
                     </p>
                     <p>在这种情况下，如果<code class="codeph">sales_pc</code>工作负载激增，导致争用资源并导致<code class="codeph">sales_cart</code> Performance Class违反其性能目标，则可能导致OLTP应用程序的服务级别协议（SLA）违规。Oracle数据库服务管理系统发布了一项建议，要求以<code class="codeph">sales_pc</code>工作负载为代价增加对<code class="codeph">sales_cart</code> Performance Class的CPU访问权限，因为<code class="codeph">sales_cart</code> Performance Class的级别更高;更高的排名表示满足<code class="codeph">sales_cart</code> Performance Class的性能目标比满足<code class="codeph">sales_pc</code> Performance Class的性能目标更重要。
                     </p>
                     <p>如果在实施建议后，sales_cart和<code class="codeph">sales_pc</code>性能类仍未满足其性能目标，则Oracle数据库QoS管理会通过从后台服务器移动服务器来发出建议以增加联机服务器池中的服务器数量池，或托管较少关键工作负载或具有更多空间的工作负载的服务器池。在这种情况下，可以从后台服务器池移动服务器，因为后台服务器池当前高于其最小大小1。如果后台服务器池的最小大小为2，则Oracle数据库QoS管理必须在不同的服务器池中查找可用的服务器;如果这样做会导致服务器池低于其最小大小，则建议不要从服务器池移动服务器池。
                     </p>
                     <p>如果您实施建议的操作，并且您的应用程序使用群集托管服务和客户端运行时负载平衡，则应用程序用户不应因此重新分配而看到服务中断。在正在移动的服务器上以事务方式关闭服务。将服务器添加到压力服务器池后，将在重新分配的服务器上启动所有数据库实例及其提供的服务。此时，会话开始逐渐切换到使用服务器池中的新服务器，从而缓解瓶颈。</p>
                     <p>使用相同的方案，如果<code class="codeph">sales_pc</code> Performance Class和<code class="codeph">hr_pc</code> Performance Class都需要其他服务器来满足其性能目标，那么Oracle数据库QoS管理首先会发布建议以提高<code class="codeph">sales_pc</code> Performance Class的性能，因为<code class="codeph">sales_pc</code> Performance Class排名更高比<code class="codeph">hr_pc</code> Performance Class。当<code class="codeph">sales_pc</code> Performance Class满足其性能目标时，Oracle Database QoS Management会提出改进<code class="codeph">hr_pc</code> Performance Class性能的建议。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="overview-oracle-database-qos-management.html#GUID-D9ED0922-43EF-4AB5-80BA-669B753F1D87" title="Oracle Database QoS Management使您能够通过其建议管理多余容量以满足特定的性能目标。">建议概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="00813.using-XML-schema-processor-for-Java.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <meta name="description" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <title>使用XML Schema Processor for Java</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-xquery-API-for-Java-to-access-XML-DB.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-JAXB-class-generator.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-xquery-API-for-Java-to-access-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-JAXB-class-generator.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用XML Schema Processor for Java</li>
            </ol>
            <a id="GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" name="GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450"></a><a id="ADXDK993"></a><a id="ADXDK5000"></a>
            
            <h2 id="ADXDK-GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" class="sect2"><span class="enumeration_chapter">17</span>使用XML Schema Processor for Java</h2>
         </header>
         <div class="ind">
            <div>
               <p>这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。</p>
               <div class="section"> </div>
               <!-- class="section" -->
            </div><a id="ADXDK994"></a><a id="ADXDK19254"></a><div class="props_rev_3"><a id="GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50" name="GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50"></a><h3 id="ADXDK-GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50" class="sect3">XML验证简介</h3>
               <div>
                  <p>主题涵盖了XML验证的不同技术。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19255"></a><div class="props_rev_3"><a id="GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A" name="GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A"></a><h4 id="ADXDK-GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A" class="sect4">使用Java Schema Processor for Java的先决条件</h4>
                  <div>
                     <p>涵盖了使用XML模式处理器的先决条件。</p>
                     <p>本节假定您具备这些技术的工作知识：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">文档类型定义（DTD）</span></a> 。XML文档类型定义（DTD）定义XML文档的合法结构。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-B1E6F2C9-39D7-42D5-817B-6210231ABF97" title="XML Schema语言也称为XML Schema，是一种W3C建议，用于在XML文档中使用简单数据类型和复杂结构。它解决了目前DTD中缺乏的领域，包括数据类型的定义和验证。"><span class="xrefglossterm">XML Schema语言</span></a> 。XML Schema定义XML文档的法律结构。
                           </p>
                        </li>
                     </ul>
                     <p>要了解有关这些技术的更多信息，请参阅<a href="preface.html#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB" title="列出了与此文档相关的Oracle资源。">相关文档中</a>的XML资源。
                     </p>
                  </div>
               </div><a id="ADXDK19256"></a><div class="props_rev_3"><a id="GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72" name="GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72"></a><h4 id="ADXDK-GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72" class="sect4">用于Java的XML模式处理器的标准和规范</h4>
                  <div>
                     <p>XML Schema是万维网联盟（W3C）标准。</p>
                     <p>Oracle XML Schema处理器支持W3C XML Schema规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema0_primer" target="_blank"><span class="italic">XML Schema第0部分：入门</span></a> 
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema1_struct" target="_blank"><span class="italic">XML Schema第1部分：结构</span></a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema2_types" target="_blank"><span class="italic">XML Schema第2部分：数据类型</span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="描述了Oracle XML Developer&#39;s Kit（XDK）标准。">Oracle XML Developer的套件标准</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19257"></a><div class="props_rev_3"><a id="GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA" name="GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA"></a><h4 id="ADXDK-GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA" class="sect4">使用DTD进行XML验证</h4>
                  <div>
                     <p>文档类型定义（DTD）最初是为SGML开发的。 XML DTD是SGML中可用的子集，它提供了一种声明XML标记约束的机制。XML DTD支持以下规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML文档中可以包含哪些元素。</p>
                        </li>
                        <li>
                           <p>XML元素的内容模型，即元素是仅包含数据还是具有一组定义其结构的子元素。DTD可以定义子元素是可选的还是必需的，以及它是否只能出现一次或多次。</p>
                        </li>
                        <li>
                           <p>XML元素的属性。DTD还可以指定属性是可选的还是必需的。</p>
                        </li>
                        <li>
                           <p>在XML文档中合法的实体。</p>
                        </li>
                     </ul>
                     <p>XML DTD本身不是用XML编写的，而是一种与上下文无关的语法，用于定义XML文档的结构。您可以在XML文档本身或XML文档的单独文件中声明DTD。</p>
                     <p>验证是根据其关联的DTD验证XML文档的过程，确保结构，元素的使用和属性的使用与DTD中的定义一致。因此，处理XML文档的应用程序可以假定数据与定义匹配。</p>
                     <p>使用XDK，您可以编写包含验证XML解析器的应用程序;也就是说，一个程序根据DTD解析和验证XML文档。根据其实现，验证解析器可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在遇到错误时停止处理，或继续。</p>
                        </li>
                        <li>
                           <p>在报告发生时报告警告和错误，或在处理结束时报告摘要形式。</p>
                        </li>
                        <li>
                           <p>启用或禁用验证模式</p>
                           <p>大多数处理器可以启用或禁用验证模式，但它们仍然必须处理实体定义和DTD的其他构造。</p>
                        </li>
                     </ul>
                  </div><a id="ADXDK19259"></a><a id="ADXDK19260"></a><a id="ADXDK19258"></a><div class="props_rev_3"><a id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D" name="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D"></a><h5 id="ADXDK-GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D" class="sect5">XDK中的DTD样本</h5>
                     <div>
                        <p>显示了一个示例DTD，以及符合该DTD的示例XML文档。</p>
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHDHBEE">例17-1</a>显示了名为<code class="codeph">family.dtd</code>的DTD的内容，该DTD位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common/</code> 。<code class="codeph">&lt;ELEMENT&gt;</code>标签指定文档中元素的合法命名和结构，而<code class="codeph">&lt;ATTLIST&gt;</code>标签指定元素的合法属性。
                        </p>
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHCDDBD">例17-2</a>显示了名为<code class="codeph">family.xml</code>的XML文档的内容，该文档也位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common/</code> 。<code class="codeph">&lt;!<code class="codeph">family.xml</code> DOCTYPE&gt;</code>元素指定此XML文档符合名为<code class="codeph">family.dtd</code>的外部DTD。
                        </p>
                        <div class="example" id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHDHBEE">
                           <p class="titleinexample">例17-1 family.dtd</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;！ELEMENT家族（会员*）&gt; &lt;！ATTLIST家族姓氏CDATA #REQUIRED&gt; &lt;！ELEMENT成员（#PCDATA）&gt; &lt;！ATTLIST会员会员ID #REQUIRED&gt; &lt;！ATTLIST成员爸爸IDREF #IMPLIED&gt; &lt;！ATTLIST成员妈妈IDREF #IMPLIED&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHCDDBD">
                           <p class="titleinexample">例17-2 family.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”standalone =“no”？&gt; &lt;！DOCTYPE系列SYSTEM“family.dtd”&gt; &lt;family lastname =“Smith”&gt; &lt;member memberid =“m1”&gt; Sarah &lt;/ member&gt; &lt;member memberid =“m2”&gt; Bob &lt;/ member&gt; &lt;member memberid =“m3” mom =“m1”dad =“m2”&gt; Joanne &lt;/ member&gt; &lt;member memberid =“m4”mom =“m1”dad =“m2”&gt; Jim &lt;/ member&gt; &lt;/ family&gt;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19261"></a><div class="props_rev_3"><a id="GUID-674379DA-81FD-43CD-9C8B-998B70A11103" name="GUID-674379DA-81FD-43CD-9C8B-998B70A11103"></a><h4 id="ADXDK-GUID-674379DA-81FD-43CD-9C8B-998B70A11103" class="sect4">使用XML模式进行XML验证</h4>
                  <div>
                     <p>介绍了涉及使用XML模式进行验证的概念。</p>
                     <p><a href="glossary.html#GUID-B1E6F2C9-39D7-42D5-817B-6210231ABF97" title="XML Schema语言也称为XML Schema，是一种W3C建议，用于在XML文档中使用简单数据类型和复杂结构。它解决了目前DTD中缺乏的领域，包括数据类型的定义和验证。"><span class="xrefglossterm">XML Schema语言</span></a> （也称为<a href="glossary.html#GUID-8FD3F1F2-EA9C-4AED-955B-FE1570ABECDE" title="相当于XML Schema语言。"><span class="xrefglossterm">XML Schema Definition</span></a> ）是由W3C创建的，它使用XML语法来描述XML文档的内容和结构。<a href="glossary.html#GUID-085CAB85-F0BC-4D3B-A282-21E17B0BC9B3" title="用XML Schema语言编写的文档。"><span class="xrefglossterm">XML模式</span></a>是用XML模式语言编写的XML文档。XML模式文档包含描述输入XML文档结构的规则，称为<a href="glossary.html#GUID-C0B7CAC1-AB51-490D-AA39-ED961BB623CD" title="根据XML模式验证的XML文档。如果实例文档符合模式的规则，则认为它是有效的。"><span class="xrefglossterm">实例文档</span></a> 。当且仅当实例文档符合XML模式的规则时，实例文档才有效。
                     </p>
                     <p>XML Schema语言定义了以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>实例文档中哪些元素和属性是合法的</p>
                        </li>
                        <li>
                           <p>哪些元素可以是其他元素的子元素</p>
                        </li>
                        <li>
                           <p>子元素的顺序和数量</p>
                        </li>
                        <li>
                           <p>元素和属性的数据类型</p>
                        </li>
                        <li>
                           <p>元素和属性的默认值和固定值</p>
                        </li>
                     </ul>
                     <p>验证XML解析器尝试确定实例文档是否符合其关联XML模式的规则。使用XDK，您可以编写一个执行此模式验证的验证解析器。根据其实现，验证解析器可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在遇到错误时停止处理，或继续。</p>
                        </li>
                        <li>
                           <p>在报告发生时报告警告和错误，或在处理结束时报告摘要形式。</p>
                        </li>
                     </ul>
                     <p>处理器必须考虑实体定义以及实例文档中包含的DTD中定义的其他构造。XML Schema语言没有定义当实例文档同时包含XML模式和DTD时必须发生的事情。因此，在这种情况下应用程序的行为取决于实现。</p>
                  </div><a id="ADXDK19263"></a><a id="ADXDK19264"></a><a id="ADXDK19262"></a><div class="props_rev_3"><a id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3" name="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3"></a><h5 id="ADXDK-GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3" class="sect5">XDK中的XML模式示例</h5>
                     <div>
                        <p>将显示一个示例XML文档，其中包含一个购买报告，该报告描述了在不同区域中订购的零件。该文档位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/report.xml</code> 。还显示了可用于验证<code class="codeph">report.xml</code>的XML模式文档<code class="codeph">report.xsd</code> 。
                        </p>
                        <p>除其他外，XML模式定义实例文档中合法的元素的名称以及元素可以包含的数据类型。</p>
                        <div class="example" id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3__BABHGCFC">
                           <p class="titleinexample">例17-3 report.xml</p><pre class="pre codeblock"><code>&lt;purchaseReport xmlns =“http://www.example.com/Report”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：schemaLocation =“http：//www.example .com / Report report.xsd“period =”P3M“periodEnding =”1999-12-31“&gt; &lt;regions&gt; &lt;zip code =”95819“&gt; &lt;part number =”872-AA“quantity =”1“/&gt; &lt;part number =“926-AA”quantity =“1”/&gt; &lt;part number =“833-AA”quantity =“1”/&gt; &lt;part number =“455-BX”quantity =“1”/&gt; &lt;/ zip&gt; &lt;zip code =“63143”&gt; &lt;part number =“455-BX”quantity =“4”/&gt; &lt;/ zip&gt; &lt;/ regions&gt; &lt;parts&gt; &lt;part number =“872-AA”&gt;割草机&lt;/ part&gt; &lt;part number =“926-AA”&gt;婴儿监视器&lt;/ part&gt; &lt;part number =“833-AA”&gt; Lapis项链&lt;/ part&gt; &lt;part number =“455-BX”&gt;坚固的货架&lt;/ part&gt; &lt;/ parts&gt; &lt;/ purchaseReport&gt;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3__BABFDAEI">
                           <p class="titleinexample">例17-4 report.xsd</p><pre class="pre codeblock"><code>&lt;schema targetNamespace =“http://www.example.com/Report”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：r =“http://www.example.com/Report “elementFormDefault =”qualified“&gt; &lt;annotation&gt; &lt;documentation xml：lang =”en“&gt; Example.com版权所有2000 Example.com的报告架构。版权所有。&lt;/ documentation&gt; &lt;/ annotation&gt; &lt;element name =“purchaseReport”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“regions”type =“r：RegionsType”&gt; &lt;keyref name =“dummy2”refer =“r：pNumKey “&gt; &lt;selector xpath =”r：zip / r：part“/&gt; &lt;field xpath =”@ number“/&gt; &lt;/ keyref&gt; &lt;/ element&gt; &lt;element name =”parts“type =”r：PartsType“/ &gt; &lt;/ sequence&gt; &lt;attribute name =“period”type =“duration”/&gt; &lt;attribute name =“periodEnding”type =“date”/&gt; &lt;/ complexType&gt; &lt;unique name =“dummy1”&gt; &lt;selector xpath =“ r：regions / r：zip“/&gt; &lt;field xpath =”@ code“/&gt; &lt;/ unique&gt; &lt;key name =”pNumKey“&gt; &lt;selector xpath =”r：parts / r：part“/&gt; &lt;field xpath =“@ number”/&gt; &lt;/ key&gt; &lt;/ element&gt; &lt;complexType name =“RegionsType”&gt; &lt;sequence&gt; &lt;element name =“zip”maxOccurs =“unbounded”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“ part“maxOccurs =”unbounded“&gt; &lt;complexType&gt; &lt;complexContent&gt; &lt;restriction base =”anyType“&gt; &lt;attribute name =”number“type =”r：SKU“/&gt; &lt;attribute name =”quantity“type =”positiveInteger“ /&gt; &lt;/ restriction&gt; &lt;/ complexContent&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;attribute name =“c ode“type =”positiveInteger“/&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;simpleType name =”SKU“&gt; &lt;restriction base =”string“&gt; &lt;pattern value =”\ d {3 }  -  [AZ] {2}“/&gt; &lt;/ restriction&gt; &lt;/ simpleType&gt; &lt;complexType name =”PartsType“&gt; &lt;sequence&gt; &lt;element name =”part“maxOccurs =”unbounded“&gt; &lt;complexType&gt; &lt;simpleContent&gt; &lt; extension base =“string”&gt; &lt;attribute name =“number”type =“r：SKU”/&gt; &lt;/ extension&gt; &lt;/ simpleContent&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ schema &gt;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19266"></a><a id="ADXDK19265"></a><div class="props_rev_3"><a id="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9" name="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9"></a><h4 id="ADXDK-GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9" class="sect4">XML模式和DTD之间的差异</h4>
                  <div>
                     <p>XML Schema语言包含DTD规范的大部分功能。XML模式与DTD具有类似的用途，但在指定文档约束时更灵活。</p>
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9__CIHDIBAB" title="此表比较了XML Schema语言和DTD的功能">表17-1</a>比较了两种验证机制之间的一些功能。
                     </p>
                     <div class="tblformal" id="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9__CIHDIBAB">
                        <p class="titleintable">表17-1 XML Schema和DTD之间的功能比较</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="XML Schema与DTD的特性比较" width="100%" border="1" summary="This table compares the features of the XML Schema language and DTDs" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="37%" id="d63446e943">特征</th>
                                 <th align="left" valign="bottom" width="22%" id="d63446e946">XML Schema</th>
                                 <th align="left" valign="bottom" width="41%" id="d63446e949">DTD</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e954" headers="d63446e943 ">
                                    <p>元素嵌套</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e954 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e954 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e964" headers="d63446e943 ">
                                    <p>元素出现约束</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e964 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e964 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e974" headers="d63446e943 ">
                                    <p>允许的属性</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e974 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e974 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e984" headers="d63446e943 ">
                                    <p>属性类型和默认值</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e984 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e984 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e994" headers="d63446e943 ">
                                    <p>用XML编写</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e994 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e994 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1003" headers="d63446e943 ">
                                    <p>命名空间支持</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1003 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1003 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1012" headers="d63446e943 ">
                                    <p>内置数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1012 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1012 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1021" headers="d63446e943 ">
                                    <p>用户定义的数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1021 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1021 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1030" headers="d63446e943 ">
                                    <p>包含/进口</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1030 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1030 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1039" headers="d63446e943 ">
                                    <p>细化（继承）</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1039 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1039 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>这些原因可能是选择XML模式验证而不是DTD验证最有说服力的原因：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML Schema语言使您可以定义元素和属性<span class="italic">内容</span>的规则。您可以使用数据类型实现对内容的控制。使用XML Schema数据类型，您可以更轻松地执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>声明哪些元素包含哪些类型的数据，例如，一个元素中的正整数和另一个元素中的年份</p>
                              </li>
                              <li>
                                 <p>处理从数据库获得的数据</p>
                              </li>
                              <li>
                                 <p>定义数据限制，例如，10到20之间的数字</p>
                              </li>
                              <li>
                                 <p>定义数据格式，例如MM-DD-YYYY形式的日期</p>
                              </li>
                              <li>
                                 <p>在不同数据类型之间转换数据，例如，字符串到日期</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>与DTD语法不同，用XML Schema语言编写的文档本身是用XML编写的。因此，您可以执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用XML解析器来解析XML模式</p>
                              </li>
                              <li>
                                 <p>使用XML文档对象模型（DOM）处理XML模式</p>
                              </li>
                              <li>
                                 <p>使用可扩展样式表语言转换（XSLT）转换XML文档</p>
                              </li>
                              <li>
                                 <p>在其他XML模式中重用XML模式</p>
                              </li>
                              <li>
                                 <p>通过添加元素和属性来扩展XML架构</p>
                              </li>
                              <li>
                                 <p>引用同一文档中的多个XML模式</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADXDK19267"></a><div class="props_rev_3"><a id="GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8" name="GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8"></a><h3 id="ADXDK-GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8" class="sect3">使用XML架构处理器：概述</h3>
               <div>
                  <p>Oracle XML Schema处理器是一个基于SAX的XML模式验证器，可用于根据XML模式验证实例文档。处理器支持语言示例（LAX）和严格验证。</p>
                  <p>您可以通过以下方式使用处理器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在XML解析器中启用它</p>
                     </li>
                     <li>
                        <p>与DOM树一起使用它来验证整个或部分XML文档</p>
                     </li>
                     <li>
                        <p>将它用作处理管道中的组件（如内容处理程序）</p>
                     </li>
                  </ul>
                  <p>您可以根据需要以不同方式配置架构处理器。例如，您可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用固定的XML架构或基于实例文档中的<code class="codeph">schemaLocation</code>属性自动构建架构。
                        </p>
                     </li>
                     <li>
                        <p>设置<code class="codeph">XMLError</code>和<code class="codeph">entityResolver</code>以更好地控制验证过程。
                        </p>
                     </li>
                     <li>
                        <p>确定要验证的实例文档的数量。您可以使用<a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__G1043218" title="此表显示可在XDK解析器中使用的setValidationMode（）标志。模式名称，Java中的模式值和描述是列。">表12-1中</a>指定的任何验证模式。您还可以将一种元素指定为验证的根。
                        </p>
                     </li>
                  </ul>
               </div><a id="ADXDK19269"></a><a id="ADXDK19270"></a><a id="ADXDK19268"></a><div class="props_rev_3"><a id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6" name="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6"></a><h4 id="ADXDK-GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6" class="sect4">使用Java Schema Processor for Java：基本过程</h4>
                  <div>
                     <p>描述了对处理XML模式的应用程序很重要的XDK包。</p>
                     <p>这些是处理XML模式的应用程序的重要包：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">oracle.xml.parser.v2</code> ，提供用于XML解析的API</p>
                        </li>
                        <li>
                           <p><code class="codeph">oracle.xml.parser.schema</code> ，提供用于XML Schema处理的API</p>
                        </li>
                     </ul>
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__CHDHIJJE" title="该表描述了oracle.xml.parser.schema类。">表17-2</a>中描述了<code class="codeph">oracle.xml.parser.schema</code>包中最重要的类。这些构成了大多数XML模式应用程序的核心。
                     </p>
                     <div class="tblformalwide" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__CHDHIJJE">
                        <p class="titleintable">表17-2 oracle.xml.parser.schema类</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="oracle.xml.parser.schema类" width="100%" border="1" summary="This table describes the oracle.xml.parser.schema classes." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="22%" id="d63446e1325">类/接口</th>
                                 <th align="left" valign="bottom" width="29%" id="d63446e1328">描述</th>
                                 <th align="left" valign="bottom" width="49%" id="d63446e1331">方法</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1336" headers="d63446e1325 ">
                                    <p><code class="codeph">XMLSchema</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1336 d63446e1328 ">
                                    <p>表示XML Schema组件模型。<code class="codeph">XMLSchema</code>对象是属于不同目标命名空间的一组<code class="codeph">XMLSchemaNodes</code> 。<code class="codeph">XSDValidator</code>类使用<code class="codeph">XMLSchema</code>进行模式验证或元数据。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1336 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">get</code> <code class="codeph">getElement()</code>和<code class="codeph">getSchemaTargetNS()</code>获取有关XML模式的信息</p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">printSchema()</code>输出有关XML模式的信息</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1377" headers="d63446e1325 ">
                                    <p><code class="codeph">XMLSchemaNode</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1377 d63446e1328 ">
                                    <p>表示目标命名空间中的模式组件，包括类型定义，元素和属性说明以及组和属性组定义。</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1377 d63446e1331 ">
                                    <p>主要方法是<code class="codeph">get</code>方法，如<code class="codeph">getElementSet()</code>和<code class="codeph">getAttributeDeclarations()</code>获取XML模式的组件。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1398" headers="d63446e1325 ">
                                    <p><code class="codeph">XSDBuilder</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1398 d63446e1328 ">
                                    <p>从XML模式文档构建<code class="codeph">XMLSchema</code>对象。<code class="codeph">XMLSchema</code>对象是与顶级模式声明和定义相对应的一组对象（信息集项）。模式文档经过XML解析并转换为DOM树。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1398 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">build()</code>创建一个<code class="codeph">XMLSchema</code>对象。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">getObject()</code>返回<code class="codeph">XMLSchema</code>对象。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">setEntityResolver()</code>设置<code class="codeph">EntityResolver</code>以解析导入和包含。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1441" headers="d63446e1325 ">
                                    <p><code class="codeph">XSDValidator</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1441 d63446e1328 ">
                                    <p>根据XML模式验证实例XML文档。注册时， <code class="codeph">XSDValidator</code>对象作为<code class="codeph">XMLParser</code>和<code class="codeph">XMLDocument</code>事件处理程序之间的管道节点插入。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1441 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">get</code> <code class="codeph">getCurrentMode()</code>和<code class="codeph">getElementDeclaration()</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">set</code> <code class="codeph">setXMLProperty()</code>和<code class="codeph">setDocumentLocator()</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">startDocument()</code>接收文档开头的通知。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">startElement()</code>接收元素开头的通知。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__I1012436">图17-1</a>描述了使用XML Schema processor for Java验证实例文档的基本过程。
                     </p>
                     <div class="figure" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__I1012436">
                        <p class="titleinfigure">图17-1 Java的XML模式处理器</p><img src="img/adxdk105.gif" width="419" alt="下面是图17-1的描述" title="下面是图17-1的描述" longdesc="img_text/adxdk105.html"><br><a href="img_text/adxdk105.html">“图17-1 Java的XML模式处理器”的描述</a></div>
                     <!-- class="figure" -->
                     <p>XML Schema处理器执行以下主要任务：</p>
                     <ol>
                        <li>
                           <p>构建器（ <code class="codeph">XSDBuilder</code>对象）从输入XML架构文档中组装XML架构。虽然实例文档和模式不需要特定地作为操作系统上的文件存在，但它们通常被称为文件。它们可以作为字节流，数据库记录中的字段或XML Infoset“信息项”的集合存在。</p>
                           <p>此任务涉及将架构文档解析为对象。构建器显式或隐式创建架构对象：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在显式模式下，在调用处理器时传入XML模式。<a href="using-XML-schema-processor-for-Java.html#GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSetSchema.java显示了如何显式验证XML模式。验证模式是显式的，因为您使用XSDBuilder类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。">针对外部引用的XML模式进行验证</a>说明了如何在显式模式下构建模式对象。
                                 </p>
                              </li>
                              <li>
                                 <p>在隐式模式下，在调用处理器时不传递XML模式，因为模式在实例文档内部引用。<a href="using-XML-schema-processor-for-Java.html#GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSample.java显示了如何针对隐式XML模式进行验证。验证模式是隐式的，因为XML模式在实例文档本身中被引用。">针对内部引用的XML模式进行验证</a>说明了如何以隐式模式创建模式对象。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>XML模式验证程序使用模式对象来验证实例文档。此任务包含以下步骤：</p>
                           <ol type="a">
                              <li>
                                 <p>Simple API for XML（SAX）解析器将实例文档解析为SAX事件，并将其传递给验证器。</p>
                              </li>
                              <li>
                                 <p>验证器接收SAX事件作为输入，并根据模式对象验证它们，如果找到无效的XML组件则发送错误消息。</p>
                                 <p><a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7" title="要解析XML文档，请调用parse（）方法。通常，您将调用与parse（）方法关联的初始化和终止方法。">XML Parser</a>中的验证描述了验证实例文档时可以使用的验证模式。如果未使用<code class="codeph">XSDBuilder</code>类显式设置验证模式，则实例文档必须具有指向模式文件的正确<code class="codeph">xsi:schemaLocation</code>属性。否则，程序不会执行验证。如果处理器遇到错误，则会生成错误消息。
                                 </p>
                              </li>
                              <li>
                                 <p>验证器将输入SAX事件，默认值或后架构验证信息发送到DOM构建器或应用程序。</p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                     <div class="infoboxnotealso" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__GUID-79CE7578-8DAB-49AF-88FC-70B09FD34EF9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">XSDBuilder</code> ， <code class="codeph">DOMParser</code>和<code class="codeph">SAXParser</code>类</p>
                           </li>
                           <li>
                              <p><a href="using-XML-schema-processor-for-Java.html#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" title="这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。">使用XML Schema Processor for Java</a>了解XDK SAX和DOM解析器</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADXDK19272"></a><a id="ADXDK19271"></a><div class="props_rev_3"><a id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479" name="GUID-1794B57C-BD9A-4322-B136-B07B950EC479"></a><h4 id="ADXDK-GUID-1794B57C-BD9A-4322-B136-B07B950EC479" class="sect4">运行XML架构处理器演示程序</h4>
                  <div>
                     <p>用于Java的XML Schema处理器的演示程序包含在<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code> 。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI" title="此表描述了可用于测试XML架构处理器的XML文件和程序。文件和描述是列。">表17-3</a>介绍了可用于测试XML架构处理器的XML文件和程序。
                        </p>
                        <div class="tblformalwide" id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI">
                           <p class="titleintable">表17-3 XML架构示例文件</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML模式示例文件" width="100%" border="1" summary="This table describes the XML files and programs that you can use to test the XML Schema processor. File and Description are the Columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d63446e1704">文件</th>
                                    <th align="left" valign="bottom" width="81%" id="d63446e1707">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1712" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">cat.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1712 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序用于验证<code class="codeph">catalogue.xml</code>示例XML架构。<code class="codeph">cat.xsd</code>模式指定书籍目录的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1728" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">catalogue.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1728 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序用于针对<code class="codeph">cat.xsd</code>架构验证的示例实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1741" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">catalogue_e.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1741 d63446e1707 ">
                                       <p><code class="codeph">XSDSample.java</code>程序使用的示例实例文档。当程序尝试针对<code class="codeph">cat.xsd</code>架构验证此文档时，它会生成架构错误。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1754" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">DTD2Schema.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1754 d63446e1707 ">
                                       <p>此示例程序将DTD（第一个参数）转换为XML架构，并使用它来验证XML文件（第二个参数）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1761" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">embeded_xsql.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1761 d63446e1707 ">
                                       <p><code class="codeph">XSDLax.java.</code>使用的XML模式<code class="codeph">XSDLax.java.</code> 该模式定义了XSQL页面的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1771" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">embeded_xsql.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1771 d63446e1707 ">
                                       <p><code class="codeph">XSDLax.java</code>使用的实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1781" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer1.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1781 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。定义此文档的XML模式是<code class="codeph">juicer1.xsd</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1794" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer1.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1794 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML架构。此XML架构定义了<code class="codeph">juicer1.xml</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1807" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer2.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1807 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。定义此文档的XML模式是<code class="codeph">juicer2.xsd</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1820" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer2.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1820 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。此XML架构定义了<code class="codeph">juicer2.xml</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1833" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report.xml将</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1833 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>用于根据XML模式<code class="codeph">report.xsd</code>验证的示例XML文件。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1847" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1847 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序使用的示例XML架构，用于验证<code class="codeph">report.xml</code>的内容。<code class="codeph">report.xsd</code>模式指定采购订单的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1863" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report_e.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1863 d63446e1707 ">
                                       <p>当程序使用<code class="codeph">XSDSample.java</code>验证此示例XML文件时，它会生成XML Schema错误。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1873" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsddom.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1873 d63446e1707 ">
                                       <p>此程序显示如何通过获取文档的DOM表示并使用<code class="codeph">XSDValidator</code>对象来验证它来验证实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1883" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1883 d63446e1707 ">
                                       <p>此程序通过将<code class="codeph">SchemaLocation</code>属性中引用的模式重定向到本地版本来验证XML文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1893" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1893 d63446e1707 ">
                                       <p>该XML文档描述了一本书。该文件用作<code class="codeph">xsdent.java</code>的输入。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1903" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1903 d63446e1707 ">
                                       <p>此XML架构文档定义<code class="codeph">xsdent.xml</code>的规则。架构文档包含设置为<code class="codeph">xsdent-1.xsd</code>的<code class="codeph">schemaLocation</code>属性。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1919" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent-1.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1919 d63446e1707 ">
                                       <p><code class="codeph">xsdent.xsd</code> <code class="codeph">schemaLocation</code>属性引用的XML模式文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1932" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdproperty.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1932 d63446e1707 ">
                                       <p>此演示演示如何配置XML架构处理器以基于复杂类型或元素声明验证XML文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1939" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdsax.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1939 d63446e1707 ">
                                       <p>此演示演示如何验证作为SAX流接收的XML文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1946" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDLax.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1946 d63446e1707 ">
                                       <p>此演示与<code class="codeph">XSDSetSchema.java</code>相同，但为LAX验证设置<code class="codeph">SCHEMA_LAX_VALIDATION</code>标志。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1959" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDSample.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1959 d63446e1707 ">
                                       <p>此程序是一个示例驱动程序，可用于处理XML实例文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1967" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDSetSchema.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1967 d63446e1707 ">
                                       <p>此程序是通过覆盖<code class="codeph">schemaLocation</code>来处理XML实例文档的示例驱动程序。该程序使用<code class="codeph">cat.xsd</code>的XML Schema规范来验证<code class="codeph">catalogue.xml</code>的内容。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>有关如何编译和运行示例程序的文档位于同一目录的<code class="codeph">README</code>中。基本步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>转到<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\java\schema</code>目录（Windows）。</span></li>
                        <li class="stepexpand"><span>在命令行运行<code class="codeph">make</code> （UNIX）或<code class="codeph">Make.bat</code> （Windows）。</span></li>
                        <li class="stepexpand"><span>将<code class="codeph">xmlparserv2.jar</code> ， <code class="codeph">xschema.jar</code>和当前目录添加到<code class="codeph">CLASSPATH</code> 。这些JAR文件位于<code class="codeph">$ORACLE_HOME/lib</code> （UNIX）和<code class="codeph">%ORACLE_HOME%\lib</code> （Windows）中。例如，您可以在UNIX上使用<code class="codeph">tcsh</code> shell设置<code class="codeph">CLASSPATH</code> ：</span><div><pre class="oac_no_warn" dir="ltr">setenv CLASSPATH“$ CLASSPATH”：$ ORACLE_HOME / lib / xmlparserv2.jar：$ ORACLE_HOME / lib / schema.jar：。</pre><div class="infoboxnote" id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479__GUID-FF593407-5EB2-4FAC-93BA-E6344D752FF5">
                                 <p class="notep1">注意：</p>
                                 <p>XML Schema处理器需要JDK 1.2或更高版本，并且可以在任何支持Java 1.2的操作系统上使用。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用目录中包含的XML文件运行示例程序：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>这些示例使用<code class="codeph">report.xsd</code>验证的内容<code class="codeph">report.xml</code> ：</p><pre class="oac_no_warn" dir="ltr">java XSDSample report.xml java XSDSetSchema report.xsd report.xml</pre></li>
                                 <li>
                                    <p>此示例在Lax模式下验证实例文档：</p><pre class="oac_no_warn" dir="ltr">java XSDLax embeded_xsql.xsd embeded_xsql.xml</pre></li>
                                 <li>
                                    <p>这些示例使用<code class="codeph">cat.xsd</code>来验证<code class="codeph">catalogue.xml</code>的内容：</p><pre class="oac_no_warn" dir="ltr">java XSDSample catalogue.xml java XSDSetSchema cat.xsd catalogue.xml</pre></li>
                                 <li>
                                    <p>这些示例生成错误消息：</p><pre class="oac_no_warn" dir="ltr">java XSDSample catalogue_e.xml java XSDSample report_e.xml</pre></li>
                                 <li>
                                    <p>此示例使用<code class="codeph">xsdent.xsd</code>的<code class="codeph">schemaLocation</code>属性将XML架构重定向到<code class="codeph">xsdent-1.xsd</code>以进行验证：</p><pre class="oac_no_warn" dir="ltr">java xsdent xsdent.xml xsdent.xsd</pre></li>
                                 <li>
                                    <p>本实施例中从生成SAX流<code class="codeph">report.xml</code>和验证它针对所定义的XML模式<code class="codeph">report.xsd</code> ：</p><pre class="oac_no_warn" dir="ltr">java xsdsax report.xsd report.xml</pre></li>
                                 <li>
                                    <p>本例创建的DOM表示<code class="codeph">report.xml</code>和验证它针对所定义的XML模式<code class="codeph">report.xsd</code> ：</p><pre class="oac_no_warn" dir="ltr">java xsddom report.xsd report.xml</pre></li>
                                 <li>
                                    <p>这些示例配置从元素声明或复杂类型定义开始的验证：</p><pre class="oac_no_warn" dir="ltr">java xsdproperty juicer1.xml juicer1.xsd http://www.juicers.org \ juicersType false&gt; juicersType.out java xsdproperty juicer2.xml juicer2.xsd http://www.juicers.org \ Juicers true&gt; juicers_e.out</pre></li>
                                 <li>
                                    <p>此示例将DTD（ <code class="codeph">dtd2schema.dtd</code> ）转换为XML架构，并使用它来验证实例文档（ <code class="codeph">dtd2schema.xml</code> ）：</p><pre class="oac_no_warn" dir="ltr">java DTD2Schema dtd2schema.dtd dtd2schema.xml</pre></li>
                              </ul>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19273"></a><div class="props_rev_3"><a id="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0" name="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0"></a><h4 id="ADXDK-GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0" class="sect4">使用XML Schema Processor命令行实用程序</h4>
                  <div>
                     <p>您可以使用XML解析器命令行实用程序（ <code class="codeph">oraxml</code> ）来针对XML模式和DTD验证实例文档。
                     </p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0__GUID-C586B6FC-60E7-4CCF-AC3B-E18751B87AAF">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="XML-parsing-for-Java.html#GUID-204C527C-DED2-4FBA-861E-3378370529ED" title="oraxml实用程序位于$ ORACLE_HOME / bin（UNIX）或％ORACLE_HOME％\ bin（Windows）中，是一个解析XML文档的命令行界面。它检查结构良好和有效性。">使用Java XML Parser命令行实用程序（oraxml）</a>获取有关如何运行<code class="codeph">oraxml</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19275"></a><a id="ADXDK19274"></a><div class="props_rev_3"><a id="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C" name="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C"></a><h5 id="ADXDK-GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C" class="sect5">使用oraxml验证模式</h5>
                     <div>
                        <p>示例显示了如何通过在命令行上调用<code class="codeph">oraxml</code>来针对XML模式<code class="codeph">report.xsd</code>验证文档<code class="codeph">report.xml</code> 。
                        </p>
                        <div class="example" id="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C__CIHGACIE">
                           <p class="titleinexample">示例17-5使用oraxml验证模式</p>
                           <p>在<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code>目录中调用此命令：</p><pre class="pre codeblock"><code>oraxml -schema -enc report.xml</code></pre><p>预期的产出是：</p><pre class="pre codeblock"><code>输入文件的编码：UTF-8使用Schema验证模式解析输入XML文件时没有错误。</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19277"></a><a id="ADXDK19276"></a><div class="props_rev_3"><a id="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA" name="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA"></a><h5 id="ADXDK-GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA" class="sect5">使用oraxml验证DTD</h5>
                     <div>
                        <p>示例显示如何通过在命令行上调用<code class="codeph">oraxml</code>来针对DTD <code class="codeph">family.dtd</code>验证文档<code class="codeph">family.xml</code> 。
                        </p>
                        <div class="example" id="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA__CIHJDDBC">
                           <p class="titleinexample">示例17-6使用oraxml验证DTD</p>
                           <p>在<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common</code>目录中调用此命令：</p><pre class="pre codeblock"><code>oraxml -dtd -enc family.xml</code></pre><p>预期的产出是：</p><pre class="pre codeblock"><code>输入文件的编码：UTF-8使用DTD验证模式解析输入XML文件时没有错误。</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK995"></a><a id="ADXDK19278"></a><div class="props_rev_3"><a id="GUID-61216843-3968-49AB-8323-5774A7ABA2D7" name="GUID-61216843-3968-49AB-8323-5774A7ABA2D7"></a><h3 id="ADXDK-GUID-61216843-3968-49AB-8323-5774A7ABA2D7" class="sect3">使用XML模式验证XML</h3>
               <div>
                  <p>主题涵盖了使用XML模式验证XML文档的各种方法。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19279"></a><div class="props_rev_3"><a id="GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" name="GUID-5B182AA2-84E3-416A-837A-6563B2F948D5"></a><h4 id="ADXDK-GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" class="sect4">验证内部引用的XML模式</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDSample.java</code>显示了如何针对隐式XML模式进行验证。验证模式是隐式的，因为XML模式在实例文档本身中被引用。
                     </p>
                     <div class="section">
                        <p>按照本节中的步骤编写使用<code class="codeph">setValidationMode()</code>方法的程序<code class="codeph">oracle.xml.parser.v2.</code><code class="codeph">DOMParser</code>类：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建DOM解析器以用于验证实例文档。来自<code class="codeph">XSDSample.java</code>此代码片段显示了如何创建<code class="codeph">DOMParser</code>对象：</span><div><pre class="oac_no_warn" dir="ltr">public class XSDSample {public static void main（String [] args）抛出异常{if（args.length！= 1）{System.out.println（“用法：java XSDSample &lt;文件名&gt;”）;返回; } process（args [0]）; public static void process（String xmlURI）throws Exception {DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; ...} ...}</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它从作为参数传递给程序的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置验证DOM解析器的验证模式。例如， <code class="codeph">XSDSample.java</code>显示了如何指定XML模式验证：</span><div><pre class="oac_no_warn" dir="ltr">dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setErrorStream()</code>方法设置输出错误流。例如， <code class="codeph">XSDSample.java</code>为DOM解析器对象设置错误流：</span><div><pre class="oac_no_warn" dir="ltr">dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法验证实例文档。您不必显式创建XML架构对象，因为架构由实例文档在内部引用。例如， <code class="codeph">XSDSample.java</code>验证实例文档：</span><div><pre class="oac_no_warn" dir="ltr">尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（URL）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } catch（XMLParseException pe）{System.out.println（“Parser Exception：”+ pe.getMessage（））; } catch（Exception e）{System.out.println（“NonParserException：”+ e.getMessage（））; }</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19280"></a><div class="props_rev_3"><a id="GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" name="GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8"></a><h4 id="ADXDK-GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" class="sect4">验证外部引用的XML模式</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDSetSchema.java</code>显示了如何显式验证XML模式。验证模式是显式的，因为您使用<code class="codeph">XSDBuilder</code>类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。
                     </p>
                     <div class="section">
                        <p></p>
                        <p>按照本节中的基本步骤编写使用<code class="codeph">oracle.xml.parser.schema.的<code class="codeph">build()</code>方法的Java程序<code class="codeph">oracle.xml.parser.schema.XSDBuilder</code>类：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">XSDBuilder.build()</code>方法从XML模式文档构建XML模式对象。来自<code class="codeph">XSDSetSchema.java</code>此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">public class XSDSetSchema {public static void main（String [] args）抛出异常{if（args.length！= 2）{System.out.println（“用法：java XSDSample &lt;schema_file&gt; &lt;xml_file&gt;”）;返回; XSDBuilder builder = new XSDBuilder（）; URL url = createURL（args [0]）; //构建XML模式对象XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）; }。 。 。
</pre><p><code class="codeph">createURL()</code>方法是一个辅助方法，它根据命令行中指定的模式文档文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建DOM解析器以用于验证实例文档。<code class="codeph">XSDSetSchema.java</code>中的此代码显示了如何将实例文档文件名和XML模式对象传递给<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setXMLSchema()</code>方法指定要用于验证的模式对象。在隐式验证模式下，此步骤不是必需的，因为实例文档已经引用了模式。例如， <code class="codeph">XSDSetSchema.java</code>指定架构：</span><div><pre class="oac_no_warn" dir="ltr">dp.setXMLSchema（schemadoc）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置DOM解析器对象的验证模式。例如， <code class="codeph">XSDSample.java</code>显示了如何指定XML模式验证：</span><div><pre class="oac_no_warn" dir="ltr">dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setErrorStream()</code>方法设置解析器的输出错误流。例如， <code class="codeph">XSDSetSchema.java</code>设置它：</span><div><pre class="oac_no_warn" dir="ltr">dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法针对XML模式验证实例文档。例如， <code class="codeph">XSDSetSchema.java</code>包含以下代码：</span><div><pre class="oac_no_warn" dir="ltr">尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（url）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } catch（XMLParseException pe）{System.out.println（“Parser Exception：”+ pe.getMessage（））; } catch（Exception e）{System.out.println（“NonParserException：”+ e.getMessage（））; }</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19281"></a><div class="props_rev_3"><a id="GUID-AFB85EDC-550E-41D9-8754-9F916E44301E" name="GUID-AFB85EDC-550E-41D9-8754-9F916E44301E"></a><h4 id="ADXDK-GUID-AFB85EDC-550E-41D9-8754-9F916E44301E" class="sect4">验证XML文档的子部分</h4>
                  <div>
                     <p>在LAX模式下，您可以验证XML文档的各个部分，而无需验证所有部分。LAX解析验证在关联的XML模式中声明的文档中的元素。如果实例文档不包含模式中声明的元素，则处理器不会认为该实例文档无效。</p>
                     <div class="section">
                        <p></p>
                        <p>通过使用LAX模式，您只能为要验证的XML部分定义模式。<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDLax.java</code>程序显示了如何使用LAX验证。该程序遵循<a href="using-XML-schema-processor-for-Java.html#GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSetSchema.java显示了如何显式验证XML模式。验证模式是显式的，因为您使用XSDBuilder类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。">验证外部引用的XML模式中</a>描述的基本步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>从用户指定的XML模式文档构建XML模式对象。</span></li>
                        <li><span>创建DOM解析器以用于验证实例文档。</span></li>
                        <li><span>指定用于验证的XML架构。</span></li>
                        <li><span>设置DOM解析器对象的验证模式。</span></li>
                        <li><span>设置解析器的输出错误流。</span></li>
                        <li><span>通过调用<code class="codeph">DOMParser.parse()</code>针对XML模式验证实例文档。</span></li>
                     </ol>
                     <div class="section">
                        <p>要启用LAX验证，程序<code class="codeph">SCHEMA_LAX_VALIDATION</code>解析器中的验证模式设置为<code class="codeph">SCHEMA_LAX_VALIDATION</code>而不是<code class="codeph">SCHEMA_VALIDATION</code> 。来自<code class="codeph">XSDLax.java</code>代码片段显示了这种技术：</p><pre class="oac_no_warn" dir="ltr">dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_LAX_VALIDATION）; dp.setPreserveWhitespace（true）; 。 。 。
</pre><p>您可以通过运行示例程序来测试LAX验证：</p><pre class="oac_no_warn" dir="ltr">java XSDLax embeded_xsql.xsd embeded_xsql.xml</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19282"></a><div class="props_rev_3"><a id="GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3" name="GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3"></a><h4 id="ADXDK-GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3" class="sect4">从SAX流验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsdsax.java</code>显示如何验证作为SAX流接收的XML文档。您实例化<code class="codeph">XSDValidator</code>并将其作为内容处理程序注册到SAX解析器。
                     </p>
                     <div class="section">
                        <p>按照本节中的步骤编写从SAX流验证XML的程序：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.build()</code>方法，从用户指定的XML模式文档构建XML模式对象。此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（args [0]）; //构建XML模式对象XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）; 。 。 。
</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它根据命令行中指定的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个SAX解析器（ <code class="codeph">SAXParser</code>对象）以用于验证实例文档。来自<code class="codeph">saxxsd.java</code>代码片段将句柄传递给XML文档和模式文档到<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">process（args [1]，schemadoc）; ... public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {SAXParser dp = new SAXParser（）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置SAX解析器。此代码片段使用<code class="codeph">XSDBuilder.setValidationMode()</code>方法设置SAX解析器对象的验证模式：</span><div><pre class="oac_no_warn" dir="ltr">dp.setPreserveWhitespace（true）; dp.setValidationMode（XMLParser的。非验证）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建并配置验证器（ <code class="codeph">XSDValidator</code>对象）。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLError错误; ...错误=新XMLError（）; ...XSDValidator validator = new XSDValidator（）; ...validator.setError（ERR）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.setXMLProperty()</code>方法指定要用于验证的XML模式。第一个参数是属性的名称，它是<code class="codeph">fixedSchema</code> ，第二个参数是对XML模式对象的引用。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">validator.setXMLProperty（XSDNode。FIXED_SCHEMA，schemadoc）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>将验证器注册为解析器的SAX内容处理程序。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.setContentHandler（验证器）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">SAXParser.parse()</code>方法，针对XML模式验证实例文档。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.parse（url）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19283"></a><div class="props_rev_3"><a id="GUID-38EF516D-CB44-4857-9EEF-17ECE082068E" name="GUID-38EF516D-CB44-4857-9EEF-17ECE082068E"></a><h4 id="ADXDK-GUID-38EF516D-CB44-4857-9EEF-17ECE082068E" class="sect4">从DOM验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsddom.java</code>显示如何通过获取文档的DOM表示并使用<code class="codeph">XSDValidator</code>对象来验证它来验证实例文档。
                     </p>
                     <div class="section">
                        <p><code class="codeph">xsddom.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.build()</code>方法，从用户指定的XML模式文档构建XML模式对象。此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（args [0]）; XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）;</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它根据命令行中指定的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建DOM解析器（ <code class="codeph">DOMParser</code>对象）以用于验证实例文档。来自<code class="codeph">domxsd.java</code>代码片段将句柄传递给XML文档和模式文档到<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">process（args [1]，schemadoc）; ... public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {DOMParser dp = new DOMParser（）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置DOM解析器。此代码片段使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置解析器对象的验证模式：</span><div><pre class="oac_no_warn" dir="ltr">dp.setPreserveWhitespace（true）; dp.setValidationMode（XMLParser的。非验证）; dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>解析实例文档。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.parse（url）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>获取输入文档的DOM表示。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument doc = dp.getDocument（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建并配置验证器（ <code class="codeph">XSDValidator</code>对象）。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLError错误; ...错误=新XMLError（）; ...XSDValidator validator = new XSDValidator（）; ...validator.setError（ERR）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.setXMLProperty()</code>方法指定要用于验证的模式对象。第一个参数是属性的名称，在此示例中为<code class="codeph">fixedSchema</code> ，第二个参数是对架构对象的引用。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">validator.setXMLProperty（XSDNode。FIXED_SCHEMA，schemadoc）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>获取DOM树的根元素（ <code class="codeph">XMLElement</code> ）并进行验证。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLElement root =（XMLElement）doc.getDocumentElement（）; XMLElement copy =（XMLElement）root.validateContent（validator，true）; copy.print（System.out的）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19284"></a><div class="props_rev_3"><a id="GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C" name="GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C"></a><h4 id="ADXDK-GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C" class="sect4">从设计类型和元素验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsdproperty.java</code>显示了如何配置XML Schema处理器以基于复杂类型或元素声明验证XML文档。
                     </p>
                     <div class="section">
                        <p><code class="codeph">xsdproperty.java</code>程序遵循以下步骤：</p>
                        <ol>
                           <li>
                              <p>为实例文档名称，XML模式名称，根节点名称空间，根节点本地名称以及元素或复杂类型的规范创建<code class="codeph">String</code>对象（“true”表示根节点是元素声明）。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">String xmlfile = args [0]; String xsdfile = args [1]; ...String ns = args [2]; //根节点的命名空间String nm = args [3]; //根节点的本地名称String el = args [4]; //如果根节点是元素声明，则为true;否则，根节点是复杂类型</pre></li>
                           <li>
                              <p>创建XSD构建器并使用它来创建架构对象。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（xsdfile）; XMLSchema架构; ...schema =（XMLSchema）builder.build（url）;</pre></li>
                           <li>
                              <p>获取节点。根据节点是元素声明还是复杂类型调用不同的方法：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果节点是元素声明，则将本地名称和命名空间传递给架构对象的<code class="codeph">getElement()</code>方法。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果节点是元素声明，则将命名空间，本地名称和根复合体类型传递给架构对象的<code class="codeph">getType()</code>方法。
                                    </p>
                                 </li>
                              </ul>
                              <p><code class="codeph">xsdproperty.java</code>使用此控件结构：</p><pre class="oac_no_warn" dir="ltr">QxName qname = new QxName（ns，nm）; ...XSDNode nd; ...if（el.equals（“true”））{nd = schema.getElement（ns，nm）; / *过程......* /} else {nd = schema.getType（ns，nm，XSDNode。类型）; / *过程......* /}</pre></li>
                           <li>
                              <p>获取节点后，创建一个新的解析器并将模式设置为解析器以启用模式验证。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">DOMParser dp = new DOMParser（）; URL url = XMLUtil.createURL（xmlURI）;</pre></li>
                           <li>
                              <p>在解析器上设置属性，然后解析URL。调用<code class="codeph">schemaValidatorProperty()</code>方法：</p>
                              <ol type="a">
                                 <li>
                                    <p>将解析器上的根元素或类型属性设置为完全限定名称。</p>
                                    <p>对于顶级元素声明，请将属性名称设置为<code class="codeph">XSDNode.ROOT_ELEMENT</code>和<code class="codeph">QName</code>的值，由<code class="codeph">process1()</code>方法显示。
                                    </p>
                                    <p>对于顶级类型定义，请将属性名称设置为<code class="codeph">XSDNode.ROOT_TYPE</code>和<code class="codeph">QName</code>的值，由<code class="codeph">process2()</code>方法显示。
                                    </p>
                                 </li>
                                 <li>
                                    <p>将解析器上的根节点属性设置为元素或复杂类型节点。</p>
                                    <p>对于元素节点，将属性名称设置为<code class="codeph">XSDNode.ROOT_NODE</code>和<code class="codeph">XSDElement</code>节点的值，如<code class="codeph">XSDElement</code> <code class="codeph">process3()</code>方法所示。
                                    </p>
                                    <p>对于类型节点，将属性名称设置为<code class="codeph">XSDNode.ROOT_NODE</code>和<code class="codeph">XSDComplexType</code>节点的值，如<code class="codeph">XSDComplexType</code> <code class="codeph">process3()</code>方法所示。
                                    </p>
                                 </li>
                              </ol>
                              <p>此代码片段显示了方法调用的顺序：</p><pre class="oac_no_warn" dir="ltr">if（el.equals（“true”））{nd = schema.getElement（ns，nm）; process1（xmlfile，schema，qname）; process3（xmlfile，schema，nd）; } else {nd = schema.getType（ns，nm，XSDNode。类型）; process2（xmlfile，schema，qname）; process3（xmlfile，schema，nd）; }</pre><p>处理方法实施：</p><pre class="oac_no_warn" dir="ltr">static void process1（String xmlURI，XMLSchema schema，QxName qname）抛出异常{/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_ELEMENT，qname）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...static void process2（String xmlURI，XMLSchema schema，QxName qname）抛出异常{/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_TYPE，qname）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...static void process3（String xmlURI，XMLSchema schema，XSDNode node）抛出Exception {/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_NODE，节点）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...}</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADXDK996"></a><a id="ADXDK19286"></a><div class="props_rev_3"><a id="GUID-654F9D12-EC32-464B-9465-06ECB9213829" name="GUID-654F9D12-EC32-464B-9465-06ECB9213829"></a><h3 id="ADXDK-GUID-654F9D12-EC32-464B-9465-06ECB9213829" class="sect3">使用XML模式进行编程的技巧和技巧</h3>
               <div>
                  <p>主题包括覆盖模式位置和将DTD转换为XML模式。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19287"></a><div class="props_rev_3"><a id="GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D" name="GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D"></a><h4 id="ADXDK-GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D" class="sect4">使用实体解析器覆盖架构位置</h4>
                  <div>
                     <p>当<code class="codeph">XSDBuilder</code>构建模式时，可能需要包含或导入在<code class="codeph">schemaLocation</code>属性中指定为URL的其他模式。在某些情况下，您可能希望覆盖<code class="codeph">&lt;import&gt;</code>指定的架构位置，并为构建器提供所需的架构文档。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI" title="此表描述了可用于测试XML架构处理器的XML文件和程序。文件和描述是列。">表17-3</a>中描述的<code class="codeph">xsdent.java</code>演示显示了需要导入指定为<code class="codeph">schemaLocation</code>的模式的情况。<code class="codeph">xsdent.xml</code>文件中的document元素包含以下属性：</p><pre class="oac_no_warn" dir="ltr">xsi：schemaLocation =“http://www.example.com/BookCatalogue xsdent.xsd”&gt;</pre><p><code class="codeph">xsdent.xsd</code>文档包含以下元素：</p><pre class="oac_no_warn" dir="ltr">&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema"targetNamespace =”http://www.example.com/BookCatalogue“xmlns：catd =”http://www.example.com/Digest “xmlns：cat =”http://www.example.com/BookCatalogue“elementFormDefault =”qualified“&gt; &lt;import namespace =”http://www.example.com/Digest“schemaLocation =”xsdent-1.xsd“ /&gt;</pre><p>作为想要覆盖<code class="codeph">&lt;import&gt;</code>指定的模式位置并向构建器提供所需模式文档的示例，假设您已从外部Web站点下载了模式文档并将其存储在数据库中。在这种情况下，您可以在<code class="codeph">XSDBuilder</code>设置实体解析程序。<code class="codeph">XSDBuilder</code>将架构位置传递给解析器，解析器将<code class="codeph">InputStream</code> ， <code class="codeph">Reader</code>或<code class="codeph">URL</code>作为<code class="codeph">InputSource</code> 。构建器可以从<code class="codeph">InputSource</code>读取架构文档。
                        </p>
                        <p><code class="codeph">xsdent.java</code>程序显示了如何使用实体解析器覆盖架构位置。您必须实现<code class="codeph">EntityResolver</code>接口，实例化实体解析程序，并在XML模式构建器中进行设置。在演示代码中， <code class="codeph">sampleEntityResolver1</code>将<code class="codeph">InputSource</code>作为<code class="codeph">InputStream</code>返回，而<code class="codeph">sampleEntityResolver2</code>将<code class="codeph">InputSource</code>作为<code class="codeph">URL</code>返回。</p>
                        <p>请遵循以下基本步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建新的XML架构生成器：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>将构建器设置为实体解析器。实体解析器是实现<code class="codeph">EntityResolver</code>接口的类。解析器的目的是使XML阅读器在包含它们之前拦截任何外部实体。此代码片段创建实体解析器并在构建器中设置它：</span><div><pre class="oac_no_warn" dir="ltr">builder.setEntityResolver（new sampleEntityResolver1（））;</pre><p><code class="codeph">sampleEntityResolver1</code>类实现<code class="codeph">resolveEntity()</code>方法。您可以使用此方法将外部系统标识符重定向到本地URI。源代码是：</p><pre class="oac_no_warn" dir="ltr">class sampleEntityResolver1实现EntityResolver {public InputSource resolveEntity（String targetNS，String systemId）抛出SAXException，IOException {//根据targetNS＆systemId InputSource mySource = null执行任何验证检查; URL u = XMLUtil.createURL（systemId）; //使用InputStream作为输入创建输入源mySource = new InputSource（u.openStream（））; mySource.setSystemId（的systenId）;返回mySource; }}</pre><p><code class="codeph">sampleEntityResolver1</code>类使用流初始化<code class="codeph">InputSource</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>构建XML架构对象。此代码显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">schemadoc = builder.build（url）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>根据XML模式验证实例文档。该程序执行此语句：</span><div><pre class="oac_no_warn" dir="ltr">进程（xmlfile，schemadoc）;</pre><p><code class="codeph">process()</code>方法创建一个DOM解析器，对其进行配置，并调用<code class="codeph">parse()</code>方法。该方法实施：</p><pre class="oac_no_warn" dir="ltr">public static void process（String xmlURI，Object schemadoc）throws Exception {DOMParser dp = new DOMParser（）; URL url = XMLUtil.createURL（xmlURI）; dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）;试试{dp.parse（url）; ...}</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19288"></a><div class="props_rev_3"><a id="GUID-BC0B8A74-265E-4EBF-B012-923DA614F744" name="GUID-BC0B8A74-265E-4EBF-B012-923DA614F744"></a><h4 id="ADXDK-GUID-BC0B8A74-265E-4EBF-B012-923DA614F744" class="sect4">将DTD转换为XML模式</h4>
                  <div>
                     <p>由于XML Schema语言的强大功能和灵活性，您可能希望将现有DTD转换为XML架构文档。您可以使用XDK执行此转换。</p>
                     <div class="section">
                        <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/DTD2Schema.java</code>程序显示了如何转换DTD。你可以测试一下程序：</p><pre class="oac_no_warn" dir="ltr">java DTD2Schema dtd2schema.dtd dtd2schema.xml</pre><p>按照以下基本步骤将DTD转换为XML架构文档：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parseDTD()</code>方法解析DTD。<code class="codeph">DTD2Schema.java</code>中的此代码片段显示了如何创建DTD对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL dtdURL = createURL（args [0]）; DTD dtd = getDTD（dtdURL，“abc”）;</pre><p>实现了<code class="codeph">getDTD()</code>方法：</p><pre class="oac_no_warn" dir="ltr">private static DTD getDTD（URL dtdURL，String rootName）throws Exception {DOMParser parser = new DOMParser（）; DTD dtd; parser.setValidationMode（真）; parser.setErrorStream（System.out的）; parser.showWarnings（真）; parser.parseDTD（dtdURL，rootName）; dtd =（DTD）parser.getDoctype（）;返回dtd; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DTD.convertDTD2Sdhema()</code>方法将DTD转换为XML模式DOM树。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument dtddoc = dtd.convertDTD2Schema（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XMLDocument.print()</code>方法将XML模式DOM树写入输出流。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">FileOutputStream fos = new FileOutputStream（“dtd2schema.xsd.out”）; dtddoc.print（FOS）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XSDBuilder.build()</code>方法从架构DOM树创建XML架构对象。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLSchema schemadoc =（XMLSchema）builder.build（dtddoc，null）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法针对XML模式验证实例文档。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">validate（args [1]，schemadoc）;</pre><p><code class="codeph">validate()</code>方法已实现：</p><pre class="oac_no_warn" dir="ltr">DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）;尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（url）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } ...</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>