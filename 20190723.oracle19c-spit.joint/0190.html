<html id="03412.advanced-materialized-views.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>高级物化视图</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="basic-materialized-views.html" title="Previous" type="text/html"></link>
      <link rel="next" href="refreshing-materialized-views.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="basic-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="refreshing-materialized-views.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">优化数据仓库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">高级物化视图</li>
            </ol>
            <a id="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" name="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B"></a>
            
            <h2 id="DWHSG-GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" class="sect2"><span class="enumeration_chapter">6个</span>高级物化视图</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论使用实例化视图的高级主题。它包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-43FA865F-8C02-4B99-9202-49728BAA7687">关于分区和物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" title="不支持在分析视图或层次结构的查询上创建物化视图。">关于分析处理环境中的物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A">关于物化视图和模型</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-BC3675D3-C925-4D72-B953-34E7C818EB91">关于物化视图的安全问题</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">使实体化视图无效</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E">改变物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-0702359B-D379-4299-86C4-2958BCD4381D" title="即使物化视图标记为陈旧，实时物化视图也会为用户查询提供新数据。">使用实时物化视图</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8227"></a><div class="props_rev_3"><a id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687" name="GUID-43FA865F-8C02-4B99-9202-49728BAA7687"></a><h3 id="DWHSG-GUID-43FA865F-8C02-4B99-9202-49728BAA7687" class="sect3"><span class="enumeration_section">6.1</span>关于分区和物化视图</h3>
               <div>
                  <p><a id="d25854e81" class="indexterm-anchor"></a><a id="d25854e85" class="indexterm-anchor"></a>由于数据仓库中保存的数据量很大，因此在设计数据库时，分区是一个非常有用的选项。对事实表进行分区可以提高可伸缩性，简化系统管理，并且可以定义可以高效重建的本地索引。对事实表进行分区还可以提高快速刷新物化视图的机会，因为这可以在物化视图上启用分区更改跟踪（PCT）刷新。对物化视图进行分区也有利于刷新，因为刷新过程可以在更多场景中使用并行DML，而基于PCT的刷新可以使用截断分区来有效地维护物化视图。
                  </p>
                  <div class="infoboxnotealso" id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687__GUID-C0A88051-183F-4068-9B28-5A058CE6B1FD">
                     <p class="notep1">也可以看看：</p>
                     <p>有关分区的更多详细信息，请参见<a href="../vldbg/partition-concepts.html#VLDBG002" target="_blank"><span><cite>“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0661E251-15FA-4845-A358-7209D9B22096">对物化视图进行分区</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-B609252D-DD65-4617-8F38-B1AB52473AA5">对预构建表进行分区</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-5AC25C22-427B-45B8-B949-B05AC8853310">滚动物化视图</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG00324"></a><div class="props_rev_3"><a id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" name="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1"></a><h4 id="DWHSG-GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" class="sect4"><span class="enumeration_section">6.1.1</span>关于分区更改跟踪</h4>
                  <div>
                     <p>它是<a id="d25854e143" class="indexterm-anchor"></a><a id="d25854e145" class="indexterm-anchor"></a>与整个物化视图相比，追踪新鲜到更细粒度的可能性和有利性。您可以通过<a href="glossary.html#GUID-32BF9E11-2C90-446A-9C66-4D0BA8DF7798"><span class="xrefglossterm">分区更改跟踪（PCT）</span></a>来实现此目的，这是一种识别物化视图中哪些行受特定详细信息表分区影响的方法。当一个或多个细节表被分区时，可以识别物化视图中对应于修改的细节分区的特定行;当修改分区而所有其他行保持新鲜时，这些行变得陈旧。
                     </p>
                     <p>您可以使用PCT来标识哪些物化视图行对应于特定分区。PCT还用于支持对详细信息表进行分区维护操作后的快速刷新。例如，如果截断或删除详细信息表分区，则会标识并删除实例化视图中受影响的行。</p>
                     <p>识别哪些物化视图行是新的或陈旧的，而不是将整个物化视图视为过时，允许查询重写使用<code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式下新鲜的行。多个视图（例如<code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code> ）详细说明了哪些分区过时或新鲜。如果通过物化视图中存在的连接相关表达式启用已更改表上的分区更改跟踪，则Oracle不会重写部分过时的物化视图。
                     </p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-C6E771CD-21C4-42DC-871F-C18680BECA1D">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">关于加入依赖表达式和分区更改跟踪</a> ”</span>以获取更多信息</p>
                     </div>
                     <p>请注意，虽然分区更改跟踪跟踪分区和子分区级别（对于复合分区表）的过时性，但PCT刷新的粒度级别仅是顶级分区策略。因此，对复合分区表的一个子分区中的数据进行的任何更改都只会将受影响的单个子分区标记为过时，并且该表的其余部分可用于重写，但PCT刷新将刷新包含受影响的整个分区。子分区。</p>
                     <p>为了支持PCT，物化视图必须满足以下要求：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>必须对物化视图引用的至少一个详细信息表进行分区。</p>
                        </li>
                        <li>
                           <p>分区表必须使用范围，列表或带范围或列表的复合分区作为顶级分区策略。</p>
                        </li>
                        <li>
                           <p>顶级分区键必须只包含一列。</p>
                        </li>
                        <li>
                           <p>物化视图必须包含分区键列或分区标记或详细信息表的<code class="codeph">ROWID</code>或连接依赖表达式。
                           </p>
                        </li>
                        <li>
                           <p>如果使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句，分区键列或分区标记或<code class="codeph">ROWID</code>或参加相关的表达式必须出现在<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。
                           </p>
                        </li>
                        <li>
                           <p>如果使用分析窗口函数或<code class="codeph">MODEL</code>子句，则分区键列或分区标记或<code class="codeph">ROWID</code>或连接依赖表达式必须存在于其各自的<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句中。
                           </p>
                        </li>
                        <li>
                           <p>数据修改只能在分区表上进行。如果对物化视图中具有连接依赖表达式的表执行PCT刷新，则不应在任何连接相关表中进行数据修改。</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMPATIBILITY</code>初始化参数必须至少为9.0.0.0.0。
                           </p>
                        </li>
                     </ul>
                     <p>引用视图，远程表或外连接的物化视图不支持PCT。</p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-13A32E69-2B80-4385-A3E8-F5B10B9991C0">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_MVIEW.PMARKER</code>函数和分区标记的详细信息，请<code class="codeph">DBMS_MVIEW.PMARKER</code> <a href="../arpls/DBMS_MVIEW.html#ARPLS027" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BDF063E9-7769-4272-A54E-C5E199476C46">关于分区键和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">关于加入依赖表达式和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79">关于分区标记和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-462D637E-27E2-4581-BD50-6CA79A854000">关于分区更改跟踪中的部分重写</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8229"></a><a id="DWHSG8228"></a><div class="props_rev_3"><a id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46" name="GUID-BDF063E9-7769-4272-A54E-C5E199476C46"></a><h5 id="DWHSG-GUID-BDF063E9-7769-4272-A54E-C5E199476C46" class="sect5"><span class="enumeration_section">6.1.1.1</span>关于分区键和分区更改跟踪</h5>
                     <div>
                        <p>分区更改跟踪需要物化视图中的足够信息，以便能够将源分区详细信息表中的详细信息行与相应的物化视图行相关联。这可以通过在<code class="codeph">SELECT</code>列表中包含详细信息表分区键列来实现，如果使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>则可以在<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表中包含。
                        </p>
                        <p>考虑存储每日客户销售的物化视图的示例。以下示例使用<code class="codeph">sh</code>示例模式和三个详细信息表<code class="codeph">sales</code> ， <code class="codeph">products</code>和<code class="codeph">times</code>来创建实例化视图。 <code class="codeph">sales</code>表由<code class="codeph">time_id</code>列分区， <code class="codeph">products</code>由<code class="codeph">prod_id</code>列分区。 <code class="codeph">times</code>不是分区表。
                        </p>
                        <div class="example" id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46__GUID-57C843AC-0CA8-4C49-92D3-5B9D7964F9ED">
                           <p class="titleinexample">示例6-1带分区键的物化视图</p><pre class="oac_no_warn" dir="ltr">使用ROWID创建物料化视图日志（prod_id，time_id，quantity_sold，amount_sold）包括新值;使用ROWID创建物料化视图日志（prod_id，prod_name，prod_desc）包括新值;使用ROWID（time_id，calendar_month_name，calendar_year）创建物料化视图日志，包括新值; CREATE MATERIALIZED VIEW cust_dly_sales_mv建立快速刷新需求快速启动作为选择的QUERY REWRITE s.time_id，p.prod_id，p.prod_name，COUNT（*），SUM（s.quantity_sold），SUM（s.amount_sold），COUNT（s。 quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY s.time_id，p.prod_id，p.prod_name;</pre><p>对于<code class="codeph">cust_dly_sales_mv</code> ，在<code class="codeph">sales</code>表上启用了PCT，因为分区键列<code class="codeph">time_id</code>位于物化视图中。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8231"></a><a id="DWHSG8230"></a><div class="props_rev_3"><a id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" name="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697"></a><h5 id="DWHSG-GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" class="sect5"><span class="enumeration_section">6.1.1.2</span>关于连接依赖表达式和分区更改跟踪</h5>
                     <div>
                        <p>由直接或间接通过等值连接到分区键上的分区详细信息表的表的列组成的表达式称为连接依赖表达式，该表达式是连接键的维度属性或维度分层父级。详细信息表路径中的表集称为连接依赖表。考虑以下：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，t.calendar_month_name FROM sales s，times t WHERE s.time_id = t.time_id;</pre><p>在此查询中， <code class="codeph">times</code>表是一个连接依赖表，因为它连接到分区键列<code class="codeph">time_id</code>上的<code class="codeph">sales</code>表。此外， <code class="codeph">calendar_month_name</code>是<code class="codeph">times.time_id</code>的维度层次结构属性，因为<code class="codeph">calendar_month_name</code>是<code class="codeph">times.mon_id</code>的属性， <code class="codeph">times.mon_id</code>是<code class="codeph">times.mon_id</code>的维度层次结构父<code class="codeph">times.time_id</code> 。因此，表达<code class="codeph">calendar_month_name</code>从<code class="codeph">times</code>表是一个连接依赖性表达。让我们考虑另一个例子：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，y.calendar_year_name FROM sales s，times_d d，times_m m，times_y y WHERE s.time_id = d.time_id AND d.day_id = m.day_id AND m.mon_id = y.mon_id;</pre><p>在这里， <code class="codeph">times</code>表规格化到<code class="codeph">times_d</code> ， <code class="codeph">times_m</code>和<code class="codeph">times_y</code>表。<code class="codeph">times_y</code>表中的表达式<code class="codeph">calendar_year_name</code>是一个依赖于连接的表达式，表<code class="codeph">times_d</code> ， <code class="codeph">times_m</code>和<code class="codeph">times_y</code>是依赖于连接的表。这是因为<code class="codeph">times_y</code>表通过<code class="codeph">times_m</code>和<code class="codeph">times_d</code>表间接连接到其分区键列<code class="codeph">time_id</code>上的sales表。
                        </p>
                        <p>这使用户可以创建包含聚合的实体化视图，这些聚合在某个级别上高于详细信息表的分区键。请考虑以下存储每月客户销售额的物化视图示例。</p>
                        <div class="example" id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697__GUID-88E6DF64-A0B7-4343-BF7A-CEAADF171F4A">
                           <p class="titleinexample">示例6-2创建物化视图：加入依赖表达式</p>
                           <p>假设存在先前定义的物化视图日志，可以使用以下DDL创建物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv根据需求建立推荐的刷新快速启用QUERY REWRITE作为选择t.calendar_month_name，p.prod_id，p.prod_name，COUNT（*），SUM（s.quantity_sold），SUM（s.amount_sold），COUNT（s。 quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY t.calendar_month_name，p.prod_id，p.prod_name;</pre><p>在这里，您可以使用连接相关表<code class="codeph">times</code>和<code class="codeph">times.calendar_month_name</code>是由<code class="codeph">times.time_id</code>确定的维度属性的关系将详细信息表行与其对应的物化视图行相关<code class="codeph">times.time_id</code> 。这样可以在<code class="codeph">sales</code>表上启用分区更改跟踪。除此之外， <code class="codeph">prod_id</code>在物化视图中存在分区键列<code class="codeph">prod_id</code> ，因此在产品表上启用了PCT。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8233"></a><a id="DWHSG8232"></a><div class="props_rev_3"><a id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" name="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79"></a><h5 id="DWHSG-GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" class="sect5"><span class="enumeration_section">6.1.1.3</span>关于分区标记和分区更改跟踪</h5>
                     <div>
                        <p><code class="codeph">DBMS_MVIEW.PMARKER</code>函数旨在显着降低物化视图的基数（不同值与表行数的比率）（例子见<a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">示例6-3</a> ）。该函数返回一个分区标识符，该标识符唯一标识指定分区表中指定行的分区或子分区。因此，使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数而不是<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中的分区键列。
                        </p>
                        <p>与物化视图中PL / SQL函数的一般情况不同，即使重写模式为<code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code> ，使用<code class="codeph">DBMS_MVIEW.PMARKER</code>也不会阻止使用该物化视图进行重写。</p>
                        <p>作为使用<code class="codeph">PMARKER</code>功能的示例，请考虑计算典型数字，例如在给定年份内产品类别产生的收入。如果每月销售1000种不同的产品，则在物化视图中将产生12,000行。
                        </p>
                        <div class="example" id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">
                           <p class="titleinexample">示例6-3在物化视图中使用分区标记</p>
                           <p>考虑存储每个产品类别的年销售收入的物化视图的示例。在每个产品类别中有大约数百种不同的产品，包括物化视图中<code class="codeph">products</code>表的分区键列<code class="codeph">prod_id</code>将大大增加基数。相反，此物化视图使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数，该函数将物化视图的基数增加了<code class="codeph">products</code>表中分区数量的因子。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW prod_yr_sales_mv建立需求快速刷新需要启动REERY REWRITE作为选择DBMS_MVIEW.PMARKER（p.rowid），p.prod_category，t.calendar_year，COUNT（*），SUM（s.amount_sold），SUM（s.quantity_sold） ，COUNT（s.amount_sold），COUNT（s.quantity_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY DBMS_MVIEW.PMARKER（p.rowid）， p.prod_category，t.calendar_year;</pre><p><code class="codeph">prod_yr_sales_mv</code>在其<code class="codeph">SELECT</code>列表中的<code class="codeph">products</code>表上包含<code class="codeph">DBMS_MVIEW.PMARKER</code>函数。这使得对<code class="codeph">products</code>表的分区更改跟踪的基数影响明显小于分区键列<code class="codeph">prod_id</code> 。在此示例中， <code class="codeph">prod_yr_sales_mv</code>的所需聚合<code class="codeph">prod_yr_sales_mv</code>是按<code class="codeph">products.prod_category</code>分组。使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数，物化视图基数仅增加了<code class="codeph">products</code>表中分区数量的因子。这通常会明显小于包含分区键列的基数影响。
                           </p>
                           <p>请注意，由于<code class="codeph">SELECT</code>列表中存在与连接相关的表达式<code class="codeph">calendar_year</code> ，因此在<code class="codeph">sales</code>表上启用了分区更改跟踪。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8234"></a><div class="props_rev_3"><a id="GUID-462D637E-27E2-4581-BD50-6CA79A854000" name="GUID-462D637E-27E2-4581-BD50-6CA79A854000"></a><h5 id="DWHSG-GUID-462D637E-27E2-4581-BD50-6CA79A854000" class="sect5"><span class="enumeration_section">6.1.1.4</span>关于分区变更跟踪中的部分重写</h5>
                     <div>
                        <p>随后的<code class="codeph">INSERT</code>语句将新行添加到表<code class="codeph">sales</code>的<code class="codeph">sales_part3</code>分区。此时，由于<code class="codeph">cust_dly_sales_mv</code>使用分区键在表<code class="codeph">sales</code>具有PCT可用，因此Oracle可以在物化视图<code class="codeph">cust_dly_sales_mv</code>与<code class="codeph">sales_part3</code>分区对应的过时行（其他行在其新鲜状态中保持不变）。查询重写无法识别物化视图<code class="codeph">cust_mth_sales_mv</code>和<code class="codeph">prod_yr_sales_mv</code>的新部分，因为PCT可使用连接相关表达式在表销售中使用。仅当使用分区键或分区标记在详细信息表上提供PCT时，查询重写才能确定详细信息表更改的物化视图的新部分。
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8235"></a><div class="props_rev_3"><a id="GUID-0661E251-15FA-4845-A358-7209D9B22096" name="GUID-0661E251-15FA-4845-A358-7209D9B22096"></a><h4 id="DWHSG-GUID-0661E251-15FA-4845-A358-7209D9B22096" class="sect4"><span class="enumeration_section">6.1.2</span>对物化视图进行分区</h4>
                  <div>
                     <div class="section">
                        <p>对物化视图进行分区涉及使用标准Oracle分区子句定义物化视图，如以下示例所示。此语句创建一个名为<code class="codeph">part_sales_mv</code>的物化视图，该视图使用三个分区，可以快速刷新，并且有资格进行查询重写：</p><pre class="oac_no_warn" dir="ltr">创建实质性视图part_sales_mv按范围划分的并行分区（time_id）（PARTITION month1 VALUE少于（7月-12-1998'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M）TABLESPACE sf1，PARTITION month2 VALUES不到（截止日期（'31 -12-1999'，'DD-MM-YYYY'））PCT免费0存储（初始8M）表格sf2，分区月3价值低于（7月12日（'31 -12-2000'，'DD） -MM-YYYY'））PCTFREE 0存储（初始8M）表格sf3）构建推荐的刷新快速启用QUERY REWRITE作为SELECT s.cust_id，s.time_id，SUM（s.amount_sold）AS sum_dol_sales，SUM（s.quantity_sold）AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8236"></a><div class="props_rev_3"><a id="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" name="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5"></a><h4 id="DWHSG-GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" class="sect4"><span class="enumeration_section">6.1.3</span>对预构建表进行分区</h4>
                  <div>
                     <div class="section">
                        <p><a id="d25854e709" class="indexterm-anchor"></a>或者，可以将物化视图注册到分区的预构建表。 <span class="q">“ <a href="advanced-materialized-views.html#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">对物化视图</a></span>进行分区的好处<span class="q">”</span>描述了对预构建表进行分区的好处。以下示例说明了这一点：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_sales_tab_mv（time_id，cust_id，sum_dollar_sales，sum_unit_sale）PARALLEL PARTITION BY RANGE（time_id）（PARTITION month1 VALUE少于（TO_DATE（'31 -12-1998'，'DD-MM-YYYY'））PCTFREE 0 STORAGE（INITIAL） 8M）TABLESPACE sf1，PARTITION month2 VALUE少于（7月12日（'31 -12-1999'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M）TABLESPACE sf2，分区第3个月值（不到（*） -12-2000'，'DD-MM-YYYY'））PCTFREE 0 STORAGE（INITIAL 8M）TABLESPACE sf3）AS SELECT s.time_id，s.cust_id，SUM（s.amount_sold）AS sum_dollar_sales，SUM（s.quantity_sold） AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id; CREATE MATERIALIZED VIEW part_sales_tab_mv ON PREBUILT TABLE ENABLE QUERY REWRITE as SELECT s.time_id，s.cust_id，SUM（s.amount_sold）AS sum_dollar_sales，SUM（s.quantity_sold）AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id;</pre><p>在此示例中，表<code class="codeph">part_sales_tab_mv</code>已分区超过三个月，然后注册实例化视图以使用预构建表。此物化视图符合查询重写的条件，因为已包含<code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>子句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8237"></a><div class="props_rev_3"><a id="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" name="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA"></a><h5 id="DWHSG-GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" class="sect5"><span class="enumeration_section">6.1.3.1</span>对物化视图进行分区的好处</h5>
                     <div>
                        <p>当物化视图在细分表的分区键列或连接依赖表达式上进行分区时，使用<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句在刷新期间删除物化视图的一个或多个分区，然后使用新数据重新填充分区更有效。除了<span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”中</span>描述的其他条件之外，如果满足以下条件，Oracle数据库将使用此快速刷新（称为PCT刷新）并带有分区截断。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>物化视图在细分表的分区键列或连接相关表达式上进行分区。</p>
                           </li>
                           <li>
                              <p>如果使用分区键列或连接表达式启用PCT，则物化视图应为范围或列表分区。</p>
                           </li>
                           <li>
                              <p>PCT更新是非原子的。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8238"></a><div class="props_rev_3"><a id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310" name="GUID-5AC25C22-427B-45B8-B949-B05AC8853310"></a><h4 id="DWHSG-GUID-5AC25C22-427B-45B8-B949-B05AC8853310" class="sect4"><span class="enumeration_section">6.1.4</span>滚动物化视图</h4>
                  <div>
                     <p>当数据仓库或数据集市包含时间维度时，通常需要归档最旧的信息，然后重新使用存储来获取新信息。这称为滚动窗口场景。如果事实表或物化视图包含时间维度并且由时间属性水平分区，则滚动物化视图的管理可以简化为一些快速分区维护操作，前提是推出的数据单位等于或等于与范围分区最不一致的。</p>
                     <p>如果您计划在数据仓库中使用滚动的物化视图，则应确定计划执行分区维护操作的频率，并且应该计划对事实表和物化视图进行分区，以减少旧数据所需的系统管理开销量。老了。另外一个考虑因素是您可能希望在不经常更新的分区上使用数据压缩。</p>
                     <p>您不限于使用范围分区。例如，使用时间值和键值的复合分区可以为您的数据提供良好的分区解决方案。</p>
                     <div class="infoboxnotealso" id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310__GUID-8BAE7F52-08F0-4A6B-A4A1-864208143D3D">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。">刷新物化视图</a>以获取有关<code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>更多详细信息以及有关压缩的详细信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8239"></a><div class="props_rev_3"><a id="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" name="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A"></a><h3 id="DWHSG-GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" class="sect3"><span class="enumeration_section">6.2</span>关于分析处理环境中的物化视图</h3>
               <div>
                  <p>本节讨论分析SQL使用的概念以及关系数据库如何处理这些类型的查询。它还说明了使用常见方案创建物化视图的最佳方法。</p>
                  <p>以下主题包含有关不同环境中的实例化视图的其他信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-97D76353-0B1A-4685-868E-CAC915FDE194" title="不支持在分析视图或层次结构的查询上创建物化视图。">关于物化视图和分析视图</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A">关于物化视图和分层多维数据集</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D">分区物化视图的好处</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444">关于压缩物化视图</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39">关于具有集合运算符的物化视图</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-97D76353-0B1A-4685-868E-CAC915FDE194" name="GUID-97D76353-0B1A-4685-868E-CAC915FDE194"></a><h4 id="DWHSG-GUID-97D76353-0B1A-4685-868E-CAC915FDE194" class="sect4"><span class="enumeration_section">6.2.1</span>关于物化视图和分析视图</h4>
                  <div>
                     <p>不支持在分析视图或层次结构的查询上创建物化视图。</p>
                  </div>
               </div><a id="DWHSG8241"></a><a id="DWHSG8242"></a><a id="DWHSG8240"></a><div class="props_rev_3"><a id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" name="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A"></a><h4 id="DWHSG-GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" class="sect4"><span class="enumeration_section">6.2.2</span>关于物化视图和分层多维数据集</h4>
                  <div>
                     <p>虽然数据仓库环境通常以星型模式的形式查看数据，但对于分析性SQL查询，数据以分层多维数据集的形式保存。分层多维数据集包括沿其每个维度的汇总层次聚合的数据，这些聚合跨维度组合。它包括商业智能查询所需的典型聚合集。</p>
                     <div class="example" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__GUID-C915B982-A86F-4A53-8A1E-68BB537E1152">
                        <p class="titleinexample">示例6-4分层多维数据集</p>
                        <p>考虑具有两个维度的销售数据集，每个维度都具有四级层次结构：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>时间，包含（所有时间），年，季度和月份。</p>
                           </li>
                           <li>
                              <p>产品，包含（所有产品），部门，品牌和项目。</p>
                           </li>
                        </ul>
                        <p>这意味着分层多维数据集中有16个聚合组。这是因为四个时间级别乘以四个产品级别来生成立方体。<a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832" title="此表说明了时间和产品维度的层次结构。">表6-1</a>显示了每个维度的四个级别。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="tblformal" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832">
                           <p class="titleintable">表6-1按时间和产品进行的滚动</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="ROLLUP按时间和产品" width="100%" border="1" summary="This table illustrates the hierarchies for the Time and Product dimensions." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d25854e984">按时间滚动</th>
                                    <th align="left" valign="bottom" width="70%" id="d25854e987">ROLLUP按产品分类</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e992" headers="d25854e984 ">
                                       <p>年，季度，月份</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e992 d25854e987 ">
                                       <p>分裂，品牌，项目</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e999" headers="d25854e984 ">
                                       <p>一年，季度</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e999 d25854e987 ">
                                       <p>分裂，品牌</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1006" headers="d25854e984 ">
                                       <p>年</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1006 d25854e987 ">
                                       <p>师</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1013" headers="d25854e984 ">
                                       <p>一直</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1013 d25854e987 ">
                                       <p>所有产品</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>请注意，随着您增加维度和级别的数量，要计算的组数量会急剧增加。此示例涉及16个组，但如果您要添加两个具有相同级别的维度，则将具有4 x 4 x 4 x 4 = 256个不同的组。另外，如果您的维度中有多个层次结构，请考虑类似的组增加。例如，时间维度可能具有累计到财务季度和财务年度的额外财务月份层次结构。处理群体爆炸一直是在线分析处理系统数据存储的主要挑战。</p>
                        <p>典型的在线分析查询对多维数据集的不同部分进行<a href="glossary.html#GUID-F7CC0204-822C-4C1F-AE7D-A7CC609C05C0"><span class="xrefglossterm">切片和切块</span></a> ，将一个级别的聚合与另一个级别的聚合进行比较。例如，查询可能会找到2002年1月份杂货部门的销售情况，并将它们与2001年全年的杂货部门的总销售额进行比较。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8243"></a><div class="props_rev_3"><a id="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" name="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D"></a><h4 id="DWHSG-GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" class="sect4"><span class="enumeration_section">6.2.3</span>对物化视图进行分区的好处</h4>
                  <div>
                     <p>具有多个聚合组的物化视图在适当分区时为刷新和查询重写提供最佳性能。</p>
                     <p>滚动窗口场景中的PCT刷新需要在时间维度的某个级别上进行顶级分区。并且，针对此物化视图重写的查询的分区修剪需要在<code class="codeph">GROUPING_ID</code>列上进行分区。因此，这些物化视图的最有效分区方案是使用复合分区（（ <code class="codeph">time</code> ， <code class="codeph">GROUPING_ID</code> ）列上的范围列表）。通过以这种方式对实例化视图进行分区，您可以启用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>PCT刷新，从而提高刷新性能。</p>
                        </li>
                        <li>
                           <p>分区修剪：只访问相关的聚合组，从而大大降低了查询处理成本。</p>
                        </li>
                     </ul>
                     <p>如果您不想使用PCT刷新，则可以在<code class="codeph">GROUPING_ID</code>列上按列表进行分区。
                     </p>
                  </div>
               </div><a id="DWHSG8244"></a><div class="props_rev_3"><a id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" name="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444"></a><h4 id="DWHSG-GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" class="sect4"><span class="enumeration_section">6.2.4</span>关于压缩物化视图</h4>
                  <div>
                     <p>使用高度冗余数据时应考虑数据压缩，例如具有许多外键的表。特别是，使用<code class="codeph">ROLLUP</code>子句创建的物化视图可能是候选者。
                     </p>
                     <div class="infoboxnotealso" id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444__GUID-D26EC127-092A-4EA1-A934-D93A63CA2951">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/ALTER-MATERIALIZED-VIEW.html#SQLRF52876" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>用于数据压缩语法和限制</p>
                           </li>
                           <li>
                              <p>有关压缩的详细信息，请参阅<span class="q">“ <a href="basic-materialized-views.html#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">关于物化视图的存储和表压缩</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8245"></a><div class="props_rev_3"><a id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" name="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39"></a><h4 id="DWHSG-GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" class="sect4"><span class="enumeration_section">6.2.5</span>关于具有集合运算符的物化视图</h4>
                  <div>
                     <p>Oracle数据库提供支持<a id="d25854e1136" class="indexterm-anchor"></a><a id="d25854e1140" class="indexterm-anchor"></a>物化视图，其定义查询涉及集合运算符。现在可以为查询重写启用具有集合运算符的物化视图。您可以使用<code class="codeph">ON</code> <code class="codeph">COMMIT</code>或<code class="codeph">ON</code> <code class="codeph">DEMAND</code>刷新刷新物化视图。
                     </p>
                     <p>如果定义查询具有支持快速刷新<code class="codeph">UNION</code> <code class="codeph">ALL</code>在在顶级运营商和每个查询块<code class="codeph">UNION</code> <code class="codeph">ALL</code> ，满足物化视图的要求与骨料或物化视图只联接。此外，物化视图必须包含一个常量列（称为<code class="codeph">UNION</code> <code class="codeph">ALL</code>标记），该列在每个查询块中具有不同的值，在下面的示例中，该列是第<code class="codeph">1 marker</code>列<code class="codeph">1 marker</code>和第<code class="codeph">2 marker</code>列<code class="codeph">2 marker</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39__GUID-B5D588FD-4A69-47CE-984B-DAEDF545DA81">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="basic-materialized-views.html#GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6">在与UNION ALL物化视图快速刷新的限制</a></span>用于与物化视图的快速刷新的详细限制<span class="q">”</span> <code class="codeph">UNION</code> <code class="codeph">ALL</code> 。</p>
                     </div>
                  </div><a id="DWHSG8247"></a><a id="DWHSG8248"></a><a id="DWHSG8246"></a><div class="props_rev_3"><a id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" name="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E"></a><h5 id="DWHSG-GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" class="sect5"><span class="enumeration_section">6.2.5.1</span>使用UNION ALL的物化视图示例</h5>
                     <div>
                        <div class="section">
                           <p>以下示例说明了如何创建涉及<code class="codeph">UNION</code> <code class="codeph">ALL</code>的快速可刷新的物化视图。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-0AAA7B44-0790-4B59-98E4-5D47DC0BC6B1">
                           <p class="titleinexample">示例6-5使用具有两个连接视图的UNION ALL的物化视图</p>
                           <p>要创建具有两个连接视图的<code class="codeph">UNION</code> <code class="codeph">ALL</code>化视图，实例化视图日志必须具有rowid列，并且在以下示例中， <code class="codeph">UNION</code> <code class="codeph">ALL</code>标记是列， <code class="codeph">1 marker</code>和<code class="codeph">2 marker</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">使用ROWID创建物料化视图登录销售;使用ROWID创建物料化视图登录客户; CREATE MATERIALIZED VIEW unionall_sales_cust_joins_mv REFRESH FAST ON COMMIT ENABLE QUERY REWRITE AS（选择c.rowid crid，s.rowid srid，c.cust_id，s.amount_sold，1个标记FROM sales s，customers c WHERE s.cust_id = c.cust_id AND c .cust_last_name ='Smith'）UNION ALL（SELECT c.rowid crid，s.rowid srid，c.cust_id，s.amount_sold，2 marker FROM sales s，customers c WHERE s.cust_id = c.cust_id AND c.cust_last_name = '棕色'）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-CE59DA03-7059-4C7B-A5E4-25C2341C64DC">
                           <p class="titleinexample">示例6-6使用带有连接和聚合的UNION ALL的物化视图</p>
                           <p>以下示例显示了具有连接的物化视图的<code class="codeph">UNION</code> <code class="codeph">ALL</code>和具有聚合的物化视图。在这个例子中可以注意到几件事。可以使用Null或常量来确保相应<code class="codeph">SELECT</code>列列的数据类型匹配。此外， <code class="codeph">UNION</code> <code class="codeph">ALL</code>标记列可以是字符串文字，在以下示例中为<code class="codeph">'Year' umarker</code> ， <code class="codeph">'Quarter' umarker</code>或<code class="codeph">'Daily' umarker</code> ：</p><pre class="oac_no_warn" dir="ltr">使用ROWID，SEQUENCE（amount_sold，time_id）创建物料化视图登录销售包括新值;使用ROWID，SEQUENCE（time_id，fiscal_year，fiscal_quarter_number，day_number_in_week）创建物料化视图日志包括新值; CREATE MATERIALIZED VIEW unionall_sales_mix_mv REFRESH FAST ON DEMAND AS（选择'年'umarker，NULL，NULL，t.fiscal_year，SUM（s.amount_sold）amt，COUNT（s.amount_sold），COUNT（*）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.fiscal_year）UNION ALL（选择'Quarter'umarker，NULL，NULL，t.fiscal_quarter_number，SUM（s.amount_sold）amt，COUNT（s.amount_sold），COUNT（*）FROM sales s，times t WHERE s.time_id = t.time_id and t.fiscal_year = 2001 GROUP BY t.fiscal_quarter_number）UNION ALL（选择'Daily'umarker，s.rowid rid，t.rowid rid2，t.day_number_in_week，s。 amount_sold amt，1,1 FROM sales s，times t WHERE s.time_id = t.time_id AND t.time_id介于'01 -Jan-01'和'01 -Dec-31'）之间;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8249"></a><div class="props_rev_3"><a id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" name="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A"></a><h3 id="DWHSG-GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" class="sect3"><span class="enumeration_section">6.3</span>关于物化视图和模型</h3>
               <div>
                  <p>在SQL中提供基于数组的计算的模型可以在物化视图中使用。因为<code class="codeph">MODEL</code>子句计算可能很昂贵，所以您可能希望使用两个单独的物化视图：一个用于模型计算，一个用于<code class="codeph">SELECT</code> ...<code class="codeph">GROUP</code> <code class="codeph">BY</code>查询。例如，您可以创建以下物化视图，而不是使用一个长物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW my_groupby_mv REFRESH FAST ENABLE QUERY REWRITE AS SELECT country_name country，prod_name prod，calendar_year year，SUM（amount_sold）sale，COUNT（amount_sold）cnt，COUNT（*）cntstr FROM sales，times，customers，countries，products WHERE sales。 time_id = times.time_id AND sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY country_name，prod_name，calendar_year; CREATE MATERIALIZED VIEW my_model_mv ENABLE QUERY REWRITE AS SELECT country，prod，year，sale，cnt FROM my_groupby_mv MODEL PARTITION BY（country）DIMENSION BY（prod，year）MEASURES（sale s）IGNORE NAV（s ['Shorts'，2000] = 0.2 * AVG（CV（），1996年和1999年之间的年份]，s ['Kids Pajama'，2000] = 0.5 * AVG（s）（CV（），1995年和1999年之间的年份]，s ['男孩Pajama'，2000] = 0.6 * AVG（s）[CV（），1994年和1999年之间的年份]，......&lt;数百个其他更新规则&gt;）;</pre><p>通过使用两个物化视图，您可以增量维护物化视图<code class="codeph">my_groupby_mv</code> 。物化视图<code class="codeph">my_model_mv</code>位于一个小得多的数据集上，因为它建立在<code class="codeph">my_groupby_mv</code> ，可以通过完全刷新来维护。
                  </p>
                  <p>具有模型的物化视图可以仅使用完全刷新或PCT刷新，并且仅可用于部分文本查询重写。</p>
                  <div class="infoboxnotealso" id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A__GUID-A8CBF5AB-82C5-4793-BF59-F7C8E7C4F82B">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a>有关模型计算的更多详细信息</p>
                  </div>
               </div>
            </div><a id="DWHSG8251"></a><div class="props_rev_3"><a id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" name="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91"></a><h3 id="DWHSG-GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" class="sect3"><span class="enumeration_section">6.4</span>关于物化视图的安全问题</h3>
               <div>
                  <p><a id="d25854e1363" class="indexterm-anchor"></a>创建一个<a id="d25854e1368" class="indexterm-anchor"></a>在您自己的模式中的物化视图中，您必须具有<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>特权以及对另一个模式中引用的任何表的<code class="codeph">SELECT</code>或<code class="codeph">READ</code>特权。要在另一个模式中<code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">VIEW</code> ，您必须具有<code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>特权，并且<code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>的所有者需要对所引用的表具有<code class="codeph">SELECT</code>或<code class="codeph">READ</code>权限（如果它们来自其他模式）。此外，如果在引用模式外部表的实例化视图上启用查询重写，则必须对模式外的每个表具有<code class="codeph">GLOBAL</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>特权或<code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>对象特权。
                  </p>
                  <p>如果物化视图位于预构建容器上，则创建者（如果与所有者不同）必须在容器表上具有<code class="codeph">READ WITH GRANT</code>或<code class="codeph">SELECT</code> <code class="codeph">WITH</code> <code class="codeph">GRANT</code>权限。
                  </p>
                  <p>如果在尝试创建实例化视图时继续获得权限错误并且您认为已授予所有必需权限，则问题很可能是由于未明确授予权限并尝试从角色继承权限代替。如果表位于不同的模式中，则物化视图的所有者必须已明确授予对引用表的<code class="codeph">SELECT</code>或<code class="codeph">READ</code>访问权限。
                  </p>
                  <p>如果使用指定的<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>创建实例化视图，则如果定义查询中的任何表都在所有者架构之外，则实例化视图的所有者需要额外的权限。在这种情况下，所有者在所有者架构之外的每个表上都需要<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>系统特权或<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>对象特权。
                  </p>
                  <div class="infoboxnotealso" id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91__GUID-1F2568A6-4F99-40D4-9C11-24AE6998C303">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="advanced-materialized-views.html#GUID-B0671C37-8287-46D6-A3D9-236DC7917775">使用虚拟专用数据库（VPD）查询物化视图</a></p>
                  </div>
               </div><a id="DWHSG8252"></a><div class="props_rev_3"><a id="GUID-B0671C37-8287-46D6-A3D9-236DC7917775" name="GUID-B0671C37-8287-46D6-A3D9-236DC7917775"></a><h4 id="DWHSG-GUID-B0671C37-8287-46D6-A3D9-236DC7917775" class="sect4"><span class="enumeration_section">6.4.1</span>使用虚拟专用数据库（VPD）查询物化视图</h4>
                  <div>
                     <p>对于所有安全问题，物化视图用作直接查询物化视图时实际显示的视图。创建视图或物化视图时，所有者必须具有访问他们正在创建的视图或物化视图的基础基础关系的必要权限。使用这些权限，所有者可以发布其他用户可以访问的视图或物化视图，前提是他们已被授予对视图或物化视图的访问权限。</p>
                     <p>使用虚拟专用数据库的物化视图是类似的。创建实例化视图时，对于实例化视图所有者的实例化视图的基本关系，不得有任何VPD策略生效。如果存在任何VPD策略，则在创建<code class="codeph">USING TRUSTED CONSTRAINTS</code>化视图时必须使用<code class="codeph">USING TRUSTED CONSTRAINTS</code>子句。物化视图的所有者可以在新物化视图上建立VPD策略。访问实体化视图的用户必须遵守物化视图上的VPD策略。但是，它们不另外受制于物化视图的基础基础关系的VPD策略，因为对物化视图的所有者执行基础基础关系的安全处理。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE">使用查询重写与虚拟专用数据库</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034">物化视图和虚拟专用数据库的限制</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8253"></a><div class="props_rev_3"><a id="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" name="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE"></a><h5 id="DWHSG-GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" class="sect5"><span class="enumeration_section">6.4.1.1</span>使用虚拟专用数据库重写查询</h5>
                     <div>
                        <p>当你<a id="d25854e1550" class="indexterm-anchor"></a>使用查询重写访问物化视图，物化视图充当访问结构，就像索引一样。因此，以这种方式访问的物化视图的安全隐患与索引非常相似：所有安全检查都是针对请求查询中指定的关系执行的。索引或物化视图用于加快访问数据的性能，不提供任何额外的安全检查。因此，索引或物化视图的存在不会提供额外的安全检查。
                        </p>
                        <p>当您在VPD存在的情况下使用查询重写访问实体化视图时，这也适用。请求查询受到针对查询中指定的关系存在的任何VPD策略的约束。查询重写可能会重写查询以使用实体化视图而不是访问详细信息关系，但前提是它可以保证提供完全相同的行，就像没有发生重写一样。具体而言，查询重写必须保留并遵守针对请求查询中指定的关系的任何VPD策略。但是，当使用查询重写访问实例化视图时，针对实体化视图本身的任何VPD策略都不起作用。这是因为VPD策略已经针对请求查询中的关系保护了数据。</p>
                     </div>
                  </div><a id="DWHSG8254"></a><div class="props_rev_3"><a id="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" name="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034"></a><h5 id="DWHSG-GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" class="sect5"><span class="enumeration_section">6.4.1.2</span>物化视图和虚拟专用数据库的限制</h5>
                     <div>
                        <div class="section">
                           <p>询问<a id="d25854e1580" class="indexterm-anchor"></a> rewrite不会将其完整和部分文本匹配模式与包含与活动VPD策略的关系的请求查询一起使用，但它确实使用了一般的重写方法。这是因为VPD透明地转换请求查询以影响VPD策略。如果查询重写是针对具有VPD策略的请求查询执行文本匹配转换，则效果将取消VPD策略。
                           </p>
                           <p>此外，在创建或刷新实例化视图时，实例化视图的所有者必须不具有对实例化视图的基本关系有效的任何活动VPD策略，否则将返回错误。物化视图所有者必须要么没有此类VPD策略，要么任何此类策略必须返回<code class="codeph">NULL</code> 。这是因为VPD将透明地修改实体化视图的定义查询，使得实体化视图包含的行集与实例化视图定义所指示的行集不匹配。
                           </p>
                           <p>解决此限制但仍然创建包含所需VPD指定的行子集的物化视图的一种方法是在用户帐户中创建物化视图，该用户帐户没有针对实例化视图的详细关系的活动VPD策略。此外，您可以在物化视图的<code class="codeph">WHERE</code>子句中包含谓词，该谓词体现了VPD策略的效果。当查询重写尝试重写具有该VPD策略的请求查询时，它会将请求查询上的VPD生成的谓词与您在创建实例化视图时直接指定的谓词进行匹配。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8250"></a><div class="props_rev_3"><a id="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" name="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF"></a><h3 id="DWHSG-GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" class="sect3"><span class="enumeration_section">6.5使</span>实体化视图无效</h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1617" class="indexterm-anchor"></a><a id="d25854e1621" class="indexterm-anchor"></a>自动维护与物化视图相关的依赖关系以确保正确操作。创建实例化视图时，实例化视图取决于其定义中引用的详细信息表。对物化视图中的任何依赖项<code class="codeph">INSERT</code>任何DML操作（如<code class="codeph">INSERT</code>或<code class="codeph">DELETE</code> ， <code class="codeph">UPDATE</code>或DDL操作）都将导致其无效。要重新验证实例化视图，请使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">COMPILE</code>语句。
                     </p>
                     <p>物化视图在引用时会自动重新生效。在许多情况下，物化视图将成功且透明地重新验证。但是，如果已在实例化视图引用的表中删除列，或者实例化视图的所有者没有查询重写权限之一，并且该权限现已授予所有者，则应使用以下语句重新验证物化视图：</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW mview_name COMPILE;</pre><p>可以通过查询数据字典视图<code class="codeph">USER_MVIEWS</code>或<code class="codeph">ALL_MVIEWS</code>来检查<code class="codeph">USER_MVIEWS</code>视图的<code class="codeph">ALL_MVIEWS</code> 。 <code class="codeph">STALENESS</code>列将显示<code class="codeph">FRESH</code> ， <code class="codeph">STALE</code> ， <code class="codeph">UNUSABLE</code> ， <code class="codeph">UNKNOWN</code> ， <code class="codeph">UNDEFINED</code>或<code class="codeph">NEEDS_COMPILE</code>以指示是否可以使用物化视图。状态自动维护。但是，如果物化视图的<code class="codeph">NEEDS_COMPILE</code>标记为<code class="codeph">NEEDS_COMPILE</code> ，则可以发出<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ...<code class="codeph">COMPILE</code>语句，用于验证物化视图并获取正确的过期状态。如果一个物化视图的状态为<code class="codeph">UNUSABLE</code> ，你必须执行完整的刷新带来的物化视图回<code class="codeph">FRESH</code>状态。如果物化视图基于您永远不会刷新的预构建表，则必须删除并重新创建物化视图。不跟踪远程物化视图的陈旧性。因此，如果使用远程物化视图进行重写，则认为它们是可信的。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8255"></a><div class="props_rev_3"><a id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" name="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E"></a><h3 id="DWHSG-GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" class="sect3"><span class="enumeration_section">6.6</span>改变物化观点</h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1727" class="indexterm-anchor"></a>可以对物化视图进行以下修改：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>更改其刷新选项（ <code class="codeph">FAST/FORCE/COMPLETE/NEVER</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>更改其刷新模式（ <code class="codeph">ON</code> <code class="codeph">COMMIT/ON</code> <code class="codeph">DEMAND</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>重新编译它。</p>
                        </li>
                        <li>
                           <p>启用或禁用其用于查询重写。</p>
                        </li>
                        <li>
                           <p>考虑一下新鲜感。</p>
                        </li>
                        <li>
                           <p>分区维护操作。</p>
                        </li>
                        <li>
                           <p>启用查询计算</p>
                        </li>
                     </ul>
                     <p>通过删除然后重新创建物化视图来实现所有其他更改。修改操作的成功取决于是否满足变更要求。例如，如果所有基表上都存在物化视图日志，则快速刷新会成功。</p>
                     <p>当物化视图失效时，可以使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>语句的<code class="codeph">COMPILE</code>子句。此编译过程很快，并允许再次使用查询重写来使用实例化视图。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E__GUID-FE37E5E9-CD02-4786-BA38-AE9F48C02595">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>语句的更多信息，请<a href="../sqlrf/SQL-Statements-ALTER-LIBRARY-to-ALTER-SESSION.html#SQLRF009" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“使<a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">实体化视图无效</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0702359B-D379-4299-86C4-2958BCD4381D" name="GUID-0702359B-D379-4299-86C4-2958BCD4381D"></a><h3 id="DWHSG-GUID-0702359B-D379-4299-86C4-2958BCD4381D" class="sect3"><span class="enumeration_section">6.7</span>使用实时物化视图</h3>
               <div>
                  <p>即使物化视图标记为陈旧，实时物化视图也会为用户查询提供新数据。</p>
                  <div class="infoboxnotealso" id="GUID-0702359B-D379-4299-86C4-2958BCD4381D__GUID-5884C45D-BD87-448E-AED6-E780C02360AD">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" title="实时物化视图是一种物化视图，即使物化视图由于数据更改而与其基表不同步，也可为用户查询提供新数据。">实时物化视图概述</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" title="要创建实时物化视图，请使用CREATE MATERIALIZED VIEW语句中的ON QUERY COMPUTATION子句。">创建实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" title="如果满足实时物化视图的先决条件，则可以通过更改其定义并启用查询计算，将现有物化视图转换为实时物化视图。">将现有物化视图转换为实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" title="对于重写用户查询以使用实时物化视图的查询重写机制，必须为实时物化视图启用查询重写。">启用查询重写以使用实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。">在查询重写期间使用实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。">使用实时物化视图进行直接查询访问</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-84838620-20F6-4929-85BD-FCB2D9603710" title="数据字典视图中的ON_QUERY_COMPUTATION列ALL_MVIEWS，DBA_MVIEWS和USER_MVIEWS指示实例化视图是否是实时物化视图。">列出实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" title="要为使用实时物化视图的用户查询获得更好的性能，您可以遵循某些准则。">提高实时物化视图的性能</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" name="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E"></a><h4 id="DWHSG-GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" class="sect4"><span class="enumeration_section">6.7.1</span>实时物化视图概述</h4>
                  <div>
                     <p>实时物化视图是一种物化视图，即使物化视图由于数据更改而与其基表不同步，也可为用户查询提供新数据。</p>
                     <p>除非将SQL会话设置为过期容忍模式，否则标记为过时的实例化视图不能用于查询重写。需要实时数据的组织通常使用<code class="codeph">ON COMMIT</code>刷新模式，以确保通过对基表所做的更改来更新<code class="codeph">ON COMMIT</code>化视图。但是，当DML对基表的更改非常频繁且非常频繁时，此模式可能会导致资源争用并降低刷新性能。实时物化视图提供了一种轻量级解决方案，可通过动态重新计算数据从过时的物化视图中获取新数据。
                     </p>
                     <p>实时物化视图可以使用任何可用的非现场刷新方法，包括基于日志或基于PCT的刷新。它们可以按需使用或按计划自动刷新使用，但不能使用<code class="codeph">ON COMMIT</code>子句指定的自动刷新。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-7BF29E2F-BE91-44CD-B756-77D8C564D819">实时物化视图的优点</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>为物化视图提供改进的可用性</p>
                           </li>
                           <li>
                              <p>为访问可能过时的物化视图的用户查询提供新数据</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-3A57CD0F-6878-4803-A912-F175BA445E66">实时物化视图如何工作？</p>
                        <p>实时物化视图使用称为<span class="italic">查询计算</span>的技术来提供具有陈旧物化视图的新数据。当查询访问实时物化视图时，Oracle数据库首先检查实时物化视图是否标记为陈旧。如果它不是陈旧的，则使用实时物化视图原样提供所需数据。如果将实时物化视图标记为陈旧，则使用查询计算技术生成新数据并返回正确的查询结果。
                        </p>
                        <p>实时物化视图使用类似基于日志的刷新技术，以提供具有陈旧物化视图的新数据。它们将现有数据与更改日志中记录的更改相结合，以获取最新数据。但是，与基于日志的刷新不同，实时物化视图不使用物化视图日志来更新实时物化视图中的数据。相反，当查询访问过时的实时物化视图时，使用查询计算重新计算的数据将直接用于回答查询。</p>
                        <p>通过在物化视图定义中使用<code class="codeph">ON QUERY COMPUTATION</code>子句创建实时物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" name="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA"></a><h5 id="DWHSG-GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" class="sect5"><span class="enumeration_section">6.7.1.1</span>使用实时物化视图的限制</h5>
                     <div>
                        <p>使用实时物化视图受到某些限制。</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在以下情况下无法使用实时物化视图：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在基表上创建的一个或多个物化视图日志不可用或不存在。</p>
                                 </li>
                                 <li>
                                    <p>对于更改方案，不可行的，基于日志的或PCT刷新是不可行的。</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">ON COMMIT</code>子句指定自动刷新。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果实时物化视图是在一个或多个基本物化视图之上定义的嵌套物化视图，则只有在所有基本物化视图都是新的时才会发生查询重写。如果一个或多个基本物化视图过时，则不使用此实时物化视图执行查询重写。</p>
                           </li>
                        </ul>
                        <p>不共享直接访问实时物化视图的查询的游标。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" name="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0"></a><h5 id="DWHSG-GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" class="sect5"><span class="enumeration_section">6.7.1.2</span>关于访问实时物化视图</h5>
                     <div>
                        <p>与物化视图一样，存在多种方法来访问存储在实时物化视图中的数据。</p>
                        <p></p>
                        <p>可以通过以下方式之一访问存储在实时物化视图中的数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查询重写</p>
                              <p>重写与实时物化视图定义类似的用户查询以使用实时物化视图。</p>
                           </li>
                           <li>
                              <p>直接访问实时物化视图</p>
                              <p>用户查询使用其名称直接引用实时物化视图。</p>
                           </li>
                        </ul>
                        <p>在这两种情况下，实时物化视图的内容可以作为陈旧数据访问，也可以触发正确结果的查询计算。是否触发查询计算取决于环境和实际的SQL语句。</p>
                        <p><code class="codeph">EXPLAIN PLAN</code>语句的输出包含指示查询计算是否用于特定用户查询的消息。
                        </p>
                        <div class="infoboxnotealso" id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0__GUID-35FE7EF7-6975-4FC2-9FCC-A76DB3984952">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。">使用实时物化视图进行直接查询访问</a></p>
                              </li>
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。">在查询重写期间使用实时物化视图</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" name="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92"></a><h4 id="DWHSG-GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" class="sect4"><span class="enumeration_section">6.7.2</span>创建实时物化视图</h4>
                  <div>
                     <p>要创建实时物化视图，请使用<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中的<code class="codeph">ON QUERY COMPUTATION</code>子句。
                     </p>
                     <div class="section">
                        <p>您可以创建实时物化视图，即使它们不适用于所有更改方案的查询计算。创建实时物化视图的最低要求是它支持<code class="codeph">INSERT</code>操作的非现场刷新。如果遇到其他更改方案（例如混合DML操作），则查询计算对于所有类型的实时物化视图可能都不可行。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>实时物化视图必须使用不合适的基于日志的刷新机制（包括PCT刷新）。<code class="codeph">ON COMMIT</code>刷新模式不能用于实时物化视图。
                        </p>
                        <p><span class="bold">要创建实时物化视图：</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>确保实时物化视图的所有基表上都存在物化视图日志。</span></li>
                        <li><span>为实时物化视图所基于的所有表创建物化视图日志。</span></li>
                        <li><span>通过在<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中包含<code class="codeph">ENABLE ON QUERY COMPUTATION</code>子句来创建实时物化视图。</span></li>
                     </ol>
                     <div class="example" id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92__GUID-31E0354C-A993-43AF-949B-961571DF5243">
                        <p class="titleinexample">示例6-7创建实时物化视图</p>
                        <p>此示例创建一个名为<code class="codeph">SUM_SALES_RTMV</code>的实时物化视图，该视图基于从<code class="codeph">SH</code>模式中的<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>表聚合的数据。在创建实时物化视图之前，请确保满足所需的先决条件。
                        </p>
                        <ol>
                           <li>
                              <p>在基表<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>上创建物化视图日志。</p>
                              <p>以下命令在<code class="codeph">SALES</code>表上创建<code class="codeph">SALES</code>化视图日志：</p><pre class="pre codeblock"><code>使用SEQUENCE，ROWID（prod_id，quantity_sold，amount_sold）创建物料化视图登录销售包括新价值;</code></pre><p>以下命令在<code class="codeph">PRODUCTS</code>表上创建实例化视图日志。
                              </p><pre class="pre codeblock"><code>使用ROWID创建物料化视图登录产品（prod_id，prod_name，prod_category，prod_subcategory）包括新值;</code></pre></li>
                           <li>
                              <p>通过在<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中包含<code class="codeph">ON QUERY COMPUTATION</code>子句来创建实时物化视图。快速刷新方法用于此实时物化视图， <code class="codeph">ENABLE QUERY REWRITE</code>子句指示必须启用查询重写。
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW sum_sales_rtmv REFRESH FAST ON DERMAND ENABLE QUERY REWRITE ENABLE QUERY COMPUTATION AS SELECT prod_name，SUM（quantity_sold）AS sum_qty，COUNT（quantity_sold）AS cnt_qty，SUM（amount_sold）AS sum_amt，COUNT（amount_sold）AS cnt_amt，COUNT（* ）AS cnt_star FROM sales，产品WHERE sales.prod_id = products.prod_id GROUP BY prod_name;</code></pre></li>
                        </ol>
                        <p>在创建<code class="codeph">SUM_SALES_RTMV</code>实时物化视图后，假定运行以下查询。
                        </p><pre class="pre codeblock"><code>SELECT prod_name，SUM（quantity_sold），SUM（amount_sold）FROM sales，products WHERE sales.prod_id = products.prod_id GROUP BY prod_name;</code></pre><p>如果<code class="codeph">SUM_SALES_RTMV</code>不是陈旧的，则使用存储在此实时物化视图中的数据返回查询结果。但是，如果<code class="codeph">SUM_SALES_RTMV</code>是陈旧的，并且使用具有查询计算的物化视图重写查询的成本低于基表访问，则通过组合<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>上的物化视图日志中的增量更改来回答查询。具有实时物化视图<code class="codeph">SUM_SALES_RTMV</code>的数据的表。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" name="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0"></a><h4 id="DWHSG-GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" class="sect4"><span class="enumeration_section">6.7.3</span>将现有物化视图转换为实时物化视图</h4>
                  <div>
                     <p>如果满足实时物化视图的先决条件，则可以通过更改其定义并启用查询计算，将现有物化视图转换为实时物化视图。</p>
                     <div class="section">
                        <p><span class="bold">要将物化视图转换为实时物化视图：</span> 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>通过使用<code class="codeph">ALTER MATERIALIZED VIEW</code>语句中的<code class="codeph">ON QUERY COMPUTATION</code>子句修改实例化视图定义并启用查询计算。</span></li>
                     </ul>
                     <div class="section">
                        <p>通过使用<code class="codeph">ALTER MATERIALIZED VIEW</code>语句中的<code class="codeph">DISABLE ON QUERY COMPUTATION</code>子句<code class="codeph">DISABLE ON QUERY COMPUTATION</code>查询计算，可以将实时物化视图转换为常规物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0__GUID-5DD6FF33-5D45-416B-946C-CA44A3772F37">
                        <p class="titleinexample">示例6-8将实体化视图转换为实时物化视图</p>
                        <p>物化视图<code class="codeph">SALES_RTMV</code>基于<code class="codeph">SALES</code> ， <code class="codeph">TIMES</code>和<code class="codeph">PRODUCTS</code>表，并使用快速刷新。物化视图日志存在于所有三个基表中。您想要修改此物化视图并将其转换为实时物化视图。
                        </p>
                        <ol>
                           <li>
                              <p>修改实例化视图定义并包含<code class="codeph">ON QUERY COMPUTATION</code>子句以将其更改为实时物化视图。
                              </p><pre class="pre codeblock"><code>ALTER MATERIALIZED VIEW sales_rtmv启用查询计算;</code></pre></li>
                           <li>
                              <p>查询<code class="codeph">DBA_MVIEWS</code>视图以确定是否为<code class="codeph">SALES_RTMV</code>启用了查询计算。</p><pre class="pre codeblock"><code><code class="codeph">SELECT mview_name, on_query_computation</code> <code class="codeph">FROM dba_mviews WHERE mview_name = 'SALES_RTMV';</code></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" name="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73"></a><h4 id="DWHSG-GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" class="sect4"><span class="enumeration_section">6.7.4</span>启用查询重写以使用实时物化视图</h4>
                  <div>
                     <p>对于重写用户查询以使用实时物化视图的查询重写机制，必须为实时物化视图启用查询重写。</p>
                     <div class="section">
                        <p>您可以通过修改实时物化视图的定义，在创建时或随后为实时物化视图启用查询重写。<code class="codeph">ENABLE QUERY REWRITE</code>子句用于启用查询重写。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>要为现有的实时物化视图启用查询重写，请执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>运行<code class="codeph">ALTER MATERIALIZED VIEW</code>命令并包含<code class="codeph">ENABLE QUERY REWRITE</code>子句。</span></li>
                     </ul>
                     <div class="example" id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73__GUID-38AD3618-6915-4945-93AE-EC59DBF517BC">
                        <p class="titleinexample">示例6-9为实时物化视图启用查询重写</p>
                        <p>实时物化视图<code class="codeph">my_rtmv</code>使用快速刷新机制。您希望修改此实时物化视图的定义，并指定查询重写机制在重写查询时必须考虑此实时物化视图。
                        </p>
                        <p>以下命令为<code class="codeph">my_rtmv</code>启用查询重写：</p><code class="codeph">ALTER MATERIALIZED VIEW my_rtmv ENABLE QUERY REWRITE;</code></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" name="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4"></a><h4 id="DWHSG-GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" class="sect4"><span class="enumeration_section">6.7.5</span>在查询重写期间使用实时物化视图</h4>
                  <div>
                     <p>如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。</p>
                     <div class="section">
                        <p>运行用户查询时，查询重写首先检查是否有新的实体化视图可用于提供所需数据。如果不存在合适的物化视图，则查询重写将查找可用于重写用户查询的实时物化视图。新的物化视图优于实时物化视图，因为在为实时物化视图计算新数据时会产生一些开销。接下来，基于成本的优化器使用查询计算确定SQL查询的成本，然后决定是否将使用实时物化视图来回答此用户查询。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>如果当前SQL会话的<code class="codeph">QUERY_REWRITE_INTEGRITY</code>模式设置为<code class="codeph">STALE_TOLERATED</code> ，则在查询重写期间不会使用查询计算。<code class="codeph">STALE_TOLERATED</code>重写模式表示不需要新的结果来满足查询，因此不需要查询计算。
                        </p>
                        <p><span class="bold">对于查询重写以使用实时物化视图：</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>确保<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式。<code class="codeph">QUERY_REWRITE_INTEGRITY</code>模式不应设置为<code class="codeph">STALE_TOLERATED</code>模式。</span></li>
                        <li class="stepexpand"><span>运行与用于定义实时物化视图的SQL查询匹配的用户查询。</span><div>
                              <p>任何可以重写以利用实时物化视图的查询都将使用具有查询计算的实时物化视图。</p>
                              <p>使用<code class="codeph">EXPLAIN PLAN</code>验证是否使用实时物化视图重写了查询。
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4__GUID-B4B383C0-0ACF-4E5E-B4EC-08DEBD4A43B1">
                        <p class="titleinexample">示例6-10在查询重写期间使用实时物化视图</p>
                        <p>此示例创建一个启用了查询重写的实时物化视图，然后演示查询重写使用它来为用户查询提供数据。</p>
                        <ol>
                           <li>
                              <p>在<code class="codeph">SALES</code>表上创建物化视图日志，该表是要创建的实时物化视图的基表。
                              </p>
                           </li>
                           <li>
                              <p>创建实时物化视图<code class="codeph">mav_sum_sales</code>并启用查询重写。
                              </p><pre class="pre codeblock"><code>创建物化视图mav_sum_sales快速启动需求快速启动查询计算启用QUERY REWRITE作为选择prod_id，sum（quantity_sold）作为sum_qty，count（quantity_sold）作为cnt_qty，sum（amount_sold）sum_amt，count（amount_sold）cnt_amt，count（*）as cnt_star FROM sales GROUP BY prod_id;</code></pre></li>
                           <li>
                              <p>运行以下查询：</p><pre class="pre codeblock"><code>SELECT prod_id，sum（quantity_sold），sum（amount_sold）FROM sales WHERE prod_id &lt;1000 GROUP BY prod_id;</code></pre><p>观察该查询类似于用于定义实时物化视图<code class="codeph">mav_sum_sales</code> 。由于不存在具有与查询类似的定义的其他物化视图，因此查询重写可以使用<code class="codeph">mav_sum_sales</code>实时物化视图来确定查询结果。您可以通过检查SQL游标缓存（例如，使用<code class="codeph">DBMS_XPLAN</code> ），使用SQL监视器或使用<code class="codeph">EXPLAIN PLAN</code>来验证是否已进行查询重写。</p>
                              <p>使用<code class="codeph">mav_sum_sales</code>的内部重写查询类似于以下语句：</p><pre class="pre codeblock"><code>SELECT prod_id，sum_qty，sum_amt FROM mav_sum_sales WHERE prod_id &lt;1000;</code></pre></li>
                           <li>
                              <p>验证是否使用实时物化视图来提供查询结果。使用<code class="codeph">EXPLAIN PLAN</code>语句查看查询的执行计划。
                              </p>
                              <p>以下执行计划显示了对实时物化视图的直接访问。如果物化视图过时，则执行计划将变得更加复杂，并且包括对其他对象的访问（例如，物化视图日志），具体取决于未完成的DML操作。</p><pre class="pre codeblock"><code>EXPLAIN PLAN for SELECT prod_id，sum（quantity_sold），sum（amount_sold）FROM sales WHERE prod_id &lt;1000 GROUP BY prod_id; SELECT plan_table_output FROM table（dbms_xplan.display（'plan_table'，null，'serial'））; PLAN_TABLE_OUTPUT ------------------------------------------------- ----------------------------------------------计划哈希值： 13616844 ------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | 92 | 3588 | 3（0）| 00:00:01 | | * 1 | MAT_VIEW ACCESS FULL | MAV_SUM_SALES | 92 | 3588 | 3（0）| 00:00:01 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 1  - 过滤器（“PROD_ID”&lt;1000）注-----  - 使用动态统计：动态采样（level = 2）选择17行。</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" name="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E"></a><h4 id="DWHSG-GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" class="sect4"><span class="enumeration_section">6.7.6</span>使用实时物化视图进行直接查询访问</h4>
                  <div>
                     <p>您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。</p>
                     <div class="section">
                        <p>如果用户查询中指定的实时物化视图是新鲜的，则直接从实时物化视图中提取所需数据。如果实时物化视图过时，则必须使用<code class="codeph">FRESH_MV</code>提示执行查询计算并获取新数据。Oracle数据库不会自动对在用户查询中直接访问的实时物化视图执行查询计算。
                        </p>
                        <p>在直接访问实时物化视图时，从陈旧的实时物化视图中获取新数据：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>在用户查询中使用<code class="codeph">FRESH_MV</code>提示指示必须执行查询计算。</span></li>
                     </ul>
                     <div class="example" id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E__GUID-6D715D37-9A73-4C5C-8AA7-5EC1892DA477">
                        <p class="titleinexample">示例6-11创建实时物化视图并在查询中使用它</p>
                        <p>此示例创建基于<code class="codeph">SALES_NEW</code>表的实时物化视图<code class="codeph">MY_RTMV</code> 。<code class="codeph">SALES_NEW</code>表创建为<code class="codeph">SH.SALES</code>表的副本。创建实时物化视图后，将在行表中插入一行。接下来， <code class="codeph">fresh_mv</code>提示用于通过在用户查询中使用实体化视图名称从实时物化视图访问新数据。
                        </p>
                        <ol>
                           <li>
                              <p>在基表<code class="codeph">sales_new</code>上创建物化视图日志。
                              </p>
                              <p>基表上的物化视图日志对于创建实时物化视图是必需的。</p><pre class="pre codeblock"><code>在sales_new上创建MATERIALIZED VIEW LOG WITH sequence，ROWID（prod_id，cust_id，time_id，channel_id，promo_id，quantity_sold，amount_sold）包括新值;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">sales_new</code>作为基表创建名为<code class="codeph">my_rtmv</code>的实时物化视图。
                              </p>
                              <p><code class="codeph">ON QUERY COMPUTATION</code>子句指示创建实时物化视图。指定的刷新模式是基于日志的快速刷新。为实时物化视图启用了查询重写。
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW my_rtmv REFRESH快速启用查询计算启用QUERY REWRITE作为SELECT prod_id，cust_id，channel_id，sum（quantity_sold）sum_q，count（quantity_sold）cnt_q，avg（quantity_sold）avg_q，sum（amount_sold）sum_a，count（amount_sold）cnt_a ，avg（amount_sold）avg_a FROM sales_new GROUP BY prod_id，cust_id，channel_id;</code></pre></li>
                           <li>
                              <p>在<code class="codeph">sales_new</code>插入一行，即实时物化视图的基表并提交此更改。
                              </p><pre class="pre codeblock"><code>INSERT INTO sales_new（prod_id，cust_id，time_id，channel_id，promo_id，quantity_sold，amount_sold）VALUES（116,100450，sysdate，9,9999,10,350）;承诺;</code></pre></li>
                           <li>
                              <p>直接查询实时物化视图，以显示在上一步中添加到实时物化视图基表的行的数据。</p><pre class="pre codeblock"><code>SELECT * from my_rtmv WHERE prod_id = 116 AND cust_id = 100450 AND channel_id = 9; PROD_ID CUST_ID CHANNEL_ID SUM_Q CNT_Q AVG_Q SUM_A CNT_A AVG_A ------- ------- ---------- ----- ----- -----  - --- ----- ------ 116 100450 9 1 1 1 11.99 1 11.99</code></pre><p>请注意，查询结果不会显示此数据的更新值。这是因为实时物化视图尚未通过对其基表所做的更改进行刷新。</p>
                           </li>
                           <li>
                              <p>在查询实时物化视图时包括<code class="codeph">FRESH_MV</code>提示，以显示基表中更新的行。
                              </p><pre class="pre codeblock"><code>SELECT / * + fresh_mv * / * FROM my_rtmv WHERE prod_id = 116 AND cust_id = 100450 AND channel_id = 9; PROD_ID CUST_ID CHANNEL_ID SUM_Q CNT_Q AVG_Q SUM_A CNT_A AVG_A ------- ------- ---------- ----- ----- -----  - --- ----- ------ 116 100450 9 11 2 5.5 361.99 2 180.995</code></pre><p>请注意，这次显示更新的行。这是因为<code class="codeph">FRESH_MV</code>提示触发实时物化视图的查询计算并重新计算新数据。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-84838620-20F6-4929-85BD-FCB2D9603710" name="GUID-84838620-20F6-4929-85BD-FCB2D9603710"></a><h4 id="DWHSG-GUID-84838620-20F6-4929-85BD-FCB2D9603710" class="sect4"><span class="enumeration_section">6.7.7</span>列出实时物化视图</h4>
                  <div>
                     <p>数据字典视图中的<code class="codeph">ON_QUERY_COMPUTATION</code>列<code class="codeph">ALL_MVIEWS</code> ， <code class="codeph">DBA_MVIEWS</code>和<code class="codeph">USER_MVIEWS</code>指示<code class="codeph">USER_MVIEWS</code>化视图是否是实时物化视图。
                     </p>
                     <div class="section">
                        <p><code class="codeph">ON_QUERY_COMPUTATION</code>列中的Y值表示实时物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">要列出用户架构中的所有实时物化视图：</div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>查询<code class="codeph">USER_MVIEWS</code>视图并显示<code class="codeph">USER_MVIEWS</code>视图的详细信息，并将<code class="codeph">ON_QUERY_COMPUTATION</code>列设置为Y.</span></li>
                     </ul>
                     <div class="example" id="GUID-84838620-20F6-4929-85BD-FCB2D9603710__GUID-3E8E705C-34BC-4668-9B9E-9CDD71FD5227">
                        <p class="titleinexample">示例6-12列出当前用户架构中的实时物化视图</p><pre class="pre codeblock"><code>SELECT owner，mview_name，rewrite_enabled，staleness FROM user_mviews WHERE on_query_computation ='Y'; OWNER MVIEW_NAME REWRITE_ENABLED STALENESS ------ ------------ ------------------- --------- --- SH SALES_RTMV N FRESH SH MAV_SUM_SALES Y FRESH SH MY_SUM_SALES_RTMV Y FRESH SH NEW_SALES_RTMV Y STALE</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" name="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5"></a><h4 id="DWHSG-GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" class="sect4"><span class="enumeration_section">6.7.8</span>提高实时物化视图的性能</h4>
                  <div>
                     <p>要为使用实时物化视图的用户查询获得更好的性能，您可以遵循某些准则。</p>
                     <p></p>
                     <p>使用以下指南和实时物化视图：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>经常刷新实时物化视图以增强可能使用这些实时物化视图的查询的性能。</p>
                           <p>由于实时物化视图通过将基础表的增量更改与现有物化视图数据相结合来工作，因此当要计算的增量变化很小时，查询响应时间会增强。通过更加出色的DML操作，查询计算可能变得更加复杂（并且成本高昂），直到基本表访问变得更加高效（在查询重写的情况下）。</p>
                        </li>
                        <li>
                           <p>收集基表，实时物化视图和物化视图日志的统计信息，以使优化器能够准确地确定查询的成本。</p>
                           <p>对于查询重写，基于成本的重写机制使用优化器来确定是否应该使用重写的查询。优化程序使用统计信息来确定成本。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="05777.understanding-source-objects.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>了解源对象</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java API Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java API Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="olap-java-api-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T13:53:39-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2000, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96402-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="creating-metadata-and-analytic-workspaces.html" title="Previous" type="text/html"></link>
      <link rel="next" href="making-queries-using-source-methods.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="OLAP Java API Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="OLAAP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="creating-metadata-and-analytic-workspaces.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="making-queries-using-source-methods.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java API开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">了解源对象</li>
            </ol>
            <a id="GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2" name="GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2"></a><a id="OLAAP247"></a>
            
            <h2 id="OLAAP-GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2" class="sect2"><span class="enumeration_chapter">5</span>了解源对象</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍用于指定查询的<code class="codeph">Source</code>对象。使用<code class="codeph">Source</code> ，您可以指定要从数据存储中检索的数据以及要对数据执行的分析或其他操作。 <a href="making-queries-using-source-methods.html#GUID-B5D5AF5D-330E-46D3-8BD7-E84B1373E6A7"> 使用源方法进行查询</a> ，提供了使用<code class="codeph">Source</code>对象的示例。 <a href="creating-dynamic-queries.html#GUID-16DC09F2-FA92-4987-A125-2EE813B7413E"> 创建动态查询</a> ，描述使用<code class="codeph">Template</code>对象进行可修改的查询。
               </p>
               <p>本章包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="understanding-source-objects.html#GUID-816E6FBC-B0ED-4109-A0A4-34E8FBBE3332">源对象概述</a></p>
                  </li>
                  <li>
                     <p><a href="understanding-source-objects.html#GUID-26FAD107-7192-41FA-AAE2-066949993CEB">各种源对象</a></p>
                  </li>
                  <li>
                     <p><a href="understanding-source-objects.html#GUID-0604D759-310C-43F9-9111-29739F022A2C">源对象的特征</a></p>
                  </li>
                  <li>
                     <p><a href="understanding-source-objects.html#GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240">输入和输出的来源</a></p>
                  </li>
                  <li>
                     <p><a href="understanding-source-objects.html#GUID-38CC13B9-38A3-4D0A-87B7-13A5BFC2EB6E">描述参数化源对象</a></p>
                  </li>
               </ul>
            </div><a id="OLAAP248"></a><div class="props_rev_3"><a id="GUID-816E6FBC-B0ED-4109-A0A4-34E8FBBE3332" name="GUID-816E6FBC-B0ED-4109-A0A4-34E8FBBE3332"></a><h3 id="OLAAP-GUID-816E6FBC-B0ED-4109-A0A4-34E8FBBE3332" class="sect3"><span class="enumeration_section">5.1</span>源对象概述</h3>
               <div>
                  <p><a id="d13320e118" class="indexterm-anchor"></a><a id="d13320e122" class="indexterm-anchor"></a><a id="d13320e126" class="indexterm-anchor"></a>您使用<code class="codeph">Source</code>对象创建一个查询，指定要从数据库中检索的数据。作为查询， <code class="codeph">Source</code>类似于SQL <code class="codeph">SELECT</code>语句。
                  </p>
                  <p>要创建查询，通常使用<code class="codeph">oracle.olapi.metadata.mdm</code>包中的类来获取表示OLAP元数据对象的<code class="codeph">MdmSource</code>对象。从<code class="codeph">MdmSource</code>对象，您可以获取<code class="codeph">Source</code>对象。您还可以使用<code class="codeph">DataProvider</code>方法创建其他类型的<code class="codeph">Source</code>对象。然后，您可以使用这些<code class="codeph">Source</code>对象来创建查询。要检索查询指定的数据，请为<code class="codeph">Source</code>创建<code class="codeph">Cursor</code> 。
                  </p>
                  <p>使用<code class="codeph">Source</code>的方法，您可以指定维度成员，属性值或度量值的选择。您也可以在的元素指定的操作<code class="codeph">Source</code> ，比如数学计算，比较和排序，添加或删除查询的元素。
                  </p>
                  <p><a id="d13320e179" class="indexterm-anchor"></a> <code class="codeph">Source</code>类有一些基本方法和许多使用一种或多种基本方法的快捷方法。最复杂的基本方法是<code class="codeph">join(Source joined, Source comparison, int comparisonRule, boolean visible)</code>方法和<code class="codeph">recursiveJoin(Source joined, Source compariso4n, Source parent, int comparisonRule, boolean parentsFirst, boolean parentsRestrictedToBase, int maxIterations, boolean visible)</code>方法。<code class="codeph">join</code>和<code class="codeph">recursiveJoin</code>方法的许多其他签名是基本方法的某些操作的快捷方式。
                  </p>
                  <p>在本章中，除非另有说明，否则有关<code class="codeph">join</code>方法的信息同样适用于<code class="codeph">recursiveJoin</code>方法。随着<code class="codeph">join</code>方法可以涉及一个的元素<code class="codeph">Source</code>的那些另一个的<code class="codeph">Source</code>通过连接<code class="codeph">Source</code>与输入到<code class="codeph">Source</code>与该输入相匹配。例如，要指定检索具有维度作为输入的度量数据所需的维度成员，可以使用<code class="codeph">join</code>方法将维度成员与度量相关联。<code class="codeph">join</code>方法和<code class="codeph">Source</code>的输入在<span class="q">“</span> <code class="codeph">Source</code>的<span class="q"><a href="understanding-source-objects.html#GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240">输入和输出</a> ”</span>中描述。
                  </p>
                  <p><code class="codeph">Source</code>具有某些特征，例如类型和数据类型，并且它可以具有一个或多个输入或输出。本章介绍了这些概念。它还描述了不同类型的<code class="codeph">Source</code>对象以及如何获取它们，以及<code class="codeph">join</code>方法和其他<code class="codeph">Source</code>方法以及如何使用这些方法来指定查询。
                  </p>
               </div>
            </div><a id="OLAAP249"></a><div class="props_rev_3"><a id="GUID-26FAD107-7192-41FA-AAE2-066949993CEB" name="GUID-26FAD107-7192-41FA-AAE2-066949993CEB"></a><h3 id="OLAAP-GUID-26FAD107-7192-41FA-AAE2-066949993CEB" class="sect3"><span class="enumeration_section">5.2</span>各种源对象</h3>
               <div>
                  <div class="section">
                     <p><a id="d13320e287" class="indexterm-anchor"></a><a id="d13320e291" class="indexterm-anchor"></a>您用于指定数据和执行分析的<code class="codeph">Source</code>对象的种类以及获取它们的方式如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d13320e302" class="indexterm-anchor"></a>主要<code class="codeph">Source</code>对象，由<code class="codeph">MdmSource</code>对象（如<code class="codeph">MdmDimension</code>或<code class="codeph">MdmDimensionedObject</code>的<code class="codeph">getSource</code>方法返回。主要<code class="codeph">Source</code>提供对<code class="codeph">MdmSource</code>表示的数据的访问。获取主要<code class="codeph">Source</code>对象通常是创建查询的第一步。然后，您通常从主<code class="codeph">Source</code>对象中选择元素，从而生成派生的<code class="codeph">Source</code>对象。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e340" class="indexterm-anchor"></a>派生的<code class="codeph">Source</code>对象，可以通过调用<code class="codeph">Source</code>对象的某些方法获得。诸如<code class="codeph">join</code>方法返回一个新的<code class="codeph">Source</code> ，该<code class="codeph">Source</code>派生自您调用该方法的<code class="codeph">Source</code> 。除了由<code class="codeph">MdmDimension</code>的主要<code class="codeph">Source</code>指定的简单值列表之外，数据存储上的所有查询都是派生的<code class="codeph">Source</code>对象。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e372" class="indexterm-anchor"></a> Fundamental <code class="codeph">Source</code>对象，由<code class="codeph">FundamentalMetadataObject</code>的<code class="codeph">getSource</code>方法返回。这些<code class="codeph">Source</code>对象表示OLAP Java API数据类型。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e391" class="indexterm-anchor"></a><a id="d13320e395" class="indexterm-anchor"></a>列表或范围<code class="codeph">Source</code>对象，这些对象由返回<code class="codeph">createConstantSource</code> ， <code class="codeph">createListSource</code> ，或<code class="codeph">createRangeSource</code>一个的方法<code class="codeph">DataProvider</code> 。通常，您使用此类<code class="codeph">Source</code>作为<code class="codeph">join</code>方法的<code class="codeph">joined</code>或<code class="codeph">comparison</code>参数。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e430" class="indexterm-anchor"></a><a id="d13320e434" class="indexterm-anchor"></a><a id="d13320e438" class="indexterm-anchor"></a><a id="d13320e442" class="indexterm-anchor"></a><a id="d13320e444" class="indexterm-anchor"></a><a id="d13320e446" class="indexterm-anchor"></a><a id="d13320e448" class="indexterm-anchor"></a> Empty，null或void <code class="codeph">Source</code>对象。空和空隙<code class="codeph">Source</code>对象由返回<code class="codeph">getEmptySource</code>或<code class="codeph">getVoidSource</code>一个的方法<code class="codeph">DataProvider</code> ，和空<code class="codeph">Source</code>目的通过返回的<code class="codeph">nullSource</code>一个的方法<code class="codeph">Source</code> 。空的<code class="codeph">Source</code>没有元素。void <code class="codeph">Source</code>和null <code class="codeph">Source</code>每个都有一个值为<code class="codeph">null</code>元素。空隙之间的差<code class="codeph">Source</code>和一个空<code class="codeph">Source</code>是该空隙的类型<code class="codeph">Source</code>是<code class="codeph">FundamentalMetadataObject</code>为数值数据类型和一个空的类型<code class="codeph">Source</code>是<code class="codeph">Source</code>其<code class="codeph">nullSource</code>方法返回它。通常情况下，你使用这些类型的<code class="codeph">Source</code>对象为<code class="codeph">joined</code>或<code class="codeph">comparison</code>参数的<code class="codeph">join</code>方法。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e526" class="indexterm-anchor"></a>动态<code class="codeph">Source</code>对象，由<code class="codeph">DynamicDefinition</code>的<code class="codeph">getSource</code>方法返回。动态<code class="codeph">Source</code>通常是派<code class="codeph">Source</code> 。它由<code class="codeph">Template</code>生成，您可以使用该<code class="codeph">Template</code>创建动态查询，您可以在与最终用户交互后进行修改。
                           </p>
                        </li>
                        <li>
                           <p><a id="d13320e552" class="indexterm-anchor"></a>参数化的<code class="codeph">Source</code>对象，由<code class="codeph">Parameter</code>的<code class="codeph">createSource</code>方法返回。与列表或范围<code class="codeph">Source</code>类似，您使用参数化的<code class="codeph">Source</code>作为<code class="codeph">join</code>方法的参数。但是，与列表或范围<code class="codeph">Source</code>不同，您可以更改<code class="codeph">Parameter</code>在连接操作后表示的值，从而更改派生的<code class="codeph">Source</code>表示的选择。您可以为该派生的<code class="codeph">Source</code>创建<code class="codeph">Cursor</code>并检索查询的结果。然后，您可以更改<code class="codeph">Parameter</code>的值，并且无需为派生的<code class="codeph">Source</code>创建新<code class="codeph">Cursor</code> ，请使用相同的<code class="codeph">Cursor</code>来检索已修改查询的结果。
                           </p>
                        </li>
                     </ul>
                     <p><a id="d13320e605" class="indexterm-anchor"></a> <code class="codeph">Source</code>类具有以下子类：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">BooleanSource</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DateSource</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">NumberSource</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">StringSource</code></p>
                        </li>
                     </ul>
                     <p>这些子类具有不同的数据类型，并实现需要这些数据类型的<code class="codeph">Source</code>方法。每个子类还实现独特到它的方法，如<code class="codeph">implies</code>一个的方法<code class="codeph">BooleanSource</code>或<code class="codeph">indexOf</code>一个的方法<code class="codeph">StringSource</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="OLAAP250"></a><div class="props_rev_3"><a id="GUID-0604D759-310C-43F9-9111-29739F022A2C" name="GUID-0604D759-310C-43F9-9111-29739F022A2C"></a><h3 id="OLAAP-GUID-0604D759-310C-43F9-9111-29739F022A2C" class="sect3"><span class="enumeration_section">5.3</span>源对象的特征</h3>
               <div>
                  <p><code class="codeph">Source</code>具有数据类型，类型和标识符（ID），除空<code class="codeph">Source</code>之外的所有<code class="codeph">Source</code>对象都具有一个或多个元素。以下主题描述了这些概念。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-4DEE19D0-26E5-4C77-A26E-50D353422885">来源的要素和价值观</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-A851D911-480D-4F7F-93B0-9794621CA09F">源的数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501">来源类型</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-D2D985B8-62B4-4900-BCE5-8772BA596E8A">源的源识别和源定义</a></p>
                     </li>
                  </ul>
                  <p>某些<code class="codeph">Source</code>对象具有一个或多个输入或输出。<span class="q">“ <a href="understanding-source-objects.html#GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240">源的输入和输出</a> ”</span>中讨论了这些复杂的概念。
                  </p>
               </div><a id="OLAAP251"></a><div class="props_rev_3"><a id="GUID-4DEE19D0-26E5-4C77-A26E-50D353422885" name="GUID-4DEE19D0-26E5-4C77-A26E-50D353422885"></a><h4 id="OLAAP-GUID-4DEE19D0-26E5-4C77-A26E-50D353422885" class="sect4"><span class="enumeration_section">5.3.1</span>来源的要素和价值观</h4>
                  <div>
                     <p><a id="d13320e759" class="indexterm-anchor"></a><a id="d13320e763" class="indexterm-anchor"></a><a id="d13320e767" class="indexterm-anchor"></a>除空<code class="codeph">Source</code>外，所有<code class="codeph">Source</code>对象都有一个或多个元素。<code class="codeph">Source</code>的元素具有值，该值可以为null。例如，CHANNEL_AWJ维度的<code class="codeph">MdmPrimaryDimension</code>对象的<code class="codeph">Source</code>有四个元素。这些元素的值是维度成员的唯一值，如下所示。
                     </p><pre class="oac_no_warn" dir="ltr">CHANNEL_PRIMARY :: CHANNEL :: TOTAL CHANNEL_PRIMARY :: CHANNEL :: CAT CHANNEL_PRIMARY :: CHANNEL :: DIR CHANNEL_PRIMARY :: CHANNEL :: INT</pre></div>
               </div><a id="OLAAP252"></a><div class="props_rev_3"><a id="GUID-A851D911-480D-4F7F-93B0-9794621CA09F" name="GUID-A851D911-480D-4F7F-93B0-9794621CA09F"></a><h4 id="OLAAP-GUID-A851D911-480D-4F7F-93B0-9794621CA09F" class="sect4"><span class="enumeration_section">5.3.2</span>源的数据类型</h4>
                  <div>
                     <p><a id="d13320e825" class="indexterm-anchor"></a><a id="d13320e831" class="indexterm-anchor"></a><a id="d13320e835" class="indexterm-anchor"></a><a id="d13320e839" class="indexterm-anchor"></a><a id="d13320e843" class="indexterm-anchor"></a> <code class="codeph">FundamentalMetadataObject</code>类表示<code class="codeph">MdmSource</code>元素值的数据类型。<code class="codeph">Source</code>的数据类型由基本<code class="codeph">Source</code>表示。例如， <code class="codeph">BooleanSource</code>包含具有Java <code class="codeph">boolean</code>值的元素。<code class="codeph">BooleanSource</code>的数据类型是表示OLAP Java API布尔值的基本<code class="codeph">Source</code> 。
                     </p>
                     <p><a id="d13320e874" class="indexterm-anchor"></a>为了得到根本<code class="codeph">Source</code>是代表的数据类型<code class="codeph">Source</code> ，致电<code class="codeph">getDataType</code>的方法<code class="codeph">Source</code> 。您还可以通过调用<code class="codeph">FundamentalMetadataObject</code>的<code class="codeph">getSource</code>方法来获取基本<code class="codeph">Source</code> 。
                     </p>
                     <p>主<code class="codeph">Source</code>的数据类型与关联的元数据对象的SQL数据类型相关。例如，具有SQL数据类型<code class="codeph">VARCHAR2(30)</code>的<code class="codeph">MdmBaseAttribute</code>将生成一个<code class="codeph">Source</code>其数据类型是表示OLAP Java API String值的基本<code class="codeph">Source</code> 。以下代码获取该基本<code class="codeph">Source</code> 。
                     </p><pre class="oac_no_warn" dir="ltr"><a id="d13320e923" class="indexterm-anchor"></a> 。fmp.getStringDataType（）的getSource（）; // fmp是FundamentalMetadataProvider。
</pre><p><a id="d13320e929" class="indexterm-anchor"></a>数据类型的<code class="codeph">Source</code>典型用法是作为连接或递归连接操作的比较<code class="codeph">Source</code> 。因此，它表示该数据类型的所有值的集合。有关使用<code class="codeph">getDataType</code>方法的<a href="making-queries-using-source-methods.html#GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85__CBBEBEJH">示例</a> ，请参见<a href="making-queries-using-source-methods.html#GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85__CBBEBEJH">例6-3</a> ， <a href="making-queries-using-source-methods.html#GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A__CBBDDAHE">示例6-5</a>和<a href="making-queries-using-source-methods.html#GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D__CBBJDIAC">示例6-11</a> 。
                     </p>
                  </div>
               </div><a id="OLAAP254"></a><a id="OLAAP253"></a><div class="props_rev_3"><a id="GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501" name="GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501"></a><h4 id="OLAAP-GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501" class="sect4"><span class="enumeration_section">5.3.3</span>源的类型</h4>
                  <div>
                     <p><a id="d13320e990" class="indexterm-anchor"></a><a id="d13320e996" class="indexterm-anchor"></a><a id="d13320e1000" class="indexterm-anchor"></a><a id="d13320e1006" class="indexterm-anchor"></a><a id="d13320e1010" class="indexterm-anchor"></a>随着一个数据类型，一个<code class="codeph">Source</code>有一个类型，其是<code class="codeph">Source</code>从中的元素<code class="codeph">Source</code>被绘制。<code class="codeph">Source</code>的类型确定<code class="codeph">join</code>方法是否可以将<code class="codeph">Source</code>与另一个<code class="codeph">Source</code>的输入匹配。唯一的<code class="codeph">Source</code>不有型的根本<code class="codeph">Source</code>为OLAP的Java API数值数据类型，它代表了集中的所有值，以及来自所有其他<code class="codeph">Source</code>的对象最终下降。您可以通过调用<code class="codeph">Source</code>的<code class="codeph">getType</code>方法找到该类型。
                     </p>
                     <p>该类型的根本的<code class="codeph">Source</code>是数据类型<code class="codeph">Source</code> 。类型的列表或范围的<code class="codeph">Source</code>是列表或范围的元素的值的数据类型<code class="codeph">Source</code> 。
                     </p>
                     <p>主要<code class="codeph">Source</code>的类型是以下之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>的基本<code class="codeph">Source</code> ，它表示主的元素的值的数据类型<code class="codeph">Source</code> 。例如，典型数字<code class="codeph">MdmMeasure</code>的<code class="codeph">getSource</code>方法返回的<code class="codeph">Source</code>类型是表示所有OLAP Java API编号值集的基本<code class="codeph">Source</code> 。
                           </p>
                        </li>
                        <li>
                           <p>该<code class="codeph">Source</code>为包含主对象<code class="codeph">Source</code> 。例如，类型<code class="codeph">Source</code>由返回<code class="codeph">getSource</code>一个的方法<code class="codeph">MdmLevelHierarchy</code>是<code class="codeph">Source</code>为<code class="codeph">MdmPrimaryDimension</code>包含的层次结构。
                           </p>
                        </li>
                     </ul>
                     <p>类型派生的<code class="codeph">Source</code>是下列中的一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d13320e1126" class="indexterm-anchor"></a> <span>基本</span> <code class="codeph">Source</code> ，它的<code class="codeph">Source</code>方法返回派生的<code class="codeph">Source</code> 。甲<code class="codeph">Source</code>通过返回的<code class="codeph">alias</code> ， <code class="codeph">distinct</code> ， <code class="codeph">extract</code> ， <code class="codeph">join</code> ， <code class="codeph">recursiveJoin</code> ，或<code class="codeph">value</code>的方法，或它们的快捷方式中的一个，具有与基<code class="codeph">Source</code>作为类型。
                           </p>
                        </li>
                        <li>
                           <p>一个基本的<code class="codeph">Source</code> 。由<code class="codeph">position</code>和<code class="codeph">count</code>等方法返回的<code class="codeph">Source</code>类型是OLAP Java API Integer数据类型的基本<code class="codeph">Source</code> 。由进行比较的方法（例如<code class="codeph">eq</code> ， <code class="codeph">le</code>等）返回的<code class="codeph">Source</code>类型是Boolean数据类型的基本<code class="codeph">Source</code> 。执行聚合函数的方法返回的<code class="codeph">Source</code>类型（如<code class="codeph">NumberSource</code>方法<code class="codeph">total</code>和<code class="codeph">average</code> ）是表示函数的基本<code class="codeph">Source</code> 。
                           </p>
                        </li>
                     </ul>
                     <p><a id="d13320e1217" class="indexterm-anchor"></a><a id="d13320e1223" class="indexterm-anchor"></a><a id="d13320e1227" class="indexterm-anchor"></a><a id="d13320e1233" class="indexterm-anchor"></a>具有基本<code class="codeph">Source</code>作为类型的派生<code class="codeph">Source</code>是从中派生它的<code class="codeph">Source</code>的子类型。具有基本A衍生来源<code class="codeph">Source</code>作为类型是基本的子类型<code class="codeph">Source</code> 。您可以使用<code class="codeph">isSubtypeOf</code>方法确定<code class="codeph">Source</code>是否是另一个<code class="codeph">Source</code>的子类型。
                     </p>
                     <p><a id="d13320e1264" class="indexterm-anchor"></a>例如，在<a href="understanding-source-objects.html#GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501__I1015161">示例5-1中</a> ， <code class="codeph">myList</code>对象是列表<code class="codeph">Source</code> 。该示例使用<code class="codeph">myList</code>从<code class="codeph">prodHier</code>选择值，这是PRODUCT_AWJ维度的<code class="codeph">MdmPrimaryDimension</code>的<code class="codeph">MdmLevelHierarchy</code>的<code class="codeph">Source</code> 。在示例中， <code class="codeph">dp</code>是<code class="codeph">DataProvider</code> 。
                     </p>
                     <div class="example" id="GUID-09278179-5DEB-4777-BB7D-F78ED9CA7501__I1015161">
                        <p class="titleinexample">例5-1使用isSubtypeOf方法</p><pre class="oac_no_warn" dir="ltr">来源myList = dp.createListSource（new String [] {“PRODUCT_PRIMARY :: FAMILY :: LTPC”，“PRODUCT_PRIMARY :: FAMILY :: DTPC”，“PRODUCT_PRIMARY :: FAMILY :: ACC”，“PRODUCT_PRIMARY :: FAMILY :: MON” “}）; Source prodSel = prodHier.selectValues（myList）; if（prodSel.isSubtypeOf（prodHier））println（“prodSel是prodHier的子类型。”）; else println（“prodSel不是prodHier的子类型。”）;</pre><p>因为<code class="codeph">prodSel</code>是<code class="codeph">prodSel</code>的子类型， <code class="codeph">prodHier</code> <code class="codeph">if</code>语句中的条件为true，示例显示以下内容：</p><pre class="oac_no_warn" dir="ltr">prodSel是prodHier的子类型。
</pre><p><code class="codeph">myList</code>的类型是基本的字符串<code class="codeph">Source</code> 。<code class="codeph">prodHier</code>的类型是PRODUCT_AWJ维度的<code class="codeph">Source</code> 。的类型的<code class="codeph">prodSel</code>是<code class="codeph">prodHier</code>由于元件<code class="codeph">prodSel</code>从的元件衍生<code class="codeph">prodHier</code> 。
                        </p>
                        <p>一个的超型<code class="codeph">Source</code>是一个的类型的类型<code class="codeph">Source</code> ，等等，向上穿过类型的<code class="codeph">Source</code>的基本数值数据类型。例如，基本值<code class="codeph">Source</code>是基本字符串<code class="codeph">Source</code>的类型，它是<code class="codeph">prodHier</code>的类型，它是<code class="codeph">prodSel</code>的类型。基本的Value <code class="codeph">Source</code>和基本的String <code class="codeph">Source</code>都是<code class="codeph">prodSel</code>超类型。所述<code class="codeph">prodSel</code> <code class="codeph">Source</code>是的子类型<code class="codeph">prodHier</code> ，并且基本字符串的<code class="codeph">Source</code> ，其根本价值<code class="codeph">Source</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP255"></a><div class="props_rev_3"><a id="GUID-D2D985B8-62B4-4900-BCE5-8772BA596E8A" name="GUID-D2D985B8-62B4-4900-BCE5-8772BA596E8A"></a><h4 id="OLAAP-GUID-D2D985B8-62B4-4900-BCE5-8772BA596E8A" class="sect4"><span class="enumeration_section">5.3.4</span>源的源识别和源定义</h4>
                  <div>
                     <p><a id="d13320e1428" class="indexterm-anchor"></a><a id="d13320e1432" class="indexterm-anchor"></a><a id="d13320e1436" class="indexterm-anchor"></a><a id="d13320e1440" class="indexterm-anchor"></a> <code class="codeph">Source</code>具有标识ID，该ID是在当前与数据库的连接期间唯一标识它的<code class="codeph">String</code> 。您可以通过调用<code class="codeph">Source</code>的<code class="codeph">getID</code>方法来获取标识。例如，以下代码获取PRODUCT_AWJ维度的<code class="codeph">MdmPrimaryDimension</code>的<code class="codeph">Source</code>标识并显示该值。
                     </p><pre class="oac_no_warn" dir="ltr">println（“prodDim的源ID是”+ prodDim.getID（））;</pre><p>上面的代码显示以下内容：</p><pre class="oac_no_warn" dir="ltr">prodDim的源ID是隐藏的..GLOBAL.PRODUCT_AWJ</pre><p><a id="d13320e1471" class="indexterm-anchor"></a><a id="d13320e1475" class="indexterm-anchor"></a>每个<code class="codeph">Source</code>还有一个<code class="codeph">SourceDefinition</code>对象，它记录有关<code class="codeph">Source</code>信息。Oracle OLAP在内部使用此信息。例如， <code class="codeph">SourceDefinition</code>派生的<code class="codeph">Source</code>记录所产生的连接操作的参数<code class="codeph">Source</code> ，如碱<code class="codeph">Source</code> ，接合的<code class="codeph">Source</code> ，比较<code class="codeph">Source</code> ，比较规则，以及值<code class="codeph">visible</code>参数。
                     </p>
                     <p><code class="codeph">DynamicDefinition</code>类是<code class="codeph">SourceDefinition</code>的子类。一个OLAP API的Java客户端应用程序使用<code class="codeph">DynamicDefinition</code>一个的<code class="codeph">Template</code>来获得动力<code class="codeph">Source</code>的的<code class="codeph">Template</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="OLAAP256"></a><div class="props_rev_3"><a id="GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240" name="GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240"></a><h3 id="OLAAP-GUID-02FCA7A8-5A52-484B-8952-BE12B7AE3240" class="sect3"><span class="enumeration_section">5.4</span>来源的输入和输出</h3>
               <div>
                  <p>一个的输入<code class="codeph">Source</code>指示的元素<code class="codeph">Source</code>具有相对于那些相互的<code class="codeph">Source</code> 。一个的输出<code class="codeph">Source</code>中包含来自所述的值的元素<code class="codeph">Source</code>与输出导出。具有一个或多个输出的<code class="codeph">Source</code>有点像数组数组。
                  </p>
                  <p><code class="codeph">Source</code>可以有输入，它可以有输出。<code class="codeph">Source</code>的输入和输出是其他<code class="codeph">Source</code>对象。
                  </p>
                  <p>基础<code class="codeph">Source</code>的输入和输出会影响从该基础<code class="codeph">Source</code>派生的<code class="codeph">Source</code>元素。为了得到一个<code class="codeph">Source</code> ，您可以使用基本的方法<code class="codeph">Source</code> 。派生的<code class="codeph">Source</code>可以具有输出或输入，或者两者都有，或者两者都没有，这取决于方法和方法的参数。
                  </p>
                  <p>某些<code class="codeph">Source</code>方法（如<code class="codeph">value</code>和<code class="codeph">position</code>方法）返回具有输入的<code class="codeph">Source</code> 。<code class="codeph">join</code>和<code class="codeph">recursiveJoin</code>方法可以返回具有输出的<code class="codeph">Source</code> 。如果连接操作涉及一个<code class="codeph">Source</code>与一个输入端和一个<code class="codeph">Source</code>与该输入相匹配，那么，输入作为在制备衍生的元素的滤波器<code class="codeph">Source</code> 。
                  </p>
                  <p>以下主题描述了<code class="codeph">join</code>方法，输出和输入的概念以及输入的匹配。它们提供了制造的例子<code class="codeph">Source</code>具有输出对象， <code class="codeph">Source</code>具有输入，并加入匹配了一个输入端，操作对象<code class="codeph">Source</code> 。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-38A6BB94-56A5-4A50-90E1-A7DBD83539DD">描述连接方法</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-CDD7803E-22A0-4F30-8471-2569E82C006E">输出源</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-74C3E73D-40DF-46C9-8831-5FDF66BE6048">输入源</a></p>
                     </li>
                     <li>
                        <p><a href="understanding-source-objects.html#GUID-41EDCE42-C277-433F-81D6-306148FC263D">匹配源与输入</a></p>
                     </li>
                  </ul>
               </div><a id="OLAAP257"></a><div class="props_rev_3"><a id="GUID-38A6BB94-56A5-4A50-90E1-A7DBD83539DD" name="GUID-38A6BB94-56A5-4A50-90E1-A7DBD83539DD"></a><h4 id="OLAAP-GUID-38A6BB94-56A5-4A50-90E1-A7DBD83539DD" class="sect4"><span class="enumeration_section">5.4.1</span>描述连接方法</h4>
                  <div>
                     <p><a id="d13320e1720" class="indexterm-anchor"></a><a id="d13320e1724" class="indexterm-anchor"></a>使用<code class="codeph">join</code>方法，可以将一个<code class="codeph">Source</code>的元素与另一个<code class="codeph">Source</code>的元素连接起来，以生成派生的<code class="codeph">Source</code> 。派生的<code class="codeph">Source</code>可以有输入或输出。派生<code class="codeph">Source</code>的元素以及它是否具有任何输入或输出取决于传递给<code class="codeph">join</code>方法的参数值。
                     </p>
                     <p><code class="codeph">join</code>方法的完整签名如下。
                     </p><pre class="oac_no_warn" dir="ltr">源连接（源连接，源比较，int comparisonRule，布尔可见）</pre><p><a id="d13320e1759" class="indexterm-anchor"></a><a id="d13320e1763" class="indexterm-anchor"></a>您调用<code class="codeph">join</code>方法的<code class="codeph">Source</code>是join操作的基础。该方法的参数如下。
                     </p>
                  </div><a id="OLAAP258"></a><div class="props_rev_3"><a id="GUID-B0FDCEC3-E3C0-492C-8CCD-F1D1026406C5" name="GUID-B0FDCEC3-E3C0-492C-8CCD-F1D1026406C5"></a><h5 id="OLAAP-GUID-B0FDCEC3-E3C0-492C-8CCD-F1D1026406C5" class="sect5"><span class="enumeration_section">5.4.1.1</span>描述连接的参数</h5>
                     <div>
                        <p><a id="d13320e1809" class="indexterm-anchor"></a><a id="d13320e1813" class="indexterm-anchor"></a> <code class="codeph">joined</code>参数是<code class="codeph">Source</code>对象。<code class="codeph">join</code>方法连接基本<code class="codeph">Source</code>的元素和已连接<code class="codeph">Source</code>的元素，其结果由其他<code class="codeph">join</code>参数的值确定。如果连接的<code class="codeph">Source</code>的值与基本<code class="codeph">Source</code>的值无关，也就是说，如果连接的<code class="codeph">Source</code>和基本<code class="codeph">Source</code>没有与另一个的输入匹配，则连接将生成元素的笛卡尔积。 base和已连接的<code class="codeph">Source</code>对象。<span class="q">“ <a href="understanding-source-objects.html#GUID-CDD7803E-22A0-4F30-8471-2569E82C006E">输出源</a> ”</span>主题中的示例演示了这种连接操作。
                        </p>
                        <p>如果连接的<code class="codeph">Source</code>的值与基本<code class="codeph">Source</code>的值相关，也就是说，如果连接的<code class="codeph">Source</code>或基本<code class="codeph">Source</code>是另一个的输入，则派生的<code class="codeph">Source</code>的元素是匹配的结果输入。<span class="q">“ <a href="understanding-source-objects.html#GUID-41EDCE42-C277-433F-81D6-306148FC263D">使用输入匹配源</a> ”中的</span>示例演示了这种连接操作。
                        </p>
                     </div>
                  </div><a id="OLAAP259"></a><div class="props_rev_3"><a id="GUID-7579066B-F94F-4D53-8200-E72E10993630" name="GUID-7579066B-F94F-4D53-8200-E72E10993630"></a><h5 id="OLAAP-GUID-7579066B-F94F-4D53-8200-E72E10993630" class="sect5"><span class="enumeration_section">5.4.1.2</span>描述比较参数</h5>
                     <div>
                        <p><a id="d13320e1916" class="indexterm-anchor"></a> <code class="codeph">comparison</code>参数是另一个<code class="codeph">Source</code>对象。join操作将比较<code class="codeph">Source</code>的元素值与已连接<code class="codeph">Source</code>的值进行比较。连接和比较对象中相同的值参与连接操作或从参与中删除，具体取决于<code class="codeph">comparisonRule</code>参数的值。
                        </p>
                     </div>
                  </div><a id="OLAAP260"></a><div class="props_rev_3"><a id="GUID-6D856ADF-3241-4F74-A2DA-6B0DF28D7C0F" name="GUID-6D856ADF-3241-4F74-A2DA-6B0DF28D7C0F"></a><h5 id="OLAAP-GUID-6D856ADF-3241-4F74-A2DA-6B0DF28D7C0F" class="sect5"><span class="enumeration_section">5.4.1.3</span>描述comparisonRule参数</h5>
                     <div>
                        <p><a id="d13320e1972" class="indexterm-anchor"></a><a id="d13320e1976" class="indexterm-anchor"></a> <code class="codeph">comparisonRule</code>参数的值指定已连接的<code class="codeph">Source</code>哪些值参与连接操作。<code class="codeph">comparisonRule</code>值还确定参与值的排序顺序。比较规则是<code class="codeph">Source</code>类的静态常量字段之一。基本比较规则如下。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d13320e1996" class="indexterm-anchor"></a><a id="d13320e2000" class="indexterm-anchor"></a> <code class="codeph">COMPARISON_RULE_SELECT</code> ，指定只有接合的元件<code class="codeph">Source</code> ，同时也是在比较<code class="codeph">Source</code>参与连接操作。
                              </p>
                           </li>
                           <li>
                              <p><a id="d13320e2015" class="indexterm-anchor"></a><a id="d13320e2019" class="indexterm-anchor"></a> <code class="codeph">COMPARISON_RULE_REMOVE</code> ，指定只有接合的元件<code class="codeph">Source</code>不在所述比较<code class="codeph">Source</code>参与连接操作。
                              </p>
                           </li>
                        </ul>
                        <p>其他比较规则是所有以各种方式对结果值进行排序的选择操作。这些规则如下。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d13320e2037" class="indexterm-anchor"></a><code class="codeph">COMPARISON_RULE_ASCENDING</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMPARISON_RULE_ASCENDING_NULLS_FIRST</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMPARISON_RULE_ASCENDING_NULLS_LAST</code></p>
                           </li>
                           <li>
                              <p><a id="d13320e2053" class="indexterm-anchor"></a><code class="codeph">COMPARISON_RULE_DESCENDING</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMPARISON_RULE_DESCENDING_NULLS_FIRST</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMPARISON_RULE_DESCENDING_NULLS_LAST</code></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="OLAAP261"></a><div class="props_rev_3"><a id="GUID-72D1F4CF-6207-4C45-B78E-BB1B67D62466" name="GUID-72D1F4CF-6207-4C45-B78E-BB1B67D62466"></a><h5 id="OLAAP-GUID-72D1F4CF-6207-4C45-B78E-BB1B67D62466" class="sect5"><span class="enumeration_section">5.4.1.4</span>描述可见参数</h5>
                     <div>
                        <p><a id="d13320e2102" class="indexterm-anchor"></a> <code class="codeph">visible</code>参数是一个<code class="codeph">boolean</code>值，指定连接的<code class="codeph">Source</code>是否显示为由join操作派生的<code class="codeph">Source</code>的输出。如果<code class="codeph">visible</code>参数的值为<code class="codeph">true</code> ，则派生的<code class="codeph">Source</code>具有包含从连接的<code class="codeph">Source</code>提取的元素的输出。如果值为<code class="codeph">false</code> ，则派生的<code class="codeph">Source</code>没有已连接<code class="codeph">Source</code>的输出。
                        </p>
                     </div>
                  </div>
               </div><a id="OLAAP262"></a><div class="props_rev_3"><a id="GUID-CDD7803E-22A0-4F30-8471-2569E82C006E" name="GUID-CDD7803E-22A0-4F30-8471-2569E82C006E"></a><h4 id="OLAAP-GUID-CDD7803E-22A0-4F30-8471-2569E82C006E" class="sect4"><span class="enumeration_section">5.4.2</span>来源的输出</h4>
                  <div>
                     <p><a id="d13320e2176" class="indexterm-anchor"></a><a id="d13320e2182" class="indexterm-anchor"></a> <code class="codeph">join</code>方法返回一个派生的<code class="codeph">Source</code> ，它具有由方法参数指定的基本<code class="codeph">Source</code>元素的值。这些值是所导出的所述基值<code class="codeph">Source</code> 。
                     </p>
                     <p>如果<code class="codeph">join</code>方法的<code class="codeph">visible</code>参数的值为<code class="codeph">true</code> ，则连接的<code class="codeph">Source</code>将成为派生<code class="codeph">Source</code>的输出。然后，派生<code class="codeph">Source</code>的元素具有输出值和基值，由连接操作的其他参数指定。
                     </p>
                     <p><a id="d13320e2223" class="indexterm-anchor"></a><a id="d13320e2229" class="indexterm-anchor"></a><a id="d13320e2235" class="indexterm-anchor"></a>派<code class="codeph">Source</code>可以具有从零到多个输出。作为输出的<code class="codeph">Source</code>本身可以具有输出。您可以通过调用<code class="codeph">getOutputs</code>方法获取<code class="codeph">Source</code>的输出，该方法返回<code class="codeph">Source</code>对象的<code class="codeph">List</code> 。
                     </p>
                     <p>以下主题中的示例都具有简单的连接操作，这些操作可生成具有一个或多个输出的<code class="codeph">Source</code>对象。由于连接操作中没有任何<code class="codeph">Source</code>对象具有输入，因此连接操作生成的派生<code class="codeph">Source</code>对象的值是基础的Cartesian产品和连接的<code class="codeph">Source</code>对象。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C">使用输出生成源</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534">使用COMPARISON_RULE_SELECT</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-0846E8CA-CA50-49EA-842F-5A45563A5818">使用COMPARISON_RULE_REMOVE</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76">生成具有两个输出的源</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-78234ECD-F90D-41C1-B637-803D54AD89B9">隐藏输出</a></p>
                        </li>
                     </ul>
                     <p>非常不同的结果从涉及联合操作发生<code class="codeph">Source</code>具有输入和<code class="codeph">Source</code>与该输入相匹配。有关具有输入和输入匹配的<code class="codeph">Source</code>对象的示例，请参阅以下主题。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-74C3E73D-40DF-46C9-8831-5FDF66BE6048">输入源</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-41EDCE42-C277-433F-81D6-306148FC263D">匹配源与输入</a></p>
                        </li>
                     </ul>
                  </div><a id="OLAAP264"></a><a id="OLAAP263"></a><div class="props_rev_3"><a id="GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C" name="GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C"></a><h5 id="OLAAP-GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C" class="sect5"><span class="enumeration_section">5.4.2.1</span>使用输出生成源</h5>
                     <div>
                        <div class="example" id="GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C__BABFCECA">
                           <p class="titleinexample">例5-2使用输出生成源的简单连接</p>
                           <p><a id="d13320e2359" class="indexterm-anchor"></a>此示例使用<code class="codeph">join</code>方法的最简单签名来生成具有一个输出的<code class="codeph">Source</code> 。该示例创建了一个列表<code class="codeph">Source</code> ， <code class="codeph">letters</code> ，它有三个元素，其值为A，B和C.它还创建一个列表<code class="codeph">Source</code> ， <code class="codeph">names</code> ，它有三个元素，其值为Stephen，Leo和莫莉。
                           </p><pre class="oac_no_warn" dir="ltr">源字母= dp.createListSource（new String [] {“A”，“B”，“C”}）;源名= dp.createListSource（new String [] {“Stephen”，“Leo”，“Molly”}）;源lettersWithNames = letters.join（名字）; // Oracle OLAP将join方法的此快捷方式签名转换为//以下完整签名，其中dp是会话的DataProvider。//来源letters.join（姓名， <a id="d13320e2387" class="indexterm-anchor"></a> // dp.getEmptySource（），//来源。COMPARISON_RULE_REMOVE，// true）;</pre><p><code class="codeph">letters.join(names)</code>操作连接基本<code class="codeph">Source</code> ， <code class="codeph">letters</code>和连接的<code class="codeph">Source</code> ， <code class="codeph">names</code>的元素。由于比较<code class="codeph">Source</code>没有元素，因此连接操作不会删除生成派生<code class="codeph">Source</code>的联接<code class="codeph">Source</code>中的任何元素。（比较<code class="codeph">Source</code>是由示例中显示的完整<code class="codeph">join</code>签名的<code class="codeph">dp.getEmptySource()</code>参数返回的空<code class="codeph">Source</code> 。）得到的<code class="codeph">Source</code> ， <code class="codeph">lettersWithNames</code>是基本<code class="codeph">letters</code>元素和连接<code class="codeph">names</code>的笛卡尔积。因为<code class="codeph">letters</code>和<code class="codeph">names</code>都有三个元素，所以<code class="codeph">lettersWithNames</code>的元素<code class="codeph">lettersWithNames</code>为9。
                           </p>
                           <p>因为<code class="codeph">letters.join(names)</code>的<code class="codeph">visible</code>参数为<code class="codeph">true</code> ，所以派生的<code class="codeph">Source</code>有一个输出。因为没有<code class="codeph">elements</code>从接合除去<code class="codeph">Source</code> ，派生<code class="codeph">Source</code>具有所有加入的元素的值<code class="codeph">Source</code> 。
                           </p>
                           <p>一个<code class="codeph">Cursor</code>的<code class="codeph">Source</code>具有相同的结构<code class="codeph">Source</code> 。<code class="codeph">lettersWithNames</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>有一个<code class="codeph">ValueCursor</code>用于派生<code class="codeph">Source</code>的基值和一个<code class="codeph">ValueCursor</code>用于输出值。下表显示了<code class="codeph">ValueCursor</code>对象的值。该表包含不在<code class="codeph">ValueCursor</code>对象中的<code class="codeph">ValueCursor</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">输出值基础值Stephen A Stephen B Stephen C Leo A Leo B Leo C Molly A Molly B Molly C.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP266"></a><a id="OLAAP265"></a><div class="props_rev_3"><a id="GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534" name="GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534"></a><h5 id="OLAAP-GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534" class="sect5"><span class="enumeration_section">5.4.2.2</span>使用COMPARISON_RULE_SELECT</h5>
                     <div>
                        <div class="example" id="GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534__BABHAHJD">
                           <p class="titleinexample">例5-3选择连接源元素的简单连接</p>
                           <p><a id="d13320e2559" class="indexterm-anchor"></a>此示例演示如何使用具有值的比较<code class="codeph">Source</code>和比较规则<code class="codeph">COMPARISON_RULE_SELECT</code> 。该示例使用<a href="understanding-source-objects.html#GUID-B19BD929-B106-4AD3-84CC-0E8DCA51E86C__BABFCECA">示例5-2中</a>的<code class="codeph">letter</code>和<code class="codeph">names</code> <code class="codeph">Source</code>对象，并添加<code class="codeph">someNames</code> <code class="codeph">Source</code> 。它使用<code class="codeph">someNames</code>作为比较<code class="codeph">Source</code> 。从连接操作派生的<code class="codeph">Source</code>的输出只有连接的<code class="codeph">Source</code>和比较<code class="codeph">Source</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">来源someNames = dp.createListSource（new String [] {“Stephen”，“Molly”}）; Source lettersAndSelectedNames = letters.join（names，someNames，Source。COMPARISON_RULE_SELECT，true）;</pre><p>一个<code class="codeph">Cursor</code>为<code class="codeph">lettersAndSelectedNames</code> <code class="codeph">Source</code>具有由指定的值<code class="codeph">Source</code> 。下表显示了<code class="codeph">Cursor</code>值并添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">输出值基本值Stephen A Stephen B Stephen C Molly A Molly B Molly C.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP268"></a><a id="OLAAP267"></a><div class="props_rev_3"><a id="GUID-0846E8CA-CA50-49EA-842F-5A45563A5818" name="GUID-0846E8CA-CA50-49EA-842F-5A45563A5818"></a><h5 id="OLAAP-GUID-0846E8CA-CA50-49EA-842F-5A45563A5818" class="sect5"><span class="enumeration_section">5.4.2.3</span>使用COMPARISON_RULE_REMOVE</h5>
                     <div>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-0846E8CA-CA50-49EA-842F-5A45563A5818__BABFJAAH">
                           <p class="titleinexample">示例5-4删除已连接源元素的简单连接</p>
                           <p><a id="d13320e2667" class="indexterm-anchor"></a>此示例演示如何使用具有值的比较<code class="codeph">Source</code>和比较规则<code class="codeph">COMPARISON_RULE_REMOVE</code> 。该比较规则从参与连接操作中删除了在连接和比较<code class="codeph">Source</code>对象中相同的值。因此，派<code class="codeph">Source</code>的输出仅具有来自不在比较<code class="codeph">Source</code>中的已连接<code class="codeph">Source</code>的名称。
                           </p>
                           <p>该示例具有与<a href="understanding-source-objects.html#GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534__BABHAHJD">示例5-3</a>相同的基础，连接和比较<code class="codeph">Source</code>对象。
                           </p><pre class="oac_no_warn" dir="ltr">源lettersAndNamesWithoutRemovedNames = letters.join（names，someNames，Source。COMPARISON_RULE_REMOVE，true）;</pre><p>一个<code class="codeph">Cursor</code>为<code class="codeph">lettersAndNamesWithoutRemovedNames</code> <code class="codeph">Source</code>具有由指定的值<code class="codeph">Source</code> 。下表显示了值并添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">输出值基础值Leo A Leo B Leo C.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP270"></a><a id="OLAAP269"></a><div class="props_rev_3"><a id="GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76" name="GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76"></a><h5 id="OLAAP-GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76" class="sect5"><span class="enumeration_section">5.4.2.4</span>生成具有两个输出的源</h5>
                     <div>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76__BABBAIFI">
                           <p class="titleinexample">例5-5产生具有两个输出的源的简单连接</p>
                           <p><a id="d13320e2757" class="indexterm-anchor"></a>如果将<code class="codeph">Source</code>到具有输出的<code class="codeph">Source</code> ，并且<code class="codeph">visible</code> <code class="codeph">parameter</code>为<code class="codeph">true</code> ，则join操作将生成一个<code class="codeph">Source</code> ，该<code class="codeph">Source</code>将已连接的<code class="codeph">Source</code>作为附加输出。附加输出成为第一个输出，如本例所示。
                           </p>
                           <p>该示例使用<a href="understanding-source-objects.html#GUID-E4E4A262-B925-423A-B2FA-65CF2AE44534__BABHAHJD">示例5-3中</a>的<code class="codeph">Source</code>对象创建另一个列表<code class="codeph">Source</code> ， <code class="codeph">colors</code> ，其中包含两种颜色的名称。该示例将<code class="codeph">colors</code> <code class="codeph">Source</code>连接到<code class="codeph">lettersWithSelectedNames</code> <code class="codeph">Source</code>以生成<code class="codeph">lettersWithSelectedNamesAndColors</code> <code class="codeph">Source</code> 。
                           </p>
                           <p><code class="codeph">lettersWithSelectedNames</code> <code class="codeph">Source</code>将<code class="codeph">names</code>作为输出。<code class="codeph">lettersWithSelectedNamesAndColors</code> <code class="codeph">Source</code>具有<code class="codeph">colors</code>和<code class="codeph">names</code>作为输出。第一个输出是<code class="codeph">colors</code> ，第二个输出是<code class="codeph">names</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">Source colors = dp.createListSource（new String [] {“Green”，“Maroon”}）;源lettersWithSelectedNames = letters.join（names，someNames，Source。COMPARISON_RULE_SELECT，true）;源lettersWithSelectedNamesAndColors = lettersWithSelectedNames.join（colors）;</pre><p><code class="codeph">lettersWithSelectedNamesAndColors</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有下表中显示的值。该表添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">输出1值输出2值基本值绿色斯蒂芬A绿色斯蒂芬B绿色斯蒂芬C绿色莫莉绿色莫莉B绿色莫莉C栗色斯蒂芬A栗色斯蒂芬B栗色斯蒂芬C栗色莫莉A栗色莫莉B栗色莫莉C</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP272"></a><a id="OLAAP271"></a><div class="props_rev_3"><a id="GUID-78234ECD-F90D-41C1-B637-803D54AD89B9" name="GUID-78234ECD-F90D-41C1-B637-803D54AD89B9"></a><h5 id="OLAAP-GUID-78234ECD-F90D-41C1-B637-803D54AD89B9" class="sect5"><span class="enumeration_section">5.4.2.5</span>隐藏输出</h5>
                     <div>
                        <div class="example" id="GUID-78234ECD-F90D-41C1-B637-803D54AD89B9__BABDJJDJ">
                           <p class="titleinexample">例5-6隐藏输出的简单连接</p>
                           <p><a id="d13320e2901" class="indexterm-anchor"></a><a id="d13320e2907" class="indexterm-anchor"></a>如果<code class="codeph">join</code>方法的<code class="codeph">visible</code>参数为<code class="codeph">false</code> ，则连接的<code class="codeph">Source</code>参与连接操作，但不会显示为连接派生的<code class="codeph">Source</code>的输出。此示例使用<code class="codeph">joinHidden</code>快捷方法连接来自<a href="understanding-source-objects.html#GUID-22B406BC-38A1-45D8-9E01-06F579EBBF76__BABBAIFI">示例5-5</a>的<code class="codeph">lettersWithSelectedNames</code>和<code class="codeph">colors</code> <code class="codeph">Source</code>对象。该示例在注释中包含<code class="codeph">joinHidden</code>快捷方式的完整<code class="codeph">join</code>签名。
                           </p><pre class="oac_no_warn" dir="ltr">源lettersWithSelectedNamesAndHiddenColors = lettersWithSelectedNames.joinHidden（colors）; // joinHidden快捷方法的完整签名是// Source result = base.join（joined，// dp.getEmptySource（），// Source。COMPARISON_RULE_REMOVE，// false）; //因此，如果Source base = lettersWithSelectedNames且// Source joined = colors，则结果Source与// lettersWithSelectedNamesAndHiddenColors Source相同。
</pre><p><code class="codeph">lettersWithSelectedNamesAndHiddenColors</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有下表中显示的值。该表添加了标题。
                           </p>
                           <p>请注意，派生的<code class="codeph">lettersWithSelectedNamesAndHiddenColors</code> <code class="codeph">Source</code>仍然有12个元素，即使<code class="codeph">colors</code> <code class="codeph">Source</code>的值不显示为输出值。派生的<code class="codeph">Source</code>对于隐藏<code class="codeph">colors</code> <code class="codeph">Source</code>每个值都有一组<code class="codeph">lettersWithSelectedNames</code> <code class="codeph">Source</code>的六个值。
                           </p>
                           <p>该示例显示以下输出。</p><pre class="oac_no_warn" dir="ltr">输出值基本值Stephen A Stephen B Stephen C Molly A Molly B Molly C Stephen A Stephen B Stephen C Molly A Molly B Molly C</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="OLAAP273"></a><div class="props_rev_3"><a id="GUID-74C3E73D-40DF-46C9-8831-5FDF66BE6048" name="GUID-74C3E73D-40DF-46C9-8831-5FDF66BE6048"></a><h4 id="OLAAP-GUID-74C3E73D-40DF-46C9-8831-5FDF66BE6048" class="sect4"><span class="enumeration_section">5.4.3</span>源的输入</h4>
                  <div>
                     <p><a id="d13320e3032" class="indexterm-anchor"></a><a id="d13320e3038" class="indexterm-anchor"></a><a id="d13320e3042" class="indexterm-anchor"></a> <span class="q">“ <a href="understanding-source-objects.html#GUID-CDD7803E-22A0-4F30-8471-2569E82C006E">输出源</a> ”</span>主题中的示例都生成派生的<code class="codeph">Source</code>对象，这些对象具有不相关基础和已连接的<code class="codeph">Source</code>对象的笛卡尔积的元素。虽然这样的操作可能很有用，但<code class="codeph">Source</code>对象的一个更强大的方面是能够将一个<code class="codeph">Source</code>的元素与另一个<code class="codeph">Source</code> 。当存在这样的关系时，您可以派生其他<code class="codeph">Source</code>对象，这些对象是相关元素之间的操作的结果。例如，你可以得到一个<code class="codeph">Source</code>包含另一只选定的元素<code class="codeph">Source</code> 。元素之间的这种关系由<code class="codeph">Source</code>的输入表示。
                     </p>
                     <p>具有输入的<code class="codeph">Source</code>是不完整的数据规范。输入表示<code class="codeph">Source</code>的类型，该<code class="codeph">Source</code>可以具有连接操作完成数据规范所需的元素。在使用<code class="codeph">Cursor</code>检索数据之前，必须将输入与具有完成规范的元素的<code class="codeph">Source</code>匹配。
                     </p>
                     <p>您可以使用<code class="codeph">join</code>或<code class="codeph">recursiveJoin</code>方法将输入与<code class="codeph">Source</code>匹配。匹配发生在基本<code class="codeph">Source</code>和已连接的<code class="codeph">Source</code> 。
                     </p>
                     <p>输入的匹配充当过滤器，以便由连接操作派生的<code class="codeph">Source</code>仅具有基本<code class="codeph">Source</code>的元素，其值与已连接<code class="codeph">Source</code>的元素的值相关。“将<code class="codeph">Source</code>与输入<span class="q"><a href="understanding-source-objects.html#GUID-41EDCE42-C277-433F-81D6-306148FC263D">匹配</a> ”</span>中描述了与将<code class="codeph">Source</code>与输入匹配相关的规则。该主题具有生成派<code class="codeph">Source</code>对象的示例，这些<code class="codeph">Source</code>对象是输入匹配的结果。
                     </p>
                     <p><a id="d13320e3137" class="indexterm-anchor"></a><a id="d13320e3143" class="indexterm-anchor"></a><a id="d13320e3149" class="indexterm-anchor"></a> <code class="codeph">Source</code>可以具有从零到多个输入。您可以通过调用<code class="codeph">getInputs</code>方法获取<code class="codeph">Source</code>的所有输入。
                     </p>
                     <p>一些主要<code class="codeph">Source</code>对象具有输入。你可以得到一个<code class="codeph">Source</code> ，通过使用一些方法有一个输入<code class="codeph">Source</code>类。
                     </p>
                  </div><a id="OLAAP274"></a><div class="props_rev_3"><a id="GUID-52930A3C-DC86-420C-80F3-FF2A3A9AF618" name="GUID-52930A3C-DC86-420C-80F3-FF2A3A9AF618"></a><h5 id="OLAAP-GUID-52930A3C-DC86-420C-80F3-FF2A3A9AF618" class="sect5"><span class="enumeration_section">5.4.3.1</span>带输入的主源对象</h5>
                     <div>
                        <p><a id="d13320e3207" class="indexterm-anchor"></a><a id="d13320e3211" class="indexterm-anchor"></a><a id="d13320e3217" class="indexterm-anchor"></a><a id="d13320e3221" class="indexterm-anchor"></a> <code class="codeph">MdmDimensionedObject</code>子类<code class="codeph">MdmAttribute</code>和<code class="codeph">MdmMeasure</code>的主要<code class="codeph">Source</code>对象具有输入。<code class="codeph">MdmAttribute</code>的主要<code class="codeph">Source</code>有一个输入。<code class="codeph">MdmMeasure</code>的主要<code class="codeph">Source</code>有一个或多个输入。
                        </p>
                        <p><a id="d13320e3252" class="indexterm-anchor"></a><a id="d13320e3256" class="indexterm-anchor"></a> <code class="codeph">MdmAttribute</code>或<code class="codeph">MdmMeasure</code>的输入是<code class="codeph">MdmAttribute</code>对象的<code class="codeph">Source</code>对象，用于<code class="codeph">MdmPrimaryDimension</code>属性或度量。要获取属性或度量的值，必须使用包含相关维成员的<code class="codeph">Source</code>连接属性或度量。连接操作将属性或度量的输入与包含维成员的<code class="codeph">Source</code>进行匹配。<a href="understanding-source-objects.html#GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D__BABJHBEG">示例5-7</a>将属性的输入与该属性的维度进行匹配。<a href="understanding-source-objects.html#GUID-83F2CA40-C041-4733-A13F-3EC617942312__BABFIEJH">示例5-8</a>将度量的输入与该度量的维度进行匹配。
                        </p>
                     </div>
                  </div><a id="OLAAP275"></a><div class="props_rev_3"><a id="GUID-F00CC751-9451-4ECE-84AE-0B0ECC724D78" name="GUID-F00CC751-9451-4ECE-84AE-0B0ECC724D78"></a><h5 id="OLAAP-GUID-F00CC751-9451-4ECE-84AE-0B0ECC724D78" class="sect5"><span class="enumeration_section">5.4.3.2</span>使用输入导出源</h5>
                     <div>
                        <p><a id="d13320e3319" class="indexterm-anchor"></a><a id="d13320e3323" class="indexterm-anchor"></a><a id="d13320e3329" class="indexterm-anchor"></a><a id="d13320e3331" class="indexterm-anchor"></a><a id="d13320e3333" class="indexterm-anchor"></a>某些<code class="codeph">Source</code>方法始终返回具有输入的<code class="codeph">Source</code> 。<code class="codeph">extract</code> ， <code class="codeph">position</code>或<code class="codeph">value</code>方法返回的<code class="codeph">Source</code>具有基本<code class="codeph">Source</code>作为输入。您可以使用这些方法生成一个<code class="codeph">Source</code>其元素是从另一个<code class="codeph">Source</code>的元素派生或过滤的。
                        </p>
                        <p><code class="codeph">value</code>方法返回一个<code class="codeph">Source</code> ，它具有基本<code class="codeph">Source</code>的元素，并具有基本<code class="codeph">Source</code>作为输入。您通常使用<code class="codeph">value</code>方法返回的<code class="codeph">Source</code>作为基础或<code class="codeph">join</code>方法的<code class="codeph">Source</code> ，或者有时作为比较<code class="codeph">Source</code> 。本章中的几个示例和<a href="making-queries-using-source-methods.html#GUID-B5D5AF5D-330E-46D3-8BD7-E84B1373E6A7">使用源方法进行查询使用</a> <code class="codeph">value</code>方法。
                        </p>
                        <p><code class="codeph">position</code>方法返回一个<code class="codeph">Source</code> ，它具有基本<code class="codeph">Source</code>的每个元素的位置，并且具有基本<code class="codeph">Source</code>作为输入。有关使用<code class="codeph">position</code>方法的<a href="making-queries-using-source-methods.html#GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68__CBBHFCIH">示例</a> ，请参见<a href="making-queries-using-source-methods.html#GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68__CBBHFCIH">示例6-4</a> 。
                        </p>
                        <p>当要加入的<code class="codeph">Source</code>对象的元素将<code class="codeph">Source</code>对象作为值时，可以使用<code class="codeph">extract</code>方法。对于使用<code class="codeph">extract</code>方法的<a href="understanding-source-objects.html#GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F__BABIJIFI">实例</a> ，参见<a href="understanding-source-objects.html#GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F__BABIJIFI">实施例5-12</a> ， <a href="making-queries-using-source-methods.html#GUID-6039C35F-361A-430F-9015-5687F072245A__CBBBGBGC">实施例6-8</a> ， <a href="making-queries-using-source-methods.html#GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBHGDGG">实施例6-13</a>和<a href="making-queries-using-source-methods.html#GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBFEDFJ">实施例6-14</a> 。
                        </p>
                     </div>
                  </div><a id="OLAAP276"></a><div class="props_rev_3"><a id="GUID-F0FE8FFC-D1D7-4B2B-9FEA-BB91521971A2" name="GUID-F0FE8FFC-D1D7-4B2B-9FEA-BB91521971A2"></a><h5 id="OLAAP-GUID-F0FE8FFC-D1D7-4B2B-9FEA-BB91521971A2" class="sect5"><span class="enumeration_section">5.4.3.3</span>输入类型</h5>
                     <div>
                        <p><a id="d13320e3480" class="indexterm-anchor"></a><a id="d13320e3486" class="indexterm-anchor"></a><a id="d13320e3492" class="indexterm-anchor"></a>由<code class="codeph">position</code>或<code class="codeph">value</code>方法派生的<code class="codeph">Source</code>的输入和<code class="codeph">MdmDimensionedObject</code>固有的输入是常规输入。一个普通的输入涉及所述的元素<code class="codeph">Source</code>与输入到的元素<code class="codeph">Source</code>与该输入相匹配。您可以通过调用<code class="codeph">getRegularInputs</code>方法获取常规输入。
                        </p>
                        <p><a id="d13320e3520" class="indexterm-anchor"></a> <code class="codeph">extract</code>方法返回的<code class="codeph">Source</code>的输入是提取输入。您可以通过调用<code class="codeph">getExtractionInputs</code>方法获取提取输入。
                        </p>
                     </div>
                  </div>
               </div><a id="OLAAP277"></a><div class="props_rev_3"><a id="GUID-41EDCE42-C277-433F-81D6-306148FC263D" name="GUID-41EDCE42-C277-433F-81D6-306148FC263D"></a><h4 id="OLAAP-GUID-41EDCE42-C277-433F-81D6-306148FC263D" class="sect4"><span class="enumeration_section">5.4.4</span>匹配源与输入</h4>
                  <div>
                     <p><a id="d13320e3569" class="indexterm-anchor"></a><a id="d13320e3575" class="indexterm-anchor"></a><a id="d13320e3581" class="indexterm-anchor"></a><a id="d13320e3585" class="indexterm-anchor"></a>在连接操作中， <code class="codeph">Source</code>与输入的匹配仅在基本<code class="codeph">Source</code>和连接的<code class="codeph">Source</code>之间发生。如果满足下列条件之一，则<code class="codeph">Source</code>与输入匹配。
                     </p>
                     <ol>
                        <li>
                           <p><code class="codeph">Source</code>与输入是同一个对象，或者是输入的子类型。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">Source</code>的输出与输入的对象相同，或者输出是输入的子类型。
                           </p>
                        </li>
                     </ol>
                     <p>连接操作按前面列表中显示的顺序查找条件。它以递归方式搜索<code class="codeph">Source</code>的输出列表，包括输出的任何输出，寻找与输入的匹配。搜索以第一个匹配的<code class="codeph">Source</code>结束。输入只能与一个<code class="codeph">Source</code>匹配。
                     </p>
                     <p>当一个<code class="codeph">Source</code>与一个输入被连接到一个<code class="codeph">Source</code>与输入，导出匹配<code class="codeph">Source</code>通过返回的<code class="codeph">join</code>方法具有涉及由该方法的参数中指定的元件基体的元件。派生的<code class="codeph">Source</code>没有输入。
                     </p>
                     <p>将<code class="codeph">Source</code>与输入匹配不会影响基本<code class="codeph">Source</code>或连接的<code class="codeph">Source</code>的输出。如果基本<code class="codeph">Source</code>的输出与已连接的<code class="codeph">Source</code>的输入匹配，则生成的<code class="codeph">Source</code>没有输入，但它具有输出。如果连接操作中的基本<code class="codeph">Source</code>或连接的<code class="codeph">Source</code>在操作中不匹配的输入，则不匹配的输入是结果<code class="codeph">Source</code>的输入。
                     </p>
                     <p><code class="codeph">join</code>方法的比较<code class="codeph">Source</code>不参与输入匹配。如果比较<code class="codeph">Source</code>有输入，则该输入不匹配，并且<code class="codeph">join</code>方法返回的<code class="codeph">Source</code>具有相同的输入。
                     </p>
                     <p>以下主题中的示例演示了如何将<code class="codeph">Source</code>与输入进行匹配。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D">匹配MdmAttribute的源输入</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-83F2CA40-C041-4733-A13F-3EC617942312">匹配度量的输入</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-55A3D7AA-68FF-4DCC-B7E9-22E38A799AD4">使用值Method通过输入派生源</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-D196A026-C589-401A-B312-001702278183">使用值Method选择源的值</a></p>
                        </li>
                        <li>
                           <p><a href="understanding-source-objects.html#GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F">使用提取方法组合源对象的元素</a></p>
                        </li>
                     </ul>
                  </div><a id="OLAAP279"></a><a id="OLAAP278"></a><div class="props_rev_3"><a id="GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D" name="GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D"></a><h5 id="OLAAP-GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D" class="sect5"><span class="enumeration_section">5.4.4.1</span>匹配<span class="enumeration_section">MdmAttribute</span>的源输入</h5>
                     <div>
                        <div class="section">
                           <p><a href="understanding-source-objects.html#GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D__BABJHBEG">实施例5-7</a>说明了的接合<code class="codeph">Source</code>用于<code class="codeph">MdmBaseAttribute</code>到<code class="codeph">Source</code>用于<code class="codeph">MdmPrimaryDimension</code> 。该示例从<code class="codeph">MdmPrimaryDimension</code>维度的<code class="codeph">MdmPrimaryDimension</code>获取本地值属性。该<code class="codeph">Source</code>为属性， <code class="codeph">locValAttr</code> ，具有<code class="codeph">Source</code>为<code class="codeph">MdmPrimaryDimension</code>作为输入。
                           </p>
                           <p>在示例中， <code class="codeph">locValAttr</code>是连接操作的基本<code class="codeph">Source</code> ， <code class="codeph">chanDim</code>是连接的<code class="codeph">Source</code> 。因为<code class="codeph">chanDim</code>是实例<code class="codeph">Source</code>为<code class="codeph">MdmPrimaryDimension</code>为CHANNEL_AWJ尺寸， <code class="codeph">chanDim</code>用的输入相匹配<code class="codeph">locValAttr</code> 。连接的结果是<code class="codeph">dimMembersWithLocalValue</code> ，它将<code class="codeph">chanDim</code>作为输出并且没有任何输入。
                           </p>
                           <p><code class="codeph">locValAttr</code> <code class="codeph">Source</code>有四个元素，因为CHANNEL_AWJ维度的四个成员中的每一个都具有不同的本地值。由连接操作<code class="codeph">dimMembersWithLocalValue</code>派生的<code class="codeph">Source</code>有四个元素。每个元素的值是维度成员和相关属性值。维度成员是输出中的值，属性值来自基数。
                           </p>
                           <p><a href="understanding-source-objects.html#GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D__BABJHBEG">例5-7</a>演示了如何匹配基本<code class="codeph">Source</code>与已连接<code class="codeph">Source</code>的输入。在该示例中， <code class="codeph">mdmDBSchema</code>是GLOBAL模式的<code class="codeph">MdmDatabaseSchema</code> 。
                           </p>
                           <p><code class="codeph">dimMembersWithLocalValue</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有下表中显示的值。输出值是从连接的<code class="codeph">Source</code> ， <code class="codeph">chanDim</code>派生的唯一维度成员值。基值来自基础<code class="codeph">Source</code> ， <code class="codeph">locValAttr</code> 。该表添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">输出值基值CHANNEL_PRIMARY :: TOTAL_CHANNEL :: TOTAL TANNAL CHANNEL_PRIMARY :: CHANNEL :: CAT CAT CHANNEL_PRIMARY :: CHANNEL :: DIR DIR CHANNEL_PRIMARY :: CHANNEL :: INT INT</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D__BABJHBEG">
                           <p class="titleinexample">示例5-7获取维成员的属性</p><pre class="oac_no_warn" dir="ltr">MdmStandardDimension mdmChanDim = mdmDBSchema.findOrCreateStandardDimension（“CHANNEL_AWJ”）; Source chanDim = mdmChanDim.getSource（）; Source locValAttr = mdmChanDim.getLocalValueAttribute（）。getSource（）;源dimMembersWithLocalValue = locValAttr.join（chanDim）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP281"></a><a id="OLAAP280"></a><div class="props_rev_3"><a id="GUID-83F2CA40-C041-4733-A13F-3EC617942312" name="GUID-83F2CA40-C041-4733-A13F-3EC617942312"></a><h5 id="OLAAP-GUID-83F2CA40-C041-4733-A13F-3EC617942312" class="sect5"><span class="enumeration_section">5.4.4.2</span>匹配度量的输入</h5>
                     <div>
                        <div class="section">
                           <p><a id="d13320e3924" class="indexterm-anchor"></a> <a href="understanding-source-objects.html#GUID-83F2CA40-C041-4733-A13F-3EC617942312__BABFIEJH">例5-8</a>演示了如何从度量中获取值。该示例将获取<code class="codeph">MdmCube</code>包含UNIT_PRICE措施，并得到了<code class="codeph">MdmBaseMeasure</code>从该多维数据集的措施。多维数据集和多维数据集的度量由PRODUCT_AWJ和TIME_AWJ维度标注。该示例获取这些维度的<code class="codeph">MdmPrimaryDimension</code>对象，并获取这些元数据对象的<code class="codeph">Source</code>对象。
                           </p>
                           <p>该<code class="codeph">Source</code>为度量， <code class="codeph">unitPrice</code> ，具有<code class="codeph">Source</code>为两个对象<code class="codeph">MdmPrimaryDimension</code>对象作为输入。该示例加入<code class="codeph">Source</code> ，用于与测量<code class="codeph">Source</code>的尺寸的对象。连接操作将度量的输入与维度的<code class="codeph">Source</code>对象进行匹配。
                           </p>
                           <p>示例性的第一连接的<code class="codeph">Source</code>为PRODUCT_AWJ尺寸与<code class="codeph">Source</code>的措施。<code class="codeph">unitPrice.join(prodDim)</code>操作派生一个<code class="codeph">Source</code> ，它具有来自<code class="codeph">unitPrice</code>基值，并将<code class="codeph">prodDim</code>作为输出。它还具有TIME_AWJ维度的<code class="codeph">Source</code>作为输入。接下来的联接操作加入<code class="codeph">Source</code>被派生<code class="codeph">unitPrice.join(prodDim)</code>与<code class="codeph">timeDim</code>的<code class="codeph">Source</code>为TIME_AWJ维度。该join操作匹配<code class="codeph">unitPrice.join(prodDim)</code>派生的<code class="codeph">Source</code>与<code class="codeph">timeDim</code> 。
                           </p>
                           <p>由第二个连接操作派生的<code class="codeph">Source</code>是<code class="codeph">pricesByProductAndTime</code> 。该<code class="codeph">Source</code>没有输入，并且PRODUCT_AWJ和TIME_AWJ维度的<code class="codeph">Source</code>对象作为输出。<code class="codeph">pricesByProductAndTime</code>的<code class="codeph">Cursor</code>包含每个时间值的每个产品值的价格。
                           </p>
                           <p><a id="d13320e4034" class="indexterm-anchor"></a>该示例最终调用<code class="codeph">pricesByProductAndTime</code>的<code class="codeph">count</code>方法。该方法返回<code class="codeph">NumberSource</code> <code class="codeph">numPricesByProductAndTime</code> ，它包含的元素的数量<code class="codeph">pricesByProductAndTime</code> <code class="codeph">Source</code> 。<code class="codeph">numPricesByProductAndTime</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>包含值4998，它是产品和时间元组的度量值数。
                           </p>
                           <p>为了产生<code class="codeph">Source</code>仅包含某些产品和时间的测量值，你需要加入<code class="codeph">Source</code>与测量<code class="codeph">Source</code>指定所需的维值的对象。您可以使用维度的主要<code class="codeph">Source</code>方法来生成此类选择。生成表示<code class="codeph">Source</code>的值选择的<code class="codeph">Source</code>的一种方法是使用<code class="codeph">value</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-83F2CA40-C041-4733-A13F-3EC617942312__BABFIEJH">
                           <p class="titleinexample">例5-8获取测量值</p>
                           <p><a id="d13320e4095" class="indexterm-anchor"></a>此示例演示如何匹配基本<code class="codeph">Source</code>与已连接<code class="codeph">Source</code>的输入。在该示例中， <code class="codeph">mdmDBSchema</code>是GLOBAL模式的<code class="codeph">MdmDatabaseSchema</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">MdmCube mdmPriceCube = mdmDBSchema.findOrCreateCube（“PRICE_CUBE_AWJ”）; MdmBaseMeasure mdmUnitPrice = mdmPriceCube.findOrCreateBaseMeasure（“UNIT_PRICE”）; MdmStandardDimension mdmProdDim = mdmDBSchema.findOrCreateStandardDimension（“PRODUCT_AWJ”）; MdmTimeDimension mdmTimeDim = mdmDBSchema.findOrCreateTimeDimension（“TIME_AWJ”）; Source prodDim = mdmProdDim.getSource（）;源timeDim = mdmTimeDim.getSource（）;源unitPrice = mdmUnitPrice.getSource（）;来源priceByProductAndTime = unitPrice.join（prodDim）.join（timeDim）; NumberSource numPricesByProductAndTime = pricesByProductAndTime.count（）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP283"></a><a id="OLAAP282"></a><div class="props_rev_3"><a id="GUID-55A3D7AA-68FF-4DCC-B7E9-22E38A799AD4" name="GUID-55A3D7AA-68FF-4DCC-B7E9-22E38A799AD4"></a><h5 id="OLAAP-GUID-55A3D7AA-68FF-4DCC-B7E9-22E38A799AD4" class="sect5"><span class="enumeration_section">5.4.4.3</span>使用值方法导出带输入的源</h5>
                     <div>
                        <div class="example" id="GUID-55A3D7AA-68FF-4DCC-B7E9-22E38A799AD4__BABFCCIA">
                           <p class="titleinexample">例5-9使用值方法将源关联到自身</p>
                           <p><a id="d13320e4155" class="indexterm-anchor"></a><a id="d13320e4161" class="indexterm-anchor"></a>在此示例中， <code class="codeph">lettersValue</code> <code class="codeph">Source</code>由<code class="codeph">lettersValue</code> <code class="codeph">letters.value()</code>方法返回。<code class="codeph">lettersValue</code> <code class="codeph">Source</code>将<code class="codeph">letters</code>作为输入。输入表示<code class="codeph">Source</code>与输入的值之间的关系以及与输入匹配的<code class="codeph">Source</code>的值。
                           </p>
                           <p>连接操作将<code class="codeph">letters</code>作为基础<code class="codeph">Source</code> ，将<code class="codeph">lettersValue</code>作为连接的<code class="codeph">Source</code> 。基本的<code class="codeph">Source</code> ， <code class="codeph">letters</code> ，与<code class="codeph">lettersValue</code>的输入匹配，也是<code class="codeph">letters</code> ，因为它们是相同的。通过join操作生成的<code class="codeph">Source</code> ， <code class="codeph">lettersByLettersValue</code>将<code class="codeph">lettersValue</code>作为输出。它没有输入。<code class="codeph">lettersByLettersValue</code>每个元素都有一个来自<code class="codeph">letters</code>的基值和来自<code class="codeph">lettersValue</code>的相关值。
                           </p><pre class="oac_no_warn" dir="ltr">源字母= dp.createListSource（new String [] {“A”，“B”，“C”}）;源lettersValue = letters.value（）;源lettersByLettersValue = letters.join（lettersValue）;</pre><p><code class="codeph">lettersByLettersValue</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有下表中显示的值。该表添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">输出值基准值AA BB CC</pre><p>由于<code class="codeph">lettersByLettersValue</code>仅包含基础和已关联的<code class="codeph">Source</code>对象的值，因此<code class="codeph">lettersByLettersValue</code> <code class="codeph">Source</code>的<code class="codeph">Cursor</code>的基值与输出值相同。如果基础和已连接的<code class="codeph">Source</code>对象不相关，如<code class="codeph">letters.join(letters)</code> ，则join操作生成的<code class="codeph">Source</code>将包含基础的Cartesian产品和已连接的<code class="codeph">Source</code>对象。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP285"></a><a id="OLAAP286"></a><a id="OLAAP284"></a><div class="props_rev_3"><a id="GUID-D196A026-C589-401A-B312-001702278183" name="GUID-D196A026-C589-401A-B312-001702278183"></a><h5 id="OLAAP-GUID-D196A026-C589-401A-B312-001702278183" class="sect5"><span class="enumeration_section">5.4.4.4</span>使用值方法选择源的值</h5>
                     <div>
                        <div class="example" id="GUID-D196A026-C589-401A-B312-001702278183__BABBBAFI">
                           <p class="titleinexample">示例5-10使用值Method选择源的元素</p>
                           <p><a id="d13320e4323" class="indexterm-anchor"></a><a id="d13320e4327" class="indexterm-anchor"></a><a id="d13320e4333" class="indexterm-anchor"></a><a id="d13320e4337" class="indexterm-anchor"></a>通过使用<code class="codeph">value</code>方法，您可以派生一个<code class="codeph">Source</code> ，它是另一个<code class="codeph">Source</code>元素的选择。此示例从<a href="understanding-source-objects.html#GUID-F4052FE8-9065-4EBF-87F4-6A087FFF4A1D__BABJHBEG">示例5-7中</a>的PRODUCT_AWJ维度的<code class="codeph">Source</code>选择两个元素。此实施例证明碱<code class="codeph">Source</code>与所述接合的输入匹配<code class="codeph">Source</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">源productsToSelect = dp.createListSource（new String [] {“PRODUCT_PRIMARY :: ITEM :: ENVY EXE”，“PRODUCT_PRIMARY :: ITEM :: ENVY STD”}）; Source selectedProducts = prodDim.join（prodDim.value（），productsToSelect，Source。COMPARISON_RULE_SELECT，false）; //隐藏输出
</pre><p><code class="codeph">productsToSelect</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">PRODUCT_PRIMARY :: ITEM :: ENVY EXE PRODUCT_PRIMARY :: ITEM :: ENVY STD</pre><p><code class="codeph">selectedProducts</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">PRODUCT_PRIMARY :: ITEM :: ENVY EXE PRODUCT_PRIMARY :: ITEM :: ENVY STD</pre><p><a id="d13320e4392" class="indexterm-anchor"></a>两个<code class="codeph">Source</code>对象包含相同的值。但是，对象的类型是不同的。<code class="codeph">productsToSelect</code> <code class="codeph">Source</code>的类型是String数据类型的<code class="codeph">FundamentalMetadataObject</code>的<code class="codeph">Source</code> 。<code class="codeph">selectedProducts</code> <code class="codeph">Source</code>的类型是<code class="codeph">prodDim</code>因为<code class="codeph">selectedProducts</code>派生自<code class="codeph">prodDim</code> 。因此， <code class="codeph">selectedProducts</code>是的子类型<code class="codeph">prodDim</code> ，因此它可以与一个相匹配<code class="codeph">Source</code>具有<code class="codeph">Source</code>为PRODUCT_AWJ尺寸作为输入，如图在下一个例子。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-D196A026-C589-401A-B312-001702278183__BABBCGED">
                           <p class="titleinexample">示例5-11使用派生源对象选择度量值</p>
                           <p><a id="d13320e4445" class="indexterm-anchor"></a>此示例从两个维度的<code class="codeph">Source</code>对象中选择元素，然后获取所选维度成员的度量值。该示例使用与<a href="understanding-source-objects.html#GUID-83F2CA40-C041-4733-A13F-3EC617942312__BABFIEJH">示例5-8中</a>相同的尺寸和度量。在这个例子中，然而， <code class="codeph">Source</code>与所述的输入相匹配的对象<code class="codeph">Source</code>的措施不是<code class="codeph">Source</code>的尺寸的对象。相反，它们是维度的<code class="codeph">Source</code>对象的子类型。子类型指定维度的选定成员。通过将度量与尺度<code class="codeph">pricesForSelectedProductsAndTimes</code>联而得到的<code class="codeph">Source</code>具有六个元素，这些元素仅指定三个时间值的两个产品的度量值，而不是<a href="understanding-source-objects.html#GUID-83F2CA40-C041-4733-A13F-3EC617942312__BABFIEJH">示例5-8</a>中的<code class="codeph">pricesByProductAndTime</code> <code class="codeph">Source</code>的4998个元素。在此示例中， <code class="codeph">mdmDBSchema</code>是GLOBAL模式的<code class="codeph">MdmDatabaseSchema</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">//创建产品和时间维度成员的列表。源productsToSelect = dp.createListSource（new String [] {“PRODUCT_PRIMARY :: ITEM :: ENVY EXE”，“PRODUCT_PRIMARY :: ITEM :: ENVY STD”}）;源timesToSelect = dp.createListSource（new String [] {“CALENDAR_YEAR :: MONTH :: 2000.01”，“CALENDAR_YEAR :: MONTH :: 2001.01”，“CALENDAR_YEAR :: MONTH :: 2002.01”}）; //获取PRICE_CUBE_AWJ多维数据集。MdmCube mdmPriceCube = mdmDBSchema.findOrCreateCube（“PRICE_CUBE_AWJ”）; //从多维数据集中获取UNIT_PRICE度量。MdmBaseMeasure mdmUnitPrice = mdmPriceCube.findOrCreateBaseMeasure（“UNIT_PRICE”）; //获取PRODUCT_AWJ和TIME_AWJ尺寸。MdmStandardDimension mdmProdDim = mdmDBSchema.findOrCreateStandardDimension（“PRODUCT_AWJ”）; MdmTimeDimension mdmTimeDim = mdmDBSchema.findOrCreateTimeDimension（“TIME_AWJ”）; //获取维度和度量的Source对象。Source prodDim = mdmProdDim.getSource（）;源timeDim = mdmTimeDim.getSource（）;源unitPrice = mdmUnitPrice.getSource（）; //使用value方法，派生指定所选//维度成员的Source对象。Source selectedProducts = prodDim.join（prodDim.value（），productsToSelect，Source。COMPARISON_RULE_SELECT，false）; Source selectedTimes = timeDim.join（timeDim.value（），timesToSelect，Source。COMPARISON_RULE_SELECT，false）; //派生一个Source，指定所选产品的unitPrice值和时间。来源priceForSelectedProductsAndTimes = unitPrice.join（selectedProducts）.join（selectedTimes）;</pre><p><code class="codeph">pricesForSelectedProductsAndTimes</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有下表中显示的值。该表添加了标题。
                           </p><pre class="oac_no_warn" dir="ltr">月产品价格----------------------------- ------------------ ------------- ------- CALENDAR_YEAR :: MONTH :: 2000.01 PRODUCT_PRIMARY :: ITEM :: ENVY EXE 3358.02 CALENDAR_YEAR :: MONTH :: 2000.01 PRODUCT_PRIMARY :: ITEM :: ENVY STD 3000.11 CALENDAR_YEAR :: MONTH :: 2001.01 PRODUCT_PRIMARY :: ITEM :: ENVY EXE 3223.28 CALENDAR_YEAR :: MONTH :: 2001.01 PRODUCT_PRIMARY :: ITEM :: ENVY STD 2426.07 CALENDAR_YEAR :: MONTH :: 2002.01 PRODUCT_PRIMARY :: ITEM :: ENVY EXE 3008.95 CALENDAR_YEAR :: MONTH :: 2002.01 PRODUCT_PRIMARY :: ITEM :: ENVY STD 2140.71</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP288"></a><a id="OLAAP287"></a><div class="props_rev_3"><a id="GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F" name="GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F"></a><h5 id="OLAAP-GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F" class="sect5"><span class="enumeration_section">5.4.4.5</span>使用提取方法组合源对象的元素</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">extract</code>方法派生一个<code class="codeph">Source</code> ，它具有基本<code class="codeph">Source</code>作为输入。当<code class="codeph">Source</code>的元素值是<code class="codeph">Source</code>对象本身时，可以使用<code class="codeph">extract</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-677C41E0-21D4-4A9D-9703-E5EB312A197F__BABIJIFI">
                           <p class="titleinexample">例5-12提取源的元素</p>
                           <p><a id="d13320e4566" class="indexterm-anchor"></a>此示例使用<code class="codeph">selectValues</code>方法从<code class="codeph">StringSource</code>维度的<code class="codeph">StringSource</code>派生两个元素选择。<code class="codeph">selectValues</code>方法是<a href="understanding-source-objects.html#GUID-D196A026-C589-401A-B312-001702278183__BABBBAFI">示例5-10</a>和<a href="understanding-source-objects.html#GUID-D196A026-C589-401A-B312-001702278183__BABBCGED">示例5-11</a>中生成<code class="codeph">selectedProducts</code>和<code class="codeph">selectedTimes</code> <code class="codeph">Source</code>对象的方法的完整<code class="codeph">join</code>签名的快捷方式。
                           </p>
                           <p><a id="d13320e4598" class="indexterm-anchor"></a>此示例创建一个列表<code class="codeph">Source</code> ， <code class="codeph">sourcesToCombine</code> ，它将两个派生的<code class="codeph">Source</code>对象作为元素值。<code class="codeph">sourcesToCombine.extract()</code>方法生成<code class="codeph">sourcesToCombineWithAnInput</code> ，它是<code class="codeph">sourcesToCombine</code>作为输入的<code class="codeph">Source</code> 。加入操作<code class="codeph">sourcesToCombineWithAnInput.joinHidden(sourcesToCombine)</code>的输入相匹配<code class="codeph">sourcesToCombineWithAnInput</code>与接合<code class="codeph">sourcesToCombine</code>并产生<code class="codeph">combinedSources</code> ，它没有输入或输出。这种<code class="codeph">Source</code>元素组合的快捷方式是<code class="codeph">appendValues</code>方法。
                           </p><pre class="oac_no_warn" dir="ltr">MdmStandardDimension mdmProdDim = mdmDBSchema.findOrCreateStandardDimension（“PRODUCT_AWJ”）; StringSource prodDim =（StringSource）mdmProdDim.getSource（）; Source productsToSelect = prodDim.selectValues（new String [] {“PRODUCT_PRIMARY :: ITEM :: ENVY ABM”，“PRODUCT_PRIMARY :: ITEM :: ENVY EXE”，“PRODUCT_PRIMARY :: ITEM :: ENVY STD”}）;来源moreProductsToSelect = prodDim.selectValues（new String [] {“PRODUCT_PRIMARY :: ITEM :: SENT FIN”，“PRODUCT_PRIMARY :: ITEM :: SENT MM”，“PRODUCT_PRIMARY :: ITEM :: SENT STD”}）;源sourceToCombine = dp.createListSource（new Source [] {productsToSelect，moreProductsToSelect}）;源sourceToCombineWithAnInput = sourcesToCombine.extract（）; Source combinedProducts = sourcesToCombineWithAnInput.joinHidden（sourcesToCombine）;</pre><p><code class="codeph">combinedProducts</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">PRODUCT_PRIMARY :: ITEM :: ENVY ABM PRODUCT_PRIMARY :: ITEM :: ENVY EXE PRODUCT_PRIMARY :: ITEM :: ENVY STD PRODUCT_PRIMARY :: ITEM :: SENT FIN PRODUCT_PRIMARY :: ITEM :: SENT MM PRODUCT_PRIMARY :: ITEM :: SENT STD</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="OLAAP290"></a><a id="OLAAP289"></a><div class="props_rev_3"><a id="GUID-38CC13B9-38A3-4D0A-87B7-13A5BFC2EB6E" name="GUID-38CC13B9-38A3-4D0A-87B7-13A5BFC2EB6E"></a><h3 id="OLAAP-GUID-38CC13B9-38A3-4D0A-87B7-13A5BFC2EB6E" class="sect3"><span class="enumeration_section">5.5</span>描述参数化源对象</h3>
               <div>
                  <p><a id="d13320e4712" class="indexterm-anchor"></a><a id="d13320e4716" class="indexterm-anchor"></a><a id="d13320e4720" class="indexterm-anchor"></a><a id="d13320e4724" class="indexterm-anchor"></a>参数化<code class="codeph">Source</code>对象提供了一种通过更改参数化的<code class="codeph">Source</code>指定的元素集来指定查询和检索查询的不同结果集的方法。使用<code class="codeph">Parameter</code>的<code class="codeph">createSource</code>方法创建参数化<code class="codeph">Source</code> 。<code class="codeph">Parameter</code>提供参数化<code class="codeph">Source</code>指定的值。
                  </p>
                  <p>本主题中的示例是使用<code class="codeph">Parameter</code>对象的非常简单的演示。<code class="codeph">Parameter</code>典型用法是指定多维数据集的页面边缘，如<a href="making-queries-using-source-methods.html#GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA__CBAGDGHE">例6-9</a>所示。<code class="codeph">Parameter</code>另一个用途是仅从服务器获取您当前需要的元素集。<a href="making-queries-using-source-methods.html#GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638__CBBCFEBC">例6-15</a>演示了如何使用<code class="codeph">Parameter</code>对象来获取不同的元素集。
                  </p>
                  <p>当你创建一个<code class="codeph">Parameter</code>对象，您提供的初始值<code class="codeph">Parameter</code> 。然后使用<code class="codeph">Parameter</code>创建参数化的<code class="codeph">Source</code> 。在指定查询时包含参数化的<code class="codeph">Source</code> 。您为查询创建一个<code class="codeph">Cursor</code> 。您可以使用<code class="codeph">setValue</code>方法更改<code class="codeph">Parameter</code>的值，该方法更改查询指定的元素集。使用相同的<code class="codeph">Cursor</code> ，您可以检索新的值集。
                  </p>
                  <p><a id="d13320e4799" class="indexterm-anchor"></a><a id="d13320e4803" class="indexterm-anchor"></a><a id="d13320e4807" class="indexterm-anchor"></a><a id="d13320e4811" class="indexterm-anchor"></a><a id="d13320e4815" class="indexterm-anchor"></a>此示例演示如何使用<code class="codeph">Parameter</code>和参数化<code class="codeph">Source</code>来指定维度中的成员。该示例获取PRODUCT_AWJ维度的<code class="codeph">MdmStandardDimension</code> ，并获取<code class="codeph">MdmStandardDimension</code>的<code class="codeph">Source</code>作为<code class="codeph">StringSource</code> 。
                  </p>
                  <p>该示例创建一个<code class="codeph">StringParameter</code>对象，该对象具有维度成员作为初始值。然后，它创建一个参数化的<code class="codeph">Source</code> ， <code class="codeph">paramProdSel</code> ，通过使用<code class="codeph">createSource</code>所述的方法<code class="codeph">StringParameter</code> 。接下来，它使用<code class="codeph">paramProdSel</code>作为选择维度成员的连接操作中的比较<code class="codeph">Source</code> 。
                  </p>
                  <p>该示例获取维度的本地值属性的<code class="codeph">Source</code> 。它加入那个<code class="codeph">Source</code> ， <code class="codeph">locValAttr</code> ，与<code class="codeph">paramProdSel</code> 。该连接操作生成<code class="codeph">dimMemberWithLocalValue</code> <code class="codeph">Source</code> 。
                  </p>
                  <p>该示例为<code class="codeph">dimMemberWithLocalValue</code>创建<code class="codeph">Cursor</code>并显示<code class="codeph">Cursor</code>的值。复位后<code class="codeph">Cursor</code>位置和变更的值<code class="codeph">prodParam</code> <code class="codeph">StringParameter</code> ，该示例显示的值<code class="codeph">Cursor</code>一次。
                  </p>
                  <p><code class="codeph">dp</code>对象是<code class="codeph">DataProvider</code> 。<code class="codeph">getContext</code>方法获取一个<code class="codeph">Context11g</code>对象，该对象具有提交当前<code class="codeph">Transaction</code>的方法和显示<code class="codeph">Cursor</code>值的方法。
                  </p>
                  <div class="example" id="GUID-38CC13B9-38A3-4D0A-87B7-13A5BFC2EB6E__CBAGGBDB">
                     <p class="titleinexample">示例5-13使用参数化源更改尺寸选择</p><pre class="oac_no_warn" dir="ltr">MdmStandardDimension mdmProdDim = mdmDBSchema.findOrCreateStandardDimension（“PRODUCT_AWJ”）; StringSource prodDim =（StringSource）mdmProdDim.getSource（）; StringParameter prodParam = new StringParameter（dp，“PRODUCT_PRIMARY :: FAMILY :: LTPC”）; Source prodParamSrc = prodParam.createSource（）;源paramProdSel = prodDim.join（prodDim.value（），prodParamSrc）;源locValAttr = mdmProdDim.getLocalValueAttribute（）。getSource（）;来源dimMemberWithLocalValue = locValAttr.join（paramProdSel）; //提交交易。的getContext（）提交（）; //为源创建一个光标。CursorManager cursorMngr = dp.createCursorManager（dimMemberWithLocalValue）; Cursor cursor = cursorMngr.createCursor（）; //显示Cursor的值。。的getContext（）displayCursor（光标）; //更改产品参数值。prodParam.setValue（ “PRODUCT_PRIMARY :: FAMILY :: DTPC”）; //将光标位置重置为1 cursor.setPosition（1）; //再次显示Cursor的值。。的getContext（）displayCursor（光标）;</pre><p><code class="codeph">dimMemberWithLocalValue</code>的<code class="codeph">Cursor</code>显示以下内容。
                     </p><pre class="oac_no_warn" dir="ltr">PRODUCT_PRIMARY :: FAMILY :: LTPC，LTPC</pre><p>改变的值后<code class="codeph">StringParameter</code>和复位的位置<code class="codeph">Cursor</code> ，该<code class="codeph">Cursor</code>用于<code class="codeph">dimMemberWithLocalValue</code>显示以下。
                     </p><pre class="oac_no_warn" dir="ltr">PRODUCT_PRIMARY :: FAMILY :: DTPC，DTPC</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="00045.using-pipelined-and-parallel-table-functions.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用流水线和并行表函数</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00"></meta>
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96431-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-user-defined-aggregate-functions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="designing-data-cartridges.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-user-defined-aggregate-functions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="designing-data-cartridges.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="building-data-cartridges.html" property="item" typeof="WebPage"><span property="name">构建数据磁带</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用流水线和并行表函数</li>
            </ol>
            <a id="GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4" name="GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4"></a><a id="ADDCI2140"></a>
            
            <h2 id="ADDCI-GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4" class="sect2"><span class="enumeration_chapter">13</span>使用流水线和并行表功能</h2>
         </header>
         <div class="ind">
            <div>
               <p>表函数和通用数据类型<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>通常与表函数一起使用。
               </p>
            </div><a id="ADDCI4678"></a><a id="ADDCI4679"></a><a id="ADDCI4677"></a><div class="props_rev_3"><a id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C" name="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C"></a><h3 id="ADDCI-GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C" class="sect3"><span class="enumeration_section">13.1</span>表函数概述</h3>
               <div>
                  <p>表函数是生成可以像物理数据库表一样查询的行集合（嵌套表或varray）的函数。您在查询的<code class="codeph">FROM</code>子句中使用表函数，如数据库表的名称。
                  </p>
                  <p>表函数可以将行集合作为输入。输入集合参数可以是集合类型或<code class="codeph">REF CURSOR</code> 。</p>
                  <p>表函数可以并行执行，并且返回的行可以直接流式传输到下一个进程而无需中间分段。表函数返回的集合中的行也可以流水线化;这意味着它们在生成时被迭代返回，而不是在完成表函数输入的所有处理后在单个批处理中返回。</p>
                  <p>表函数的流式传输，流水线操作和并行执行可以通过以下方式提高性能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>通过启用表函数的多线程并发执行</p>
                     </li>
                     <li>
                        <p>通过消除进程之间的中间分段</p>
                     </li>
                     <li>
                        <p>通过改进查询响应时间：对于非流水线表函数，必须构造表函数返回的整个集合，并在查询返回单个结果行之前将其返回到服务器。流水线操作可以在生成行时迭代地返回行。这也减少了表函数所需的内存，因为对象缓存不必实现整个集合。</p>
                     </li>
                     <li>
                        <p>通过迭代地提供表函数返回的集合中的结果行，因为生成行而不是等待整个集合在表或内存中暂存，然后返回整个集合</p>
                     </li>
                  </ul>
                  <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__CIHHJFCF">图13-1</a>显示了一个典型的数据处理场景，在最终加载到数据库之前，数据经过几个（在本例中为三个）转换，由表函数实现。在这种情况下，表函数不是并行运行的，并且必须在每次转换后暂存整个结果集合。
                  </p>
                  <div class="figure" id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__CIHHJFCF">
                     <p class="titleinfigure">图13-1具有非并行，非流水线表函数的典型数据处理</p><img src="img/addci044.gif" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/addci044.html"><br><a href="img_text/addci044.html">“图13-1具有非并行，非流水线表函数的典型数据处理”的描述</a></div>
                  <!-- class="figure" -->
                  <p>相比之下， <a href="using-pipelined-and-parallel-table-functions.html#GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__I1006439">图13-2</a>显示了流和并行执行如何简化相同的场景。
                  </p>
                  <div class="figure" id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__I1006439">
                     <p class="titleinfigure">图13-2使用流水线和并行执行的数据处理</p><img src="img/addci045.gif" alt="下面是图13-2的描述" title="下面是图13-2的描述" longdesc="img_text/addci045.html"><br><a href="img_text/addci045.html">“图13-2使用流水线和并行执行的数据处理”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ADDCI4680"></a><div class="props_rev_3"><a id="GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF" name="GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF"></a><h3 id="ADDCI-GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF" class="sect3"><span class="enumeration_section">13.2</span>表函数概念</h3>
               <div>
                  <p>考虑表函数以及与这些表函数的流水线操作和并行执行相关的一些概念。</p>
               </div><a id="ADDCI4682"></a><a id="ADDCI4683"></a><a id="ADDCI4684"></a><a id="ADDCI4685"></a><a id="ADDCI4681"></a><div class="props_rev_3"><a id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED" name="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED"></a><h4 id="ADDCI-GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED" class="sect4"><span class="enumeration_section">13.2.1</span>表函数</h4>
                  <div>
                     <p>表函数返回一个集合类型实例，可以通过调用查询的<code class="codeph">FROM</code>子句中的函数来查询表。表函数使用<code class="codeph">TABLE</code>关键字。
                     </p>
                     <p>以下示例显示了一个表函数<code class="codeph">GetBooks</code> ，它将<code class="codeph">CLOB</code>作为输入并返回集合类型<code class="codeph">BookSet_t</code>的实例。<code class="codeph">CLOB</code>列以某种格式（专有或遵循诸如XML之类的标准）存储书籍的目录列表。table函数返回所有目录及其相应的图书清单。集合类型<code class="codeph">BookSet_t</code>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBGIFJ">例13-1中</a>定义。
                     </p>
                     <p><code class="codeph">CLOB</code>存储在表<code class="codeph">Catalogs</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHECFFI">例13-2所示</a> 。
                     </p>
                     <p>函数<code class="codeph">GetBooks()</code>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBIIEH">例13-3中</a>定义。
                     </p>
                     <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHEJHJB">例13-4中</a>的查询返回所有目录及其相应的图书清单。
                     </p>
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBGIFJ">
                        <p class="titleinexample">示例13-1创建集合类型</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（名称VARCHAR2（100），作者VARCHAR2（30），抽象VARCHAR2（1000））; CREATE TYPE BookSet_t AS TABLE of Book_t;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHECFFI">
                        <p class="titleinexample">例13-2在表中存储Clob</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE目录（名称VARCHAR2（30），cat CLOB）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBIIEH">
                        <p class="titleinexample">示例13-3创建返回集合类型的函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（一个CLOB）返回BookSet_t;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHEJHJB">
                        <p class="titleinexample">示例13-4在查询中使用集合类型</p><pre class="oac_no_warn" dir="ltr">SELECT c.name，Book.name，Book.author，Book.abstract FROM Catalogs c，TABLE（GetBooks（c.cat））Book;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4686"></a><div class="props_rev_3"><a id="GUID-4382D7CF-942A-479F-9726-2C801BE614FB" name="GUID-4382D7CF-942A-479F-9726-2C801BE614FB"></a><h4 id="ADDCI-GUID-4382D7CF-942A-479F-9726-2C801BE614FB" class="sect4"><span class="enumeration_section">13.2.2</span>流水线表功能</h4>
                  <div>
                     <p>如果生产者（转换）生成消费者（转换）消耗数据，则数据被称为流水线，而不是在输入到下一个转换之前在表或缓存中暂存。</p>
                     <p>管道传输使表函数能够更快地返回行，并且可以减少缓存表函数结果所需的内存。</p>
                     <p>流水线表函数可以在子集中返回表函数的结果集合。返回的集合的行为类似于可以根据需要获取的流。这使得可以使用像虚拟表这样的表函数。</p>
                     <p>流水线表功能可以通过两种方式实现：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在本机PL / SQL方法中，使用者和生产者可以在单独的执行线程上运行（在相同或不同的进程上下文中），并通过管道或排队机制进行通信。这种方法类似于协同例程执行。</p>
                        </li>
                        <li>
                           <p>在接口方法中，使用者和生产者在同一个执行线程上运行。生成器在生成一组结果后显式地将控件返回给使用者。此外，生产者缓存当前状态，以便当消费者再次调用它时，它可以从中断状态恢复。</p>
                           <p>接口方法要求您以过程语言实现一组定义良好的接口。</p>
                        </li>
                     </ul>
                     <p>协同例程执行模型为实现流水线表函数提供了一种更简单的本机PL / SQL机制，但该模型不能用于用C或Java编写的表函数。另一方面，接口方法可以。接口方法要求生产者在返回之前将当前状态信息保存在上下文对象中，以便可以在下次调用时恢复此状态。</p>
                     <p>在本讨论中，术语<span class="italic">表函数</span>指的是<span class="italic">流水线</span>表函数 - 一个表函数，它以迭代的流水线方式返回集合。
                     </p>
                  </div>
               </div><a id="ADDCI4690"></a><a id="ADDCI4688"></a><a id="ADDCI4689"></a><a id="ADDCI4687"></a><div class="props_rev_3"><a id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265" name="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265"></a><h4 id="ADDCI-GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265" class="sect4"><span class="enumeration_section">13.2.3</span>具有REF CURSOR参数的流水线表函数</h4>
                  <div>
                     <p>一个<a id="d38518e483" class="indexterm-anchor"></a> pipelined table函数可以接受常规函数接受的任何参数。接受<code class="codeph">REF CURSOR</code>作为参数的表函数可以用作转换函数。也就是说，它可以使用<code class="codeph">REF CURSOR</code>来获取输入行，对它们执行一些转换，然后将结果输出（使用接口方法或本机PL / SQL方法）。
                     </p>
                     <p>例如，以下代码<code class="codeph">StockPivot</code>绘了定义<code class="codeph">StockPivot</code>函数的声明。此函数将类型的行（ <code class="codeph">Ticker, OpenPrice, ClosePrice</code> ）转换为表格的两行（ <code class="codeph">Ticker, PriceType, Price</code> ）。为行（ <code class="codeph">"ORCL", 41, 42</code> ）调用<code class="codeph">StockPivot</code>生成两行：（ <code class="codeph">"ORCL", "O", 41</code> ）和（ <code class="codeph">"ORCL", "C", 42</code> ）。
                     </p>
                     <p>表函数的输入数据可能来自表<code class="codeph">StockTable</code>等源：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE StockTable（ticker VARCHAR（4），openprice NUMBER，closeprice NUMBER）;</pre><p>声明在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">例13-5中</a> 。
                     </p>
                     <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHIGGCC">例13-6</a>使用<code class="codeph">StockPivot</code>表函数。
                     </p>
                     <p>在前面的查询中，流水线表函数<code class="codeph">StockPivot</code>从<code class="codeph">CURSOR</code>子查询<code class="codeph">SELECT * FROM StockTable</code> <code class="codeph">StockPivot</code>获取行，执行转换，并将结果作为表传递回用户。该函数为每个输入行生成两个输出行（集合元素）。
                     </p>
                     <p>请注意，当<code class="codeph">CURSOR</code>子查询从SQL传递到<code class="codeph">REF CURSOR</code>函数参数时，如前面的示例所示，当函数开始执行时，引用的游标将打开。
                     </p>
                     <div class="section">
                        <p>另请注意，基于表函数的<code class="codeph">REF CURSOR</code>变量不允许使用游标操作： <code class="codeph">SELECT FOR UPDATE</code>和<code class="codeph">WHERE CURRENT OF</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__GUID-1CB8B210-E43C-4EF3-9103-7979E2F93286">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B">流水线表函数：接口方法</a>使用接口方法在C和Java中完整实现此表函数的<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B">示例</a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">
                        <p class="titleinexample">示例13-5使用REF CURSOR参数声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">- 为表函数的输出集合创建类型 - 和集合元素CREATE TYPE TickerType AS OBJECT（ticker VARCHAR2（4），PriceType VARCHAR2（1），price NUMBER）; CREATE TYPE TickerTypeSet AS TABLE OF TickerType; - 定义引用游标类型CREATE PACKAGE refcur_pkg IS TYPE refcur_t IS REF CURSOR RETURN StockTable％ROWTYPE; END refcur_pkg; /  - 创建表函数CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED ...; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHIGGCC">
                        <p class="titleinexample">例13-6使用具有REF CURSOR参数的流水线表函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4691"></a><div class="props_rev_3"><a id="GUID-15ED880C-113D-4B44-8732-D70A0AAAD405" name="GUID-15ED880C-113D-4B44-8732-D70A0AAAD405"></a><h4 id="ADDCI-GUID-15ED880C-113D-4B44-8732-D70A0AAAD405" class="sect4"><span class="enumeration_section">13.2.4</span>表函数的并行执行</h4>
                  <div>
                     <p>同<a id="d38518e639" class="indexterm-anchor"></a>并行执行出现在<code class="codeph">SELECT</code>列表中的函数，该函数的执行被推送到多个从属扫描进程并由其执行。这些都在函数输入数据的一段上执行函数。
                     </p>
                     <p>例如，查询</p><pre class="oac_no_warn" dir="ltr">SELECT f（col1）FROM选项卡;</pre><p>如果<code class="codeph">f</code>是纯函数，则并行化。从属扫描过程执行的SQL类似于：</p><pre class="oac_no_warn" dir="ltr">SELECT f（col1）FROM tab WHERE ROWID BETWEEN：b1 AND：b2;</pre><p>每个从属扫描都在一系列rowid上运行，并将函数<code class="codeph">f</code>应用于每个包含的行。然后通过扫描过程执行函数<code class="codeph">f</code> ;它不是独立运行的。
                     </p>
                     <p>与<code class="codeph">SELECT</code>列表中出现的函数不同，在<code class="codeph">FROM</code>子句中调用表函数并返回集合。这会影响表函数输入数据在从属扫描之间进行分区的方式，因为分区方法必须适合表函数执行的操作。（例如， <code class="codeph">ORDER BY</code>操作要求输入进行范围分区，而<code class="codeph">GROUP BY</code>操作要求输入进行散列分区。）
                     </p>
                     <p>表函数本身在其声明中指定适合它的分区方法，如<span class="q">“ <a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0">输入数据分区</a> ”中所述</span> 。然后，该功能以两阶段操作执行。首先，一组从属进程按照函数声明中的指示对数据进行分区;然后第二组从属扫描在分区数据上并行执行表函数。以下查询中的表函数具有<code class="codeph">REF CURSOR</code>参数：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab）））;</pre><p>扫描由一组从属进程执行，这些从属进程将行（基于函数声明中指定的分区方法）重新分配给实际并行执行函数<code class="codeph">f</code>的第二组从属进程。
                     </p>
                  </div>
               </div>
            </div><a id="ADDCI4692"></a><div class="props_rev_3"><a id="GUID-6785018C-8D7E-453B-A6D0-843648118EA6" name="GUID-6785018C-8D7E-453B-A6D0-843648118EA6"></a><h3 id="ADDCI-GUID-6785018C-8D7E-453B-A6D0-843648118EA6" class="sect3"><span class="enumeration_section">13.3</span>流水线表功能</h3>
               <div>
                  <p>考虑实现流水线表函数所涉及的问题。</p>
               </div><a id="ADDCI4693"></a><div class="props_rev_3"><a id="GUID-B322B116-1D3D-4E5B-9625-2B31189589AF" name="GUID-B322B116-1D3D-4E5B-9625-2B31189589AF"></a><h4 id="ADDCI-GUID-B322B116-1D3D-4E5B-9625-2B31189589AF" class="sect4"><span class="enumeration_section">13.3.1</span>流水线表函数的实现选择</h4>
                  <div>
                     <p>如前所述，支持两种方法来实施<a id="d38518e808" class="indexterm-anchor"></a>流水线表函数：接口方法和PL / SQL方法。
                     </p>
                     <p>接口方法要求用户提供实现预定义Oracle接口的类型，该接口包括start，fetch和close操作。创建表函数时，该类型与表函数相关联。在查询执行期间，重复调用<code class="codeph">fetch</code>方法以迭代检索结果。使用接口方法，与表函数关联的实现类型的方法可以用任何支持的内部或外部语言（包括PL / SQL，C / C ++和Java）实现。
                     </p>
                     <p>使用PL / SQL方法，单个PL / SQL函数包含一个特殊指令，用于从函数中输出结果（集合的单个元素），而不是将整个集合作为单个值返回。原生PL / SQL方法实现起来比较简单，因为它只需要编写一个PL / SQL函数。</p>
                     <p>用于实现流水线表函数的方法不会影响它们的使用方式。无论用于实现它们的方法如何，流水线表函数都以完全相同的方式用于SQL语句中。</p>
                  </div>
               </div><a id="ADDCI4695"></a><a id="ADDCI4696"></a><a id="ADDCI4694"></a><div class="props_rev_3"><a id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67" name="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67"></a><h4 id="ADDCI-GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67" class="sect4"><span class="enumeration_section">13.3.2</span>声明流水线表函数</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过指定<code class="codeph">PIPELINED</code>关键字来声明管道化表函数。此关键字表示该函数迭代地返回行。流水线表函数的返回类型必须是集合类型（嵌套<code class="codeph">table</code>或<code class="codeph">varray</code> ）。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHCGIAE">例13-7</a>显示了使用接口方法实现的流水线表函数的声明。对于功能的接口程序<code class="codeph">GetBooks</code>和<code class="codeph">StockPivot</code>已经在实施的类型<code class="codeph">BookMethods</code>和<code class="codeph">StockPivotImpl</code>分别。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHEIAEC">例13-8</a>显示了使用本机PL / SQL方法实现的相同表函数的声明。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHCGIAE">
                        <p class="titleinexample">例13-7为接口方法声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（cat CLOB）返回BookSet_t使用BookMethods进行流水线操作; CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED使用StockPivotImpl;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHEIAEC">
                        <p class="titleinexample">示例13-8为本机PL / SQL方法声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（cat CLOB）RETURN BookSet_t <span class="bold">PIPELINED IS</span> ...; CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet <span class="bold">PIPELINED IS ...</span>;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4698"></a><a id="ADDCI4697"></a><div class="props_rev_3"><a id="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D" name="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D"></a><h4 id="ADDCI-GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D" class="sect4"><span class="enumeration_section">13.3.3</span>实现本机PL / SQL方法</h4>
                  <div>
                     <div class="section">
                        <p>在PL / SQL中， <code class="codeph">PIPE ROW</code>语句使表函数管道连续并继续处理。该语句使PL / SQL表函数能够在生成后立即返回行。这在<a href="using-pipelined-and-parallel-table-functions.html#GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">实施例13-9中说明</a> 。出于性能原因，PL / SQL运行时系统会批量向行提供行。
                        </p>
                        <p>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">例13-9中</a> ， <code class="codeph">PIPE ROW(out_rec)</code>语句将数据从PL / SQL表函数中移出。
                        </p>
                        <p><code class="codeph">PIPE ROW</code>语句只能在流水线表函数体中使用;如果在其他任何地方使用它，则会引发错误。对于不返回任何行的流水线表函数，可以省略<code class="codeph">PIPE ROW</code>语句。
                        </p>
                        <p>流水线表函数必须具有不返回值的<code class="codeph">RETURN</code>语句。<code class="codeph">RETURN</code>语句将控制权传递回使用者，并确保下一次获取获取<code class="codeph">NO_DATA_FOUND</code>异常。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">
                        <p class="titleinexample">示例13-9为本机PL / SQL方法实现流水线表函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED IS out_rec TickerType：= TickerType（NULL，NULL，NULL）; in_rec p％ROWTYPE; BEGIN LOOP FETCH p INTO in_rec; p％NOTFOUND时退出; - 第一行out_rec.ticker：= in_rec。新浪体育讯北京时间; out_rec。PriceType：='O'; out_rec.price：= in_rec。OpenPrice; PIPE ROW（out_rec）; - 第二行out_rec。PriceType：='C'; out_rec。价格：= in_rec。ClosePrice; PIPE ROW（out_rec）;结束循环;关闭p;返回;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4700"></a><a id="ADDCI4699"></a><div class="props_rev_3"><a id="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A" name="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A"></a><h4 id="ADDCI-GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A" class="sect4"><span class="enumeration_section">13.3.4</span> PL / SQL表函数之间的流水线操作</h4>
                  <div>
                     <div class="section">
                        <p>通过串行执行，结果是<a id="d38518e1074" class="indexterm-anchor"></a>使用类似于协同例程执行的方法从一个PL / SQL表函数流水线化到另一个PL / SQL表函数。<a href="using-pipelined-and-parallel-table-functions.html#GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A__CIHBGDJD">例13-10</a>管道结果从函数<code class="codeph">g</code>到函数<code class="codeph">f</code> 。
                        </p>
                        <p>并行执行的工作方式类似，只是每个函数在不同的进程或进程集中执行。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A__CIHBGDJD">
                        <p class="titleinexample">示例13-10将函数结果从一个函数移植到另一个函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM TABLE（g（）））））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4701"></a><div class="props_rev_3"><a id="GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA" name="GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA"></a><h4 id="ADDCI-GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA" class="sect4"><span class="enumeration_section">13.3.5</span>将PIPE ROW与AUTONOMOUS_TRANSACTION结合起来</h4>
                  <div>
                     <p>因为表函数在生成行时来回传递控制来调用例程，所以对表函数和<code class="codeph">PRAGMA AUTONOMOUS_TRANSACTION</code>的组合存在限制。如果表函数是自治事务的一部分，则它必须在每个<code class="codeph">PIPE ROW</code>语句之前执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> ，以避免调用子程序中的错误。
                     </p>
                  </div>
               </div><a id="ADDCI4702"></a><div class="props_rev_3"><a id="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6" name="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6"></a><h4 id="ADDCI-GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6" class="sect4"><span class="enumeration_section">13.3.6</span>实现接口方法</h4>
                  <div>
                     <div class="section">
                        <p>要使用接口方法，必须定义实现<code class="codeph">ODCITable</code>接口的实现类型。此接口由start，fetch和close例程组成，其签名由Oracle指定，并且您实现为该类型的方法。
                        </p>
                        <p>Oracle调用方法在执行包含表函数的查询时执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>首先使用<code class="codeph">ODCITableStart()</code>函数初始化扫描上下文参数。</span></li>
                        <li><span>获取以生成结果集合中的行的子集。必要时多次调用<code class="codeph">ODCITableFetch()</code>方法以返回整个集合。</span></li>
                        <li><span>在最后一个<code class="codeph">ODCITableFetch()</code>之后使用<code class="codeph">ODCITableClose()</code>关闭并清理（释放内存等<code class="codeph">ODCITableFetch()</code> 。</span></li>
                     </ol>
                     <div class="section">
                        <p><code class="codeph">ODCITable</code>接口还定义了两个可选的例程， <code class="codeph">ODCITablePrepare()</code>和<code class="codeph">ODCITableDescribe()</code> ，它们在编译时调用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在无法以静态方式定义的情况下， <code class="codeph">ODCITableDescribe()</code>确定表函数返回的数据类型的结构。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCITablePrepare()</code>初始化扫描上下文参数。如果实现此方法，则将其准备的扫描上下文传递给<code class="codeph">ODCITableStart()</code>例程，并在表函数的重新启动之间维护上下文。它还提供投影信息并支持瞬态匿名类型的返回。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6__GUID-5123E535-52DC-4251-8D48-9A928A075966">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-C45BF680-3EBE-4E53-8A08-193ED22F61C8">ODCITableDescribe（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-54F5311D-8708-44AB-85A9-9CFE3EE79C76">ODCITableFetch（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADDCI4703"></a><div class="props_rev_3"><a id="GUID-93026BCE-7C11-4333-AA7F-19120ADFA135" name="GUID-93026BCE-7C11-4333-AA7F-19120ADFA135"></a><h5 id="ADDCI-GUID-93026BCE-7C11-4333-AA7F-19120ADFA135" class="sect5"><span class="enumeration_section">13.3.6.1</span>扫描上下文</h5>
                     <div>
                        <p>对于生成下一组行的fetch方法，表函数必须能够在接口例程的连续调用之间维护上下文以获取另一组行。此上下文称为扫描上下文，由实现类型的属性定义。表函数通过在实现类型的对象实例中对其进行建模来保留扫描上下文。</p>
                     </div>
                  </div><a id="ADDCI4704"></a><div class="props_rev_3"><a id="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855" name="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855"></a><h5 id="ADDCI-GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855" class="sect5"><span class="enumeration_section">13.3.6.2</span>启动例程</h5>
                     <div>
                        <p>启动例程<code class="codeph">ODCITableStart()</code>是第一个被调用以开始从表函数中检索行的例程。此例程通常执行扫描所需的设置，创建扫描上下文（作为对象实例<code class="codeph">sctx</code> ）并将其返回给Oracle。但是，如果实现了<code class="codeph">ODCITablePrepare()</code> ，它将创建扫描上下文，然后将其传递给<code class="codeph">ODCITableStart()</code>例程。用户在<code class="codeph">SELECT</code>语句中指定的表函数的参数作为参数传递给此例程。
                        </p>
                        <p>请注意，表函数的任何<code class="codeph">REF CURSOR</code>参数必须在<code class="codeph">ODCITableStart()</code>的声明中声明为<code class="codeph">SYS_REFCURSOR</code>类型。普通的<code class="codeph">REF CURSOR</code>类型不能用作<code class="codeph">ODCITableStart()</code>形式参数类型。普通的<code class="codeph">REF CURSOR</code>类型只能在包中声明，并且包中定义的类型不能在类型方法中用作形式参数类型。要在<code class="codeph">ODCITableStart()</code>使用<code class="codeph">REF CURSOR</code>类型，必须使用系统定义的<code class="codeph">SYS_REFCURSOR</code>类型。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855__GUID-57C748B6-0D15-4C31-A757-54BC548E4787">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADDCI4705"></a><div class="props_rev_3"><a id="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C" name="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C"></a><h5 id="ADDCI-GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C" class="sect5"><span class="enumeration_section">13.3.6.3</span>获取例程</h5>
                     <div>
                        <p>Oracle使用一次或多次调用获取例程<code class="codeph">ODCITableFetch()</code>来检索表函数结果集中的所有行。扫描上下文作为参数传入。此例程返回一行或多行的下一个子集。
                        </p>
                        <p>Oracle重复调用fetch例程，直到table函数返回了所有行。在每次调用<code class="codeph">ODCITableFetch()</code>返回更多行会减少必须进行的提取调用次数，从而提高性能。table函数应返回一个null集合，以指示已返回所有行。
                        </p>
                        <p><code class="codeph">nrows</code>参数指示满足当前OCI调用所需的行数。例如，如果当前OCI调用是请求<code class="codeph">100</code>行的<code class="codeph">ODCITableFetch()</code> ，并且已返回<code class="codeph">20</code>行，则<code class="codeph">nrows</code>参数等于<code class="codeph">80</code> 。允许获取函数返回不同数量的行。此参数的主要目的是防止<code class="codeph">ODCITableFetch()</code>返回比实际需要更多的行。如果<code class="codeph">ODCITableFetch()</code>返回的行数多于此参数的值，则会在后续的<code class="codeph">ODCITableFetch()</code>调用中缓存并返回这些行，或者如果在获取所有OCI语句句柄之前将其关闭，则会丢弃这些行。
                        </p>
                        <div class="infoboxnotealso" id="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C__GUID-6CD06611-EB41-4606-9DE5-D5FE651A88C3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="pipelined-and-parallel-table-functions.html#GUID-54F5311D-8708-44AB-85A9-9CFE3EE79C76">ODCITableFetch（）</a></p>
                        </div>
                     </div>
                  </div><a id="ADDCI4707"></a><a id="ADDCI4706"></a><div class="props_rev_3"><a id="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7" name="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7"></a><h5 id="ADDCI-GUID-A8636931-4B13-4D68-8289-3F29D1B687D7" class="sect5"><span class="enumeration_section">13.3.6.4</span>关闭例程</h5>
                     <div>
                        <p>在最后一次提取调用之后，Oracle会调用关闭例程<a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a> 。扫描上下文作为参数传入。该例程执行必要的清理操作。
                        </p>
                        <div class="figure" id="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7__GUID-517CBAB1-37B7-42BA-95D7-38C2D04D333F">
                           <p class="titleinfigure">图13-3表功能行源执行流程图</p><img src="img/addci046.gif" alt="下面是图13-3的描述" title="下面是图13-3的描述" longdesc="img_text/addci046.html"><br><a href="img_text/addci046.html">“图13-3表函数行执行流程图”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="ADDCI4709"></a><a id="ADDCI4710"></a><a id="ADDCI4711"></a><a id="ADDCI4708"></a><div class="props_rev_3"><a id="GUID-A55E0878-7F31-4317-B599-3188035020B7" name="GUID-A55E0878-7F31-4317-B599-3188035020B7"></a><h5 id="ADDCI-GUID-A55E0878-7F31-4317-B599-3188035020B7" class="sect5"><span class="enumeration_section">13.3.6.5</span>描述返回的数据结构;描述方法</h5>
                     <div>
                        <p>有时，无法静态地从表函数定义返回类型的结构。如果行的形状在不同的查询中不同，则可能取决于调用表函数的实际参数。可以声明这样的表函数返回<code class="codeph">AnyDataSet</code> 。<code class="codeph">AnyDataSet</code>是一种通用集合类型。它可用于对任何集合（任何元素类型）进行建模，并具有一组相关的API（PL / SQL和C），使您能够构造<code class="codeph">AnyDataSet</code>实例并访问元素。
                        </p>
                        <p>以下示例显示声明为返回<code class="codeph">AnyDataSet</code>集合的表函数，该集合的结构在函数创建时未得到修复：</p><pre class="oac_no_warn" dir="ltr">创建函数AnyDocuments（VARCHAR2）使用DocumentMethods返回任何数据集;</pre><p>当格式取决于表函数的实际参数时，可以实现<code class="codeph">ODCITableDescribe()</code>例程来确定结果集合中元素的格式。Oracle在查询编译时调用<code class="codeph">ODCITableDescribe()</code>来检索特定类型信息。通常，例程使用用户参数来确定返回行的形状。返回集合中元素的格式通过返回<code class="codeph">AnyType</code>实例传递给Oracle。
                        </p>
                        <p><code class="codeph">AnyType</code>实例指定特定查询的返回行的实际结构。与<code class="codeph">AnyDataSet</code>一样， <code class="codeph">AnyType</code>具有一组关联的PL / SQL和C接口，用于构造和访问元数据信息。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCGJII">例13-11中</a>的查询，对于<code class="codeph">AnyDocuments</code>函数，返回书籍或杂志上的信息。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">示例13-12</a>是<code class="codeph">ODCITableDescribe()</code>方法的实现，该方法查询指定位置的XML文档的DTD以返回相应的<code class="codeph">AnyType</code>值，无论是书籍还是杂志。通过使用字段名称和数据类型信息调用构造函数API来构造<code class="codeph">AnyType</code>实例。
                        </p>
                        <p>当Oracle调用<code class="codeph">ODCITableDescribe()</code> ，它使用<code class="codeph">AnyType</code> <code class="codeph">OUT</code>参数中返回的类型信息来解析命令行中的引用，例如对<code class="codeph">x.的引用<code class="codeph">x.<a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">例13-12中的</a> Abstract</code>属性。仅当返回的类型是命名类型且因此具有命名属性时，此功能才适用。
                        </p>
                        <p><code class="codeph">ODCITableDescribe()</code>另一个特性是它能够在执行<code class="codeph">SELECT *</code>查询时描述<code class="codeph">SELECT</code>列表参数，例如使用OCI接口。检索到的信息反映了<code class="codeph">ODCITableDescribe()</code>返回的每个顶级属性的一个<code class="codeph">SELECT</code>列表项。
                        </p>
                        <p>因为在编译时调用<code class="codeph">ODCITableDescribe()</code>方法，所以表函数应至少有一个在编译时具有值的参数，如常量。通过使用具有不同参数的表函数，您可以从函数中获得不同的返回类型，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCHGAB">例13-13所示</a> 。
                        </p>
                        <p>仅当使用接口方法实现表函数时， <code class="codeph">ODCITableDescribe()</code>功能才可用。返回<code class="codeph">ANYDATASET</code>的表函数的本机PL / SQL实现返回其结构对服务器不透明的行。
                        </p>
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCGJII">
                           <p class="titleinexample">示例13-11查询AnyType数据</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（AnyDocuments（'http：//.../documents.xml'））x WHERE x。摘要像'％internet％';</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">
                           <p class="titleinexample">示例13-12实现ODCITableDescribe（）方法</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Mag_t AS OBJECT（名称VARCHAR2（100），发布者VARCHAR2（30），抽象VARCHAR2（1000））;静态功能ODCITableDescribe（rtype OUT ANYTYPE，url VARCHAR2）是BEGIN联系指定的Web服务器并检索文档...检查XML doc schema以确定书籍或杂志......IF书籍THEN rtype = AnyType。AnyTypeGetPersistent（ 'SYS'， 'BOOK_T'）; ELSE rtype = AnyType。AnyTypeGetPersistent（ 'SYS'， 'MAG_T'）;万一;结束;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCHGAB">
                           <p class="titleinexample">示例13-13使用返回AnyType的函数</p><pre class="oac_no_warn" dir="ltr">- 发出书籍SELECT x的查询。姓名，x。作者FROM TABLE（AnyDocuments（'Books.xml'））x; - 为杂志SELECT x发出查询。姓名，x。Publisher FROM TABLE（AnyDocuments（'Magazines.xml'））x;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__GUID-C49DFFED-0420-4587-AE63-2B5E0688E241">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-C45BF680-3EBE-4E53-8A08-193ED22F61C8">ODCITableDescribe（）</a></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="using-pipelined-and-parallel-table-functions.html#GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0">Transient和Generic Types</a> ”</span>有关<code class="codeph">AnyDataSet</code>和<code class="codeph">AnyType</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADDCI4713"></a><a id="ADDCI4712"></a><div class="props_rev_3"><a id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7" name="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7"></a><h5 id="ADDCI-GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7" class="sect5"><span class="enumeration_section">13.3.6.6</span>准备执行查询;准备方法</h5>
                     <div>
                        <p>在查询编译时调用<code class="codeph">ODCITablePrepare()</code> 。它生成并保存信息以减少查询的执行时间。
                        </p>
                        <p>如果未实现<code class="codeph">ODCITablePrepare()</code> ，则<code class="codeph">ODCITableStart()</code>在每次调用时初始化上下文。但是，如果您实现了<code class="codeph">ODCITablePrepare()</code> ，它会初始化扫描上下文，在执行查询时<code class="codeph">ODCITableStart()</code>其传递给<code class="codeph">ODCITableStart()</code> ，从而缩短启动时间。此外，当<code class="codeph">ODCITablePrepare()</code>来实现， <code class="codeph">ODCITableClose()</code>是在查询过程中调用一次，而不是每次都表功能重新启动。这有以下好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它通过减少对<code class="codeph">ODCITableClose()</code>的调用次数来减少执行时间。
                              </p>
                           </li>
                           <li>
                              <p>它允许在表函数重启之间保持扫描上下文。</p>
                           </li>
                        </ul>
                        <p><code class="codeph">ODCITablePrepare()</code>还为表函数提供投影信息。如果没有为返回用户定义类型（UDT）集合的表函数实现<code class="codeph">ODCITablePrepare()</code> ，则表函数必须设置每个元素的UDT的每个属性，因为它无法知道使用了哪些属性。相反，从常规表中选择仅获取所需的列，这在大多数情况下自然更快。但是，如果您实现了<code class="codeph">ODCITablePrepare()</code> ，它可以构建一个属性位置数组，在<code class="codeph">ODCITabFuncInfo</code>类型的参数中记录返回类型信息，并将此信息保存在扫描上下文中，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__CIHEHBAJ">例13-14所述</a> 。
                        </p>
                        <p>实现<code class="codeph">ODCITablePrepare()</code>还允许表函数返回瞬态匿名类型。在查询编译结束时调用<code class="codeph">ODCITablePrepare()</code> ，因此可以传递describe方法构建的表描述符对象（TDO）。describe方法可以构建并返回瞬态匿名TDO。 Oracle会转换此TDO，以便在查询执行期间使用它，并将转换后的TDO传递给<code class="codeph">RetType</code>属性中的prepare方法。如果describe方法返回非匿名类型的TDO，则该TDO与转换后的TDO相同。因此，如果表函数返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>作为命名集合类型， <code class="codeph">RetType</code>属性包含此类型的TDO。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AnyDataSet</code>和describe方法返回一个命名类型， <code class="codeph">RetType</code>属性包含命名类型的TDO。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AnyDataSet</code>和describe方法返回匿名类型，Oracle转换此类型， <code class="codeph">RetType</code>包含转换后的TDO。</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__CIHEHBAJ">
                           <p class="titleinexample">示例13-14构建属性位置数组并将其保存在扫描上下文中</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE SYS.ODCITabFuncInto AS OBJECT（Attrs SYS.ODCINumberList，RetType SYS.AnyType）;</pre><div class="infoboxnotealso" id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__GUID-B39CB605-DA78-4001-9121-266C5F0346C4">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4715"></a><a id="ADDCI4714"></a><div class="props_rev_3"><a id="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1" name="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1"></a><h4 id="ADDCI-GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1" class="sect4"><span class="enumeration_section">13.3.7</span>查询表功能</h4>
                  <div>
                     <div class="section">
                        <p>流水线<a id="d38518e2038" class="indexterm-anchor"></a>表函数在<code class="codeph">SELECT</code>语句的<code class="codeph">FROM</code>子句中独立于实现使用，无论是在本机PL / SQL中还是通过接口方法。Oracle会从表函数实现中迭代检索结果行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1__CIHJCECB">例13-15所示</a> 。
                        </p>
                        <p>但是，如果表函数的输出仅由作为参数传递给它的值确定，那么函数总是为传入的每个相应值组合生成完全相同的结果值，则可以声明函数<code class="codeph">DETERMINISTIC</code>和Oracle自动为它缓冲行。但请注意，数据库无法知道标记为<code class="codeph">DETERMINISTIC</code>的函数是否确实是<code class="codeph">DETERMINISTIC</code> ，如果不是，则结果是不可预测的。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1__CIHJCECB">
                        <p class="titleinexample">示例13-15使用表函数迭代检索行</p><pre class="oac_no_warn" dir="ltr">选择x。Ticker，x。价格FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））x WHERE x。PriceType = 'C';</pre></div>
                     <!-- class="example" -->
                  </div><a id="ADDCI4717"></a><a id="ADDCI4716"></a><div class="props_rev_3"><a id="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C" name="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C"></a><h5 id="ADDCI-GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C" class="sect5"><span class="enumeration_section">13.3.7.1</span>对表函数实现多次调用</h5>
                     <div>
                        <div class="section">
                           <p>在同一查询或单独查询中多次调用表函数会导致底层实现的多次执行。也就是说，通常，没有行的缓冲或重用，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C__CIHJAEHD">例13-16所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C__CIHJAEHD">
                           <p class="titleinexample">示例13-16使用表函数的多个调用</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（...））t1，TABLE（f（...））t2 WHERE t1.id = t2.id; SELECT * FROM TABLE（f（））; SELECT * FROM TABLE（f（））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4719"></a><a id="ADDCI4720"></a><a id="ADDCI4721"></a><a id="ADDCI4718"></a><div class="props_rev_3"><a id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE" name="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE"></a><h5 id="ADDCI-GUID-9AC506C7-030B-495F-A910-51640E2C9CEE" class="sect5"><span class="enumeration_section">13.3.7.2</span>使用PL / SQL REF CURSOR变量</h5>
                     <div>
                        <div class="section">
                           <p>可以为表函数的查询定义PL / SQL <code class="codeph">REF CURSOR</code>变量，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHJBDCA">例13-17所示</a> 。
                           </p>
                           <p>表函数上的游标与普通游标具有相同的获取语义。基于表函数的<code class="codeph">REF CURSOR</code>赋值没有特殊语义。
                           </p>
                           <p>但是，SQL优化器不会跨PL / SQL语句进行优化;因此， <a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">实施例13-19</a>比<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">实施例13-18</a>运行得更好。
                           </p>
                           <p>此外， <a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">示例13-18</a>由于与执行两个SQL语句相关的开销而较慢，并且因为它没有利用通过在两个函数之间流水线化结果实现的效率，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">例13-19</a>所做的那样。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHJBDCA">
                           <p class="titleinexample">示例13-17为表函数查询定义REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">打开c FOR SELECT * FROM TABLE（f（...））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">
                           <p class="titleinexample">例13-18使用REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">BEGIN OPEN r FOR SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab）））; SELECT * BULK COLLECT INTO rec_tab FROM TABLE（g（r））;结束;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">
                           <p class="titleinexample">例13-19更有效地使用REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（g（CURSOR（SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab））））））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4723"></a><a id="ADDCI4722"></a><div class="props_rev_3"><a id="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B" name="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B"></a><h4 id="ADDCI-GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B" class="sect4"><span class="enumeration_section">13.3.8</span>在表函数内执行DML操作</h4>
                  <div>
                     <div class="section">
                        <p>必须使用自治事务pragma声明表函数，以便函数执行DML语句。该pragma导致函数在不由其他进程共享的自治事务中执行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B__CIHIFFDH">例13-20所示</a> 。
                        </p>
                        <p>在并行执行期间，表函数的每个实例都会创建一个独立的事务。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B__CIHIFFDH">
                        <p class="titleinexample">示例13-20使用自治事务Pragma声明表函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION f（p SYS_REFCURSOR）返回CollType PIPELINED是PRAGMA AUTONOMOUS_TRANSACTION;开始 ...结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4725"></a><a id="ADDCI4726"></a><a id="ADDCI4724"></a><div class="props_rev_3"><a id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7" name="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7"></a><h4 id="ADDCI-GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7" class="sect4"><span class="enumeration_section">13.3.9</span>对表函数执行DML操作</h4>
                  <div>
                     <div class="section">
                        <p>表函数不能是<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>或<code class="codeph">DELETE</code>语句中的目标表。例如，以下语句引发错误：</p><pre class="oac_no_warn" dir="ltr">UPDATE F（CURSOR（SELECT * FROM tab））SET col = value; INSERT INTO f（...）价值观（'任何'，'事物'）;</pre><p>但是，您可以在表函数上创建视图，并使用<code class="codeph">INSTEAD OF</code>触发器对其进行更新，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHIEICC">例13-21所示</a> 。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHDDHDG">例13-22</a>演示了当用户在<code class="codeph">BookTable</code>视图中插入行时如何触发<code class="codeph">INSTEAD OF</code>触发器：
                        </p>
                        <p>可以在基于表函数的视图上为所有DML操作定义<code class="codeph">INSTEAD OF</code>触发器。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHIEICC">
                        <p class="titleinexample">示例13-21在表上创建视图</p><pre class="oac_no_warn" dir="ltr">创建视图BookTable AS SELECT x。姓名，x。作者FROM TABLE（GetBooks（'data.txt'））x;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHDDHDG">
                        <p class="titleinexample">例13-22将行插入视图时如何触发INSTEAD OF触发器</p><pre class="oac_no_warn" dir="ltr">创建触发器BookTable_insert INSTEAD OF INSERT在BookTable上为每个行开始引用新的内容......结束;插入BookTable值（...）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4727"></a><div class="props_rev_3"><a id="GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62" name="GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62"></a><h4 id="ADDCI-GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62" class="sect4"><span class="enumeration_section">13.3.10</span>处理表函数中的异常</h4>
                  <div>
                     <div class="section">
                        <p>表函数中的异常处理与普通用户定义函数的处理方式相同。</p>
                        <p>某些语言（如C和Java）为用户提供的异常处理提供了一种机制。如果处理表函数内引发的异常，则表函数执行异常处理程序并继续处理。退出异常处理程序将控制到封闭范围。如果异常被清除，则执行正常进行。</p>
                        <p>表函数中的未处理异常会导致父事务回滚。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADDCI4728"></a><div class="props_rev_3"><a id="GUID-C36634BB-613C-4D88-AC58-A58E1409DF24" name="GUID-C36634BB-613C-4D88-AC58-A58E1409DF24"></a><h3 id="ADDCI-GUID-C36634BB-613C-4D88-AC58-A58E1409DF24" class="sect3"><span class="enumeration_section">13.4</span>并行表函数</h3>
               <div>
                  <p>为一个<a id="d38518e2509" class="indexterm-anchor"></a>表函数要并行执行，它必须有一个分区输入参数。当且仅当满足以下两个条件时，才会为表函数启用并行性：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>该函数在其声明中有一个<code class="codeph">PARALLEL_ENABLE</code>子句。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">PARTITION BY</code>子句指定了一个<code class="codeph">REF CURSOR</code> 。
                        </p>
                        <p>如果没有为任何输入<code class="codeph">REF CURSOR</code>指定<code class="codeph">PARTITION BY</code>子句作为<code class="codeph">PARALLEL_ENABLE</code>子句的一部分，则SQL编译器无法确定如何正确分区数据。
                        </p>
                     </li>
                  </ul>
               </div><a id="ADDCI4730"></a><a id="ADDCI4731"></a><a id="ADDCI4729"></a><div class="props_rev_3"><a id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112" name="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112"></a><h4 id="ADDCI-GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112" class="sect4"><span class="enumeration_section">13.4.1</span>使用光标变量输入数据</h4>
                  <div>
                     <div class="section">
                        <p>您可以将一组行传递给<code class="codeph">REF CURSOR</code>参数中的PL / SQL函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHBBFBA">例13-23所示</a> 。
                        </p>
                        <p>子查询的结果可以直接传递给函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHJHBGA">例13-24所示</a> 。需要<code class="codeph">CURSOR</code>关键字来指示子查询的结果应作为<code class="codeph">REF CURSOR</code>参数传递。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHBBFBA">
                        <p class="titleinexample">示例13-23将一组行传递给REF CURSOR中的PL / SQL函数</p><pre class="oac_no_warn" dir="ltr">功能f（p1 IN SYS_REFCURSOR）返回...;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHJHBGA">
                        <p class="titleinexample">示例13-24将子查询中的结果直接传递给函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT empno FROM tab）））;</pre></div>
                     <!-- class="example" -->
                  </div><a id="ADDCI4733"></a><a id="ADDCI4734"></a><a id="ADDCI4735"></a><a id="ADDCI4732"></a><div class="props_rev_3"><a id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3" name="GUID-A56ECF67-9706-4140-8280-CB2135762AD3"></a><h5 id="ADDCI-GUID-A56ECF67-9706-4140-8280-CB2135762AD3" class="sect5"><span class="enumeration_section">13.4.1.1</span>使用多个REF CURSOR输入变量</h5>
                     <div>
                        <div class="section">
                           <p>PL / SQL函数可以接受多个<code class="codeph">REF CURSOR</code>输入变量，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHIFIJG">例13-25所示</a> 。
                           </p>
                           <p>可以调用函数<code class="codeph">g</code>如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHFJFEH">例13-26所示</a> 。
                           </p>
                           <p>您可以通过创建迭代返回数据的<code class="codeph">REF CURSOR</code>将表函数返回值传递给其他表函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHEEJBG">例13-27所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHIFIJG">
                           <p class="titleinexample">例13-25通过REF CURSOR将一组行传递给PL / SQL函数</p><pre class="oac_no_warn" dir="ltr">创建功能g（p1 pkg.refcur_t1，p2 pkg.refcur_t2）返回...管道......;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHFJFEH">
                           <p class="titleinexample">示例13-26调用使用多个REF CURSOR参数的函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（g（CURSOR（SELECT empno FROM tab），CURSOR（SELECT * FROM emp））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHEEJBG">
                           <p class="titleinexample">示例13-27使用REF CURSOR在表函数之间传递返回值</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM TABLE（g（...）））））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4737"></a><a id="ADDCI4736"></a><div class="props_rev_3"><a id="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F" name="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F"></a><h5 id="ADDCI-GUID-05693808-65AB-4F7C-8881-E20DF095EF2F" class="sect5"><span class="enumeration_section">13.4.1.2</span>显式打开查询的REF CURSOR</h5>
                     <div>
                        <p>您可以显式打开查询的<code class="codeph">REF CURSOR</code> ，并将其作为参数传递给表函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">例13-28所示</a> 。
                        </p>
                        <div class="example" id="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">
                           <p class="titleinexample">例13-28显式使用查询REF CURSOR作为表函数参数</p><pre class="oac_no_warn" dir="ltr">BEGIN OPEN r FOR SELECT * FROM TABLE（f（...））; - 必须返回单行结果集。SELECT * INTO rec FROM TABLE（g（r））;结束;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4739"></a><a id="ADDCI4738"></a><div class="props_rev_3"><a id="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC" name="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC"></a><h5 id="ADDCI-GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC" class="sect5"><span class="enumeration_section">13.4.1.3</span> PL / SQL REF CURSOR Java和C / C ++函数的参数</h5>
                     <div>
                        <p>并行和流水线表函数可以用C / C ++，Java或PL / SQL编写。与PL / SQL不同，C / C ++和Java不支持<code class="codeph">REF CURSOR</code>类型，但您仍然可以将<code class="codeph">REF CURSOR</code>参数传递给C / C ++和Java函数。
                        </p>
                        <p>如果将表函数实现为C调用，则传递给callout的<code class="codeph">IN REF CURSOR</code>参数将自动作为已执行的OCI语句句柄使用。您可以像任何其他已执行的语句句柄一样使用此句柄。
                        </p>
                        <p>作为<code class="codeph">IN OUT</code>参数传递的callout的<code class="codeph">REF CURSOR</code>参数在进入callout的过程中转换为执行语句句柄，并且语句句柄在转出时转换回<code class="codeph">REF CURSOR</code> 。（入站和出站语句句柄可能不同。）
                        </p>
                        <p>如果<code class="codeph">REF CURSOR</code>类型用作<code class="codeph">OUT</code>参数或调用的返回类型，则调用必须返回语句句柄，该句柄将转换为调用者的<code class="codeph">REF CURSOR</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">例13-28所示</a> 。
                        </p>
                        <p>如果函数编写为Java调用，则<code class="codeph">IN REF CURSOR</code>参数将自动转换为Java <code class="codeph">ResultSet</code>类的实例。仅当您使用基于OCI的胖JDBC驱动程序时， <code class="codeph">IN REF CURSOR</code>到<code class="codeph">ResultSet</code>映射才可用。此映射不适用于瘦JDBC驱动程序。与C调用中的已执行语句句柄一样，当<code class="codeph">REF CURSOR</code>是<code class="codeph">IN OUT</code>参数， <code class="codeph">OUT</code>参数或函数的返回类型时，Java <code class="codeph">ResultSet</code>将在其路径上转换回PL / SQL <code class="codeph">REF CURSOR</code>打给来电者。
                        </p>
                        <p>还支持预定义的弱<code class="codeph">REF CURSOR</code>类型<code class="codeph">SYS_REFCURSOR</code> 。使用<code class="codeph">SYS_REFCURSOR</code> ，您无需先在包中创建<code class="codeph">REF CURSOR</code>类型，然后才能使用它。这种弱<code class="codeph">REF CURSOR</code>类型可以在<a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a>方法中使用，该方法作为类型方法不能接受包类型。
                        </p>
                        <p>要使用强<code class="codeph">REF CURSOR</code>类型，您仍然必须创建一个PL / SQL包并在其中声明一个强<code class="codeph">REF CURSOR</code>类型。此外，如果使用强<code class="codeph">REF CURSOR</code>类型作为表函数的参数，则<code class="codeph">REF CURSOR</code>参数的实际类型必须与列类型匹配，否则会生成错误。
                        </p>
                        <p>要对弱<code class="codeph">REF CURSOR</code>参数进行分区，必须按<code class="codeph">ANY</code>分区，因为弱<code class="codeph">REF CURSOR</code>参数不能由<code class="codeph">RANGE</code>或<code class="codeph">HASH</code>分区。 Oracle建议您不要对表函数使用弱<code class="codeph">REF CURSOR</code>参数。
                        </p>
                        <div class="example" id="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC__GUID-51BB05D7-E1F4-448E-A1D4-E142CF235D25">
                           <p class="titleinexample">例13-29在呼叫中使用REF CURSOR</p><pre class="oac_no_warn" dir="ltr">创建或替换PACKAGE p1 AS TYPE rc是REF光标;结束;创建或替换LIBARY MYLIB作为'mylib.so';创建或替换函数MyCallout（stmthp p1.rc）RETURN binary_integer AS LANGUAGE C LIBRARY MYLIB WITH CONTEXT PARAMETERS（context，stmthp ocirefcursor，RETURN sb4）; sb4 MyCallout（OCIExtProcContext * ctx，OCIStmt ** stmthp）OCIEnv * envhp; / * env。 handle * / OCISvcCtx * svchp; / * service handle * / OCIError * errhp; / *错误句柄* / OCISession * usrhp; / * user handle * / int errnum = 29400; / *选择一些oracle错误号* / char errmsg [512]; / *错误消息缓冲区* / size_t errmsglen; / *错误消息的长度* / OCIDefine * defn1p =（OCIDefine *）0; OCINumber * val =（OCINumber *）0; OCINumber * rval =（OCINumber *）0;剑状态= 0; double num = 0; val =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; / *获取OCI句柄* / if（GetHandles（ctx，＆envhp，＆svchp，＆errhp，＆usrhp，＆rval））返回-1; / *定义获取缓冲区* / psdro_checkerr（NULL，errhp，OCIDefineByPos（* stmthp，＆defn1p，errhp，（ub4）1，（dvoid *）＆num，（sb4）sizeof（num），SQLT_FLT，（dvoid *）0， （ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT））; / * Fetch loop * / while（（status = OCIStmtFetch（* stmthp，errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT））== OCI_SUCCESS || status == OCI_SUCCESS_WITH_INFO）{printf（“val = ％LF \ n”个，NUM）; } return 0; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4741"></a><a id="ADDCI4742"></a><a id="ADDCI4743"></a><a id="ADDCI4744"></a><a id="ADDCI4740"></a><div class="props_rev_3"><a id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0" name="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0"></a><h4 id="ADDCI-GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0" class="sect4"><span class="enumeration_section">13.4.2</span>输入数据分区</h4>
                  <div>
                     <p>该<a id="d38518e3028" class="indexterm-anchor"></a>表函数声明可以为一个<code class="codeph">REF CURSOR</code>参数指定数据分区，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGECED">例13-30所示</a> 。<code class="codeph">PARALLEL_ENABLE</code>子句中的<code class="codeph">PARTITION BY</code>短语指定要分区的哪个输入游标以及用于分区的列。
                     </p>
                     <p>在列列表中指定显式列名时， <a id="d38518e3046" class="indexterm-anchor"></a><a id="d38518e3050" class="indexterm-anchor"></a>分区方法可以是<code class="codeph">RANGE</code>或<code class="codeph">HASH</code> 。输入行在指定列上进行散列或范围分区。
                     </p>
                     <p><code class="codeph">ANY</code>关键字使您可以指示函数行为独立于输入数据的分区。使用此关键字时，运行时系统会在从属服务器之间随机分区数据。此关键字适用于占用一行的函数，操作其列，并仅基于此行的列生成输出行。
                     </p>
                     <p>为了演示， <a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHEDEFF">示例13-31中</a>的类似于pivot的函数<code class="codeph">StockPivot()</code>将类型的行<code class="codeph">(Ticker varchar(4), OpenPrice number, ClosePrice number)</code>作为输入，并生成该类型的行<code class="codeph">(Ticker varchar(4), PriceType varchar(1), Price number)</code> 。因此，行（ <code class="codeph">"ORCL", 41, 42</code> ）生成两行：（ <code class="codeph">"ORCL", "O", 41</code> ）和（ <code class="codeph">"ORCL", "C", 42</code> ）。
                     </p>
                     <p>您可以直接使用在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">示例13-5中</a>创建的<code class="codeph">rec_tab_type</code> ，而不是<code class="codeph">TickerTypeSet</code> ，也可以使用相同的方式定义它。
                     </p>
                     <p>函数<code class="codeph">f()</code>可用于从<code class="codeph">Stocks</code>表生成另一个表，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHCCJBG">例13-32</a>所示。
                     </p>
                     <p>如果并行扫描<code class="codeph">StockTable</code>并在<code class="codeph">OpenPrice</code>分区，那么函数<code class="codeph">StockPivot()</code>将与扫描<code class="codeph">StockTable</code>的数据流运算符结合使用，因此会看到相同的分区。
                     </p>
                     <p>如果<code class="codeph">StockTable</code>未分区，并且其上的扫描不是并行执行，则<code class="codeph">AlternateStockTable</code>的插入也会按顺序运行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGIDHB">例13-33所示</a> 。
                     </p>
                     <p>如果函数<code class="codeph">g()</code>并行运行并由<code class="codeph">ANY</code>分区，则并行插入可以与<code class="codeph">g()</code>属于同一数据流运算符。
                     </p>
                     <p>只要指定了<code class="codeph">ANY</code>关键字，数据就会在从属中随机分区。这实际上意味着该功能在与输入参数相关联的扫描的同一从设备中执行。
                     </p>
                     <p>此处不需要重新分发或重新分配数据。在这种情况下，当光标<code class="codeph">p</code>本身未启用并行时，传入数据将在列列表中的列上随机分区。循环表队列用于此分区。
                     </p>
                     <p>如果在分区的<code class="codeph">XMLType</code>表上创建<code class="codeph">XMLIndex</code>索引，或者使用范围，列表或散列分区在<code class="codeph">XMLType</code>列上创建分区表，则该索引将与基表进行均分配置。
                     </p>
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGECED">
                        <p class="titleinexample">示例13-30为REF CURSOR参数指定数据分区</p><pre class="oac_no_warn" dir="ltr">CREATE函数F（P <span class="italic">ref_cursor_type）RETURN</span> rec_tab_type PIPELINED PARALLEL_ENABLE（分区P BY [{HASH | <span class="italic">RANGE}（column_list中</span> ）| ANY]）IS BEGIN ...结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHEDEFF">
                        <p class="titleinexample">示例13-31实现StockPivot（）函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN rec_tab_type PIPELINED PARALLEL_ENABLE（PARTITION p BY ANY）是ret_rec rec_type;开始用于rec IN p LOOP ret_rec。股票代码：= rec。新浪体育讯北京时间; ret_rec。PriceType：=“O”; ret_rec。价格：= rec。OpenPrice; PIPE ROW（ret_rec）; ret_rec。股票代码：= rec。新浪体育讯北京时间; - 冗余;不需要ret_rec。PriceType：=“C”; ret_rec。价格：= rec。ClosePrice; PIPE ROW ret_rec;结束循环;返回;结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHCCJBG">
                        <p class="titleinexample">例13-32使用REF CURSOR从另一个表生成表</p><pre class="oac_no_warn" dir="ltr">INSERT INTO AlternateStockTable SELECT * FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGIDHB">
                        <p class="titleinexample">例13-33使用REF CURSOR进行扫描和插入</p><pre class="oac_no_warn" dir="ltr">创建功能g（p refcur_pkg.refcur_t）返回...PIPELINED PARALLEL_ENABLE（从任何地方分开）开始......结束; INSERT INTO AlternateStockTable SELECT * FROM TABLE（f（CURSOR（SELECT * FROM Stocks））），TABLE（g（CURSOR（...）））WHERE <span class="italic">join_condition</span> ;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4746"></a><a id="ADDCI4745"></a><div class="props_rev_3"><a id="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4" name="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4"></a><h4 id="ADDCI-GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4" class="sect4"><span class="enumeration_section">13.4.3</span>叶级表函数的并行执行</h4>
                  <div>
                     <p>并行执行表函数需要<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入参数。如果表函数本身并不需要一组行作为输入，那么必须重新设计该函数以要求<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入。
                     </p>
                     <p>例如，以下函数并行读取一组外部文件并返回它们包含的记录。要为<code class="codeph">REF CURSOR</code>提供工作，您可以先创建一个表并使用文件名填充它。然后，可以将此表上的<code class="codeph">REF CURSOR</code>作为参数传递给表函数<code class="codeph">readfiles()</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4__CIHCAJGD">例13-34所示</a> 。
                     </p>
                     <div class="example" id="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4__CIHCAJGD">
                        <p class="titleinexample">例13-34使用REF CURSOR读取一组外部传感器</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE filetab（filename VARCHAR（20））; INSERT INTO filetab VALUES（'file0'）; INSERT INTO filetab VALUES（'file1'）; ...INSERT INTO filetab VALUES（'fileN'）; SELECT * FROM TABLE（readfiles（CURSOR（SELECT filename FROM filetab）））; CREATE FUNCTION readfiles（p pkg.rc_t）RETURN coll_type PARALLEL_ENABLE（PARTITION p BY ANY）IS ret_rec rec_type;开始接收完成输入：= FALSE; WHILE（done = FALSE）LOOP完成：= readfilerecord（rec.filename，ret_rec）; PIPE ROW（ret_rec）;结束循环;结束循环;返回;结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4747"></a><div class="props_rev_3"><a id="GUID-29BF4664-DC92-4ABA-810D-0998AAA33563" name="GUID-29BF4664-DC92-4ABA-810D-0998AAA33563"></a><h3 id="ADDCI-GUID-29BF4664-DC92-4ABA-810D-0998AAA33563" class="sect3"><span class="enumeration_section">13.5</span>表函数的输入数据流</h3>
               <div>
                  <p>数据流是表函数对从光标参数中提取的行进行排序或聚类的方式。函数可以通过以下任何方式流式传输其输入数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对输入行的排序没有限制。</p>
                     </li>
                     <li>
                        <p>在特定的一列或多列上订购它们。</p>
                     </li>
                     <li>
                        <p>将它们集中在特定键上。</p>
                     </li>
                  </ul>
                  <p>要控制输入流的行为，请使用<a href="using-pipelined-and-parallel-table-functions.html#GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHECDFJ">示例13-36中</a>的语法。
                  </p>
                  <p>可以为函数的顺序或并行执行指定输入流。如果未指定<code class="codeph">ORDER BY</code>或<code class="codeph">CLUSTER BY</code>子句，则以随机顺序输入行。对于从SQL语句中的<code class="codeph">ORDER BY</code>子句的语义进行并行执行， <code class="codeph">ORDER BY</code>的语义是不同的。在SQL语句中， <code class="codeph">ORDER BY</code>子句全局排序整个数据集。在表函数中， <code class="codeph">ORDER BY</code>子句对从属服务器上运行的表函数的每个实例的本地各行进行排序。
                  </p>
                  <p>群集导致具有相同键值的行彼此相邻显示，但它不会对行进行任何排序。</p>
                  <p><code class="codeph">expr</code>应该是<code class="codeph">REFCURSOR</code>收到的<code class="codeph">REFCURSOR</code> 。
                  </p>
                  <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHGDIBD">例13-35</a>说明了对输入流进行排序的语法。在该示例中，函数<code class="codeph">f()</code>接受类型<code class="codeph">(Region, Sales)</code>行并返回表单<code class="codeph">(Region, AvgSales)</code> ，显示每个区域的平均销售额。
                  </p>
               </div><a id="ADDCI4748"></a><a id="ADDCI4749"></a><div class="props_rev_3"><a id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B" name="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B"></a><h4 id="ADDCI-GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B" class="sect4"><span class="enumeration_section">13.5.1</span>设置输入流</h4>
                  <div>
                     <div class="example" id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHGDIBD">
                        <p class="titleinexample">例13-35排序输入流</p><pre class="oac_no_warn" dir="ltr">CREATE函数F（P <span class="italic">ref_cursor_type）RETURN</span> tab_rec_type PIPELINED CLUSTER p BY（地区）PARALLEL_ENABLE（分区P BY HASH（地区））IS ret_rec rec_type; cnt号码;总数; BEGIN LOOP FETCH p INTO rec; p％NOTFOUND时退出; IF（组中的第一个rec）THEN cnt：= 1; sum：= rec。销售; ELSIF（组中的最后一个记录）那么如果（cnt &lt;&gt; 0）那么ret_rec。地区：= rec。区域; ret_rec。AvgSales：= sum / cnt; PIPE ROW（ret_rec）;万一; ELSE cnt：= cnt + 1; sum：= sum + rec。销售;万一;结束循环;返回;结束</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHECDFJ">
                        <p class="titleinexample">例13-36控制输入数据流</p><pre class="oac_no_warn" dir="ltr">功能f（p ref_cursor_type）RETURN tab_rec_type [PIPELINED] {[ORDER | CLUSTER] expr BY column_list} PARALLEL_ENABLE（{PARTITION p BY [ANY | {HASH | RANGE} column_list]}）IS BEGIN ...结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4750"></a><div class="props_rev_3"><a id="GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B" name="GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B"></a><h4 id="ADDCI-GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B" class="sect4"><span class="enumeration_section">13.5.2</span>并行执行：分区和集群</h4>
                  <div>
                     <p>分区和聚类很容易混淆，但它们做了不同的事情。有时，在没有并行执行的集群的情况下进行分区就足够了。</p>
                     <p>考虑一个函数<code class="codeph">SmallAggr</code>对于每个执行内存中的工资的聚合<code class="codeph">department_id</code> ，其中<code class="codeph">department_id</code>可以是<code class="codeph">1</code> ， <code class="codeph">2</code> ，或<code class="codeph">3</code> 。函数的输入行可以通过<code class="codeph">department_id</code>上的<code class="codeph">HASH</code>进行分区，以便<code class="codeph">department_id</code>等于<code class="codeph">1</code>所有行都转到一个slave， <code class="codeph">department_id</code>等于<code class="codeph">2</code>所有行都转到另一个slave，依此类推。
                     </p>
                     <p>输入行不必在<code class="codeph">department_id</code>上聚类以在函数中执行聚合。每个slave可以有一个<code class="codeph">1</code>乘<code class="codeph">3</code>数组<code class="codeph">SmallSum[1..3]</code> ，其中每个<code class="codeph">department_id</code>总和在内存中添加到<code class="codeph">SmallSum[department_id]</code> 。另一方面，如果<code class="codeph">department_id</code>的唯一值的数量非常大，您可能希望使用群集来计算部门聚合并一次将它们写入磁盘一个<code class="codeph">department_id</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="ADDCI4751"></a><div class="props_rev_3"><a id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6" name="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6"></a><h3 id="ADDCI-GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6" class="sect3"><span class="enumeration_section">13.6</span>并行创建域索引</h3>
               <div>
                  <p>创建一个<a id="d38518e3638" class="indexterm-anchor"></a>域索引可能是一个漫长的过程，因为域索引通常处理大量数据。您可以通过使用表函数并行创建域索引来利用表函数的并行处理功能来缓解此瓶颈。
                  </p>
                  <p>通常， <code class="codeph">ODCIIndexCreate()</code>例程执行以下步骤：</p>
                  <ol>
                     <li>
                        <p>创建用于存储索引数据的表</p>
                     </li>
                     <li id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__CIHFGIID">
                        <p>从基表中获取相关数据（如<code class="codeph">keycols</code>和<code class="codeph">rowid</code> ，对其进行转换，并将相关的转换数据插入到为存储索引数据而创建的表中。
                        </p>
                     </li>
                     <li>
                        <p>在存储索引数据的表上构建二级索引，以便在查询时更快地访问。</p>
                     </li>
                  </ol>
                  <p>第<a href="using-pipelined-and-parallel-table-functions.html#GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__CIHFGIID">2</a>步是创建域索引的瓶颈。您可以通过将这些操作封装在并行表函数中并从<code class="codeph">ODCIIndexCreate()</code>函数调用该函数来加快此步骤。在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHDDFGE">例13-37中</a> ，定义了表函数<code class="codeph">IndexLoad()</code>来做到这一点。
                  </p>
                  <p>其中<code class="codeph">p</code>是表单的游标：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + PARALLEL（ <span class="italic">base_table</span> ， <span class="italic">par_degree</span> ）* / keycols，rowid FROM <span class="italic">base_table</span>
</pre><p>可以显式指定<span class="italic"><code class="codeph">par_degree</code></span>值;否则，它是从基表的并行度导出的。
                  </p>
                  <p>需要使用<a href="using-pipelined-and-parallel-table-functions.html#GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHGHDIB">示例</a> <code class="codeph">IndexMerge()</code>定义的函数<code class="codeph">IndexMerge()</code>来合并<code class="codeph">IndexLoad()</code>的多个实例的结果。
                  </p>
                  <p><code class="codeph">ODCIIndexCreate()</code>的新步骤将是：</p>
                  <ol>
                     <li>
                        <p>为索引创建元数据结构（用于存储索引数据的表）。</p>
                     </li>
                     <li>
                        <p>显式提交事务，以便<code class="codeph">IndexLoad()</code>函数可以访问已提交的数据。
                        </p>
                     </li>
                     <li>
                        <p>并行调用<code class="codeph">IndexLoad()</code> ，如以下代码示例所示。
                        </p>
                        <p>调用并行域索引加载的合并</p><pre class="oac_no_warn" dir="ltr">status：= ODCIIndexMerge（CURSOR（SELECT * FROM TABLE（ODCIIndexLoad（ia，parms，CURSOR（SELECT <span class="italic">key_cols</span> ，ROWID FROM <span class="italic">basetable</span> ）））））</pre></li>
                     <li>
                        <p>创建二级索引结构。</p>
                     </li>
                  </ol>
                  <div class="infoboxnotealso" id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__GUID-1FB7D6B6-2DCB-4715-BC85-9598904A0C19">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="extensible-indexing-interface.html#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate（）</a></p>
                  </div>
               </div><a id="ADDCI4753"></a><a id="ADDCI4752"></a><div class="props_rev_3"><a id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D" name="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D"></a><h4 id="ADDCI-GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D" class="sect4"><span class="enumeration_section">13.6.1</span>加载域索引</h4>
                  <div>
                     <div class="section">
                        <p>二级索引的形成非常耗时，Oracle建议您实现域索引的并行加载，如“并行加载域索引”部分所示，然后重新组合它们，如“合并并行域的结果”中所示索引加载“示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHDDFGE">
                        <p class="titleinexample">示例13-37并行加载域索引</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION IndexLoad（ia ODCIIndexInfo，parms VARCHAR2，p refcur-type）RETURN status_code_type PARALLEL_ENABLE（PARTITION p BY ANY）PRAGMA AUTONOMOUS_TRANSACTION开始于rec IN p LOOP  - 处理每个rec并确定索引条目 - 从中获取索引存储表的名称参数ia  - 插入在ODCIIndexCreate END LOOP中创建的表中;承诺; - 显式提交自治txn RETURN ODCIConst。成功;结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHGHDIB">
                        <p class="titleinexample">例13-38合并并行域索引加载的结果</p><pre class="oac_no_warn" dir="ltr">创建功能IndexMerge（p refcur-type）返回编号从开始输入循环开始（rec！= ODCIConst。成功）返回错误;结束循环;返回成功;结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4756"></a><a id="ADDCI4755"></a><div class="props_rev_3"><a id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0" name="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0"></a><h3 id="ADDCI-GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0" class="sect3"><span class="enumeration_section">13.7</span>瞬态和通用类型</h3>
               <div>
                  <p>Oracle有三个特殊的SQL <a id="d38518e3872" class="indexterm-anchor"></a>数据类型<a id="d38518e3877" class="indexterm-anchor"></a>让你<a id="d38518e3882" class="indexterm-anchor"></a>动态封装和访问任何其他SQL类型的类型描述，数据实例和数据实例集，包括对象和集合类型。您还可以使用这三种特殊类型来创建匿名或未命名的类型，包括匿名集合类型。<a href="using-pipelined-and-parallel-table-functions.html#GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__CIHDHEEI" title="类型及其描述">见表13-1</a> 。
                  </p>
                  <p>这三种SQL类型实现为opaque类型;数据库不知道这些类型的内部结构：只能通过实现函数（通常是3GL例程）来查询它们的数据。Oracle提供了OCI和PL / SQL API来实现这些功能。</p>
                  <div class="tblformal" id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__CIHDHEEI">
                     <p class="titleintable">表13-1通用SQL类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="通用SQL类型" width="100%" border="1" summary="Type and its description" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="30%" id="d38518e3902">类型</th>
                              <th align="left" valign="bottom" width="70%" id="d38518e3905">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3910" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYTYPE</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3910 d38518e3905 ">
                                 <p>类型描述类型。<code class="codeph">SYS.ANYTYPE</code>可以包含任何SQL类型的类型描述，无论是命名还是未命名，包括对象类型和集合类型。
                                 </p>
                                 <p>一个<code class="codeph">ANYTYPE</code>可以包含持久性类型的类型描述，但一个<code class="codeph">ANYTYPE</code>本身是瞬时的：在该值<code class="codeph">ANYTYPE</code>本身不自动存储在数据库中。要创建持久性类型，请使用SQL中的<code class="codeph">CREATE TYPE</code>语句。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3935" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYDATA</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3935 d38518e3905 ">
                                 <p>自描述数据实例类型。<code class="codeph">SYS.ANYDATA</code>包含给定类型的实例，包含数据以及类型的描述。从这个意义上说， <code class="codeph">SYS.ANYDATA</code>是自描述的。<code class="codeph">ANYDATA</code>可以持久存储在数据库中。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3952" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYDATASET</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3952 d38518e3905 ">
                                 <p>自描述数据集类型。<code class="codeph">SYS.ANYDATASET</code>类型包含给定类型的描述以及该类型的一组数据实例。<code class="codeph">ANYDATASET</code>可以持久存储在数据库中。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>这三种类型中的每一种都可以与数据库本机的任何内置类型一起使用，包括对象类型和集合类型，包括命名和未命名。这些类型提供了一种通用方式，可以使用类型描述，单个实例和其他类型的实例集动态工作。使用API，您可以创建任何类型的瞬态<code class="codeph">ANYTYPE</code>描述。同样，您可以创建任何SQL类型的数据值或将其转换（转换）为<code class="codeph">ANYDATA</code>并可以将<code class="codeph">ANYDATA</code> （返回）转换为SQL类型。同样，使用多组值和<code class="codeph">ANYDATASET</code> 。</p>
                  <p>泛型类型简化了存储过程的使用。您可以使用泛型类型来封装标准类型的描述和数据，并将封装的信息传递给泛型类型的参数。在过程的主体中，您可以详细说明如何处理封装数据以及任何类型的类型描述。</p>
                  <p>您还可以将各种基础类型的封装数据存储在<code class="codeph">ANYDATA</code>或<code class="codeph">ANYDATASET</code>类型的一个表列中。例如，您可以使用带有高级排队的<code class="codeph">ANYDATA</code>来为异构类型的数据建模队列。您可以像查询任何其他数据一样查询基础数据类型的数据。
                  </p>
                  <p>但请注意，在瞬态类型上创建的<code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>对象（例如通过<code class="codeph">ANYTYPE</code> API构造的未命名类型）不能永久存储在<code class="codeph">ANYDATA</code>或<code class="codeph">ANYDATASET</code>表列中。
                  </p>
                  <p>对应于三种通用SQL类型的是对它们进行建模的三种OCI类型。每个都有一组用于创建和访问相应类型的函数：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCIType</code> ，对应于<code class="codeph">SYS.ANYTYPE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCIAnyData</code> ，对应于<code class="codeph">SYS.ANYDATA</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCIAnyDataSet</code> ，对应于<code class="codeph">SYS.ANYDATASET</code></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__GUID-2E932ECB-22AD-4EF7-8872-A7D2E7286CD5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=LNOCI-GUID-169F309C-279B-410C-9844-E0ACC505F789" target="_blank"><span class="italic">Oracle调用接口程序员指南，</span></a>用于<code class="codeph">OCIType</code> ， <code class="codeph">OCIAnyData</code>和<code class="codeph">OCIAnyDataSet</code> API以及如何使用它们的详细信息</p>
                        </li>
                        <li>
                           <p> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=ARPLS-GUID-4AA6AA30-CAEE-4DCD-B214-9AD51D0229B4" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>有关<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>类型的接口以及<code class="codeph">DBMS_TYPES</code>包的信息，该包定义了内置和用户定义类型的常量，用于<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=ADOBJ010" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南，</span></a>用于定义通用，瞬态和不透明类型。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="01152.DBMS_XMLSCHEMA.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="DBMS_XMLSCHEMA package provides procedures to manage XML schemas."></meta>
      <meta name="description" content="DBMS_XMLSCHEMA package provides procedures to manage XML schemas."></meta>
      <title>DBMS_XMLSCHEMA</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="PL/SQL Packages and Types Reference"></meta>
      <meta property="og:description" content="DBMS_XMLSCHEMA package provides procedures to manage XML schemas."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="PL/SQL Packages and Types Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-packages-and-types-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-25T11:24:34-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96430-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="DBMS_XMLSAVE.html" title="Previous" type="text/html"></link>
      <link rel="next" href="DBMS_XMLSCHEMA_ANNOTATE.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference"></meta>
    <meta name="dcterms.isVersionOf" content="ARPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="DBMS_XMLSAVE.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="DBMS_XMLSCHEMA_ANNOTATE.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">PL / SQL包和类型参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">DBMS_XMLSCHEMA</li>
            </ol>
            <a id="GUID-0D53E906-350F-477B-9A55-85FAEBDCE32E" name="GUID-0D53E906-350F-477B-9A55-85FAEBDCE32E"></a><a id="ARPLS377"></a><a id="ARPLS377"></a>
            
            <h2 id="ARPLS-GUID-0D53E906-350F-477B-9A55-85FAEBDCE32E" class="sect2"><span class="enumeration_chapter">202</span> DBMS_XMLSCHEMA</h2>
         </header>
         <div class="ind">
            <div>
               <p><code class="codeph">DBMS_XMLSCHEMA</code>包提供了管理XML模式的过程。
               </p>
               <p>它是在Oracle数据库安装期间由脚本<code class="codeph">dbmsxsch.sql</code>创建的。
               </p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-F9B6DEA7-DA54-4FB5-A8B0-DE01A5125BA3" title="DBMS_XMLSCHEMA包使用子程序来管理XML模式。">概观</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-FF8CA31C-6DA1-491B-8CD7-FCB6195F8CB4" title="由XDB拥有，DBMS_XMLSCHEMA包必须由SYS或XDB创建。 EXECUTE特权被授予PUBLIC。此包中的子程序使用当前用户的权限执行。">安全模型</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9" title="DBMS_XMLSCHEMA包定义了在指定参数值时要使用的几个常量。">常量</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-CD8EA0C4-26E2-402D-AF89-7297D658E092" title="此表列出了DBMS_XMLSCHEMA包使用的视图">查看</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-92F9F223-6925-4D93-A735-842603D25622" title="有使用就地XML模式演变的指南。">操作说明</a></p>
                  </li>
                  <li>
                     <p><a href="DBMS_XMLSCHEMA.html#GUID-6C78A496-2FD3-413A-9586-E2FFA3083B74" title="此表列出了DBMS_XMLSCHEMA子程序并简要描述了它们。">DBMS_XMLSCHEMA子程序摘要</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-0D53E906-350F-477B-9A55-85FAEBDCE32E__GUID-E484BD41-0D0C-45D3-9E75-6079840A82F3">
                  <p class="notep1">也可以看看：</p>
                  <p><a href="../adxdb/XML-DB-basics.html#ADXDB-GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" target="_blank"><span><cite>Oracle XML DB开发人员指南</cite></span></a></p>
               </div>
            </div><a id="ARPLS70045"></a><a id="ARPLS70045"></a><div class="props_rev_3"><a id="GUID-F9B6DEA7-DA54-4FB5-A8B0-DE01A5125BA3" name="GUID-F9B6DEA7-DA54-4FB5-A8B0-DE01A5125BA3"></a><h3 id="ARPLS-GUID-F9B6DEA7-DA54-4FB5-A8B0-DE01A5125BA3" class="sect3"><span class="enumeration_section">202.1</span> DBMS_XMLSCHEMA概述</h3>
               <div>
                  <p><code class="codeph">DBMS_XMLSCHEMA</code>包使用子程序来管理XML模式。
                  </p>
                  <div class="section">
                     <p>这些子程序提供以下XML模式管理::</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>注册XML架构</p>
                        </li>
                        <li>
                           <p>删除以前注册的XML架构</p>
                        </li>
                        <li>
                           <p>重新编译以前注册的XML架构</p>
                        </li>
                        <li>
                           <p>生成XML架构</p>
                        </li>
                        <li>
                           <p>演变XML模式</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ARPLS74020"></a><a id="ARPLS74020"></a><div class="props_rev_3"><a id="GUID-FF8CA31C-6DA1-491B-8CD7-FCB6195F8CB4" name="GUID-FF8CA31C-6DA1-491B-8CD7-FCB6195F8CB4"></a><h3 id="ARPLS-GUID-FF8CA31C-6DA1-491B-8CD7-FCB6195F8CB4" class="sect3"><span class="enumeration_section">202.2</span> DBMS_XMLSCHEMA安全模型</h3>
               <div>
                  <p>由<code class="codeph">XDB</code>拥有， <code class="codeph">DBMS_XMLSCHEMA</code>包必须由<code class="codeph">SYS</code>或<code class="codeph">XDB</code>创建。 <code class="codeph">EXECUTE</code>特权被授予<code class="codeph">PUBLIC</code> 。此包中的子程序使用当前用户的权限执行。
                  </p>
               </div>
            </div><a id="ARPLS70046"></a><a id="ARPLS70047"></a><a id="ARPLS70048"></a><a id="ARPLS70049"></a><a id="ARPLS70047"></a><a id="ARPLS70048"></a><a id="ARPLS70049"></a><a id="ARPLS70046"></a><div class="props_rev_3"><a id="GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9" name="GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9"></a><h3 id="ARPLS-GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9" class="sect3"><span class="enumeration_section">202.3</span> DBMS_XMLSCHEMA常量</h3>
               <div>
                  <p><code class="codeph">DBMS_XMLSCHEMA</code>包定义了在指定参数值时要使用的几个常量。
                  </p>
                  <div class="section">
                     <p>这些常量如下表所示。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="DBMS_XMLSCHEMA.html#GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDEHIIF" title="此表描述了DBMS_XMLSCHEMA子程序使用的删除选项相关常量。">表202-1</a></p>
                        </li>
                        <li>
                           <p><a href="DBMS_XMLSCHEMA.html#GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDIAGJC" title="此表描述了DBMS_XMLSCHEMA子程序使用的启用层次结构相关常量。">表202-2</a></p>
                        </li>
                        <li>
                           <p><a href="DBMS_XMLSCHEMA.html#GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDGIBBD" title="此表描述了DBMS_XMLSCHEMA子程序使用的寄存器csid相关常量。">表202-3</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDEHIIF">
                     <p class="titleintable">表202-1 <span class="italic"><span class="bold">DBMS_XMLSCHEMA常量</span></span> - 删除选项</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XMLSCHEMA常量 - 删除选项" width="100%" border="1" summary="This table describes delete option related constants used by DBMS_XMLSCHEMA subprograms." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="37%" id="d1262190e538">不变</th>
                              <th align="left" valign="bottom" width="18%" id="d1262190e541">类型</th>
                              <th align="left" valign="bottom" width="9%" id="d1262190e544">值</th>
                              <th align="left" valign="bottom" width="35%" id="d1262190e547">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e552" headers="d1262190e538 ">
                                 <p><code class="codeph">DELETE_RESTRICT</code></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d1262190e552 d1262190e541 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e552 d1262190e544 ">
                                 <p><code class="codeph">1</code></p>
                              </td>
                              <td align="left" valign="top" width="35%" headers="d1262190e552 d1262190e547 ">
                                 <p>如果存在依赖于它的任何表或XML模式，则删除XML模式将失败</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e568" headers="d1262190e538 ">
                                 <p><code class="codeph">DELETE_INVALIDATE</code></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d1262190e568 d1262190e541 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e568 d1262190e544 ">
                                 <p><code class="codeph">2</code></p>
                              </td>
                              <td align="left" valign="top" width="35%" headers="d1262190e568 d1262190e547 ">
                                 <p>如果存在依赖于它的表或XML模式，则删除XML模式不会失败。所有相关表和模式都无效。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e584" headers="d1262190e538 ">
                                 <p><code class="codeph">DELETE_CASCADE</code></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d1262190e584 d1262190e541 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e584 d1262190e544 ">
                                 <p><code class="codeph">3</code></p>
                              </td>
                              <td align="left" valign="top" width="35%" headers="d1262190e584 d1262190e547 ">
                                 <p>删除XML模式还会删除与其关联的所有SQL类型和默认表。只有在注册XML模式期间将<code class="codeph">gentypes</code>参数设置为<code class="codeph">TRUE</code>时，才会删除SQL类型。但是，如果存在符合架构或任何从属XML架构的任何实例文档，则删除XML架构将失败。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e606" headers="d1262190e538 ">
                                 <p><code class="codeph">DELETE_CASCADE_FORCE</code></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d1262190e606 d1262190e541 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e606 d1262190e544 ">
                                 <p><code class="codeph">4</code></p>
                              </td>
                              <td align="left" valign="top" width="35%" headers="d1262190e606 d1262190e547 ">
                                 <p>此选项与<code class="codeph">DELETE_CASCADE</code>类似，不同之处在于它不检查符合架构或任何从属XML架构的任何存储的实例文档。此外，它忽略任何错误。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="tblformal" id="GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDIAGJC">
                     <p class="titleintable">表202-2 <span class="italic"><span class="bold">DBMS_XMLSCHEMA常量</span></span> - 启用层次结构</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XMLSCHEMA常量 - 启用层次结构" width="100%" border="1" summary="This table describes enable hierarchy related constants used by DBMS_XMLSCHEMA subprograms." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="37%" id="d1262190e639">不变</th>
                              <th align="left" valign="bottom" width="19%" id="d1262190e642">类型</th>
                              <th align="left" valign="bottom" width="9%" id="d1262190e645">值</th>
                              <th align="left" valign="bottom" width="34%" id="d1262190e648">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e653" headers="d1262190e639 ">
                                 <p><code class="codeph">ENABLE_HIERARCHY_NONE</code></p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d1262190e653 d1262190e642 ">
                                 <p><code class="codeph">PLS_INTEGER</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e653 d1262190e645 ">
                                 <p><code class="codeph">1</code></p>
                              </td>
                              <td align="left" valign="top" width="34%" headers="d1262190e653 d1262190e648 ">
                                 <p>在注册该模式时创建的任何表上都不会调用<code class="codeph">DBMS_XDBZ</code>包的<code class="codeph">ENABLE_HIERARCHY</code>过程</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e675" headers="d1262190e639 ">
                                 <p><code class="codeph">ENABLE_HIERARCHY_CONTENTS</code></p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d1262190e675 d1262190e642 ">
                                 <p><code class="codeph">PLS_INTEGER</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e675 d1262190e645 ">
                                 <p><code class="codeph">2</code></p>
                              </td>
                              <td align="left" valign="top" width="34%" headers="d1262190e675 d1262190e648 ">
                                 <p>所述<code class="codeph">ENABLE_HIERARCHY</code>所述的程序<code class="codeph">DBMS_XDBZ</code>包将被称为用于与模式注册期间创建的所有表<code class="codeph">hierarchy_type</code>作为<code class="codeph">DBMS_XDBZ</code> 。 <code class="codeph">ENABLE_CONTENTS</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d1262190e705" headers="d1262190e639 ">
                                 <p><code class="codeph">ENABLE_HIERARCHY_RESMETADATA</code></p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d1262190e705 d1262190e642 ">
                                 <p><code class="codeph">PLS_INTEGER</code></p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d1262190e705 d1262190e645 ">
                                 <p><code class="codeph">3</code></p>
                              </td>
                              <td align="left" valign="top" width="34%" headers="d1262190e705 d1262190e648 ">
                                 <p>所述<code class="codeph">ENABLE_HIERARCHY</code>所述的程序<code class="codeph">DBMS_XDBZ</code>包将与模式注册期间创建的所有表被称为<code class="codeph">hierarchy_type</code>作为<code class="codeph">DBMS_XDBZ</code> 。 <code class="codeph">ENABLE_RESMETADATA</code> 。用户应传入<code class="codeph">DBMS_XMLSCHEMA</code> 。 <code class="codeph">ENABLE_RESMETADATA</code>用于他们打算用作资源元数据表的模式。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="tblformal" id="GUID-345D2846-284E-46B8-9AF3-F5961D8D70A9__CHDGIBBD">
                     <p class="titleintable">表202-3 <span class="italic"><span class="bold">DBMS_XMLSCHEMA常量</span></span> - 注册CSID</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XMLSCHEMA常量 - 注册CSID" width="100%" border="1" summary="This table describes register csid related constants used by DBMS_XMLSCHEMA subprograms." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="38%" id="d1262190e757">不变</th>
                              <th align="left" valign="bottom" width="20%" id="d1262190e760">类型</th>
                              <th align="left" valign="bottom" width="10%" id="d1262190e763">值</th>
                              <th align="left" valign="bottom" width="32%" id="d1262190e766">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e771" headers="d1262190e757 ">
                                 <p><code class="codeph">REGISTER_NODOCID</code></p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d1262190e771 d1262190e760 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d1262190e771 d1262190e763 ">
                                 <p><code class="codeph">1</code></p>
                              </td>
                              <td align="left" valign="top" width="32%" headers="d1262190e771 d1262190e766 ">
                                 <p>如果为元数据使用注册了模式（在注册期间使用值<code class="codeph">ENABLE_HIER_RESMETADATA</code>用于参数<code class="codeph">enablehierarchy</code> ），则会将名为<code class="codeph">DOCID</code>的列添加到模式注册期间创建的所有表中。可以在<code class="codeph">REGISTERSCHEMA</code>的options参数中使用此常量，以防止在用户希望优化存储时创建此列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e799" headers="d1262190e757 ">
                                 <p><code class="codeph">REGISTER_CSID_NULL</code></p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d1262190e799 d1262190e760 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="10%" headers="d1262190e799 d1262190e763 ">
                                 <p><code class="codeph">-1</code></p>
                              </td>
                              <td align="left" valign="top" width="32%" headers="d1262190e799 d1262190e766 ">
                                 <p>如果用户希望在调用<code class="codeph">REGISTERSCHEMA</code>时不指定输入模式文档的字符集，则此值可用于csid参数</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="ARPLS70050"></a><a id="ARPLS70051"></a><a id="ARPLS70051"></a><a id="ARPLS70050"></a><div class="props_rev_3"><a id="GUID-CD8EA0C4-26E2-402D-AF89-7297D658E092" name="GUID-CD8EA0C4-26E2-402D-AF89-7297D658E092"></a><h3 id="ARPLS-GUID-CD8EA0C4-26E2-402D-AF89-7297D658E092" class="sect3"><span class="enumeration_section">202.4</span>意见</h3>
               <div>
                  <p>此表列出了<code class="codeph">DBMS_XMLSCHEMA</code>包使用的视图</p>
                  <div class="section">
                     <p><a href="../refrn/static-data-dictionary-views.html#REFRN-GUID-8865F65B-EF6D-44A5-B0A1-3179EFF0C36A" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>中详细介绍了这些视图的列</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-CD8EA0C4-26E2-402D-AF89-7297D658E092__CHDCADGJ">
                     <p class="titleintable">表202-4 DBMS_XMLSCHEMA使用的视图摘要</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XMLSCHEMA使用的视图摘要" width="100%" border="1" summary="This table lists the Catalog Views of DBMS_XMLSCHEMA subprograms." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="38%" id="d1262190e930">架构</th>
                              <th align="left" valign="bottom" width="62%" id="d1262190e933">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e938" headers="d1262190e930 ">
                                 <p><a href="../refrn/USER_XML_SCHEMAS.html#REFRN26307" target="_blank"><code class="codeph">USER_XML_SCHEMAS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e938 d1262190e933 ">
                                 <p>用户拥有的所有已注册的XML模式</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e948" headers="d1262190e930 ">
                                 <p><a href="../refrn/ALL_XML_SCHEMAS.html#REFRN20307" target="_blank"><code class="codeph">ALL_XML_SCHEMAS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e948 d1262190e933 ">
                                 <p>所有已注册的XML模式可供当前用户使用</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e958" headers="d1262190e930 ">
                                 <p><a href="../refrn/DBA_XML_SCHEMAS.html#REFRN23307" target="_blank"><code class="codeph">DBA_XML_SCHEMAS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e958 d1262190e933 ">
                                 <p>数据库中所有已注册的XML模式</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e968" headers="d1262190e930 ">
                                 <p><a href="../refrn/DBA_XML_TABLES.html#REFRN23309" target="_blank"><code class="codeph">DBA_XML_TABLES</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e968 d1262190e933 ">
                                 <p>系统中的所有<code class="codeph">XMLType</code>表</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e981" headers="d1262190e930 ">
                                 <p><a href="../refrn/USER_XML_TABLES.html#REFRN26309" target="_blank"><code class="codeph">USER_XML_TABLES</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e981 d1262190e933 ">
                                 <p>当前用户拥有的所有<code class="codeph">XMLType</code>表</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e994" headers="d1262190e930 ">
                                 <p><a href="../refrn/ALL_XML_TABLES.html#REFRN20309" target="_blank"><code class="codeph">ALL_XML_TABLES</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e994 d1262190e933 ">
                                 <p>当前用户可以使用的所有<code class="codeph">XMLType</code>表</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1007" headers="d1262190e930 ">
                                 <p><a href="../refrn/DBA_XML_TAB_COLS.html#REFRN23308" target="_blank"><code class="codeph">DBA_XML_TAB_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1007 d1262190e933 ">
                                 <p>系统中的所有<code class="codeph">XMLType</code>表列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1020" headers="d1262190e930 ">
                                 <p><a href="../refrn/USER_XML_TAB_COLS.html#REFRN26308" target="_blank"><code class="codeph">USER_XML_TAB_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1020 d1262190e933 ">
                                 <p>当前用户拥有的表中的所有<code class="codeph">XMLType</code>表列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1033" headers="d1262190e930 ">
                                 <p><a href="../refrn/ALL_XML_TAB_COLS.html#REFRN20308" target="_blank"><code class="codeph">ALL_XML_TAB_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1033 d1262190e933 ">
                                 <p>表中的所有<code class="codeph">XMLType</code>表列都可供当前用户使用</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1046" headers="d1262190e930 ">
                                 <p><a href="../refrn/DBA_XML_VIEWS.html#REFRN23311" target="_blank"><code class="codeph">DBA_XML_VIEWS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1046 d1262190e933 ">
                                 <p>系统中的所有<code class="codeph">XMLType</code>视图</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1059" headers="d1262190e930 ">
                                 <p><a href="../refrn/USER_XML_VIEWS.html#REFRN26311" target="_blank"><code class="codeph">USER_XML_VIEWS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1059 d1262190e933 ">
                                 <p>当前用户拥有的所有<code class="codeph">XMlType</code>视图</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1073" headers="d1262190e930 ">
                                 <p><a href="../refrn/ALL_XML_VIEWS.html#REFRN20311" target="_blank"><code class="codeph">ALL_XML_VIEWS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1073 d1262190e933 ">
                                 <p>当前用户可以使用的所有<code class="codeph">XMLType</code>视图</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1086" headers="d1262190e930 ">
                                 <p><a href="../refrn/DBA_XML_VIEW_COLS.html#REFRN23310" target="_blank"><code class="codeph">DBA_XML_VIEW_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1086 d1262190e933 ">
                                 <p>系统中的所有<code class="codeph">XMLType</code>视图列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1099" headers="d1262190e930 ">
                                 <p><a href="../refrn/USER_XML_VIEW_COLS.html#REFRN26310" target="_blank"><code class="codeph">USER_XML_VIEW_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1099 d1262190e933 ">
                                 <p>当前用户拥有的视图中的所有<code class="codeph">XMLType</code>视图列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d1262190e1112" headers="d1262190e930 ">
                                 <p><a href="../refrn/ALL_XML_VIEW_COLS.html#REFRN20310" target="_blank"><code class="codeph">ALL_XML_VIEW_COLS</code></a></p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d1262190e1112 d1262190e933 ">
                                 <p>当前用户可以使用的视图中的所有<code class="codeph">XMLType</code>视图列</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="ARPLS70052"></a><a id="ARPLS70053"></a><a id="ARPLS70053"></a><a id="ARPLS70052"></a><div class="props_rev_3"><a id="GUID-92F9F223-6925-4D93-A735-842603D25622" name="GUID-92F9F223-6925-4D93-A735-842603D25622"></a><h3 id="ARPLS-GUID-92F9F223-6925-4D93-A735-842603D25622" class="sect3"><span class="enumeration_section">202.5</span> DBMS_XMLSCHEMA操作说明</h3>
               <div>
                  <p>有使用就地XML模式演变的指南。</p>
                  <div class="section">
                     <p>在执行就地XML架构演变之前，您应该遵循以下准备步骤：</p>
                     <ol>
                        <li>
                           <p>备份将要演变的XML架构的所有现有数据（实例文档）。</p>
                        </li>
                        <li>
                           <p>仅使用跟踪执行空运行，即，不实际演变XML模式或更新任何实例文档，以生成将在演变期间执行的更新操作的跟踪。为此，请将flag参数值设置为<code class="codeph">INPLACE_TRACE</code> 。不要也使用<code class="codeph">INPLACE_EVOLVE</code> 。执行空运行后，检查跟踪文件，验证列出的DDL操作实际上是您想要的操作。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ARPLS70054"></a><a id="ARPLS70055"></a><a id="ARPLS70055"></a><a id="ARPLS70054"></a><div class="props_rev_3"><a id="GUID-6C78A496-2FD3-413A-9586-E2FFA3083B74" name="GUID-6C78A496-2FD3-413A-9586-E2FFA3083B74"></a><h3 id="ARPLS-GUID-6C78A496-2FD3-413A-9586-E2FFA3083B74" class="sect3"><span class="enumeration_section">202.6</span> DBMS_XMLSCHEMA子程序摘要</h3>
               <div>
                  <p>此表列出了<code class="codeph">DBMS_XMLSCHEMA</code>子程序并简要描述了它们。
                  </p>
                  <div class="tblformal" id="GUID-6C78A496-2FD3-413A-9586-E2FFA3083B74__GUID-FBEFC382-1516-47E5-BA12-0A597C2286D6">
                     <p class="titleintable">表202-5 DBMS_XMLSCHEMA包子程序</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XMLSCHEMA包子程序" width="100%" border="1" summary="This table lists the DBMS_XMLSCHEMA subprograms in alphabetical order and briefly describes them." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d1262190e1338">方法</th>
                              <th align="left" valign="bottom" width="69%" id="d1262190e1341">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1346" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-C61CF495-127E-4276-8853-43827D40BD40" title="此过程可用于重新编译已注册的XML架构。这对于将处于无效状态的模式置于有效状态非常有用。可能导致ORA-31001异常：资源句柄或路径名无效。">COMPILESCHEMA程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1346 d1262190e1341 ">
                                 <p>用于重新编译已注册的XML模式。这对于将处于无效状态的模式置于有效状态非常有用。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1361" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-769A2A32-B169-4809-AA90-4565E3A01EF4" title="此过程演化已注册的模式，以便现有的XML实例保持有效。">COPYEVOLVE程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1361 d1262190e1341 ">
                                 <p>演进已注册的模式，以便现有的XML实例保持有效</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1373" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D" title="此过程将删除URL指定的XML架构。">DELETESCHEMA程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1373 d1262190e1341 ">
                                 <p>从数据库中删除架构</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1385" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58" title="此过程通过将架构更改传播到对象类型和表来演变已注册的架构。">INPLACEEVOLVE程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1385 d1262190e1341 ">
                                 <p>通过将架构更改传播到对象类型和表来演化已注册的架构</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1397" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E" title="此过程将删除XML架构。">PURGESCHEMA程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1397 d1262190e1341 ">
                                 <p>删除XML架构</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1409" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-8E30B10A-FD31-4892-9898-66022BE6BC15" title="此过程注册指定的模式以供数据库使用。">REGISTERSCHEMA程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1409 d1262190e1341 ">
                                 <p>注册指定的架构以供Oracle使用。然后，该模式可用于存储符合此标准的文档。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d1262190e1421" headers="d1262190e1338 ">
                                 <p><a href="DBMS_XMLSCHEMA.html#GUID-8E9313FC-622C-4773-BED1-A09A0E331F60" title="此过程注册由URI名称指定的XML模式。">REGISTERURI程序</a></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d1262190e1421 d1262190e1341 ">
                                 <p>注册由URI名称指定的XML模式</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="ARPLS70056"></a><a id="ARPLS70057"></a><a id="ARPLS70057"></a><a id="ARPLS70056"></a><div class="props_rev_3"><a id="GUID-C61CF495-127E-4276-8853-43827D40BD40" name="GUID-C61CF495-127E-4276-8853-43827D40BD40"></a><h4 id="ARPLS-GUID-C61CF495-127E-4276-8853-43827D40BD40" class="sect4"><span class="enumeration_section">202.6.1</span> COMPILESCHEMA程序</h4>
                  <div>
                     <p>此过程可用于重新编译已注册的XML架构。这对于将处于无效状态的模式置于有效状态非常有用。可能导致<code class="codeph">ORA-31001</code>异常：资源句柄或路径名无效。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-C61CF495-127E-4276-8853-43827D40BD40__GUID-8401E9C3-504C-469D-B8D7-CE8975F1A717">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.COMPILESCHEMA（schemaurl IN VARCHAR2）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C61CF495-127E-4276-8853-43827D40BD40__GUID-0F1F6B03-61BB-4229-B0B8-50C02048F2C3">参数</p>
                        <div class="tblformal" id="GUID-C61CF495-127E-4276-8853-43827D40BD40__GUID-AE69B71A-D40F-4692-A2B3-0A0D6747A019">
                           <p class="titleintable">表202-6 COMPILESCHEMA过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="COMPILESCHEMA程序参数" width="100%" border="1" summary="This table describes the Parameters of the DBMS_XMLSCHEMA.COMPILESCHEMA subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e1545">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e1548">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1553" headers="d1262190e1545 ">
                                       <p><code class="codeph">schemaurl</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1553 d1262190e1548 ">
                                       <p>标识架构的URL</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70058"></a><a id="ARPLS70059"></a><a id="ARPLS70059"></a><a id="ARPLS70058"></a><div class="props_rev_3"><a id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4" name="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4"></a><h4 id="ARPLS-GUID-769A2A32-B169-4809-AA90-4565E3A01EF4" class="sect4"><span class="enumeration_section">202.6.2</span> COPYEVOLVE程序</h4>
                  <div>
                     <p>此过程演化已注册的模式，以便现有的XML实例保持有效。</p>
                     <div class="section">
                        <p>此过程根据以下基本方案完成（替代操作由过程的参数控制）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将基于模式的<code class="codeph">XMLType</code>表中的数据复制到临时表存储</p>
                           </li>
                           <li>
                              <p>丢掉旧桌子</p>
                           </li>
                           <li>
                              <p>删除旧架构</p>
                           </li>
                           <li>
                              <p>注册新模式</p>
                           </li>
                           <li>
                              <p>创建新的<code class="codeph">XMLType</code>表</p>
                           </li>
                           <li>
                              <p>使用临时存储中的数据填充新表;不保留辅助结构（约束，触发器，索引等）</p>
                           </li>
                           <li>
                              <p>删除临时表</p>
                              <div class="infoboxnotealso" id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4__GUID-44995848-B1DD-47BB-A940-9A4B357BC49B">
                                 <p class="notep1">也可以看看：</p>
                                 <p></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>“ <a href="../adxdb/XML-Schema-evolution.html#ADXDB0800" target="_blank"><span class="italic">Oracle XML DB Developer's Guide</span></a> ”中的“Schema Evolution”一章，介绍了如何发展现有模式的示例</p>
                                    </li>
                                    <li>
                                       <p><a href="../errmg/index.html" target="_blank"><span class="italic">Oracle数据库错误消息，</span></a>以获取有关模式演变特定异常的信息，ORA-30142至ORA-30946。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4__GUID-9A4088CE-F891-4054-947C-DF2B2DF092F2">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.COPYEVOLVE（schemaurls IN XDB $ STRUBG_LIST_T，newschemas IN XMLSequenceType，转换IN XMLSequenceType：= NULL，preserveolddocs IN BOOLEAN：= FALSE，maptablename IN VARCHAR2：= NULL，generatetables IN BOOLEAN：= TRUE，强制IN BOOLEAN：= FALSE，schemaowners IN XDB $ STRING_LIST_T：= NULL parallelDegree IN PLS_INTEGER：= 0，options IN PLS_INTEGER：= 0）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4__GUID-2E8B4AA3-751C-4C98-9EA5-6BF9ACE8212A">参数</p>
                        <div class="tblformal" id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4__GUID-54E28538-5C68-4D78-86BE-AED57770CAB4">
                           <p class="titleintable">表202-7 COPYEVOLVE过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="COPYEVOLVE过程参数" width="100%" border="1" summary="This table describes parameters of the DBMS_XMLSCHEMA.COPYEVOLVE subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e1720">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e1723">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1728" headers="d1262190e1720 ">
                                       <p><code class="codeph">schemaurls</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1728 d1262190e1723 ">
                                       <p>要进化的所有模式的URL的<code class="codeph">VARRAY</code> 。应包括依赖模式。除非<code class="codeph">FORCE</code>参数为<code class="codeph">TRUE</code> ，否则URL应按依赖顺序排列。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1744" headers="d1262190e1720 ">
                                       <p><code class="codeph">newschemas</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1744 d1262190e1723 ">
                                       <p><code class="codeph">VARRAY</code>新架构文档。应以与相应URL相同的顺序指定。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1754" headers="d1262190e1720 ">
                                       <p><code class="codeph">变换</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1754 d1262190e1723 ">
                                       <p>转换XSL文档的<code class="codeph">VARRAY</code>将应用于基于模式的文档。应以与相应URL相同的顺序指定。如果不需要转换，则为可选。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1764" headers="d1262190e1720 ">
                                       <p><code class="codeph">preserveolddocs</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1764 d1262190e1723 ">
                                       <p>默认值为<code class="codeph">FALSE</code> ，并删除包含旧数据的临时表。如果为<code class="codeph">TRUE</code> ，则在模式演变完成后，这些表仍可用。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1778" headers="d1262190e1720 ">
                                       <p><code class="codeph">maptabname</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1778 d1262190e1723 ">
                                       <p>指定在演变过程中将表映射到临时表的表的名称。有效列是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">SCHEMA_URL</code> - <code class="codeph">VARCHAR2(700)</code> - 此表符合的模式的URL</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SCHEMA_OWNER</code> - <code class="codeph">VARCHAR2(30)</code> - 模式的所有者</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ELEMENT_NAME</code> - <code class="codeph">VARCHAR2(256)</code> - 此表符合的元素</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TAB_NAME</code> - <code class="codeph">VARCHAR2(65)</code> - 限定表名： <span class="italic"><code class="codeph">&lt;owner_name&gt;.&lt;table_name&gt;</code></span></p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">COL_NAME</code> - <code class="codeph">VARCHAR2(4000)</code> - 列的名称（ <code class="codeph">XMLType</code>表的<code class="codeph">NULL</code> ）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TEMP_TABNAME</code> - <code class="codeph">VARCHAR2(30)</code> - 保存此表数据的临时表的名称。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1844" headers="d1262190e1720 ">
                                       <p><code class="codeph">generatetables</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1844 d1262190e1723 ">
                                       <p>默认值为<code class="codeph">TRUE</code> ，将生成新表。
                                       </p>
                                       <p>如果为<code class="codeph">FALSE</code> ：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>注册新架构后，不会生成新表</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">preserveolddocs</code>必须为<code class="codeph">TRUE</code></p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">maptablename</code>必须为非<code class="codeph">NULL</code></p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1878" headers="d1262190e1720 ">
                                       <p><code class="codeph">力</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1878 d1262190e1723 ">
                                       <p>默认值为<code class="codeph">FALSE</code> 。</p>
                                       <p>如果为<code class="codeph">TRUE</code> ，则忽略模式演变期间生成的错误。在模式之间存在循环依赖关系时使用，以确保尽管注册中可能存在错误，仍会存储所有模式。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1894" headers="d1262190e1720 ">
                                       <p><code class="codeph">schemaowners</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1894 d1262190e1723 ">
                                       <p>架构所有者名称的<code class="codeph">VARRAY</code> 。应以与相应URL相同的顺序指定。假设所有模式都归当前用户所有，则默认值为NULL。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1904" headers="d1262190e1720 ">
                                       <p><code class="codeph">paralleldegree</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1904 d1262190e1723 ">
                                       <p>指定在演变的数据复制阶段期间在<code class="codeph">PARALLEL</code>提示中使用的<code class="codeph">PARALLEL</code>度。如果为0（默认值），则不会在数据复制语句中给出<code class="codeph">PARALLEL</code>提示。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e1918" headers="d1262190e1720 ">
                                       <p><code class="codeph">选项</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e1918 d1262190e1723 ">
                                       <p>目前，唯一受支持的选项是<code class="codeph">COPYEVOLVE_BINARY_XML</code> ，它允许您注册二进制XML的新模式，并使用二进制XML作为存储类型创建新的表/列。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-769A2A32-B169-4809-AA90-4565E3A01EF4__GUID-89E29FB2-121D-4974-B791-B68FC2601EA5">使用说明</p>
                        <p>您应该在调用之前备份所有模式和文档，因为<a href="DBMS_XMLSCHEMA.html#GUID-769A2A32-B169-4809-AA90-4565E3A01EF4" title="此过程演化已注册的模式，以便现有的XML实例保持有效。">COPYEVOLVE过程</a>在实现模式演变之前删除所有符合条件的文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70060"></a><a id="ARPLS70061"></a><a id="ARPLS70062"></a><a id="ARPLS70061"></a><a id="ARPLS70062"></a><a id="ARPLS70060"></a><div class="props_rev_3"><a id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D" name="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D"></a><h4 id="ARPLS-GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D" class="sect4"><span class="enumeration_section">202.6.3</span> DELETESCHEMA程序</h4>
                  <div>
                     <p>此过程将删除URL指定的XML架构。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-3EA250EF-8DED-4383-86C1-1523E78DEBD3">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.DELETESCHEMA（schemaurl IN VARCHAR2，delete_option IN PLS_INTEGER：= DELETE_RESTRICT）;</pre><div class="infoboxnotealso" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-D6A3385E-E66E-4BB8-87C2-90DBA807F396">
                           <p class="notep1">也可以看看：</p>
                           <p>“ <a href="../adxdb/XML-Schema-and-query-basic.html#ADXDB0600" target="_blank"><span class="italic">Oracle XML DB开发人员指南</span></a> ”中的“XMLSCHEMA存储和查询：基本”一章</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-EA8C52A1-594C-4DA7-90A3-9C6F21A6164A">参数</p>
                        <div class="tblformal" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-23F4F068-ACC5-4481-845A-4F659BB5BC3F">
                           <p class="titleintable">表202-8 DELETESCHEMA过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DELETESCHEMA过程参数" width="100%" border="1" summary="This table describes parameters of the DBMS_XMLSCHEMA.DELETESCHEMA subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e2059">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e2062">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2067" headers="d1262190e2059 ">
                                       <p><code class="codeph">schemaurl</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2067 d1262190e2062 ">
                                       <p>标识要删除的架构的URL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2075" headers="d1262190e2059 ">
                                       <p><code class="codeph">delete_option</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2075 d1262190e2062 ">
                                       <p>删除选项：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">DELETE_RESTRICT</code> - 如果存在依赖于此模式的任何表或模式，则模式删除将失败</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DELETE_INVALIDATE</code> - 如果存在任何依赖<code class="codeph">DELETE_INVALIDATE</code> ，则架构删除不会失败。相反，它只是使所有依赖对象无效。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DELETE_CASCADE</code> - 模式删除也将删除所有默认SQL类型和默认表。但是，如果存在符合此架构的任何存储实例，则删除将失败。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DELETE_CASCADE_FORCE</code> -类似<code class="codeph">DELETE_CASCADE</code>只是它不检查符合这个模式中的任何存储的实例。此外，它忽略任何错误。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-213CCF62-6CB4-4235-AEF8-A5A5C9AC9F28">例外</p>
                        <div class="tblformal" id="GUID-0F9F9631-F0C4-4F86-942A-DB0DDAF3D21D__GUID-4985B65C-646B-40BF-A225-7CA87D2565C8">
                           <p class="titleintable">表202-9 DELETESCHEMA过程异常</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DELETESCHEMA程序例外" width="100%" border="1" summary="This table describes exceptions raised by the DBMS_XMLSCHEMA.DELETESCHEMA subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e2119">例外</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e2122">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2127" headers="d1262190e2119 ">
                                       <p><code class="codeph">ORA-31001</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2127 d1262190e2122 ">
                                       <p>资源句柄或路径名无效</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70072"></a><a id="ARPLS70073"></a><a id="ARPLS70073"></a><a id="ARPLS70072"></a><div class="props_rev_3"><a id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58" name="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58"></a><h4 id="ARPLS-GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58" class="sect4"><span class="enumeration_section">202.6.4</span> INPLACEEVOLVE程序</h4>
                  <div>
                     <p>此过程通过将架构更改传播到对象类型和表来演变已注册的架构。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58__GUID-D17D4455-82EE-4EE9-ABAB-2F32F8341ED5">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.INPLACEEVOLVE（schemaURL IN VARCHAR2，diffXML IN XMLType，标记IN NUMBER）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58__GUID-5677829A-4680-40C9-9576-F34EAD2EA8AC">参数</p>
                        <div class="tblformal" id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58__GUID-288C00CF-117E-4650-9628-5CBC735DC2C7">
                           <p class="titleintable">表202-10 INPLACEEVOLVE过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="INPLACEEVOLVE过程参数" width="100%" border="1" summary="This table describes parameters of the DBMS_XMLSCHEMA.INPLACEEVOLVE subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e2244">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e2247">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2252" headers="d1262190e2244 ">
                                       <p><code class="codeph">schemaurl</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2252 d1262190e2247 ">
                                       <p>要发展的模式的URL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2260" headers="d1262190e2244 ">
                                       <p><code class="codeph">diffXML</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2260 d1262190e2247 ">
                                       <p>要应用于架构的更改。这是一个符合<code class="codeph">XDIFF</code>模式的XML文档，它指定需要应用哪些更改以及模式文档中要应用更改的位置。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2271" headers="d1262190e2244 ">
                                       <p><code class="codeph">旗</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2271 d1262190e2247 ">
                                       <p>可以在此参数中设置以下位以控制此过程的行为：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">INPLACE_EVOLVE</code> （值1，表示第1位打开） - 执行就地XML模式演变：构造新的XML模式并对其进行验证（针对XML模式的XML模式）;构造演化实例文档磁盘结构所需的DDL语句，执行DDL语句，并用新的XML模式替换旧的XML模式。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">INPLACE_TRACE</code> （值2，表示第2位打开） - 执行就地演变所需的所有步骤，除了执行DDL语句并用new覆盖旧的XML模式，然后同时写入DDL语句和新的XML模式跟踪文件。
                                             </p>
                                          </li>
                                       </ul>
                                       <p>也就是说，每个位构造新的XML模式，验证它，并确定发展实例文档下的磁盘结构所需的步骤。此外：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>位<code class="codeph">INPLACE_EVOLVE</code>执行这些演进步骤，并用新的替换旧的XML模式。
                                             </p>
                                          </li>
                                          <li>
                                             <p>位<code class="codeph">INPLACE_TRACE</code>将演化步骤和新XML模式保存在跟踪文件中（它不执行演化步骤）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58__GUID-867D4903-7642-4A74-B298-F5D15CEBC5CC">例外</p>
                        <p>该程序在以下情况下引发异常：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于无效的<code class="codeph">XPATH</code>表达式和不符合xdiff模式的<code class="codeph">XDIFF</code>文档，将引发错误。
                              </p>
                           </li>
                           <li>
                              <p>语法正确但导致架构文档中的无效节点的路径表达式将导致错误。</p>
                           </li>
                           <li>
                              <p>如果架构更改使架构成为格式错误的XML文档或无效的XML架构，则会引发错误。</p>
                           </li>
                           <li>
                              <p>由<code class="codeph">CREATE</code> <code class="codeph">TYPE</code> ， <code class="codeph">ALTER</code> <code class="codeph">TYPE</code>和类似命令导致的任何错误都将生成错误消息。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0387B5C9-36C1-4F77-8D32-B8CA5F637B58__GUID-A88FB8C2-FF23-4B6E-9377-BBB20A93EA40">使用说明</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在尝试就地演进之前，用户需要备份所有数据，因为此操作没有回滚。</p>
                           </li>
                           <li>
                              <p>用户必须使用<a href="DBMS_XMLSCHEMA.html#GUID-8E30B10A-FD31-4892-9898-66022BE6BC15" title="此过程注册指定的模式以供数据库使用。">REGISTERSCHEMA过程</a>和<a href="DBMS_XMLSCHEMA.html#GUID-8E9313FC-622C-4773-BED1-A09A0E331F60" title="此过程注册由URI名称指定的XML模式。">REGISTERURI过程</a>在数据库中注册新的XML模式，模式URL与要进化的模式URL不同。如果新模式成功注册并且可用，则用户应该尝试通过此子程序将现有模式演变为新模式。如果新模式的注册成功，则用户必须先删除此模式（及其所有依赖对象），然后再尝试在旧模式URL上发展模式。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70074"></a><a id="ARPLS70075"></a><a id="ARPLS70075"></a><a id="ARPLS70074"></a><div class="props_rev_3"><a id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E" name="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E"></a><h4 id="ARPLS-GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E" class="sect4"><span class="enumeration_section">202.6.5</span> PURGESCHEMA程序</h4>
                  <div>
                     <p>此过程将删除XML架构。</p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E__GUID-0373A32F-657B-4E91-9EA0-30D7E5C74D06">
                           <p class="notep1">也可以看看：</p>
                           <p>“ <a href="../adxdb/XML-Schema-and-query-object-relational-storage.html#ADXDB0700" target="_blank"><span class="italic">Oracle XML DB开发人员指南</span></a> ”中的“XMLSCHEMA存储和查询：高级”一章</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E__GUID-F487DF8F-B978-401D-8CFC-19C3486C6F2C">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.PURGESCHEMA（图案IN RAW）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E__GUID-452BFE0B-8472-4A61-824E-7A17C3D2F215">参数</p>
                        <div class="tblformal" id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E__GUID-DB41914A-0310-4EA9-80AB-C27E7D3E326D">
                           <p class="titleintable">表202-11 PURGESCHEMA程序参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PURGESCHEMA程序参数" width="100%" border="1" summary="This table describes parameters of the DBMS_XMLSCHEMA.PURGESCHEMA subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e2483">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e2486">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2491" headers="d1262190e2483 ">
                                       <p><code class="codeph">schemaid</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2491 d1262190e2486 ">
                                       <p>要清除的架构的ID</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-11ABAA82-56FB-4D4D-8D59-F5E5395E3D9E__GUID-1CC1A5EC-66DB-45B0-BB49-6EA4551876C9">使用说明</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>架构应该最初注册为二进制编码，并且应该在<code class="codeph">HIDE</code>模式下删除。
                              </p>
                           </li>
                           <li>
                              <p>在<code class="codeph">HIDE</code>模式下删除模式后，它将继续存在于XML DB字典中，并用于解码已编码的文档。当没有使用此模式编码的存储实例时，用户将调用此接口。
                              </p>
                           </li>
                           <li>
                              <p>清除架构后，将回收该架构使用的任何空间，并且如果尝试对其进行解码，则使用该架构编码的文档将引发错误。</p>
                           </li>
                           <li>
                              <p>可以从目录视图中获取架构ID。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70076"></a><a id="ARPLS70077"></a><a id="ARPLS70077"></a><a id="ARPLS70076"></a><div class="props_rev_3"><a id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15" name="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15"></a><h4 id="ARPLS-GUID-8E30B10A-FD31-4892-9898-66022BE6BC15" class="sect4"><span class="enumeration_section">202.6.6</span> REGISTERSCHEMA程序</h4>
                  <div>
                     <p>此过程注册指定的模式以供数据库使用。</p>
                     <div class="section">
                        <p>该过程超载。每种语法形式的不同功能与定义一起呈现。</p>
                        <div class="infoboxnote" id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15__GUID-1204FEE3-DCD9-4230-BBA0-33C23CF0352F">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database <span class="italic">11g</span>第2版（11.2）开始，不推荐使用<code class="codeph">genbean</code>参数。Oracle建议您不要在新应用程序中使用此参数。对此功能的支持仅用于向后兼容。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15__GUID-4C8B5712-5C42-4273-894A-F85C5ED09E08">
                           <p class="notep1">也可以看看：</p>
                           <p>“ <a href="../adxdb/XML-Schema-and-query-basic.html#ADXDB0600" target="_blank"><span class="italic">Oracle XML DB开发人员指南</span></a> ”中的“XMLSCHEMA存储和查询：基本”一章</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15__GUID-DC85539A-63EF-4A8C-B56D-16436BF7E033">句法</p>
                        <p>注册指定为<code class="codeph">VARCHAR2</code>的模式：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN VARCHAR2，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，gentables IN BOOLEAN：= TRUE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2 ：= NULL，enablehierarchy IN PLS_INTEGER：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，options IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">BFILE</code>的模式。架构文档的内容必须位于数据库字符集中：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN BFILE，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2：= NULL，enablehierarchy IN PLS_INTEGER ：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，选项IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">BFILE</code>的模式，并标识模式文档的字符集ID：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN BFILE，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= TRUE，gentables IN BOOLEAN：= TRUE，force IN BOOLEAN：= TRUE，owner IN VARCHAR2 ：=''，csid IN NUMBER，enablehierarchy IN PLS_INTEGER：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，options IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">BLOB</code>的模式。架构文档的内容必须位于数据库字符集中：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN BLOB，local IN BOOLEAN：= TRUE，genTypes IN BOOLEAN：= TRUE，genBean IN BOOLEAN：= FASLE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2：= NULL，enablehierarchy IN PLS_INTEGER ：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，选项IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">BLOB</code>的模式并标识模式文档的字符集ID：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN BLOB，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= TRUE，gentables IN BOOLEAN：= TRUE，force IN BOOLEAN：= TRUE，owner IN VARCHAR2 ：=''，csid IN NUMBER，enablehierarchy IN PLS_INTEGER：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，options IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">CLOB</code>的模式</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN CLOB，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2：= NULL，options IN PLS_INTEGER ：= 0）;</pre><p>注册指定为<code class="codeph">XMLTYPE</code>的模式。</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN SYS.XMLTYPE，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2：= NULL，enablehierarchy IN PLS_INTEGER：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，选项IN PLS_INTEGER：= 0）;</pre><p>注册指定为<code class="codeph">BLOB</code>的模式。架构文档的内容必须位于数据库字符集中：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERSCHEMA（schemaurl IN VARCHAR2，schemadoc IN SYS.URIType，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2：= NULL，enablehierarchy IN PLS_INTEGER：= DBMS_XMLSCHEMA.ENABLE_CONTENTS，选项IN PLS_INTEGER：= 0）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15__GUID-F16495B3-A434-4A75-BE24-51DD71C6C3B5">参数</p>
                        <div class="tblformal" id="GUID-8E30B10A-FD31-4892-9898-66022BE6BC15__GUID-C25815AC-7E12-44AE-875A-B26F3B7AB0CA">
                           <p class="titleintable">表202-12 REGSITERSCHEMA过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="REGSITERSCHEMA程序参数" width="100%" border="1" summary="This table describes the parameters of the DBMS_XMLSCHEMA.REGISTERSCHEMA subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e2703">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e2706">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2711" headers="d1262190e2703 ">
                                       <p><code class="codeph">schemaurl</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2711 d1262190e2706 ">
                                       <p>唯一标识架构文档的URL。此值用于派生数据库层次结构中的架构文档的路径名。可以在XML Schema import元素的<code class="codeph">schemalocation</code>属性中使用。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2722" headers="d1262190e2703 ">
                                       <p><code class="codeph">schemadoc</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2722 d1262190e2706 ">
                                       <p>有效的XML架构文档</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2730" headers="d1262190e2703 ">
                                       <p><code class="codeph">本地</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2730 d1262190e2706 ">
                                       <p>这是本地还是全局架构？</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>默认情况下，所有模式都在<code class="codeph">/sys/schemas/&lt;username&gt;/...</code>下注册为本地模式<code class="codeph">/sys/schemas/&lt;username&gt;/...</code></p>
                                          </li>
                                          <li>
                                             <p>如果模式注册为全局模式，则将其添加到<code class="codeph">/sys/schemas/PUBLIC/...</code></p>
                                          </li>
                                       </ul>
                                       <p>您需要对目录具有写权限才能将模式注册为全局模式。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2751" headers="d1262190e2703 ">
                                       <p><code class="codeph">gentypes</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2751 d1262190e2706 ">
                                       <p>确定模式编译器是否生成对象类型。默认情况下为<code class="codeph">TRUE.</code>如果使用二进制XML，则必须将<code class="codeph">gentypes</code>设置为<code class="codeph">FALSE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2768" headers="d1262190e2703 ">
                                       <p><code class="codeph">genbean</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2768 d1262190e2706 ">
                                       <p>确定模式编译器是否生成Java bean。默认情况下，为<code class="codeph">FALSE</code> 。 Oracle建议始终将此参数设置为<code class="codeph">FALSE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2782" headers="d1262190e2703 ">
                                       <p><code class="codeph">gentables</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2782 d1262190e2706 ">
                                       <p>确定架构编译器是否生成默认表。默认情况下为<code class="codeph">TRUE</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2792" headers="d1262190e2703 ">
                                       <p><code class="codeph">力</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2792 d1262190e2706 ">
                                       <p>如果此参数设置为<code class="codeph">TRUE</code> ，则架构注册不会引发错误。相反，它会在出现任何错误时创建无效的XML架构对象。默认情况下，此参数的值为<code class="codeph">FALSE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2806" headers="d1262190e2703 ">
                                       <p><code class="codeph">所有者</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2806 d1262190e2706 ">
                                       <p>此参数指定拥有XML架构对象的数据库用户的名称。默认情况下，注册架构的用户拥有XML架构对象。此参数可用于注册由其他数据库用户拥有的XML架构。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2814" headers="d1262190e2703 ">
                                       <p><code class="codeph">CSID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2814 d1262190e2706 ">
                                       <p>标识输入架构文档的字符集。如果此值为<code class="codeph">0</code> ，则架构文档的编码由“text / xml”MIME类型的当前规则确定。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2825" headers="d1262190e2703 ">
                                       <p><code class="codeph">enablehierarchy</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2825 d1262190e2706 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">ENABLE_HIERARCHY_NONE</code> - 在注册该模式时创建的任何表上都不会调用启用层次结构</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ENABLE_HIERARCHY_CONTENTS</code> - 将为<code class="codeph">DBMS_XDBZ</code>为<code class="codeph">DBMS_XDBZ</code>模式注册期间创建的所有表调用启用层次<code class="codeph">hierarchy_type</code> 。 <code class="codeph">ENABLE_CONTENTS</code> 。这是默认值。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ENABLE_HIERARCHY_RESMETADATA</code> - 将在<code class="codeph">hierarchy_type</code>注册期间创建的所有表上调用启用层次<code class="codeph">hierarchy_type</code> ，其中<code class="codeph">hierarchy_type</code>为<code class="codeph">DBMS_XDBZ</code> 。 <code class="codeph">ENABLE_RESMETADATA</code> 。用户应传入<code class="codeph">DBMS_XMLSCHEMA</code> 。 <code class="codeph">ENABLE_RESMETADATA</code>用于他们打算用作资源元数据表的模式。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e2871" headers="d1262190e2703 ">
                                       <p><code class="codeph">选项</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e2871 d1262190e2706 ">
                                       <p>用于指定架构应如何注册的其他选项。各种选项表示为整数位，而选项参数应通过执行所需位的<code class="codeph">BITOR</code>来构造。可能的位：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">REGISTER_NODOCID</code> - 这将禁止为行<code class="codeph">DOCID</code>创建<code class="codeph">DOCID</code>列。这是一种存储优化，当我们不需要<code class="codeph">DOCID</code>回文档表时（例如，如果我们不关心重写可以通过使用<code class="codeph">DOCID</code>列重写的某些查询），这可能是理想的。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">REGISTER_BINARYXML</code> - 注册二进制XML的模式</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">REGISTER_NT_AS_IOT</code> - 将模式注册期间创建的嵌套表存储为索引组织表。缺省情况是将嵌套表存储为堆表</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ARPLS70078"></a><a id="ARPLS70079"></a><a id="ARPLS70079"></a><a id="ARPLS70078"></a><div class="props_rev_3"><a id="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60" name="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60"></a><h4 id="ARPLS-GUID-8E9313FC-622C-4773-BED1-A09A0E331F60" class="sect4"><span class="enumeration_section">202.6.7</span> REGISTERURI程序</h4>
                  <div>
                     <p>此过程注册由URI名称指定的XML模式。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60__GUID-4CD783D9-CA3D-4240-BF57-FFBC79720672">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 11g第2版（11.2）开始，不推荐使用<code class="codeph">genbean</code>参数。Oracle建议您不要在新应用程序中使用此参数。对此功能的支持仅用于向后兼容。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60__GUID-1124F4BC-5FCA-4FDB-973B-98B3487290A6">句法</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.REGISTERURI（schemaurl IN VARCHAR2，schemadocuri IN VARCHAR2，local IN BOOLEAN：= TRUE，gentypes IN BOOLEAN：= TRUE，genbean IN BOOLEAN：= FALSE，gentables IN BOOLEAN：= TRUE，force IN BOOLEAN：= FALSE，owner IN VARCHAR2 ：= NULL，选项IN PLS_INTEGER：= 0）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60__GUID-C7A003CE-ABE7-4D62-86F4-D8FCF5346EFE">参数</p>
                        <div class="tblformal" id="GUID-8E9313FC-622C-4773-BED1-A09A0E331F60__GUID-602DBE8F-2A3A-45D8-8D51-F34785D8AF11">
                           <p class="titleintable">表202-13 REGISTERURI过程参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="REGISTERURI程序参数" width="100%" border="1" summary="This table describes the parameters of the DBMS_XMLSCHEMA.REGISTERURI subprogram." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d1262190e3020">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d1262190e3023">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3028" headers="d1262190e3020 ">
                                       <p><code class="codeph">schemaurl</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3028 d1262190e3023 ">
                                       <p>唯一标识架构文档。可以在XML Schema import元素的<code class="codeph">schemaLocation</code>属性中使用。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3039" headers="d1262190e3020 ">
                                       <p><code class="codeph">schemadocuri</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3039 d1262190e3023 ">
                                       <p>路径名（URI）对应于架构文档的物理位置。URI路径可以基于HTTP，FTP，DB或Oracle XML DB协议。此函数使用<code class="codeph">urifactory</code>构造<code class="codeph">URIType</code>实例，并调用<a href="DBMS_XMLSCHEMA.html#GUID-8E30B10A-FD31-4892-9898-66022BE6BC15" title="此过程注册指定的模式以供数据库使用。">REGISTERSCHEMA过程</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3060" headers="d1262190e3020 ">
                                       <p><code class="codeph">本地</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3060 d1262190e3023 ">
                                       <p>确定这是本地模式还是全局模式。默认情况下，所有模式都在<code class="codeph">/sys/schemas/ &lt;username&gt;/...</code>下注册为本地模式<code class="codeph">/sys/schemas/ &lt;username&gt;/...</code>如果模式注册为全局模式，则将其添加到<code class="codeph">/sys/schemas/PUBLIC/...</code> 用户需要对目录具有写权限才能注册全局模式。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3074" headers="d1262190e3020 ">
                                       <p><code class="codeph">gentypes</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3074 d1262190e3023 ">
                                       <p>确定编译器是否生成对象类型。默认情况下为<code class="codeph">TRUE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3085" headers="d1262190e3020 ">
                                       <p><code class="codeph">genbean</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3085 d1262190e3023 ">
                                       <p>确定编译器是否生成Java bean。默认情况下，为<code class="codeph">FALSE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3096" headers="d1262190e3020 ">
                                       <p><code class="codeph">gentables</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3096 d1262190e3023 ">
                                       <p>确定编译器是否生成默认表。默认为<code class="codeph">TRUE</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3107" headers="d1262190e3020 ">
                                       <p><code class="codeph">力</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3107 d1262190e3023 ">
                                       <p><code class="codeph">TRUE:</code>架构注册不会引发错误。相反，它会在出现任何错误时创建无效的XML架构对象。默认情况下，此参数的值为<code class="codeph">FALSE</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3120" headers="d1262190e3020 ">
                                       <p><code class="codeph">所有者</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3120 d1262190e3023 ">
                                       <p>此参数指定拥有XML架构对象的数据库用户的名称。默认情况下，注册架构的用户拥有XML架构对象。此参数可用于注册由其他数据库用户拥有的XML架构。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d1262190e3128" headers="d1262190e3020 ">
                                       <p><code class="codeph">选项</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d1262190e3128 d1262190e3023 ">
                                       <p>用于指定架构应如何注册的其他选项。各种选项表示为整数位，而选项参数应通过执行所需位的<code class="codeph">BITOR</code>来构造。可能的位：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">REGISTER_NODOCID</code> - 这将禁止为行<code class="codeph">DOCID</code>创建<code class="codeph">DOCID</code>列。这是一种存储优化，当我们不需要<code class="codeph">DOCID</code>回文档表时（例如，如果我们不关心重写可以通过使用<code class="codeph">DOCID</code>列重写的某些查询），这可能是理想的。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="04202.preparing-Java-class-methods.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>准备用于执行的Java类方法</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="java-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T00:55:24-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96468-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Java-classes-in-database.html" title="Previous" type="text/html"></link>
      <link rel="next" href="server-user-interface.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JJDEV"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-classes-in-database.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="server-user-interface.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="Java-applications-in-database.html" property="item" typeof="WebPage"><span property="name">Oracle数据库上的Java应用程序</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">准备用于执行的Java类方法</li>
            </ol>
            <a id="GUID-0183CF7A-911E-4F3A-AA17-989023010C2D" name="GUID-0183CF7A-911E-4F3A-AA17-989023010C2D"></a><a id="JJDEV02040"></a>
            
            <h2 id="JJDEV-GUID-0183CF7A-911E-4F3A-AA17-989023010C2D" class="sect2"><span class="enumeration_section">2.5</span>准备Java类执行方法</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p><a id="d8687e87" class="indexterm-anchor"></a><a id="d8687e89" class="indexterm-anchor"></a><a id="d8687e93" class="indexterm-anchor"></a><a id="d8687e95" class="indexterm-anchor"></a>要确保运行Java方法，必须执行以下操作：</p>
               </div>
               <!-- class="section" -->
               <ol>
                  <li><span>决定何时编译Java源代码。</span></li>
                  <li><span>确定是否要使用默认解析程序或其他解析程序来查找数据库中的支持Java类。</span></li>
                  <li><span>将类加载到数据库中。如果您不希望为类使用默认解析程序，则应使用load命令指定单独的解析程序。</span></li>
                  <li><span>发布您的课程或方法。</span></li>
               </ol>
               <div class="section">
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-77024007-F203-44DF-B3EB-75E72D491B63">编译Java类</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-F17E6450-17E3-49EE-9258-EF5E01748198">解决类依赖关系概述</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63">使用loadjava工具加载类概述</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-3F57CC21-BC4C-4203-B477-695E039D5973">授予执行权限概述</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7">控制当前用户概述</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1">检查Java上载概述</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-8D343A4B-EC7A-4F65-8942-56D184250B64">关于发布数据库中加载的Java方法</a></p>
                     </li>
                     <li>
                        <p><a href="preparing-Java-class-methods.html#GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA">审计数据库中加载的Java类概述</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JJDEV02041"></a><div class="props_rev_3"><a id="GUID-77024007-F203-44DF-B3EB-75E72D491B63" name="GUID-77024007-F203-44DF-B3EB-75E72D491B63"></a><h3 id="JJDEV-GUID-77024007-F203-44DF-B3EB-75E72D491B63" class="sect3"><span class="enumeration_section">2.5.1</span>编译Java类</h3>
               <div>
                  <div class="section">
                     <p>可以通过以下方式之一编译Java源代码：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d8687e261" class="indexterm-anchor"></a>您可以在将客户端系统加载到数据库之前，通过Java编译器（如<code class="codeph">javac</code>显式编译源代码。
                           </p>
                        </li>
                        <li>
                           <p>您可以要求数据库在加载过程中编译源代码，该过程由<code class="codeph">loadjava</code>工具管理。
                           </p>
                        </li>
                        <li>
                           <p><a id="d8687e277" class="indexterm-anchor"></a>您可以强制编译在运行时动态发生。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-77024007-F203-44DF-B3EB-75E72D491B63__GUID-34E41FE0-5FD0-4EC2-9F50-A7535D279BC9">
                        <p class="notep1">注意：</p>
                        <p>如果您决定通过<code class="codeph">loadjava</code>工具进行编译，则可以指定编译器选项。
                        </p>
                     </div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="preparing-Java-class-methods.html#GUID-51E64EF1-74D7-4E39-AB9C-1021DF344B0B">通过javac编译源代码</a></p>
                        </li>
                        <li>
                           <p><a href="preparing-Java-class-methods.html#GUID-1F6328ED-397C-48DF-9503-904FF2398FE5">通过loadjava工具编译源代码</a></p>
                        </li>
                        <li>
                           <p><a href="preparing-Java-class-methods.html#GUID-1CC261BC-1B21-43B3-9745-6E38D5F494C6">在运行时编译源代码</a></p>
                        </li>
                        <li>
                           <p><a href="preparing-Java-class-methods.html#GUID-C2285812-D08C-4D76-86E2-9517B233FA08">指定编译器选项</a></p>
                        </li>
                        <li>
                           <p><a href="preparing-Java-class-methods.html#GUID-3B5A4B16-8824-4357-A613-D1CBC8C636D4">自动重新编译源程序</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="preparing-Java-class-methods.html#GUID-C2285812-D08C-4D76-86E2-9517B233FA08">指定编译器选项</a></li>
                     </ul>
                  </div>
               </div>
               <a id="JJDEV13063"></a><div class="props_rev_3"><a id="GUID-51E64EF1-74D7-4E39-AB9C-1021DF344B0B" name="GUID-51E64EF1-74D7-4E39-AB9C-1021DF344B0B"></a><h4 id="JJDEV-GUID-51E64EF1-74D7-4E39-AB9C-1021DF344B0B" class="sect4"><span class="enumeration_section">2.5.1.1</span>通过javac编译源代码</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用传统的Java编译器编译Java源代码，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">javac <span class="variable" translate="no">&lt;file_name&gt;</span> .java</pre><p>编译后，将已编译的二进制文件加载到数据库中，而不是源本身。这是一个更好的选择，因为在您自己的系统上调试Java代码通常更容易，而不是在数据库上调试它。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13064"></a><div class="props_rev_3"><a id="GUID-1F6328ED-397C-48DF-9503-904FF2398FE5" name="GUID-1F6328ED-397C-48DF-9503-904FF2398FE5"></a><h4 id="JJDEV-GUID-1F6328ED-397C-48DF-9503-904FF2398FE5" class="sect4"><span class="enumeration_section">2.5.1.2</span>通过loadjava工具编译源代码</h4>
                  <div>
                     <div class="section">
                        <p>当您指定<code class="codeph">-resolve</code>与选项<code class="codeph">loadjava</code>为源文件的工具，将发生以下情况：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>源文件作为源架构对象加载。</span></li>
                        <li><span>源文件已编译。</span></li>
                        <li><span>为已编译的<code class="codeph">.java</code>文件中定义的每个类创建类模式对象。</span></li>
                        <li><span>已编译的代码存储在类架构对象中。</span></li>
                     </ol>
                     <div class="section">
                        <p><a id="d8687e537" class="indexterm-anchor"></a><a id="d8687e541" class="indexterm-anchor"></a> Oracle数据库将所有编译错误写入<code class="codeph">loadjava</code>工具的日志文件以及<code class="codeph">USER_ERRORS</code>视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13065"></a><div class="props_rev_3"><a id="GUID-1CC261BC-1B21-43B3-9745-6E38D5F494C6" name="GUID-1CC261BC-1B21-43B3-9745-6E38D5F494C6"></a><h4 id="JJDEV-GUID-1CC261BC-1B21-43B3-9745-6E38D5F494C6" class="sect4"><span class="enumeration_section">2.5.1.3</span>在运行时编译源代码</h4>
                  <div>
                     <div class="section">
                        <p>在没有<code class="codeph">-resolve</code>选项的情况下将Java源加载到数据库中时，例如：</p><pre class="oac_no_warn" dir="ltr">loadjava <span class="variable" translate="no">&lt;file_name&gt;</span> .java</pre><p>然后，Oracle Database在运行时需要类时自动编译源代码。源文件将加载到源架构对象中。Oracle数据库将所有编译错误写入<code class="codeph">loadjava</code>工具的日志文件以及<code class="codeph">USER_ERRORS</code>视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13066"></a><div class="props_rev_3"><a id="GUID-C2285812-D08C-4D76-86E2-9517B233FA08" name="GUID-C2285812-D08C-4D76-86E2-9517B233FA08"></a><h4 id="JJDEV-GUID-C2285812-D08C-4D76-86E2-9517B233FA08" class="sect4"><span class="enumeration_section">2.5.1.4</span>指定编译器选项</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过以下方式指定编译器选项：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d8687e764" class="indexterm-anchor"></a>使用<code class="codeph">loadjava</code>工具在命令行上指定编译器选项。您还可以使用<code class="codeph">loadjava</code>工具指定编码选项。
                              </p>
                           </li>
                           <li>
                              <p>在。中指定持久编译器选项<a id="d8687e778" class="indexterm-anchor"></a> <code class="codeph">JAVA$OPTIONS</code>表。每个架构都存在<code class="codeph">JAVA$OPTIONS</code>表。每次编译时，编译器都会使用这些选项。但是，使用<code class="codeph">loadjava</code>工具指定的任何编译器选项<code class="codeph">loadjava</code>覆盖此表中定义的选项。如果要以这种方式指定编译器选项，则必须自己创建此表。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="props_rev_3"><a id="GUID-D3FE2307-FEDE-4E0E-8FAF-3B68D4F0191E" name="GUID-D3FE2307-FEDE-4E0E-8FAF-3B68D4F0191E"></a><h5 id="JJDEV-GUID-D3FE2307-FEDE-4E0E-8FAF-3B68D4F0191E" class="sect5"><span class="enumeration_section">2.5.1.4.1</span>指定默认编译器选项</h5>
                     <div>
                        <div class="section">
                           <p>在编译既未存在<code class="codeph">JAVA$OPTIONS</code>条目也未指定任何选项的命令行值的源模式对象时，编译器将采用以下默认值：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">编码= System.getProperty（ “file.encoding的”）;</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">在线= TRUE</code></p>
                                 <p>此选项仅适用于包含SQLJ构造的Java源。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">调试=真</code></p>
                                 <p>此选项相当于：</p><pre class="oac_no_warn" dir="ltr">javac -g</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-FE9BED3B-A1E5-4412-A36D-2EBB230DAEE6" name="GUID-FE9BED3B-A1E5-4412-A36D-2EBB230DAEE6"></a><h5 id="JJDEV-GUID-FE9BED3B-A1E5-4412-A36D-2EBB230DAEE6" class="sect5"><span class="enumeration_section">2.5.1.4.2</span>在命令行上指定编译器选项</h5>
                     <div>
                        <div class="section">
                           <p>使用<code class="codeph">loadjava</code>工具指定的<code class="codeph">encoding</code>编译器选项标识<code class="codeph">.java</code>文件的编码。此选项会覆盖<code class="codeph">JAVA$OPTIONS</code>表中的任何匹配值。值与以下内容相同：</p><pre class="oac_no_warn" dir="ltr">javac -encoding</pre><p>此选项仅在加载源文件时相关。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-7F1602B0-2B02-4FAD-BA9C-A515C0889E11" name="GUID-7F1602B0-2B02-4FAD-BA9C-A515C0889E11"></a><h5 id="JJDEV-GUID-7F1602B0-2B02-4FAD-BA9C-A515C0889E11" class="sect5"><span class="enumeration_section">2.5.1.4.3</span>指定数据库表中指定的编译器选项</h5>
                     <div>
                        <div class="section">
                           <p>每个<code class="codeph">JAVA$OPTIONS</code>条目都包含应用选项设置的源模式对象的名称。您可以使用多行为不同的源架构对象设置不同的选项。
                           </p>
                           <p>您可以使用以下过程和函数设置<code class="codeph">JAVA$OPTIONS</code>条目，这些过程和函数在数据库包<code class="codeph">DBMS_JAVA</code>中定义：</p><pre class="oac_no_warn" dir="ltr">程序<a id="d8687e1109" class="indexterm-anchor"></a> set_compiler_option（名称VARCHAR2，选项VARCHAR2，值VARCHAR2）;功能<a id="d8687e1112" class="indexterm-anchor"></a> get_compiler_option（名称VARCHAR2，选项VARCHAR2）RETURNS VARCHAR2;程序<a id="d8687e1115" class="indexterm-anchor"></a> reset_compiler_option（名称VARCHAR2，选项VARCHAR2）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDEV13071"></a><a id="JJDEV13070"></a><div class="props_rev_3"><a id="GUID-B64CB458-9D0B-42DE-85EB-303EB0F66091" name="GUID-B64CB458-9D0B-42DE-85EB-303EB0F66091"></a><h5 id="JJDEV-GUID-B64CB458-9D0B-42DE-85EB-303EB0F66091" class="sect5"><span class="enumeration_section">2.5.1.4.4</span>有关指定数据库表中指定的编译器选项的详细信息</h5>
                     <div>
                        <div class="section">
                           <p>下表描述了上一节中描述的方法的参数。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-B64CB458-9D0B-42DE-85EB-303EB0F66091__CEGJBDHI">
                           <p class="titleintable">表2-2名称和选项参数的定义</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="名称和选项参数的定义" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d8687e1219">参数</th>
                                    <th align="left" valign="bottom" width="69%" id="d8687e1222">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d8687e1227" headers="d8687e1219 ">
                                       <p>名称</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d8687e1227 d8687e1222 ">
                                       <p>这是Java包名称，完全限定的类名称或空字符串。当编译器在<code class="codeph">JAVA$OPTIONS</code>表中搜索用于编译Java源模式对象的选项时，它使用具有<code class="codeph">name</code>值的行，该行最接近匹配模式对象的完全限定类名。一个<code class="codeph">name</code> ，它的值是空字符串匹配任何架构对象名称。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d8687e1243" headers="d8687e1219 ">
                                       <p>选项</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d8687e1243 d8687e1222 ">
                                       <p><code class="codeph">option</code>参数是<code class="codeph">online</code> ， <code class="codeph">encoding</code>或<code class="codeph">debug</code> 。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p>最初，架构没有<code class="codeph">JAVA$OPTIONS</code>表。要创建<code class="codeph">JAVA$OPTIONS</code>表，请使用<code class="codeph">DBMS_JAVA</code>包中的<code class="codeph">java.set_compiler_option</code>过程来设置值。如果表不存在，该过程将创建该表。用单引号指定参数。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; execute dbms_java.set_compiler_option（'xy'，'online'，'false'）;</pre><p>下表表示假设的<code class="codeph">JAVA$OPTIONS</code>数据库表。模式匹配规则是尽可能多地将模式名称与表条目匹配。模式匹配具有更高分辨率的模式名称是适用的条目。由于表没有<code class="codeph">encoding</code>选项的条目，因此编译器使用命令行上指定的缺省值或值。表中显示的<code class="codeph">online</code>选项与模式对象名称匹配如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>名称<code class="codeph">abcd</code>匹配以<code class="codeph">abcd</code>开头的类名和包名。包和类使用<code class="codeph">online=true</code>编译。
                                 </p>
                              </li>
                              <li>
                                 <p>名称<code class="codeph">ab</code>匹配以<code class="codeph">ab</code>开头的类和包名称。名称<code class="codeph">ab</code>与<code class="codeph">abcd</code>不匹配。包和类使用<code class="codeph">online=false</code>编译。
                                 </p>
                              </li>
                              <li>
                                 <p>所有其他包和类都匹配空字符串条目，并使用<code class="codeph">online=true</code>进行编译。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-B64CB458-9D0B-42DE-85EB-303EB0F66091__BABBIFHD">
                           <p class="titleintable">表2-3示例JAVA $ OPTIONS表</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="示例JAVA $ OPTIONS表" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="18%" id="d8687e1338">名称</th>
                                    <th align="left" valign="bottom" width="18%" id="d8687e1341">选项</th>
                                    <th align="left" valign="bottom" width="18%" id="d8687e1344">值</th>
                                    <th align="left" valign="bottom" width="46%" id="d8687e1347">匹配示例</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d8687e1352" headers="d8687e1338 ">
                                       <p>A B C D</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1352 d8687e1341 ">
                                       <p><code class="codeph">线上</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1352 d8687e1344 ">
                                       <p><code class="codeph">真正</code></p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d8687e1352 d8687e1347 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">A B C D</code></p>
                                             <p>完全匹配模式。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ABCDE</code> 
                                             </p>
                                             <p>第一部分完全匹配模式。没有其他规则与完整限定名称匹配。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d8687e1379" headers="d8687e1338 ">
                                       <p>AB</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1379 d8687e1341 ">
                                       <p><code class="codeph">线上</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1379 d8687e1344 ">
                                       <p><code class="codeph">假</code></p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d8687e1379 d8687e1347 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">AB</code></p>
                                             <p>完全匹配模式</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">ABCX</code></p>
                                             <p>第一部分完全匹配模式。没有其他规则符合此规则。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d8687e1405" headers="d8687e1338 ">
                                       <p>空字符串</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1405 d8687e1341 ">
                                       <p><code class="codeph">线上</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d8687e1405 d8687e1344 ">
                                       <p><code class="codeph">真正</code></p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d8687e1405 d8687e1347 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">AC</code></p>
                                             <p>没有模式匹配任何已定义的名称。默认为空字符串规则。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">XY</code></p>
                                             <p>没有模式匹配任何已定义的名称。默认为空字符串规则。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="JJDEV13072"></a><div class="props_rev_3"><a id="GUID-3B5A4B16-8824-4357-A613-D1CBC8C636D4" name="GUID-3B5A4B16-8824-4357-A613-D1CBC8C636D4"></a><h4 id="JJDEV-GUID-3B5A4B16-8824-4357-A613-D1CBC8C636D4" class="sect4"><span class="enumeration_section">2.5.1.5</span>自动<span class="enumeration_section">重新</span>编译源程序</h4>
                  <div>
                     <div class="section">
                        <p>Oracle数据库提供依赖关系管理和自动构建工具，当您对其所依赖的源程序或二进制程序进行更改时，它们透明地重新编译源程序。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">公共等级A {B b; public void assignB（）{b = new B（）}} public class B {C c; public void assignC（）{c = new C（）}} public class C {A a; public void assignA（）{a = new A（）}}</pre><p>系统在类级别的粒度上跟踪依赖关系。在前面的例子中，可以看到的是类<code class="codeph">A</code> ， <code class="codeph">B</code> ，和<code class="codeph">C</code>互相依赖，因为<code class="codeph">A</code>持有的实例<code class="codeph">B</code> ， <code class="codeph">B</code>持有的一个实例<code class="codeph">C</code> ，和<code class="codeph">C</code>保持的一个实例<code class="codeph">A</code> 。如果通过向其添加新字段来更改类<code class="codeph">A</code>的定义，则Oracle数据库中的依赖性机制将类<code class="codeph">B</code>和<code class="codeph">C</code>标记为无效。在再次使用这些类之前，Oracle数据库会尝试解析它们并在必要时重新编译。请注意，只有在服务器上存在源文件时才能重新编译类。
                        </p>
                        <p>依赖系统使您可以依赖Oracle数据库来管理类之间的依赖关系，重新编译和自动解决。只有在开发过程中并且想要尽早发现问题时，才必须自行强制编译和解决。如果您不希望依赖关系管理工具为您执行此操作， <code class="codeph">loadjava</code>工具还提供强制编译和解决的功能。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDEV02042"></a><div class="props_rev_3"><a id="GUID-F17E6450-17E3-49EE-9258-EF5E01748198" name="GUID-F17E6450-17E3-49EE-9258-EF5E01748198"></a><h3 id="JJDEV-GUID-F17E6450-17E3-49EE-9258-EF5E01748198" class="sect3"><span class="enumeration_section">2.5.2</span>解决类依赖关系概述</h3>
               <div>
                  <p>许多Java类包含对其他类的引用，这是重用代码的本质。传统的JVM在<code class="codeph">CLASSPATH</code>指定的目录中搜索<code class="codeph">.class</code> ， <code class="codeph">.zip</code>和<code class="codeph">.jar</code>文件。相反，Oracle JVM在数据库模式中搜索类对象。在Oracle数据库中，因为您将所有Java类加载到数据库中，所以可能需要指定在数据库中查找Java类的依赖类的位置。
                  </p>
                  <p>数据库中加载的所有类都称为类模式对象，并在某些模式中加载。所有预定义的Java应用程序编程接口（API）（例如<code class="codeph">java.lang.*</code> ）都在<code class="codeph">PUBLIC</code>模式中加载。如果您的类依赖于您定义的其他类，那么您可能会在自己的架构中加载它们。例如，如果您的架构是<code class="codeph">HR</code> ，则数据库解析程序在搜索<code class="codeph">PUBLIC</code>架构之前搜索<code class="codeph">HR</code>架构。用于搜索的模式列表称为a <a id="d8687e1703" class="indexterm-anchor"></a> <span class="bold">解析器规范</span> 。为每个类定义解析器规范。这与经典JVM形成对比，其中<code class="codeph">CLASSPATH</code>对所有类都是全局的。
                  </p>
                  <p>在查找和解析类的类间依赖关系时，解析程序将每个类标记为有效或无效，具体取决于是否找到所有相互依赖的类。如果您加载的类包含对在相应模式中找不到的类的引用，则该类将列为无效。运行时不成功的解决方案会产生<code class="codeph">ClassNotFound</code>异常。此外，如果类树非常大，则运行时解析可能因缺少数据库资源而失败。
                  </p>
                  <div class="infoboxnote" id="GUID-F17E6450-17E3-49EE-9258-EF5E01748198__GUID-F211E9C7-4342-4BE1-BAA6-C0938F7A0336">
                     <p class="notep1">注意：</p>
                     <p>与Java编译器一样， <code class="codeph">loadjava</code>工具解析对类的引用，但不解析对资源的引用。确保正确加载类所需的资源文件。
                     </p>
                  </div>
                  <p><a id="d8687e1725" class="indexterm-anchor"></a>对于类中的每个类间引用，解析器将搜索解析器规范指定的模式以获取有效的模式<a id="d8687e1730" class="indexterm-anchor"></a>满足引用的类模式对象。如果所有引用都已解析，则解析程序将该类标记为有效。从未解决过或已解决失败的类被标记为无效。依赖于变为无效的模式对象的类也标记为无效。
                  </p>
                  <p><a id="d8687e1736" class="indexterm-anchor"></a><a id="d8687e1740" class="indexterm-anchor"></a>为了更容易地搜索依赖类，Oracle数据库提供了一个默认的解析器和解析器规范，它首先搜索定义者的模式，然后搜索<code class="codeph">PUBLIC</code>模式。这涵盖了数据库中加载的大多数类。但是，如果要访问除自己或<code class="codeph">PUBLIC</code>之外的模式中的类，则必须定义自己的解析器规范。
                  </p>
                  <p>可以通过以下方式解决类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用默认解析程序加载，该解析程序搜索定义者的模式和<code class="codeph">PUBLIC</code> ：</p><pre class="oac_no_warn" dir="ltr">loadjava -resolve</pre></li>
                     <li>
                        <p>使用您自己的解析器规范定义加载：</p><pre class="oac_no_warn" dir="ltr">loadjava-resolve -resolver“（（* HR）（* OTHER）（* PUBLIC））”</pre><p>在前面的示例中，解析程序规范定义包括<code class="codeph">HR</code>模式， <code class="codeph">OTHER</code>模式和<code class="codeph">PUBLIC</code> 。</p>
                     </li>
                  </ul>
                  <p><code class="codeph">-resolver</code>选项指定要在定义的模式中搜索的对象。在前面的示例中，在<code class="codeph">HR</code> ， <code class="codeph">OTHER</code>和<code class="codeph">PUBLIC</code>中搜索所有类模式对象。但是，如果要仅搜索架构中的某个类或类组，则可以缩小搜索范围。例如，要仅搜索<code class="codeph">OTHER</code>模式中的<code class="codeph">my/gui/*</code>类，您可以按如下方式定义解析器规范：</p><pre class="oac_no_warn" dir="ltr">loadjava -resolve -resolver'（（* HR）（“my / gui / *”OTHER）（* PUBLIC））'</pre><p>解析器规范中的第一个参数用于类模式对象，第二个参数定义用于搜索这些类模式对象的模式。</p>
               </div>
               <div class="props_rev_3"><a id="GUID-B0AEB608-C38C-4064-9259-C404B9C8024A" name="GUID-B0AEB608-C38C-4064-9259-C404B9C8024A"></a><h4 id="JJDEV-GUID-B0AEB608-C38C-4064-9259-C404B9C8024A" class="sect4"><span class="enumeration_section">2.5.2.1</span>允许引用不存在的类</h4>
                  <div>
                     <div class="section">
                        <p>您可以在解析程序规范中指定一个特殊选项，该选项允许对不存在的类进行未解析的引用。有时，内部类永远不会在产品中使用。在标准Java环境中，这不是问题，因为只要不调用方法，JVM就会忽略它们。但是，在解析类时，Oracle JVM会尝试解析该类引用的所有名称，包括可能永远不会使用的名称。如果Oracle JVM无法为该类引用的每个此类名称找到匹配的类，则正在解析的类将标记为无效且无法运行。</p>
                        <p>要忽略引用，可以在解析器规范中指定通配符减号（ <code class="codeph">-</code> ）。以下示例指定允许对<code class="codeph">my/gui</code>中的类进行任何引用，即使它在解析器规范模式列表中不存在。
                        </p><pre class="oac_no_warn" dir="ltr">loadjava -resolve -resolver'（（* HR）（* PUBLIC）（“my / gui / *” - ））'</pre><p>如果没有通配符，如果在其中一个模式中找不到依赖类，则您的类将列为无效并且无法运行。</p>
                        <p>此外，您可以定义要忽略所有未找到的类。但是，这很危险，因为具有依赖类的类将被标记为有效，即使依赖类不存在也是如此。但是，如果没有依赖类，该类永远不能运行。在这种情况下，您将在运行时收到异常。</p>
                        <p>要忽略<code class="codeph">HR</code>或<code class="codeph">PUBLIC</code>未找到的所有类，请指定以下解析程序规范：</p><pre class="oac_no_warn" dir="ltr">loadjava -resolve -resolver“（（* HR）（* PUBLIC）（*  - ））”</pre><p>如果您以后打算加载要求您使用此类解析程序的不存在的类，则不应使用包含减号（ - ）通配符的解析程序。相反，在解析之前包括模式中的所有引用类。</p>
                        <p>即使使用减号（ - ）通配符，类的超类也永远不存在。如果未找到超类，则无论在解析器中使用减号（ - ）通配符，该类都将无效。</p>
                        <div class="infoboxnote" id="GUID-B0AEB608-C38C-4064-9259-C404B9C8024A__GUID-1C350115-5FB7-4246-953E-893AFD2B3528">
                           <p class="notep1">注意：</p>
                           <p>处理不存在的类的另一种机制是使用<code class="codeph">loadjava</code>工具的<code class="codeph">-gemissing</code>选项。此选项使<code class="codeph">loadjava</code>工具创建和加载引用但未定义的类的定义。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13075"></a><div class="props_rev_3"><a id="GUID-EFDB4640-FABA-45FE-961C-CC6EAA5C65D9" name="GUID-EFDB4640-FABA-45FE-961C-CC6EAA5C65D9"></a><h4 id="JJDEV-GUID-EFDB4640-FABA-45FE-961C-CC6EAA5C65D9" class="sect4"><span class="enumeration_section">2.5.2.2</span>字节码验证器</h4>
                  <div>
                     <div class="section">
                        <p>根据JVM规范， <code class="codeph">.class</code>文件在它们定义的类在JVM中可用之前需要进行验证。在Oracle JVM中，验证过程在类解析时进行。
                        </p>
                        <p>下表描述了解析程序可能发现的问题以及发出的相应Oracle错误代码。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-EFDB4640-FABA-45FE-961C-CC6EAA5C65D9__CEGFGFAC">
                        <p class="titleintable">表2-4 ORA错误</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="ORA错误" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d8687e2043">错误代码</th>
                                 <th align="left" valign="bottom" width="69%" id="d8687e2046">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d8687e2051" headers="d8687e2043 ">
                                    <p><code class="codeph">ORA-29545</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d8687e2051 d8687e2046 ">
                                    <p>如果解析器确定类格式不正确，则解析器不会将其标记为有效。当解析器拒绝某个类时，它会发出<code class="codeph">ORA-29545</code>错误。<code class="codeph">loadjava</code>工具报告错误。例如，如果<code class="codeph">.class</code>文件的内容不是Java编译的结果或文件已损坏，则抛出此错误。
                                    </p>
                                    <p>如果您使用解析器的减号（ - ）通配符表达式并且未验证某些类的有效性，则<code class="codeph">ORA-29545</code>错误也可能会出现。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d8687e2073" headers="d8687e2043 ">
                                    <p><code class="codeph">ORA-29552</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d8687e2073 d8687e2046 ">
                                    <p>在某些情况下，解析器允许将类标记为有效，但会替换类中的字节码以在运行时引发异常。在这些情况下，解析程序会发出<code class="codeph">loadjava</code>工具报告的<code class="codeph">ORA-29552</code>警告。当Java语言规范（JLS）要求抛出<code class="codeph">IncompatibleClassChangeError</code>时， <code class="codeph">loadjava</code>工具会发出此警告。Oracle JVM依靠解析器来检测这些情况，支持JLS所需的正确运行时行为。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p><a id="d8687e2094" class="indexterm-anchor"></a>带有减号（ <code class="codeph">-</code> ）通配符的解析程序将您的类标记为有效，无论您的类引用的类是否存在。由于继承和接口，您可能希望编写使用类实例的有效Java方法，就好像它是超类或特定接口的实例一样。当被验证的方法使用对<code class="codeph">A</code>类的引用时，就好像它是对<code class="codeph">B</code>类的引用一样，解析器必须检查<code class="codeph">A</code>是扩展还是实现<code class="codeph">B</code>例如，考虑以下可能有效的方法，其签名意味着返回<code class="codeph">B</code>的实例，但其主体返回<code class="codeph">A</code>的实例：</p><pre class="oac_no_warn" dir="ltr">B myMethod（A a）{return a; }</pre><p>仅当<code class="codeph">A</code>扩展<code class="codeph">B</code>类或<code class="codeph">A</code>实现接口<code class="codeph">B</code>该方法才有效。如果使用减号（ - ）通配符解析了<code class="codeph">A</code>或<code class="codeph">B</code> ，则解析器不知道此方法是安全的。在这种情况下，解析器将<code class="codeph">myMethod</code>的字节码替换为在调用<code class="codeph">myMethod</code>抛出异常的字节码。
                        </p>
                        <p>没有减号（ <code class="codeph">-)</code>通配符的解析程序可确保找到并正确解析<code class="codeph">A</code>和<code class="codeph">B</code>的类定义（如果它们存在于它们专门标识的模式中）。您可以考虑使用替代解析程序的唯一情况是，您是否必须加载包含引用其他非系统类的类的现有JAR文件，这些类未包含在JAR文件中。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="schema-objects-and-Oracle-JVM-utilities.html#GUID-2A76FBC2-3A4A-4620-9A83-CA01724B13DB">架构对象和Oracle JVM实用程序</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDEV13565"></a><div class="props_rev_3"><a id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438" name="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438"></a><h3 id="JJDEV-GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438" class="sect3"><span class="enumeration_section">2.5.3</span>登录Oracle JVM</h3>
               <div>
                  <div class="section">
                     <p>Oracle JVM在日志记录属性查找领域扩展了JDK Java Logging API，以增强日志记录配置管理的安全性并支持基于用户的日志记录配置。</p>
                     <div class="infoboxnotealso" id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438__GUID-56563E43-CD7A-424C-AADF-01FCB6DDF9FA">
                        <p class="notep1">也可以看看：</p>
                        <p>有关Java Logging API的更多信息，请访问以下站点：</p>
                        <p><a href="http://docs.oracle.com/javase/7/docs/" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/</code></a></p>
                     </div>
                     <p>你必须激活<a id="d8687e2275" class="indexterm-anchor"></a>会话中的<code class="codeph">LogManager</code>初始化Oracle JVM中的日志记录属性。每个会话使用<code class="codeph">LogManager</code> API初始化日志记录属性， <code class="codeph">LogManager</code> API使用数据库驻留资源查找进行扩展。
                     </p>
                     <p>Oracle JVM执行以下步骤来配置日志记录选项：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand" id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438__CEGDJFCG"><span>如果设置了<code class="codeph">java.util.logging.config.class</code>属性，则日志记录行为与标准JDK中的相同。</span></li>
                     <li class="stepexpand" id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438__CEGGCACF"><span>如果未设置<code class="codeph">java.util.logging.config.class</code>属性，则Oracle JVM会检查当前用户架构中<code class="codeph">javavm/lib/logging.properties</code>资源的可用性。</span><div>
                           <p>如果可用，此资源将用作<code class="codeph">LogManager</code>的配置设置，并设置<code class="codeph">java.util.logging.config.file</code>属性。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand" id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438__CEGBGJHC"><span>如果上述两个条件都不成立，则检查<code class="codeph">java.util.logging.config.file</code>属性，如果指定， <code class="codeph">LogManager</code> API中的描述使用。</span></li>
                     <li class="stepexpand"><span>如果步骤1,2和3中的条件均不成立，则使用<code class="codeph">SYS</code>模式中的<code class="codeph">javavm/lib/logging.properties</code>资源。此资源是<code class="codeph">$(java.home)/lib/logging.properties</code>文件的副本，该文件在数据库创建时加载到<code class="codeph">SYS</code>模式中。这意味着，默认情况下， <code class="codeph">LogManager</code>行为就像根据<code class="codeph">$(java.home)/javavm/lib/logging.properties</code>文件配置一样。但是，在重新创建数据库之前，更改此文件无效</span></li>
                  </ol>
                  <div class="section">
                     <p>如果您对<code class="codeph">javavm/lib/logging.properties</code>文件中的缺省设置不满意，请准备一组不同的属性，并使用<code class="codeph">loadjava</code>命令将它们加载到模式中。例如，如果您的模式是<code class="codeph">HR</code>并且您当前的文件目录是<code class="codeph">mydir</code> ，那么在<code class="codeph">mydir</code>下创建一个目录<code class="codeph">javavm/lib/</code>并在<code class="codeph">mydir/javavm/lib/</code>目录下的<code class="codeph">logging.properties</code>文件中指定所需的属性。然后，从<code class="codeph">mydir</code>调用<code class="codeph">loadjava</code>命令，如下所示：</p><pre class="oac_no_warn" dir="ltr">mydir％loadjava -u HR -v -r javavm / lib / logging.properties password： <span class="italic">&lt;password&gt;</span>
</pre><p>调用<code class="codeph">loadjava</code>命令后，可以删除<code class="codeph">mydir/javavm/lib/logging.properties</code>文件。任何作为<code class="codeph">HR</code>运行并执行<code class="codeph">LogManager</code>激活的会话都将使<code class="codeph">LogManager</code>配置来自此数据库驻留资源的属性专用于<code class="codeph">HR</code> 。</p>
                     <div class="infoboxnote" id="GUID-F14EAF04-948C-4CF6-A034-5E8D692BC438__GUID-14F99A6E-DB95-47EE-9B02-1EEF43422289">
                        <p class="notep1">注意：</p>
                        <p>Oracle JVM始终使用安全管理器运行。因此，无论使用何种日志配置方法，都必须为<code class="codeph">HR</code>授予日志记录权限。在大多数情况下，特权用户发出的以下调用足以授予这些权限：</p><pre class="oac_no_warn" dir="ltr">调用dbms_java.grant_permission（'HR'，'SYS：java.util.logging。LoggingPermission'，'control'，''）;</pre></div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDEV13076"></a><a id="JJDEV13077"></a><a id="JJDEV02043"></a><div class="props_rev_3"><a id="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63" name="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63"></a><h3 id="JJDEV-GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63" class="sect3"><span class="enumeration_section">2.5.4</span>使用loadjava工具加载类概述</h3>
               <div>
                  <div class="section">
                     <p><a id="d8687e2524" class="indexterm-anchor"></a>您可以使用<code class="codeph">loadjava</code>工具从文件创建模式对象，并将模式对象加载到不同的模式。例如，</p><pre class="oac_no_warn" dir="ltr">loadjava -u HR -schema TEST MyClass.java密码： <span class="italic">密码</span>
</pre><div class="infoboxnote" id="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63__GUID-720C6F10-4316-4731-AAF8-EB18F3907CC4">
                        <p class="notep1">注意：</p>
                        <p>如果使用命令行界面， <span class="italic">则不</span>必将类作为模式对象加载到数据库。例如，</p><pre class="oac_no_warn" dir="ltr">C：\ oraclehome \ bin&gt; loadjava -u HR MyClass.java密码： <span class="italic">密码</span>
</pre></div>
                     <p>您还可以在SQL命令中运行<code class="codeph">loadjava</code>工具。与从文件编译和加载的传统JVM不同，Oracle JVM从数据库模式对象编译和加载。
                     </p>
                     <p>以下内容描述了与传统JVM使用的文件相对应的数据库模式对象。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63__CEGFBCFA">
                     <p class="titleintable">表2-5 Java文件说明</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Java文件的描述" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="52%" id="d8687e2563">Java文件类型</th>
                              <th align="left" valign="bottom" width="48%" id="d8687e2566">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d8687e2571" headers="d8687e2563 ">
                                 <p><a id="d8687e2573" class="indexterm-anchor"></a><a id="d8687e2575" class="indexterm-anchor"></a> <code class="codeph">.java</code>源文件或<code class="codeph">.sqlj</code>源文件</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d8687e2571 d8687e2566 ">
                                 <p>对应于Java的源模式对象</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d8687e2590" headers="d8687e2563 ">
                                 <p><a id="d8687e2592" class="indexterm-anchor"></a> <code class="codeph">.class</code>编译的Java文件</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d8687e2590 d8687e2566 ">
                                 <p>对应Java <a id="d8687e2600" class="indexterm-anchor"></a><a id="d8687e2604" class="indexterm-anchor"></a>类模式对象</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d8687e2608" headers="d8687e2563 ">
                                 <p><code class="codeph">.properties</code> Java资源文件， <code class="codeph">.ser</code> SQLJ配置文件或数据文件</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d8687e2608 d8687e2566 ">
                                 <p>对应Java <a id="d8687e2619" class="indexterm-anchor"></a>资源模式对象</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>您必须将所有类或资源加载到数据库中以供数据库中的其他类使用。此外，在加载时，您可以定义谁可以在数据库中运行您的类。</p>
                     <p>下表描述了<code class="codeph">loadjava</code>工具为每种类型的文件执行的活动。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63__CEGEDDGB">
                     <p class="titleintable">表2-6架构对象上的loadjava操作</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="架构对象上的loadjava操作" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d8687e2640">架构对象</th>
                              <th align="left" valign="bottom" width="69%" id="d8687e2643">loadjava对象的操作</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e2648" headers="d8687e2640 ">
                                 <p><a id="d8687e2650" class="indexterm-anchor"></a> <code class="codeph">.java</code>源文件</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e2648 d8687e2643 ">
                                 <ol>
                                    <li>
                                       <p>创建一个Java <a id="d8687e2660" class="indexterm-anchor"></a>除非指定了另一个模式，否则定义者模式中的源模式对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>将源文件的内容加载到架构对象中。</p>
                                    </li>
                                    <li>
                                       <p>为源文件中定义的所有类创建类模式对象。</p>
                                    </li>
                                    <li>
                                       <p>如果请求<code class="codeph">-resolve</code> ，则编译源模式对象并解析类及其依赖项。然后，它将已编译的类存储到类模式对象中。
                                       </p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e2676" headers="d8687e2640 ">
                                 <p><code class="codeph">.sqlj</code>源文件</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e2676 d8687e2643 ">
                                 <ol>
                                    <li>
                                       <p>创建一个<a id="d8687e2686" class="indexterm-anchor"></a>除非指定了另一个模式，否则定义者模式中的源模式对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>将源文件的内容加载到架构对象中。</p>
                                    </li>
                                    <li>
                                       <p>为源文件中定义的所有类和资源创建类模式对象。</p>
                                    </li>
                                    <li>
                                       <p>如果请求<code class="codeph">-resolve</code> ，则转换并编译源模式对象，并将编译后的类存储到类模式对象中。然后，它将配置文件存储到<code class="codeph">.ser</code>资源架构对象中并对其进行自定义。
                                       </p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e2705" headers="d8687e2640 ">
                                 <p><a id="d8687e2707" class="indexterm-anchor"></a> <code class="codeph">.class</code>编译的Java文件</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e2705 d8687e2643 ">
                                 <ol>
                                    <li>
                                       <p>创建一个<a id="d8687e2717" class="indexterm-anchor"></a><a id="d8687e2721" class="indexterm-anchor"></a>除非指定了另一个模式，否则定义者模式中的类模式对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>将类文件加载到架构对象中。</p>
                                    </li>
                                    <li>
                                       <p>如果指定了<code class="codeph">-resolve</code>则解析并验证类及其依赖项。
                                       </p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e2734" headers="d8687e2640 ">
                                 <p><code class="codeph">.properties</code> Java资源文件</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e2734 d8687e2643 ">
                                 <ol>
                                    <li>
                                       <p>创建一个<a id="d8687e2744" class="indexterm-anchor"></a>除非指定了另一个模式，否则定义者模式中的资源模式对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>将资源文件加载到架构对象中。</p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e2751" headers="d8687e2640 ">
                                 <p><code class="codeph">.ser</code> SQLJ配置文件</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e2751 d8687e2643 ">
                                 <ol>
                                    <li>
                                       <p>创建一个<a id="d8687e2761" class="indexterm-anchor"></a>除非指定了另一个模式，否则定义者模式中的资源模式对象。
                                       </p>
                                    </li>
                                    <li>
                                       <p>将<code class="codeph">.ser</code>资源文件加载到架构对象中并对其进行自定义。
                                       </p>
                                    </li>
                                 </ol>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-D920E247-8D81-4D08-8A5D-8C47BAC52C63__GUID-0846FAAB-1703-4F90-A413-73C6B0977AEA">
                        <p class="notep1">注意：</p>
                        <p><a id="d8687e2773" class="indexterm-anchor"></a>所述<code class="codeph">dropjava</code>工具执行的反向<code class="codeph">loadjava</code>工具。它删除与Java文件对应的模式对象。始终使用<code class="codeph">dropjava</code>工具来删除与创建的Java模式对象<code class="codeph">loadjava</code>工具。例如，</p><pre class="oac_no_warn" dir="ltr">dropjava -u HR -schema TEST MyClass.java密码： <span class="italic">密码</span>
</pre><p>删除SQL数据定义语言（DDL）命令不会更新<code class="codeph">loadjava</code>工具和<code class="codeph">dropjava</code>工具维护的辅助数据。您还可以从SQL命令中运行<code class="codeph">dropjava</code>工具。
                        </p>
                        <p><a id="d8687e2805" class="indexterm-anchor"></a>加载类和资源后，可以访问数据库模式中的<code class="codeph">USER_OBJECTS</code>视图，以验证是否已正确加载类和资源。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="schema-objects-and-Oracle-JVM-utilities.html#GUID-2A76FBC2-3A4A-4620-9A83-CA01724B13DB">架构对象和Oracle JVM实用程序</a></li>
                        <li><a href="invoking-Java-methods.html#GUID-FC2894A1-87C3-4695-968E-A3E69344B353">关于使用命令行界面</a></li>
                     </ul>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-8D6C27CF-FA07-4D6F-823F-32BB6AB4FCC8" name="GUID-8D6C27CF-FA07-4D6F-823F-32BB6AB4FCC8"></a><h4 id="JJDEV-GUID-8D6C27CF-FA07-4D6F-823F-32BB6AB4FCC8" class="sect4"><span class="enumeration_section">2.5.4.1</span>关于用户类加载类的元数据共享</h4>
                  <div>
                     <p>由内置机制加载的用于加载数据库驻留类的类称为<span class="bold">系统类加载</span> ，而通过其他方式<span class="bold">加载的类</span>称为<span class="bold">用户类加载</span> 。将类加载到数据库中时，会在内存中创建类的表示形式，其中一部分在此处称为类元数据。对于使用该类的任何会话，类元数据是相同的，并且可能是可共享的。之前，此类共享仅适用于系统类加载的类。从Oracle Database <span class="italic">11g开始</span> ，您还可以根据系统管理员的意愿共享用户类加载类的类元数据。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="classpath-extensions-user-classes-metadata.html#GUID-C948182D-D9C7-45DB-9B7A-648BBCA47F6E">类路径扩展和用户分类加载的元数据</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A0EF25BC-DC00-4B1E-9968-35C1D2E134D4" name="GUID-A0EF25BC-DC00-4B1E-9968-35C1D2E134D4"></a><h4 id="JJDEV-GUID-A0EF25BC-DC00-4B1E-9968-35C1D2E134D4" class="sect4"><span class="enumeration_section">2.5.4.2</span>定义相同类两次</h4>
                  <div>
                     <div class="section">
                        <p><a id="d8687e3024" class="indexterm-anchor"></a>在同一模式中，不能有两个具有相同名称的类对象。此规则以两种方式影响您：</p>
                        <div class="infoboxnote" id="GUID-A0EF25BC-DC00-4B1E-9968-35C1D2E134D4__GUID-972F8E4F-6276-421C-A5D1-21C945BE2187">
                           <p class="notep1">注意：</p>
                           <p>此规则的一个例外是当您对数据库驻留JAR使用<code class="codeph">-prependjarnames</code>选项时。如果使用此选项，则可以在同一模式中具有两个具有相同类名的类。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以加载特定的Java <code class="codeph">.class</code>文件或其<code class="codeph">.java</code>文件，但不能同时加载两者。
                              </p>
                              <p>Oracle数据库跟踪您是加载了类文件还是源文件。如果要更新类，则必须加载最初加载的相同类型的文件。如果要更新其他类型，则必须在加载第二个类型之前删除第一个类型。例如，如果您加载<code class="codeph">x.java</code>作为类<code class="codeph">y</code>的源，那么要加载<code class="codeph">x.class</code> ，您必须首先删除<code class="codeph">x.java</code> 。
                              </p>
                           </li>
                           <li>
                              <p>您无法在同一模式中的两个不同模式对象中定义相同的类。例如，假设<code class="codeph">x.java</code>定义了类<code class="codeph">y</code>并且您希望将<code class="codeph">y</code>的定义移动到<code class="codeph">z.java</code> 。如果<code class="codeph">x.java</code>已经加载，则<code class="codeph">loadjava</code>工具拒绝任何企图加载<code class="codeph">z.java</code> ，这也定义了<code class="codeph">y</code> 。相反，请执行以下任一操作：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>删除<code class="codeph">x.java</code> ，加载定义<code class="codeph">y</code> <code class="codeph">z.java</code> ，然后加载新的<code class="codeph">x.java</code> ，它不定义<code class="codeph">y</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>加载新的<code class="codeph">x.java</code> ，它不定义<code class="codeph">y</code> ，然后加载定义<code class="codeph">y</code> <code class="codeph">z.java</code> 。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="preparing-Java-class-methods.html#GUID-E4FAFBDA-6E16-41E2-B3A7-E3E3EAF9CD3E">数据库驻留JAR</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A5003838-A6C1-43E6-A546-03F2EFA87247" name="GUID-A5003838-A6C1-43E6-A546-03F2EFA87247"></a><h4 id="JJDEV-GUID-A5003838-A6C1-43E6-A546-03F2EFA87247" class="sect4"><span class="enumeration_section">2.5.4.3</span>关于指定数据库权限和JVM权限</h4>
                  <div>
                     <div class="section">
                        <p>您必须具有以下SQL数据库权限才能加载类：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">CREATE PROCEDURE</code>和<code class="codeph">CREATE TABLE</code>权限以加载到您的架构中。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">CREATE ANY PROCEDURE</code>并<code class="codeph">CREATE ANY TABLE</code>权限以加载到另一个模式。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.aurora.security。JServerPermission.loadLibraryInClass.</code> <span class="italic"><code class="codeph">classname</code></span> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-contents-Oracle-JVM-security.html#GUID-E3427117-0517-4B6D-B346-81BB36A51489">加载类的权限</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-40C45ED1-F7CA-4AD3-8E06-BBCEEF156780" name="GUID-40C45ED1-F7CA-4AD3-8E06-BBCEEF156780"></a><h4 id="JJDEV-GUID-40C45ED1-F7CA-4AD3-8E06-BBCEEF156780" class="sect4"><span class="enumeration_section">2.5.4.4</span>关于加载JAR或ZIP文件</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">loadjava</code>工具接受<code class="codeph">.class</code> ， <code class="codeph">.java</code> ， <code class="codeph">.properties</code> ， <code class="codeph">.sqlj</code> ， <code class="codeph">.ser</code> ， <code class="codeph">.jar</code>或<code class="codeph">.zip</code>文件。JAR或ZIP文件可以包含源，类和数据文件。将JAR或ZIP文件传递给<code class="codeph">loadjava</code>工具时，它会打开存档并单独加载存档的成员。没有JAR或ZIP架构对象。如果JAR或ZIP内容自上次加载后未发生更改，则不会重新加载。因此，加载JAR或ZIP文件几乎没有性能损失。实际上，加载JAR或ZIP文件是使用<code class="codeph">loadjava</code>工具的最简单方法。
                        </p>
                        <div class="infoboxnote" id="GUID-40C45ED1-F7CA-4AD3-8E06-BBCEEF156780__GUID-8A7B311F-D034-4C70-921B-0594E7752561">
                           <p class="notep1">注意：</p>
                           <p>如果类自上次加载后没有更改，则不会重新加载类。但是，您可以使用<code class="codeph">-force</code>选项强制重新加载类。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-E4FAFBDA-6E16-41E2-B3A7-E3E3EAF9CD3E" name="GUID-E4FAFBDA-6E16-41E2-B3A7-E3E3EAF9CD3E"></a><h4 id="JJDEV-GUID-E4FAFBDA-6E16-41E2-B3A7-E3E3EAF9CD3E" class="sect4"><span class="enumeration_section">2.5.4.5</span>数据库驻留JAR</h4>
                  <div>
                     <div class="section">
                        <p>从<span class="italic">11g</span>版本1（11.1）开始，当您将JAR的内容加载到数据库中时，您可以选择创建表示JAR本身的数据库对象。通过这种方式，您可以保留此JAR对象与从JAR加载的类，资源和源对象之间的关联。这使您能够：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用签名的JAR和JAR名称空间隔离的方式与在标准JVM中使用它们的方式相同。</p>
                           </li>
                           <li>
                              <p>管理从JAR派生的类，同时将其作为单个单元加载到数据库中。这有助于您防止从JAR加载的类的个别重新定义。它还允许您删除从JAR加载的整个类集，无论外部文件系统上的内容或JAR是否继续存在，在删除它时。</p>
                           </li>
                        </ul>
                        <p>要将JAR加载到数据库中，您可以使用<code class="codeph">loadjava</code>工具的以下选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">-jarsasdbobjects</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">-prependjarnames</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="loadjava-tool.html#GUID-033299E6-07E2-4C2C-9E26-A2FE25118F1C">loadjava工具</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDEV13084"></a><a id="JJDEV13083"></a><div class="props_rev_3"><a id="GUID-3F57CC21-BC4C-4203-B477-695E039D5973" name="GUID-3F57CC21-BC4C-4203-B477-695E039D5973"></a><h3 id="JJDEV-GUID-3F57CC21-BC4C-4203-B477-695E039D5973" class="sect3"><span class="enumeration_section">2.5.5</span>授予执行权限概述</h3>
               <div>
                  <p><a id="d8687e3608" class="indexterm-anchor"></a>如果在自己的模式中加载所有类，并且不引用模式之外的任何类，则您已拥有运行类的权限。您具有对象调用同一模式中加载的其他对象所需的特权。也就是说， <code class="codeph">A</code>类能够调用<code class="codeph">B</code>类。类<code class="codeph">A</code>必须给予调用类权<code class="codeph">B</code> 。</p>
                  <p><a id="d8687e3626" class="indexterm-anchor"></a>定义Java应用程序的类在其所有者的SQL模式下存储在Oracle数据库中。默认情况下，出于安全考虑，其他用户无法运行驻留在一个用户架构中的类。您可以通过以下方式为其他用户提供运行课程的权限：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<code class="codeph">loadjava -grant</code>选项</p>
                     </li>
                     <li>
                        <p>使用以下命令：</p><pre class="oac_no_warn" dir="ltr">SQL&gt;将myclass上的execute赋予HR;</pre><p>其中， <code class="codeph">myclass</code>是底层Java类的名称。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-3F57CC21-BC4C-4203-B477-695E039D5973__GUID-2572C53A-E3F5-414D-89DB-99CEDC94A45D">
                     <p class="notep1">注意：</p>
                     <p>在Oracle Database <span class="italic">11g第</span> 1版（11.1）之前，授予对存储过程的执行权限意味着授予对存储过程引用的存储过程和Java类的执行权限。自Oracle Database <span class="italic">11g</span>发布以来，如果您还希望在底层Java类上授予执行权限，则必须明确授予该类的执行权限。实现这是为了提高安全性。
                     </p>
                  </div>
                  <p>下图说明了运行类所需的权限。</p>
                  <div class="figure" id="GUID-3F57CC21-BC4C-4203-B477-695E039D5973__CEGFCIGG">
                     <p class="titleinfigure">图2-3运行类的权限</p><img src="img/exeright.gif" alt="下面是图2-3的描述" title="下面是图2-3的描述" longdesc="img_text/exeright.html"><br><a href="img_text/exeright.html">“图2-3运行类的权限”的说明</a></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="loadjava-tool.html#GUID-033299E6-07E2-4C2C-9E26-A2FE25118F1C">loadjava工具</a></li>
                        <li><a href="Java-application-performance.html#GUID-7AB351A8-AA78-477C-AC3F-B5AD74E79A2B">Oracle数据库Java应用程序性能</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13086"></a><a id="JJDEV13087"></a><a id="JJDEV13085"></a><div class="props_rev_3"><a id="GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7" name="GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7"></a><h3 id="JJDEV-GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7" class="sect3"><span class="enumeration_section">2.5.6</span>控制当前用户的概述</h3>
               <div>
                  <p>在执行PL / SQL代码期间，始终存在当前用户。相同的概念用于执行Java代码。最初，当前用户是用户，他创建调用Java代码的会话。通过相应的包装器从SQL或PL / SQL调用Java方法。Java包装器是特殊的PL / SQL实体，它将Java方法暴露给SQL和PL / SQL作为PL / SQL存储过程或函数。这样的包装器可能会改变当前的有效用户。将当前有效用户更改为包装器所有者的包装器称为definer的权限包装器。如果包装器未更改当前有效用户，则有效用户保持不变。</p>
                  <p>默认情况下，Java包装器是<a id="d8687e3774" class="indexterm-anchor"></a>定义者的权利包装。如果要覆盖它，请使用<code class="codeph">AUTHID CURRENT_USER</code>选项创建包装器。
                  </p>
                  <p>在执行Java代码期间的任何时候，都会维护Java调用堆栈。堆栈包含与输入的Java方法相对应的帧，最里面的帧对应于当前正在执行的方法。默认情况下，Java方法在堆栈上执行而不更改当前用户，即具有当前有效调用者的权限，而不是他们的定义者。</p>
                  <p>您可以使用<code class="codeph">loadjava -definer</code>选项将Java类加载到数据库。具有标记的definer属性的类的任何方法都成为定义者的权限方法。当输入这样的方法时，在Java堆栈上创建一种称为定义器框架的特殊帧。该帧将当前有效用户切换到此类的所有者（定义者）。新的用户ID对所有内部框架保持有效，直到定义器的框架从堆栈弹出或输入嵌套的定义框架为止。
                  </p>
                  <p>因此，在执行从SQL或PL / SQL通过其包装器调用的Java方法的任何给定时间，有效用户都是以下之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Java堆栈中最里面的定义器框架</p>
                     </li>
                     <li>
                        <p>最顶层Java方法的PL / SQL包装器的所有者，如果它是定义者的权限，或者是调用包装器的用户。</p>
                     </li>
                  </ul>
                  <p>考虑使用定义者权利程序来分析销售额的公司。要提供本地销售统计信息，过程<code class="codeph">analyze</code>必须访问驻留在每个区域站点的<code class="codeph">sales</code>表。为此，该过程还必须驻留在每个区域站点。这会导致维护问题。为了解决这个问题，公司在总部安装了一个调用程序权限版本的程序<code class="codeph">analyze</code> 。
                  </p>
                  <p>下图显示了所有区域站点如何使用相同的过程查询自己的<code class="codeph">sales</code>表。
                  </p>
                  <div class="figure" id="GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7__BABFBIBJ">
                     <p class="titleinfigure">图2-4 Invoker的权利解决方案</p><img src="img/invoker_rights_solution.gif" alt="下面是图2-4的描述" title="下面是图2-4的描述" longdesc="img_text/invoker_rights_solution.html"><br><a href="img_text/invoker_rights_solution.html">“图2-4祈求者权利解决方案”的描述</a></div>
                  <!-- class="figure" -->
                  <p>有时，您可能希望覆盖默认调用者的权限行为。假设总部希望<code class="codeph">analyze</code>程序计算销售佣金并更新中央<code class="codeph">payroll</code>表。这提出了一个问题，因为<code class="codeph">analyze</code>调用者不应该直接访问<code class="codeph">payroll</code>表， <code class="codeph">payroll</code>表存储员工工资和其他敏感数据。
                  </p>
                  <p>下图说明了解决方案，其中<code class="codeph">analyze</code>程序调用<code class="codeph">calcComm</code>的权限过程<code class="codeph">calcComm</code> ，后者又更新了<code class="codeph">payroll</code>表。
                  </p>
                  <div class="figure" id="GUID-4695681F-91B7-45A1-AA10-CD6BF046C4C7__BABDDBAD">
                     <p class="titleinfigure">图2-5间接访问</p><img src="img/controlled_access.gif" width="328" alt="下面是图2-5的描述" title="下面是图2-5的描述" longdesc="img_text/controlled_access.html"><br><a href="img_text/controlled_access.html">“图2-5间接访问”的描述</a></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="writing-top-level-call-specifications.html#GUID-140C918E-A174-42BA-AC1F-87907BD0E878">编写顶级呼叫规范</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13089"></a><a id="JJDEV13090"></a><a id="JJDEV13091"></a><a id="JJDEV13092"></a><a id="JJDEV13088"></a><div class="props_rev_3"><a id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1" name="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1"></a><h3 id="JJDEV-GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1" class="sect3"><span class="enumeration_section">2.5.7</span>检查Java上载概述</h3>
               <div>
                  <div class="section">
                     <p>您可以查询<code class="codeph">USER_OBJECTS</code>数据库视图以获取有关您拥有的模式对象的信息，包括Java源，类和资源。例如，这使您可以验证加载的源，类或资源是否正确存储在架构对象中。
                     </p>
                     <p>下表列出了<code class="codeph">USER_OBJECTS</code>中的键列及其说明。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1__BABJHIGG">
                     <p class="titleintable">表2-7关键USER_OBJECT列</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="关键USER_OBJECT列" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d8687e3983">名称</th>
                              <th align="left" valign="bottom" width="69%" id="d8687e3986">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e3991" headers="d8687e3983 ">
                                 <p><code class="codeph">OBJECT_NAME</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e3991 d8687e3986 ">
                                 <p>对象的名称</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e3999" headers="d8687e3983 ">
                                 <p><code class="codeph">OBJECT_TYPE</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e3999 d8687e3986 ">
                                 <p>对象的类型，例如<code class="codeph">JAVA SOURCE</code> ， <code class="codeph">JAVA CLASS</code>或<code class="codeph">JAVA RESOURCE</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8687e4016" headers="d8687e3983 ">
                                 <p><code class="codeph">状态</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8687e4016 d8687e3986 ">
                                 <p>对象的状态。值可以是<code class="codeph">VALID</code>或<code class="codeph">INVALID</code> 。它对<code class="codeph">JAVA RESOURCE</code>总是<code class="codeph">VALID</code>的。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1__GUID-A1DFE3E8-2936-4F68-95B6-8436ACA7E795">对象名称和类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>一个<code class="codeph">OBJECT_NAME</code>在<code class="codeph">USER_OBJECTS</code>是别名。如果超过30个字符，则完全限定名称将存储为别名。
                     </p>
                     <p><a id="d8687e4048" class="indexterm-anchor"></a><a id="d8687e4052" class="indexterm-anchor"></a>如果服务器使用架构对象的别名，则可以使用<code class="codeph">DBMS_JAVA</code>包的<code class="codeph">LONGNAME()</code>函数从查询中将其作为完全限定名称接收，而无需知道别名或转换规则。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT dbms_java.longname（object_name）FROM user_objects WHERE object_type ='JAVA SOURCE';</pre><p>此语句显示Java源模式对象的标准名称。如果没有使用别名，则不会发生转换。</p>
                     <div class="infoboxnote" id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1__GUID-9690559D-1872-414E-A30C-8AD688CB4905">
                        <p class="notep1">注意：</p>
                        <p>SQL和PL / SQL <span class="italic">不</span>区分大小写。
                        </p>
                     </div>
                     <p><a id="d8687e4074" class="indexterm-anchor"></a>您可以使用<code class="codeph">DBMS_JAVA</code>包的<code class="codeph">SHORTNAME()</code>函数将完全限定名称用作查询条件，而无需知道它是否已转换为数据库中的别名。
                     </p><pre class="oac_no_warn" dir="ltr">SQL * Plus&gt; SELECT object_type FROM user_objects WHERE object_name = dbms_java.shortname（'known_fullname'）;</pre><p>此语句显示具有指定的完全限定名称的架构对象的<code class="codeph">OBJECT_TYPE</code> 。这假设完全限定名称可在数据库字符集中表示。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; select * from javasnm; SHORT LONGNAME ------------------------------------------------ ---------------------- / 78e6d350_BinaryExceptionHandl sun / tools / java / BinaryExceptionHandler / b6c774bb_ClassDeclaration sun / tools / java / ClassDeclaration / af5a8ef3_JarVerifierStream1 sun / tools / jar / JarVerifierStream $ 1</pre><p>此语句显示存储在<code class="codeph">javasnm</code>视图中的所有数据。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1__GUID-22A7BF64-09D7-4F8A-B864-7289134A587D">状态</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><code class="codeph">STATUS</code>是一个字符串，表示Java模式对象的有效性。如果成功编译，则Java源模式对象为<code class="codeph">VALID</code>如果成功解析，则Java类模式对象为<code class="codeph">VALID</code> 。Java资源架构对象始终为<code class="codeph">VALID</code> ，因为资源未解析。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1FAE81CC-C835-4058-BCF8-15534DF1CFC1__GUID-F6183BC9-24B2-4B17-AA61-7E2173079F02">示例：访问USER_OBJECTS</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下SQL * Plus脚本访问<code class="codeph">USER_OBJECTS</code>视图以显示有关上载的Java源，类和资源的信息：</p><pre class="oac_no_warn" dir="ltr">COL object_name格式a30 COL object_type格式a15 SELECT object_name，object_type，status FROM user_objects WHERE object_type IN（'JAVA SOURCE'，'JAVA CLASS'，'JAVA RESOURCE'）ORDER BY object_type，object_name;</pre><p>您可以选择使用通配符查询<code class="codeph">USER_OBJECTS</code> ，如下例所示：</p><pre class="oac_no_warn" dir="ltr">SELECT object_name，object_type，status FROM user_objects WHERE object_name LIKE'％Alerter';</pre><p>上述语句查找以字符<code class="codeph">Alerter</code>结尾的任何<code class="codeph">OBJECT_NAME</code>条目。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="shortened-class-names.html#GUID-7A13AB37-4680-4E22-83EA-830C79E61126">缩短的班级名称</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13093"></a><div class="props_rev_3"><a id="GUID-8D343A4B-EC7A-4F65-8942-56D184250B64" name="GUID-8D343A4B-EC7A-4F65-8942-56D184250B64"></a><h3 id="JJDEV-GUID-8D343A4B-EC7A-4F65-8942-56D184250B64" class="sect3"><span class="enumeration_section">2.5.8</span>关于发布数据库中加载的Java方法</h3>
               <div>
                  <p>Oracle数据库使客户端和SQL能够在发布后调用数据库中加载的Java方法。您可以发布对象本身或单个方法。如果编写要使用触发器直接或间接使用SQL数据操作语言（DML）或PL / SQL调用的Java存储过程，则必须在类中发布单个方法。使用调用规范，指定如何访问该方法。Java程序由许多类中的许多方法组成。但是，通常只使用调用规范公开一些<code class="codeph">static</code>方法。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="publishing-Java-classes.html#GUID-C6DB962A-CCA6-44A1-990C-3E52636A0634">使用呼叫规范发布Java类</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13095"></a><a id="JJDEV13096"></a><a id="JJDEV13094"></a><div class="props_rev_3"><a id="GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA" name="GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA"></a><h3 id="JJDEV-GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA" class="sect3"><span class="enumeration_section">2.5.9</span>审计数据库中加载的Java类概述</h3>
               <div>
                  <div class="section">
                     <p>在Oracle Database 10g第2版（10.2）之前的版本中，无法直接审计数据库中的Java类。但是，您可以审核PL / SQL包装器。通常，所有Java存储过程都是从某些包装器启动的。因此，可以审计所有Java存储过程，但不能直接审计。</p>
                     <p>自Oracle Database 10g第2版（10.2）以来，您可以审计DDL语句，以创建，更改或删除Java源，类和资源模式对象，就像使用任何其他DDL语句一样。Oracle数据库提供了审核选项，可以轻松直接地审核Java活动。您还可以审核Java源，类和资源的任何修改。</p>
                     <p><a id="d8687e4362" class="indexterm-anchor"></a>您可以在两个不同级别（语句级别和对象级别）审核与Java模式对象相关的数据库活动。在语句级别，您可以审核与特殊语句模式相关的所有活动。
                     </p>
                     <p><a href="preparing-Java-class-methods.html#GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA__CEGCDDIG" title="表">表2-8</a>列出了语句审计选项以及与Java模式对象相关的相应SQL语句。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA__CEGCDDIG">
                     <p class="titleintable">表2-8与Java模式对象相关的语句审计选项</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="与Java模式对象相关的语句审计选项" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="50%" id="d8687e4383">声明选项</th>
                              <th align="left" valign="bottom" width="50%" id="d8687e4386">SQL语句</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4391" headers="d8687e4383 ">
                                 <p><code class="codeph">创造JAVA来源</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4391 d8687e4386 ">
                                 <p><code class="codeph">创造JAVA来源</code></p>
                                 <p><code class="codeph">创建或替换JAVA源</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4403" headers="d8687e4383 ">
                                 <p><code class="codeph">ALTER JAVA SOURCE</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4403 d8687e4386 ">
                                 <p><code class="codeph">ALTER JAVA SOURCE</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4412" headers="d8687e4383 ">
                                 <p><code class="codeph">DROP JAVA SOURCE</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4412 d8687e4386 ">
                                 <p><code class="codeph">DROP JAVA SOURCE</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4421" headers="d8687e4383 ">
                                 <p><code class="codeph">创造JAVA CLASS</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4421 d8687e4386 ">
                                 <p><code class="codeph">创造JAVA CLASS</code></p>
                                 <p><code class="codeph">创建或替换JAVA CLASS</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4433" headers="d8687e4383 ">
                                 <p><code class="codeph">ALTER JAVA CLASS</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4433 d8687e4386 ">
                                 <p><code class="codeph">ALTER JAVA CLASS</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4442" headers="d8687e4383 ">
                                 <p><code class="codeph">DROP JAVA CLASS</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4442 d8687e4386 ">
                                 <p><code class="codeph">DROP JAVA CLASS</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4451" headers="d8687e4383 ">
                                 <p><code class="codeph">创建JAVA资源</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4451 d8687e4386 ">
                                 <p><code class="codeph">创建JAVA资源</code></p>
                                 <p><code class="codeph">创建或替换JAVA资源</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4463" headers="d8687e4383 ">
                                 <p><code class="codeph">ALTER JAVA RESOURCE</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4463 d8687e4386 ">
                                 <p><code class="codeph">ALTER JAVA RESOURCE</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d8687e4472" headers="d8687e4383 ">
                                 <p><code class="codeph">DROP JAVA RESOURCE</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d8687e4472 d8687e4386 ">
                                 <p><code class="codeph">DROP JAVA RESOURCE</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>例如，如果要审核<code class="codeph">ALTER JAVA SOURCE</code> DDL语句，请在SQL提示符处输入以下语句：</p><pre class="oac_no_warn" dir="ltr">审核更改JAVA来源</pre><p><a id="d8687e4489" class="indexterm-anchor"></a>对象级审计提供更精细的粒度。它使您能够通过放大特定对象来识别特定问题。
                     </p>
                     <p><a href="preparing-Java-class-methods.html#GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA__CEGBGHFF" title="表">表2-9</a>列出了每个Java模式对象的对象审计选项。单元格中的条目X表示可以为该Java模式对象审核相应的SQL命令。条目NA表示相应的SQL命令不适用于该Java模式对象。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA__CEGBGHFF">
                     <p class="titleintable">表2-9与Java模式选项相关的对象审计选项</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="与Java模式选项相关的对象审计选项" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d8687e4512">对象选项</th>
                              <th align="left" valign="bottom" width="24%" id="d8687e4515">Java来源</th>
                              <th align="left" valign="bottom" width="24%" id="d8687e4518">Java资源</th>
                              <th align="left" valign="bottom" width="23%" id="d8687e4521">Java类</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d8687e4526" headers="d8687e4512 ">
                                 <p><code class="codeph">改变</code></p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4526 d8687e4515 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4526 d8687e4518 ">
                                 <p>NA</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d8687e4526 d8687e4521 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d8687e4540" headers="d8687e4512 ">
                                 <p><code class="codeph">执行</code></p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4540 d8687e4515 ">
                                 <p>NA</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4540 d8687e4518 ">
                                 <p>NA</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d8687e4540 d8687e4521 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d8687e4554" headers="d8687e4512 ">
                                 <p><code class="codeph">审计</code></p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4554 d8687e4515 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4554 d8687e4518 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d8687e4554 d8687e4521 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d8687e4568" headers="d8687e4512 ">
                                 <p><code class="codeph">GRANT</code></p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4568 d8687e4515 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d8687e4568 d8687e4518 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d8687e4568 d8687e4521 ">
                                 <p>X</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-9DF130C1-763D-4B2C-9F66-7F2C0E6BB7FA__GUID-0084ECD1-0D53-4A4E-8C05-C84C45E5F390">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../dbseg/part_6.html#DBSEG006" target="_blank"><span class="italic">Oracle数据库安全指南</span></a></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/AUDIT-Traditional-Auditing.html#SQLRF01107" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="00214.data-interface-for-persistent-LOBs.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>持久LOB的数据接口</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="PLSQL-semantics-for-LOBs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="reference-semantics-LOBs.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="PLSQL-semantics-for-LOBs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="reference-semantics-LOBs.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="value-semantic-LOBs.html" property="item" typeof="WebPage"><span property="name">值语义LOB</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">持久LOB的数据接口</li>
            </ol>
            <a id="GUID-4BFDD493-F3FE-451C-9B03-21669D635586" name="GUID-4BFDD493-F3FE-451C-9B03-21669D635586"></a><a id="ADLOB1300"></a>
            
            <h2 id="ADLOB-GUID-4BFDD493-F3FE-451C-9B03-21669D635586" class="sect2"><span class="enumeration_chapter">9</span>持久LOB的数据接口</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d27394e61" class="indexterm-anchor"></a>数据接口是一个通用术语，指的是正在使用的任何接口，查询数据库或更新数据库。
               </p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC">持久性LOB的数据接口概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F">为持久性LOB使用数据接口的好处</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3">在PL / SQL中使用持久LOB的数据接口</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26">用于OCI中持久LOB的数据接口</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339">数据接口与Java中的持久性LOB一起使用</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB">与远程LOB一起使用的数据接口</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB45643"></a><a id="ADLOB45644"></a><a id="ADLOB45642"></a><div class="props_rev_3"><a id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC" name="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC"></a><h3 id="ADLOB-GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC" class="sect3">持久性LOB的数据接口概述</h3>
               <div>
                  <p>持久性LOB的数据接口包括一组Java，PL / SQL和OCI API，它们被扩展为与LOB数据类型一起使用。</p>
                  <p>这些API最初设计用于遗留数据类型（如<code class="codeph">LONG</code> ， <code class="codeph">LONG</code> <code class="codeph">RAW</code>和<code class="codeph">VARCHAR2</code> ，也可以与<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>显示的相应LOB数据类型一起使用。这些表显示了<span class="italic">绑定或定义类型</span>列中的旧数据类型以及<span class="italic">LOB列类型</span>列中相应的受支持LOB数据类型。您可以使用LOB的数据接口在LOB列中存储和操作字符数据和二进制数据，就像它存储在相应的旧数据类型中一样。
                  </p>
                  <div class="infoboxnote" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__GUID-0960EE0F-D2C1-44AC-83DA-9593491DD1DC">
                     <p class="notep1">注意：</p>
                     <p>数据接口适用于LOB列和作为对象属性的LOB。在本章中， <span class="italic">LOB列</span>表示LOB列和LOB属性。
                     </p>
                     <p>您可以使用数组绑定和定义接口在一次往返中插入和选择多行。</p>
                  </div>
                  <p>虽然本讨论的大部分内容都集中在字符数据类型上，但相同的概念适用于<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的完整字符和二进制数据类型。<code class="codeph">CLOB</code>在这些表中也表示<code class="codeph">NCLOB</code> 。
                  </p>
                  <div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364">
                     <p class="titleintable">表9-1 SQL和PL / SQL中对应的LONG和LOB数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="SQL和PL / SQL中对应的LONG和LOB数据类型" width="100%" border="1" summary="This table is described in the preceding text" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="33%" id="d27394e231">绑定或定义类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e234">LOB列类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e237">用于存储</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e242" headers="d27394e231 ">
                                 <p><code class="codeph">CHAR</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e242 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e242 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e254" headers="d27394e231 ">
                                 <p><code class="codeph">长</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e254 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e254 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e266" headers="d27394e231 ">
                                 <p><code class="codeph">VARCHAR2</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e266 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e266 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e278" headers="d27394e231 ">
                                 <p><code class="codeph">LONG RAW</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e278 d27394e234 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e278 d27394e237 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e290" headers="d27394e231 ">
                                 <p><code class="codeph">生的</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e290 d27394e234 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e290 d27394e237 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324">
                     <p class="titleintable">表9-2 OCI中对应的LONG和LOB数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="OCI中相应的LONG和LOB数据类型" width="100%" border="1" summary="This table is described in the preceding text" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="33%" id="d27394e312">绑定或定义类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e315">LOB列类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e318">用于存储</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e323" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_AFC（N）</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e323 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e323 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e335" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_CHR</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e335 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e335 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e347" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LNG</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e347 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e347 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e359" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_VCS</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e359 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e359 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e371" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_BIN</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e371 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e371 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e383" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LBI</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e383 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e383 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e395" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LVB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e395 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e395 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="ADLOB45645"></a><div class="props_rev_3"><a id="GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F" name="GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F"></a><h3 id="ADLOB-GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F" class="sect3">为持久性LOB使用数据接口的好处</h3>
               <div>
                  <p>使用持久LOB的数据接口具有以下好处：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果您的应用程序使用<code class="codeph">LONG</code>数据类型，那么您可以使用具有LOB数据类型的相同应用程序，而几乎不需要修改现有应用程序。为此，只需将表中的<code class="codeph">LONG</code>录音带列转换为LOB录音带列，如将<code class="codeph">LONG</code>列<a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773">迁移到LOB中所述</a> 。
                        </p>
                     </li>
                     <li>
                        <p>对于使用顺序访问技术的OCI应用程序，性能更好。使用数据接口的分段<code class="codeph">INSERT</code>或fetch具有与使用OCI函数（如<code class="codeph">OCILobRead2()</code>和<code class="codeph">OCILobWrite2()</code>相当的性能。由于数据接口允许在单个OCI调用中将超过4K字节的数据插入LOB，因此可以节省到服务器的往返。
                        </p>
                     </li>
                     <li>
                        <p>您可以在一次<code class="codeph">OCIStmtFetch()</code>调用中读取LOB数据，而不是先获取LOB定位符然后再调用<code class="codeph">OCILobRead2()</code> 。当您想要从头开始读取LOB数据时，这可以提高性能。
                        </p>
                     </li>
                     <li>
                        <p>您可以使用数组绑定和定义接口在一个往返中插入和选择具有LOB的多个行。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADLOB45646"></a><div class="props_rev_3"><a id="GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3" name="GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3"></a><h3 id="ADLOB-GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3" class="sect3">在PL / SQL中使用持久LOB的数据接口</h3>
               <div>
                  <p>使用数据接口，您可以使用<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1中</a>列出的<code class="codeph">LONG</code>和LOB数据类型在PL / SQL中执行以下操作：</p>
               </div>
               <div class="props_rev_3"><a id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068" name="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068"></a><h4 id="ADLOB-GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068" class="sect4">关于在PL / SQL中为持久性LOB使用数据接口</h4>
                  <div>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将存储在数据类型（如<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code>字符数据<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>到<code class="codeph">CLOB</code>列中。
                           </p>
                        </li>
                        <li>
                           <p>将存储在数据类型（如<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>二进制数据<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>到<code class="codeph">BLOB</code>列中。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">CLOB</code>列上使用<code class="codeph">SELECT</code>语句将数据选择到字符缓冲区变量（如<code class="codeph">CHAR</code> ， <code class="codeph">LONG</code>或<code class="codeph">VARCHAR2</code> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">BLOB</code>列上的<code class="codeph">SELECT</code>语句将数据选择为二进制缓冲区变量，如<code class="codeph">RAW</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code> 。</p>
                        </li>
                        <li>
                           <p>在<code class="codeph">CLOB</code>和<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code>变量之间进行跨类型分配（隐式类型转换）。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">BLOB</code>和<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>变量之间进行跨类型分配（隐式类型转换）。
                           </p>
                        </li>
                        <li>
                           <p>将LOB数据类型传递给定义为接受<code class="codeph">LONG</code>数据类型的函数，或将<code class="codeph">LONG</code>数据类型传递给定义为接受LOB数据类型的函数。例如，您可以将<code class="codeph">CLOB</code>实例传递给定义为接受另一种字符类型的函数，例如<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code> 。</p>
                        </li>
                        <li>
                           <p>将<code class="codeph">CLOB</code>与其他PL / SQL函数和接受<code class="codeph">VARCHAR2</code>参数的运算符（如<code class="codeph">INSTR</code>和<code class="codeph">SUBSTR</code> 。</p>
                           <div class="infoboxnote" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-B2A1391C-F028-4EF5-9C13-38A92A7E7713">
                              <p class="notep1">注意：</p>
                              <p>在PL / SQL中使用带有<code class="codeph">SELECT</code>语句的LOB数据接口时，无法指定要读取的数量。您只能指定缓冲区的缓冲区长度。如果缓冲区长度小于LOB数据长度，则数据库将引发异常。
                              </p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-A1D4A9EE-3785-4DDA-BBC7-55A2511AFDE8">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a>有关SQL语句中LOB支持的详细信息</p>
                                 </li>
                                 <li>
                                    <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9">LOB数据类型不支持某些隐式转换</a></p>
                                 </li>
                                 <li>
                                    <p><a href="data-interface-for-persistent-LOBs.html#GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60">将CLOB传递给SQL和PL / SQL内置</a>函数，以获取接受<code class="codeph">VARCHAR2</code>参数的完整函数列表，例如<code class="codeph">INSTR</code>和<code class="codeph">SUBSTR</code></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45647"></a><div class="props_rev_3"><a id="GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F" name="GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F"></a><h4 id="ADLOB-GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F" class="sect4">使用SQL和PL / SQL中的数据接口访问LOB列的准则</h4>
                  <div>
                     <p>本节介绍用于使用持久LOB的数据接口访问LOB列或属性的技术。</p>
                     <p>来自<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>列或属性的数据可以由常规SQL语句引用，例如<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">SELECT</code> 。</p>
                     <p>PL / SQL中没有分段<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或fetch例程。因此，可以从LOB列或属性访问的数据量受最大字符缓冲区大小的限制。PL / SQL支持最大32KB  -  1（32767字节）的字符缓冲区大小。因此，PL / SQL应用程序只能使用持久LOB的数据接口访问大小小于32K字节的LOB。
                     </p>
                     <p>如果必须使用数据接口访问超过32KB -1，则必须从PL / SQL代码进行OCI调用，以使用API进行分段插入和获取。</p>
                     <p>使用以下准则使用数据接口访问LOB列或属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">INSERT</code>操作</p>
                           <p>您可以使用<code class="codeph">VALUES</code>子句中的常规<code class="codeph">INSERT</code>语句<code class="codeph">INSERT</code>到包含LOB列或属性的表中。LOB列的字段可以是文字，字符数据类型，二进制数据类型或LOB定位符。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">UPDATE</code>操作</p>
                           <p>LOB列或属性可以通过<code class="codeph">UPDATE</code>整体<code class="codeph">UPDATE</code> ...<code class="codeph">SET</code>语句。在<code class="codeph">SET</code>子句中，新值可以是文字，字符数据类型，二进制数据类型或LOB定位器。
                           </p>
                        </li>
                        <li>
                           <p>十六进制到原始和原始到十六进制转换的4000字节限制</p>
                           <p>数据库不会对大于4000字节的数据执行<code class="codeph">RAW</code>或<code class="codeph">RAW</code>到十六进制转换的隐式十六进制。您不能将字符数据的缓冲区绑定到二进制数据类型列，如果缓冲区的大小超过4000字节，则无法将二进制数据的缓冲区绑定到字符数据类型列。尝试这样做会导致列数据被截断为4000字节。
                           </p>
                           <p>例如，如果缓冲区的大小超过4000个字节，则无法将<code class="codeph">VARCHAR2</code>缓冲区绑定到<code class="codeph">LONG</code> <code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列。同样，如果缓冲区大小超过4000字节，则无法将<code class="codeph">RAW</code>缓冲区绑定到<code class="codeph">LONG</code>或<code class="codeph">CLOB</code>列。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT</code>操作</p>
                           <p>可以在PL / SQL中将LOB列或属性选择为字符或二进制缓冲区。如果LOB列或属性长于缓冲区大小，则会引发异常，而不会使用任何数据填充缓冲区。LOB列或属性也可以选择到LOB定位器中。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45648"></a><div class="props_rev_3"><a id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30" name="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30"></a><h4 id="ADLOB-GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30" class="sect4">隐式赋值和参数传递</h4>
                  <div>
                     <p><a id="d27394e1055" class="indexterm-anchor"></a> LOB列支持隐式赋值和参数传递。
                     </p>
                     <p>对于<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的数据类型，您可以使用永久LOB的数据接口将任何字符类型传递或分配给任何其他字符类型，或任何二进制类型传递给任何其他二进制类型。
                     </p>
                     <p>隐式赋值适用于显式声明的变量，以及通过使用<code class="codeph">%TYPE</code>属性引用现有列类型声明的变量，如以下示例所示。此示例假定表<code class="codeph">t</code>中的列<code class="codeph">long_col</code>已从<code class="codeph">LONG</code>列迁移到<code class="codeph">CLOB</code>列。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（long_col LONG）; - 更改此表以将LONG列更改为LOB DECLARE VARCHAR2（100）; b t.long_col％type; - 此变量从LONG变为CLOB BEGIN SELECT * INTO b FROM t; a：= b; - 这从“VARCHAR2：= LONG变为VARCHAR2：= CLOB b：= a;  - 从”LONG：= VARCHAR2变为CLOB：= VARCHAR2 END;</pre><p>函数和过程之间允许隐式参数传递。例如，您可以将<code class="codeph">CLOB</code>传递给函数或过程，其中形式参数定义为<code class="codeph">VARCHAR2</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30__GUID-15CEBD8A-E573-4DF7-B10C-2AA19CCDE46D">
                        <p class="notep1">注意：</p>
                        <p>将<code class="codeph">VARCHAR2</code>缓冲区分配给LOB变量的效率低于将<code class="codeph">VARCHAR2</code>分配给<code class="codeph">LONG</code>变量的效率，因为前者涉及创建临时LOB。因此，PL / SQL用户的应用程序性能略有下降。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45649"></a><div class="props_rev_3"><a id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60" name="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60"></a><h4 id="ADLOB-GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60" class="sect4">将CLOB传递给SQL和PL / SQL内置函数</h4>
                  <div>
                     <p>接受字符数据的内置PL / SQL函数也支持隐式参数传递。例如， <code class="codeph">INSTR</code>可以接受<code class="codeph">CLOB</code>和其他字符数据。
                     </p>
                     <p>任何接受<code class="codeph">VARCHAR2</code> SQL或PL / SQL内置函数都可以接受<code class="codeph">CLOB</code>作为参数。类似地， <code class="codeph">VARCHAR2</code>变量可以传递给任何带有LOB定位符的参数的<code class="codeph">DBMS_LOB</code> API。
                     </p>
                     <div class="infoboxnotealso" id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60__GUID-DAE4EAA9-B69B-4075-AEF0-774942D3A36B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a></p>
                     </div>
                  </div>
               </div><a id="ADLOB45650"></a><div class="props_rev_3"><a id="GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50" name="GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50"></a><h4 id="ADLOB-GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50" class="sect4">显式转换函数</h4>
                  <div>
                     <p>在PL / SQL中，这些显式转换函数将其他数据类型转换为<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>数据类型，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TO_CLOB()</code>将<code class="codeph">LONG</code> ， <code class="codeph">VARCHAR2</code>和<code class="codeph">CHAR</code>转换为<code class="codeph">CLOB</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">TO_BLOB()</code>将<code class="codeph">LONG RAW</code>和<code class="codeph">RAW</code>转换为<code class="codeph">BLOB</code></p>
                        </li>
                     </ul>
                     <p>另请注意，转换函数<code class="codeph">TO_CHAR()</code>可以将<code class="codeph">CLOB</code>转换为<code class="codeph">CHAR</code>类型。
                     </p>
                  </div>
               </div><a id="ADLOB45651"></a><div class="props_rev_3"><a id="GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2" name="GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2"></a><h4 id="ADLOB-GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2" class="sect4">从SQL调用PL / SQL和C过程</h4>
                  <div>
                     <p>从SQL调用PL / SQL或C过程时，不允许使用超过4000字节数据的缓冲区。</p>
                  </div>
               </div><a id="ADLOB45652"></a><div class="props_rev_3"><a id="GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760" name="GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760"></a><h4 id="ADLOB-GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760" class="sect4">从PL / SQL调用PL / SQL和C过程</h4>
                  <div>
                     <div class="section">
                        <p>您可以从PL / SQL调用PL / SQL或C过程。您可以将<code class="codeph">CLOB</code>作为实际参数传递，其中<code class="codeph">CHR</code>是形式参数，反之亦然。<code class="codeph">BLOB</code>和<code class="codeph">RAW</code> 。
                        </p>
                        <p>可能出现这些情况的一个示例是，当正式参数或实际参数是锚定类型时，即使用<span class="italic"><code class="codeph">table_name.column_name</code></span> <code class="codeph">%type</code>语法声明变量。
                        </p>
                        <p>PL / SQL过程或函数可以接受<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR2</code>作为形式参数。例如，PL / SQL过程可以是以下之一：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当形式参数是<code class="codeph">CLOB</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_lob（table_name IN VARCHAR2，lob INOUT CLOB）AS ...开始 ...结束; /</pre></li>
                           <li>
                              <p>当形式参数是<code class="codeph">VARCHAR2</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_lob（table_name IN VARCHAR2，lob INOUT VARCHAR2）AS ...开始 ...结束; /</pre></li>
                        </ul>
                        <p>调用函数可以是以下任何类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当实际参数是CHR时：</p><pre class="oac_no_warn" dir="ltr">创建程序......声明c VARCHAR2 [200]; BEGIN get_lob（'table_name'，c）;结束;</pre></li>
                           <li>
                              <p>当实际参数是<code class="codeph">CLOB</code> ：</p><pre class="oac_no_warn" dir="ltr">创建程序......声明c CLOB; BEGIN get_lob（'table_name'，c）;结束;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45653"></a><div class="props_rev_3"><a id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7" name="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7"></a><h4 id="ADLOB-GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7" class="sect4">INSERT和UPDATE操作中的所有大小的绑定</h4>
                  <div>
                     <p>LOB列上的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作支持所有大小的绑定。在单个<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句中允许多个任何大小的绑定。
                     </p>
                     <div class="infoboxnote" id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7__GUID-E423B9EE-938F-4BB1-B79C-DEAFDE3F09C0">
                        <p class="notep1">注意：</p>
                        <p>创建表时，为任何LOB列指定的默认值的长度限制为4000个字节。</p>
                     </div>
                  </div>
               </div><a id="ADLOB45654"></a><div class="props_rev_3"><a id="GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D" name="GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D"></a><h4 id="ADLOB-GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D" class="sect4">SQL运算符结果的4000字节限制</h4>
                  <div>
                     <p>如果将超过4000个字节的数据绑定到<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> ，并且数据由SQL运算符组成，则Oracle数据库会将结果的大小限制为最多4000个字节。
                     </p>
                     <p>以下语句仅插入4000个字节，因为<code class="codeph">LPAD</code>的结果限制为4000个字节：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO print_media（ad_sourcetext）VALUES（lpad（'a'，5000，'a'））;</pre><p>以下语句仅插入2000个字节，因为<code class="codeph">LPAD</code>的结果限制为4000个字节，隐式十六进制到原始转换将其转换为2000个字节的<code class="codeph">RAW</code>数据：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO print_media（ad_photo）VALUES（lpad（'a'，5000，'a'））;</pre></div>
               </div><a id="ADLOB45655"></a><div class="props_rev_3"><a id="GUID-D0C584EC-CA94-4166-99ED-F630EB655A76" name="GUID-D0C584EC-CA94-4166-99ED-F630EB655A76"></a><h4 id="ADLOB-GUID-D0C584EC-CA94-4166-99ED-F630EB655A76" class="sect4">SQL运算符的4000字节结果限制示例</h4>
                  <div>
                     <p>此示例说明了SQL运算符的结果如何限制为4000个字节。</p><pre class="oac_no_warn" dir="ltr">/ *以下命令仅插入4000个字节，因为* LPAD的结果限制为4000字节* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，lpad（'a'，5000，'a'） ）; SELECT LENGTH（ad_sourcetext）FROM print_media WHERE product_id = 2004 AND ad_id = 5; ROLLBACK; / *以下命令仅插入2000个字节，因为* LPAD的结果限制为4000个字节，隐式的十六进制到原始转换*将其转换为2000个字节的RAW数据。* / INSERT INTO print_media（product_id，ad_id，ad_composite）VALUES（2004,5，lpad（'a'，5000，'a'））;来自print_media的SELECT LENGTH（ad_composite）WHERE product_id = 2004 AND ad_id = 5; ROLLBAACK;</pre></div>
               </div><a id="ADLOB45656"></a><div class="props_rev_3"><a id="GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01" name="GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01"></a><h4 id="ADLOB-GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01" class="sect4">对超过4000字节的约束的限制</h4>
                  <div>
                     <p>绑定超过4000字节的限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果表同时具有<code class="codeph">LONG</code>和LOB列，则可以将超过4000个字节的数据绑定到<code class="codeph">LONG</code>或LOB列，但不能将两个数据绑定到同一语句中。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>操作中，不允许将任何长度数据绑定到LOB列。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB1306"></a><div class="props_rev_3"><a id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2" name="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2"></a><h4 id="ADLOB-GUID-6011EE96-FE71-46C1-9914-70412A98C2E2" class="sect4">并行DML（PDML）支持LOB</h4>
                  <div>
                     <p>当在具有SecureFiles LOB或BasicFiles LOB的分区表和仅具有SecureFiles LOB的非分区表上执行时，Oracle支持并行执行大多数以下DML操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">插入</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INSERT AS SELECT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE TABLE AS SELECT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">删除</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">UPDATE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">MERGE</code> （条件<code class="codeph">UPDATE</code>和<code class="codeph">INSERT</code> ）</p>
                        </li>
                        <li>
                           <p>多表<code class="codeph">INSERT</code></p>
                        </li>
                        <li>
                           <p>SQL Loader</p>
                        </li>
                        <li>
                           <p>进出口</p>
                        </li>
                     </ul>
                     <p>从版本12 <span class="italic">c</span>开始，对并行DML的增强支持包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>LOB列作为SecureFiles LOB存储在非分区表中。（以前的版本已包含分区表）</p>
                        </li>
                        <li>
                           <p>对SecureFiles LOB列的直接加载支持，这些列具有在其上定义的上下文索引。</p>
                        </li>
                     </ul>
                     <p><span class="bold">限制</span></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果表除了SecureFiles LOB列之外还具有BasicFiles LOB列，则禁用并行插入直接加载（PIDL）。</p>
                        </li>
                        <li>
                           <p>一些域索引实现可能由于其设计而限制负载分布并降低性能。</p>
                        </li>
                        <li>
                           <p>必须仅为顶级非分区表指定并行性。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2__GUID-A4CF8295-988F-40E7-BBB7-446F86957C39">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../admin/managing-processes.html#ADMIN11186" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a>部分“管理并行SQL执行的进程”</p>
                     </div>
                  </div>
               </div><a id="ADLOB45657"></a><div class="props_rev_3"><a id="GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D" name="GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D"></a><h4 id="ADLOB-GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D" class="sect4">示例：PL / SQL  - 在INSERT和UPDATE中使用超过4000字节的绑定</h4>
                  <div>
                     <div class="section">
                        <p>此示例演示了在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作中使用大于4000字节的绑定。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE bigtext VARCHAR2（32767）; smalltext VARCHAR2（2000）; bigraw RAW（32767）; BEGIN bigtext：= LPAD（'a'，32767，'a'）; smalltext：= LPAD（'a'，2000，'a'）; bigraw：= utl_raw.cast_to_raw（bigtext）; / * INSERT允许LOB列的多个长绑定：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext，ad_composite）VALUES（2004,1，bigtext，bigraw）; / * INSERT允许LOB列的单长绑定：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2005,2，smalltext）; bigtext：= LPAD（'b'，32767，'b'）; smalltext：= LPAD（'b'，20，'a'）; bigraw：= utl_raw.cast_to_raw（bigtext）; / *允许LOB列的多个长绑定用于UPDATE：* / UPDATE print_media SET ad_sourcetext = bigtext，ad_composite = bigraw，ad_finaltext = smalltext; / * LOD列的单长绑定允许UPDATE：* / UPDATE print_media SET ad_sourcetext = smalltext，ad_finaltext = bigtext; / *以下是不允许的，因为我们试图在LONG和LOB列中插入超过4000个字节的数据：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext，press_release）VALUES（2030,3，bigtext，bigtext ）; / *允许将数据插入LOB属性* / INSERT INTO print_media（product_id，ad_id，ad_header）VALUES（2049,4，adheader_typ（null，null，null，bigraw））; / *以下是不允许的，因为我们尝试执行INSERT AS SELECT数据INTO LOB * / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）SELECT 2056,5，bigtext FROM dual;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45658"></a><div class="props_rev_3"><a id="GUID-F808592E-C7AA-44C7-8178-8359F21C6814" name="GUID-F808592E-C7AA-44C7-8178-8359F21C6814"></a><h4 id="ADLOB-GUID-F808592E-C7AA-44C7-8178-8359F21C6814" class="sect4">使用INSERT，UPDATE和SELECT操作的LOB数据接口</h4>
                  <div>
                     <div class="section">
                        <p>LOB上的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句的使用方式与<code class="codeph">LONG</code>上的相同。例如：</p><pre class="oac_no_warn" dir="ltr">DECLARE ad_buffer VARCHAR2（100）; BEGIN INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，'广告来源1'）; UPDATE print_media SET ad_sourcetext ='广告来源2'WHERE product_id = 2004 AND ad_id = 5; / *如果它最多100个字节，则检索LOB列，否则它*引发异常* / SELECT ad_sourcetext INTO ad_buffer FROM print_media WHERE product_id = 2004 AND ad_id = 5;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45659"></a><div class="props_rev_3"><a id="GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B" name="GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B"></a><h4 id="ADLOB-GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B" class="sect4">在赋值和参数传递中使用LOB的数据接口</h4>
                  <div>
                     <div class="section">
                        <p>LOB的数据接口支持隐式赋值和参数传递，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（clob_col CLOB，blob_col BLOB）;插入价值观（'abcdefg'，'aaaaaa'）; DECLARE var_buf VARCHAR2（100）; clob_buf CLOB; raw_buf RAW（100）; blob_buf BLOB; BEGIN SELECT * INTO clob_buf，blob_buf FROM t; var_buf：= clob_buf; clob_buf：= var_buf; raw_buf：= blob_buf; blob_buf：= raw_buf;结束; /创建或更换程序FOO（一个IN OUT CLOB）开始 - 任何程序体a：='abc';结束; /创建或替换程序栏（b输出VARCHAR2）开始 - 任何程序体b：='xyz';结束; / DECLARE VARCHAR2（100）：='1234567'; b CLOB; BEGIN FOO（a）; SELECT clob_col INTO b FROM t; BAR（b）中;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45660"></a><div class="props_rev_3"><a id="GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C" name="GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C"></a><h4 id="ADLOB-GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C" class="sect4">使用带有PL / SQL内置函数的LOB数据接口</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了在PL / SQL内置函数中使用<code class="codeph">CLOB</code> ，使用LOB的数据接口：</p><pre class="oac_no_warn" dir="ltr">DECLARE my_ad CLOB; revised_ad CLOB; myGist VARCHAR2（100）：='这是我的要点。“; modifiedGist VARCHAR2（100）; BEGIN INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，'广告来源1'）; - 选择一个CLOB列到CLOB变量中SELECT ad_sourcetext INTO my_ad FROM print_media WHERE product_id = 2004 AND ad_id = 5; - 对CLOB变量执行VARCHAR2操作：revised_ad：= UPPER（SUBSTR（my_ad，1,20））; -  revised_ad是一个临时LOB  - 在CLOB的末尾Concat a VARCHAR2：modified_ad：= revised_ad || myGist; - 如果my_ad是 - 超过100个字节，则以下语句引发错误myGist：= my_ad;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45661"></a><div class="props_rev_3"><a id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26" name="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26"></a><h3 id="ADLOB-GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26" class="sect3">用于OCI中持久LOB的数据接口</h3>
               <div>
                  <p>本节讨论包含在持久LOB的数据接口中的OCI函数。这些OCI函数对LOB数据类型的工作方式与对<code class="codeph">LONG</code>数据类型的工作方式完全相同。使用这些函数，您可以使用与存储字符或二进制数据的其他数据类型相同的技术，在LOB上的OCI中执行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ，fetch，bind和define操作。
                  </p>
                  <div class="infoboxnote" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-72B9F551-C82D-46E2-9383-5ABE7FC4AA7A">
                     <p class="notep1">注意：</p>
                     <p>您可以使用数组绑定和定义接口在一个往返中插入和选择具有LOB的多个行。</p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-F4746FFA-C968-4645-BAF6-D96A31C2B22E">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../lnoci/binding-and-defining-in-oci.html#LNOCI059" target="_blank"><span class="italic">Oracle调用接口程序员指南</span></a> <span class="italic">，</span> “OCI中的运行时数据分配和分段操作”部分</p>
                  </div>
               </div><a id="ADLOB45662"></a><div class="props_rev_3"><a id="GUID-440FBDD9-016D-482E-B4E2-D94753709D9B" name="GUID-440FBDD9-016D-482E-B4E2-D94753709D9B"></a><h4 id="ADLOB-GUID-440FBDD9-016D-482E-B4E2-D94753709D9B" class="sect4">OCI中绑定的LOB数据类型</h4>
                  <div>
                     <p>您可以在以下操作中绑定LOB数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>常规，分段和回调绑定<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作</p>
                        </li>
                        <li>
                           <p>数组绑定<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作</p>
                        </li>
                        <li>
                           <p>参数传递到PL / SQL和OCI边界</p>
                        </li>
                     </ul>
                     <p>可以通过轮询或提供回调来执行分段操作。为了支持这些操作，以下OCI函数接受<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的<code class="codeph">LONG</code>和LOB数据类型。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIBindByName()</code>和<code class="codeph">OCIBindByPos()</code> 
                           </p>
                           <p>这些函数在SQL语句中的程序变量和占位符之间创建关联，或者在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作的PL / SQL块中创建关联。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIBindDynamic（）</code></p>
                           <p>您可以使用此调用为<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作的动态数据分配注册回调</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIStmtGetPieceInfo()</code>和<code class="codeph">OCIStmtSetPieceInfo()</code> 
                           </p>
                           <p>这些调用用于获取或设置分段操作的片段信息。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45663"></a><div class="props_rev_3"><a id="GUID-1D08A343-F384-4C17-8468-0B50AB4869A9" name="GUID-1D08A343-F384-4C17-8468-0B50AB4869A9"></a><h4 id="ADLOB-GUID-1D08A343-F384-4C17-8468-0B50AB4869A9" class="sect4">OCI中定义的LOB数据类型</h4>
                  <div>
                     <p>持久性LOB的数据接口允许以下OCI函数接受<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的LONG和LOB数据类型。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIDefineByPos（）</code> 
                           </p>
                           <p>此调用将<code class="codeph">SELECT</code>列表中的项与类型和输出数据缓冲区相关联。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIDefineDynamic（）</code></p>
                           <p>如果在<code class="codeph">OCIDefineByPos()</code>函数调用中选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，则此调用将注册<code class="codeph">SELECT</code>操作的用户回调。
                           </p>
                        </li>
                     </ul>
                     <p>将这些函数与LOB类型一起使用时，LOB数据（而非定位器）将被选择到缓冲区中。请注意，在OCI中，您无法使用LOB的数据接口指定要读取的数量。您只能指定缓冲区的缓冲区长度。数据库只读取适合缓冲区的数量，数据被截断。</p>
                  </div>
               </div><a id="ADLOB45664"></a><div class="props_rev_3"><a id="GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1" name="GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1"></a><h4 id="ADLOB-GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1" class="sect4">OCI中使用的多字节字符集与LOB的数据接口</h4>
                  <div>
                     <p>当客户端字符集采用多字节格式时，数据接口中包含的函数与LOB数据类型的操作方式与LONG数据类型的操作方式相同，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于多字节字符集中的<span class="italic">分段</span>提取，可以在中间剪切多字节字符，在一个缓冲区的末尾有一些字节，在下一个缓冲区中有剩余的字节。
                           </p>
                        </li>
                        <li>
                           <p>对于<span class="italic">常规</span>提取，如果缓冲区不能保存最后一个字符的所有字节，则Oracle返回适合缓冲区的字节数，从而返回部分字符。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45665"></a><div class="props_rev_3"><a id="GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E" name="GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E"></a><h4 id="ADLOB-GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E" class="sect4">用于在LOB列上执行INSERT或UPDATE的OCI函数</h4>
                  <div>
                     <p>本节讨论可用于使用数据接口对LOB列或属性执行<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作的各种技术。本节中描述的操作假定您已初始化OCI环境并分配了所有必需的句柄。
                     </p>
                  </div><a id="ADLOB45666"></a><div class="props_rev_3"><a id="GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24" name="GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24"></a><h5 id="ADLOB-GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24" class="sect5">在海贼王中执行简单的INSERT或UPDATE</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口以单件形式执行简单的<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>在<code class="codeph">OCI_DEFAULT</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB的占位符绑定为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>来执行实际的<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45667"></a><div class="props_rev_3"><a id="GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311" name="GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311"></a><h5 id="ADLOB-GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311" class="sect5">使用分段INSERT和UPDATE与轮询</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口进行轮询来执行分段<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li class="stepexpand"><span>在<code class="codeph">OCI_DATA_AT_EXEC</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB绑定为字符数据或二进制数据。</span></li>
                           <li class="stepexpand"><span>在默认模式下调用<code class="codeph">OCIStmtExecute()</code> 。从<code class="codeph">OCIStmtExecute()</code>返回的值为<code class="codeph">OCIStmtExecute()</code>时，在循环中执行以下每个<code class="codeph">OCI_NEED_DATA</code> 。终止你的循环，当从返回的值<code class="codeph">OCIStmtExecute()</code>是<code class="codeph">OCI_SUCCESS</code> 。</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以检索有关要插入的片段的信息。
                                       </p>
                                    </li>
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtSetPieceInfo()</code>来设置有关要插入的片段的信息。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45668"></a><div class="props_rev_3"><a id="GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327" name="GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327"></a><h5 id="ADLOB-GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327" class="sect5">使用回调执行分段INSERT和UPDATE</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久LOB的数据接口使用回调执行分段<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>在<code class="codeph">OCI_DATA_AT_EXEC</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB列的占位符绑定为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIBindDynamic()</code>以指定回调。</span></li>
                           <li><span>在默认模式下调用<code class="codeph">OCIStmtExecute()</code> 。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45669"></a><div class="props_rev_3"><a id="GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB" name="GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB"></a><h5 id="ADLOB-GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB" class="sect5">数组INSERT和UPDATE操作</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久LOB的数据接口执行数组<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请使用本节中结合<code class="codeph">OCIBindArrayOfStruct()</code>讨论的任何技术，或者指定迭代次数（ <span class="italic"><code class="codeph">iter</code></span> ）， <span class="italic"><code class="codeph">iter</code></span>值大于1，in <code class="codeph">OCIStmtExecute()</code>调用。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADLOB45670"></a><div class="props_rev_3"><a id="GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF" name="GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF"></a><h4 id="ADLOB-GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF" class="sect4">用于在OCI中获取LOB数据的数据接口</h4>
                  <div>
                     <p>本节讨论可以使用数据接口为持久性LOB从OCI列或OCI中的属性获取数据的技术。</p>
                  </div><a id="ADLOB45671"></a><div class="props_rev_3"><a id="GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7" name="GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7"></a><h5 id="ADLOB-GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7" class="sect5">简单的单件装</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口对LOB执行简单的提取操作，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下准备<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefineByPos()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下定义选择列表位置，以将LOB定义为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtFetch()</code>来执行实际的提取。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45672"></a><div class="props_rev_3"><a id="GUID-254F3A11-F9CC-4DC2-B855-333C508D6622" name="GUID-254F3A11-F9CC-4DC2-B855-333C508D6622"></a><h5 id="ADLOB-GUID-254F3A11-F9CC-4DC2-B855-333C508D6622" class="sect5">使用轮询执行分段提取</h5>
                     <div>
                        <div class="section">
                           <p>要使用LOB的数据接口进行轮询，对LOB列执行分段提取操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtPrepare()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下准备<code class="codeph">SELECT</code>语句。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIDefinebyPos()</code>以在<code class="codeph">OCI_DYNAMIC_FETCH</code>模式中定义选择列表位置，以将LOB列定义为字符数据或二进制数据。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li class="stepexpand"><span>在默认模式下调用<code class="codeph">OCIStmtFetch()</code> 。从<code class="codeph">OCIStmtFetch()</code>返回的值为<code class="codeph">OCIStmtFetch()</code>时，在循环中执行以下每个<code class="codeph">OCI_NEED_DATA.</code>终止你的循环，当从返回的值<code class="codeph">OCIStmtFetch()</code>是<code class="codeph">OCI_SUCCESS</code> 。</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以检索有关要获取的片段的信息。
                                       </p>
                                    </li>
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtSetPieceInfo()</code>来设置有关要获取的片段的信息。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45673"></a><div class="props_rev_3"><a id="GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140" name="GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140"></a><h5 id="ADLOB-GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140" class="sect5">使用回调执行分段</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口对带有回调的LOB列执行分段提取操作，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefinebyPos()</code>以在<code class="codeph">OCI_DYNAMIC_FETCH</code>模式中定义选择列表位置，以将LOB列定义为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefineDynamic()</code>以指定回调。</span></li>
                           <li><span>在默认模式下调用<code class="codeph">OCIStmtFetch()</code> 。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45674"></a><div class="props_rev_3"><a id="GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5" name="GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5"></a><h5 id="ADLOB-GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5" class="sect5">数组提取</h5>
                     <div>
                        <div class="section">
                           <p>要执行的阵列OCI取使用持久性的LOB的数据接口，可以使用任何的结合在本节中讨论的技术<code class="codeph">OCIDefineArrayOfStruct()</code>或者通过指定的迭代的数量（ <span class="italic"><code class="codeph">iter</code></span> ）中，用的值<span class="italic"><code class="codeph">iter</code></span>大于1 ，在<code class="codeph">OCIStmtExecute()</code>调用中。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADLOB45675"></a><div class="props_rev_3"><a id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423" name="GUID-34D56682-00EB-42DD-869A-9C5C4E288423"></a><h4 id="ADLOB-GUID-34D56682-00EB-42DD-869A-9C5C4E288423" class="sect4">PL / SQL和C从OCI绑定</h4>
                  <div>
                     <div class="section">
                        <p>当您从OCI调用PL / SQL过程并具有<code class="codeph">IN</code>或<code class="codeph">OUT</code>或<code class="codeph">IN OUT</code>绑定时，您应该能够：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将变量绑定为<code class="codeph">SQLT_CHR</code>或<code class="codeph">SQLT_LNG</code> ，其中PL / SQL过程的形式参数为<code class="codeph">SQLT_CLOB</code> ，或者</p>
                           </li>
                           <li>
                              <p>将变量绑定为<code class="codeph">SQLT_BIN</code>或<code class="codeph">SQLT_LBI</code> ，其中形式参数为<code class="codeph">SQLT_BLOB</code></p>
                           </li>
                        </ul>
                        <p>以下两种情况有效：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423__GUID-3017AE1C-FB9E-4711-ABA7-0FEDBB70322B">在“begin foo（：1）; end;”中调用PL / SQL Out-binds方式</p>
                        <p>下面是在“begin foo（：1）; end;”中调用PL / SQL out-binds的示例。方式：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“BEGIN get_lob（：c）; END;”;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423__GUID-E2BFEEBF-209F-4559-92A2-C4000BED9C61">在“call foo（：1）;”中调用PL / SQL Out-binds方式</p>
                        <p>这是在“call foo（：1）;”中调用PL / SQL out-binds的示例。方式：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“CALL get_lob（：c）;” ;</pre><p>在这两种情况下，程序的其余部分都有以下声明：</p><pre class="oac_no_warn" dir="ltr">OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; curlen = 0; OCIBindByName（stmthp，＆bndhp [3]，errhp，（text *）“：c”，（sb4）strlen（（char *）“：c”），（dvoid *）buf5，（sb4）LONGLEN，SQLT_CHR，（dvoid） *）0，（ub2 *）0，（ub2 *）0，（ub4）1，（ub4 *）＆curlen，（ub4）OCI_DATA_AT_EXEC）;</pre><p>PL / SQL过程<code class="codeph">get_lob()</code>如下：</p><pre class="oac_no_warn" dir="ltr">过程get_lob（c INOUT CLOB）是 - 这可能是列％类型BEGIN .../ *程序体可以是PL / SQL或C * / END;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45678"></a><div class="props_rev_3"><a id="GUID-28B40747-D702-44FB-BF19-F7DC46C67722" name="GUID-28B40747-D702-44FB-BF19-F7DC46C67722"></a><h4 id="ADLOB-GUID-28B40747-D702-44FB-BF19-F7DC46C67722" class="sect4">示例：C（OCI） -  INSERT和UPDATE超过4000字节的绑定</h4>
                  <div>
                     <div class="section">
                        <p>对于<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作，您可以使用超过4000个字节的绑定。
                        </p><pre class="oac_no_warn" dir="ltr">void insert3（）{/ *允许将数据插入LOB属性。* / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO Print_media（ad_header）\ VALUES（adheader_typ（NULL，NULL，NULL，：1））”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（dvoid *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（const OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45679"></a><div class="props_rev_3"><a id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6" name="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6"></a><h4 id="ADLOB-GUID-67A21099-37E9-4400-9D75-D86A106A4FC6" class="sect4">在PL / SQL中使用LOB的数据接口从LOB上的OCI绑定</h4>
                  <div>
                     <div class="section">
                        <p>LOB的数据接口允许来自OCI的LOB PL / SQL绑定工作。当您从OCI调用PL / SQL过程并具有<code class="codeph">IN</code>或<code class="codeph">OUT</code>或<code class="codeph">IN OUT</code>绑定时，您应该能够将变量绑定为<code class="codeph">SQLT_CHR</code> ，其中PL / SQL过程的形式参数是<code class="codeph">SQLT_CLOB</code> 。</p>
                        <div class="infoboxnote" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-09184C69-A045-4A00-AA79-8EC4A232E6E6">
                           <p class="notep1">注意：</p>
                           <p>C程序包含在PL / SQL存根中，因此OCI应用程序始终调用PL / SQL存根。</p>
                        </div>
                        <p>对于OCI呼叫计划，以下是可能的情况：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-CDC4A047-241F-4030-834F-DA5364DF516B">在“begin foo（：1）; end;”中调用PL / SQL Out-binds方式</p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“BEGIN PKG1。P5（：c）;结束; “;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-97C50125-BA23-44FB-A5C4-45E6089F8911">在“call foo（：1）;”中调用PL / SQL Out-binds方式</p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“CALL PKG1。P5（：c）;“;</pre><p>在这两种情况下，该计划的其余部分如下：</p><pre class="oac_no_warn" dir="ltr">OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; curlen = 0; OCIBindByName（stmthp，＆bndhp [3]，errhp，（text *）“：c4”，（sb4）strlen（（char *）“：c”），（dvoid *）buf5，（sb4）LONGLEN，SQLT_CHR，（dvoid） *）0，（ub2 *）0，（ub2 *）0，（ub4）1，（ub4 *）＆curlen，（ub4）OCI_DATA_AT_EXEC）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）;</pre><p>PL / SQL过程<code class="codeph">PKG1.P5</code>如下：</p><pre class="oac_no_warn" dir="ltr">创建或更换包装体pkg1 AS ...过程p5（c OUT CLOB）是 - 这可能是表％rowtype（所以它现在是CLOB）BEGIN ...结束p5;结束pkg1;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45682"></a><div class="props_rev_3"><a id="GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED" name="GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED"></a><h4 id="ADLOB-GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED" class="sect4">绑定大于4000字节的LOB列的LONG数据</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了LOB列的绑定字符数据：</p><pre class="oac_no_warn" dir="ltr">void simple_insert（）{word buflen; text buf [5000]; text * insstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（2004,1，：SRCTXT）”; OCIStmtPrepare（stmthp，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [0]，errhp，（text *）“：SRCTXT”，（sb4）strlen（（char *）“：SRCTXT”），（dvoid *）buf，（sb4）sizeof（buf），SQLT_CHR ，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; memset（（void *）buf，（int）'A'，（size_t）5000）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45683"></a><div class="props_rev_3"><a id="GUID-4F79C855-71C0-4307-BD72-114889A9DFDE" name="GUID-4F79C855-71C0-4307-BD72-114889A9DFDE"></a><h4 id="ADLOB-GUID-4F79C855-71C0-4307-BD72-114889A9DFDE" class="sect4">使用具有轮询的分段INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用分段<code class="codeph">INSERT</code>和使用LOB的数据接口进行轮询。
                        </p><pre class="oac_no_warn" dir="ltr">void piecewise_insert（）{text * sqlstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：1，：2，：3）”; ub2 rcode; ub1 piece，i; word product_id = 2004;单词ad_id = 2; ub4 buflen; char buf [5000]; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [0]，errhp，（ub4）1，（dvoid *）＆product_id，（sb4）sizeof（product_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [1]，errhp，（ub4）2，（dvoid *）＆ad_id，（sb4）sizeof（ad_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）0，（sb4）15000，SQLT_LNG，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4） 0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC）; i = 0;而（1）{i ++; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; switch（retval）{case OCI_NEED_DATA：memset（（void *）buf，（int）'A'+ i，（size_t）5000）; buflen = 5000; if（i == 1）piece = OCI_FIRST_PIECE;否则if（i == 3）piece = OCI_LAST_PIECE; else piece = OCI_NEXT_PIECE; if（OCIStmtSetPieceInfo（（dvoid *）bndhp [2]，（ub4）OCI_HTYPE_BIND，errhp，（dvoid *）buf，＆buflen，piece，（dvoid *）0，＆rcode））{printf（“ERROR：OCIStmtSetPieceInfo：％d \ n“，retval）;打破;打破case OCI_SUCCESS：break; default：printf（“oci exec返回％d \ n”，retval）;的Report_Error（errhp）; retval = OCI_SUCCESS; } / * end switch * / if（retval == OCI_SUCCESS）break; } / * end while（1）* /}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45684"></a><div class="props_rev_3"><a id="GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871" name="GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871"></a><h4 id="ADLOB-GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871" class="sect4">使用具有回调的分段INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用带回调的分段<code class="codeph">INSERT</code>将<code class="codeph">LONG</code>数据绑定到LOB列：</p><pre class="oac_no_warn" dir="ltr">void callback_insert（）{word buflen = 15000; word product_id = 2004;单词ad_id = 3; text * sqlstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：1，：2，：3）”;字pos = 3; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）OCIBindByPos（stmthp，＆bndhp [0]，errhp，（ub4）1，（dvoid *） ＆product_id，（sb4）sizeof（product_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [1]，errhp，（ub4）2，（dvoid *）＆ad_id，（sb4）sizeof（ad_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）0，（sb4）buflen，SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4） 0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC）; OCIBindDynamic（bndhp [2]，errhp，（dvoid *）（dvoid *）＆pos，insert_cbk，（dvoid *）0，（OCICallbackOutBind）0）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; } / * end insert_data（）* / / * Inbind回调以指定输入数据。* / static sb4 insert_cbk（dvoid * ctxp，OCIBind * bindp，ub4 iter，ub4 index，dvoid ** bufpp，ub4 * alenpp，ub1 * piecep，dvoid ** indpp）{static int a = 0;字j; ub4 inpos = *（（ub4 *）ctxp）; char buf [5000]; switch（inpos）{case 3：memset（（void *）buf，（int）'A'+ a，（size_t）5000）; * bufpp =（dvoid *）buf; * alenpp = 5000;一个++;打破;默认值：printf（“错误：无效位置编号：％d \ n”，inpos）; } * indpp =（dvoid *）0; * piecep = OCI_ONE_PIECE; if（inpos == 3）{if（a &lt;= 1）{* piecep = OCI_FIRST_PIECE; printf（“插入回调：第一部分\ n”）; } else if（a &lt;3）{* piecep = OCI_NEXT_PIECE; printf（“插入回调：％d'th \ n”，a）; } else {* piecep = OCI_LAST_PIECE; printf（“插入回调：％d'th \ n”，a）; a = 0;返回OCI_CONTINUE; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45685"></a><div class="props_rev_3"><a id="GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE" name="GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE"></a><h4 id="ADLOB-GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE" class="sect4">使用数组INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明使用数组<code class="codeph">INSERT</code>操作绑定LOB列的字符数据：</p><pre class="oac_no_warn" dir="ltr">void array_insert（）{ub4 i;字buflen;字arrbuf1 [5];单词arrbuf2 [5]; text arrbuf3 [5] [5000]; text * insstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：PID，：AID，：SRCTXT）”; OCIStmtPrepare（stmthp，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [0]，errhp，（text *）“：PID”，（sb4）strlen（（char *）“：PID”），（dvoid *）＆arrbuf1 [0]，（sb4）sizeof（arrbuf1 [0]），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [1]，errhp，（text *）“：AID”，（sb4）strlen（（char *）“：AID”），（dvoid *）＆arrbuf2 [0]，（sb4）sizeof（arrbuf2 [0]），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [2]，errhp，（text *）“：SRCTXT”，（sb4）strlen（（char *）“：SRCTXT”），（dvoid *）arrbuf3 [0]，（sb4）sizeof（arrbuf3 [0]），SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindArrayOfStruct（bndhp [0]，errhp sizeof（arrbuf1 [0]），indsk，rlsk，rcsk）; OCIBindArrayOfStruct（bndhp [1]，errhp，sizeof（arrbuf2 [0]），indsk，rlsk，rcsk）; OCIBindArrayOfStruct（bndhp [2]，errhp，sizeof（arrbuf3 [0]），indsk，rlsk，rcsk）; for（i = 0; i &lt;5; i ++）{arrbuf1 [i] = 2004; arrbuf2 [i] = i + 4; memset（（void *）arrbuf3 [i]，（int）'A'+ i，（size_t）5000）; } OCIStmtExecute（svchp，stmthp，errhp，（ub4）5，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45686"></a><div class="props_rev_3"><a id="GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98" name="GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98"></a><h4 id="ADLOB-GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98" class="sect4">使用简单提取将LOB列选择为LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用简单提取选择LOB列：</p><pre class="oac_no_warn" dir="ltr">void simple_fetch（）{word retval; text buf [15000]; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE \ Product_id = 2004”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; while（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）{OCIDefineByPos（stmthp，＆defhp，errhp，（ub4）1，（dvoid *）buf，（sb4）sizeof（buf），（ub2）SQLT_CHR，（dvoid *） 0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; if（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）printf（“buf =％。* s \ n”，15000，buf）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45687"></a><div class="props_rev_3"><a id="GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250" name="GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250"></a><h4 id="ADLOB-GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250" class="sect4">使用带轮询的分段提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用带轮询的分段提取在<code class="codeph">LONG</code>缓冲区中选择LOB列：</p><pre class="oac_no_warn" dir="ltr">void piecewise_fetch（）{text buf [15000]; ub4 buflen = 5000;单词retval; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id = 2”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆dfnhp，errhp，（ub4）1，（dvoid *）NULL，（sb4）100000，SQLT_LNG，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DYNAMIC_FETCH）; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub2）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）;而且（retval！= OCI_NO_DATA &amp;&amp; retval！= OCI_SUCCESS）{ub1 piece; ub4 iter; ub4 idx; genclr（（void *）buf，5000）; switch（retval）{case OCI_NEED_DATA：OCIStmtGetPieceInfo（stmthp，errhp，＆hdlptr，＆hdltype，＆in_out，＆iter，＆idx，＆piece）; buflen = 5000; OCIStmtSetPieceInfo（hdlptr，hdltype，errhp，（dvoid *）buf，＆buflen，piece，（CONST dvoid *）＆indp1，（ub2 *）0）; retval = OCI_NEED_DATA;打破; default：printf（“ERROR：分段提取，％d \ n”，retval）;返回; } / * end switch * / retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub2）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; printf（“数据：％。5000s \ n”，buf）; } / *结束时* /}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45688"></a><div class="props_rev_3"><a id="GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D" name="GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D"></a><h4 id="ADLOB-GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D" class="sect4">使用带回调的分段提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了在使用带回调的分段提取时选择<code class="codeph">LONG</code>列到LOB缓冲区：</p><pre class="oac_no_warn" dir="ltr">char buf [5000]; void callback_fetch（）{word outpos = 1; text * sqlstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id = 3”; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆dfnhp [0]，errhp，（ub4）1，（dvoid *）0，（sb4）3 * sizeof（buf），SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *） 0，（ub4）OCI_DYNAMIC_FETCH）; OCIDefineDynamic（dfnhp [0]，errhp，（dvoid *）＆outpos，（OCICallbackDefine）fetch_cbk）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; buf [4999] ='\ 0'; printf（“选择回调：最后一块：％s \ n”，buf）; } / * ----------------------------------------------- --------------- * / / *获取回调以指定缓冲区。* / / * ---------------------------------------------- ---------------- * / static sb4 fetch_cbk（dvoid * ctxp，OCIDefine * dfnhp，ub4 iter，dvoid ** bufpp，ub4 ** alenpp，ub1 * piecep，dvoid ** indpp，ub2 ** rcpp）{static int a = 0; ub4 outpos = *（（ub4 *）ctxp）; ub4 len = 5000; switch（outpos）{case 1：a ++; * bufpp =（dvoid *）buf; * alenpp =＆len;打破;默认值：* bufpp =（dvoid *）0; * alenpp =（ub4 *）0; printf（“ERROR：无效的位置编号：％d \ n”，outpos）; } * indpp =（dvoid *）0; * rcpp =（ub2 *）0; buf [len] ='\ 0'; if（a &lt;= 1）{* piecep = OCI_FIRST_PIECE; printf（“选择回调：0件\ n”）; } else if（a &lt;3）{* piecep = OCI_NEXT_PIECE; printf（“Select callback：％d'th piece：％s \ n”，a-1，buf）; } else {* piecep = OCI_LAST_PIECE; printf（“Select callback：％d'th piece：％s \ n”，a-1，buf）; a = 0; } return OCI_CONTINUE; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45689"></a><div class="props_rev_3"><a id="GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075" name="GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075"></a><h4 id="ADLOB-GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075" class="sect4">使用数组提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明如何使用数组提取将LOB列选择到<code class="codeph">LONG</code>缓冲区中：</p><pre class="oac_no_warn" dir="ltr">void array_fetch（）{word i; text arrbuf [5] [5000]; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id&gt; = 4”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp1，errhp，（ub4）1，（dvoid *）arrbuf [0]，（sb4）sizeof（arrbuf [0]），（ub2）SQLT_CHR，（dvoid *）0，（ub2 *）0， （ub2 *）0，（ub4）OCI_DEFAULT）; OCIDefineArrayOfStruct（dfnhp1，errhp，sizeof（arrbuf [0]），indsk，rlsk，rcsk）; retval = OCIStmtFetch（stmthp，errhp，（ub4）5，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; if（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）{printf（“％。5000s \ n”，arrbuf [0]）; printf（“％。5000s \ n”，arrbuf [1]）; printf（“％。5000s \ n”，arrbuf [2]）; printf（“％。5000s \ n”，arrbuf [3]）; printf（“％。5000s \ n”，arrbuf [4]）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45690"></a><div class="props_rev_3"><a id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339" name="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339"></a><h3 id="ADLOB-GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339" class="sect3">数据接口与Java中的持久性LOB一起使用</h3>
               <div>
                  <div class="section">
                     <p>您还可以使用与<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据相同的流机制来读取和写入<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>数据。
                     </p>
                     <p>要阅读，请使用<code class="codeph">defineColumnType(nn, Types.LONGVARCHAR)</code>或<code class="codeph">defineColumnType(nn, Types.LONGVARBINARY)</code>在列上。这会在数据上生成直接流，就像它是<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列一样。一种用于在输入<code class="codeph">PreparedStatement</code> ，可以使用<code class="codeph">setBinaryStream()</code> <code class="codeph">setCharacterStream()</code>或<code class="codeph">setAsciiStream()</code>为一个参数，该参数是一个<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> 。这些方法使用流接口根据流中的数据在数据库中创建LOB。如果已知数据的长度，为了获得更好的性能，请使用接受length参数的<span class="apiname" translate="no">setBinaryStream()</span>或<span class="apiname" translate="no">setCharacterStream</span>函数的版本。数据接口还支持标准JDBC方法，例如ResultSet和CallableStatement上的getString / getBytes以及PreparedStatement上的setString / setBytes来读取和写入LOB数据。使用这些API进行LOB访问更容易编码，并且在许多情况下更快。所有这些技术都可以减少数据库往返次数，并可能在某些情况下提高性能。有关适用的重要限制，请参阅Javadoc on stream数据， <a href="http://www.oracle.com/technology/" target="_blank"><code class="codeph">http://www.oracle.com/technology/</code></a>为<a href="http://www.oracle.com/technology/" target="_blank"><code class="codeph">http://www.oracle.com/technology/</code></a> 。</p>
                     <p>请参阅<span class="italic">JDBC Developer's Guide and Reference中的以下内容</span> ：</p>
                     <div class="infoboxnotealso" id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339__GUID-289B2555-8963-4A41-8EC1-8908F6358229">
                        <p class="notep1">也可以看看：</p>
                        <p> </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../jjdbc/LOBs-and-BFiles.html#JJDBC28534" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，“使用LOB和BFILE”，“LOB的数据接口”部分</p>
                           </li>
                           <li>
                              <p><a href="../jjdbc/JDBC-standards-support.html#JJDBC28082" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，“JDBC标准支持”</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADLOB1323"></a><div class="sect2"><a id="GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB" name="GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB"></a><h3 id="ADLOB-GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB" class="sect3">与远程LOB一起使用的数据接口</h3>
               <div>
                  <p>在Oracle Database <span class="italic">10g</span>第2版之后，支持用于插入，更新和选择远程LOB（通过<code class="codeph">dblink</code>访问）的数据接口。
                  </p>
               </div>
               <div class="props_rev_3"><a id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F" name="GUID-23097695-09B0-4107-9720-FBE4D8283C0F"></a><h4 id="ADLOB-GUID-23097695-09B0-4107-9720-FBE4D8283C0F" class="sect4">关于具有远程LOB的数据接口</h4>
                  <div>
                     <p>讨论的示例使用在两个模式中创建的<code class="codeph">print_media</code>表： <code class="codeph">dbs1</code>和<code class="codeph">dbs2</code> 。显示的示例中使用的该表的<code class="codeph">CLOB</code>列是<code class="codeph">ad_finaltext</code> 。为PL / SQL，OCI和Java提供的示例使用这一列的绑定和定义，但也可以访问多个列。以下是支持的功能及其局限性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以将<code class="codeph">CLOB</code>定义为<code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code> ，将<code class="codeph">NCLOB</code>为<span>CHAR或NCHAR</span> 。 <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>可以定义为<code class="codeph">LONG</code> 。 <code class="codeph">BLOB</code>可以定义为<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code> 。</p>
                        </li>
                        <li>
                           <p>支持数组绑定和定义。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F__GUID-0742C293-8B42-47CC-9D30-ECADB24003F6">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-interface-for-persistent-LOBs.html#GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33">PL / SQL中的远程数据接口示例</a> ”</span>及其后的部分。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45691"></a><div class="props_rev_3"><a id="GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E" name="GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E"></a><h4 id="ADLOB-GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E" class="sect4">不支持的语法</h4>
                  <div>
                     <p>远程LOB不支持某些语法。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不支持涉及多个数据库的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT t1.lobcol，a2.lobcol FROM t1，t2.lobcol @ dbs2 a2 WHERE LENGTH（t1.lobcol）= LENGTH（a2.lobcol）;</pre><p>这个查询都不是（在PL / SQL块中）：</p><pre class="oac_no_warn" dir="ltr">SELECT t1.lobcol INTO varchar_buf1 FROM t1 @ dbs1 UNION ALL SELECT t2.lobcol INTO varchar_buf2 FROM t2 @ dbs2;</pre></li>
                        <li>
                           <p>仅支持进入远程持久LOB列的数据的绑定和定义，因此不允许在PL / SQL中传递为远程LOB绑定或定义<code class="codeph">CHAR</code>数据的参数，因为这可能会产生不受支持的远程临时LOB。这些陈述都会产生错误：</p><pre class="oac_no_warn" dir="ltr">SELECT foo（）INTO varchar_buf FROM table1 @ dbs2; -  foo返回LOB SELECT foo（）@ dbs INTO char_val FROM DUAL; -  foo返回LOB SELECT XMLType（）。getclobval INTO varchar_buf FROM table1 @ dbs2;</pre></li>
                        <li>
                           <p>如果远程对象是一个视图，如</p><pre class="oac_no_warn" dir="ltr">CREATE VIEW v AS SELECT foo（）a FROM ...; -  foo返回LOB / *然后本地数据库尝试获取CLOB数据并返回错误* / SELECT a INTO varchar_buf FROM v @ dbs2;</pre><p>这会返回错误，因为它会生成一个不受支持的远程临时LOB。</p>
                        </li>
                        <li>
                           <p><code class="codeph">RETURNING</code> <code class="codeph">INTO</code>不支持<code class="codeph">CHAR</code>和<code class="codeph">CLOB</code>之间的隐式转换。</p>
                        </li>
                        <li>
                           <p>如果实际参数是LOB类型且远程参数是<code class="codeph">VARCHAR2</code> ， <code class="codeph">NVARCHAR2</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">NCHAR</code>或<code class="codeph">RAW</code> ，则不允许PL / SQL参数传递。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45692"></a><div class="props_rev_3"><a id="GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33" name="GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33"></a><h4 id="ADLOB-GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33" class="sect4">PL / SQL中的远程数据接口示例</h4>
                  <div>
                     <p>数据接口仅支持PL / SQL中大小小于32KB的数据。以下代码段显示了一个PL / SQL示例：</p><pre class="oac_no_warn" dir="ltr">CONNECT pm声明my_ad <span class="bold">varchar（6000）</span> ：= lpad（'b'，6000，'b'）; BEGIN INSERT INTO <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_finaltext）VALUES（10000,10，my_ad）; - 重置缓冲区值my_ad：='a'; SELECT ad_finaltext INTO my_ad FROM <span class="bold">print_media @ dbs2</span> WHERE product_id = 10000;结束; /</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，则<code class="codeph">my_ad</code>必须是<code class="codeph">RAW</code>类型。如果LOB大小超过32KB-1，则PL / SQL会引发截断错误，并且缓冲区的内容未定义。
                     </p>
                  </div>
               </div><a id="ADLOB45693"></a><div class="props_rev_3"><a id="GUID-0E65F171-0B92-4AC4-8929-B348481C7209" name="GUID-0E65F171-0B92-4AC4-8929-B348481C7209"></a><h4 id="ADLOB-GUID-0E65F171-0B92-4AC4-8929-B348481C7209" class="sect4">OCI中的远程数据接口示例</h4>
                  <div>
                     <p>对于OCI，数据接口仅支持大小小于<code class="codeph">2 GBytes</code> （可能是声明为<code class="codeph">sb4</code>的变量的最大值）的数据。以下伪代码可以增强为OCI程序的一部分：</p><pre class="oac_no_warn" dir="ltr">...text * sql =（text *）“insert into <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_finaltext）values（：1，：2，：3）”; OCIStmtPrepare（...）; OCIBindByPos（...）; / *绑定位置1和2 *的数据，它们独立于LOB * / OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）charbuf1，（sb4）len_charbuf1， <span class="bold">SQLT_CHR</span> ，（dvoid *） 0，（ub2 *）0，（ub2 *）0,0,0，OCI_DEFAULT）; OCIStmtExecute（...）; ...text * sql =（text *）“从<span class="bold">print_media @ dbs2</span>中选择ad_finaltext，其中product_id = 10000”; OCIStmtPrepare（...）; OCIDefineByPos（stmthp，＆dfnhp [2]，errhp，（ub4）1，（dvoid *）charbuf2，（sb4）len_charbuf2， <span class="bold">SQLT_CHR</span> ，（dvoid *）0，（ub2 *）0，（ub2 *）0，OCI_DEFAULT）; OCIStmtExecute（...）; ...
</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>而不是<code class="codeph">CLOB</code> ，那么使用<code class="codeph">SQLT_BIN</code>类型绑定和定义。如果LOB大小超过2GB-1，则OCI会引发截断错误，并且缓冲区的内容未定义。
                     </p>
                  </div>
               </div><a id="ADLOB45694"></a><div class="props_rev_3"><a id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB" name="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB"></a><h4 id="ADLOB-GUID-7C8CA747-6873-4679-A316-EA3F078D34AB" class="sect4">JDBC中的远程数据接口示例</h4>
                  <div>
                     <p>以下代码片段适用于所有三个JDBC驱动程序（数据库中的OCI，Thin和<code class="codeph">kprb</code> ）：</p>
                     <p><span class="bold">绑定：</span> 
                     </p>
                     <p>这适用于非流模式：</p><pre class="oac_no_warn" dir="ltr">...String sql =“insert into <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_final_text）”+“values（：1，：2，：3）”; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1,2）; pstmt.setInt（2,20）; <span class="bold">pstmt.setString（3，“Java string”）;</span> int rows = pstmt.executeUpdate（）; ...
</pre><p>对于流模式，与前面的代码相同的代码，除了<code class="codeph">setString()</code>语句被以下之一替换：</p><pre class="oac_no_warn" dir="ltr">pstmt.setCharacterStream（3，new LabeledReader（），1000000）; pstmt.setAsciiStream（3，new LabeledAsciiInputStream（），1000000）;</pre><p>这里， <code class="codeph">LabeledReader()</code>和<code class="codeph">LabeledAsciiInputStream()</code>分别产生字符和ASCII流。如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，那么如果绑定的类型为<code class="codeph">RAW</code> ，前面的示例将起作用：</p><pre class="oac_no_warn" dir="ltr">pstmt.setBytes（3，&lt;some byte [] array&gt;）; pstmt.setBinaryStream（3，new LabeledInputStream（），1000000）;</pre><p>这里， <code class="codeph">LabeledInputStream()</code>生成二进制流。
                     </p>
                     <p><span class="bold">限定：</span> 
                     </p>
                     <p>对于非流模式：</p><pre class="oac_no_warn" dir="ltr">OracleStatement stmt =（OracleStatement）（conn.createStatement（））; stmt.defineColumnType（1，类型。<span class="bold">VARCHAR</span> ）; ResultSet rst = stmt.executeQuery（“从print_media @ dbs2中选择ad_finaltext”）; while（rst.next（））{String s = rst.getString（1）; System.out.println（s）; }</pre><p>对于流媒体模式：</p><pre class="oac_no_warn" dir="ltr">OracleStatement stmt =（OracleStatement）（conn.createStatement（））; stmt.defineColumnType（1，类型。<span class="bold">LONGVARCHAR</span> ）; ResultSet rst = stmt.executeQuery（“从print_media @ dbs2中选择ad_finaltext”）; while（rst.next（））{Reader reader = rst.getCharacterStream（1）; while（reader.ready（））{System.out.print（（char）（reader.next（）））; System.out.println（）; }</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，那么如果define的类型为<code class="codeph">LONGVARBINARY</code> ，则前面的示例有效：</p><pre class="oac_no_warn" dir="ltr">...OracleStatement stmt =（OracleStatement）conn.createStatement（）; stmt.defineColumnType（1，类型。整数 ）; stmt.defineColumnType（2，类型。LONGVARBINARY）; ResultSet rset = stmt.executeQuery（“SELECT ID，LOBCOL FROM LOBTAB @MYSELF”）; while（rset.next（））{/ * using getBytes（）* / / * byte [] b = rset.getBytes（“LOBCOL”）; System.out.println（“ID：”+ rset.getInt（“ID”）+“length：”+ b.length）; * / / *使用getBinaryStream（）* / InputStream byte_stream = rset.getBinaryStream（“LOBCOL”）; byte [] b =新字节[100000]; int b_len = byte_stream.read（b）; System.out.println（“ID：”+ rset.getInt（“ID”）+“length：”+ b_len）; byte_stream.close（）; } ...</pre><div class="infoboxnotealso" id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB__GUID-2EA17AA0-FC07-4D20-A18F-F949168714A8">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/LOBs-and-BFiles.html#JJDBC15000" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="04085.JDBC-reference-information.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>JDBC参考信息</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="appendixes.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-RAC-FAN-API.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="appendixes.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-RAC-FAN-API.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="appendixes.html" property="item" typeof="WebPage"><span property="name">附录</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">JDBC参考信息</li>
            </ol>
            <a id="GUID-7D2E4420-DC2D-4B0C-82E2-960EBE5CD9A7" name="GUID-7D2E4420-DC2D-4B0C-82E2-960EBE5CD9A7"></a><a id="JJDBC28905"></a>
            
            <h2 id="JJDBC-GUID-7D2E4420-DC2D-4B0C-82E2-960EBE5CD9A7" class="sect2"><span class="enumeration_chapter">一个</span> JDBC参考信息</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='JDBC-reference-information'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <div class="section">
                  <p>本附录包含详细的Java数据库连接（JDBC）参考信息，包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="JDBC-reference-information.html#GUID-260661A5-E0CE-40D5-8590-FC15266C3392">支持的SQL-JDBC数据类型映射</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-reference-information.html#GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE">支持的SQL和PL / SQL数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-reference-information.html#GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2">关于使用PL / SQL类型</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-reference-information.html#GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787">使用嵌入式JDBC转义语法</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-reference-information.html#GUID-E8DF3990-1EB5-4185-989C-06D13740BD01">Oracle JDBC Notes和限制</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JJDBC28907"></a><a id="JJDBC28906"></a><div class="props_rev_3"><a id="GUID-260661A5-E0CE-40D5-8590-FC15266C3392" name="GUID-260661A5-E0CE-40D5-8590-FC15266C3392"></a><h3 id="JJDBC-GUID-260661A5-E0CE-40D5-8590-FC15266C3392" class="sect3"><span class="enumeration_section">A.1</span>支持的SQL-JDBC数据类型映射</h3>
               <div>
                  <div class="section">
                     <p>下表列出了可以有效映射给定SQL数据类型的所有可能的Java类型。Oracle JDBC驱动程序将支持这些非默认映射。例如，在<code class="codeph">oracle.sql.实现SQL <code class="codeph">CHAR</code>数据<code class="codeph">oracle.sql.CHAR</code>对象，使用<code class="codeph">getCHAR</code>方法。将其实现为<code class="codeph">java.math.BigDecimal</code>对象，使用<code class="codeph">getBigDecimal</code>方法。
                     </p>
                     <div class="infoboxnote" id="GUID-260661A5-E0CE-40D5-8590-FC15266C3392__GUID-DF153A1A-6DD8-469C-AB9F-5DD4B2FEF02C">
                        <p class="notep1">注意：</p>
                        <p>这个类，其中<code class="codeph">oracle.jdbc.OracleData</code>以斜体显示，可以由Oracle JVM Web服务调用实用程序生成。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-260661A5-E0CE-40D5-8590-FC15266C3392__CACBBAIE">
                     <p class="titleintable">表A-1有效的SQL数据类型-Java类映射</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="有效的SQL数据类型-Java类映射" width="100%" border="1" summary="This table lists the valid SQL data type and Java class mappings." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="35%" id="d88087e106">SQL数据类型</th>
                              <th align="left" valign="bottom" width="65%" id="d88087e109">Java类型</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e114" headers="d88087e106 ">
                                 <p><code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">LONG</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e114 d88087e109 ">
                                 <p><code class="codeph">java.lang中。串</code></p>
                                 <p><code class="codeph">oracle.sql。CHAR</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e132" headers="d88087e106 ">
                                 <p><code class="codeph">数</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e132 d88087e109 ">
                                 <p><code class="codeph">布尔</code></p>
                                 <p><code class="codeph">烧焦</code></p>
                                 <p><code class="codeph">字节</code></p>
                                 <p><code class="codeph">短</code></p>
                                 <p><code class="codeph">INT</code></p>
                                 <p><code class="codeph">长</code></p>
                                 <p><code class="codeph">浮动</code></p>
                                 <p><code class="codeph">双</code></p>
                                 <p><code class="codeph">java.lang中。字节</code></p>
                                 <p><code class="codeph">java.lang中。短</code></p>
                                 <p><code class="codeph">java.lang中。整数</code></p>
                                 <p><code class="codeph">java.lang中。长</code></p>
                                 <p><code class="codeph">java.lang中。浮动</code></p>
                                 <p><code class="codeph">java.lang中。双</code></p>
                                 <p><code class="codeph">java.math中。BigDecimal的</code></p>
                                 <p><code class="codeph">oracle.sql。数</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e187" headers="d88087e106 ">
                                 <p><code class="codeph">BINARY_INTEGER</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e187 d88087e109 ">
                                 <p><code class="codeph">布尔</code></p>
                                 <p><code class="codeph">烧焦</code></p>
                                 <p><code class="codeph">字节</code></p>
                                 <p><code class="codeph">短</code></p>
                                 <p><code class="codeph">INT</code></p>
                                 <p><code class="codeph">长</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e211" headers="d88087e106 ">
                                 <p><code class="codeph">BINARY_FLOAT</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e211 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。BINARY_FLOAT</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e220" headers="d88087e106 ">
                                 <p><code class="codeph">BINARY_DOUBLE</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e220 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。BINARY_DOUBLE</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e229" headers="d88087e106 ">
                                 <p><code class="codeph">日期</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e229 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。日期</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e238" headers="d88087e106 ">
                                 <p><code class="codeph">生的</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e238 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。生的</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e247" headers="d88087e106 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e247 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleBlob</code> <a id="fn_1" name="fn_1" href="#fn_1" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.blob="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oracleblob="" interface=")" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e268" headers="d88087e106 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e268 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleClob</code> <a id="fn_2" name="fn_2" href="#fn_2" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.clob="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oracleclob="" interface=")" ="" onclick="footdisplay(2, "><sup>Foot 2</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e289" headers="d88087e106 ">
                                 <p><code class="codeph">BFILE</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e289 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。BFILE</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e298" headers="d88087e106 ">
                                 <p><code class="codeph">ROWID</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e298 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。ROWID</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e308" headers="d88087e106 ">
                                 <p><code class="codeph">TIMESTAMP</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e308 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。TIMESTAMP</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e317" headers="d88087e106 ">
                                 <p><code class="codeph">TIMESTAMP与时区</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e317 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。TIMESTAMPTZ</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e326" headers="d88087e106 ">
                                 <p><code class="codeph">TIMESTAMP与当地时区</code></p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e326 d88087e109 ">
                                 <p><code class="codeph">oracle.sql。TIMESTAMPLTZ</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e335" headers="d88087e106 ">
                                 <p>引用光标</p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e335 d88087e109 ">
                                 <p>j <code class="codeph">ava.sql.结果集</code></p>
                                 <p><code class="codeph">sqlj.runtime。ResultSetIterator</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e347" headers="d88087e106 ">
                                 <p>用户定义的命名类型，ADT</p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e347 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleStruct</code> <a id="fn_3" name="fn_3" href="#fn_3" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.struct="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oraclestruct="" interface=")" ="" onclick="footdisplay(3, "><sup>Foot 3</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e367" headers="d88087e106 ">
                                 <p>不透明的命名类型</p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e367 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleOpaque</code> <a id="fn_4" name="fn_4" href="#fn_4" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.opaque="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oracleopaque="" interface=")" ="" onclick="footdisplay(4, "><sup>Foot 4</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e387" headers="d88087e106 ">
                                 <p>嵌套表和VARRAY命名类型</p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e387 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleArray</code> <a id="fn_5" name="fn_5" href="#fn_5" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.array="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oraclearray="" interface=")" ="" onclick="footdisplay(5, "><sup>Foot 5</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="35%" id="d88087e407" headers="d88087e106 ">
                                 <p>对命名类型的引用</p>
                              </td>
                              <td align="left" valign="top" width="65%" headers="d88087e407 d88087e109 ">
                                 <p><code class="codeph">oracle.jdbc。OracleRef</code> <a id="fn_6" name="fn_6" href="#fn_6" class="" starting="" from="" oracle="" database="" 12c="" release="" 1="" (12.1),="" the="" oracle.sql.ref="" is="" deprecated="" and="" replaced="" with="" oracle.jdbc.oracleref="" interface=")" ="" onclick="footdisplay(6, "><sup>Foot 6</sup></a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用BLOB</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleBlob</code>接口。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注2</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用CLOB</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleClob</code>接口。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注3</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用STRUCT</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleStruct</code>接口。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注4</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用OPAQUE</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleOpaque</code>接口。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注5</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用ARRAY</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleArray</code>接口。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注6</sup></p><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用REF</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleRef</code>接口。
                     </p>
                  <p></p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-260661A5-E0CE-40D5-8590-FC15266C3392__GUID-C9081210-1653-4CDF-8D35-12A5C38B7588">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不支持<code class="codeph">UROWID</code>类型。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql.Datum</code>类是抽象的。传递给<code class="codeph">oracle.sql.类型的参数的值<code class="codeph">oracle.sql.Datum</code>必须是与基础SQL类型对应的Java类型。同样，返回类型为<code class="codeph">oracle.sql.的方法返回的值<code class="codeph">oracle.sql.Datum</code>必须是与基础SQL类型对应的Java类型。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28909"></a><a id="JJDBC28910"></a><a id="JJDBC28911"></a><a id="JJDBC28912"></a><a id="JJDBC28908"></a><div class="props_rev_3"><a id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE" name="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE"></a><h3 id="JJDBC-GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE" class="sect3"><span class="enumeration_section">A.2</span>支持的SQL和PL / SQL数据类型</h3>
               <div>
                  <div class="section">
                     <p>本节中的表列出了SQL和PL / SQL数据类型，以及对它们的Oracle JDBC驱动程序支持。下表描述了对SQL数据类型的Oracle JDBC驱动程序支持。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE__G1009689">
                     <p class="titleintable">表A-2支持SQL数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="支持SQL数据类型" width="100%" border="1" summary="This table lists Oracle JDBC driver support for SQL Data Types." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="52%" id="d88087e486">SQL数据类型</th>
                              <th align="left" valign="bottom" width="48%" id="d88087e489">JDBC驱动程序支持？</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e494" headers="d88087e486 ">
                                 <p>BFILE</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e494 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e501" headers="d88087e486 ">
                                 <p>BLOB</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e501 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e508" headers="d88087e486 ">
                                 <p>CHAR</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e508 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e515" headers="d88087e486 ">
                                 <p>CLOB</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e515 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e522" headers="d88087e486 ">
                                 <p>日期</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e522 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e529" headers="d88087e486 ">
                                 <p>NCHAR</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e529 d88087e489 ">
                                 <p>没有<a id="fn_7" name="fn_7" href="#fn_7" type="" the="" nchar="" is="" supported="" indirectly.="" there="" no="" corresponding="" java.sql.types="" type,="" but="" if="" your="" application="" calls="" formofuse(nchar)="" method,="" then="" this="" can="" be="" accessed=")" ="" onclick="footdisplay(7, "><sup>脚7</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e539" headers="d88087e486 ">
                                 <p>NCHAR变化</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e539 d88087e489 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e546" headers="d88087e486 ">
                                 <p>数</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e546 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e553" headers="d88087e486 ">
                                 <p>NVARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e553 d88087e489 ">
                                 <p>是<a id="fn_8" name="fn_8" href="#fn_8" type="" in="" jse="" 6,="" the="" nvarchar2="" is="" supported="" directly.="" j2se="" 5.0,="" indirectly.="" there="" no="" corresponding="" java.sql.types="" type,="" but="" if="" your="" application="" calls="" formofuse(nchar)="" method,="" then="" this="" can="" be="" accessed=")" ="" onclick="footdisplay(8, "><sup>脚8</sup></a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e563" headers="d88087e486 ">
                                 <p>生的</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e563 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e570" headers="d88087e486 ">
                                 <p>REF</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e570 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e578" headers="d88087e486 ">
                                 <p>ROWID</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e578 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e585" headers="d88087e486 ">
                                 <p>UROWID</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e585 d88087e489 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e592" headers="d88087e486 ">
                                 <p>VARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e592 d88087e489 ">
                                 <p>是</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p class="tablefootnote"><sup class="tablefootnote">脚注7</sup></p><p>NCHAR类型是间接支持的。没有相应的java.sql。类型类型，但如果您的应用程序调用formOfUse（NCHAR）方法，则可以访问此类型。</p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注8</sup></p><p>在JSE 6中，直接支持NVARCHAR2类型。在J2SE 5.0中，间接支持NVARCHAR2类型。没有相应的java.sql。类型类型，但如果您的应用程序调用formOfUse（NCHAR）方法，则可以访问此类型。</p>
                  <p></p>
                  <div class="section">
                     <p>下表描述了对ANSI支持的SQL数据类型的Oracle JDBC支持。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE__G1009738">
                     <p class="titleintable">表A-3支持ANSI-92 SQL数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="支持ANSI-92 SQL数据类型" width="100%" border="1" summary="This table lists Oracle JDBC driver support for ANSI-92 SQL Data Types." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="52%" id="d88087e611">ANSI支持的SQL数据类型</th>
                              <th align="left" valign="bottom" width="48%" id="d88087e614">JDBC驱动程序支持？</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e619" headers="d88087e611 ">
                                 <p>字符</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e619 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e626" headers="d88087e611 ">
                                 <p>DEC</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e626 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e633" headers="d88087e611 ">
                                 <p>DECIMAL</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e633 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e640" headers="d88087e611 ">
                                 <p>双精度</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e640 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e647" headers="d88087e611 ">
                                 <p>浮动</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e647 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e654" headers="d88087e611 ">
                                 <p>INT</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e654 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e661" headers="d88087e611 ">
                                 <p>整数</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e661 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e668" headers="d88087e611 ">
                                 <p>国家人物</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e668 d88087e614 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e675" headers="d88087e611 ">
                                 <p>国家角色变化</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e675 d88087e614 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e682" headers="d88087e611 ">
                                 <p>国家查尔</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e682 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e689" headers="d88087e611 ">
                                 <p>国家角色变化</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e689 d88087e614 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e697" headers="d88087e611 ">
                                 <p>NCHAR</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e697 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e704" headers="d88087e611 ">
                                 <p>NCHAR变化</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e704 d88087e614 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e711" headers="d88087e611 ">
                                 <p>数字</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e711 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e718" headers="d88087e611 ">
                                 <p>真实</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e718 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e725" headers="d88087e611 ">
                                 <p>SMALLINT</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e725 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e732" headers="d88087e611 ">
                                 <p>VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e732 d88087e614 ">
                                 <p>是</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>下表描述了SQL用户定义类型的Oracle JDBC驱动程序支持。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE__G1009950">
                     <p class="titleintable">表A-4对SQL用户定义类型的支持</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="支持SQL用户定义的类型" width="100%" border="1" summary="This table lists Oracle JDBC driver support for SQL user-defined types." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="52%" id="d88087e751">SQL用户定义的类型</th>
                              <th align="left" valign="bottom" width="48%" id="d88087e754">JDBC驱动程序支持？</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e759" headers="d88087e751 ">
                                 <p>不透明</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e759 d88087e754 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e766" headers="d88087e751 ">
                                 <p>参考类型</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e766 d88087e754 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e773" headers="d88087e751 ">
                                 <p>对象类型（ <code class="codeph">JAVA_OBJECT</code> ）</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e773 d88087e754 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d88087e783" headers="d88087e751 ">
                                 <p>嵌套表类型和VARRAY类型</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d88087e783 d88087e754 ">
                                 <p>是</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>下表描述了对PL / SQL数据类型的Oracle JDBC驱动程序支持。PL / SQL数据类型包括以下类别：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>标量类型</p>
                        </li>
                        <li>
                           <p>标量字符类型，包括<code class="codeph">DATE</code>数据类型</p>
                        </li>
                        <li>
                           <p>复合类型</p>
                        </li>
                        <li>
                           <p>参考类型</p>
                        </li>
                        <li>
                           <p>大对象（LOB）类型</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE__G1009796">
                     <p class="titleintable">表A-5支持PL / SQL数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="支持PL / SQL数据类型" width="100%" border="1" summary="This table lists Oracle JDBC driver support for PL/SQL data types." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="49%" id="d88087e821">PL / SQL数据类型</th>
                              <th align="left" valign="bottom" width="51%" id="d88087e824">JDBC驱动程序支持？</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e829" headers="d88087e821 ">
                                 <p><span class="bold">标量类型：</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e829 d88087e824 "> </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e835" headers="d88087e821 ">
                                 <p>二进制整数</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e835 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e842" headers="d88087e821 ">
                                 <p>DEC</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e842 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e849" headers="d88087e821 ">
                                 <p>DECIMAL</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e849 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e856" headers="d88087e821 ">
                                 <p>双精度</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e856 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e863" headers="d88087e821 ">
                                 <p>浮动</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e863 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e870" headers="d88087e821 ">
                                 <p>INT</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e870 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e877" headers="d88087e821 ">
                                 <p>整数</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e877 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e884" headers="d88087e821 ">
                                 <p>自然</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e884 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e891" headers="d88087e821 ">
                                 <p>自然科学<span class="italic">ñ</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e891 d88087e824 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e900" headers="d88087e821 ">
                                 <p>数</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e900 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e908" headers="d88087e821 ">
                                 <p>数字</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e908 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e915" headers="d88087e821 ">
                                 <p>PLS_INTEGER</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e915 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e922" headers="d88087e821 ">
                                 <p>正</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e922 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e929" headers="d88087e821 ">
                                 <p>正的<span class="italic">N</span>值</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e929 d88087e824 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e938" headers="d88087e821 ">
                                 <p>真实</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e938 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e945" headers="d88087e821 ">
                                 <p>SIGNTYPE</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e945 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e952" headers="d88087e821 ">
                                 <p>SMALLINT</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e952 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e959" headers="d88087e821 ">
                                 <p>布尔</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e959 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e966" headers="d88087e821 ">
                                 <p><span class="bold">标量字符类型：</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e966 d88087e824 "> </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e972" headers="d88087e821 ">
                                 <p>CHAR</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e972 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e979" headers="d88087e821 ">
                                 <p>字符</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e979 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e987" headers="d88087e821 ">
                                 <p>长</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e987 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e994" headers="d88087e821 ">
                                 <p>LONG RAW</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e994 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1001" headers="d88087e821 ">
                                 <p>NCHAR</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1001 d88087e824 ">
                                 <p>不（见注）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1008" headers="d88087e821 ">
                                 <p>NVARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1008 d88087e824 ">
                                 <p>不（见注）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1015" headers="d88087e821 ">
                                 <p>生的</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1015 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1022" headers="d88087e821 ">
                                 <p>ROWID</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1022 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1029" headers="d88087e821 ">
                                 <p>串</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1029 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1036" headers="d88087e821 ">
                                 <p>UROWID</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1036 d88087e824 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1043" headers="d88087e821 ">
                                 <p>VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1043 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1050" headers="d88087e821 ">
                                 <p>VARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1050 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1057" headers="d88087e821 ">
                                 <p>日期</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1057 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1065" headers="d88087e821 ">
                                 <p><span class="bold">复合类型：</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1065 d88087e824 "> </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1071" headers="d88087e821 ">
                                 <p>记录</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1071 d88087e824 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1078" headers="d88087e821 ">
                                 <p>表</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1078 d88087e824 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1085" headers="d88087e821 ">
                                 <p>VARRAY</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1085 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1092" headers="d88087e821 ">
                                 <p><span class="bold">参考类型：</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1092 d88087e824 "> </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1098" headers="d88087e821 ">
                                 <p>REF CURSOR类型</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1098 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1105" headers="d88087e821 ">
                                 <p>对象引用类型</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1105 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1112" headers="d88087e821 ">
                                 <p><span class="bold">LOB类型：</span></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1112 d88087e824 "> </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1118" headers="d88087e821 ">
                                 <p>BFILE</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1118 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1125" headers="d88087e821 ">
                                 <p>BLOB</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1125 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1132" headers="d88087e821 ">
                                 <p>CLOB</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1132 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="49%" id="d88087e1140" headers="d88087e821 ">
                                 <p>NCLOB</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d88087e1140 d88087e824 ">
                                 <p>是</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-9A3DFD72-E254-4BC6-B533-A6B7A9EDFBEE__GUID-83D26B5A-64D4-4463-8327-972A2FB881F9">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">NATURAL</code> ， <code class="codeph">NATURAL</code> <span class="italic"><code class="codeph">n</code></span> ， <code class="codeph">POSITIVE</code> ， <code class="codeph">POSITIVE</code> <span class="italic"><code class="codeph">n</code></span>和<code class="codeph">SIGNTYPE</code>是<code class="codeph">BINARY INTEGER</code>子类型。</p>
                           </li>
                           <li>
                              <p><code class="codeph">DEC</code> ， <code class="codeph">DECIMAL</code> ， <code class="codeph">DOUBLE PRECISION</code> ， <code class="codeph">FLOAT</code> ， <code class="codeph">INT</code> ， <code class="codeph">INTEGER</code> ， <code class="codeph">NUMERIC</code> ， <code class="codeph">REAL</code>和<code class="codeph">SMALLINT</code>类型是<code class="codeph">NUMBER</code>子类型。</p>
                           </li>
                           <li>
                              <p><code class="codeph">NCHAR</code>和<code class="codeph">NVARCHAR2</code>类型是间接支持的。没有相应的<code class="codeph">java.sql.Types</code>类型，但如果您的应用程序调用<code class="codeph">formOfUse(NCHAR)</code> ，则可以访问这些类型。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="globalization-support.html#GUID-C29926B3-8B5B-4B05-9193-29B247B52C66">NCHAR，NVARCHAR2，NCLOB和defaultNChar属性</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC29146"></a><a id="JJDBC29033"></a><a id="JJDBC29147"></a><a id="JJDBC29032"></a><div class="props_rev_3"><a id="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2" name="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2"></a><h3 id="JJDBC-GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2" class="sect3"><span class="enumeration_section">A.3</span>关于使用PL / SQL类型</h3>
               <div>
                  <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，您可以将模式级PL / SQL类型映射为通用<code class="codeph">java.sql.Struct</code>类型和PL / SQL集合为<code class="codeph">java.sql.Array</code>类型。因此，您可以仅使用JDBC API来描述和绑定PL / SQL类型，而不是创建映射到PL / SQL包类型以进行绑定的模式级类型。</p>
                  <p>例如，您可以调用<code class="codeph">Connection.createStruct(type_name)</code>方法来首先创建可用于描述PL / SQL类型的描述符，然后在客户端上创建此类型的新<code class="codeph">STRUCT</code>表示。在Oracle数据库12 <span class="italic">c</span>解除1（12.1），可以通过指定重新使用此API <code class="codeph">type_name</code>作为<code class="codeph">“schema.package.typename"</code>或<code class="codeph">“package.typename"</code> 。
                  </p>
                  <p>所有PL / SQL包类型都映射到系统范围的唯一名称，JDBC可以使用它来检索服务器端类型元数据。名称采用以下形式：</p><pre class="oac_no_warn" dir="ltr">[SCHEMA。] &lt;PACKAGE&gt; &lt;类型&gt;</pre><div class="infoboxnote" id="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2__GUID-0923B1EE-2898-4181-B061-961039E72742">
                     <p class="notep1">注意：</p>
                     <p>如果模式与包名相同，并且如果存在与PL / SQL类型同名的类型，则它将无法识别具有两个部件名称格式的对象，即&lt;package &gt; &lt;类型&gt;。在这种情况下，您必须使用三个部件名称&lt;schema&gt;。&lt;package&gt;。&lt;type&gt;。</p>
                  </div>
                  <p>以下代码片段解释了如何绑定PL / SQL包中声明的类型：</p><pre class="oac_no_warn" dir="ltr">/ * ---------------------------＃在运行此示例之前执行以下SQL操作---------- ----------------- conn HR / hr;创建或替换包TEST_PKG是类型V_TYP是varchar2（200）的varray（10）; type R_TYP是record（c1 pls_integer，c2 varchar2（100））;程序VARR_PROC（V_TYP中的p1，p2 OUT V_TYP）;程序REC_PROC（R_TYP中的p1，p2 OUT R_TYP）;结束; /创建或替换包体TEST_PKG是程序VARR_PROC（V_TYP中的p1，p2 OUT V_TYP）是开始p2：= p1;结束;程序REC_PROC（R_TYP中的p1，p2 OUT R_TYP）开始p2：= p1;结束;结束; / * / import java.sql。阵列; import java.sql。CallableStatement的; import java.sql。连接; import java.sql。的SQLException; import java.sql。结构; import java.sql。类型; import oracle.jdbc。的OracleConnection; public class PLSQLTypesSample {public static void main（String [] args）抛出SQLException {System.out.println（“begin ...”）;连接conn = null; oracle.jdbc.pool。OracleDataSource ods = new oracle.jdbc.pool。OracleDataSource（）; ods.setURL（ “JDBC：预言：OCI：本地主机：5521：ORCL”）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; // get connection conn = ods.getConnection（）; //调用过程TEST_PKG.VARR_PROC CallableStatement cstmt = null; try {cstmt = conn.prepareCall（“{call TEST_PKG.VARR_PROC（？，？）}“）; // PLSQL VARRAY类型绑定Array arr =（（OracleConnection）conn）.createArray（”TEST_PKG.V_TYP“，new String [] {”A“，”B“}）; cstmt.setArray（1，arr ）; cstmt.registerOutParameter（2，类型。ARRAY，“TEST_PKG.V_TYP”）; cstmt.execute（）; //获取PLSQL VARRAY类型输出参数值Array outArr = cstmt.getArray（2）; // ...} catch（Exception e）{e.printStackTrace（）; } finally {if（cstmt！= null）cstmt.close（）; } //调用过程TEST_PKG.REC_PROC尝试{cstmt = conn.prepareCall（“{call TEST_PKG.REC_PROC（？，？）}“;; // PLSQL RECORD类型绑定Struct struct = conn.createStruct（”TEST_PKG.R_TYP“，new Object [] {12345，”B“}）; cstmt.setObject（1，struct）; cstmt.registerOutParameter（2 ，类型。STRUCT，“TEST_PKG.R_TYP”）; cstmt.execute（）; //获取PLSQL RECORD类型输出参数值Struct outStruct =（Struct）cstmt.getObject（2）; // ...} catch（Exception e）{e.printStackTrace（）; } finally {if（cstmt！= null）cstmt.close（）;如果（连环！= null）conn.close（）;的System.out.println（“完成了！“）;}}</pre><div class="section">
                     <p class="subhead2" id="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2__GUID-05D6757B-C351-4A52-97CD-78230C461053">使用％ROWTYPE属性为每行创建Java级别对象</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>您可以使用<code class="codeph">%ROWTYPE</code>属性创建Java级对象。在这种情况下，表的每一行都创建为<code class="codeph">java.sql.Struct</code>对象。例如，如果您的包<code class="codeph">pack1</code>具有以下规范：</p>
                     <div class="infoboxnotealso" id="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2__GUID-82313689-290B-4BCF-88D5-0896F2A7EB7C">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">%ROWTYPE</code>属性的更多信息，请<a href="../lnpls/ROWTYPE-attribute.html#LNPLS01342" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                     </div><pre class="oac_no_warn" dir="ltr">创建或更换包装件类型EMPLOYEE_ROWTYPE_ARRAY是雇员表％ROWTYPE; END PACK1; /</pre><p>以下代码段显示了如何使用JDBC API检索<code class="codeph">EMPLOYEE_ROWTYPE_ARRAY</code>数组的值：</p>
                     <p>此示例返回<code class="codeph">java.sql.<code class="codeph">java.sql. Array</code> <code class="codeph">java.sql.Struct</code>对象，其中每个<code class="codeph">Struct</code>元素表示<code class="codeph">EMPLOYEES</code>表的一行。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2__CHEDCCHD">
                     <p class="titleinexample">示例A-1为数据库表行创建结构对象</p><pre class="oac_no_warn" dir="ltr">CallableStatement cstmt = conn.prepareCall（“BEGIN SELECT * BULK COLLECT INTO：1 from EMPLOYEE; END;”）; cstmt.registerOutParameter（1，OracleTypes。ARRAY，“PACK1。EMPLOYEE_ROWTYPE_ARRAY“）; cstmt.execute（）;数组a = cstmt.getArray（1）;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="JJDBC28914"></a><a id="JJDBC28913"></a><div class="props_rev_3"><a id="GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787" name="GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787"></a><h3 id="JJDBC-GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787" class="sect3"><span class="enumeration_section">A.4</span>使用嵌入式JDBC转义语法</h3>
               <div>
                  <div class="section">
                     <p>神谕<a id="d88087e1381" class="indexterm-anchor"></a><a id="d88087e1383" class="indexterm-anchor"></a> JDBC驱动程序支持一些嵌入式JDBC转义语法，这是您在花括号之间指定的语法。目前的支持是基本的。
                     </p>
                     <div class="infoboxnote" id="GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787__GUID-3F85EA7F-2E98-41AF-AC57-1930CD39A87E">
                        <p class="notep1">注意：</p>
                        <p>JDBC转义语法以前称为SQL92语法或SQL92转义语法。</p>
                     </div>
                     <p>本节介绍驱动程序为以下构造提供的支持：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-FCB7E652-4532-47AF-9783-B7E2B6ADA41C">时间和日期文字</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-9F59DD78-4FD3-4451-A27C-53505F842F15">标量函数</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-5D371A5B-D7F6-42EB-8C0D-D317F3C53708">喜欢逃脱角色</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-3454411C-5F24-4D46-83A9-5DA0BA704F5D">MATCH_RECOGNIZE条款</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-B0C6C3C6-9E3F-4428-876C-5C493A9D2624">外连接</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-BE5C683E-0A2F-42D1-AF9B-7854BFAC4D53">函数调用语法</a></p>
                        </li>
                     </ul>
                     <p>在驱动程序支持有限的情况下，这些部分还描述了可能的解决方法。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787__CHEFDIAB">
                     <p class="subhead2" id="GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787__GUID-092E10EB-F3E9-4295-8AD9-15B7027F4796">禁用转义处理</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>该<a id="d88087e1432" class="indexterm-anchor"></a>默认情况下启用JDBC转义语法处理，这会导致JDBC驱动程序在将SQL代码发送到数据库之前执行转义替换。如果您希望驱动程序使用常规Oracle <a id="d88087e1435" class="indexterm-anchor"></a> SQL语法，它比JDBC转义语法处理更有效，然后使用此语句：</p><pre class="oac_no_warn" dir="ltr">stmt.setEscapeProcessing（假）;</pre></div>
                  <!-- class="section" -->
               </div><a id="JJDBC28915"></a><div class="props_rev_3"><a id="GUID-FCB7E652-4532-47AF-9783-B7E2B6ADA41C" name="GUID-FCB7E652-4532-47AF-9783-B7E2B6ADA41C"></a><h4 id="JJDBC-GUID-FCB7E652-4532-47AF-9783-B7E2B6ADA41C" class="sect4"><span class="enumeration_section">A.4.1</span>时间和日期文字</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e1464" class="indexterm-anchor"></a><a id="d88087e1468" class="indexterm-anchor"></a>数据库在日期，时间和时间戳文字中使用的语法不同。JDBC支持仅以特定格式编写的日期和时间。本节介绍了SQL语句中日期，时间和时间戳文字必须使用的格式。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC28916"></a><div class="props_rev_3"><a id="GUID-A5DB6CFB-E0D6-4AC8-AF51-4E82452E48BF" name="GUID-A5DB6CFB-E0D6-4AC8-AF51-4E82452E48BF"></a><h5 id="JJDBC-GUID-A5DB6CFB-E0D6-4AC8-AF51-4E82452E48BF" class="sect5"><span class="enumeration_section">A.4.1.1日期文字</span></h5>
                     <div>
                        <div class="section">
                           <p>JDBC驱动程序支持以下格式编写的SQL语句中的日期文字：</p><pre class="oac_no_warn" dir="ltr">{d'yyyy-mm-dd'}</pre><p><code class="codeph">yyyy-mm-dd</code>代表年，月和日。例如：</p><pre class="oac_no_warn" dir="ltr">{d'1995-10-22'}</pre><p>JDBC驱动程序将使用等效的Oracle表示替换此转义子句：“1995年10月22日”。</p>
                           <p>以下代码段包含在SQL语句中使用日期文字的示例。</p><pre class="oac_no_warn" dir="ltr">//连接到数据库//您可以在连接URL中的@符号后面添加数据库名称。 OracleDataSource ods = new OracleDataSource（）; ods.setURL（ “JDBC：预言：OCI：@”）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; Connection conn = ods.getConnection（）; //创建一个Statement语句stmt = conn.createStatement（）; //从雇员表中选择雇佣日期为Jan-23-1982的第一个名称列ResultSet rset = stmt.executeQuery（“SELECT first_name FROM employees WHERE hire_date = {d'1982-01-23'}”）; //迭代结果并打印员工姓名while（rset.next（））System.out.println（rset.getString（1））;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28917"></a><div class="props_rev_3"><a id="GUID-A9D9AB11-1CBB-4091-851D-2E0A0F280F08" name="GUID-A9D9AB11-1CBB-4091-851D-2E0A0F280F08"></a><h5 id="JJDBC-GUID-A9D9AB11-1CBB-4091-851D-2E0A0F280F08" class="sect5"><span class="enumeration_section">A.4.1.2</span>时间文字</h5>
                     <div>
                        <div class="section">
                           <p>JDBC驱动程序支持以下格式编写的SQL语句中的时间文字：</p><pre class="oac_no_warn" dir="ltr">{t'hh：mm：ss'}</pre><p>其中， <code class="codeph">hh:mm:ss</code>代表小时，分钟和秒。例如：</p><pre class="oac_no_warn" dir="ltr">{t '05：10：45'}</pre><p>JDBC驱动程序将使用等效的Oracle表示替换此escape子句：“05:10:45”。</p>
                           <p>如果时间指定为：</p><pre class="oac_no_warn" dir="ltr">{t '14：20：50'}</pre><p>假设服务器使用24小时制，那么等效的Oracle表示将是“14:20:50”。</p>
                           <p>此代码段包含在SQL语句中使用时间文字的示例。</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“SELECT first_name FROM employees WHERE hire_date = {t '12：00：00'}”）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28919"></a><a id="JJDBC28918"></a><div class="props_rev_3"><a id="GUID-271C19F0-459D-4DA8-8C1D-F04AA5B8CD08" name="GUID-271C19F0-459D-4DA8-8C1D-F04AA5B8CD08"></a><h5 id="JJDBC-GUID-271C19F0-459D-4DA8-8C1D-F04AA5B8CD08" class="sect5"><span class="enumeration_section">A.4.1.3</span>时间戳文字</h5>
                     <div>
                        <div class="section">
                           <p>JDBC驱动程序支持以下格式编写的SQL语句中的时间戳文字：</p><pre class="oac_no_warn" dir="ltr">{ts'yyyy-mm-dd hh：mm：ss.f ...“}</pre><p>其中<code class="codeph">yyyy-mm-dd hh:mm:ss.f...</code>表示年，月，日，小时，分钟和秒。小数秒部分（ <code class="codeph">.f...</code> ）是可选的，可以省略。例如： <code class="codeph">{ts '1997-11-01 13:22:45'}</code>以Oracle格式表示，NOV 01 1997 13:22:45。
                           </p>
                           <p>此代码段包含在SQL语句中使用时间戳文字的示例。</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“SELECT first_name FROM employees WHERE hire_date = {ts'1982-01-23 12:00:00'}”）;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-271C19F0-459D-4DA8-8C1D-F04AA5B8CD08__GUID-83B0777E-468F-4FDD-B55C-C5A36D962C84">将SQL DATE数据类型映射到Java</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Oracle Database 8 <span class="italic">i</span>及更早版本不支持<code class="codeph">TIMESTAMP</code>数据，但Oracle <code class="codeph">DATE</code>数据曾经将时间组件作为SQL标准的扩展。因此，Oracle Database 8 <span class="italic">i</span>和早期版本的JDBC驱动程序映射了<code class="codeph">oracle.sql.DATE</code>到<code class="codeph">java.sql.用于保留时间组件的Timestamp</code> 。从Oracle Database 9.0.1开始，包括<code class="codeph">TIMESTAMP</code>支持，并且9 <span class="italic">i</span> JDBC驱动程序开始映射<code class="codeph">oracle.sql.DATE</code>到<code class="codeph">java.sql.Date</code> 。此映射不正确，因为它截断了Oracle <code class="codeph">DATE</code>数据的时间组件。为了解决这个问题，Oracle Database <span class="italic">11g</span>第1版引入了一个新的标志<code class="codeph">mapDateToTimestamp</code> 。此标志的默认值为<code class="codeph">true</code> ，这意味着默认情况下驱动程序将正确映射<code class="codeph">oracle.sql.DATE</code>到<code class="codeph">java.sql.Timestamp</code> ，保留时间信息。如果你仍然想要不正确但10 <span class="italic">g</span>兼容的<code class="codeph">oracle.sql.DATE</code>到<code class="codeph">java.sql.Date</code>映射，然后您可以通过将<code class="codeph">mapDateToTimestamp</code>标志的值设置为<code class="codeph">false</code>来获取它。
                           </p>
                           <div class="infoboxnote" id="GUID-271C19F0-459D-4DA8-8C1D-F04AA5B8CD08__GUID-CDBD8914-C61E-4AE4-A2DB-51C6D5A45A7D">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>从Oracle Database <span class="italic">11g开始</span> ，如果您在DATE列上有索引要由SQL查询使用，那么为了获得更快更准确的结果，您必须以下列方式使用<code class="codeph">setObject</code>方法：</p><pre class="oac_no_warn" dir="ltr">日期d = parseIsoDate（val）;时间戳t =新的时间戳（d.getTime（））; stmt.setObject（pos，new oracle.sql。DATE（t，（Calendar）UTC_CAL.clone（）））;</pre><p>这是因为如果使用<code class="codeph">setDate</code>方法，则Oracle DATE数据的时间组件将丢失，如果使用<code class="codeph">setTimestamp</code>方法，则不会使用DATE列上的索引。
                                    </p>
                                 </li>
                                 <li>
                                    <p>克服<code class="codeph">oracle.sql.的问题<code class="codeph">oracle.sql.DATE</code>到<code class="codeph">java.sql.Date</code>映射，Oracle Database 9.2引入了一个标志， <code class="codeph">V8Compatible</code> 。此标志的默认值为<code class="codeph">false</code> ，这允许将Oracle <code class="codeph">DATE</code>数据映射到<code class="codeph">java.sql.Date</code>数据。但是，用户可以通过将此标志的值设置为<code class="codeph">true</code>来保留Oracle <code class="codeph">DATE</code>数据的时间组件。自11 <span class="italic">g</span>以来不支持此标志，因为它控制了Oracle Database 8 <span class="italic">i的</span>兼容性，不再受支持。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28920"></a><div class="props_rev_3"><a id="GUID-9F59DD78-4FD3-4451-A27C-53505F842F15" name="GUID-9F59DD78-4FD3-4451-A27C-53505F842F15"></a><h4 id="JJDBC-GUID-9F59DD78-4FD3-4451-A27C-53505F842F15" class="sect4"><span class="enumeration_section">A.4.2</span>标量函数</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e1752" class="indexterm-anchor"></a><a id="d88087e1754" class="indexterm-anchor"></a> Oracle JDBC驱动程序不支持所有标量函数。要找出驱动程序支持的功能，请使用Oracle特定的<code class="codeph">oracle.jdbc.支持的以下方法<code class="codeph">oracle.jdbc.OracleDatabaseMetaData</code>类和标准Java <code class="codeph">java.sql.DatabaseMetadata</code>接口：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">getNumericFunctions（）</code></p>
                              <p>返回驱动程序支持的以逗号分隔的数学函数列表。例如， <code class="codeph">ABS</code> ， <code class="codeph">COS</code> ， <code class="codeph">SQRT</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">getStringFunctions（）</code></p>
                              <p>返回驱动程序支持的逗号分隔的字符串函数列表。例如， <code class="codeph">ASCII</code> ， <code class="codeph">LOCATE</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">getSystemFunctions（）</code></p>
                              <p>返回驱动程序支持的逗号分隔的系统函数列表。例如， <code class="codeph">DATABASE</code> ， <code class="codeph">USER</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">getTimeDateFunctions（）</code></p>
                              <p>返回驱动程序支持的逗号分隔的时间和日期函数列表。例如， <code class="codeph">CURDATE</code> ， <code class="codeph">DAYOFYEAR</code> ， <code class="codeph">HOUR</code> 。</p>
                              <div class="infoboxnote" id="GUID-9F59DD78-4FD3-4451-A27C-53505F842F15__GUID-E998A021-2B5A-4DD7-8BE7-686CB800D1EC">
                                 <p class="notep1">注意：</p>
                                 <p>Oracle JDBC驱动程序支持<code class="codeph">fn</code> ，即function关键字。
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28921"></a><div class="props_rev_3"><a id="GUID-5D371A5B-D7F6-42EB-8C0D-D317F3C53708" name="GUID-5D371A5B-D7F6-42EB-8C0D-D317F3C53708"></a><h4 id="JJDBC-GUID-5D371A5B-D7F6-42EB-8C0D-D317F3C53708" class="sect4"><span class="enumeration_section">A.4.3</span> LIKE转义字符</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e1851" class="indexterm-anchor"></a><a id="d88087e1855" class="indexterm-anchor"></a>字符<code class="codeph">%</code>和<code class="codeph">_</code>在SQL <code class="codeph">LIKE</code>子句中具有特殊含义。您使用<code class="codeph">%</code>来匹配零个或多个字符，使用<code class="codeph">_</code>来匹配一个字符。如果你想在字符串中按字面解释这些字符，那么你在它们前面加上一个特殊的转义字符。例如，如果要使用＆符号（ <code class="codeph">&amp;</code> ）作为转义字符，则在SQL语句中将其标识为：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（）; //从emp表中选择empno列，其中ename以'_'开头ResultSet rset = stmt.executeQuery（“SELECT empno FROM emp WHERE ename LIKE'＆_％'{ESCAPE'＆'}”）; //迭代结果并打印员工编号while（rset.next（））System.out.println（rset.getString（1））;</pre><div class="infoboxnote" id="GUID-5D371A5B-D7F6-42EB-8C0D-D317F3C53708__GUID-BB92CBF9-B537-48F4-A1FC-CCBEFC7A97D5">
                           <p class="notep1">注意：</p>
                           <p>如果要将反斜杠字符（\）用作转义字符，则必须输入两次，即\\。例如：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">ResultSet rset = stmt.executeQuery("SELECT empno FROM emp</code> <code class="codeph">WHERE ename LIKE '\\_%' {escape '\\'}");</code>
</pre></div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-3454411C-5F24-4D46-83A9-5DA0BA704F5D" name="GUID-3454411C-5F24-4D46-83A9-5DA0BA704F5D"></a><h4 id="JJDBC-GUID-3454411C-5F24-4D46-83A9-5DA0BA704F5D" class="sect4"><span class="enumeration_section">A.4.4</span> MATCH_RECOGNIZE条款</h4>
                  <div>
                     <div class="section">
                        <p>的<code class="codeph">?</code> character在Oracle Database <span class="italic">11g</span>及更高版本的<code class="codeph">MATCH_RECOGNIZE</code>子句中用作标记。由于JDBC标准定义了<code class="codeph">?</code> 作为参数标记的字符，JDBC驱动程序和服务器SQL引擎无法区分同一令牌的不同用途。
                        </p>
                        <p>在早期版本的JDBC Driver中，如果要解释<code class="codeph">?</code> 如果字符不是<code class="codeph">MATCH_RECOGNIZE</code>标记而不是参数标记，则必须使用<code class="codeph">Statement</code>而不是<code class="codeph">PreparedStatement</code>并禁用转义处理。但是，从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始，您可以在使用时使用“ <code class="codeph">{\\ ... \\}'</code>语法<code class="codeph">?</code> 字符，以便JDBC驱动程序不将其作为参数标记处理，并允许SQL引擎处理它。以下代码段显示了如何使用“ <code class="codeph">{\\ ... \\}'</code>语法：</p><pre class="oac_no_warn" dir="ltr">String sql =“select T.firstW，T.lastZ ,?“+ //使用参数标记”来自tkpattern_S11“+”MATCH_RECOGNIZE（“+”MEASURES A.c1作为firstW，last（Z.c1）作为lastZ“+”ALL MATCHES“+”{\\ PATTERN（A？X*？Y +？ž？）\\}“+ //使用转义序列”DEFINE“+”X作为X.c2&gt; prev（X.c2），“+”Y作为Y.c2 &lt;prev（Y.c2），“+”Z as Z.c2&gt; prev（Z.c2）“+”）为T“; PreparedStatement ps = conn.prepareStatatement（sql）; ps.setString（1，”test“）; ResultSet rs = ps.executeQuery（）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="JDBC-reference-information.html#GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787">使用嵌入式JDBC转义语法</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28922"></a><div class="props_rev_3"><a id="GUID-B0C6C3C6-9E3F-4428-876C-5C493A9D2624" name="GUID-B0C6C3C6-9E3F-4428-876C-5C493A9D2624"></a><h4 id="JJDBC-GUID-B0C6C3C6-9E3F-4428-876C-5C493A9D2624" class="sect4"><span class="enumeration_section">A.4.5</span>外连接</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e1987" class="indexterm-anchor"></a><a id="d88087e1989" class="indexterm-anchor"></a> Oracle JDBC驱动程序不支持外连接语法。解决方法是使用Oracle外连接语法：</p>
                        <p>代替：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（）; ResultSet rset = stmt.executeQuery（“SELECT ename，dname FROM {OJ dept LEFT OUTER JOIN emp on dept.deptno = emp.deptno} ORDER BY ename”）;</pre><p>使用Oracle SQL语法：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（）; ResultSet rset = stmt.executeQuery（“SELECT ename，dname FROM emp b，dept a WHERE a.deptno = b.deptno（+）ORDER BY ename”）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28923"></a><div class="props_rev_3"><a id="GUID-BE5C683E-0A2F-42D1-AF9B-7854BFAC4D53" name="GUID-BE5C683E-0A2F-42D1-AF9B-7854BFAC4D53"></a><h4 id="JJDBC-GUID-BE5C683E-0A2F-42D1-AF9B-7854BFAC4D53" class="sect4"><span class="enumeration_section">A.4.6</span>函数调用语法</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2027" class="indexterm-anchor"></a><a id="d88087e2031" class="indexterm-anchor"></a> Oracle JDBC驱动程序支持以下过程和函数调用语法：</p>
                        <p>程序调用：</p><pre class="oac_no_warn" dir="ltr">{call <span class="italic">procedure_name</span> （ <span class="italic">argument1</span> ， <span class="italic">argument2</span> ，...）}</pre><p>函数调用：</p><pre class="oac_no_warn" dir="ltr">{？= call <span class="italic">procedure_name</span> （ <span class="italic">argument1</span> ， <span class="italic">argument2</span> ，...）}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28924"></a><div class="props_rev_3"><a id="GUID-65F27495-9D7C-45B1-BE83-CBFC182EC686" name="GUID-65F27495-9D7C-45B1-BE83-CBFC182EC686"></a><h4 id="JJDBC-GUID-65F27495-9D7C-45B1-BE83-CBFC182EC686" class="sect4"><span class="enumeration_section">A.4.7</span> Oracle SQL语法示例的JDBC转义语法</h4>
                  <div>
                     <div class="section">
                        <p>您可以编写一个简单的程序来将JDBC转义语法转换为Oracle SQL语法。以下程序使用JDBC转义语法为函数调用，日期文字，时间文字和时间戳文字输出可比较的Oracle SQL语法。在该计划中， <a id="d88087e2091" class="indexterm-anchor"></a> <code class="codeph">oracle.jdbc.OracleSql</code>类的<code class="codeph">parse()</code>方法执行转换。
                        </p><pre class="oac_no_warn" dir="ltr">public class Foo {static oracle.jdbc。OracleDriver驱动程序=新的oracle.jdbc。一个OracleDriver（）; public static void main（String args []）throws Exception {show（“{call foo（？，？）}“）; 节目 （”{？=呼叫栏（？，？）}“）; show（”{d'1998-10-22'}“）; show（”{t '16：22：34'}“）; show（”{ts'1998-10-22 16:22： 34'}“）;} public static void show（String s）throws Exception {System.out.println（s +”=&gt;“+ driver.processSqlEscapes（s））;}}</pre><p>以下代码是输出可打印类似SQL语法的输出。</p><pre class="oac_no_warn" dir="ltr">{call foo（？，？）}=&gt; BEGIN foo（：1，：2）;结束; {？=呼叫栏（？，？）}=&gt; BEGIN：1：= bar（：2，：3）;结束; {d'1998-10-22'} =&gt; TO_DATE（'1998-10-22'，'YYYY-MM-DD'）{t '16：22：34'} =&gt; TO_DATE（'16：22：34 '，'HH24：MI：SS'）{ts'1998-10-22 16:22:34'} =&gt; TO_TIMESTAMP（'1998-10-22 16:22:34'，'YYYY-MM-DD HH24： MI：SS.FF“）</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28925"></a><div class="props_rev_3"><a id="GUID-E8DF3990-1EB5-4185-989C-06D13740BD01" name="GUID-E8DF3990-1EB5-4185-989C-06D13740BD01"></a><h3 id="JJDBC-GUID-E8DF3990-1EB5-4185-989C-06D13740BD01" class="sect3"><span class="enumeration_section">A.5</span> Oracle JDBC注释和限制</h3>
               <div>
                  <div class="section">
                     <p>下列<a id="d88087e2130" class="indexterm-anchor"></a><a id="d88087e2134" class="indexterm-anchor"></a> Oracle JDBC实现中存在限制，但所有这些限制要么无关紧要，要么具有简单的解决方法。本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-7011D030-6150-4E23-82B3-22BACD77FBDA">CursorName中</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-F159927E-8C74-470E-BFBB-533A2C61718C">JDBC外部加入Escapes</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-BAB18806-5800-4CF8-86CE-AFE5652FD7BD">IEEE 754浮点符合性</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-07453AC2-CFF8-42FA-8107-FE2AACF6AEF9">DatabaseMetaData调用的目录参数</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-229AC112-6C98-4D70-AEC9-A22AC0BDA3BB">SQLWarning类</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-F192A2C5-603E-42BD-A1CD-D7E94857C85E">执行DDL语句</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-reference-information.html#GUID-F9266B56-774F-4419-873E-C5625FE057D7">绑定命名参数</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28926"></a><div class="props_rev_3"><a id="GUID-7011D030-6150-4E23-82B3-22BACD77FBDA" name="GUID-7011D030-6150-4E23-82B3-22BACD77FBDA"></a><h4 id="JJDBC-GUID-7011D030-6150-4E23-82B3-22BACD77FBDA" class="sect4"><span class="enumeration_section">A.5.1</span> CursorName</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2211" class="indexterm-anchor"></a> Oracle JDBC驱动程序不支持<code class="codeph">getCursorName</code>和<code class="codeph">setCursorName</code>方法，因为没有方便的方法将它们映射到Oracle构造。Oracle建议使用<code class="codeph">ROWID</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-extensions.html#GUID-8069D705-A031-469D-855F-53525798F64F">Oracle ROWID类型</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28927"></a><div class="props_rev_3"><a id="GUID-F159927E-8C74-470E-BFBB-533A2C61718C" name="GUID-F159927E-8C74-470E-BFBB-533A2C61718C"></a><h4 id="JJDBC-GUID-F159927E-8C74-470E-BFBB-533A2C61718C" class="sect4"><span class="enumeration_section">A.5.2</span> JDBC外连接转义</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2260" class="indexterm-anchor"></a> Oracle JDBC驱动程序不支持JDBC外连接转义。请改用+使用Oracle SQL语法。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="JDBC-reference-information.html#GUID-DFF83C4A-D0F8-420C-BA66-8681B939B787">使用嵌入式JDBC转义语法</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28929"></a><div class="props_rev_3"><a id="GUID-BAB18806-5800-4CF8-86CE-AFE5652FD7BD" name="GUID-BAB18806-5800-4CF8-86CE-AFE5652FD7BD"></a><h4 id="JJDBC-GUID-BAB18806-5800-4CF8-86CE-AFE5652FD7BD" class="sect4"><span class="enumeration_section">A.5.3</span> IEEE 754浮点符合性</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2301" class="indexterm-anchor"></a><a id="d88087e2307" class="indexterm-anchor"></a><a id="d88087e2309" class="indexterm-anchor"></a> Oracle <code class="codeph">NUMBER</code>类型的算法不符合浮点运算的IEEE 754标准。因此，Oracle执行的计算结果与Java执行的相同计算之间可能存在很小的分歧。
                        </p>
                        <p>Oracle以与十进制算术兼容的格式存储数字，并保证38位十进制数字的精度。它表示零，负无穷大，加上无穷大。对于它表示的每个正数，它表示相同绝对值的负数。</p>
                        <p>它代表10 <sup>-30</sup>和（1 - 10 <sup>-38）</sup>之间的每一个正数* 10 <sup>126</sup>完整38位精度的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28930"></a><div class="props_rev_3"><a id="GUID-07453AC2-CFF8-42FA-8107-FE2AACF6AEF9" name="GUID-07453AC2-CFF8-42FA-8107-FE2AACF6AEF9"></a><h4 id="JJDBC-GUID-07453AC2-CFF8-42FA-8107-FE2AACF6AEF9" class="sect4"><span class="enumeration_section">A.5.4</span> DatabaseMetaData调用的目录参数</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2352" class="indexterm-anchor"></a><a id="d88087e2358" class="indexterm-anchor"></a><a id="d88087e2360" class="indexterm-anchor"></a>某些<code class="codeph">DatabaseMetaData</code>方法定义<code class="codeph">catalog</code>参数。此参数是方法的选择标准之一。Oracle没有多个目录，但它确实有包。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="performance-extensions.html#GUID-15865071-39F2-430F-9EDA-EB34D0B2D560">关于报告DatabaseMetaData TABLE_REMARKS</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28931"></a><div class="props_rev_3"><a id="GUID-229AC112-6C98-4D70-AEC9-A22AC0BDA3BB" name="GUID-229AC112-6C98-4D70-AEC9-A22AC0BDA3BB"></a><h4 id="JJDBC-GUID-229AC112-6C98-4D70-AEC9-A22AC0BDA3BB" class="sect4"><span class="enumeration_section">A.5.5</span> SQLWarning类</h4>
                  <div>
                     <div class="section">
                        <p><a id="d88087e2402" class="indexterm-anchor"></a><a id="d88087e2408" class="indexterm-anchor"></a> <code class="codeph">java.sql.SQLWarning</code>类提供有关数据库访问警告的信息。警告通常包含警告的描述和标识警告的代码。警告以静默方式链接到其方法导致报告的对象。Oracle JDBC驱动程序通常不支持<code class="codeph">SQLWarning</code> 。作为例外，可滚动结果集操作会生成SQL警告，但<code class="codeph">SQLWarning</code>实例是在客户端上创建的，而不是在数据库中创建的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="JDBC-getting-started.html#GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD">关于处理SQL异常</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28932"></a><div class="props_rev_3"><a id="GUID-F192A2C5-603E-42BD-A1CD-D7E94857C85E" name="GUID-F192A2C5-603E-42BD-A1CD-D7E94857C85E"></a><h4 id="JJDBC-GUID-F192A2C5-603E-42BD-A1CD-D7E94857C85E" class="sect4"><span class="enumeration_section">A.5.6</span>执行DDL语句</h4>
                  <div>
                     <div class="section">
                        <p>您必须使用<code class="codeph">Statement</code>对象执行数据定义语言（DDL）语句。如果使用<code class="codeph">PreparedStatements</code>对象或<code class="codeph">CallableStatements</code>对象，则DDL语句仅在第一次执行时生效。如果SQL语句位于语句高速缓存中，则会导致意外行为。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28933"></a><div class="props_rev_3"><a id="GUID-F9266B56-774F-4419-873E-C5625FE057D7" name="GUID-F9266B56-774F-4419-873E-C5625FE057D7"></a><h4 id="JJDBC-GUID-F9266B56-774F-4419-873E-C5625FE057D7" class="sect4"><span class="enumeration_section">A.5.7</span>绑定命名参数</h4>
                  <div>
                     <div class="section">
                        <p>使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法时，不支持按名称绑定。在某些情况下，以前版本的Oracle JDBC驱动程序在使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法时允许按名称绑定语句变量。在以下语句中，命名变量<code class="codeph">EmpId</code>将绑定到整数<code class="codeph">314159</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">PreparedStatement p = conn.prepareStatement（“SELECT name FROM emp WHERE id =：EmpId”）; p.setInt（1,314159）;</pre><p>这种使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法按名称绑定的功能不是JDBC规范的一部分，Oracle也不支持它。JDBC驱动程序可能抛出<code class="codeph">SQLException</code>或产生意外结果。从Oracle Database 10 <span class="italic">g</span> JDBC驱动程序开始，使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">AtName</code>方法支持按名称绑定。
                        </p>
                        <p>在调用<code class="codeph">execute</code>方法之前，驱动程序不会复制绑定值。因此，在调用<code class="codeph">execute</code>方法之前更改绑定值可能会更改绑定值。例如，请考虑以下代码段：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement p; .......日期d =新日期（1181676033917L）; p.setDate（1，d）; d.setTime（0）; p.executeUpdate（）;</pre><p>此代码段在数据库中插入<code class="codeph">Date(0)</code>而不是<code class="codeph">Date(1181676033917L)</code>因为出于性能原因，JDBC驱动程序实现不会复制绑定值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-extensions.html#GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7">接口oracle.jdbc。OracleCallableStatement</a></li>
                           <li><a href="Oracle-extensions.html#GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61">接口oracle.jdbc。OraclePreparedStatement</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html><html id="00027.extensible-optimizer-interface.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>可扩展的优化器接口</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00"></meta>
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96431-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="extensible-indexing-interface.html" title="Previous" type="text/html"></link>
      <link rel="next" href="user-defined-aggregate-functions-interface.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="extensible-indexing-interface.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="user-defined-aggregate-functions-interface.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="reference.html" property="item" typeof="WebPage"><span property="name">参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">可扩展的优化器接口</li>
            </ol>
            <a id="GUID-2B314B88-73C1-49A0-9A74-1AB99B20FA94" name="GUID-2B314B88-73C1-49A0-9A74-1AB99B20FA94"></a><a id="ADDCI4210"></a>
            
            <h2 id="ADDCI-GUID-2B314B88-73C1-49A0-9A74-1AB99B20FA94" class="sect2"><span class="enumeration_chapter">21</span>可扩展优化器接口</h2>
         </header>
         <div class="ind">
            <div>
               <p>考虑构成可扩展优化器接口的函数和过程。</p>
            </div><a id="ADDCI5082"></a><div class="props_rev_3"><a id="GUID-EF80CBFF-6B23-41DB-9777-29E630F47350" name="GUID-EF80CBFF-6B23-41DB-9777-29E630F47350"></a><h3 id="ADDCI-GUID-EF80CBFF-6B23-41DB-9777-29E630F47350" class="sect3"><span class="enumeration_section">21.1</span>可扩展优化器接口</h3>
               <div>
                  <p>可扩展的优化器接口支持使用分区表和域索引。这可以通过两种方式实现：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>其他属性已添加到某些系统定义的对象类型中，这些对象类型是<code class="codeph">ODCIStats</code>接口方法的参数。例如，增强了<code class="codeph">ODCIColInfo</code>类型以添加有关列分区的信息。
                        </p>
                     </li>
                     <li>
                        <p>对于某些<code class="codeph">ODCIStats</code>方法，参数的参数或语义已更改。
                        </p>
                     </li>
                  </ul>
                  <p>请注意，必须更新<code class="codeph">ODCIStats2</code>版本的<code class="codeph">ODCIStats</code>接口的代码， <code class="codeph">ODCIStats2</code>将统计类型与indextype一起使用，该索引类型实现可扩展索引接口的<code class="codeph">ODCIIndex2</code>版本。
                  </p>
               </div>
               <div class="props_rev_3"><a id="GUID-2E4DE8D5-5769-4DF4-9F87-B208EE9D1007" name="GUID-2E4DE8D5-5769-4DF4-9F87-B208EE9D1007"></a><h4 id="ADDCI-GUID-2E4DE8D5-5769-4DF4-9F87-B208EE9D1007" class="sect4"><span class="enumeration_section">21.1.1</span>在可扩展优化器接口中使用统计函数</h4>
                  <div>
                     <div class="section">
                        <p>考虑一下如何使用统计函数的示例。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在模式<code class="codeph">HR</code> ，我们定义以下运算符：</span><div><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR包含绑定（VARCHAR2（4000），VARCHAR2（30））RETURN NUMBER USING Contains_fn; CREATE TYPE stat1（...，STATIC FUNCTION ODCIStatsSelectivity（pred ODCIPredInfo，sel OUT NUMBER，args ODCIArgDescList，start NUMBER，stop NUMBER，doc VARCHAR2（4000），key VARCHAR2（30））return NUMBER，STACTIC FUNCTION ODCIStatsFunctionCost（func ODCIFuncInfo， cost OUT ODCICost，args ODCIArgDescList，doc VARCHAR2（4000），key VARCHAR2（30））返回NUMBER，STATIC FUNCTION ODCIStatsIndexCost（ia ODCIIndexInfo，sel NUMBER，cost OUT ODCICost，qi ODCIQueryInfo，pred ODCIPredInfo，args ODCIArgDescList，start NUMBER，stop NUMBER ，键VARCHAR2（30））返回NUMBER，...）; CREATE TABLE T（恢复VARCHAR2（4000））;在T上创建索引T_resume（简历）INDEXTYPE是indtype;关联统计与函数Contains_fn使用stat1;使用INDEXTYPE indtype使用stat1与SYSTEM MANAGED STORAGE TABLES关联统计数据;</pre></div>
                        </li>
                        <li class="stepexpand"><span>优化器遇到查询</span><div><pre class="oac_no_warn" dir="ltr">SELECT * FROM T WHERE包含（resume，'ORACLE'）= 1，</pre></div>
                        </li>
                        <li class="stepexpand"><span>它通过为<code class="codeph">Contains</code>运算符的功能实现调用用户定义的选择性函数来计算谓词的选择性。在这种情况下，选择性函数是<code class="codeph">stat1.ODCIStatsSelectivity</code> 。它被称为如下：</span><div><pre class="oac_no_warn" dir="ltr"><code class="codeph">STAT1。ODCIStatsSelectivity (</code> <code class="codeph">ODCIPredInfo('HR', 'Contains_fn', NULL, 29),</code> <code class="codeph">sel,</code> <code class="codeph">ODCIArgDescList(</code> <code class="codeph">ODCIArgDesc(ODCIConst.ArgLit,</code> NULL，NULL，NULL，NULL，NULL，NULL）， <code class="codeph">ODCIArgDesc(ODCIConst.ArgLit,</code> NULL，NULL，NULL，NULL，NULL，NULL）， <code class="codeph">ODCIArgDesc(ODCIConst.ArgCol, 'T', 'HR', '"RESUME"', NULL, NULL, NULL),</code> <code class="codeph">ODCIArgDesc(ODCIConst.ArgLit,</code> NULL，NULL，NULL，NULL，NULL，NULL）） <code class="codeph">1,</code> <code class="codeph">1,</code> <code class="codeph">NULL,</code> <code class="codeph">'ORACLE')</code>
</pre></div>
                        </li>
                        <li class="stepexpand"><span>假设选择性函数返回3（百分比）的选择性。在评估域索引时，优化器会调用用户定义的索引成本函数，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">STAT1。ODCIStatsIndexCost（ODCIIndexInfo（'HR'，'T_RESUME'，ODCIColInfoList（ODCIColInfo（'HR'，'T'，'“RESUME”'，NULL，NULL，NULL，0,0,0,0）），NULL，0， 0,0,0），3，cost，NULL，ODCIPredInfo（'HR'，'Contains'，NULL，13），ODCIArgDescList（ODCIArgDesc（ODCIConst。ArgLit，NULL，NULL，NULL，NULL，NULL，NULL），ODCIArgDesc（ODCIConst。ArgLit，NULL，NULL，NULL，NULL，NULL，NULL），ODCIArgDesc（ODCIConst。ArgLit，NULL，NULL，NULL，NULL，NULL，NULL）），1,1，'ORACLE'）</pre></div>
                        </li>
                        <li class="stepexpand"><span>假设优化器决定不使用域索引，因为它太昂贵了。然后，它调用用户定义的成本函数，用于运算符的功能实现，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">STAT1。ODCIStatsFunctionCost（ODCIFuncInfo（'HR'，'Contains_fn'，NULL，1），cost，ODCIArgDescList（ODCIArgDesc（ODCIConst。ArgCol，'T'，'HR'，'“RESUME”'，NULL，NULL，NULL），ODCIArgDesc（ODCIConst。ArgLit，NULL，NULL，NULL，NULL，NULL，NULL）），NULL，'ORACLE'）</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADDCI5084"></a><div class="props_rev_3"><a id="GUID-4538C0C3-FFAF-4E25-B6D4-F136121950C0" name="GUID-4538C0C3-FFAF-4E25-B6D4-F136121950C0"></a><h4 id="ADDCI-GUID-4538C0C3-FFAF-4E25-B6D4-F136121950C0" class="sect4"><span class="enumeration_section">21.1.2解释</span>计划</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>显示<code class="codeph">PLAN_TABLE</code>的<code class="codeph">CPU_COST</code>和<code class="codeph">IO_COST</code>列中域索引的用户定义的CPU和I / O开销。例如，假设我们有一个表<code class="codeph">Emp_tab</code>和一个用户定义的运算符<code class="codeph">Contains</code> 。此外，假设有一个域索引<code class="codeph">EmpResume_indx</code>上<code class="codeph">Resume_col</code>的柱<code class="codeph">Emp_tab</code> ，那的索引类型<code class="codeph">EmpResume_indx</code>支持操作者<code class="codeph">Contains</code> 。然后，查询</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Emp_tab WHERE包含（Resume_col，'Oracle'）= 1</pre><p>可能有以下计划：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-4538C0C3-FFAF-4E25-B6D4-F136121950C0__GUID-A0E58BE4-69F5-4E58-B966-E4996DFDF7CB">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="The following table provides an example of the EXPLAIN PLAN." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d75198e373">操作</th>
                                 <th align="left" valign="bottom" width="15%" id="d75198e377">OPTIONS</th>
                                 <th align="left" valign="bottom" width="27%" id="d75198e380">OBJECT_NAME</th>
                                 <th align="left" valign="bottom" width="18%" id="d75198e383">CPU_COST</th>
                                 <th align="left" valign="bottom" width="17%" id="d75198e386">IO_COST</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d75198e391" headers="d75198e373 "><pre class="oac_no_warn" dir="ltr">选择声明</pre></td>
                                 <td align="left" valign="top" width="15%" headers="d75198e391 d75198e377 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                                 <td align="left" valign="top" width="27%" headers="d75198e391 d75198e380 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                                 <td align="left" valign="top" width="18%" headers="d75198e391 d75198e383 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                                 <td align="left" valign="top" width="17%" headers="d75198e391 d75198e386 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d75198e403" headers="d75198e373 "><pre class="oac_no_warn" dir="ltr">表访问</pre></td>
                                 <td align="left" valign="top" width="15%" headers="d75198e403 d75198e377 "><pre class="oac_no_warn" dir="ltr">通过ROWID</pre></td>
                                 <td align="left" valign="top" width="27%" headers="d75198e403 d75198e380 "><pre class="oac_no_warn" dir="ltr">EMP_TAB</pre></td>
                                 <td align="left" valign="top" width="18%" headers="d75198e403 d75198e383 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                                 <td align="left" valign="top" width="17%" headers="d75198e403 d75198e386 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d75198e417" headers="d75198e373 "><pre class="oac_no_warn" dir="ltr">DOMAIN INDEX</pre></td>
                                 <td align="left" valign="top" width="15%" headers="d75198e417 d75198e377 "><pre class="oac_no_warn" dir="ltr"></pre></td>
                                 <td align="left" valign="top" width="27%" headers="d75198e417 d75198e380 "><pre class="oac_no_warn" dir="ltr">EMPRESUME_INDX</pre></td>
                                 <td align="left" valign="top" width="18%" headers="d75198e417 d75198e383 "><pre class="oac_no_warn" dir="ltr">300</pre></td>
                                 <td align="left" valign="top" width="17%" headers="d75198e417 d75198e386 "><pre class="oac_no_warn" dir="ltr">4</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ADDCI5085"></a><div class="props_rev_3"><a id="GUID-28A4EDA6-19DD-4773-B3B8-1802C3B01E21" name="GUID-28A4EDA6-19DD-4773-B3B8-1802C3B01E21"></a><h4 id="ADDCI-GUID-28A4EDA6-19DD-4773-B3B8-1802C3B01E21" class="sect4"><span class="enumeration_section">21.1.3</span> INDEX提示</h4>
                  <div>
                     <div class="section">
                        <p>索引提示适用于域索引。换句话说，如果可能，索引提示会强制优化程序为用户定义的运算符使用提示索引。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5086"></a><div class="props_rev_3"><a id="GUID-53F41476-C56D-42F9-9442-57612A993026" name="GUID-53F41476-C56D-42F9-9442-57612A993026"></a><h4 id="ADDCI-GUID-53F41476-C56D-42F9-9442-57612A993026" class="sect4"><span class="enumeration_section">21.1.4</span> ORDERED_PREDICATES提示</h4>
                  <div>
                     <div class="section">
                        <p>提示<code class="codeph">ORDERED_PREDICATES</code>强制优化器保留谓词评估的顺序（除了用于索引键的谓词），如SQL DML语句的<code class="codeph">WHERE</code>子句中所指定的那样。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADDCI5088"></a><a id="ADDCI5087"></a><div class="props_rev_3"><a id="GUID-77BE64E1-1EF6-4649-847D-567A72DAB77D" name="GUID-77BE64E1-1EF6-4649-847D-567A72DAB77D"></a><h3 id="ADDCI-GUID-77BE64E1-1EF6-4649-847D-567A72DAB77D" class="sect3"><span class="enumeration_section">21.2</span>用户定义的ODCIStats函数</h3>
               <div>
                  <div class="section">
                     <p>用户定义的<code class="codeph">ODCIStats</code>函数用于表列，函数，包，类型，索引类型或域索引。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-77BE64E1-1EF6-4649-847D-567A72DAB77D__GUID-4DAE6E6B-0196-423F-9E3C-546072D77B50">
                     <p class="titleintable">表21-1用户定义的ODCIStats函数摘要</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="用户定义的ODCIStats函数摘要" width="100%" border="1" summary="Column 1 gives the function name, Column two provides its description" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="42%" id="d75198e620">功能</th>
                              <th align="left" valign="bottom" width="58%" id="d75198e623">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e628" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-866750E9-7193-458B-B29C-6A494094DF6C">ODCIGetInterfaces（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e628 d75198e623 ">
                                 <p>了解用户已实现的<code class="codeph">ODCIStats</code>接口版本。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e640" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87">ODCIStatsCollect（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e640 d75198e623 ">
                                 <p>由<code class="codeph">DBMS_STATS</code>包调用，以收集表，表的分区，索引或索引的分区上的用户定义的统计信息。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e652" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2">ODCIStatsDelete（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e652 d75198e623 ">
                                 <p>删除表，表的分区，索引或索引的分区上的用户定义的统计信息。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e661" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1">ODCIStatsFunctionCost（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e661 d75198e623 ">
                                 <p>计算函数的成本。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e670" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6">ODCIStatsExchangePartition（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e670 d75198e623 ">
                                 <p><code class="codeph">ALTER TABLE EXCHANGE PARTITION ...时交换域索引统计信息<code class="codeph">ALTER TABLE EXCHANGE PARTITION ...发布INCLULDING INDEXES</code>命令。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e682" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777">ODCIStatsIndexCost（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e682 d75198e623 ">
                                 <p>计算域索引扫描的成本。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e691" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3">ODCIStatsSelectivity（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e691 d75198e623 ">
                                 <p>指定谓词的选择性。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e700" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C">ODCIStatsTableFunction（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e700 d75198e623 ">
                                 <p>为表函数和输入游标表达式提供基数统计。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="42%" id="d75198e709" headers="d75198e620 ">
                                 <p><a href="extensible-optimizer-interface.html#GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2">ODCIStatsUpdPartStatistics（）</a></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d75198e709 d75198e623 ">
                                 <p>在分区维护操作期间更新统计信息。修补域索引统计信息。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="ADDCI5090"></a><a id="ADDCI5091"></a><a id="ADDCI5089"></a><div class="props_rev_3"><a id="GUID-866750E9-7193-458B-B29C-6A494094DF6C" name="GUID-866750E9-7193-458B-B29C-6A494094DF6C"></a><h4 id="ADDCI-GUID-866750E9-7193-458B-B29C-6A494094DF6C" class="sect4"><span class="enumeration_section">21.2.1</span> ODCIGetInterfaces（）</h4>
                  <div>
                     <div class="section">
                        <p>服务器调用<code class="codeph">ODCIGetInterfaces</code>以发现用户在用户定义的统计类型的方法中实现了哪个版本的<code class="codeph">ODCIStats</code>接口。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-866750E9-7193-458B-B29C-6A494094DF6C__GUID-69121109-0C5A-4B78-A2BA-FB430E918DF1">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">函数ODCIGetInterfaces（ifclist OUT ODCIObjectList）返回数字;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-866750E9-7193-458B-B29C-6A494094DF6C__GUID-819AE6D9-3271-4EED-AF67-2C3B59346622">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="17%" id="d75198e795">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e798">进出</th>
                                 <th align="left" valign="bottom" width="72%" id="d75198e801">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="17%" id="d75198e806" headers="d75198e795 "><pre class="oac_no_warn" dir="ltr">ifclist</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e806 d75198e798 "><pre class="oac_no_warn" dir="ltr">OUT</pre></td>
                                 <td align="left" valign="top" width="72%" headers="d75198e806 d75198e801 ">
                                    <p>统计类型实现的<code class="codeph">ODCIStats</code>接口版本。该值应为<code class="codeph">SYS.ODCISTATS2</code> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-866750E9-7193-458B-B29C-6A494094DF6C__GUID-292C20CE-163A-4BCB-99E3-E8D10285E604">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code>的成功， <code class="codeph">ODCIConst.否则会Error</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5094"></a><a id="ADDCI5095"></a><a id="ADDCI5093"></a><div class="props_rev_3"><a id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87" name="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87"></a><h4 id="ADDCI-GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87" class="sect4"><span class="enumeration_section">21.2.2</span> ODCIStatsCollect（）</h4>
                  <div>
                     <div class="section">
                        <p>由<code class="codeph">DBMS_STATS</code>包调用以收集用户定义的统计信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87__GUID-56AAA2E0-2EFC-4EF9-9B79-FBAA4E23E511">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 has lists the version of a function and column 2 gives its description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="41%" id="d75198e901">句法</th>
                                 <th align="left" valign="bottom" width="59%" id="d75198e904">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d75198e909" headers="d75198e901 "><pre class="oac_no_warn" dir="ltr">FUNCTION ODCIStatsCollect（col ODCIColInfo，options ODCIStatsOptions，statistics OUT RAW，env ODCIEnv）返回NUMBER;</pre></td>
                                 <td align="left" valign="top" width="59%" headers="d75198e909 d75198e904 ">
                                    <p>由<code class="codeph">DBMS_STATS</code>包调用，以收集表或表的分区上的用户定义的统计信息。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d75198e919" headers="d75198e901 "><pre class="oac_no_warn" dir="ltr">FUNCTION ODCIStatsCollect（ia ODCIIndexInfo，options ODCIStatsOptions，statistics OUT RAW，env ODCIEnv）返回NUMBER;</pre></td>
                                 <td align="left" valign="top" width="59%" headers="d75198e919 d75198e904 ">
                                    <p>被调用以在索引或索引的分区上收集用户定义的统计信息。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87__GUID-1C66368D-E893-40B3-897A-EA2EF13D0B10">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d75198e934">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e937">进出</th>
                                 <th align="left" valign="bottom" width="70%" id="d75198e940">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d75198e945" headers="d75198e934 ">
                                    <p><code class="codeph">关口</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e945 d75198e937 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="70%" headers="d75198e945 d75198e940 ">
                                    <p>正在收集统计信息的列</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d75198e956" headers="d75198e934 ">
                                    <p><code class="codeph">选项</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e956 d75198e937 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="70%" headers="d75198e956 d75198e940 ">
                                    <p>传递给<code class="codeph">DBMS_STATS</code>选项</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d75198e969" headers="d75198e934 ">
                                    <p><code class="codeph">统计</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e969 d75198e937 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="70%" headers="d75198e969 d75198e940 ">
                                    <p>收集用户定义的统计信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d75198e980" headers="d75198e934 ">
                                    <p>ENV</p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e980 d75198e937 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="70%" headers="d75198e980 d75198e940 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d75198e990" headers="d75198e934 ">
                                    <p><code class="codeph">IA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e990 d75198e937 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="70%" headers="d75198e990 d75198e940 ">
                                    <p>正在收集统计信息的域索引</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87__GUID-87986909-2531-467D-A37A-A083EC43C430">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>该函数返回<code class="codeph">ODCIConst.Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告。</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87__GUID-ED815DD9-7364-4C66-AD06-6172DBCB6E01">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>此函数应实现为<code class="codeph">STATIC</code>类型方法。
                              </p>
                           </li>
                           <li>
                              <p>如果仅为一个分区收集统计信息，则使用分区的名称填充<code class="codeph">ODCIColInfo</code>类型中的<code class="codeph">TablePartition</code>字段。否则（如果必须为所有分区或整个表收集统计信息），则<code class="codeph">TablePartition</code>字段为空。
                              </p>
                           </li>
                           <li>
                              <p>如果执行<code class="codeph">DBMS_STATS</code>包方法以收集分区表上的用户定义的统计信息，则进行<code class="codeph">n+1</code> <code class="codeph">ODCIStatsCollect</code>调用，其中<code class="codeph">n</code>是表中的分区数。使用分区名称和<code class="codeph">ODCIColInfo</code>填充<code class="codeph">TablePartition</code>中的<code class="codeph">TablePartition</code>属性进行前<code class="codeph">n</code>调用<code class="codeph">ODCIStatsOptions.CallProperty</code>设置为<code class="codeph">IntermediateCall</code> 。最后一次调用是将<code class="codeph">ODCIEnv.CallPropertyflag</code>设置为<code class="codeph">FinalCall</code>以允许您收集整个表的聚合统计信息。
                              </p>
                           </li>
                           <li>
                              <p>如果仅为表的一个分区收集用户定义的统计信息，则进行两次<code class="codeph">ODCIStatsCollect</code>调用。在第一个中，您应该收集分区的统计信息。对于这个调用， <code class="codeph">TablePartition</code>的属性<code class="codeph">ODCIColInfo</code>结构填充和<code class="codeph">ODCIEnv.CallProperty</code>设置为<code class="codeph">FirstCall</code> 。
                              </p>
                           </li>
                           <li>
                              <p>在第二个调用中，您可以根据为分区收集的新统计信息更新表的聚合统计信息。在此调用中， <code class="codeph">ODCIEnv.CallPropertyflag</code>设置为<code class="codeph">FinalCall</code>以指示它是第二次调用。在两个调用中都使用分区名称填充<code class="codeph">ODCIColInfo.TablePartition</code> 。
                              </p>
                           </li>
                           <li>
                              <p>对于<a href="extensible-optimizer-interface.html#GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87">非分</a>区域索引，分区域索引和域索引中的分区， <a href="extensible-optimizer-interface.html#GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87">ODCIStatsCollect（）</a>方法仅调用一次。如果仅为域索引中的一个分区收集统计信息，则使用分区号填充<code class="codeph">ODCIIndexInfo</code>类型中的<code class="codeph">IndexPartitionNum</code>字段。否则， <code class="codeph">IndexPartitionNum</code>字段为<code class="codeph">null</code> 。
                              </p>
                           </li>
                           <li>
                              <p>由于统计信息<code class="codeph">OUT RAW</code>参数的统计信息未在新接口中使用，因此磁带开发人员应将用户定义的统计信息结果存储在某些用户定义的表中。
                              </p>
                           </li>
                           <li>
                              <p>如果非分区域索引正在进行<code class="codeph">ANALYZE</code> ，则用户应收集域索引的统计信息。
                              </p>
                           </li>
                           <li>
                              <p>如果分区域索引正在<code class="codeph">ANALYZE</code> ，</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobalAndPartition</code>表示用户应收集域索引中所有分区的统计信息，然后根据为所有分区收集的统计信息汇总域索引的统计信息</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobal</code>意味着用户应该从所有域索引分区的统计信息中聚合域索引统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsPartition</code>表示用户应收集域索引中所有索引分区的统计信息。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果只有一个域索引的分区正在进行<code class="codeph">ANALYZE</code> ，</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobalAndPartition</code>表示用户应收集单个索引分区的统计信息，然后根据所有分区的统计信息聚合域索引的统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobal</code>意味着用户应该从所有索引分区的统计信息中聚合域索引统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsPartition</code>表示用户应收集单个索引分区的统计信息。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>请注意，当<code class="codeph">ODCIEnv.CallProperty = StatsGlobalAndPartition</code>或<code class="codeph">StatsGlobal</code> ，用户应聚合域索引的统计信息，具体取决于为其他索引分区收集的统计信息的可用性。如果所有索引分区的统计信息都可用，请汇总这些统计信息。如果缺少索引分区的任何统计信息，则不执行任何操作。
                              </p>
                           </li>
                           <li>
                              <p>要正确地收集本地系统管理域索引的统计， <code class="codeph">IndexInfoFlags</code>和<code class="codeph">IndexPartition</code>在田里<code class="codeph">ODCIIndexInfo</code>参数和<code class="codeph">CallProperty</code>在<code class="codeph">ODCIEnv</code>参数必须进行选择。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCIIndexInfo.IndexPartition</code>的值可用于确定是否需要为所有索引分区或子分区收集统计信息。选择以下标志以确定统计信息收集的分区级别。
                              </p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果<code class="codeph">ODCIConst.SubPartn</code>和<code class="codeph">ODCIConst.设置CompPartn</code> ，然后需要为单个子分区收集统计信息。
                                    </p>
                                    <div class="infoboxnote" id="GUID-227ABB3C-6218-4AA9-BC1C-D963EE800D87__GUID-6D3402CE-AF16-41C3-B343-93A6CFB8F654">
                                       <p class="notep1">注意：</p>
                                       <p><code class="codeph">ODCIConst.如果未设置<code class="codeph">ODCIIndexInfo.IndexPartition</code>则永远不会设置SubPartn</code> 。
                                       </p>
                                    </div>
                                 </li>
                                 <li>
                                    <p>如果<code class="codeph">ODCIConst.CompPartn</code>已设置，但<code class="codeph">ODCIConst.SubPartn</code>未设置;然后需要为复合分区的所有子分区和复合分区本身收集统计信息。如果未设置<code class="codeph">ODCIIndexInfo.IndexPartition</code> ，则对索引的所有复合分区以相同方式收集统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果既不是<code class="codeph">ODCIConst.CompPartn</code>也不是<code class="codeph">ODCIConst.设置SubPartn</code> ，然后索引不是复合分区，需要为指定的分区收集统计信息。如果未设置<code class="codeph">ODCIIndexInfo.IndexPartition</code> ，则会收集所有分区的统计信息。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5097"></a><a id="ADDCI5098"></a><a id="ADDCI5096"></a><div class="props_rev_3"><a id="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2" name="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2"></a><h4 id="ADDCI-GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2" class="sect4"><span class="enumeration_section">21.2.3</span> ODCIStatsDelete（）</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ODCIStatsDelete</code>以删除用户定义的统计信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2__GUID-D553F464-5495-44C0-9B16-113EBBB45FAB">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 has lists the version of a function and column 2 gives its description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="39%" id="d75198e1325">句法</th>
                                 <th align="left" valign="bottom" width="61%" id="d75198e1328">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d75198e1333" headers="d75198e1325 "><pre class="oac_no_warn" dir="ltr">功能ODCIStatsDelete（col ODCIColInfo，统计OUT OUTW，env ODCIEnv）返回NUMBER;</pre></td>
                                 <td align="left" valign="top" width="61%" headers="d75198e1333 d75198e1328 ">
                                    <p>删除表或表分区上的用户定义统计信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d75198e1340" headers="d75198e1325 "><pre class="oac_no_warn" dir="ltr">功能ODCIStatsDelete（ia ODCIIndexInfo，统计OUT RAW，env ODCIEnv）返回NUMBER;</pre></td>
                                 <td align="left" valign="top" width="61%" headers="d75198e1340 d75198e1328 ">
                                    <p>删除索引或索引分区上的用户定义统计信息。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2__GUID-7CF81EA1-350B-4618-B1D1-6576A1A38597">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e1355">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e1358">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e1361">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1366" headers="d75198e1355 ">
                                    <p><code class="codeph">关口</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1366 d75198e1358 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1366 d75198e1361 ">
                                    <p>要删除统计信息的列</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1377" headers="d75198e1355 ">
                                    <p><code class="codeph">统计</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1377 d75198e1358 "><pre class="oac_no_warn" dir="ltr">OUT</pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1377 d75198e1361 ">
                                    <p>包含分区表或索引的表级聚合统计信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1388" headers="d75198e1355 ">
                                    <p><code class="codeph">ENV</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1388 d75198e1358 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1388 d75198e1361 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1399" headers="d75198e1355 ">
                                    <p><code class="codeph">IA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1399 d75198e1358 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1399 d75198e1361 ">
                                    <p>删除统计信息的域索引</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2__GUID-5B046258-EBCB-48D5-874D-940B7290C102">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告。</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2__GUID-6C0D440E-12AD-4E9A-A9A0-53F9A7FB6BE0">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>此函数应实现为<code class="codeph">STATIC</code>方法。
                              </p>
                           </li>
                           <li>
                              <p>为非分区表调用该函数时，将忽略<code class="codeph">ODCIStatsDelete</code>接口中的<code class="codeph">statistics</code>参数。
                              </p>
                           </li>
                           <li>
                              <p>如果正在为分区表删除统计信息，则<code class="codeph">ODCIStatsDelete</code>被调用<code class="codeph">n+1</code>次。前<code class="codeph">n</code>调用是在<code class="codeph">ODCIColInfo</code>结构中填充分区名称，并将<code class="codeph">ODCIEnv.CallProperty</code>设置为<code class="codeph">IntermediateCall</code> 。最后一次调用是将<code class="codeph">ODCIEnv.CallProperty</code>设置为<code class="codeph">FinalCall</code> 。
                              </p>
                           </li>
                           <li>
                              <p>在第一次调用中，删除特定分区的统计信息;并在最后一次调用中删除或清理为保存已删除表的统计信息而创建的任何结构。在最后一次调用中， <code class="codeph">ODCIColInfo.TablePartition</code>设置为null。在第一次调用中，填写<code class="codeph">TablePartition</code>字段。
                              </p>
                           </li>
                           <li>
                              <p>如果仅为一个分区删除统计信息并且<code class="codeph">_minimal_stats_aggregation</code>参数设置为<code class="codeph">FALSE</code> ，则进行两次<code class="codeph">ODCIStatsDelete</code>调用。在每次调用中， <code class="codeph">ODCIColInfo.TablePartition</code>都使用分区名称填充。在第一次调用时，删除为该分区收集的任何用户定义的统计信息。在第二次调用时，更新表的聚合统计信息。
                              </p>
                           </li>
                           <li>
                              <p>如果正在为一个分区删除统计信息并且<code class="codeph">_minimal_stats_aggregation</code>设置为<code class="codeph">TRUE</code> ，则<code class="codeph">ODCIStatsDelete</code>仅被调用为删除为该分区收集的任何用户定义的统计信息。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">_minimal_stats_aggregation</code>的初始值为<code class="codeph">TRUE</code> 。</p>
                           </li>
                           <li>
                              <p>对于<a href="extensible-optimizer-interface.html#GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2">非分</a>区域索引，分区域索引或索引分区， <a href="extensible-optimizer-interface.html#GUID-294738F4-65B1-4272-BBD6-686F2E38B9C2">ODCIStatsDelete（）</a>方法仅调用一次。
                              </p>
                           </li>
                           <li>
                              <p>如果正在删除非分区域索引的统计信息，则用户应删除域索引的用户定义统计信息。</p>
                           </li>
                           <li>
                              <p>如果正在删除分区域索引的统计信息，则用户应删除域索引的聚合统计信息，并可选择删除所有域索引分区的用户定义统计信息，具体取决于<code class="codeph">ODCIEnv.CallProperty</code> <code class="codeph">Options</code> ：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobalAndPartition</code>表示用户应删除所有域索引分区的统计信息和域索引的聚合统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsGlobal</code>意味着用户应删除域索引的聚合统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ODCIEnv.CallProperty = StatsPartition</code>无效选项。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果仅为索引的一个分区删除统计信息，则用户应删除索引分区的用户定义统计信息。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5100"></a><a id="ADDCI5101"></a><a id="ADDCI5102"></a><a id="ADDCI5099"></a><div class="props_rev_3"><a id="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1" name="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1"></a><h4 id="ADDCI-GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1" class="sect4"><span class="enumeration_section">21.2.4</span> ODCIStatsFunctionCost（）</h4>
                  <div>
                     <div class="section">
                        <p>计算函数的成本。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1__GUID-B8F15675-8916-4CE2-82E5-C5651AF103AE">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">FUNCTION ODCIStatsFunctionCost（func ODCIFuncInfo，cost OUT ODCICost，args ODCIArgDescList， <span class="italic">list</span> ，env ODCIEnv）返回NUMBER;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1__GUID-897555F1-7343-4C0C-AF2A-A96470C2EC61">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e1631">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e1634">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e1637">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1642" headers="d75198e1631 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">FUNC</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1642 d75198e1634 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1642 d75198e1637 ">
                                    <p>正在计算成本的函数或类型方法</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1653" headers="d75198e1631 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">成本</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1653 d75198e1634 "><pre class="oac_no_warn" dir="ltr">OUT</pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1653 d75198e1637 ">
                                    <p>计算成本（必须是正整数）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1664" headers="d75198e1631 "><pre class="oac_no_warn" dir="ltr">ARGS</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1664 d75198e1634 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1664 d75198e1637 ">
                                    <p>调用函数或类型方法的实际参数的描述符。如果函数有<span class="italic">n个</span>参数，则<code class="codeph">args</code>数组包含<span class="italic">n个</span>元素，每个元素描述函数或类型方法的实际参数</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1683" headers="d75198e1631 "><pre class="oac_no_warn" dir="ltr"><span class="italic"><code class="codeph">名单</code></span></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1683 d75198e1634 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1683 d75198e1637 ">
                                    <p>函数或类型方法的实际参数列表;函数或类型方法中每个参数的数量，位置和类型必须相同。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1695" headers="d75198e1631 "><pre class="oac_no_warn" dir="ltr">ENV</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1695 d75198e1634 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1695 d75198e1637 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1__GUID-3457F817-BCD9-4A63-BDC4-04FE0C027C87">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告。</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B13AA56D-ABAF-431A-BAED-006B8331DCE1__GUID-0BF536EA-E5E0-4F30-82FC-66F2DC717F4B">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此函数应实现为静态类型方法。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5104"></a><a id="ADDCI5105"></a><a id="ADDCI5106"></a><a id="ADDCI5103"></a><div class="props_rev_3"><a id="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6" name="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6"></a><h4 id="ADDCI-GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6" class="sect4"><span class="enumeration_section">21.2.5</span> ODCIStatsExchangePartition（）</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ALTER TABLE EXCHANGE PARTITION ...时交换域索引统计信息<code class="codeph">ALTER TABLE EXCHANGE PARTITION ...发布INCLULDING INDEXES</code>命令。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6__GUID-8915CEE9-65AD-4CBE-BFD7-D6CEF0E0A0E1">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">功能ODCIStatsExchangePartition（ia ODCIIndexInfo，ia1 ODCIIndexInfo，env ODCIEnv）返回NUMBER;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6__GUID-7A85A8AF-0C24-4B2A-9677-7DA9056BC1E9">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e1801">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e1804">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e1807">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1812" headers="d75198e1801 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">IA</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1812 d75198e1804 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1812 d75198e1807 ">
                                    <p>有关必须交换的索引分区的信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1823" headers="d75198e1801 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">IA1</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1823 d75198e1804 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1823 d75198e1807 ">
                                    <p>有关与其交换分区的非分区表的索引的信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1834" headers="d75198e1801 "><pre class="oac_no_warn" dir="ltr">ENV</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1834 d75198e1804 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1834 d75198e1807 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6__GUID-7C4EB513-CD2B-4C78-83C1-D98B89DCE5BB">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6FE88952-A3B9-40B3-8A49-BF0D548C7EE6__GUID-7CFADE52-722E-4B05-A080-9FD31CFABF32">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>此方法应实现为<code class="codeph">STATIC</code>类型。
                              </p>
                           </li>
                           <li>
                              <p>此方法应该能够将与域索引分区关联的统计信息转换为与非分区域索引关联的统计信息，反之亦然。如果其中一个索引或索引分区缺少统计信息，则用户应该能够删除这些统计信息。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5108"></a><a id="ADDCI5109"></a><a id="ADDCI5110"></a><a id="ADDCI5107"></a><div class="props_rev_3"><a id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777" name="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777"></a><h4 id="ADDCI-GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777" class="sect4"><span class="enumeration_section">21.2.6</span> ODCIStatsIndexCost（）</h4>
                  <div>
                     <div class="section">
                        <p>计算域索引扫描的成本，扫描整个索引或扫描一个或多个索引分区（如果已构建本地域索引）。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777__GUID-90BCAE76-0BBC-414D-B878-8D650764EE03">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">FUNCTION ODCIStatsIndexCost（ia ODCIIndexInfo，sel NUMBER，cost OUT ODCICost，qi ODCIQueryInfo，pred ODCIPredInfo，args ODCIArgDescList，start <span class="italic">operator_return_type</span> ，stop <span class="italic">operator_return_type</span> ， <span class="italic">list</span> ，env ODCIEnv）return NUMBER;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777__GUID-31D25B12-8FBC-4C5E-B78D-85F4CF292936">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e1955">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e1958">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e1961">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1966" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">IA</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1966 d75198e1958 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1966 d75198e1961 ">
                                    <p>正在收集统计信息的域索引</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1977" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">SEL</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1977 d75198e1958 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1977 d75198e1961 ">
                                    <p>用户计算的谓词选择性</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1988" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">成本</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1988 d75198e1958 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1988 d75198e1961 ">
                                    <p>计算成本（必须是正整数）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e1999" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr"><code class="codeph">齐</code></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e1999 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e1999 d75198e1961 ">
                                    <p>有关查询的信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2010" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr">预计值</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2010 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2010 d75198e1961 ">
                                    <p>有关谓词的信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2020" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr">ARGS</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2020 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2020 d75198e1961 ">
                                    <p>调用运算符的<code class="codeph">start</code> ， <code class="codeph">stop</code>和实际值参数的描述符。如果运算符有<span class="italic">n个</span>参数，则<code class="codeph">args</code>数组包含<span class="italic">n + 1个</span>元素，第一个元素描述起始值，第二个元素描述停止值，剩余的<span class="italic">n-1个</span>元素描述运算符的实际值参数（即，第一个之后的论据）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2049" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr">开始</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2049 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2049 d75198e1961 ">
                                    <p>运算符的下界（例如，2表示谓词<code class="codeph">fn(...)</code> &gt; <code class="codeph">2)</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2064" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr">停</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2064 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2064 d75198e1961 ">
                                    <p>运算符的上限（例如，5表示谓词<code class="codeph">fn(...)</code> <code class="codeph">&lt;</code> <code class="codeph">5</code> ）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2083" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr"><span class="italic"><code class="codeph">名单</code></span></pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2083 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2083 d75198e1961 ">
                                    <p>运营商的实际参数清单（不包括第一个）;每个参数的数量，位置和类型必须与运算符中的数字，位置和类型相同。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2095" headers="d75198e1955 "><pre class="oac_no_warn" dir="ltr">ENV</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2095 d75198e1958 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2095 d75198e1961 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777__GUID-4079378C-3CFE-4ADC-AA35-6F4249C62B29">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777__GUID-A49E4397-85BB-4611-8E7B-8A899EBB0886">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于查询中的每个表，优化程序使用分区修剪来确定可以访问的分区范围。这些分区称为<span class="bold">有趣的分区</span> 。表的一组有趣的分区也是该表上所有域索引的有趣分区集。域索引的开销可能取决于有趣分区的集合，因此优化器将一个有趣的索引分区列表传递给<code class="codeph">args</code>参数中的<code class="codeph">ODCIStatsIndexCost</code> （此参数的类型， <code class="codeph">ODCIArgDescList</code> ，是<code class="codeph">ODCIArgDesc</code>参数描述符类型的列表）那些是列的参数。对于<code class="codeph">ODCIStatsIndexCost</code>区域索引或者无法进行分区修剪的情况，不会将分区列表传递给<code class="codeph">ODCIStatsIndexCost</code> ，您应该假定访问整个索引。
                              </p>
                           </li>
                           <li>
                              <p>域索引键可以包含多个列参数（例如，来自连接顺序中较早的其他表的索引列和列参数）。对于索引键中出现的每个列， <code class="codeph">args</code>参数包含表的有趣分区列表。例如，对于索引键</p><pre class="oac_no_warn" dir="ltr">op（T1.c1，T2.c2）= 1</pre><p>对于表<code class="codeph">T1</code>和<code class="codeph">T2</code>如果它们被分区并且存在分区修剪，则优化器会传递一组有趣的分区。
                              </p>
                           </li>
                           <li>
                              <p>此函数应实现为静态类型方法。</p>
                           </li>
                           <li>
                              <p>对于分区或非分区表上的查询，只对<code class="codeph">ODCIStatsIndexCost()</code>函数进行一次调用。对于分区表的查询，在<code class="codeph">ODCIStatsIndexCost()</code>函数中传递附加信息。请注意，传递给<code class="codeph">ODCIStatsIndexCost()</code>的列表中的某些分区可能实际上不会被查询访问。有趣分区列表主要用于排除绝对不被访问的分区。
                              </p>
                           </li>
                           <li>
                              <p>调用<code class="codeph">ODCIStatsIndexCost()</code>函数时，用户可以在成本属性的<code class="codeph">IndexCostInfo</code>字段中填写字符串，以提供可能有用的任何其他信息。当执行计划选择域索引扫描时，字符串（最多255个字符）显示在<code class="codeph">EXPLAIN PLAN</code>输出的<code class="codeph">OPTIONS</code>列中。
                              </p>
                           </li>
                           <li>
                              <p>实现此功能的用户必须在<code class="codeph">ODCIGetInterfaces()</code>调用中返回<code class="codeph">'SYS.ODCISTATS2'</code> 。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777__GUID-A25F65A1-01CB-4C20-8582-A26EAEEE1E7E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="extensible-optimizer-interface.html#GUID-866750E9-7193-458B-B29C-6A494094DF6C">ODCIGetInterfaces（）</a></p>
                              </li>
                              <li>
                                 <p><a href="extensible-optimizer-interface.html#GUID-158EC3A8-CB48-48B2-9405-198BA0FDD777">ODCIStatsIndexCost（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5112"></a><a id="ADDCI5113"></a><a id="ADDCI5114"></a><a id="ADDCI5111"></a><div class="props_rev_3"><a id="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3" name="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3"></a><h4 id="ADDCI-GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3" class="sect4"><span class="enumeration_section">21.2.7</span> ODCIStatsSelectivity（）</h4>
                  <div>
                     <div class="section">
                        <p>指定谓词的选择性。涉及单个表中列的谓词的选择性是该表满足谓词的行的分数。对于涉及来自多个表的列的谓词（例如，连接谓词），应该将选择性计算为这些表的笛卡尔积中的行的一部分。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3__GUID-4651A5EE-712C-4E31-A41D-C2053DBB8FD2">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">FUNCTION ODCIStatsSelectivity（pred ODCIPredInfo，sel OUT NUMBER，args ODCIArgDescList，start <span class="italic">function_return_type</span> ，stop <span class="italic">function_return_type</span> ， <span class="italic">list</span> ，env ODCIEnv）返回NUMBER;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3__GUID-494B36B1-4C1B-4DB5-AEBC-4768A2410335">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e2293">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e2296">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e2299">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2304" headers="d75198e2293 ">
                                    <p><code class="codeph">预计值</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2304 d75198e2296 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2304 d75198e2299 ">
                                    <p>正在计算选择性的谓词</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2315" headers="d75198e2293 ">
                                    <p><code class="codeph">SEL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2315 d75198e2296 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2315 d75198e2299 ">
                                    <p>计算的选择性表示为（和包括）0和100之间的数字，表示百分比。</p>
                                    <p>优化程序将小于0或大于100的数字忽略为无效值。如果计算的选择性小于0.5％，则可以在输出参数<code class="codeph">sel</code>返回值0。选择性为0并不意味着将删除谓词</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2331" headers="d75198e2293 ">
                                    <p><code class="codeph">ARGS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2331 d75198e2296 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2331 d75198e2299 ">
                                    <p><code class="codeph">start</code> ， <code class="codeph">stop</code>和实际参数的描述符，用于调用函数，类型方法或运算符。如果函数有<span class="italic">n个</span>参数，则<code class="codeph">args</code>数组包含<span class="italic">n + 2个</span>元素，第一个元素描述起始值，第二个元素描述停止值，剩下的<span class="italic">n个</span>元素描述函数，方法或运算符的实际参数</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2361" headers="d75198e2293 ">
                                    <p><code class="codeph">开始</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2361 d75198e2296 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2361 d75198e2299 ">
                                    <p>函数的下界（例如，2表示谓词<code class="codeph">fn(...)</code> <code class="codeph">&gt;</code> <code class="codeph">2</code> ）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2381" headers="d75198e2293 ">
                                    <p><code class="codeph">停</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2381 d75198e2296 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2381 d75198e2299 ">
                                    <p>函数的上界（例如，5表示谓词<code class="codeph">fn(...)</code> <code class="codeph">&lt;</code> <code class="codeph">5)</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2400" headers="d75198e2293 ">
                                    <p><span class="italic"><code class="codeph">名单</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2400 d75198e2296 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2400 d75198e2299 ">
                                    <p>函数或类型方法的实际参数列表;每个参数的数量，位置和类型必须与函数，类型方法或运算符中的数字，位置和类型相同。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2412" headers="d75198e2293 ">
                                    <p><code class="codeph">ENV</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2412 d75198e2296 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2412 d75198e2299 ">
                                    <p>包含有关执行例程的环境的一般信息</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3__GUID-09C17EBC-BB70-422F-A7FC-E7F993E0F064">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告</code></p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4CEECA5F-099A-4558-A50C-FD856A814CF3__GUID-9C7C6628-0D2B-42F7-8BAD-EBFD624947BF">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>与在<code class="codeph">ODCIStatsIndexCost</code> ，args参数包含表的<span class="italic">有趣</span>分区列表，这些表的列在谓词中引用，必须为其计算选择性。这些有趣的分区是分区修剪无法消除的分区，作为可能被访问的候选者。只有在发生分区修剪时才会将有趣的分区集传递给函数（换句话说，有趣的分区是所有分区的严格子集）。
                              </p>
                           </li>
                           <li>
                              <p>例如，调用<code class="codeph">ODCIStatsSelectivity</code>以计算谓词的选择性时：</p><pre class="oac_no_warn" dir="ltr">f（T1.c1，T2.c2）&gt; 4</pre><p>如果可以进行分区修剪，优化器会传递表<code class="codeph">T1</code>的有趣分区列表（在列<code class="codeph">T1.c1</code>的参数描述符中）;类似于表<code class="codeph">T2</code> 。
                              </p>
                              <p>如果谓词包含来自多个表的列，则此信息由标记位<code class="codeph">PredMultiTable</code>指示，该位在<code class="codeph">pred</code>参数的<code class="codeph">Flags</code>属性中设置。
                              </p>
                           </li>
                           <li>
                              <p>此函数应实现为静态类型方法。</p>
                           </li>
                           <li>
                              <p>实现此接口的用户必须在<code class="codeph">ODCIGetInterfaces</code>调用中返回<code class="codeph">'SYS.ODCISTATS2'</code> 。
                              </p>
                           </li>
                           <li>
                              <p>涉及单个表中列的谓词的选择性是该表满足谓词的行的分数。对于涉及来自多个表的列的谓词（例如，连接谓词），应该将选择性计算为这些表的笛卡尔积中的行的一部分。对于具有分区修剪的表，选择性应相对于所涉及的表的感兴趣分区的基数来表示。</p>
                              <p>涉及分区表上的列的谓词的选择性是相对于感兴趣的分区中的行计算的。因此，谓词的选择性</p><pre class="oac_no_warn" dir="ltr">g（T1.c1）&lt;5</pre><p>是满足此谓词的有趣分区集（或者如果不可能进行分区修剪，则为所有分区）中的行百分比。对于具有多个表的列的谓词，选择性必须相对于表的笛卡尔积中的行数。</p>
                           </li>
                           <li>
                              <p>例如，考虑谓词：</p><pre class="oac_no_warn" dir="ltr">f（T1.c1，T2.c2）&gt; 4</pre><p>假设感兴趣的分区中的行数对于<code class="codeph">T1</code>为1000，对于<code class="codeph">T2</code>为5000。该谓词的选择性必须表示为满足谓词的<code class="codeph">T1</code>和<code class="codeph">T2</code>的笛卡尔乘积中5,000,000行的百分比。
                              </p>
                           </li>
                           <li>
                              <p>如果谓词包含来自多个表的列，则此信息由<code class="codeph">pred</code>参数的<code class="codeph">Flags</code>属性中设置的标志位<code class="codeph">PredMultiTable</code>指示。
                              </p>
                           </li>
                           <li>
                              <p>如果基于单表谓词或连接顺序中较早的其他连接减少了表的基数（和其他统计数据），则相对于所涉及的表的基数表示的选择性可能仅是真实选择性的近似值。然而，对于大多数应用来说，这种对真实选择性的近似应该是可接受的。</p>
                           </li>
                           <li>
                              <p>对分区或非分区表的查询只进行一次<code class="codeph">ODCIStatsSelectivity</code>函数调用。对分区表进行查询时，在调用<code class="codeph">ODCIStatsSelectivity</code>函数时会传递其他信息。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5116"></a><a id="ADDCI5117"></a><a id="ADDCI5115"></a><div class="props_rev_3"><a id="GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C" name="GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C"></a><h4 id="ADDCI-GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C" class="sect4"><span class="enumeration_section">21.2.8</span> ODCIStatsTableFunction（）</h4>
                  <div>
                     <div class="section">
                        <p>此函数为表函数和输入游标表达式提供基数统计。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C__GUID-FF668DEA-DDDB-4E6A-98A5-17FA4425903B">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">静态函数ODCIStatsTableFunction（func IN SYS.ODCIFuncInfo，outStats OUT SYS.ODCITabFuncStats，argDesc IN SYS.ODCIArgDescList， <span class="italic">list</span> ）返回数字;</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C__GUID-4E1C7D11-3390-47AE-B19F-C583DE6370CE">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e2619">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e2622">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e2625">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2630" headers="d75198e2619 ">
                                    <p><code class="codeph">FUNC</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2630 d75198e2622 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2630 d75198e2625 ">
                                    <p>表函数名称</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2641" headers="d75198e2619 ">
                                    <p><code class="codeph">outStats</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2641 d75198e2622 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2641 d75198e2625 ">
                                    <p>预期返回的行数</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2652" headers="d75198e2619 ">
                                    <p><code class="codeph">argDesc</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2652 d75198e2622 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2652 d75198e2625 ">
                                    <p>表函数的参数说明</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2663" headers="d75198e2619 ">
                                    <p><span class="italic"><code class="codeph">名单</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2663 d75198e2622 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2663 d75198e2625 ">
                                    <p>参数'编译时值。仅在运行时具有值的表达式由空值表示。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7256F85B-B97A-4258-9596-70D88FC9DE4C__GUID-E87CBA36-CF69-48EE-873F-C564D598D224">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告。</code></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADDCI5119"></a><a id="ADDCI5120"></a><a id="ADDCI5118"></a><div class="props_rev_3"><a id="GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2" name="GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2"></a><h4 id="ADDCI-GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2" class="sect4"><span class="enumeration_section">21.2.9</span> ODCIStatsUpdPartStatistics（）</h4>
                  <div>
                     <div class="section">
                        <p>在分区维护操作期间更新统计信息。这使得统计信息类型可以修补域索引统计信息，以正确反映分区维护操作。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2__GUID-13CEA84D-DF63-4015-80E8-B00C69501221">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">静态功能ODCIStatsCollect（ia ODCIIndexInfo，palist ODCIPartInfoList，env ODCIEnv）返回编号</pre></div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2__GUID-E73F4EEC-3724-4773-9D7D-38FC5E34B8C7">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="First column lists a parameter; second column indicates the IN or OUT binding of the parameter, the third column describes the parameter." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d75198e2761">参数</th>
                                 <th align="left" valign="bottom" width="11%" id="d75198e2764">进出</th>
                                 <th align="left" valign="bottom" width="71%" id="d75198e2767">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2772" headers="d75198e2761 ">
                                    <p><code class="codeph">IA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2772 d75198e2764 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2772 d75198e2767 ">
                                    <p>包含有关域索引的信息。它不包含任何分区特定信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2783" headers="d75198e2761 ">
                                    <p>palist</p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2783 d75198e2764 "><pre class="oac_no_warn" dir="ltr"> </pre></td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2783 d75198e2767 ">
                                    <p>包含有关要删除或添加的分区的信息</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d75198e2793" headers="d75198e2761 "><pre class="oac_no_warn" dir="ltr">ENV</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d75198e2793 d75198e2764 ">
                                    <p> </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d75198e2793 d75198e2767 ">
                                    <p>传递给例程的环境句柄</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2__GUID-FB1C091B-4067-4A74-A94C-5DCB6768F05B">返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ODCIConst。Success</code> ， <code class="codeph">ODCIConst.Error</code>或<code class="codeph">ODCIConst.警告。</code></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当<code class="codeph">SYSTEM MANAGED</code>方法指定统计类型时，在PMO期间仅调用<a href="extensible-optimizer-interface.html#GUID-E3185A04-24BD-43C8-A2EC-76DDF78188A2">ODCIStatsUpdPartStatistics（）</a>方法一次。方法实现中只允许DML和查询。
                              </p>
                           </li>
                           <li>
                              <p>如果用户在全局非分区表中维护域索引统计信息，则用户应删除已删除分区的用户定义统计信息的条目（并可选择为添加的分区添加<code class="codeph">NULL</code>条目）。然后，他们可以检查<code class="codeph">ODCIEnv.CallProperty</code>是否为<code class="codeph">StatsGlobalAndPartition</code>或<code class="codeph">StatsPartition</code> 。如果<code class="codeph">ODCIEnv.CallProperty</code>是<code class="codeph">StatsGlobalAndPartition</code>那么它们应该聚合所有可用的索引分区统计信息。如果<code class="codeph">ODCIEnv.CallProperty</code>是<code class="codeph">StatsPartition</code>他们可以简单地删除聚合统计信息，或保留聚合统计信息。此调用的<code class="codeph">ODCIEnv.CallProperty</code>不能是<code class="codeph">StatsGlobal</code> 。
                              </p>
                           </li>
                           <li>
                              <p>用户应使用<code class="codeph">ODCIEnv.CallProperty</code>传入的信息来确定要删除和调整的统计信息的类型。
                              </p>
                           </li>
                           <li>
                              <p>如果该方法返回<code class="codeph">ODCIConst.Error</code> ，忽略错误并继续分区管理操作。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>