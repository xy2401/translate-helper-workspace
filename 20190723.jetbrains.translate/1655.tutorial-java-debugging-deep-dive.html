<html lang="en-US" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="../app/v2/analytics.js"></script><link rel="canonical" href="tutorial-java-debugging-deep-dive.html"></link><meta charset="UTF-8"></meta><title>教程：Java调试Deep Dive  - 帮助| IntelliJ IDEA</title><link rel="stylesheet" href="../app/v2/app.css"></link></head><body dir="ltr" data-id="Tutorial_Java_Debugging_Deep_Dive"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索IntelliJ IDEA帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="tutorial-java-debugging-deep-dive.html#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">键盘布局</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected="">Windows / Linux默认值</option><option value="primary_default_for_gnome" data-group="primary">GNOME</option><option value="primary_default_for_kde" data-group="primary">KDE</option><option value="primary_default_for_xwin" data-group="primary">XWin中</option><option value="primary_emacs" data-group="primary">Emacs的</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="primary_netbeans" data-group="primary">NetBeans的</option><option value="primary_eclipse" data-group="primary">日食</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">默认（Mac OS X 10.5+）</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X.</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_intellij_idea_classic_os_x" data-group="secondary">IntelliJ IDEA Classic（Mac OS X）</option><option value="secondary_xcode" data-group="secondary">Xcode中</option><option value="secondary_resharper" data-group="secondary">ReSharper的</option><option value="secondary_resharper_osx" data-group="secondary">ReSharper（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">Emacs（Mac OS X）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Tutorial_Java_Debugging_Deep_Dive.xml" data-toc="Tutorial_Java_Debugging_Deep_Dive">教程：Java调试Deep Dive</h1>    <div class="chapter"><h2 id="f5af49e8" data-toc="Tutorial_Java_Debugging_Deep_Dive#f5af49e8">概观</h2>        <p id="cb586273">调试是任何开发人员库中最强大的工具之一。它为我们提供了对程序运行方式的独特见解，使我们能够更深入地了解我们调试的代码段。它允许我们跟踪正在运行的代码并检查状态和执行流程。作为其中的一部分，它给了我们顺序流动的幻觉。这非常直观且功能强大，但也可能会产生误导，因为大多数现代应用程序都是多线程的。</p>        <p id="09b6bfc1">“调试”表明我们处理错误，但这实际上是用词不当。即使代码没有问题，我们从调试中获得的信息也很有用。发现错误恰好是我们从调试会话中获得的知识的一个非常常见的用例。</p>        <p id="652698d1">IntelliJ IDEA调试器提供丰富的体验，帮助我们轻松调试从最简单的代码到复杂的多线程应用程序。</p>        <p id="b1e933dc">在我们开始之前，请注意：调试是一个非常强大的工具，但它确实带来了成本。调试过程是运行时的一部分，因此会影响它。表达式的每个评估都使用调试应用程序的相同内存进行，并且可以修改并可能破坏状态。在本教程中，请记住调试是一种侵入式方法，可能会影响调试应用程序的结果。我们将探索一些方法来尽量减少其影响，有时甚至可以利用它。调试代码与运行代码相比，执行时间也大不相同。最小的调试跟踪开销本身可能已足以改变事件的时间，从而改变应用程序的行为。每个<a href="using-breakpoints.html">断点</a>或日志都是一个可能的同步点，而步进显然会显着改变时序。正如我们将要看到的那样，这在多线程环境中成为一个关键问题，有时候再生错误取决于非常特定的事件序列。</p>        <p id="d3babf30">最后要记住的是调试不能代替理解代码。实际上，从调试会话中学习的唯一方法是不断地将调试器向我们展示的信息与我们对代码的期望以及我们认为“应该”表现的方式进行比较。在开始调试会话之前，我们必须了解我们正在尝试通过它实现的目标。如果我们正在寻找一个bug，我们需要大致知道什么是不正确的，即与预期的行为或状态有什么不同。在大多数情况下，我们也会对事情出错的原因做一些初步的假设。这将决定我们的调试会话应该如何进行。在我们进行调试时，我们必须始终将这些信息与我们的期望进行比较，并在代码偏离这些期望时密切关注。<br>这是调试非常有效的地方。<br>这是我们学习的地方。</p>        <p id="6c2eb0d4">在本教程中，我们尝试深入研究调试技术，并假设您已熟悉基本概念，例如：</p><ul class="list _bullet"><li class="list__item" id="41085502"><p><a href="using-breakpoints.html#set-line-breakpoint">行断点</a>暂停JVM或线程。</p></li><li class="list__item" id="501e1e25"><p><a href="stepping-through-the-program.html">踏步</a> 。</p></li><li class="list__item" id="ac8f7a79"><p><a href="settings-debugger-stepping.html">配置为跳过的类</a> 。</p></li><li class="list__item" id="ad17d89e"><p><a href="stepping-through-the-program.html#force_step_into">强制进入</a> “跳过的代码”。</p></li><li class="list__item" id="6c18e436"><a href="evaluating-expressions.html"><span>评估表达式</span></a></li><li class="list__item" id="2723bd6b"><p>使用<a href="adding-editing-and-removing-watches.html">手表</a></p></li><li class="list__item" id="53d805dc"><p>定义<a href="debugger-data-type-renderers.html">类型渲染器</a></p></li></ul>            </div>    <div class="chapter"><h2 id="a5302e0c" data-toc="Tutorial_Java_Debugging_Deep_Dive#a5302e0c">调试在没有调试标志的情况下编译的代码</h2>        <p id="da36d210">无调试标志编译的代码无法调试。无法进入此代码。当调试器在调试会话期间遇到此类代码时，它将跳过该部分代码。</p>        <p id="37571acd">线断点也无法定义和命中。但是，这是<a href="using-breakpoints.html#method_breakpoint">Method Breakpoint</a>可以保存我们的地方，因为我们仍然可以在IntelliJ IDEA中定义一个断点，在进入或退出特定方法之前停止，即使方法本身是在没有调试标志的情况下编译的。</p>        <p id="9585cf6e">查看状态时，由于无法检查方法中的实际变量，我们将看到警告消息。</p>        <figure><img alt="变量调试信息不可用" title="变量调试信息不可用" src="../img/idea/2019.1/ij_debugging_classes_compiled_without_debug_flag.png" id="80262161" width="288" height="79"></figure>    </div>    <div class="chapter"><h2 id="2c34b5cb" data-toc="Tutorial_Java_Debugging_Deep_Dive#2c34b5cb">没有源代码的调试</h2>        <p id="bc9f3e73">如果我们没有特定代码的源代码，IntelliJ IDEA仍然会反编译该类并在反编译源中显示我们的步骤。这非常有用，但请注意，生成的反编译类可能看起来与原始类不同，如果行不匹配，则反编译代码中的调试可能会令人困惑。始终尝试获取要插入的类的源代码。</p>    </div>    <div class="chapter"><h2 id="0e10d319" data-toc="Tutorial_Java_Debugging_Deep_Dive#0e10d319">检测意外状态或流量</h2>本节介绍了如果我们知道事情已经出错的地方，但不知道原因。<div class="chapter"><h3 id="9a279d75" data-toc="Tutorial_Java_Debugging_Deep_Dive#9a279d75">探索呼叫帧</h3>            <p id="6edcb0c4">对于大多数检测到意外调用或使用意外参数值调用方法的原因的大多数情况， <span class="keyword">线断点</span>应该足够了。如果我们不确定它的调用位置，我们可以将断点放在方法中。当VM挂起时，单击前面的<a href="debug-tool-window-frames.html">调用帧</a>以查看调用堆栈并检查每个范围中的状态以查看我们如何到达此处。</p>            <figure><img alt="呼叫帧" title="呼叫帧" src="../img/idea/2019.1/ij_debugging_call_frame.png" id="0c9e93e2" width="341" height="542"></figure>        </div>        <div class="chapter"><h3 id="681f6ef2" data-toc="Tutorial_Java_Debugging_Deep_Dive#681f6ef2">丢帧</h3>            <p id="d50f75ff">如果我们走得太远并且想要返回堆栈然后重新执行代码，我们可以使用<a href="debugging-code.html#dropFrame">Drop Frame</a>功能。这是一个有用的功能，但也有潜在危险：我们必须意识到重新执行代码将执行相同的指令两次，如果这些指令修改状态，我们可能最终处于损坏状态，当然在不会出现的情况下在相同条件下正常运行。为了使<span class="keyword">Drop Frame</span>的影响明显，请考虑以下简单程序：</p>            <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DropFrameDemo</span> <span class="o">{</span> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">（</span> <span class="kd">final</span> <span class="n">String</span> <span class="o">[]</span> <span class="n">args</span> <span class="o">）</span> <span class="o">{</span> <span class="n">modifyStateBasedOnParameter</span> <span class="o">（</span> <span class="n">state</span> <span class="o">）;</span> <span class="n">modifyStateBasedOnStaticField</span> <span class="o">（）;</span> <span class="o">}</span> <span class="c1">//丢弃帧在此方法中<span class="c1">，//</span></span> <span class="c1">和再次执行将打印状态= 2</span> <span class="kd">私有</span> <span class="kd">静态</span> <span class="kt">无效</span> <span class="nf"><span class="o"><span class="o"><span class="o">modifyStateBasedOnStaticField（）{++</span></span></span></span> <span class="n">状态</span> <span class="o">;</span> <span class="n">系统</span> <span class="o">。</span> <span class="na">出</span> <span class="o">。</span> <span class="na">println</span> <span class="o">（</span> <span class="s">“state =”</span> <span class="o">+</span> <span class="n">state</span> <span class="o">）;</span> <span class="o">}</span> <span class="c1">//从此方法中丢弃帧<span class="c1">，//</span></span> <span class="c1">并再次执行将打印状态= 1个</span> <span class="kd">私有</span> <span class="kd">静态</span> <span class="kt">无效</span> <span class="nf"><span class="o">modifyStateBasedOnParameter（</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">参数</span> <span class="o"><span class="o">）{</span></span> <span class="n">状态</span> <span class="o">=</span> <span class="n">参数</span> <span class="o">+</span> <span class="mi"><span class="o">1;</span></span> <span class="n">系统</span> <span class="o">。</span> <span class="na">出</span> <span class="o">。</span> <span class="na">println</span> <span class="o">（</span> <span class="s">“state =”</span> <span class="o">+</span> <span class="n">state</span> <span class="o">）;</span> <span class="o">}</span> <span class="o">}</span></code></div>            <p id="db6e3b35">断开<code class="code">modifyStateBasedOnParameter()</code>内部不会影响状态，因为IntelliJ IDEA会记住传入该帧的参数值，并且不会重新计算这些参数值。但是，破坏<code class="code">modifyStateBasedOnStaticField()</code>会使<code class="code">state</code>字段等于'2'。在<code class="code">main()</code>的正常运行下不可能的值。</p>        </div>        <div class="chapter"><h3 id="6e3674da" data-toc="Tutorial_Java_Debugging_Deep_Dive#6e3674da">通过方法检测意外流量</h3>            <aside class="note " rel="6e3674da" id="1fc7e073" data-title=""><p>在旧版本的IntelliJ IDEA中，方法断点会显着降低执行速度。<br>从2017.1版开始，方法断点实际上是由行断点模拟的，因此速度也一样快。</p></aside>            <p id="fda2ed9b">在有问题的方法中定义行断点的替代方法是定义<a href="using-breakpoints.html#method_breakpoint">方法断点</a> 。此类断点未附加到源代码行号，而是附加到对方法的调用的进入和退出。它在两个主要情况下特别有用：</p><ul class="list _bullet"><li class="list__item" id="5aa33670"><p>当一个方法由一个接口定义时，我们想要在它的<span class="emphasis">所有</span>实现中断点。</p></li><li class="list__item" id="069a71a5"><p>当我们没有源代码，只有反编译版本时，我们仍然想检查方法调用的细节，而编译类和反编译源代码之间的行号没有任何混淆的差异。</p></li></ul>                    </div>        <div class="chapter"><h3 id="daff4589" data-toc="Tutorial_Java_Debugging_Deep_Dive#daff4589">检测意外的对象状态</h3>            <aside class="note " rel="daff4589" id="040fb507" data-title=""><p>字段监视点是一种断点，可显着降低执行速度，应谨慎使用，尤其是在时序更改可能影响方案的多线程应用程序中。</p></aside>            <p id="1f24a2d5">有时难以弄清楚导致场到达某种意外状态的确切流量。在这些特殊情况下，我们可以使用断点，当程序读取或写入特定字段时，该断点将被命中。见<a href="using-breakpoints.html#field_watchpoint">Field Watchpoint</a> 。</p>        </div>        <div class="chapter"><h3 id="c9bf8826" data-toc="Tutorial_Java_Debugging_Deep_Dive#c9bf8826">检测到抛出的意外异常</h3>            <p id="49e84b42">虽然不是严格的调试功能，但是当我们想要调查抛出异常的原因时，我们可以<a href="analyze-stacktrace-dialog.html">分析异常堆栈跟踪</a>并快速到达生成该异常的代码行。从那里， <span class="keyword">线断点</span>和<span class="keyword">步进</span>的组合通常足以找出问题所在。</p>            <figure><img alt="分析Stacktrace" title="分析Stacktrace" src="../img/idea/2019.1/ij_debugging_analyze_stack_trace.png" id="23e6a573" width="790" height="265"></figure>            <p id="eed22b75">但有时，异常包含在另一个异常中，或者被catch块捕获并吞没。我们所看到的只是它的副作用（可能是一个日志），而不是它的堆栈跟踪。为此，我们可以使用<a href="using-breakpoints.html#exception-breakpoints">异常断点</a> 。</p>        </div>    </div>        <div class="chapter"><h2 id="0f6116ac" data-toc="Tutorial_Java_Debugging_Deep_Dive#0f6116ac">调试异步流程</h2>        <p id="d238c5bd">反应式编程越来越受欢迎，在许多框架和库的帮助下，开发人员正在编写更多的异步代码。<br>异步应用程序中的流程是调试工具和使用它们的开发人员面临的主要挑战。执行在帧之间跳转，使得理解和遵循代码变得更加困难。<br>向前迈进是更容易的一点。我们可以在代码中的不同点插入断点，无论执行线程如何，请查看从一个代码段到下一个代码段的进度。<br>这样做时，要注意断点是仅挂起一个线程还是整个应用程序。该决定基于调试会话的目标。如果要检查所有线程的状态并查看哪些线程已经进展以及哪些线程可能不必要地等待，您可以在此时冻结整个系统并查看所有线程的调用帧和堆栈跟踪。<br>如果您正在调试特定操作，则可以暂停一个线程并让系统的其余部分继续工作。</p>        <div class="chapter"><h3 id="async_stacktraces" data-toc="Tutorial_Java_Debugging_Deep_Dive#async_stacktraces">异步Stacktraces</h3>            <p id="17c07418">当我们想要从代码中的特定点回顾并理解我们如何到达时，异步调试的真正痛苦就开始了。考虑下面的异步代码示例（使用JDK的CompletableFutures）：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">asyncExample</span> <span class="o">（）</span> <span class="kd">抛出</span> <span class="n">InterruptedException</span> <span class="o">，</span> <span class="n">ExecutionException</span> <span class="o">{</span> <span class="kd">final</span> <span class="n">CompletableFuture</span> <span class="o">&lt;</span> <span class="n">String</span> <span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">supplyAsync</span> <span class="o">（（）</span> <span class="o">- &gt;</span> <span class="s">“F”</span> <span class="o">）。</span> <span class="na">thenApplyAsync</span> <span class="o">（</span> <span class="k">this</span> <span class="o">::</span> <span class="n">append_oo</span> <span class="o">）;</span> <span class="n">系统</span> <span class="o">。</span> <span class="na">出</span> <span class="o">。</span> <span class="na">的<span class="o">println（</span></span> <span class="n">未来</span> <span class="na">获得</span> <span class="o"><span class="o">（））;</span></span> <span class="o">}</span> <span class="kd">私人</span> <span class="n">字符串</span> <span class="nf"><span class="o">append_oo（</span></span> <span class="n">字符串</span> <span class="n"><span class="o"><span class="o">str）{</span></span></span> <span class="k">返回</span> <span class="n">STR</span> <span class="o">+</span> <span class="s"><span class="o">“OO”;</span></span> <span class="o">}</span></code></div>当我们在方法<code class="code">append_oo</code>停止时，我们可以看到堆栈跟踪为我们提供的信息非常少。<br>具体来说，我们无法看到在其上面应用的未来，也无法看到<code class="code">asyncExample</code>方法，它为我们启动了所有。<br>                <figure><img alt="ij调试异步堆栈跟踪" title="ij调试异步堆栈跟踪" src="../img/idea/2019.1/ij_debugging_async_stacktrace.png" id="1a69a643" width="357" height="269"></figure>                        <p id="7d9645b9">在异步上下文中，堆栈跟踪只会向我们展示一个非常有限的图片，我们真正需要的是线程之间的信息流或所有线程的组合堆栈跟踪，这些都是我们到达这一点（也称为因果链） 。</p>                        <p id="f9b0d8b4">IntelliJ IDEA提供了一种查看这些<span class="keyword">异步堆栈跟踪的方法</span> 。<br>在调试会话中，IntelliJ IDEA将捕获堆栈跟踪，并在以后查看异步流的下一部分的堆栈跟踪时显示它们：<br></p><figure><img alt="ij调试异步因果关系链" title="ij调试异步因果关系链" src="../img/idea/2019.1/ij_debugging_async_causality_chain.png" id="d06cfa53" width="359" height="195"></figure>                <br>当我们过滤外部库时甚至更清楚：<br><figure><img alt="ij调试异步因果链过滤" title="ij调试异步因果链过滤" src="../img/idea/2019.1/ij_debugging_async_causality_chain_filtered.png" id="e1f46daa" width="363" height="126"></figure>                <br>要捕获的堆栈跟踪以及插入它们的点需要在<a href="async-stacktraces.html"><span>异步堆栈跟踪</span></a>下的调试器首选项中进行配置。<br>IntelliJ IDEA需要知道要显示在我们需要捕获的堆栈跟踪顶部的类名和方法。在我们的示例<code class="code">java.util.concurrent.CompletableFuture</code> <code class="code">thenApplyAsync</code> 。调试器还需要知道我们想要插入捕获的堆栈跟踪的另一个堆栈跟踪中的位置。在我们的示例中，它是<code class="code">java.util.concurrent.CompletableFuture$AsyncApply</code> <code class="code">exec</code> 。<br>为了匹配两个堆栈跟踪，我们还需要两个键 - 每个上下文一个键，当一个堆栈跟踪确实是我们的异步链中的下一个逻辑步骤时，它将指向相同的值。在我们的示例中，我们可以使用的键表达式是<code class="code">param_0</code> （参数0  - 我们传入thenApplyAsync的方法引用）。它将与<code class="code">fn</code>匹配 - <code class="code">java.util.concurrent.的变量<code class="code">java.util.concurrent.CompletableFuture$AsyncApply</code> ，用于保存第二个调用帧中的函数。<figure><img alt="ij调试异步捕获" title="ij调试异步捕获" src="../img/idea/2019.1/ij_debugging_async_capture.png" id="6ad8e9bd" width="841" height="116"></figure>                <br>这应该<a href="async-stacktraces.html">在调试器设置中</a>配置一次，并且将提供常用异步框架的配置，例如此处使用的<span class="keyword">CompletableFuture</span> 。<br>                    </div>    </div>    <div class="chapter"><h2 id="multithreaded_applications" data-toc="Tutorial_Java_Debugging_Deep_Dive#multithreaded_applications">调试多线程应用程序</h2>        <p id="c5251789">多线程应用程序是调试的最大挑战。这些应用程序不具有确定性，而且难以控制。我们从<span class="keyword">步入</span>调试会话中获得的顺序流的错觉也无济于事，可能会产生误导。<br>在调查可能是并发错误的问题时，我们需要尝试更少<span class="keyword">步骤</span>并更多地调整我们的<span class="keyword">断点</span> 。这是因为很多并发错误都依赖于不同线程之间的特定交互，而侵入式调试会话会干扰它。我们将展示如何使用各种<span class="emphasis">断点属性</span>使我们能够将干扰限制到最小。另一个重要的主题是在应用程序中控制和<a href="debug-tool-window-threads.html">切换不同的线程</a> 。我们将通过调试不同并发错误的一些示例来演示IntelliJ IDEA的功能如何帮助解决这个问题。</p>        <aside class="tip sideblock" rel="c5251789" id="5d34ec7d" data-title=""><p>始终根据其功能在多线程应用程序中命名线程。它简化了日志记录和调试。</p></aside>        <div class="chapter"><h3 id="breakpoint_properties" data-toc="Tutorial_Java_Debugging_Deep_Dive#breakpoint_properties">控制断点</h3>            <p id="3413214d">IntelliJ IDEA <a href="using-breakpoints.html#breakpoint-properties">调试器属性</a>允许我们控制触发<span class="keyword">断点</span>时采取的操作。他们中的一些人定义了一个行动，而其他人则在那里增加了是否采取行动的进一步条件。这种对断点的精细控制对于并发错误至关重要，因为大多数只有在线程以非常特定的方式进行交互时才会被重现。断点的任何干扰都可能阻止我们重现这个bug。</p>            <div class="chapter"><h4 id="a5e643a9">断点动作</h4>确定断点操作取决于我们希望在调试会话中实现的目标。<p id="e9ab0891">如果我们可以在代码中定义条件或点，我们可以从查看整个系统状态获得更多信息，我们应该暂停整个VM。</p>                <p id="7bf78b1a">有时，最好<a href="using-breakpoints.html#suspend_policy">只挂起一个线程</a>而不是整个VM。当应用程序是较大系统的一部分并且挂起VM将导致等待服务的消息溢出或请求超时最终破坏整个系统时，尤其如此。当我们有许多工作线程时，最好保持几乎所有工作，并专注于我们感兴趣的一个线程。</p>                <p id="bc10746d">当我们处理并发错误时，任何暂停执行都可能阻止我们重现错误。我们可以选择做断点不停止什么，只是<a href="using-breakpoints.html#log">记录</a>无论是消息或特定表达到控制台的值，然后检查日志。当我们有一个关于我们究竟在寻找什么的强有力的理论时，这很有效。</p>            </div>            <div class="chapter"><h4 id="c50dd82d">根据条件限制断点</h4>                <p id="1aded1e7">除了方便之外，断点条件还允许我们最小化调试会话的侵入性。它们允许我们将断点操作限制为我们认为绝对必要的操作。</p>                <aside class="note " rel="1aded1e7" id="40974647" data-title=""><p>条件本身具有开销，并且每次遇到断点时都会对其进行评估。</p></aside>                    <p id="3de40c9e">                    <a href="using-breakpoints.html#breakpoint_condition">条件表达式</a>是使用最广泛的条件。它们允许我们仅在应用程序达到特定状态时触发断点。理想的情况是，我们可以定义一个表达式来捕捉事情开始出错的确切点。</p>                    <p id="3512071a">                    <a href="using-breakpoints.html#pass_count">传递计数</a>在多次运行的代码中很有用，无论是事件处理程序还是循环，我们之后的有趣场景仅在特定次数的传递后显示。</p>                    <p id="37ee6c15">我们在代码被多次命中时使用它，但只有第一种情况很有趣。<a href="using-breakpoints.html#remove_once_hit">Remove Once Hit</a>选项在两种情况下特别有用：</p><ul class="list _bullet"><li class="list__item" id="01b0d0ad"><p>当断点操作是记录而不是挂起时，这意味着我们无法在命中之后删除或禁用断点。</p></li><li class="list__item" id="fd900ea0"><p>当代码由许多线程执行时，我们只想暂停其中一个。</p></li></ul>                                        <p id="dependency_on_other_breakpoint">一个非常有用的功能。它的明显用途是作为一个过滤器来触发断点，在这种场景中我们只是在访问一个方法后感兴趣，或者只在达到另一个状态后才对代码中的特定状态感兴趣。但是，除此之外，我们可以使用它来重现特定的并发问题，因为它可以帮助我们挂起线程并控制哪个线程到达代码中的哪个特定行以及以哪个顺序。</p>                    <aside class="tip sideblock" rel="dependency_on_other_breakpoint" id="145afbb5" data-title="">                        <p id="c2c59820">实例过滤使用实例ID，因此需要在应用程序运行时进行设置。</p></aside>                    <p id="3f4ad3d0">允许我们按类或特定实例<a href="using-breakpoints.html">过滤</a>触发。</p>            </div>        </div>    </div>    <div class="chapter"><h2 id="dfdbb7a4" data-toc="Tutorial_Java_Debugging_Deep_Dive#dfdbb7a4">调试长时间运行的方案</h2>        <p id="77ec3e20">            <a href="using-breakpoints.html#method_breakpoint">方法断点</a>和<a href="using-breakpoints.html#field_watchpoint">Field Watchpoint</a>大大减慢了代码执行速度。当执行相同的代码很多次时，即使是<a href="using-breakpoints.html#breakpoint_condition">条件断点也</a>会使处理速度变慢，足以让它变得明显。这是一个真正的问题，因为处理数百万个事件的事件处理程序的场景相当普遍（考虑重放日志文件或处理大量生产日志文件）并评估该事件处理代码中的断点条件可能会使系统变慢无法使用的状态。为了克服这个问题，假设我们可以修改运行代码，我们可以通过使用一个小技巧来提高速度，我们将其称为“代码中的断点”。当我们调试数百万个事件的处理时，这个技巧非常有用，其中只有一个事件导致问题而且我们事先不知道哪个是有问题的事件，并且可以节省我们很多等待触发条件断点的事件。最快的代码是由JVM编译和优化的执行代码。我们想要使用这个事实，所以，我们不是在断点上写条件，而是以我们稍后可以操作的方式将它引入到我们执行的代码中。然后，我们在没有任何断点的情况下进行调试，从而以最快的方式运行调试会话，并在代码运行时引入断点，只有当我们真正知道我们会发现它时。</p>        <section class="procedure-steps"><h2 id="4e4de1a1">代码中的断点</h2><ol class="list _decimal"><li class="list__item" id="1a417d6b">我们用条件为代码引入了一个循环。这意味着只有在感兴趣的状态发生时我们才进入循环。然后我们将某些内容打印到控制台，以便我们知道代码何时进入循环。因为循环不会改变任何状态，所以一旦我们进入循环，我们将保持在其中。<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="k">while</span> <span class="o">（</span> <span class="n">bugCondition</span> <span class="o">（</span> <span class="n">msg</span> <span class="o">））</span> <span class="o">{</span> <span class="n">System</span> <span class="o">。</span> <span class="na">出</span> <span class="o">。</span> <span class="na">println</span> <span class="o">（</span> <span class="s">“抓住了！<span class="o">“）;</span></span> <span class="k">尝试</span> <span class="o">{</span> <span class="n">线程</span> <span class="na">休眠</span> <span class="o"><span class="o"><span class="mi"><span class="o"><span class="o">（1000）;}</span></span></span></span></span> <span class="k">赶上</span> <span class="n"><span class="o">（InterruptedException</span>的</span> <span class="c1"><span class="n"><span class="o"><span class="o">E）{//</span></span></span>忽略</span> <span class="o"><span class="o">}}</span></span></code></div>                <aside class="tip sideblock" rel="c9850f6b" id="54a0ea70" data-title="">                    <p id="7c7d3eef">这里的睡眠只是为了避免用“陷阱”轰击控制台！“消息。</p></aside>            </li><li class="list__item" id="ea079ab6"><p id="cd5dcb8b">此时我们启动调试会话，坐下来等待“陷阱！“ 出现。控制台将告诉我们“击中”“断点”。</p>                <figure><img alt="控制台显示断点命中" title="控制台显示断点命中" src="../img/idea/2019.1/ij_debugging_gotcha.png" id="d948439f" width="250" height="508"></figure>            </li><li class="list__item" id="9ec87129">                <p id="d7ebd662">当“陷阱！“确实出现了，我们在循环中引入了一个实线断点。断点将被命中并暂停VM或线程。现在我们可以检查事件及其状态。如果检查不够，最后要做的是让我们的代码退出循环。有两种选择。</p>                <ul class="list _bullet"><li class="list__item" id="4c8f057f">                        <p id="51579467">我们可以利用<span class="keyword">Evaluate Expression</span>侵入性来评估将实际将循环条件修改为false的代码片段。如果我们使用字段或变量作为循环的条件，这很容易完成，因为我们可以修改它的值。</p>                        <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kt">boolean</span> <span class="n">enterLoop</span> <span class="o">=</span> <span class="n">bugCondition</span> <span class="o">（</span> <span class="n">msg</span> <span class="o">）;</span> <span class="k">while</span> <span class="o">（</span> <span class="n">enterLoop</span> <span class="o">）</span> <span class="o">{</span> <span class="n">System</span> <span class="o">。</span> <span class="na">出</span> <span class="o">。</span> <span class="na">println</span> <span class="o">（</span> <span class="s">“抓住了！<span class="o">“）;</span></span> <span class="k">尝试</span> <span class="o">{</span> <span class="n">线程</span> <span class="na">休眠</span> <span class="o"><span class="o"><span class="mi"><span class="o"><span class="o">（1_000）;}</span></span></span></span></span> <span class="k">赶上</span> <span class="n"><span class="o">（InterruptedException</span>的</span> <span class="c1"><span class="n"><span class="o"><span class="o">E）{//</span></span></span>忽略</span> <span class="o"><span class="o">}}</span></span></code></div>                        <figure><img alt="使用Evaluate Expression停止循环" title="使用Evaluate Expression停止循环" src="../img/idea/2019.1/ij_debugging_enter_loop_false.png" id="fe935d23" width="600" height="263"></figure>                    </li><li class="list__item" id="9a1924f6">                        <p id="30772ea5">我们可以使用调试会话的另一个功能<span class="keyword">HotSwap</span>退出循环。这允许我们在调试期间修改正在运行的代码，编译它然后IntelliJ IDEA <a href="altering-the-program-s-execution-flow.html#reload_classes">将</a>使用新版本<a href="altering-the-program-s-execution-flow.html#reload_classes">热调试调试的类</a> 。我们需要做的就是将循环条件更改为“false”。默认情况下，IntelliJ IDEA将检测到某个类是否具有新版本，并将询问我们是否使用新版本重新加载该类。</p>                        <figure><img alt="重新加载课程？" title="重新加载课程？" src="../img/idea/2019.1/ij_debugging_reload_classes.png" id="2ae034a7" width="600" height="163"></figure>                        <p id="9de587aa">加载新版本后，新的循环条件将使代码退出循环，我们可以从该点继续调试。您可以在循环之后放置另一个断点以再次暂停执行，或者只是逐步执行'false'循环条件。</p>                    </li></ul>            </li></ol><aside class="note " rel="9ec87129" id="a568fd61" data-title="">                <p id="d9c87ecf">请记住在调试后删除此代码。您还应该对真实功能进行失败的测试，以提醒您永远不要错误地提交它。</p>            </aside></section>    </div>    <div class="chapter"><h2 id="9b94aea3" data-toc="Tutorial_Java_Debugging_Deep_Dive#9b94aea3">寻找竞争条件</h2>        <p id="82f64c28">竞争条件是多线程应用程序中的常见问题。多个线程访问并修改相同的状态，可能会破坏它或导致不希望的流量。竞争条件可能是一个非常微妙的错误，通常难以重现。这是因为它只在线程以非常特定的顺序执行代码时才会发生。其他执行订单看起来很好，不会引起任何问题。</p>        <p id="8d4b0216">在线程中查找竞争条件时，我们的调试运行必须以尽可能少的干扰开始，以免干扰执行顺序。一旦我们获得了一些信息或假设执行顺序会导致错误，我们也可以使用调试功能使用<a href="tutorial-java-debugging-deep-dive.html#dependency_on_other_breakpoint">断点之间</a>的<a href="tutorial-java-debugging-deep-dive.html#dependency_on_other_breakpoint">依赖关系</a>来重现它。</p>        <div class="chapter"><h3 id="b6f37572" data-toc="Tutorial_Java_Debugging_Deep_Dive#b6f37572">检测竞争状况导致状态损坏</h3>            <aside class="tip sideblock" rel="b6f37572" id="e1368eb8" data-title="">                <p id="5bb1a15e">如果您怀疑存在竞争条件，请首先调试没有任何断点，以确保您仍然可以在调试模式下重现该问题。</p>            </aside>            <p id="c4deb115">有时竞争条件仅在系统的每十次或一百次运行中发生一次。如果我们怀疑我们的多线程代码中存在竞争条件，我们必须始终确保调试会话的侵入性不会使问题不可重现。例如，这里我们创建了一个发布者和订阅者系统，但是我们所有的订阅者共享一个原始（而不是线程安全）计数器来计算消费消息的总数。</p>            <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">私有</span> <span class="kd">类</span> <span class="nc">Subscriber</span> <span class="kd">实现</span> <span class="n">Runnable</span> <span class="o">{</span> <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span> <span class="o">（）</span> <span class="o">{</span> <span class="k">while</span> <span class="o">（</span> <span class="kc">true</span> <span class="o">）</span> <span class="o">{</span> <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">messageQueue</span> <span class="o">。</span> <span class="na">poll</span> <span class="o">（）;</span> <span class="k">如果</span> <span class="o">（</span> <span class="n">消息</span> <span class="o">！=</span> <span class="kc"><span class="o"><span class="o">NULL）{</span></span></span> <span class="k">如果</span> <span class="o"><span class="n">（MSG</span></span> <span class="na">等于</span> <span class="o"><span class="o"><span class="n"><span class="o"><span class="o">（STOP））{</span></span></span></span></span> <span class="k">打破</span> <span class="o">;</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//竞争条件就在这里！</span>
                    <span class="n">counter</span> <span class="o">++;</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span></code></div>            <p id="3393a715">一旦我们确定可以在调试模式下重现问题，我们尝试<a href="using-breakpoints.html#log">使用日志记录</a>设置<a href="using-breakpoints.html#log">断点</a>而不是暂停程序执行。在这里，我们从所有线程登录到同一控制台的事实可能会以一种“解决”错误的方式“同步”线程。我们需要确保即使现在可能需要更多尝试，我们仍然可以重现它。记录可疑状态可以缩小我们的选项范围，并允许我们看到问题不在于对方法的调用次数，而在于计数器字段。</p>        </div>        <div class="chapter"><h3 id="b65b2b95" data-toc="Tutorial_Java_Debugging_Deep_Dive#b65b2b95">避免调试器开销</h3>            <p id="c7bf9eab">在大多数机器上，竞争条件（例如我们之前示例中的竞争条件）将变成“微妙”竞争条件。“微妙”意味着对运行时环境的任何修改或更改都可以“修复”它。请记住，错误的起源是推进原始计数器不是原子操作的事实。</p>            <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="c1">//比赛条件就在这里！</span>
<span class="n">counter</span> <span class="o">++;</span></code></div>            <p id="fc2cf0c2">为了重现这个错误，我们需要两个线程，它们都读取相同的值：“第二个”线程必须在“第一个”更新它之前读取该值并刷新其CPU缓存。在正常运行期间很容易在多核机器上创建，但在调试会话中几乎不可能重现。</p>            <p id="32976527">通过断点在同一点上记录同步线程，因为它们都需要写入同一个日志。这也会刷新所有线程的CPU缓存，因为写入日志是原子的。简而言之，它阻止我们再现错误。暂停VM或线程也无法帮助我们，因为我们无法将两条指令（读取计数器值并递增）分开来中断它们。在这一点上，我们需要做出一些假设然后证明或反驳它们。由于我们不能使用任何断点，我们唯一的希望是我们可以更改实际执行的代码并引入将被编译的新代码，因此会减少干扰。</p>            <p id="7bed2304">这是非常不得已的选择。一个很好的模式来帮助我们这里是一个跟踪缓冲区。</p>            <div class="chapter"><h4 id="d15017d4">跟踪缓冲区</h4>我们可以引入一个内部缓冲区并将有趣的值存储在这个缓冲区中。将其视为本地化，非常高效的内存日志。我们必须确保：<ul class="list _bullet"><li class="list__item" id="80f01af4"><p>我们<span class="keyword">每个线程</span>都有一个缓冲区，这些缓冲区是隔离的，所以这不会引入新的并发问题。</p></li><li class="list__item" id="152df085"><p>因为缓冲区是每个线程，所以它不需要是线程安全的，并且<span class="keyword">不能</span>是线程安全的。这是因为我们希望避免引入任何同步点。</p></li><li class="list__item" id="5ecb1be2"><p>我们插入的值不能引用可以更改的实际状态，而是复制或记录消息。</p></li><li class="list__item" id="1599508f"><p>引入的代码尽可能小，以最小化其对运行代码的影响。</p></li><li class="list__item" id="86cab39a"><p>我们仅在执行结束后打印或记录缓冲区的内容，以避免使日志记录操作成为线程之间的同步机制。另一种选择是仅将值存储在跟踪缓冲区中，然后通过在代码的关键部分执行完毕后放置断点来检查其内容。</p></li></ul>                <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">私有</span> <span class="kd">类</span> <span class="nc">Subscriber</span> <span class="kd">实现</span> <span class="n">Runnable</span> <span class="o">{</span> <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="o">[]</span> <span class="n">traceBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span> <span class="n">NUMBER_OF_SUBSCRIBERS_AND_PUBLISHERS</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">];</span> <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span> <span class="o">（）</span> <span class="o">{</span> <span class="k">while</span> <span class="o">（</span> <span class="kc">true</span> <span class="o">）</span> <span class="o">{</span> <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">messageQueue</span> <span class="o">。</span> <span class="na">poll</span> <span class="o">（）;</span> <span class="k">如果</span> <span class="o">（</span> <span class="n">消息</span> <span class="o">！=</span> <span class="kc"><span class="o"><span class="o">NULL）{</span></span></span> <span class="k">如果</span> <span class="o"><span class="n">（MSG</span></span> <span class="na">等于</span> <span class="o"><span class="o"><span class="n"><span class="o"><span class="o">（STOP））{</span></span></span></span></span> <span class="k">打破</span> <span class="o">;</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="n">traceBuffer</span> <span class="o">[</span> <span class="n">index</span> <span class="o">++]</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">;</span> <span class="c1">//比赛条件就在这里！</span>
                    <span class="n">counter</span> <span class="o">++;</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span></code></div>                <p id="cdef434c">例如，这里我们引入了一个足以容纳所有消息的原始<code class="code">int array</code> ，为了证明我们对计数器中的错误的怀疑，我们在推进之前只存储计数器值。是的，它可能不是计数器提前确切的值，但如果多个线程报告相同的计数器值，它将证明我们的假设。完成所有事件后，我们可以检查跟踪缓冲区并找到重复项。</p>            </div>        </div>        <div class="chapter"><h3 id="e083e698" data-toc="Tutorial_Java_Debugging_Deep_Dive#e083e698">检测竞争条件，导致意外的流量控制</h3>            <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">私有</span> <span class="kd">类</span> <span class="nc">Subscriber</span> <span class="kd">实现</span> <span class="n">Runnable</span> <span class="o">{</span> <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span> <span class="o">（）</span> <span class="o">{</span> <span class="n">String</span> <span class="n">msg</span> <span class="o">;</span> <span class="k">while</span> <span class="o">（</span> <span class="kc">true</span> <span class="o">）</span> <span class="o">{</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">messageQueue</span> <span class="o">。</span> <span class="na">poll</span> <span class="o">（）;</span> <span class="k">如果</span> <span class="o">（</span> <span class="n">消息</span> <span class="o">！=</span> <span class="kc"><span class="o"><span class="o">NULL）{</span></span></span> <span class="k">如果</span> <span class="o"><span class="n">（MSG</span></span> <span class="na">等于</span> <span class="o"><span class="o"><span class="n"><span class="o"><span class="o">（STOP））{</span></span></span></span></span> <span class="k">打破</span> <span class="o">;</span> <span class="o">}</span> <span class="c1">// else do something</span> <span class="o">}</span> <span class="o">}</span> <span class="c1">//不会与多个订阅者一起工作，因为主线程将</span> <span class="c1">在第一个订阅者完成时唤醒。</span>
        <span class="c1">//在这里使用CountDownLatch是一种更好的方法。</span>
        <span class="kd">synchronized</span> <span class="o">（</span> <span class="n">messageQueue</span> <span class="o">）</span> <span class="o">{</span> <span class="n">messageQueue</span> <span class="o">。</span> <span class="na">notify</span> <span class="o">（）;</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span></code></div>            <p id="95cd1f8f">在这个例子中，我们有另一个竞争条件，但争用的共享状态不是直接可见的，只是由一个看似错误的流控制推断出来：第一个订阅者将唤醒主线程，即使第二个线程是仍在处理消息。在这种情况下，我们无法在“跟踪缓冲区”中检查或打印等待线程，但是当我们挂起整个应用程序时，我们可以检查各种线程的位置。</p>            <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="4110fa35"><p>首先，我们可以在唤醒后暂停主线程。我们可以看到有时其中一个订户线程仍然标记为正在运行。这使我们可以假设问题的根源在于，即太快地调用<code class="code">notify()</code>方法。</p></li><li class="list__item" id="89937d6c"><p>我们只能暂停其中一个订户线程。这将导致另一个线程通知主线程。这将向我们证明问题可能发生在任何订户中并且在其逻辑中。</p></li><li class="list__item" id="c757624d">                    <p id="2813a35c">可以肯定的是，我们可以提前暂停整个VM，就在订户通知主线程之前。然后，我们可以检查两个订户线程的状态，并证明其中一个仍在轮询，而另一个已经完成并且即将通知主线程已完成。</p>                    <figure><img alt="在通知主线程之前暂停应用程序" title="在通知主线程之前暂停应用程序" src="../img/idea/2019.1/ij_debugging_race_condition_flow_control1.png" id="4256a680" width="710" height="471"></figure>                    <p id="b196ff12">在这个屏幕截图中，我们可以看到检查线程都标记为'RUNNING'，这意味着当第一个即将通知主线程时它已经完成（在同步块内），另一个仍然可以处理消息。</p>                </li><li class="list__item" id="76ccb528">                    <p id="523b0de2">为了毫无疑问地证明我们的假设，我们还可以在订阅者的轮询循环中放置一个断点。在我们通知主线程之前，我们使断点依赖于前一个断点。击中从属断点（如下所示）证明了我们的理论。</p>                    <figure><img alt="订户内部的断点" title="订户内部的断点" src="../img/idea/2019.1/ij_debugging_race_condition_flow_control2.png" id="e7ecaddb" width="710" height="521"></figure>                </li></ol></section>        </div>    </div>    <div class="chapter"><h2 id="8d1bdc5c" data-toc="Tutorial_Java_Debugging_Deep_Dive#8d1bdc5c">检测死锁</h2>        <p id="87f8b0f2">当两个线程发生冲突时会发生死锁，两者都会阻止彼此工作。一旦发生，通过查看所有线程的帧，很容易发现死锁。我们可以通过使用<a href="debug-tool-window-dump.html">线程转储来实现</a> 。<a href="run-tool-window.html#dump_threads">运行时</a>也<a href="run-tool-window.html#dump_threads">可以使用</a>此功能。如果我们知道我们正在追逐死锁，那么运行模式甚至比调试更可取。这是因为我们不会以这种方式干涉执行，而快照将是应用程序的Java线程转储的输出。线程转储可以检测死锁并对它们发出警告。例如，在下面的转储中，我们可以看到进程在PublisherThread（它停留在第44行）和SubscriberThread（第78行）之间发现1个死锁。</p>        <figure><img alt="线程转储" title="线程转储" src="../img/idea/2019.1/ij_debugging_thread_dump.png" id="127b3a88" width="790" height="308"></figure>        <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="571e51cd">在这个例子中，我们可以看到两个线程都在等待锁定，这意味着另一个线程没有释放这些锁。我们还可以看到两者都在等待不同的锁，因为同步器ID是不同的。更有用的是顶部的死锁摘要告诉我们哪个线程持有每个锁。我们可以看到两个死锁的线程正在持有另一个线程试图获取的锁。<aside class="tip sideblock" rel="571e51cd" id="332dec57" data-title=""><p>始终根据其功能在多线程应用程序中命名线程。任何需要稍后查看线程转储的人都会感谢你。</p></aside>            </li><li class="list__item" id="c19e7fcb"><p>这应该已经为我们提供了有关死锁如何发生的大量信息。如果仍然不清楚我们的代码如何达到死锁，那么我们可以在我们点击线程转储提供的行之前尝试使用断点进行调试。当我们有一个错误的理论时，我们可以尝试使用<a href="tutorial-java-debugging-deep-dive.html#dependency_on_other_breakpoint">断点之间</a>的<a href="tutorial-java-debugging-deep-dive.html#dependency_on_other_breakpoint">依赖关系</a>来重现场景<a href="tutorial-java-debugging-deep-dive.html#dependency_on_other_breakpoint">。</a>            </p></li><li class="list__item" id="3709062b">                <p id="7e6713bd">我们现在可以在其中一个<span class="keyword">线程</span>上创建一个<span class="keyword">Suspend Thread</span>断点，并使用另一个线程转储快照验证另一个线程是否到达其死锁位置。</p>                <figure><img alt="Publisher线程中的断点" title="Publisher线程中的断点" src="../img/idea/2019.1/ij_debugging_deadlock1.png" id="7b64e298" width="710" height="172"></figure>现在我们可以在其中一个线程陷入死锁之前检查状态。</li><li class="list__item" id="f67ef413">                <p id="5630730c">另一种选择是在两个线程上放置挂起线程断点并在它们之间切换。在此示例中检查<code class="code">Publisher</code> <code class="code">Subscriber</code>和<code class="code">Subscriber</code>的状态将向我们显示导致死锁的混淆。</p>                <figure><img alt="出版商的断点" title="出版商的断点" src="../img/idea/2019.1/ij_debugging_deadlock2.png" id="8559f855" width="710" height="120"></figure>                <figure><img alt="订户中的断点" title="订户中的断点" src="../img/idea/2019.1/ij_debugging_deadlock3.png" id="0fa08cff" width="710" height="94"></figure>            </li><li class="list__item" id="8a89e462"><p>当我们检查我们的锁实例时，我们可以看到并发代码实际上是正确的，但是当我们将它们传递给两个对象时，我们混淆了读锁和写锁。查看上图中的锁实例ID。</p></li><li class="list__item" id="96a3d6cc"><p>实际上，当我们检查构造（我们注入这些锁的地方）时，我们可以看到错误：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">ThreadGroup</span> <span class="n">threadGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadGroup</span> <span class="o">（</span> <span class="s">“Demo”</span> <span class="o">）;</span> <span class="k">new</span> <span class="n">Thread</span> <span class="o">（</span> <span class="n">threadGroup</span> <span class="o">，</span> <span class="k">new</span> <span class="n">Subscriber</span> <span class="o">（</span> <span class="n">messageQueue</span> <span class="o">，</span> <span class="n">readLock</span> <span class="o">，</span> <span class="n">writeLock</span> <span class="o">），</span> <span class="s">“SubscriberThread”</span> <span class="o">）。</span> <span class="na">start</span> <span class="o">（）;</span> <span class="c1">//以错误的顺序传递锁将导致发布者和订阅者之间的</span> <span class="k">新</span> <span class="n">线程</span> <span class="o">（</span> <span class="n">threadGroup</span> <span class="o">，</span> <span class="k">new</span> <span class="n">Publisher</span> <span class="o">（</span> <span class="n">messageQueue</span> <span class="o">，</span> <span class="n">writeLock</span> <span class="o">，</span> <span class="n">readLock</span> <span class="o">），</span> <span class="s">“PublisherThread”</span> <span class="o">）</span> <span class="c1">之间出现死锁</span> <span class="o">。</span> <span class="na">start</span> <span class="o">（）;</span></code></div>            </li></ol></section>    </div>    <div class="chapter"><h2 id="697cc653" data-toc="Tutorial_Java_Debugging_Deep_Dive#697cc653">检测活锁</h2>        <p id="cdb14a8b">活锁是线程未被阻止但仍无法取得进展的情况。从外部来看，活锁应该像死锁一样，但由于线程没有被阻塞，快照（线程转储）不会在任何死锁时提醒我们。</p>        <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="2130be72">                <p id="f7500e8d">在开始调试之前尝试的一种策略是多次重复<span class="keyword">Thread Dump</span> ，然后比较各种线程的堆栈跟踪。这应该让我们清楚地看到代码中有问题的区域，在大多数情况下代码无法逃脱。</p>                <figure><img alt="Livelock快照" title="Livelock快照" src="../img/idea/2019.1/ij_debugging_livelock1.png" id="1743be6d" width="710" height="75"></figure>            </li><li class="list__item" id="b9e1ec16">                <p id="01e77921">如果我们仍然不确定，我们可以使用大量的<span class="keyword">Pass Count</span> ，我们假设只有在活锁情况下才能达到。</p>                <figure><img alt="使用传球计数" title="使用传球计数" src="../img/idea/2019.1/ij_debugging_livelock_pass_count.png" id="43b621f2" width="613" height="552"></figure>我们还可以<span class="keyword">逐步</span>执行代码并确切地确认重复执行的代码区域，但不会进展。</li><li class="list__item" id="a3fb9c61">                <p id="4ebd24d5">此时，当我们进入活锁状态时（即，当应用程序达到阻止其逃避执行的代码块的状态时），我们可以使用<span class="keyword">条件表达式</span>来捕获执行中的点。</p>                <p id="49fca862">在这个例子中，我们假设STOP消息未能将我们从循环中断开，因此要么它从未被发送过，要么它没有被处理，所以我们将引入一个断点，其条件是查找STOP消息。</p>                <figure><img alt="使用条件来捕获活锁情况" title="使用条件来捕获活锁情况" src="../img/idea/2019.1/ij_debugging_livelock_condition.png" id="08261dec" width="710" height="304"></figure>            </li><li class="list__item" id="d7f9aba6">                <p id="3196fff5">我们的断点被击中，意味着STOP消息已发送但未处理。</p>                <figure><img alt="断点命中" title="断点命中" src="../img/idea/2019.1/ij_debugging_livelock_stop_breakpoint.png" id="ab7bac2d" width="442" height="165"></figure>            </li><li class="list__item" id="acaca4d8">                <p id="ea59af9b">我们介入，使用<span class="keyword">Evaluate Expression</span>检查状态并找到错误。“有效”方法并不认为<code class="code">STOP</code>是有效消息，而是将我们置于此活锁场景中。</p>                <figure><img alt="使用Evaluate Expression来测试理论" title="使用Evaluate Expression来测试理论" src="../img/idea/2019.1/ij_debugging_livelock_evaluate.png" id="dddc35e8" width="546" height="201"></figure>            </li></ol></section>    </div><div class="last-modified" data-skip-index="skip">最后修改日期：2019年3月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="altering-the-program-s-execution-flow.html">改变程序的执行流程</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="../app/v2/app.js"></script></body></html>