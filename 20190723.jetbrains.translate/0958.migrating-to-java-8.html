<html lang="en-US" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="../app/v2/analytics.js"></script><link rel="canonical" href="migrating-to-java-8.html"></link><meta charset="UTF-8"></meta><title>迁移到Java 8  - 帮助| IntelliJ IDEA</title><link rel="stylesheet" href="../app/v2/app.css"></link></head><body dir="ltr" data-id="Migrating_to_Java_8"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索IntelliJ IDEA帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="migrating-to-java-8.html#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">键盘布局</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected="">Windows / Linux默认值</option><option value="primary_default_for_gnome" data-group="primary">GNOME</option><option value="primary_default_for_kde" data-group="primary">KDE</option><option value="primary_default_for_xwin" data-group="primary">XWin中</option><option value="primary_emacs" data-group="primary">Emacs的</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="primary_netbeans" data-group="primary">NetBeans的</option><option value="primary_eclipse" data-group="primary">日食</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">默认（Mac OS X 10.5+）</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X.</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_intellij_idea_classic_os_x" data-group="secondary">IntelliJ IDEA Classic（Mac OS X）</option><option value="secondary_xcode" data-group="secondary">Xcode中</option><option value="secondary_resharper" data-group="secondary">ReSharper的</option><option value="secondary_resharper_osx" data-group="secondary">ReSharper（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">Emacs（Mac OS X）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Migrating_to_Java_8.xml" data-toc="Migrating_to_Java_8">迁移到Java 8</h1>    <p id="f68eca36">使用最新版本的语言和库保持代码最新是一项具有挑战性的任务。幸运的是，IntelliJ IDEA可以使这更容易，通过检查来指导您的工作，自动修复和通常的重构工具。</p>    <p id="ef07267a">        <a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" data-bypass="yes" target="_blank"><span>Java SE 8</span></a>为语言带来了全新的概念，如lambda表达式，并为开发人员多年来一直使用的类添加了新方法。此外，还有新的工作方式，包括新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-bypass="yes" target="_blank"><span>Date和Time API</span></a> ，以及一个可帮助null安全的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-bypass="yes" target="_blank"><span>Optional</span></a>类型。</p>    <p id="267afed4">在本教程中，我们将展示IntelliJ IDEA如何帮助您将代码从Java 6（或7）转换为Java 8，使用代码示例来显示可用的帮助以及何时可能或可能不会选择使用新功能。</p>    <p id="36c10592">本教程假定以下先决条件：</p><ul class="list _bullet"><li class="list__item" id="2029b183"><p>您已经有一个现有代码库的IntelliJ IDEA项目。</p></li></ul>        <p id="f0ec827f">在本页面：</p>    <ul data-skip-index="skip"><li class="list__item"><a href="migrating-to-java-8.html#79ab578b">接近问题</a></li><li class="list__item"><a href="migrating-to-java-8.html#9350a618">初始设置</a></li><li class="list__item"><a href="migrating-to-java-8.html#38052c2d">配置和运行语言级别迁移检查</a></li><li class="list__item"><a href="migrating-to-java-8.html#665bc070">Lambda表达式</a></li><li class="list__item"><a href="migrating-to-java-8.html#2e1b51a0">应用lambda表达式的影响</a></li><li class="list__item"><a href="migrating-to-java-8.html#5d57c21c">新的收集方法</a></li><li class="list__item"><a href="migrating-to-java-8.html#f957bcbc">Streams API  -  foreach</a></li><li class="list__item"><a href="migrating-to-java-8.html#df9b15e2">Streams API  - 收集</a></li><li class="list__item"><a href="migrating-to-java-8.html#a5770b9a">使用Streams替换foreach的影响</a></li><li class="list__item"><a href="migrating-to-java-8.html#5633d9d1">新的日期和时间API</a></li><li class="list__item"><a href="migrating-to-java-8.html#72d9f51b">迁移到新的Date和Time API的影响</a></li><li class="list__item"><a href="migrating-to-java-8.html#e739c7c3">使用可选</a></li><li class="list__item"><a href="migrating-to-java-8.html#d715dac0">迁移到Optional的影响</a></li><li class="list__item"><a href="migrating-to-java-8.html#6cb0a49e">摘要</a></li></ul>    <section class="procedure-steps"><h2 id="79ab578b">接近问题</h2><p id="8ff2622a">IntelliJ IDEA提供的大量选项和功能可能非常庞大，尤其是在解决像尝试将整个代码库（甚至只是模块或包）迁移到新版本这样大的问题时。与大多数软件开发问题一样，以迭代方式处理此问题是值得的。</p><ol class="list _decimal"><li class="list__item" id="a2b9914a"><p>选择少量更改来实施。</p></li><li class="list__item" id="d32368b8"><p>选择代码库的一部分以应用它们。</p></li><li class="list__item" id="a4ac0514"><p>批量应用更改，经常运行项目测试，并在测试为绿色时检入VCS系统。</p></li></ol><p id="73bc825a">为此，本教程将更改分组，而不是采用Big Bang方法。</p></section>    <section class="procedure-steps"><h2 id="9350a618">初始设置</h2><ol class="list _decimal"><li class="list__item" id="e505d797"><p>确保使用Java 8 SDK进行编译。如果不是，请将SDK更改为最新版本的Java 8。</p></li><li class="list__item" id="f7ef48cb"><p>在<a href="project-page.html">项目设置中</a> ，您应将语言级别设置为“8.0  -  Lambdas，键入注释”。</p></li></ol><p id="9f6dd602">如果要在CI环境中编译代码，则还需要确保使用Java 8编译新代码。配置它超出了本教程的范围。</p></section>    <section class="procedure-steps"><h2 id="38052c2d">配置和运行语言级别迁移检查</h2><p id="056018f8">您的项目可能已经使用检查来鼓励代码中的某种程度的一致性和质量。为了完全专注于进行与升级到Java 8相关的更改，我们将创建一个新的检查配置文件。</p><ol class="list _decimal"><li class="list__item" id="8950efb1"><p>导航到<a href="code-inspection.html#access-inspections-and-settings">检查设置</a> 。</p></li><li class="list__item" id="5ed735f3"><p>            <a href="customizing-profiles.html">创建一个</a>名为“Java8” <a href="customizing-profiles.html">的新检查配置文件</a> 。</p></li><li class="list__item" id="464d06d2"><p>作为此配置文件的起点，使用“重置为空”按钮取消选择所有内容<img alt="resetProfile.png" title="resetProfile.png" src="../img/idea/2019.1/resetProfile.png" id="3dd9255f" width="20" height="22" class="inline-icon-20"> 。</p></li><li class="list__item" id="23c3b311">我们将选择一组语言迁移检查来指出我们可能要更新的代码部分：<figure><img alt="ij java 8迁移检查" title="ij java 8迁移检查" src="../img/idea/2019.1/ij_java_8_migration_inspections.png" id="0fd62ac5" width="513" height="514"></figure>这些检查将向您显示代码中您可以使用以下Java 8功能的区域：<ul class="list _ul"><li class="list__item" id="1c0f6c6a"><p>                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" data-bypass="yes" target="_blank"><span>Lambda表达式</span></a>                </p></li><li class="list__item" id="62e58357"><p>                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-bypass="yes" target="_blank"><span>方法参考</span></a>                </p></li><li class="list__item" id="e27f71bc"><p>新的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" data-bypass="yes" target="_blank"><span>收集</span></a>方法</p></li><li class="list__item" id="4e3e773e"><p>                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-bypass="yes" target="_blank"><span>Streams API</span></a>                </p></li></ul>        </li><li class="list__item" id="f80579f8"><p>单击“确定”将这些设置保存到“Java8”配置文件并关闭设置窗口。</p></li><li class="list__item" id="c7103f78"><p><a href="running-inspections.html">运行检查</a> ，选择“Java8”配置文件和范围以运行检查。如果您的项目很小，那可能是整个代码库，但更有可能您想要选择一个模块或包来开始。</p></li></ol><p id="4e4af5ff"><span class="control">分析代码</span>运行完毕后，您将在<a href="inspection-results-tool-window.html"><span>检验结果工具窗口中</span></a>看到一组结果。</p></section>    <section class="procedure-steps"><h2 id="665bc070">Lambda表达式</h2><p id="541442ec">检查将显示您可以自动转换代码以使用lambda表达式的位置。在现有代码中，您可能通常会发现许多地方，例如，当您为以下内容创建匿名内部类时：</p><ul class="list _ul"><li class="list__item" id="a9fe7cc4"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" data-bypass="yes" target="_blank"><span>Runnable</span></a> ， <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" data-bypass="yes" target="_blank"><span>Callable</span></a>                    </p></li><li class="list__item" id="c29bbf6f"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" data-bypass="yes" target="_blank"><span>比较</span></a>                    </p></li><li class="list__item" id="d956598e"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileFilter.html" data-bypass="yes" target="_blank"><span>FileFilter</span></a> ， <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html" data-bypass="yes" target="_blank"><span>PathMatcher</span></a>                    </p></li><li class="list__item" id="f1d77a9e"><p>                        <a href="http://docs.oracle.com/javase/8/javafx/api/toc.htm" data-bypass="yes" target="_blank"><span>事件处理程序</span></a>                    </p></li><li class="list__item" id="5bbf44aa"><p>第三方界面，如<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicate.html" data-bypass="yes" target="_blank"><span>番石榴的谓词</span></a>                    </p></li></ul>            <ol class="list _decimal"><li class="list__item" id="f9535b73"><p>在<a href="inspection-results-tool-window.html"><span>检查结果工具窗口中</span></a> ，您应该看到在“Java语言级别迁移辅助工具”下分组的结果。在此标题下，您可能会看到“匿名类型可以替换为lambda”。打开此标题可查看IntelliJ IDEA检测到的代码的所有部分，您可以使用lambda。你可能会看到这样的事情：</p><figure><img alt="ij java 8检查结果迁移runnable" title="ij java 8检查结果迁移runnable" src="../img/idea/2019.1/ij_java_8_inspection_results_migration_runnable.png" id="b528d387" width="1012" height="282"></figure>        </li><li class="list__item" id="17913e49"><p>例如，您可能遇到<code class="code">Runnable</code>匿名内部类：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">executorService</span> <span class="o">。</span> <span class="na"><span class="o">scheduleAtFixedRate（</span></span> <span class="k">新</span> <span class="n">的</span> <span class="nd"><span class="n"><span class="o"><span class="o">Runnable（）{@</span></span></span>覆盖</span> <span class="kd">公共</span> <span class="kt">无效</span> <span class="nf">的<span class="o"><span class="o"><span class="n"><span class="o">run（）{getDs（）</span></span></span></span></span> <span class="na">保存</span> <span class="o">（</span> <span class="k">新</span> <span class="n"><span class="o">CappedPic（</span></span> <span class="n">标题</span> <span class="o"><span class="o"><span class="o"><span class="o"><span class="mi"><span class="o"><span class="mi"><span class="o">））;}}，0，500，</span></span></span></span></span></span></span></span> <span class="n">毫秒</span> <span class="o">）;</span></code></div>        </li><li class="list__item" id="70a9906a">许多检查都提出了可以应用的修复，并且“匿名类型可以替换为lambda”确实具有建议的解决方案。要应用此修复，请：<ul class="list _ul"><li class="list__item" id="bd1c5da9"><p>单击检查窗口右侧的“ <span class="control">问题解决方案</span> ”，在我们的示例中，这是“ <span class="control">替换为lambda”</span> 。</p></li><li class="list__item" id="9a5a91fc"><p>或者在编辑器中的灰色代码上按<kbd data-primary_default="Alt+Enter" data-primary_default_for_gnome="Alt+Enter" data-primary_default_for_kde="Alt+Enter" data-primary_default_for_xwin="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_jbuilder="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_eclipse="Alt+Enter" data-secondary_mac_os_x_10.5_="⌥⏎" data-secondary_mac_os_x="⌥⏎" data-secondary_eclipse_mac_os_x="⌘1" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌥⏎">Alt + Enter</kbd> ，然后选择<span class="control">替换为lambda</span> 。</p></li></ul>        </li><li class="list__item" id="c030e62f"><p>IntelliJ IDEA然后会自动更改上面的代码以使用lambda表达式：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">executorService</span> <span class="o">。</span> <span class="na"><span class="o">scheduleAtFixedRate（（）</span></span> <span class="o">- &gt;</span> <span class="n"><span class="o">getDs（）</span></span> <span class="na">保存</span> <span class="o">（</span> <span class="k">新</span> <span class="n"><span class="o">CappedPic（</span></span> <span class="n">标题</span> <span class="o"><span class="mi"><span class="o"><span class="mi"><span class="o">）），0，500，</span></span></span></span></span> <span class="n">毫秒</span> <span class="o"><span class="o">。）;</span></span></code></div>        </li></ol><p id="2b642b26">您会注意到lambda表达式在类型信息方面的含义非常少。这里，这个lambda代表<code class="code">Runnable</code>一个实现的事实几乎消失了。IntelliJ IDEA将通过左侧装订线中的lambda图标为您提供有关lambda表达式类型的信息：</p><figure><img alt="ij java 8 lambda gutter图标" title="ij java 8 lambda gutter图标" src="../img/idea/2019.1/ij_java_8_lambda_gutter_icon.png" id="1e33d4ea" width="914" height="70"></figure>将鼠标悬停在此将告诉您类型，然后单击可以导航到声明。</section>    <div class="chapter"><h2 id="2e1b51a0">应用lambda表达式的影响</h2>        <p id="faa1aa82">您应该能够自动将此修复程序应用于代码库中找到匿名内部类的所有位置，而不会影响系统中的功能。应用更改通常还会提高代码的可读性，删除样板文件，如上例所示。</p>        <p id="ae424eb0">但是，您可能需要检查每个更改，如下所示：</p><ul class="list _ul"><li class="list__item" id="59fa910f"><p>较大的匿名内部类在lambda表单中可能不是很易读。</p></li><li class="list__item" id="8f2ceb84"><p>您可以进行其他更改和改进。</p></li></ul>                <p id="bfc03081">让我们用一个例子来解决这两点。</p>        <p id="4d9672b9">我们可能正在使用<code class="code">Runnable</code>在我们的测试中对一组特定的断言进行分组：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span> <span class="o">（）</span> <span class="o">{</span> <span class="nd">@ Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span> <span class="o">（）</span> <span class="o">{</span> <span class="n">datastoreProvider</span> <span class="o">。</span> <span class="na">注册</span> <span class="o">（</span> <span class="n">数据库</span> <span class="o">）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s">“身份证<span class="o"><span class="mi"><span class="o">”，1）</span></span></span></span> <span class="na">获得</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，3）</span></span></span></span> <span class="na">得到</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">用户</span> <span class="n">foundUser</span> <span class="o">=</span> <span class="n">数据库</span> <span class="o">。</span> <span class="na">找到</span> <span class="o">（</span> <span class="n">用户</span> <span class="o"><span class="na">一流</span></span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，2）。</span></span></span></span> <span class="na">get</span> <span class="o">（）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na">assertNotNull</span> <span class="o">（</span> <span class="n">foundUser</span> <span class="o">）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNotNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，4）</span></span></span></span> <span class="na">得到</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">断言</span> <span class="o">。</span> <span class="na">的assertEquals（</span> <span class="s"><span class="o"><span class="o"><span class="o">“</span></span></span>应该找到1个朋友<span class="o"><span class="mi"><span class="o"><span class="n">”，1，foundUser</span></span></span></span></span> <span class="na">朋友</span> <span class="na">尺寸</span> <span class="o">（））;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na">的assertEquals（</span> <span class="s"><span class="o">“</span>应该找到合适的朋友<span class="o"><span class="mi"><span class="o"><span class="n">”，4，foundUser</span></span></span></span></span> <span class="na">朋友</span> <span class="na">们</span> <span class="o"><span class="mi"><span class="o">（0）</span></span></span> <span class="na">的标识</span> <span class="o"><span class="o"><span class="o"><span class="o">。）;</span></span></span></span> <span class="o">}</span> <span class="o">};</span></code></div>                <p id="b96fbfda">将其转换为lambda会导致：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">（）</span> <span class="o">- &gt;</span> <span class="o">{</span> <span class="n">datastoreProvider</span> <span class="o">。</span> <span class="na">注册</span> <span class="o">（</span> <span class="n">数据库</span> <span class="o">）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s">“身份证<span class="o"><span class="mi"><span class="o">”，1）</span></span></span></span> <span class="na">获得</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，3）</span></span></span></span> <span class="na">得到</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">用户</span> <span class="n">foundUser</span> <span class="o">=</span> <span class="n">数据库</span> <span class="o">。</span> <span class="na">找到</span> <span class="o">（</span> <span class="n">用户</span> <span class="o"><span class="na">一流</span></span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，2）。</span></span></span></span> <span class="na">get</span> <span class="o">（）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na">assertNotNull</span> <span class="o">（</span> <span class="n">foundUser</span> <span class="o">）;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na"><span class="o">assertNotNull（</span></span> <span class="n">数据库</span> <span class="na">找到</span> <span class="o"><span class="n">（User</span></span> <span class="na">类</span> <span class="o">，</span> <span class="s"><span class="o"><span class="mi"><span class="o">“ID”，4）</span></span></span></span> <span class="na">得到</span> <span class="o"><span class="o"><span class="o"><span class="o">（）。）;</span></span></span></span> <span class="n">断言</span> <span class="o">。</span> <span class="na">的assertEquals（</span> <span class="s"><span class="o"><span class="o"><span class="o">“</span></span></span>应该找到1个朋友<span class="o"><span class="mi"><span class="o"><span class="n">”，1，foundUser</span></span></span></span></span> <span class="na">朋友</span> <span class="na">尺寸</span> <span class="o">（））;</span> <span class="n">断言</span> <span class="o">。</span> <span class="na">的assertEquals（</span> <span class="s"><span class="o">“</span>应该找到合适的朋友<span class="o"><span class="mi"><span class="o"><span class="n">”，4，foundUser</span></span></span></span></span> <span class="na">朋友</span> <span class="na">们</span> <span class="o"><span class="mi"><span class="o">（0）</span></span></span> <span class="na">的标识</span> <span class="o"><span class="o"><span class="o"><span class="o">。）;</span></span></span></span> <span class="o">};</span></code></div>这不会短得多，也不会影响可读性。<p id="7c4ad6cf">在这些情况下，您可以选择使用IntelliJ IDEA的提取方法将这些行转换为单个方法：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">（）</span> <span class="o">- &gt;</span> <span class="o">{</span> <span class="n">assertUserMatchesSpecification</span> <span class="o">（</span> <span class="n">database</span> <span class="o">，</span> <span class="n">datastoreProvider</span> <span class="o">）;</span> <span class="o">};</span></code></div>                <p id="f19e1203">检查所有lambda转换的第二个原因是可以进一步简化一些lambdas。最后一个示例是其中之一 -  IntelliJ IDEA将以灰色显示花括号，按住<kbd data-primary_default="Alt+Enter" data-primary_default_for_gnome="Alt+Enter" data-primary_default_for_kde="Alt+Enter" data-primary_default_for_xwin="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_jbuilder="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_eclipse="Alt+Enter" data-secondary_mac_os_x_10.5_="⌥⏎" data-secondary_mac_os_x="⌥⏎" data-secondary_eclipse_mac_os_x="⌘1" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌥⏎">Alt + Enter</kbd>并使用光标在大括号上弹出建议的更改<span class="control">语句lambda可以替换为表达式lambda</span> ：</p>        <p id="957f8594"></p><figure><img alt="ij java 8语句lambda可以替换" title="ij java 8语句lambda可以替换" src="../img/idea/2019.1/ij_java_8_statement_lambda_can_be_replaced.png" id="4796e4b2" width="536" height="62"></figure>        <p id="679740c4">接受此更改将导致：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">（）</span> <span class="o">- &gt;</span> <span class="n">assertUserMatchesSpecification</span> <span class="o">（</span> <span class="n">database</span> <span class="o">，</span> <span class="n">datastoreProvider</span> <span class="o">）;</span></code></div>                <p id="df9a75a0">一旦您将匿名内部类更改为lambda并进行了任何手动调整，您可能需要进行调整，例如提取方法或重新格式化代码，运行所有测试以确保一切仍然有效。如果是这样，请将这些更改提交给VCS。完成此操作后，您将准备好进入下一步。</p>    </div>    <section class="procedure-steps"><h2 id="5d57c21c">新的收集方法</h2><p id="665509bc">Java 8通过Streams API引入了一种处理数据集合的新方法。不太为人所知的是，我们习惯使用的许多<code class="code">Collection</code>类都有新的方法，而不是通过Streams API。例如， <code class="code">java.util.Iterable</code>有一个<code class="code">forEach</code>方法，允许您传入一个lambda，该lambda表示在每个元素上运行的操作。IntelliJ IDEA的检查将突出显示您可以使用此方法和其他新方法的区域。</p><ol class="list _decimal"><li class="list__item" id="8bc09e0d"><p>回到<a href="inspection-results-tool-window.html"><span>检查结果工具窗口</span></a> ，您应该在“Java语言级别迁移辅助工具”下看到“foreach可以使用流api折叠”。您可能没有意识到何时进行所有检查，但并非所有这些修复都将使用Streams API（稍后有关Streams的更多信息）。例如：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="k">for</span> <span class="o">（</span> <span class="n">Class</span> <span class="o">&lt;？</span> <span class="kd">extends</span> <span class="n">Annotation</span> <span class="o">&gt;</span> <span class="n">annotation</span> <span class="o">：</span> <span class="n">INTERESTING_ANNOTATIONS</span> <span class="o">）</span> <span class="o">{</span> <span class="n">addAnnotation</span> <span class="o">（</span> <span class="n">annotation</span> <span class="o">）;</span> <span class="o">}</span></code></div>IntelliJ IDEA建议“可以用foreach调用替换”。应用此检查为我们提供：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">有趣的事情</span> <span class="o">。</span> <span class="na">forEach</span> <span class="o">（</span> <span class="k">this</span> <span class="o">::</span> <span class="n">addAnnotation</span> <span class="o">）;</span></code></div>请注意，IntelliJ IDEA已经应用了所有简化，直到使用<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-bypass="yes" target="_blank"><span>方法参考</span></a>而不是lambda。方法引用是Java 8中的另一个新特性，通常可以在lambda表达式通常调用单个方法的地方使用。</li><li class="list__item" id="b6b2e10f"><p>方法引用需要一段时间才能习惯，因此您可能更愿意将其扩展为lambda以查看lambda版本：</p><figure><img alt="ij java 8用lambda替换方法引用" title="ij java 8用lambda替换方法引用" src="../img/idea/2019.1/ij_java_8_replace_method_reference_with_lambda.png" id="ba867f5d" width="616" height="82"></figure>在方法参考上按<kbd data-primary_default="Alt+Enter" data-primary_default_for_gnome="Alt+Enter" data-primary_default_for_kde="Alt+Enter" data-primary_default_for_xwin="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_jbuilder="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_eclipse="Alt+Enter" data-secondary_mac_os_x_10.5_="⌥⏎" data-secondary_mac_os_x="⌥⏎" data-secondary_eclipse_mac_os_x="⌘1" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌥⏎">Alt + Enter</kbd> ，然后单击<span class="control">使用lambda替换方法引用</span> 。当您习惯所有新语法时，这尤其有用。在lambda形式中，它看起来像：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">有趣的事情</span> <span class="o">。</span> <span class="na">forEach</span> <span class="o">（（</span> <span class="n">annotation</span> <span class="o">）</span> <span class="o">- &gt;</span> <span class="n">addAnnotation</span> <span class="o">（</span> <span class="n">annotation</span> <span class="o">））;</span></code></div>        </li></ol><p id="e8ff86c0">两个新表单与原始代码完全相同 - 对于<code class="code">INTERESTING_ANNOTATIONS</code>列表中的每个项目，它<code class="code">addAnnotation</code>使用该项目调用<code class="code">addAnnotation</code> 。</p></section>    <section class="procedure-steps"><h2 id="f957bcbc">Streams API  -  foreach</h2><p id="2e154b2e">IntelliJ IDEA的检查将建议在适当的时候使用<code class="code">forEach</code> on <code class="code">Iterable</code> ，但它也是新的Streams API，这是一个更好的选择。</p><p id="e529f7db"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-bypass="yes" target="_blank"><span>Streams API</span></a>是一个用于查询和操作数据的强大工具，使用它可以显着改变和简化您编写的代码。在本教程中，我们将介绍一些最简单的用例，以帮助您入门。一旦您使用这种编码风格更加舒适，您可能希望进一步使用其功能。</p><ol class="list _decimal"><li class="list__item" id="df1ac60e"><p>Streams API为我们提供了什么，我们不能简单地使用<code class="code">forEach</code>方法？让我们看一个比前一个更复杂的循环示例：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">公共</span> <span class="kt">无效</span> <span class="nf"><span class="o">addAllBooksToLibrary（</span></span> <span class="n">集</span> <span class="o">&lt;</span> <span class="n">书</span> <span class="o">&gt;</span> <span class="n">书籍</span> <span class="o"><span class="o">）{</span></span> <span class="k">为</span> <span class="o">（</span> <span class="n">书</span> <span class="n">书</span> <span class="o">：</span> <span class="n">书籍</span> <span class="o"><span class="o">）{</span></span> <span class="k">如果</span> <span class="o">（</span> <span class="n">书</span> <span class="o"><span class="na"><span class="o"><span class="o">isInPrint（））{</span></span></span></span> <span class="n">库</span> <span class="o">。</span> <span class="na">添加</span> <span class="o">（</span> <span class="n">书</span> <span class="o">）;</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span></code></div>首先，循环体检查某些条件，然后对通过该条件的项执行某些操作。</li><li class="list__item" id="52436787"><p>选择修复<span class="control">替换为forEach</span>将使用Streams API执行相同的操作：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAllBooksToLibrary</span> <span class="o">（</span> <span class="n">Set</span> <span class="o">&lt;</span> <span class="n">Book</span> <span class="o">&gt;</span> <span class="n">books</span> <span class="o">）</span> <span class="o">{</span> <span class="n">books</span> <span class="o">。</span> <span class="na">stream</span> <span class="o">（）</span> <span class="o">。</span> <span class="na">过滤器</span> <span class="o">（</span> <span class="n">本书</span> <span class="o">- &gt;</span> <span class="n">书</span> <span class="o"><span class="na"><span class="o"><span class="o">isInPrint（））。</span></span></span></span> <span class="na">forEach</span> <span class="o">（</span> <span class="n">library</span> <span class="o">::</span> <span class="n">add</span> <span class="o">）;</span> <span class="o">}</span></code></div>在这种情况下，IntelliJ IDEA为<code class="code">forEach</code>参数选择了方法引用。对于过滤器，IntelliJ IDEA使用了lambda，但会在编辑器中建议此特定示例可以使用方法引用：<figure><img alt="ij java 8可以用方法ref替换" title="ij java 8可以用方法ref替换" src="../img/idea/2019.1/ij_java_8_can_be_replaced_with_method_ref.png" id="ef6c7de8" width="535" height="102"></figure>        </li><li class="list__item" id="a855a6b0"><p>应用此修复程序给出：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">书籍</span> <span class="o">。</span> <span class="na">stream</span> <span class="o">（）</span> <span class="o">。</span> <span class="na">过滤器</span> <span class="o">（</span> <span class="n">Book</span> <span class="o">::</span> <span class="n">isInPrint</span> <span class="o">）</span> <span class="o">。</span> <span class="na">forEach</span> <span class="o">（</span> <span class="n">library</span> <span class="o">::</span> <span class="n">add</span> <span class="o">）;</span></code></div>        </li></ol></section>    <section class="procedure-steps"><h2 id="df9b15e2">Streams API  - 收集</h2><p id="81f1a9c5">而不是“可以用foreach替换”电话，你可能会看到“可以用收集电话取代”。这与上面的示例非常相似，但它不是在流的末尾调用<code class="code">forEach</code>方法并执行某些操作，而是使用流的collect方法将流操作的所有结果放入新的<code class="code">Collection</code> 。通常会看到<code class="code">for</code>循环遍历某个集合，执行某种过滤或操作，并将结果输出到新集合中，这就是此检查将使用Streams API识别和迁移的代码类型。</p><ol class="list _decimal"><li class="list__item" id="5febaecd"><p>在<a href="inspection-results-tool-window.html"><span>检查结果工具窗口中</span></a> ，您应该在“Java语言级别迁移辅助工具”下看到“foreach可以替换为collect调用”。选择其中一个检查结果将显示一个可能类似于的for循环：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">列表</span> <span class="o">&lt;</span> <span class="n">Key</span> <span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="o">....</span>

<span class="n">列表</span> <span class="o">&lt;</span> <span class="n">键</span> <span class="o">。</span><span class="na">Id</span> <span class="o">&gt;</span> <span class="n">objIds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span> <span class="o">&lt;</span> <span class="n">Key</span> <span class="o">。</span><span class="na">Id</span> <span class="o">&gt;（）;</span> <span class="k">for</span> <span class="o">（</span> <span class="n">Key</span> <span class="n">key</span> <span class="o">：</span> <span class="n">keys</span> <span class="o">）</span> <span class="o">{</span> <span class="n">objIds</span> <span class="o">。</span> <span class="na">添加</span> <span class="o">（</span> <span class="n">键</span> <span class="na">的<span class="o"><span class="o">getId（））;</span></span></span> <span class="o">}</span></code></div>在这里，我们循环遍历Key对象列表，从每个对象中获取Id，并将它们全部放入一个单独的objIds集合中。</li><li class="list__item" id="1772da7a"><p>应用<span class="control">Replace with collect</span> fix将此代码转换为：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">列表</span> <span class="o">&lt;</span> <span class="n">键</span> <span class="o">。</span><span class="na">Id</span> <span class="o">&gt;</span> <span class="n">objIds</span> <span class="o">=</span> <span class="n">键</span> <span class="o">。</span> <span class="na">stream</span> <span class="o">（）。</span> <span class="na">map</span> <span class="o">（</span> <span class="n">Key</span> <span class="o">::</span> <span class="n">getId</span> <span class="o">）。</span> <span class="na">收集</span> <span class="o">（</span> <span class="n">收藏家</span> <span class="o"><span class="na"><span class="o">toList（））;</span></span></span></code></div>        </li><li class="list__item" id="aaac9ebc"><p>重新格式化此代码，以便您可以更清楚地查看所有Stream操作：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">列表</span> <span class="o">&lt;</span> <span class="n">键</span> <span class="o">。</span><span class="na">Id</span> <span class="o">&gt;</span> <span class="n">objIds</span> <span class="o">=</span> <span class="n">键</span> <span class="o">。</span> <span class="na">stream</span> <span class="o">（）</span> <span class="o">。</span> <span class="na">map</span> <span class="o">（</span> <span class="n">Key</span> <span class="o">::</span> <span class="n">getId</span> <span class="o">）</span> <span class="o">。</span> <span class="na">收集</span> <span class="o">（</span> <span class="n">收藏家</span> <span class="o"><span class="na"><span class="o">toList（））;</span></span></span></code></div>这与原始代码完全相同 - 采用<code class="code">Key</code>的集合，将每个<code class="code">Key</code> “映射”到其<code class="code">Id</code> ，并将它们收集到新的列表中， <code class="code">objIds</code> 。</li></ol><p id="a31f6f24">与<code class="code">forEach</code>示例一样，如果过滤器需要应用于collect语句以及映射，IntelliJ IDEA可以解决，因此它可以巧妙地将许多复杂循环转换为一组Stream操作。</p></section>    <div class="chapter"><h2 id="a5770b9a">使用Streams替换foreach的影响</h2>        <p id="e3b43b08">可能很有可能运行这些检查并自动应用所有修复。在转换代码以在集合或流上使用新方法时，应该稍加注意。IDE将确保您的代码以与以前相同的方式工作，但您需要在应用更改后检查代码是否仍然可读且易于理解。如果您和您的团队第一次使用Java 8功能，那么一些新代码将非常陌生并且可能不清楚。花些时间单独查看每个更改，并确保您在开始之前了解新代码。</p>        <p id="5145315e">与lambdas一样，一个好的经验法则是从小部分代码开始 - 简短的循环转换为两个或更少的流操作，最好是单行lambdas。随着您对这些方法越来越熟悉，您可能希望解决更复杂的代码问题。</p>        <p id="7a3844a1">我们来看一个例子：</p>        <p id="126f81e1">IntelliJ IDEA建议这段代码：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="k">for</span> <span class="o">（</span> <span class="n">Entry</span> <span class="o">&lt;</span> <span class="n">Class</span> <span class="o">&lt;？</span> <span class="kd">扩展</span> <span class="n">Annotation</span> <span class="o">&gt;，</span> <span class="n">List</span> <span class="o">&lt;</span> <span class="n">Annotation</span> <span class="o">&gt;&gt;</span> <span class="n">e</span> <span class="o">：</span> <span class="n">getAnnotations</span> <span class="o">（）。</span> <span class="na">的<span class="o"><span class="o">entrySet（））{</span></span></span> <span class="k">如果</span> <span class="o">（</span> <span class="n"><span class="o">即</span></span> <span class="na">的<span class="o"><span class="o">getValue（）！</span></span>=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">！</span><span class="n">e</span> <span class="o">。</span> <span class="na">getValue</span> <span class="o">（）。</span> <span class="na">的<span class="o"><span class="o">isEmpty（））{</span></span></span> <span class="k">对于</span> <span class="o">（</span> <span class="n">译注</span> <span class="n">注释</span> <span class="o">：</span> <span class="n"><span class="o">即</span></span> <span class="na">的<span class="o"><span class="o">getValue（））{</span></span></span> <span class="n">目的地</span> <span class="o">。</span> <span class="na"><span class="o"><span class="n">addAnnotation（E</span></span></span> <span class="na">信息<span class="o">getKey（），</span></span> <span class="n">注释</span> <span class="o"><span class="o">。）;</span></span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span></code></div>可以转换为这段代码：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">getAnnotations</span> <span class="o">（）。</span> <span class="na">entrySet</span> <span class="o">（）</span> <span class="o">。</span> <span class="na">stream</span> <span class="o">（）</span> <span class="o">。</span> <span class="na">过滤器</span> <span class="o"><span class="n">（E</span></span> <span class="o"><span class="o">-</span> &gt;</span> <span class="n">电子</span> <span class="na">的<span class="o"><span class="o">getValue（）！</span></span>=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">！</span><span class="n">e</span> <span class="o">。</span> <span class="na">getValue</span> <span class="o">（）。</span> <span class="na">isEmpty</span> <span class="o">（））</span> <span class="o">。</span> <span class="na">的<span class="o"><span class="n">forEach（E</span></span></span> <span class="o">- &gt;</span> <span class="o">{</span> <span class="k">对于</span> <span class="o">（</span> <span class="n">译注</span> <span class="n">注释</span> <span class="o"><span class="o"><span class="o">：。</span></span></span> <span class="n"><span class="o">即</span></span> <span class="na">的<span class="o"><span class="o">getValue（））{</span></span></span> <span class="n">目的地</span> <span class="na"><span class="o"><span class="n">addAnnotation（E</span></span></span> <span class="na">信息<span class="o">getKey（），</span></span> <span class="n">注释</span> <span class="o"><span class="o"><span class="o">）;}}）;</span></span></span></code></div>撇开原始代码开始时难以理解的事实，您可以选择不应用更改，原因如下：<ul class="list _ul"><li class="list__item" id="99c81e08"><p>尽管重构了外循环，但<code class="code">forEach</code>方法中仍然存在for循环。这表明可能有不同的方式来构造流调用，可能使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" data-bypass="yes" target="_blank"><span>flatMap</span></a> 。</p></li><li class="list__item" id="10579775"><p><code class="code">destination.addAnnotation</code>方法表明可能有一种方法可以重新构造它以使用<code class="code">collect</code>调用而不是<code class="code">forEach</code> 。</p></li><li class="list__item" id="0384ab24"><p>它可能比原始代码更容易理解。</p></li></ul>但是，您可以选择接受此更改，原因如下：<ul class="list _ul"><li class="list__item" id="f5bdd8c4"><p>这是一段复杂的代码，它迭代并处理集合中的数据，因此向Streams API的转变是朝着正确的方向发展。当团队的开发人员更熟悉Streams的工作方式时，可以进一步重构或改进。</p></li><li class="list__item" id="b452f608"><p>在新代码中， <code class="code">if</code>条件已被移入<code class="code">filter</code>调用，使代码的这一部分更清楚。</p></li></ul>除了“保持代码”和“应用更改”选项之外，还有第三种选择：将旧代码重构为更易读的内容，即使它不使用Java 8。这可能是一段很好的代码，可以在以后重构，而不是试图解决所有代码的问题，而只是尝试采用更多的Java 8约定。</div>    <section class="procedure-steps"><h2 id="5633d9d1">新的日期和时间API</h2><p id="d89133d3">我们为“Java8”配置文件选择的检查帮助我们找到可以使用lambda表达式的位置，集合上的新方法和Streams API，并将自动应用修复程序到这些位置。Java 8中还有许多其他新功能，在下面的部分中，我们将重点介绍IntelliJ IDEA的一些功能，这些功能也可以帮助您使用它们。</p><p id="82bf94a8">在本节中，我们将介绍如何使用新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-bypass="yes" target="_blank"><span>Date和Time API</span></a>而不是<code class="code">java.util.来定位可能会受益的地方<code class="code">java.util.Date</code>和<code class="code">java.util.Calendar</code> 。</p><ol class="list _decimal"><li class="list__item" id="255c1043"><p>您需要启用新检查以查找旧Date和Time API的使用。</p><figure><img alt="ij java 8日期时间检查" title="ij java 8日期时间检查" src="../img/idea/2019.1/ij_java_8_date_time_inspection.png" id="97b45289" width="382" height="265"></figure>请注意，尽管<code class="code">java.util.上已经弃用了许多方法<code class="code">java.util.一段时间的Date</code> ，类本身不会被弃用，因此如果您在代码中使用它，则不会收到弃用警告。这就是为什么这种检查对于定位用法很有用。</li><li class="list__item" id="066866af"><p>            <a href="running-inspections.html">运行检查</a> 。您应该看到一个结果列表，如下所示：</p><figure><img alt="ij java 8日期时间检查结果" title="ij java 8日期时间检查结果" src="../img/idea/2019.1/ij_java_8_date_time_inspection_results.png" id="32965115" width="449" height="356"></figure>        </li><li class="list__item" id="af6b1312"><p>与之前的检查不同，这些检查没有建议的修复，因为它们将要求您和您的团队评估旧类的使用并决定如何将它们迁移到新API。如果您有一个<code class="code">Date</code>字段，表示没有时间的单个日期，例如：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">公共</span> <span class="kd">类</span> <span class="o">{</span> <span class="nc">大全</span> <span class="kd">私人</span> <span class="kd">最终</span> <span class="n">酒店</span> <span class="n">宾馆</span> <span class="o">;</span> <span class="kd">私人</span> <span class="kd">最终</span> <span class="n">日期</span> <span class="n">checkInDate</span> <span class="o">;</span> <span class="kd">私人</span> <span class="kd">最终</span> <span class="n">日期</span> <span class="n">checkOutDate</span> <span class="o">;</span> <span class="c1">//构造函数，getter和setter ......</span>
<span class="o">}</span></code></div>您可以选择将其替换为<code class="code">LocalDate</code> 。这可以通过上下文菜单<span class="control">Refactor |</span>来完成<span class="control">键入Migration ...</span>或通过<kbd data-primary_default="Ctrl+Shift+F6" data-primary_default_for_gnome="Ctrl+Shift+F6" data-primary_default_for_kde="Ctrl+Shift+F6" data-primary_default_for_xwin="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_jbuilder="Ctrl+Shift+F6" data-primary_visual_studio="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-secondary_mac_os_x_10.5_="⇧⌘F6" data-secondary_mac_os_x="⇧⌘F6" data-secondary_eclipse_mac_os_x="N/A" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⇧F6">Ctrl + Shift + F6</kbd> 。在弹出窗口中键入LocalDate，然后选择<code class="code">java.time.LocalDate</code> 。当您按Enter键时，这将更改此字段的类型以及getter和setter。您可能仍需要解决使用字段，getter或setter的编译错误。</li><li class="list__item" id="ab040ca5"><p>对于同时具有日期和时间的字段，您可以选择将这些<code class="code">java.time.迁移到<code class="code">java.time.LocalDateTime</code> 。对于只有时间的字段， <code class="code">java.time.LocalTime</code>可能是合适的。</p></li><li class="list__item" id="69c764eb"><p>如果您使用新<code class="code">Date</code>设置原始值，则知道这与现在的日期和时间等效：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">预订</span> <span class="o">。</span> <span class="na">setCheckInDate</span> <span class="o">（</span> <span class="k">new</span> <span class="n">Date</span> <span class="o">（））;</span></code></div>你可以使用<code class="code">now()</code>方法：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">预订</span> <span class="o">。</span> <span class="na"><span class="o">setCheckInDate（</span></span> <span class="na">现在</span> <span class="n"><span class="o"><span class="o">LOCALDATE（））;</span></span></span></code></div>        </li><li class="list__item" id="1bfe0b0b"><p>为<code class="code">java.util.设置值的常用且可读的方法<code class="code">java.util.Date</code>是使用<code class="code">java.text.SimpleDateFormat</code> 。您可能会看到类似于以下内容的代码：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">SimpleDateFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleDateFormat</span> <span class="o">（</span> <span class="s">“yyyy-MM-dd”</span> <span class="o">）;</span> <span class="n">预订</span> <span class="o">。</span> <span class="na"><span class="o">setCheckInDate（</span></span> <span class="n">格式</span> <span class="na">解析</span> <span class="o">（</span> <span class="s">“2017年3月2日<span class="o"><span class="o">”））;</span></span></span></code></div>如果此签入日期已迁移到<code class="code">LocalDate</code> ，您可以轻松地将其设置为特定日期，而无需使用格式化程序：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">预订</span> <span class="o">。</span> <span class="na"><span class="o">setCheckInDate（</span></span> <span class="na">的</span> <span class="mi"><span class="o">（2017</span>年</span> <span class="o"><span class="mi">，3</span></span> <span class="n"><span class="o"><span class="o"><span class="mi"><span class="o">LOCALDATE，2））;</span></span></span></span></span></code></div>        </li></ol><p id="4b039774">这些示例几乎没有抓住您可能想要或需要做的更改的表面，以便充分利用Java 8中的新日期和时间功能。查看<a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" data-bypass="yes" target="_blank"><span>Oracle提供</span></a>的<a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" data-bypass="yes" target="_blank"><span>教程</span></a> ，了解有关新API功能及其使用方法的更多信息。</p></section>    <div class="chapter"><h2 id="72d9f51b">迁移到新的Date和Time API的影响</h2>        <p id="f8048afd">更新代码以使用新的日期和时间API需要比将匿名内部类迁移到Lambda表达式和循环到Streams API更多的手动干预。 IntelliJ IDEA将帮助您了解使用旧<code class="code">java.util.程度和位置<code class="code">java.util.Date</code>和<code class="code">java.util.Calendar</code>类，可帮助您了解迁移的范围。IntelliJ IDEA的重构工具可以帮助您在必要时迁移这些类型。但是，您需要制定策略，了解如何处理每个更改，要使用的新类型以及如何正确使用这些更改。这不是您可以自动应用的更改。</p>    </div>    <section class="procedure-steps"><h2 id="e739c7c3">使用可选</h2><p id="342e0295">我们将看到的最后一个Java 8功能是新的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-bypass="yes" target="_blank"><span>Optional</span></a>类型。 <code class="code">java.util.Optional</code>为您提供了一种处理空值的方法，以及一种指定方法调用是否应返回空值的方法。与日期和时间一样，IntelliJ IDEA的功能将帮助您识别可能从使用<code class="code">Optional</code>类型中受益的代码区域。</p><ol class="list _decimal"><li class="list__item" id="4fbbd69d"><p>有许多检查在Java代码中查找使用null，这些检查可用于识别可能从使用<code class="code">Optional</code>获益的区域。为简单起见，我们将考虑仅启用其中两项检查：</p><figure><img alt="ij java 8 null检查" title="ij java 8 null检查" src="../img/idea/2019.1/ij_java_8_null_inspections.png" id="bc104e7d" width="363" height="473"></figure>        </li><li class="list__item" id="69af3bf1"><p>            <a href="running-inspections.html">运行代码分析</a> 。您应该看到一个结果列表，如下所示：</p><figure><img alt="ij java 8 null检查结果" title="ij java 8 null检查结果" src="../img/idea/2019.1/ij_java_8_null_inspection_results.png" id="876a1480" width="427" height="321"></figure>        </li><li class="list__item" id="d17352e1"><p>如果您看到字段的“Assignment to null”，您可能需要考虑将此字段转换为<code class="code">Optional</code> 。例如，在下面的代码中，将标记分配了偏移量的行：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">私有</span> <span class="n">整数</span> <span class="n">偏移量</span> <span class="o">;</span> <span class="c1">//代码....</span>

<span class="kd">public</span> <span class="n">Builder</span> <span class="nf">offset</span> <span class="o">（</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">）</span> <span class="o">{</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">？</span> <span class="n">value</span> <span class="o">：</span> <span class="kc">null</span> <span class="o">;</span> <span class="k">归还</span> <span class="k">这个</span> <span class="o">;</span> <span class="o">}</span> <span class="c1">//更多代码......</span></code></div>那是因为在另一种方法中，代码在用它做某事之前检查是否已经设置了这个值：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="k">if</span> <span class="o">（</span> <span class="n">偏移</span> <span class="o">！=</span> <span class="kc">null</span> <span class="o">）</span> <span class="o">{</span> <span class="n">cursor</span> <span class="o">。</span> <span class="na">跳过</span> <span class="o">（</span> <span class="n">偏移</span> <span class="o">）;</span> <span class="o">}</span></code></div>在这种情况下，null是offset的有效值 - 它表示尚未设置，因此不应使用。您可能希望通过<kbd data-primary_default="Ctrl+Shift+F6" data-primary_default_for_gnome="Ctrl+Shift+F6" data-primary_default_for_kde="Ctrl+Shift+F6" data-primary_default_for_xwin="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_jbuilder="Ctrl+Shift+F6" data-primary_visual_studio="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-secondary_mac_os_x_10.5_="⇧⌘F6" data-secondary_mac_os_x="⇧⌘F6" data-secondary_eclipse_mac_os_x="N/A" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⇧F6">Ctrl + Shift + F6</kbd>将字段更改为<code class="code">Optional</code>的<code class="code">Integer</code> ，并更改值的设置方式：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">private</span> <span class="n">可选</span> <span class="o">&lt;</span> <span class="n">Integer</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">;</span> <span class="c1">//代码......</span>

<span class="kd">public</span> <span class="n">Builder</span> <span class="nf">offset</span> <span class="o">（</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">）</span> <span class="o">{</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">？</span> <span class="n">可选</span> <span class="o">。</span> <span class="na">of</span> <span class="o">（</span> <span class="n">value</span> <span class="o">）</span> <span class="o">：</span> <span class="n">可选</span> <span class="o">。</span> <span class="na">empty</span> <span class="o">（）;</span> <span class="k">归还</span> <span class="k">这个</span> <span class="o">;</span> <span class="o">}</span> <span class="c1">//更多代码......</span></code></div>然后，您可以使用<code class="code">Optional</code>上的方法而不是执行空检查。最简单的解决方案是：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="k">如果</span> <span class="o">（</span> <span class="n">偏移</span> <span class="o"><span class="na"><span class="o"><span class="o">。isPresent（））{</span></span></span></span> <span class="n">光标</span> <span class="o">。</span> <span class="na">跳过</span> <span class="o">（</span> <span class="n">偏移</span> <span class="o">）;</span> <span class="o">}</span></code></div>但是使用Lambda Expression来定义如何处理该值会更加优雅：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">偏移</span> <span class="o">。</span> <span class="na"><span class="o"><span class="o">ifPresent（。（）</span></span></span> <span class="o">- &gt;</span> <span class="n">光标</span> <span class="na">跳过</span> <span class="o">（</span> <span class="n">偏移</span> <span class="o">））;</span></code></div>        </li><li class="list__item" id="855e6068"><p>检查还指示方法返回null的位置。如果您有一个可以返回null值的方法，则调用此方法的代码应检查它是否返回null并采取适当的操作。但是很容易忘记这样做，特别是如果开发人员不知道该方法可以返回null。更改这些方法以返回<code class="code">Optional</code>会使其更加明确，这可能不会返回值。例如，我们的检查可能会将此方法标记为返回null值：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">公众</span> <span class="n">客户</span> <span class="nf">的<span class="o"><span class="o">FindFirst（）{</span></span></span> <span class="k">如果</span> <span class="o">（</span> <span class="n">客户</span> <span class="na">的<span class="o"><span class="o"><span class="o">isEmpty（））{</span></span></span></span> <span class="k">返回</span> <span class="kc"><span class="o">NULL;</span></span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="k">返回</span> <span class="n">客户</span> <span class="o">。</span> <span class="na">得到</span> <span class="o">（</span> <span class="mi">0</span> <span class="o">）;</span> <span class="o">}</span> <span class="o">}</span></code></div>我们可以改变这个方法来返回一个<code class="code">Optional</code>的<code class="code">Customer</code> ：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">公众</span> <span class="n">可选</span> <span class="o">&lt;</span> <span class="n">客户</span> <span class="o">&gt;</span> <span class="nf">的<span class="o"><span class="o">FindFirst（）{</span></span></span> <span class="k">如果</span> <span class="o">（</span> <span class="n">客户</span> <span class="o">。</span> <span class="na">的<span class="o"><span class="o">isEmpty（））{</span></span></span> <span class="k">返回</span> <span class="n">可选</span> <span class="o">。</span> <span class="na">empty</span> <span class="o">（）;</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="k">return</span> <span class="n">可选</span> <span class="o">。</span> <span class="na"><span class="o">ofNullable（</span></span> <span class="n">客户</span> <span class="na">得到</span> <span class="o"><span class="o"><span class="mi"><span class="o">（0））;</span></span></span></span> <span class="o">}</span> <span class="o">}</span></code></div>        </li><li class="list__item" id="df23d2ca"><p>您需要更改调用这些方法的代码来处理<code class="code">Optional</code>类型。如果该值不存在，这可能是决定该怎么做的正确位置。在上面的示例中，调用<code class="code">findFirst</code>方法的代码可能看起来像这样：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">客户</span> <span class="n">至上</span> <span class="n">顾客</span> <span class="o">=</span> <span class="n">客户道</span> <span class="o">。</span> <span class="na">findFirst</span> <span class="o">（）;</span> <span class="k">if</span> <span class="o">（</span> <span class="n">firstCustomer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">）</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">CustomerNotFoundException</span> <span class="o">（）;</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="n">firstCustomer</span> <span class="o">。</span> <span class="na">setNewOffer</span> <span class="o">（</span> <span class="n">offer</span> <span class="o">）;</span> <span class="o">}</span></code></div>但是我们现在返回一个<code class="code">Optional</code> ，我们可以消除null检查：<div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">可选</span> <span class="o">&lt;</span> <span class="n">Customer</span> <span class="o">&gt;</span> <span class="n">firstCustomer</span> <span class="o">=</span> <span class="n">customerDao</span> <span class="o">。</span> <span class="na">findFirst</span> <span class="o">（）;</span> <span class="n">firstCustomer</span> <span class="o">。</span> <span class="na">orElseThrow</span> <span class="o">（（）</span> <span class="o">- &gt;</span> <span class="k">new</span> <span class="n">CustomerNotFoundException</span> <span class="o">（））</span> <span class="o">。</span> <span class="na">setNewOffer</span> <span class="o">（</span> <span class="n">offer</span> <span class="o">）;</span></code></div>        </li></ol></section>    <div class="chapter"><h2 id="d715dac0">迁移到Optional的影响</h2>        <p id="b11a7c58">将字段类型更改为“ <code class="code">Optional</code>会产生很大影响，并且自动执行所有操作并不容易。首先，尝试在类中继续使用<code class="code">Optional</code> - 如果您可以将该字段更改为<code class="code">Optional</code>尝试不通过getter和setter公开它，这将允许您进行更渐进的迁移。</p>        <p id="73237bbb">将方法返回类型更改为<code class="code">Optional</code>会产生更大的影响，您可能会发现这些更改会以意想不到的方式影响您的代码库。将此方法应用于可以为null的所有值可能会导致代码中的<code class="code">Optional</code>变量和字段，执行<code class="code">isPresent</code>检查或使用<code class="code">Optional</code>方法执行操作或抛出适当的异常。</p>        <p id="38f1b2f3">请记住，在Java 8中使用新功能的目的是简化代码并提高可读性，因此将更改的范围限制为代码的小部分，并检查使用<code class="code">Optional</code>是否使代码更易于理解，而不是更困难保持。</p>        <p id="87eb57df">IntelliJ IDEA的检查将确定可能的变更地点，重构工具可以帮助应用这些变更，但重构为<code class="code">Optional</code>会产生很大的影响，您和您的团队应该确定一个策略，以便更改哪些区域以及如何处理这些变更。您甚至可以使用“Annotate field [fieldName] as @Nullable”的建议修订来标记那些可以迁移到<code class="code">Optional</code>候选字段，以便朝着该方向迈出一步，对代码的影响更小。</p>    </div>    <div class="chapter"><h2 id="6cb0a49e">摘要</h2>        <p id="0334d638">IntelliJ IDEA的检查，特别是那些围绕语言迁移的检查，可以帮助识别代码中可以重构以使用Java 8功能的区域，甚至可以自动应用这些修复。</p>        <p id="b384f309">如果您已自动应用这些修补程序，那么查看更新的代码以检查它是否难以理解并帮助您熟悉新功能是很有价值的。</p>        <p id="06a9069e">本教程提供了有关如何迁移代码的一些指示。我们已经介绍了<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" data-bypass="yes" target="_blank"><span>lambda表达式</span></a>和<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-bypass="yes" target="_blank"><span>方法引用</span></a> ，一些关于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" data-bypass="yes" target="_blank"><span>Collection的</span></a>新方法，引入了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-bypass="yes" target="_blank"><span>Streams API</span></a> ，展示了IntelliJ IDEA如何帮助您使用新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-bypass="yes" target="_blank"><span>Date和Time API，</span></a>并研究了如何识别可能从使用new的新<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-bypass="yes" target="_blank"><span>选项中</span></a>获益的地方类型。</p>        <p id="cfb353c4">Java 8中有许多新功能，旨在使程序员的工作更轻松 - 使代码更具可读性，并使其更容易在数据结构上执行复杂的操作。IntelliJ IDEA当然不仅支持这些功能，还可以帮助开发人员使用它们，包括迁移现有代码并在编辑器中提供帮助和建议，以便在您使用它们时为您提供指导。</p>    </div><div class="last-modified" data-skip-index="skip">最后修改日期：2019年3月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="debugging-your-first-java-application.html">调试您的第一个Java应用程序</a> <a class="navigation-links__next" href="getting-started-with-java-9-module-system.html">Java 9模块系统入门</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="../app/v2/app.js"></script></body></html>