<html lang="en-US" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="../app/v2/analytics.js"></script><link rel="canonical" href="tutorial-introduction-to-refactoring.html"></link><meta charset="UTF-8"></meta><title>重构简介 - 帮助| IntelliJ IDEA</title><link rel="stylesheet" href="../app/v2/app.css"></link></head><body dir="ltr" data-id="Tutorial_Introduction_to_Refactoring"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索IntelliJ IDEA帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="tutorial-introduction-to-refactoring.html#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">键盘布局</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected="">Windows / Linux默认值</option><option value="primary_default_for_gnome" data-group="primary">GNOME</option><option value="primary_default_for_kde" data-group="primary">KDE</option><option value="primary_default_for_xwin" data-group="primary">XWin中</option><option value="primary_emacs" data-group="primary">Emacs的</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="primary_netbeans" data-group="primary">NetBeans的</option><option value="primary_eclipse" data-group="primary">日食</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">默认（Mac OS X 10.5+）</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X.</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_intellij_idea_classic_os_x" data-group="secondary">IntelliJ IDEA Classic（Mac OS X）</option><option value="secondary_xcode" data-group="secondary">Xcode中</option><option value="secondary_resharper" data-group="secondary">ReSharper的</option><option value="secondary_resharper_osx" data-group="secondary">ReSharper（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">Emacs（Mac OS X）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Tutorial_Introduction_to_Refactoring.xml" data-toc="Tutorial_Introduction_to_Refactoring">重构简介</h1>    <p id="262a1ba0">在本页面：</p>    <ul data-skip-index="skip"><li class="list__item"><a href="tutorial-introduction-to-refactoring.html#3b93d14e">介绍</a></li><li class="list__item"><a href="tutorial-introduction-to-refactoring.html#ea777618">重命名</a></li><li class="list__item"><a href="tutorial-introduction-to-refactoring.html#56cdf808">提取</a></li><li class="list__item"><a href="tutorial-introduction-to-refactoring.html#6082b21f">删除</a></li><li class="list__item"><a href="tutorial-introduction-to-refactoring.html#a3cada07">结论</a></li></ul>    <div class="chapter"><h2 id="3b93d14e">介绍</h2>        <p id="6a431861">IntelliJ IDEA提供了许多<a href="refactoring-source-code.html">自动重构功能</a> ，但作为开发人员，知道如何执行它们是不够的，我们需要了解这些重构是什么，什么时候我们想要应用它们，以及在使用之前要考虑的任何可能的缺点或事情他们。</p>        <p id="b1763af3">            <a href="http://refactoring.com/" data-bypass="yes" target="_blank"><span>正如Martin Fowler所定义的那样，重构</span></a> “......是一种用于重构现有代码体系，改变其内部结构而不改变其外部行为的规范技术”。因此，在对生产代码执行任何重构之前进行全面的<a href="code-coverage.html">测试覆盖</a>以证明您没有无意中改变了行为之前，这一点非常重要。</p>        <p id="0e14423e">本教程的目标是向IntelliJ IDEA的功能介绍那些可能不熟悉重构（尤其是自动重构）概念的人，并展示何时可能需要应用三种基本类型的重构： <a href="rename-refactorings.html">重命名</a> ， <a href="extract-method.html">提取</a>和<a href="safe-delete.html">删除</a> 。</p>    </div>    <div class="chapter"><h2 id="ea777618">重命名</h2>        <p id="5fe5154a"><a href="http://refactoring.com/catalog/renameMethod.html" data-bypass="yes" target="_blank"><span>重命名</span></a>可能看起来像是一个微不足道的重构，但通过简单的查找和替换重命名通常意味着无意中更改了具有相同名称的无关项。使用IntelliJ IDEA的<a href="rename-refactorings.html">重命名重构可以</a>最大限度地减少这些错误。</p>        <section class="procedure-steps"><h2 id="7757448f">为什么重命名？</h2><ol class="list _decimal"><li class="list__item" id="dba2d25c"><p>该名称不够具有描述性</p></li><li class="list__item" id="a9851020"><p>类/方法/变量名称与实际名称不匹配</p></li><li class="list__item" id="e9484f14"><p>引入了一些新东西，要求现有代码具有更具体的名称</p></li></ol></section>        <section class="procedure-steps"><h2 id="b4785556">在编码时重命名</h2><p id="507f57b3">想象一下，当您实现某些功能或修复某些错误时，您会遇到以下代码</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Server</span> <span class="o">（</span> <span class="n">路径</span> <span class="o">，</span> <span class="n">端口</span> <span class="o">，</span> <span class="n">端点</span> <span class="o">）;</span> <span class="n">服务器</span> <span class="o">。</span> <span class="na">init</span> <span class="o">（）;</span> <span class="n">服务器</span> <span class="o">。</span> <span class="na">run</span> <span class="o">（）;</span></code></div>我们假设我们想要：<ul class="list _bullet"><li class="list__item" id="5d830a2c"><p>重命名<code class="code">endpoint</code> （一个字段）来描述它是什么类型的端点。</p></li><li class="list__item" id="c7d4d533"><p>将<code class="code">Server</code>上的方法<code class="code">init()</code>重命名为更准确地描述该方法的方法。</p></li><li class="list__item" id="1fb5930a"><p>将<code class="code">Server</code> （一个类）重命名为更具体的内容。</p></li></ul>                <ol class="list _decimal"><li class="list__item" id="77dcd194">                <p id="fb87b63c">要重命名<code class="code">endpoint</code>字段，请将光标放在字端点上，然后按<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd> 。IntelliJ IDEA将根据类名和其他方面弹出建议列表。在这种情况下，还建议使用此字段的参数名称。</p>                <figure><img alt="重命名该字段" title="重命名该字段" src="../img/idea/2019.1/ij_rename_field.png" id="1a7860ae" width="675" height="189"></figure>。<p id="1ec98f70">选择其中一个选项或键入您自己的选项。如果该字段有一个getter，IntelliJ IDEA会询问您是否要重命名。</p>                <figure><img alt="你想重命名吸气剂吗？" title="你想重命名吸气剂吗？" src="../img/idea/2019.1/ij_rename_getter.png" id="4c5090bb" width="410" height="148"></figure>。<p id="a26ac674">您会注意到此字段的所有用法都更改为新名称，如果您已选择重命名该getter，则项目中的其他类将更新为使用新名称。有关方法重命名的更多信息，请参阅下一步。</p>            </li><li class="list__item" id="99940d1a">                <p id="0f1199bb">要重命名该方法，过程是相同的：将光标放在<code class="code">init</code>并按<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd> 。在这里，您将获得更少的建议，因此请键入新名称：</p>                <figure><img alt="重命名方法" title="重命名方法" src="../img/idea/2019.1/ij_rename_method.png" id="0d704698" width="602" height="175"></figure>                <p id="8986a8b4">除了重命名方法之外，还重命名方法的所有调用以及子类中所有重写/实现的方法。IntelliJ IDEA也可以重命名名称的非代码使用，如果您具有XML配置或其他引用类或方法的非Java文件，这将非常有用。如果再次按<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd>以显示重命名对话框，则可以配置重命名的内容</p>                <figure><img alt="更多重命名设置" title="更多重命名设置" src="../img/idea/2019.1/ij_rename_dialog.png" id="d9dab90a" width="642" height="153"></figure>                <p id="de440542">如果重命名不仅仅适用于代码，IntelliJ IDEA将为您预览重构，因此您可以选择要进行的更改。通常在这些情况下，您可以选择不在注释中重命名事件，尤其是在原始方法名称是<code class="code">name</code>等常用词的情况下。</p>                <figure><img alt="预览重命名" title="预览重命名" src="../img/idea/2019.1/ij_rename_method_more_details.png" id="e873d1dc" width="883" height="316"></figure>                <p id="0320416f">如果您不想进行某些更改，请在您不想更改的用法上按<kbd data-primary_default="Backspace" data-primary_default_for_gnome="Backspace" data-primary_default_for_kde="Backspace" data-primary_default_for_xwin="Backspace" data-primary_emacs="Backspace" data-primary_jbuilder="Backspace" data-primary_visual_studio="Backspace" data-primary_netbeans="Backspace" data-primary_eclipse="Backspace" data-secondary_mac_os_x_10.5_="⌫" data-secondary_mac_os_x="⌫" data-secondary_eclipse_mac_os_x="⌫" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌫">Backspace</kbd> 。</p>            </li><li class="list__item" id="2033433f">                <p id="01becc82">重命名类是类似的，但也可以通过<a href="project-tool-window.html"><span>项目工具窗口执行</span></a> 。在这种情况下，因为我们发现我们想要重命名我们使用它的类，所以我们将在代码中的类名上使用<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd> 。</p>                <figure><img alt="重命名该课程" title="重命名该课程" src="../img/idea/2019.1/ij_rename_class.png" id="87d2ce7f" width="658" height="174"></figure>                <p id="18517b62">当然，任何使用此类的代码也将被重命名，但您也可以选择重命名变量，继承者和代码的其他部分，以便它们与新名称对齐。同样，可以通过再次按<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd>来设置这些选项。</p>            </li></ol></section>        <section class="procedure-steps"><h2 id="b39afaf8">重命名的影响</h2><p id="ce235975">重命名局部变量或私有方法可以在运行中相当安全地完成。例如，当您正在处理触及此代码区域的某项功能时，您可以执行此重构，因为知道影响范围有限。</p><p id="3a742911">重命名类或公共方法可能会影响很多文件。如果是这种情况，这种重构应至少在其自己的单独提交中，以便将更改明确地与您当时可能正在处理的任何更改或附加功能分开。</p></section>    </div>    <div class="chapter"><h2 id="56cdf808">提取</h2>        <p id="b2a6eb41">IntelliJ IDEA的<span class="emphasis">提取重构</span>使开发人员能够重新设计代码，因为当前设计变得清晰时，无论是小规模还是大规模，都不再适用于目的。</p>        <section class="procedure-steps"><h2 id="6fdcb46e">提取变量</h2><p id="90e4d885">                    <a href="http://refactoring.com/catalog/extractVariable.html" data-bypass="yes" target="_blank"><span>提取变量</span></a>是一个影响较小的变化，可以使您的<a href="https://en.wikipedia.org/wiki/Self-documenting_code" data-bypass="yes" target="_blank"><span>代码自我记录</span></a> 。它还可用于减少代码重复。</p><p id="b7df584d">想象一下，您遇到以下代码</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">static</span> <span class="n">String</span> <span class="nf">getUsernameFromMessage</span> <span class="o">（</span> <span class="n">String</span> <span class="n">message</span> <span class="o">）</span> <span class="o">{</span> <span class="k">return</span> <span class="n">message</span> <span class="o">。</span> <span class="na">子串</span> <span class="o">（</span> <span class="n">消息</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="s">“\” SCREEN_NAME \ “：\” <span class="o"><span class="o">“）+</span></span></span> <span class="mi"><span class="o">15，</span></span> <span class="n">消息</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="s"><span class="o">”\“”，</span></span> <span class="n">邮件</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="s">“\” SCREEN_NAME \ <span class="o"><span class="o"><span class="o"><span class="o"><span class="o">“：\”。”）+</span></span></span></span></span></span> <span class="mi"><span class="o"><span class="o">15））;}</span></span></span></code></div>我们可以使用extract变量来提高此代码的可读性：<ul class="list _bullet"><li class="list__item" id="d6bedc03"><p>删除<code class="code">message.indexOf("\"screen_name\":\"") + 15)</code>的复制<code class="code">message.indexOf("\"screen_name\":\"") + 15)</code>                        </p></li><li class="list__item" id="8dc165c2"><p>引入变量来描述每个<code class="code">indexOf</code>调用所代表的内容</p></li><li class="list__item" id="7cf590b4"><p>删除幻数15</p></li></ul>                <ol class="list _decimal"><li class="list__item" id="1e7d2ee9">                <p id="d19d9b4f">首先，让我们减少重复并引入一个描述此操作正在执行的操作的变量。将光标放在表达式<code class="code">message.indexOf("\"screen_name\":\"") + 15)</code>中的任意位置，然后按<kbd data-primary_default="Ctrl+Alt+V" data-primary_default_for_gnome="Ctrl+Alt+V" data-primary_default_for_kde="Shift+Alt+V" data-primary_default_for_xwin="Ctrl+Alt+V" data-primary_emacs="Ctrl+Alt+V" data-primary_jbuilder="Ctrl+Alt+V" data-primary_visual_studio="Ctrl+Alt+V" data-primary_netbeans="Shift+Alt+V" data-primary_eclipse="Shift+Alt+L" data-secondary_mac_os_x_10.5_="⌥⌘V" data-secondary_mac_os_x="⌥⌘V" data-secondary_eclipse_mac_os_x="⌥⌘L" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥V">Ctrl + Alt +</kbd> V.IntelliJ IDEA将建议此重构的上下文，并且您要选择一个封装了这个表达式：</p>                <figure><img alt="选择要提取的表达式" title="选择要提取的表达式" src="../img/idea/2019.1/ij_extract_variable_1.png" id="97fcfa75" width="833" height="154"></figure>                <p id="ee72bb66">接下来，如果IntelliJ IDEA检测到此表达式多次出现，您可以选择替换所有出现的内容或仅替换您选择的内容。</p>                <figure><img alt="选择替换所有匹配项" title="选择替换所有匹配项" src="../img/idea/2019.1/ij_extract_variable_2.png" id="e2181132" width="820" height="105"></figure>                <p id="e1726727">提取变量后，IntelliJ IDEA会根据表达式所使用的参数等内容建议可能的名称。</p>                <figure><img alt="选择或输入名称" title="选择或输入名称" src="../img/idea/2019.1/ij_extract_variable_3_select_name.png" id="f8ff81c9" width="610" height="146"></figure>                <p id="f07cdd3e">我们将使用自己的名称<code class="code">indexOfFieldValue</code>来描述它真正代表的含义。请注意，您可以决定是否希望此变量为最终变量。</p>            </li><li class="list__item" id="7b2a130d">                <p id="f002fe59">接下来我们将为String值引入一个变量。这有两个原因：首先，记录String值代表什么，其次是因为它将帮助我们删除神奇数字。</p>                <p id="e1119891">将光标放在<code class="code">screen_name</code>某个位置，然后按<kbd data-primary_default="Ctrl+Alt+V" data-primary_default_for_gnome="Ctrl+Alt+V" data-primary_default_for_kde="Shift+Alt+V" data-primary_default_for_xwin="Ctrl+Alt+V" data-primary_emacs="Ctrl+Alt+V" data-primary_jbuilder="Ctrl+Alt+V" data-primary_visual_studio="Ctrl+Alt+V" data-primary_netbeans="Shift+Alt+V" data-primary_eclipse="Shift+Alt+L" data-secondary_mac_os_x_10.5_="⌥⌘V" data-secondary_mac_os_x="⌥⌘V" data-secondary_eclipse_mac_os_x="⌥⌘L" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥V">Ctrl + Alt + V.</kbd></p>                <figure><img alt="选择字符串值" title="选择字符串值" src="../img/idea/2019.1/ij_extract_variable_4.png" id="952cff1b" width="688" height="131"></figure>                <p id="161f9b7c">我们将给它一个更有意义的名称<code class="code">fieldName</code> 。</p>                <figure><img alt="为变量命名" title="为变量命名" src="../img/idea/2019.1/ij_extract_variable_5.png" id="34a51c08" width="608" height="139"></figure>            </li><li class="list__item" id="9a5adba4">                <p id="3d3f478d">现在，我们将使用相同的过程为另一个用作<code class="code">substring()</code>参数的表达式创建一个变量，我们将调用此<code class="code">indexOfEndOfFieldValue</code> 。</p>                <figure><img alt="提取变量" title="提取变量" src="../img/idea/2019.1/ij_extract_variable_6.png" id="db68386f" width="575" height="199"></figure>            </li><li class="list__item" id="bdbb2b4b"><p>最后，我们可以删除幻数，因为这只是字段名称的长度。最终代码如下：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getUsernameFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最后</span> <span class="n">字符串</span> <span class="n">的fieldName</span> <span class="o">=</span> <span class="s">“\” SCREEN_NAME \ <span class="o"><span class="o"><span class="o">“：\”。</span></span></span> <span class="o">“;</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="s"><span class="o">indexOf（”</span></span></span> <span class="s">\ “”</span> <span class="o">，</span> <span class="n">indexOfFieldValue</span> <span class="o">）;</span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span></code></div>它比原始版本更长，但它更具描述性，这在像这样的代码中尤其重要，因为它不清楚每个表达式代表什么。申请<code class="code">final</code>与否的选择取决于您的编码标准。</li></ol></section>        <section class="procedure-steps"><h2 id="288946c6">提取参数</h2><p id="12682681">                    <a href="javaintroduce.html">提取</a>或<a href="http://refactoring.com/catalog/addParameter.html" data-bypass="yes" target="_blank"><span>添加参数</span></a>允许开发人员更改方法，以便更容易使用。您可能希望更改参数，例如通过从Object而不是对象本身传入一些值，或者您可能希望从方法体中引入一个值作为参数，以允许在更多位置使用该方法。我们将看一个后者的例子。</p><p id="67af84f1">对于这个例子，在重构之后，我们将使用与上一个示例相同的代码，并稍微扩展它以显示同一个类中的另一个方法：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getTextFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最后</span> <span class="n">字符串</span> <span class="n">的fieldName</span> <span class="o">=</span> <span class="s">“\”文本\ <span class="o"><span class="o"><span class="o">“：\”。</span></span></span> <span class="o">“;</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="s"><span class="o">indexOf（”</span></span></span> <span class="s">\ “”</span> <span class="o">，</span> <span class="n">indexOfFieldValue</span> <span class="o">）;</span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span> <span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getUsernameFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最后</span> <span class="n">字符串</span> <span class="n">的fieldName</span> <span class="o">=</span> <span class="s">“\” SCREEN_NAME \ “：\” <span class="o">“;</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="s"><span class="o"><span class="o"><span class="o"><span class="o">indexOf（”。</span></span></span></span></span></span> <span class="s">\“”</span> <span class="o">，</span> <span class="n">indexOfFieldValue</span> <span class="o">）;</span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span></code></div><p id="1e729da9">我们的目标是删除我们在这两种方法中看到的重复代码。为此，我们将：</p><ul class="list _bullet"><li class="list__item" id="aef8590d"><p>将<code class="code">fieldName</code>更改为参数，以便我们可以将<code class="code">getUsernameFromMessage</code>方法应用于任何字段。</p></li><li class="list__item" id="1650d703"><p>将<code class="code">getUsernameFromMessage</code>重命名为代表其更一般性质的东西</p></li><li class="list__item" id="25fc74dd"><p>删除<code class="code">getTextFromMessage</code>的重复代码。</p></li></ul><ol class="list _decimal"><li class="list__item" id="268b2e32">                <p id="f3eaf9a1">将光标放在<code class="code">fieldName</code> ，然后按<kbd data-primary_default="Ctrl+Alt+P" data-primary_default_for_gnome="Ctrl+Alt+P" data-primary_default_for_kde="Ctrl+Alt+P" data-primary_default_for_xwin="Ctrl+Alt+P" data-primary_emacs="Ctrl+Alt+P" data-primary_jbuilder="N/A" data-primary_visual_studio="Ctrl+Alt+P" data-primary_netbeans="Ctrl+Alt+P" data-primary_eclipse="Ctrl+Alt+P" data-secondary_mac_os_x_10.5_="⌥⌘P" data-secondary_mac_os_x="⌥⌘P" data-secondary_eclipse_mac_os_x="⌥⌘P" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥P">Ctrl + Alt + P.</kbd>                </p>                <figure><img alt="提取参数" title="提取参数" src="../img/idea/2019.1/ij_extract_parameter_1.png" id="f005629d" width="822" height="176"></figure>                <p id="ee12114a">与其他重构一样，如果您愿意，可以为参数键入新名称。IntelliJ IDEA还预览更新的方法签名。按<kbd data-primary_default="Enter" data-primary_default_for_gnome="Enter" data-primary_default_for_kde="Enter" data-primary_default_for_xwin="Enter" data-primary_emacs="Enter" data-primary_jbuilder="Enter" data-primary_visual_studio="Enter" data-primary_netbeans="Enter" data-primary_eclipse="Enter" data-secondary_mac_os_x_10.5_="⏎" data-secondary_mac_os_x="⏎" data-secondary_eclipse_mac_os_x="⏎" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⏎">Enter</kbd>批准更改。</p>                <figure><img alt="新方法签名有任何问题" title="新方法签名有任何问题" src="../img/idea/2019.1/ij_extract_parameter_2_conflict.png" id="66e32245" width="567" height="509"></figure>                <p id="cf9cfbc3">这个特殊问题告诉我们该方法被用作方法引用，这个更改将导致方法引用转换为lambda表达式。此消息可能表示这不是您希望执行的重构。如果是这种情况，下一个示例将显示我们可以使用Extract Method进行的方法。但是，对于这个例子，我们假设我们对引入新参数的后果感到满意，所以我们只选择<span class="keyword">Continue</span> 。</p>                <p id="490e91bd">接下来，IntelliJ IDEA将检测现在可以通过调用新方法签名替换的任何代码。</p>                <figure><img alt="现在这段代码是更新方法的副本" title="现在这段代码是更新方法的副本" src="../img/idea/2019.1/ij_extract_parameter_3_duplicate.png" id="28a1971c" width="721" height="303"></figure>                <p id="85119e2d">如果在这种情况下选择“ <span class="keyword">替换”</span> ，则将替换所有重复的代码，并且IntelliJ IDEA将选择适当的值以传入新参数。</p>            </li><li class="list__item" id="636d1b6c">                <p id="67643c01">此时，原始方法<code class="code">getUsernameFromMessage</code>比它更通用，因此我们应该重命名它。我们将光标放在名称上并使用<kbd data-primary_default="Shift+F6" data-primary_default_for_gnome="Shift+F6" data-primary_default_for_kde="Shift+F6" data-primary_default_for_xwin="Shift+F6" data-primary_emacs="Shift+F6" data-primary_jbuilder="Shift+F6" data-primary_visual_studio="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_eclipse="Shift+Alt+R" data-secondary_mac_os_x_10.5_="⇧F6" data-secondary_mac_os_x="⇧F6" data-secondary_eclipse_mac_os_x="⇧F6" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⇧F6">Shift + F6</kbd> ，如上一节所示。</p>                <figure><img alt="重命名更新的方法" title="重命名更新的方法" src="../img/idea/2019.1/ij_extract_parameter_4_rename_method.png" id="12df465d" width="707" height="188"></figure>                </li><li class="list__item" id="e1cc7c1c">                <p id="ded45417">我们可以进一步简化代码。<a href="inline.html">内联</a>是提取的反转，在我们这里的代码中， <a href="http://refactoring.com/catalog/inlineTemp.html" data-bypass="yes" target="_blank"><span>内联我们的临时变量</span></a>可能是合适的，因为变量名只给我们提供了比将值直接传递给方法更多的东西。或者，假设getTextFromMessage确实是<code class="code">getValueForField</code>的简单委托，我们可以使用内联来完全删除此方法。</p>                <p id="a4792222">要内联，请将光标放在<code class="code">getTextFromMessage</code>变量上，然后按<kbd data-primary_default="Ctrl+Alt+N" data-primary_default_for_gnome="Ctrl+Alt+N" data-primary_default_for_kde="Ctrl+Alt+N" data-primary_default_for_xwin="Ctrl+Alt+N" data-primary_emacs="Ctrl+Alt+N" data-primary_jbuilder="Ctrl+Alt+N" data-primary_visual_studio="Ctrl+Alt+N" data-primary_netbeans="Ctrl+Alt+N" data-primary_eclipse="Shift+Alt+I" data-secondary_mac_os_x_10.5_="⌥⌘N" data-secondary_mac_os_x="⌥⌘N" data-secondary_eclipse_mac_os_x="⌥⌘I" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥N">Ctrl + Alt + N.</kbd>                </p>                <figure><img alt="内联不必要的方法" title="内联不必要的方法" src="../img/idea/2019.1/ij_extract_parameter_5_inline.png" id="c17db73f" width="707" height="257"></figure>                </li><li class="list__item" id="17c01d7b">                <p id="8a2ec7b9">现在我们的最终代码如下：</p>                <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">static</span> <span class="n">String</span> <span class="nf">getValueForField</span> <span class="o">（</span> <span class="n">String</span> <span class="n">message</span> <span class="o">，</span> <span class="n">String</span> <span class="n">fieldName</span> <span class="o">）</span> <span class="o">{</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">message</span> <span class="o">。</span> <span class="na">indexOf</span> <span class="o">（</span> <span class="n">fieldName</span> <span class="o">）</span> <span class="o">+</span> <span class="n">fieldName</span> <span class="o">。</span> <span class="na">length</span> <span class="o">（）;</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">message</span> <span class="o">。</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="s"><span class="o"><span class="n"><span class="o">“\””，indexOfFieldValue）;</span></span></span></span> <span class="k">返回</span> <span class="n">消息</span> <span class="na">字符串</span> <span class="o"><span class="o"><span class="n"><span class="o"><span class="n"><span class="o"><span class="o">（indexOfFieldValue，indexOfEndOfFieldValue）;}</span></span></span></span></span></span></span></code></div>                <p id="d56a498b">我们调用原始getUsernameFromMessage方法的代码是：</p>                <code class="code">分析器:: getUsernameFromMessage</code>                <p id="8b6c4e89">现在是</p>                <code class="code">（message） - &gt; Parser.getValueForField（message，“\”screen_name \“：\”“）</code>                <p id="5d0cf61a">我们调用原始getTextFromMessage方法的代码是：</p>                <code class="code">String [] wordsInMessage = Parser.getTextFromMessage（message）.split（“\\ s”）;</code>                <p id="e2ad63bb">现在是</p>                <code class="code">String [] wordsInMessage = Parser.getValueForField（message，“\”text \“：\”“）。split（”\\ s“）;</code>            </li></ol><p id="e1a1833d">请注意，我们应用此重构的方式会强制所有调用者传入字段名称，并且a）在代码周围传播String值的使用，并且b）可能会引入一个或多个这些String值的重复。这可能适合您的代码，特别是在处理字符串重复或不经常使用该方法时。但是，如果这不是一个权衡，你希望减少代码的重复，请参阅下一章的替代方法。</p><p id="cc9d037d">提取参数可以非常强大，因此值得阅读<a href="javaintroduce.html">更详细的帮助页面</a> 。</p></section>        <section class="procedure-steps"><h2 id="79c298b7">提取方法</h2><p id="c52c74a1">帮助代码可读性的一种方法是将它放在易于理解的小部分中。<a href="http://refactoring.com/catalog/extractMethod.html" data-bypass="yes" target="_blank"><span>Extract方法</span></a>允许开发人员这样做，在适当的时候将代码段移动到他们自己的描述性命名方法中。</p><p id="ca0f779e">一些开发人员可能会发现自己编写的长方法执行他们想到的操作，并且当他们完成（并测试）功能时，查看代码以查看它可以被重构和简化的位置并分解这些更长的方法。或者，当开发人员在实现新功能时遇到代码时，他们意识到将一些代码提取到自己的方法中可以让他们重用现有的功能。</p><aside class="tip sideblock" rel="ca0f779e" id="6204c78a" data-title=""><p>当IntelliJ IDEA检测到重复代码时，这是创建一个可以被具有重复代码的所有位置调用的新方法的非常好的候选者。</p></aside><p id="e9bdf5b4">我们将查看与上一节相同的示例，但采用与之前略有不同的方法。</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getTextFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最后</span> <span class="n">字符串</span> <span class="n">的fieldName</span> <span class="o">=</span> <span class="s">“\”文本\ <span class="o"><span class="o"><span class="o">“：\”。</span></span></span> <span class="o">“;</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="s"><span class="o">indexOf（”</span></span></span> <span class="s">\ “”</span> <span class="o">，</span> <span class="n">indexOfFieldValue</span> <span class="o">）;</span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span> <span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getUsernameFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最后</span> <span class="n">字符串</span> <span class="n">的fieldName</span> <span class="o">=</span> <span class="s">“\” SCREEN_NAME \ “：\” <span class="o">“;</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="s"><span class="o"><span class="o"><span class="o"><span class="o">indexOf（”。</span></span></span></span></span></span> <span class="s">\“”</span> <span class="o">，</span> <span class="n">indexOfFieldValue</span> <span class="o">）;</span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span></code></div><p id="c60acf51">正如我们之前看到的，之前的重构有一些权衡：需要将方法引用转换为lambda表达式，并且所有调用代码都需要知道所需的字段名称。我们可以选择以不同的方式删除两种方法之间的代码重复：</p><ul class="list _bullet"><li class="list__item" id="0b66e89d"><p>将公共代码提取到自己的方法中。</p></li><li class="list__item" id="278a9db9"><p>内联变量以简化剩余代码。</p></li></ul><ol class="list _decimal"><li class="list__item" id="a18b8954">                <p id="073e025b">首先，突出显示两种方法之间常见的代码：</p>                <figure><img alt="突出显示重复代码的实例" title="突出显示重复代码的实例" src="../img/idea/2019.1/ij_extract_method_1_duplicate_code.png" id="cd1f773c" width="731" height="232"></figure>                <p id="ad1e85eb">按<kbd data-primary_default="Ctrl+Alt+M" data-primary_default_for_gnome="Ctrl+Alt+M" data-primary_default_for_kde="Ctrl+Alt+M" data-primary_default_for_xwin="Ctrl+Alt+M" data-primary_emacs="Ctrl+Alt+M" data-primary_jbuilder="Ctrl+Shift+E" data-primary_visual_studio="Ctrl+Alt+M" data-primary_netbeans="Shift+Alt+M" data-primary_eclipse="Shift+Alt+M" data-secondary_mac_os_x_10.5_="⌥⌘M" data-secondary_mac_os_x="⌥⌘M" data-secondary_eclipse_mac_os_x="⌥⌘M" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥M">Ctrl + Alt + M</kbd>将显示“ <a href="extract-method-dialog.html">提取方法”对话框</a> 。</p>                <figure><img alt="提取方法对话框" title="提取方法对话框" src="../img/idea/2019.1/ij_extract_method_2_dialog.png" id="930fd5b9" width="524" height="444"></figure>                <p id="c68ef5de">键入新方法的名称<code class="code">getValueForField</code> ，然后检查参数名称和顺序。在这种情况下，我们将交换参数的顺序，因为我们更喜欢<code class="code">fieldName</code>参数更接近方法的名称。这将取决于您的代码风格和团队偏好，您可能希望大声朗读名称和参数，以查看它是否有意义作为自然语言的声明。</p>                <figure><img alt="提取方法对话框中的最终设置" title="提取方法对话框中的最终设置" src="../img/idea/2019.1/ij_extract_method_3_dialog_complete.png" id="c11a382f" width="524" height="444"></figure>                <p id="a99e32dd">当您按<span class="keyword">OK时</span> ，IntelliJ IDEA将检测可以通过调用此新方法替换的代码，并将提供重构。我们要选择<span class="keyword">是</span> 。</p>                <figure><img alt="重构代码重复" title="重构代码重复" src="../img/idea/2019.1/ij_extract_method_4_detect_duplicates.png" id="9b222b21" width="716" height="370"></figure>            </li><li class="list__item" id="3df9f8c7">                <p id="cc14532d">此时，我们的<code class="code">getTextFromMessage</code>和<code class="code">getUsernameFromMessage</code>方法是两行简单代码，这里<a href="inline.html">内联</a> fieldName变量是有意义的，因为方法名称足以描述性地删除<a href="http://refactoring.com/catalog/inlineTemp.html" data-bypass="yes" target="_blank"><span>临时变量</span></a> 。在<code class="code">fieldName</code>上按<kbd data-primary_default="Ctrl+Alt+N" data-primary_default_for_gnome="Ctrl+Alt+N" data-primary_default_for_kde="Ctrl+Alt+N" data-primary_default_for_xwin="Ctrl+Alt+N" data-primary_emacs="Ctrl+Alt+N" data-primary_jbuilder="Ctrl+Alt+N" data-primary_visual_studio="Ctrl+Alt+N" data-primary_netbeans="Ctrl+Alt+N" data-primary_eclipse="Shift+Alt+I" data-secondary_mac_os_x_10.5_="⌥⌘N" data-secondary_mac_os_x="⌥⌘N" data-secondary_eclipse_mac_os_x="⌥⌘I" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⌥N">Ctrl + Alt + N</kbd> ，然后选择“ <span class="keyword">重构”</span> 。</p>                <figure><img alt="内联不必要的变量" title="内联不必要的变量" src="../img/idea/2019.1/ij_extract_method_5_inline.png" id="a1977b59" width="624" height="265"></figure>            </li><li class="list__item" id="014fb5d8">                <p id="562b51ca">作为最后一步，您可能希望将所有类似的方法组合在一起。根据您的设置，IntelliJ IDEA可能已将新方法直接放在您选择提取方法时所使用的方法之下，如本例中的情况。要将辅助方法放在一起，将光标放在<code class="code">getValueForField</code>方法名称上，然后按<kbd data-primary_default="Ctrl+Shift+Down" data-primary_default_for_gnome="Ctrl+Shift+Down" data-primary_default_for_kde="Ctrl+Shift+Down" data-primary_default_for_xwin="Ctrl+Shift+Down" data-primary_emacs="Ctrl+Shift+Down" data-primary_jbuilder="Ctrl+Shift+Down" data-primary_visual_studio="Ctrl+Shift+Down" data-primary_netbeans="Shift+Alt+Page Down" data-primary_eclipse="Alt+Down" data-secondary_mac_os_x_10.5_="⇧⌘↓" data-secondary_mac_os_x="⇧⌘↓" data-secondary_eclipse_mac_os_x="⌥↓" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⇧↓">Ctrl + Shift + Down</kbd> 。这将在现有的getUsernameFromMessage方法下放置新方法<code class="code">getValueForField</code> 。</p>                <p id="19f29ff3">我们的最终代码如下：</p>                <div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">static</span> <span class="n">String</span> <span class="nf">getTextFromMessage</span> <span class="o">（</span> <span class="n">String</span> <span class="n">message</span> <span class="o">）</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getValueForField</span> <span class="o">（</span> <span class="s">“\”text \“：\”“</span> <span class="o">，</span> <span class="n">message</span> <span class="o">）;</span> <span class="o">}</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getUsernameFromMessage</span> <span class="o">（</span> <span class="n">String</span> <span class="n">message</span> <span class="o">）</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getValueForField</span> <span class="o">（</span> <span class="s">”\“screen_name \”：\“”</span> <span class="o">，</span> <span class="n">message</span> <span class="o">） ;</span> <span class="o">}</span> <span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getValueForField（</span></span> <span class="n">字符串</span> <span class="n">fieldName的</span> <span class="o">，</span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">indexOf</span> <span class="o">（</span> <span class="n">fieldName</span> <span class="o">）</span> <span class="o">+</span> <span class="n">fieldName</span> <span class="o">。</span> <span class="na">length</span> <span class="o">（）;</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">message</span> <span class="o">。</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="s"><span class="o"><span class="n"><span class="o">“\””，indexOfFieldValue）;</span></span></span></span> <span class="k">返回</span> <span class="n">消息</span> <span class="na">字符串</span> <span class="o"><span class="o"><span class="n"><span class="o"><span class="n"><span class="o"><span class="o">（indexOfFieldValue，indexOfEndOfFieldValue）;}</span></span></span></span></span></span></span></code></div>                <p id="ead1f957">现在我们有两个非常具体的辅助方法来获取消息体和用户名，以及一个更通用的方法，可以用来从消息中获取任何字段的值。当存在经常需要的其他字段时，可以添加其他辅助方法。</p>            </li></ol><p id="113c133a">请注意，Extract Parameter和Extract Method示例以相同的代码开头，但以看起来非常不同的代码结束。这不仅仅是因为我们使用了不同的重构，而是因为我们做出了不同的决定 - 在第一个示例中，我们选择完全删除重复，并将一些决策制定移动到方法的调用者。在第二个例子中，我们选择提供一个API，它隐藏了小辅助方法背后的字段名称的细节，但仍然提供了更通用的方法。我们也可以混合和匹配方法，我们选择开始的重构可能会引导我们朝着一个特定的方向，但我们可以决定我们的最终目的地。我们应该记住我们的重构的目标（在这种情况下，减少重复）并理解当我们选择一个方向而不是另一个方向时我们正在做出的权衡，例如决定我们是否希望调用代码来知道他们要求的字段名称对于。</p></section>        <section class="procedure-steps"><h2 id="55afff8a">提取的影响</h2><p id="7cb20b7c">好消息是你可以很容易地撤消提取。当然，不仅要选择<kbd data-primary_default="Ctrl+Z" data-primary_default_for_gnome="Ctrl+Z" data-primary_default_for_kde="Ctrl+Z" data-primary_default_for_xwin="Ctrl+Z" data-primary_emacs="Ctrl+Shift+Minus" data-primary_jbuilder="Ctrl+Z" data-primary_visual_studio="Ctrl+Z" data-primary_netbeans="Ctrl+Z" data-primary_eclipse="Ctrl+Z" data-secondary_mac_os_x_10.5_="⌘Z" data-secondary_mac_os_x="⌘Z" data-secondary_eclipse_mac_os_x="⌘Z" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌃⇧-">Ctrl + Z</kbd> ，还要通过<a href="inline.html">内联</a>创建的方法，以便代码返回原来的位置。</p><p id="47831f18">我们在这里提到的提取重构经常被有经验的开发人员用来随着它的发展塑造代码，并且每次触摸代码时，或多或少地使用它们并不罕见。一些未被覆盖的，如<a href="extract-interface.html">提取界面</a>和<a href="extract-superclass.html">提取超类</a> ，可能会对整体设计产生更广泛的影响，应该更加小心。</p></section>    </div>    <div class="chapter"><h2 id="6082b21f">删除</h2>        <p id="2879bf0a">有时，当您通过几个步骤重构代码时，最终可能会得到不再使用的代码，或者理想情况下不应该使用代码。由于重构的目标是简化，您应该始终致力于尽可能地删除未使用的代码 - 无论未使用的代码对应用程序的性能有何影响（未使用的代码），未使用的代码肯定会对开发人员的工作和尝试造成影响了解应用程序。</p>        <section class="procedure-steps"><h2 id="b820827a">安全删除</h2><p id="6653d608">IntelliJ IDEA可让您<a href="safe-delete.html">安全地删除</a>未使用的代码片段或整个文件，通知您删除代码是否安全，并提供在更改之前预览更改的选项。识别和处理未使用代码的最快方法是确保启用相关检查，默认情况下通常是这样：</p><figure><img alt="查找未使用代码的检查" title="查找未使用代码的检查" src="../img/idea/2019.1/ij_safe_delete_1_inspections.png" id="5ee0ff33" width="1003" height="671"></figure><p id="02fac863">让我们继续我们之前的重构的例子。假设我们最终得到了这段代码：</p><div class="code-block" data-lang="Java"><code class="code-block__wrapper"><span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getUsernameFromMessage（</span></span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="k">返回</span> <span class="n"><span class="o">getValueForField（</span></span> <span class="s">“\” SCREEN_NAME \ <span class="o">“：\””，</span></span> <span class="n">消息</span> <span class="o"><span class="o">）;}</span></span> <span class="kd">静态</span> <span class="n">字符串</span> <span class="nf"><span class="o">getValueForField（</span></span> <span class="n">字符串</span> <span class="n">fieldName的</span> <span class="o">，</span> <span class="n">字符串</span> <span class="n">消息</span> <span class="o"><span class="o">）{</span></span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="n"><span class="o">indexOf（fieldName</span></span></span> <span class="n">的</span> <span class="o"><span class="o">）+</span></span> <span class="n">fieldName的</span> <span class="o"><span class="o">。</span></span> <span class="na">长度</span> <span class="o">（）;</span> <span class="kd">最终</span> <span class="kt">诠释</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">=</span> <span class="n">消息</span> <span class="na">的<span class="o">indexOf（</span></span> <span class="o"><span class="s"><span class="o"><span class="n"><span class="o">“\””，indexOfFieldValue）。</span></span></span></span></span> <span class="k">返回</span> <span class="n">消息</span> <span class="o">。</span> <span class="na">substring</span> <span class="o">（</span> <span class="n">indexOfFieldValue</span> <span class="o">，</span> <span class="n">indexOfEndOfFieldValue</span> <span class="o">）;</span> <span class="o">}</span></code></div><p id="77b485d2">有可能在一段时间之后，当我们回到这段代码时，不再使用<code class="code">getUsernameFromMessage</code>方法 - 可能不再需要它，或者人们可以使用相关参数调用<code class="code">getValueForField</code> 。因此，假设我们对这些原因感到满意，我们可以继续使用此方法。</p><ol class="list _decimal"><li class="list__item" id="dc1593b4"><p>如果未使用的声明检查已打开，则方法名称将显示为灰色，表示未使用。</p><figure><img alt="删除未使用的方法是安全的" title="删除未使用的方法是安全的" src="../img/idea/2019.1/ij_safe_delete_2_unused.png" id="d386473a" width="710" height="159"></figure>            </li><li class="list__item" id="0b5025ef"><p>将光标放在<code class="code">getUsernameFromMessage</code> ，然后按<kbd data-primary_default="Alt+Enter" data-primary_default_for_gnome="Alt+Enter" data-primary_default_for_kde="Alt+Enter" data-primary_default_for_xwin="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_jbuilder="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_eclipse="Alt+Enter" data-secondary_mac_os_x_10.5_="⌥⏎" data-secondary_mac_os_x="⌥⏎" data-secondary_eclipse_mac_os_x="⌘1" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌥⏎">Alt + Enter</kbd> 。这将为您提供删除此方法的选项。</p><figure><img alt="删除未使用的方法" title="删除未使用的方法" src="../img/idea/2019.1/ij_safe_delete_3_delete.png" id="201ef698" width="747" height="183"></figure>            </li><li class="list__item" id="9fed0a25">                <p id="861d444f">选择安全删除将弹出安全删除对话框，允许您搜索此方法的用法。</p>                <figure><img alt="安全删除对话框" title="安全删除对话框" src="../img/idea/2019.1/ij_safe_delete_4_dialog.png" id="a120f214" width="506" height="125"></figure>                <p id="673febc0">按“ <span class="keyword">确定”</span>继续进行搜索。在我们的例子中，删除是完全安全的，因此删除了该方法。</p>            </li><li class="list__item" id="874ca64d">                <p id="f6a40bae">                    </p><p id="448472f5">我们的“未使用”方法可能未被标记为未使用，因为它可能会被测试覆盖。但是如果我们仍然知道它未被使用，或者通过<kbd data-primary_default="Alt+F7" data-primary_default_for_gnome="Shift+Alt+7" data-primary_default_for_kde="Shift+Alt+7" data-primary_default_for_xwin="Alt+F7" data-primary_emacs="Alt+F7" data-primary_jbuilder="Alt+F7" data-primary_visual_studio="Shift+Alt+F7" data-primary_netbeans="Alt+F7" data-primary_eclipse="Ctrl+G" data-secondary_mac_os_x_10.5_="⌥F7" data-secondary_mac_os_x="⌥F7" data-secondary_eclipse_mac_os_x="⇧⌘G" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="⌥F7">Alt + F7</kbd>进行了检查，我们仍然可以安全地删除它。</p>                    <p id="470eb828">将光标放在方法名称上，然后按<kbd data-primary_default="Alt+Delete" data-primary_default_for_gnome="Alt+Delete" data-primary_default_for_kde="Alt+Delete" data-primary_default_for_xwin="Alt+Delete" data-primary_emacs="N/A" data-primary_jbuilder="Alt+Delete" data-primary_visual_studio="Alt+Delete" data-primary_netbeans="Alt+Delete" data-primary_eclipse="Alt+Delete" data-secondary_mac_os_x_10.5_="⌘⌦" data-secondary_mac_os_x="⌘⌦" data-secondary_eclipse_mac_os_x="N/A" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="N/A">Alt + Delete</kbd> 。这将像以前一样弹出安全删除对话框，这次当您按<span class="keyword">OK时，</span> IntelliJ IDEA会警告您此方法有用法</p>                                <figure><img alt="用法发现" title="用法发现" src="../img/idea/2019.1/ij_safe_delete_5_usages_dialog.png" id="c7532c82" width="524" height="489"></figure>                <p id="61faff72">按<span class="keyword">查看用法</span>以查看这些是什么</p>                <figure><img alt="查看所有代码用法" title="查看所有代码用法" src="../img/idea/2019.1/ij_safe_delete_6_usages.png" id="27cf76d7" width="735" height="262"></figure>            </li><li class="list__item" id="f2f97e0d">                <p id="a171eb28">通过双击每个用法，使用结果面板导航到用法。在我们的例子中，我们看到有一个测试调用我们想要删除的方法。</p>                <figure><img alt="方法用于测试" title="方法用于测试" src="../img/idea/2019.1/ij_safe_delete_7_test.png" id="634b7c2f" width="623" height="109"></figure>                <p id="396db27c">由于此测试是为了确保我们不再需要的方法的正确性，我们也可以删除此测试。在编辑器窗口中，按测试方法名称上的<kbd data-primary_default="Alt+Delete" data-primary_default_for_gnome="Alt+Delete" data-primary_default_for_kde="Alt+Delete" data-primary_default_for_xwin="Alt+Delete" data-primary_emacs="N/A" data-primary_jbuilder="Alt+Delete" data-primary_visual_studio="Alt+Delete" data-primary_netbeans="Alt+Delete" data-primary_eclipse="Alt+Delete" data-secondary_mac_os_x_10.5_="⌘⌦" data-secondary_mac_os_x="⌘⌦" data-secondary_eclipse_mac_os_x="N/A" data-secondary_intellij_idea_classic_os_x="N/A" data-secondary_xcode="N/A" data-secondary_resharper="N/A" data-secondary_resharper_osx="N/A" data-secondary_emacs="N/A">Alt + Delete</kbd> ，然后在“安全删除”对话框中<span class="keyword">单击“确定</span> ”。测试方法将被删除。</p>            </li><li class="list__item" id="f71f8347"><p id="d66567c5">现在，我们将在“安全删除冲突”窗口中看到此代码不再有效。</p>                <figure><img alt="不再使用该方法" title="不再使用该方法" src="../img/idea/2019.1/ij_safe_delete_8_invalid.png" id="894d7c60" width="648" height="261"></figure>                <p id="69d08cfc">由于这是我们最初想要删除的方法的唯一用法，我们可以选择“ <span class="keyword">重新运行安全删除”</span>按钮。这次在“安全删除”对话框上按“ <span class="keyword">确定”时</span> ，将删除<code class="code">getUsernameFromMessage</code>方法。</p>            </li></ol></section>        <section class="procedure-steps"><h2 id="47d44d34">删除的影响</h2><aside class="tip sideblock" rel="47d44d34" id="d3a89b7b" data-title=""><p>如果您发现一个看似未使用但是构成公共API一部分的公共方法，则应该通过测试进行覆盖。“未使用”警告可能并不意味着您应该删除该方法，它告诉您应该测试此方法。</p></aside><p id="64956a6f">IntelliJ的检查可以显示未使用的代码，但是如果您的代码将打包为其他人使用的库，或者以其他方式公开公共API，则某些公共符号可能会在未处理时标记为未使用事实上，它们是由您无法控制的代码使用的。如果公共符号似乎未使用，则应检查其他系统是否以某种方式使用它们。</p><p id="75dba3b7">未使用的参数，局部变量和私有字段是删除的理想选择，因为应该很容易看到删除它们不会影响任何功能。</p><p id="bb609cc5">使用安全删除删除符号，无论它们是否未使用，都允许您在执行重构之前检查受影响的区域是否是您期望的区域，并让您控制您希望应用的更改。但是，仍然要注意警告，系统可能会使用公共符号，因此在删除这些符号时请务必小心。</p></section>    </div>    <div class="chapter"><h2 id="a3cada07">结论</h2>        <p id="81ea74fb">IntelliJ IDEA提供了许多自动重构，所有这些都旨在让开发人员以尽可能低影响的方式重塑您的代码。目标是进行小的，渐进的更改，始终将代码保持在编译状态。重构功能的强大之处在于将较小的更改链接在一起，以便将代码转移到您想到的某个目标的方向：减少重复，删除不必要的代码，努力简化，提高可读性，或者更大程度地重新构建设计。</p>        <p id="4a4e1bd4">在处理新功能或修复错误时，可能会进行小而简单的更改，甚至是可取的，但请记住，可能需要单独应用更大的更改，以区分不应影响现有功能和功能更改的重构。</p>    </div><div class="last-modified" data-skip-index="skip">最后修改日期：2019年3月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="tutorial-file-watchers-in-product.html">IntelliJ IDEA中的文件监视器</a> <a class="navigation-links__next" href="replace-conditional-logic-with-strategy-pattern.html">用策略模式替换条件逻辑</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="../app/v2/app.js"></script></body></html>