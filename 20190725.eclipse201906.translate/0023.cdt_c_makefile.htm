<html lang="zh-Hans" dir="ltr">

<head>
<meta http-equiv="Content-Language" content="en-us"></meta>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>Makefile文件</title>
<link rel="stylesheet" type="text/css" href="../help.css"></link>
</head>

<body dir="ltr">
<div role="main">
<h1>Makefile文件</h1>
<p>makefile是一个文本文件，由make命令引用，用于描述目标的构建，并包含诸如源级依赖项和构建顺序依赖项之类的信息。</p>
<p>CDT可以为您生成一个makefile，这样的项目称为Managed Make项目。一些项目（称为标准制作项目）允许您定义自己的makefile。</p>

<h2>示例Makefile</h2>
<pre>#Amafile示例＃此Makefile演示并解释#Make宏，宏扩展，＃规则，目标，依赖关系，命令，目标＃人工目标，模式规则，依赖关系规则。＃注释以＃开头并转到行尾。＃这是一个简单的Make Macro。LINK_TARGET = test_me.exe＃这是一个Make Macro，它使用反斜杠扩展到多行。＃这允许快速修改更多目标文件。OBJS = \ Test1.o \ Test2.o \ Main.o＃这是由两个宏扩展定义的Make宏。＃宏扩展可以视为Make Macro的文本替换。#with宏扩展引入了$并括在（括号）中。REBUILDABLES = $（OBJS）$（LINK_TARGET）#Make宏不需要在它们的宏扩展之前定义，＃但它们通常应该在它们出现在任何规则之前定义。＃因此Make Macros经常出现在Makefile中。＃这是一个简单的规则（用于“清理”您的构建环境）。＃它有一个名为“clean”的目标（第一行的冒号“：”左侧），＃no Dependencies（冒号右侧），＃和两个命令（后面几行的选项卡缩进）。＃不需要冒号之前的空格，但为了清楚起见，这里添加了空格。clean：rm -f $（REBUILDABLES）echo clean done #makefile应该有两个标准目标：＃“all”和“clean”，因为它们通常是命令行目标。 ＃此外，这些通常都是人工目标，因为它们通常＃对应于名为“all”或“clean”的真实文件。＃“all”的规则用于逐步构建系统。＃它通过表达对该系统结果的依赖来实现这一点，＃该系统又具有自己的规则和依赖关系。all：$（LINK_TARGET）echo All done＃在Makefile中出现的规则列表中没有必需的顺序。#Make将构建自己的依赖树，并且只执行每个规则一次#his依赖项的规则已成功执行。＃这是一个在其命令中使用一些内置Make Macros的规则：＃$ @扩展到规则的目标，在本例中为“test_me.exe”。＃$ ^扩展为规则的依赖项，在本例中为三个文件＃main.o，test1.o和test2.o。$（LINK_TARGET）：$（OBJS）g ++ -g -o $ @ $ ^＃这是一个模式规则，通常用于编译行。＃它说明如何创建一个带有.o后缀的文件，给定一个带.cpp后缀的文件。＃规则的命令使用一些内置的Make宏：＃$ @用于模式匹配的目标＃$ lt;对于模式匹配的依赖项％。o：％。cpp g ++ -g -o $ @ -c $ &lt;＃这些是依赖规则，它是没有任何命令的规则。#Dededency Rules表示如果冒号右边的任何文件发生变化，＃冒号左边的目标应该被认为是过时的。＃用于使过时目标保持最新的命令可以在其他地方找到＃（在这种情况下，通过上面的模式规则）。#Dededency Rules通常用于捕获头文件依赖项。Main.o：Main.h Test1.h Test2.h Test1.o：Test1.h Test2.h Test2.o：Test2.h＃除了手动捕获依赖关系外，还存在几个自动化的＃dependency生成器。这是一种可能性（注释掉）......＃％。dep：％。cpp #g ++ -M $（FLAGS）$ &lt;&gt; $ @＃include $（OBJS：.o = .dep）</pre>


<h2>经常问的问题：</h2>您的控制台视图对于调试构建非常有用。

<p><strong>Q1。我的控制台视图显示<span class="typewriter"><q>错误启动构建器</q></span> 。那是什么意思？</strong></p>
<pre>错误启动构建器（make -k clean all）（执行错误：启动失败）</pre>

<p>最有可能的是，构建命令（默认情况下为“make”）不在您的路径上。您可以将它放在路径上并重新启动Eclipse。<br>您还可以将构建命令更改为路径上的某些内容。如果使用MinGW工具进行编译，则应将build命令替换为“mingw32-make”。</p>

<p><strong>Q2。我的控制台视图说<span class="typewriter"><q>没有规则来制作目标'X'</q></span> 。</strong></p>
<pre>make -k clean all make：***没有规则让目标'干净'。make：***没有规则让目标'全部'。
</pre>

<p>默认情况下，make程序会查找最常称为“Makefile”或“makefile”的文件。如果它在工作目录中找不到这样的文件，或者该文件为空或者文件不包含命令行目标的规则（在这种情况下为“clean”和“all”），则通常会失败并显示错误消息类似于显示的消息。</p>

<p>如果您已有一个有效的Makefile，则可能需要更改构建的工作目录。build命令的默认工作目录是项目的根目录。您可以通过在Make Project属性中指定备用Build Directory来更改此设置。或者，如果您的Makefile被命名为其他名称（例如<span class="typewriter">buildFile.mk</span> ），则可以通过将默认的Build命令设置为<span class="typewriter">make -f buildFile.mk</span>来指定名称。</p>

<p>如果没有有效的Makefile，请在根目录中创建名为Makefile的新文件。然后，您可以添加示例Makefile（上面）的内容，并根据需要进行修改。</p>

<p><strong>Q3。我的控制台视图显示<span class="typewriter">“缺少分隔符”</span> 。</strong></p>
<pre>make -k clean all makefile：12：***缺少分隔符。停止。
</pre>
<p>Makefile的标准语法规定构建规则中的每一行必须以Tab字符开头。这个Tab字符经常被空格意外替换，并且因为两者都会导致空格缩进，所以这个问题很容易被忽视。在提供的示例中，错误消息可以精确定位到文件“makefile”的第12行;要解决此问题，请在该行的开头插入一个选项卡。</p>

<p><strong>Q4。我的控制台视图显示<span class="typewriter"><q>Target'all'未因错误而重新制作</q></span> 。</strong></p>
<pre>make -k clean all make：*** [clean]错误255 rm -f Test1.o Test2.o Main.o test_me.exe g ++ -g -o Test1.o -c Test1.cpp make：*** [Test1 .o]错误255 make：*** [Test2.o]错误255 make：*** [Main.o]错误255 g ++ -g -o Test2.o -c Test2.cpp g ++ -g -o Main.o -c Main.cpp make：由于错误，目标'all'未重新编译。
</pre>
<p>这里可能的罪魁祸首是g ++不在你的路径上。<br>
</p><p>错误255由make生成，因为它的命令shell无法找到特定规则的命令。<br>来自标准错误流（行错误255）和标准输出流（所有其他行）的消息将在此处的控制台视图中合并。</p>

<p><strong>Q5。什么是-k标志？</strong></p>

<p>-k标志告诉make即使在一个规则失败时也继续制定其他独立规则。这有助于构建大型项目。</p>
<p>您可以通过打开项目属性&gt; C / C ++生成项目&gt;生成构建器&gt;停止第一次生成错误来删除-k标志</p>

<p><strong>Q6。我的控制台视图如下所示：</strong></p>
<pre>mingw32-make clean all process_begin：CreateProcess（（null），rm -f Test1.o Test2.o Main.o test_me.exe，...）失败。make（e = 2）：系统找不到指定的文件。mingw32-make：*** [清除]错误2 rm -f Test1.o Test2.o Main.o test_me.exe</pre>

<p>这意味着mingw32-make无法找到实用程序“rm”。不幸的是，MinGW没有“rm”。要更正此问题，请将Makefile中的clean规则替换为：</p>
<p></p><pre>干净：-del $（REBUILDABLES）echo干净完成</pre>
<p>前导减号告诉make即使del命令返回失败也要认为干净规则是成功的。这可能是可以接受的，因为如果要删除的指定文件（或者不再存在），del命令将失败。</p>


<p><img src="../images/ng00_04a.gif" alt="IBM版权声明"></p>
</div>
</body>
</html>