<html lang="zh-Hans" dir="ltr">
<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2017. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>Java编译错误/警告首选项</title>
<link rel="stylesheet" href="../../../../book.css" type="text/css" charset="ISO-8859-1"></link>
<script src="PLUGINS_ROOT/org.eclipse.help/livehelp.js" type="text/javascript" language="JavaScript"> </script>
</head>
<body dir="ltr">
<h1>Java编译错误/警告首选项</h1>
<p>指示您对错误/警告设置的首选项<a class="command-link" href="javascript:void(0);"><img src="PLUGINS_ROOT/org.eclipse.help/command_link.png" alt="打开“错误/警告”首选项页面"> <b>Java&gt;编译器&gt;错误/警告</b></a>首选项页面。</p>
<h3>代码风格</h3>
<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Code style section">
	<tr>
		<th>
		<p>选项</p>
		</th>
		<th>
		<p>描述</p>
		</th>
		<th>
		<p>默认</p>
		</th>
	</tr>
	<tr>
		<td valign="top">
		<p>对静态成员的非静态访问</p>
		</td>
		<td valign="top">
		<p>启用后，只要使用表达式接收器访问静态字段或方法，编译器就会发出错误或警告。应使用类型名称限定对静态成员的引用。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>间接访问静态成员</p>
		</td>
		<td valign="top">
		<p>启用后，只要间接访问静态字段或方法，编译器就会发出错误或警告。应使用声明类型名称限定接口的静态字段。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>对实例字段的不合格访问</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到不合格的字段访问时发出错误或警告（例如，错过'this'）。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>访问封闭类型的不可访问成员</p>
		</td>
		<td valign="top">
		<p>启用后，只要模拟器模拟对封闭类型的不可访问成员的访问，编译器就会发出错误或警告。此类访问可能会影响性能。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>参数分配</p>
		</td>
		<td valign="top">
		<p>为参数赋值通常被认为是糟糕的样式编程。启用此选项后，编译器会将此类方案指示为错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>非外化字符串</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将针对非外部化字符串文字（即未使用// $ NON-NLS- &lt;n&gt; $标记）或不属于字符串的非外部化字符串标记发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未记录的空块</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到没有解释注释的空块语句，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>资源不通过try-with-resource（1.7或更高版本）进行管理</p>
		</td>
		<td valign="top">
		<p>启用后，如果局部变量包含类型为“java.lang”的值，编译器将发出错误或警告。AutoCloseable'，如果在该资源上显式调用方法'close（）'，但资源不是由try-with-resources块管理的。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>具有构造函数名称的方法</p>
		</td>
		<td valign="top">
		<p>使用构造函数名称命名方法通常被认为是糟糕的样式编程。启用此选项后，编译器会将此类方案指示为错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>方法可以是静态的</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将对private或final方法发出错误或警告，并且仅引用静态成员。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>方法可能是静态的</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将针对非私有或最终方法以及仅引用静态成员的方法发出错误或警告。请注意，可以在子类中重写方法，因此如果将“可能静态”方法设置为静态，则可能会破坏现有客户端。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
</table>

<h3>潜在的编程问题</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Potential programming problems section">
	<tr>
		<td valign="top">
		<p>比较相同的值（'x == x'）</p>
		</td>
		<td valign="top">
		<p>启用后，如果比较涉及相同的操作数（例如'x == x'），编译器将发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>分配没有效果（例如'x = x'）</p>
		</td>
		<td valign="top">
		<p>启用后，只要赋值无效（例如'x = x'），编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>可能的意外布尔赋值（例如'if（a = b）'）</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到可能的意外布尔赋值时发出错误或警告（例如'if（a = b）'）。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>拳击和拆箱转换</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在遇到装箱或取消装箱转换时发出错误或警告。自动装箱可能会对性能产生负面影响。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>在字符串连接中使用char数组</p>
		</td>
		<td valign="top">
		<p>启用后，只要在字符串连接中使用char []表达式，编译器就会发出错误或警告，</p>
		<code>“你好”+新char [] {'w'，'o'，'r'，'l'，'d'}</code></td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>vararg参数的不精确类型匹配</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到vararg参数的不精确类型匹配，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>使用'Object'的集合方法的参数类型不太可能</p>
		</td>
		<td valign="top">
		<p>启用后，当某些众所周知的采用“对象”的Collection方法（例如“Map＃get（Object）”）与参数类型一起使用时，编译器将发出错误或警告，该方法似乎与Collection的相应类型参数。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>对预期类型执行严格分析</p>
		</td>
		<td valign="top">
		<p>默认情况下，此分析将应用一些启发式方法来确定是否可以关联两种类型，可以通过此选项进行更改。启用后，将使用严格的兼容性检查替换启发式，即，与预期类型不严格兼容的每个参数都将触发错误或警告。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>方法equals（）的参数类型不太可能</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在'java.lang时发出错误或警告。Object＃equals（Object）'与参数类型一起使用，它似乎与接收者的类型无关，或者相应地在'java.util的参数时使用。对象#equals（Object，Object）'的类型似乎彼此无关。</p>
		</td>
		<td valign="top">
		<p>信息</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>空陈述</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到空语句（例如多余的分号），编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未使用的对象分配</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到未使用的已分配对象时发出错误或警告，例如</p>
		<code>if（name == null）</code><br>
		<code>new IllegalArgumentException（）;</code><br>
		<br>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr id="switch">
		<td valign="top">
		<p>enum上不完整的'switch'案例</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到“switch”语句时发出错误或警告，该语句不包含“default”case，也不会引用所引用枚举的每个枚举常量的case语句。</p>
		<p>Java语言规范<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.11">14.11</a>建议使用此警告。它有助于确保'switch'语句涵盖所有可能的枚举值。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr id="missing_case_despite_default">
		<td valign="top" style="padding-left:2em">
		<p>即使存在“默认”情况也会发出信号</p>
		</td>
		<td valign="top">
		<p>启用后，如果案例不涵盖枚举常量，编译器还会发出错误或警告，即使存在“默认”情况。</p>
		<p>添加新的枚举常量时，此选项有助于捕获缺少的case语句。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>'switch'缺少'default'case</p>
		</td>
		<td valign="top">
		<p>启用后，如果'switch'语句缺少'default'，编译器将发出错误或警告。因此，即使所有可能的值都被“case”语句覆盖，也会标记缺少的“default”。</p>
		<p>此选项有助于确保显式处理新的“switch”表达式值，而不是跳过。在'switch'语句之后，它还可以帮助解释未初始化变量的编译错误：合法值的集合将来会增长，因此变量也需要在'default'情况下初始化。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>“切换”案件落空</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在通过前面的非空案例进入案例时发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>隐藏的拦截块</p>
		</td>
		<td valign="top">
		<p>在try语句的本地，一些catch块可能隐藏其他块，例如</p>
		<code>试试{throw new java.io.CharConversionException（）;</code><br>
		<code>} catch（java.io.CharConversionException e）{</code><br>
		<code>} catch（java.io.IOException e）{}</code><br>
		<br>
		<p>启用后，编译器将对与已检查异常对应的隐藏catch块发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>'终''没有正常完成</p>
		</td>
		<td valign="top">
		<p>启用后，只要“finally”语句未正常完成（例如包含return语句），编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>死代码（例如'if（false）'）</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到死代码时发出错误或警告（例如'if（false）'）。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr id="resource-leak">
		<td valign="top">
		<p>资源泄漏</p>
		</td>
		<td valign="top">
		<p>启用后，如果局部变量包含类型为“java.lang”的值，编译器将发出错误或警告。AutoCloseable'（compliance&gt; = 1.7）或类型'java.io的值。可关闭'（compliance &lt;= 1.6）并且如果流分析显示方法'close（）'未在该值上本地调用。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>潜在的资源泄漏</p>
		</td>
		<td valign="top">
		<p>启用后，如果局部变量包含类型为“java.lang”的值，编译器将发出错误或警告。AutoCloseable'（compliance&gt; = 1.7）或类型'java.io的值。可关闭'（compliance &lt;= 1.6）并且如果流分析显示方法'close（）'未在本地针对所有执行路径调用该值。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>Serializable类没有serialVersionUID</p>
		</td>
		<td valign="top">
		<p>启用后，只要实现'java.io的类型，编译器就会发出错误或警告。Serializable'不包含serialVersionUID字段。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>在继承的方法上缺少synchronized修饰符</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到缺少synchronized修饰符的继承方法时发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>类重写'equals（）'但不覆盖'hashCode（）'</p>
		</td>
		<td valign="top">
		<p>启用时，编译器在遇到覆盖'equals（）'但不覆盖'hashCode（）'的类时会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
</table>

<h3>命名阴影和冲突</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Name shadowing and conflicts section">
	<tr>
		<td valign="top">
		<p>字段声明隐藏了另一个字段或变量</p>
		</td>
		<td valign="top">
		<p>启用后，如果字段声明隐藏了另一个继承的字段，编译器将发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>局部变量声明隐藏另一个字段或变量</p>
		</td>
		<td valign="top">
		<p>启用后，如果局部变量声明隐藏另一个字段或变量，编译器将发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>包括构造函数或setter方法参数</p>
		</td>
		<td valign="top">
		<p>启用后，如果构造函数或setter方法参数隐藏另一个字段或变量，编译器还会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>类型参数隐藏另一种类型</p>
		</td>
		<td valign="top">
		<p>启用后，如果内部类的类型参数隐藏外部类型，编译器将发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>方法不会覆盖包可见方法</p>
		</td>
		<td valign="top">
		<p>包默认方法在另一个包中不可见，因此无法覆盖。启用此选项后，编译器会将此类方案指示为错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>接口方法与受保护的“对象”方法冲突</p>
		</td>
		<td valign="top">
		<p>启用后，只要接口定义了与非继承的Object方法不兼容的方法，编译器就会发出错误或警告。在解决该冲突之前，不能实现这样的接口，例如</p>
		<code>接口I {</code><br>
		<code>int clone（）;</code><br>
		<code>}</code><br>
		<br>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
</table>

<h3>弃用和受限制的API</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Deprecated and restricted API section">
	<tr>
		<td valign="top">
		<p>弃用的API</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将使用已弃用的API作为错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>在弃用的代码中使用已弃用的API</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在不推荐的代码中发出弃用API的信号。问题的严重性由选项“Deprecated API”控制。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>信号覆盖或实施弃用方法</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将发出信号覆盖或实现已弃用的方法。问题的严重性由选项“Deprecated API”控制。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>禁止参考（访问规则）</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将发出访问规则中指定的禁止引用的信号。</p>
		</td>
		<td valign="top">
		<p>错误</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>气馁参考（访问规则）</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将发出访问规则中指定的不鼓励引用的信号。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
</table>

<h3>不必要的代码</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Unnecessary code section">
	<tr>
		<td valign="top">
		<p>不使用局部变量的值</p>
		</td>
		<td valign="top">
		<p>启用后，只要声明了局部变量，编译器就会发出错误或警告，但其值在其范围内从不使用。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>不使用方法参数的值</p>
		</td>
		<td valign="top">
		<p>启用后，只要声明了方法参数，编译器就会发出错误或警告，但其值在其范围内从不使用。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>忽略覆盖和实现方法</p>
		</td>
		<td valign="top">
		<p>启用后，只要声明参数，编译器就不会发出错误或警告，但在覆盖或实现其他方法的方法中从不在其范围内使用。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未使用的类型参数</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将针对未使用的类型参数发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>忽略用'@param'标记记录的参数</p>
		</td>
		<td valign="top">
		<p>启用后，只要使用“@param”标记记录未读参数，编译器就不会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未使用异常参数的值</p>
		</td>
		<td valign="top">
		<p>启用时，如果try语句的catch子句具有未在其正文中使用的异常参数，编译器将发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未使用的导入</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将针对未使用的导入引用发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>未使用的私人会员</p>
		</td>
		<td valign="top">
		<p>启用后，只要声明了私有成员但从未在同一单元中使用，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>不必要的'其他'声明</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到不必要的else语句时发出错误或警告（例如if（condition）return;否则doSomething（）;）。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>不必要的演员或'instanceof'操作</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在遇到不必要的强制转换或“instanceof”操作时发出错误或警告（例如if（object instanceof Object）return;）。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>不必要的抛出异常声明</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到抛出异常的不必要声明，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>

	<tr>
		<td valign="top" style="padding-left:2em">
		<p>忽略覆盖和实现方法</p>
		</td>
		<td valign="top">
		<p>启用后，只要在覆盖或实现其他方法的方法中遇到不必要的抛出异常声明，编译器就不会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>忽略使用'@throws'或'@exception'标记记录的异常</p>
		</td>
		<td valign="top">
		<p>启用后，只要使用'@throws'或'@exception'标记记录不必要的抛出异常声明，编译器就不会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>忽略'异常'和'可扔'</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到“异常”和“Throwable”异常的不必要声明，编译器就不会发出错误或警告</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>	
	<tr>
		<td valign="top">
		<p>未使用的'break'或'continue'标签</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到未使用的“break”或“continue”标签，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>冗余超级界面</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到显式实现已由其任何超类型实现的接口的类型，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
</table>

<h3>通用类型</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Generic types section">
	<tr>
		<td valign="top">
		<p>未经检查的泛型类型操作</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在遇到未经检查的泛型类型操作时发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>使用原始类型</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到使用原始类型（例如List而不是List &lt;String&gt;），编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>使用最终类型绑定声明的泛型类型参数</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到涉及最终类型的类型绑定，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>冗余类型参数（1.7或更高）</p>
		</td>
		<td valign="top">
		<p>启用后，只要在分配表达式中遇到不必要的类型参数，编译器就会发出错误或警告。请使用钻石操作员 - 适用于1.7级及以上。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>忽略由于原始API导致的不可避免的泛型类型问题</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将忽略程序员无法避免的与泛型相关的类型问题，因为引用的API已包含原始类型。例如，类型可能被强制在其方法签名和返回类型中使用原始类型，因为它从超类型覆盖的方法被声明为首先使用原始类型。</p>
		<p>当旧的API最终被泛化时，大多数这些问题都会消失，或者您将看到编译错误，因为您使用的类型参数不正确。对于方法签名中的原始引用，将再次出现原始类型问题。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
</table>

<h3 id="annotations">注释</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Annotations section">
	<tr>
		<td valign="top">
		<p>缺少'@Override'注释</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到覆盖另一个已实现方法的方法，编译器就会发出错误或警告，并且缺少“@Override”注释。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>包括接口方法的实现（1.6或更高版本）</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到覆盖或实现接口中声明的方法的方法，编译器也会发出错误或警告，并且缺少“@Override”注释。<br>请注意，如果编译器合规性级别为1.6或更高，则仅允许在此类方法上使用“@Override”，因此此错误或警告将永远不会出现在1.5代码中。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>	
	<tr>
		<td valign="top">
		<p>缺少'@Deprecated'注释</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到具有javadoc“@deprecated”标记的类型，但没有相应的Java“@Deprecated”注释，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>注释用作超级界面</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到实现注释的类型，编译器就会发出错误或警告。虽然可能，但这被认为是不好的做法。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>'@SuppressWarnings'中未处理的令牌</p>
		</td>
		<td valign="top">
		<p>启用后，只要遇到'@SuppressWarnings'注释中的未知标记，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>启用“@SuppressWarnings”注释</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将处理“@SuppressWarnings”注释。禁用时，它将像删除所有'@SuppressWarnings'注释一样。</p>
		<p>另请参阅<a href="../../../../tasks/task-suppress_warnings.htm">使用@SuppressWarnings排除警告</a> 。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>未使用的'@SuppressWarnings'令牌</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在“@SuppressWarnings”注释中遇到未使用的标记时发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>使用'@SuppressWarnings'抑制可选错误</p>
		</td>
		<td valign="top">
		<p>启用后，'@SuppressWarnings'注释也将禁止可选的编译错误，即此处设置为“Error”的选项。无法抑制强制编译错误。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
</table>

<h3 id="null_analysis">空分析</h3>

<table border="1" cellspacing="0" cellpadding="5" width="100%" summary="Annotations section">
	<tr>
		<td valign="top">
		<p>空指针访问</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到一个肯定为null的局部变量被解除引用时发出错误或警告。请注意，分析无法找到所有空指针访问，请参阅<strong>潜在空指针访问</strong> 。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>潜在的空指针访问</p>
		</td>
		<td valign="top">
		<p>启用后，编译器会在遇到可能为null的局部变量时取消引用时发出错误或警告。请注意，分析相当保守，只考虑存在可疑情况的情况。</p>
		<p>通过使用null注释可以提高分析的质量，可以使用选项<b>Enable an based-based null analysis启用</b>
		</p></td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>冗余空检查</p>
		</td>
		<td valign="top">
		<p>启用后，只要不能为null的局部变量测试为null，编译器就会发出错误或警告。</p>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>在null分析中包含'assert'</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在执行空分析时遵循“assert”语句。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p>启用基于注释的空分析</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将解释注释@ Nullable，@ NonNull和@NonNullByDefault，以指定给定类型是否包含值“null”。</p>
		<p>这些分析的效果进一步受以下子选项控制。</p>
		<p>另请参见<a href="../../../../tasks/task-using_null_annotations.htm">使用空注释</a> 。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr id="null_spec_violation">
		<td valign="top" style="padding-left:2em">
		<p>违反null规范</p>
		</td>
		<td valign="top">
		<p>根据此选项，只要检测到以下某种情况，编译器就会发出错误或警告：</p> 
		<ol>
		<li>使用非<em>空</em>注释声明的方法返回<em>可</em>为<em>空的</em>表达式。</li> 
		<li>可以为<em>null的</em>表达式作为参数传递给方法调用，其中使用非<em>空</em>注释声明被调用方法的相应参数。</li> 
		<li><em>可空</em>表达式分配给使用非<em>空</em>注释声明的局部变量。</li> 
		<li>覆盖使用非空注释声明的继承方法的方法尝试通过指定可为空的注释（禁止逆变返回）来放宽该约定。</li> 
		<li>覆盖对其至少一个参数具有可空声明的继承方法的方法，尝试通过为其相应参数指定非空注释（禁止协变参数）来收紧该空契约。</li>
		</ol>
		<p>在上面，如果静态地知道要求值为<code>null</code> ，或者如果使用可为空的注释声明它，则表达式被认为是<em>可</em>为空的。</p>
		</td>
		<td valign="top">
		<p>错误</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>空注释与空推理之间的冲突</p>
		</td>
		<td valign="top">
		<p>根据此选项，只要检测到以下某种情况，编译器就会发出错误或警告：</p>
		<ol>
		<li>使用非空注释声明的方法返回一个静态已知的表达式，该表达式在某些流上求值为空值。</li> 
		<li>静态已知在某些流上计算为空值的表达式作为参数传递给方法调用，其中使用非空注释声明被调用方法的相应参数。</li> 
		<li>静态已知在某些流上计算为空值的表达式将分配给使用非空注释声明的局部变量。</li> 
		</ol> 
		</td>
		<td valign="top">
		<p>错误</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>未经检查的从非注释类型到@NonNull类型的转换</p>
		</td>
		<td valign="top">
		<p>根据此选项，只要检测到以下某种情况，编译器就会发出错误或警告：</p>
		<ol>
		<li>使用非空注释声明的方法返回一个表达式，该表达式的空值信息不足以静态证明在运行时没有流将传递空值。</li> 
		<li>可用于静态证明它在运行时永远不会计算为空值的空值信息不足的表达式在方法调用中作为参数传递，其中使用非空注释声明被调用方法的相应参数。</li> 
		<li>可用于静态证明它在运行时永远不会计算为空值的空值信息不足的表达式被分配给使用非空注释声明的局部变量。</li> 
		</ol> 
		<p>未经检查的转换通常是使用其他未注释的变量或方法的结果。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr id="pessimistic_analysis">
		<td valign="top" style="padding-left:2em">
		<p>通过对自由类型变量的悲观分析检测到的问题</p>
		</td>
		<td valign="top">
		<p>除非设置为“忽略”，否则在两个方向上<a href="../../../../tasks/task-using_null_type_annotations.htm#pessimistic_analysis">悲观地分析</a>不受任何显式空注释影响的类型变量：当读取此类型的值时，假定它可以为空。当此类型显示为所需类型（即，在赋值或变量初始化的左侧，或作为检查return语句的方法返回类型）时，类型被视为需要nonnull属性。</p>
		<p>报告中由于此悲观分析而报告的问题与此选项中给出的级别一致。</p>
		<p>仅当使用<a href="../../../../tasks/task-using_null_type_annotations.htm">空类型注释</a>时，此选项才有意义。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr id="unsafe_interpretation_generic_legacy">
		<td valign="top" style="padding-left:2em">
		<p>不安全的'@Nonnull'解释库中的自由类型变量</p>
		</td>
		<td valign="top">
		<p>启用后，如果满足以下所有条件，编译器将针对方法调用发出错误或警告：</p>
		<ul>
			<li>方法声明的返回类型是一个没有任何null注释的类型变量。</li>
			<li>对于给定的调用，此类型变量将替换为非空类型。</li>
			<li>声明该方法的类型由第三方库提供。</li>
			<li>此库类型不存在空注释，无论是在其类文件中还是使用外部注释。</li>
		</ul>
		<p>这种特殊情况利用该选项一致地用非空类型替换所有出现的类型变量，但是它存在库类型可能不知道空注释的风险，因此缺少针对特定类型出现的必需@Nullable注释变量。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr><tr>
		<td valign="top" style="padding-left:2em">
		<p>冗余null注释</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在应用非空注释时发出错误或警告，尽管适用于当前位置的默认值已实现相同的效果。可以使用@NonNullByDefault批注来设置这样的默认值。</p>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr id="nonnull_annotation_dropped">
		<td valign="top" style="padding-left:2em">
		<p>'@NonNull'参数未在重写方法中注释</p>
		</td>
		<td valign="top">
		<p>启用后，如果以下所有方法成立，编译器将针对覆盖继承方法的方法的参数发出错误或警告：</p>
		<ul>
		<li>重写的方法将相应的参数声明为非null。</li>
		<li>覆盖方法中的参数没有空注释。</li>
		<li>覆盖方法不受nullness缺省值的影响。</li>
		<li>禁用null注释的继承。</li>
		</ul>
		</td>
		<td valign="top">
		<p>警告</p>
		</td>
	</tr>
	<tr>
		<td valign="top" style="padding-left:2em">
		<p>在包上缺少'@NonNullByDefault'注释</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将在以下情况下发出错误或警告：</p>
		<ol>
		<li>当包不包含默认的nullness注释时，由于缺少package-info.java或缺少package-info.java中的默认nullness注释。</li>
	 	<li>当默认包中的类型不包含默认的nullness注释时。</li>
		</ol>
		</td>
		<td valign="top">
		<p>忽视</p>
		</td>
	</tr>
	<tr id="null_annotation_names">
		<td valign="top" style="padding-left:2em">
		<p>对默认规范使用默认注释</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将使用默认的注释集来表示空值规范。这些注释包含在<b>org.eclipse.jdt.annotation</b>包中的Eclipse SDK中。</p>
		<p>您可以指定要在项目中使用的不同注释名称，但请注意，Eclipse编译器仅支持默认注释中指定的语义：</p>
		<ul>
			<li><b>org.eclipse.jdt.annotation。Nullable</b> ：Java注释类型的完全限定名称，当应用于方法签名，变量声明或字段声明中的类型时，将被解释为null是该位置的合法值的规范。<br>当前支持的位置是：方法参数，方法返回类型，局部变量和字段。
			</li>
			<li><b>org.eclipse.jdt.annotation。NonNull</b> ：Java注释类型的完全限定名称，当应用于方法签名，变量声明或字段声明中的类型时，将被解释为null在该位置<b>不是</b>合法值的规范。<br>当前支持的位置是：方法参数，方法返回类型，局部变量和字段。
			</li>
			<li>
				<b>org.eclipse.jdt.annotation。NonNullByDefault</b> ：Java注释类型的完全限定名称。当应用于没有注释参数的元素时，注释元素中的方法签名和字段声明中的所有未注释类型都将被视为使用非空注释指定它们。<br>仅在使用默认注释类型<code>org.eclipse.jdt.annotation.NonNullByDefault</code> ，也支持相反的效果：当使用常量'false'作为其参数（或类型注释的情况下为'{}'）应用注释时，外部作用域的所有相应默认值将针对带注释的元素取消。
			</li>
		</ul>
		<p>编译器仅为null规范支持一组<em>主要</em>的注释类型。另外，可以配置任意数量的<em>辅助</em>注释类型以携带相同的语义。支持辅助注释类型的唯一目的是与使用除当前项目的主要注释类型之外的其他空注释指定的第三方代码进行交互。</p>
		</td>
		<td valign="top">
		<p>上</p>
		</td>
	</tr>
	<tr id="inherit_null_annotations">
		<td valign="top" style="padding-left:2em">
		<p>继承null注释</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将检查每个方法而不显示任何显式空注释：如果它覆盖具有空注释的方法，则它将当前方法视为具有与重写方法相同的注释。</p>
	 	  <p>在传递应用继承之后以及在重写方法的站点上应用任何默认空值之后，注释继承将使用重写方法的<em>有效</em>空值。</p>
	 	  <p>如果不同的隐式空注释（来自非空默认和/或重写方法）适用于方法签名中的相同类型，则将其标记为错误，并且必须使用显式空注释来消除歧义。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
	<tr id="syntactic_null_analysis_for_fields">
		<td valign="top" style="padding-left:2em">
		<p>为字段启用语法空分析</p>
		</td>
		<td valign="top">
		<p>启用后，编译器将检测某些语法星座，其中通常会引发针对字段引用的空相关警告但可以在低风险时被抑制，因为之前已知相同的字段引用非空。使用此选项时，请参阅<a href="../../../../tasks/task-using_null_annotations.htm#syntactic_analysis">这些提示</a> 。</p>
		</td>
		<td valign="top">
		<p>离</p>
		</td>
	</tr>
</table>

<p>当启用<strong>处理上述错误（如致命编译错误</strong> ）时，所有生成的错误（致命或可配置）都会导致不可执行的代码。如果禁用，则只要没有致命错误（语法错误，类型错误或根据Java语言规范的任何错误），您的代码就可以执行。</p>

<h3 class="related">相关概念</h3>
<a href="../../../../../org.eclipse.platform.doc.user/concepts/cprbview.htm">问题观点</a><br>
<a href="../../../../concepts/concept-quickfix-assist.htm">快速解决</a><br>
<a href="../../../../concepts/concept-java-builder.htm">Java构建器</a><br>
<a href="../../../../tasks/task-suppress_warnings.htm">使用@SuppressWarnings排除警告</a>
</body>
</html>