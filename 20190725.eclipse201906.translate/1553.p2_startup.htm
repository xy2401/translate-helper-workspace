<html lang="zh-Hans" dir="ltr">
<head>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2008, 2016. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<meta http-equiv="Content-Style-Type" content="text/css"></meta>

<link rel="STYLESHEET" href="../book.css" type="text/css" charset="ISO-8859-1"></link>
<title>启动时强制更新</title>

<link rel="stylesheet" type="text/css" href="../book.css"></link>
</head>
<body bgcolor="#ffffff" dir="ltr">
<h2>启动时强制更新</h2>
<p>有时最简单的UI不是UI。在高度管理的产品安装中，可能需要在每次启动时自动更新应用程序，而无需用户干预。在这种情况下，更新并非真正“无头”，因为在搜索更新时会显示进度指示器。用户可以取消更新，但不能干预更新。如果未找到更新，则通知用户。
</p>
<p><img border="0" src="images/p2forcedupdate.png" alt="进度指示器显示更新搜索">
</p>
<p>在此配置中，根本不需要p2 UI类库bundle（ <b>org.eclipse.equinox.p2.ui</b> ）。仅使用p2核心代码来实现更新。可以在<a href="http://git.eclipse.org/c/equinox/rt.equinox.p2.git/tree/examples/org.eclipse.equinox.p2.examples.rcp.prestartupdate/">此处</a>找到使用此方法的示例RCP应用程序。
</p>
<p>在这种情况下，您需要确保在执行更新检查时启动时所有p2服务都可用。必须启动示例包本身。不太明显的是必须启动<b>org.eclipse.equinox.ds</b>包，以便找到所有声明的服务。这可以通过多种方式完成，具体取决于您运行示例的方式：</p>
<ul>
<li>在产品编辑器的“配置”选项卡中设置捆绑包起始级别（构建的.product文件）</li>
<li>在已构建的应用程序的config.ini中强制启动bundle</li>
<li>如果您只是在Eclipse中启动示例，请在启动配置中设置bundle启动级别</li>
</ul>

<p>更新检查在示例的<b>ApplicationWorkbenchWindowAdvisor</b>类的<b>postWindowOpen（）</b>方法中执行。此方法设置进度监视，调用更新搜索，并处理任何错误或通知。它使用首选项来记住它是否在更新后重新启动，以便在更新后重新启动应用程序时不会重复更新搜索。
</p>
<p>更新检查方法本身相当简单，因为它不会尝试让用户参与对更新做出任何选择。它使用<b><a href="../reference/api/org/eclipse/equinox/p2/operations/package-summary.html">p2 Operations API</a></b> （Eclipse 3.6中的新增功能）来搜索更新并执行更新。
</p>
<pre>public class P2Util {// XXX检查此应用程序的更新并返回状态。static IStatus checkForUpdates（IProvisioningAgent agent，IProgressMonitor monitor）抛出OperationCanceledException {ProvisioningSession session = new ProvisioningSession（agent）; //默认更新操作使用默认配置文件根标记查找当前//正在运行的配置文件的更新。要更改//正在更新哪些可安装单元，请使用更详细的//构造函数。UpdateOperation操作= new UpdateOperation（session）; SubMonitor sub = SubMonitor.convert（monitor，“Checking for application updates ...”，200）; IStatus status = operation.resolveModal（sub.newChild（100））; if（status.getCode（）== UpdateOperation。STATUS_NOTHING_TO_UPDATE）{返回状态; } if（status.getSeverity（）== IStatus。CANCEL）抛出新的OperationCanceledException（）; if（status.getSeverity（）！= IStatus。错误）{//更复杂的状态处理可能包括向用户显示如果存在倍数，可以使用哪些更新//区分补丁与更新等等。//在此示例中，我们只是按操作建议进行更新。ProvisioningJob job = operation.getProvisioningJob（null）; status = job.runModal（sub.newChild（100））; if（status.getSeverity（）== IStatus。CANCEL）抛出新的OperationCanceledException（）;返回状态; }}</pre>
</body>
</html>