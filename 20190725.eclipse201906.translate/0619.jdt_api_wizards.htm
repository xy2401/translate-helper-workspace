<html lang="zh-Hans"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2011. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page.">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="STYLESHEET" href="../book.css" type="text/css" charset="ISO-8859-1">
<title>Java向导页面</title>
<link rel="stylesheet" type="text/css" href="../book.css">
</head>
<body >
<h2>Java向导页面</h2>
<p><a href="../reference/api/org/eclipse/jdt/ui/wizards/package-summary.html"><b>org.eclipse.jdt.ui.wizards</b></a>包提供了用于创建和配置Java元素的向导页面。提供了几个预制页面供您使用。</p>
<h3 class="c1">创建新的Java元素</h3>
<p>向导页面的层次结构支持创建新的Java元素。</p>
<p><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewElementWizardPage.html"><b>NewElementWizardPage</b></a>是定义向导基本操作的抽象类。层次结构中提供了其他抽象类，用于对具体向导提供的功能进行自定义。</p>
<p>具体的创建向导可以直接使用，通常不打算进行子类化。</p>
<ul>

<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewClassWizardPage.html"><b>NewClassWizardPage</b></a>允许用户定义新的Java类。客户端可以实例化和配置向导页面。实现自己的类型向导子类<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewTypeWizardPage.html"><b>NewTypeWizardPage</b></a> 。要简单地打开原始的“New Java Class wizard”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewClassWizardAction.html"><b>OpenNewClassWizardAction</b></a> 。</li>
<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewInterfaceWizardPage.html"><b>NewInterfaceWizardPage</b></a>允许用户定义新的Java接口。客户端可以实例化和配置向导页面。实现自己的类型向导子类<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewTypeWizardPage.html"><b>NewTypeWizardPage</b></a> 。要简单地打开原始的“New Java Interface wizard”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewInterfaceWizardAction.html"><b>OpenNewInterfaceWizardAction</b></a> 。</li>
<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewEnumWizardPage.html"><b>NewEnumWizardPage</b></a>允许用户定义新的Java枚举。客户端可以实例化和配置向导页面。实现自己的类型向导子类<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewTypeWizardPage.html"><b>NewTypeWizardPage</b></a> 。要简单地打开原始的“New Java Enum向导”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewEnumWizardAction.html"><b>OpenNewEnumWizardAction</b></a> 。</li>
<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewAnnotationWizardPage.html"><b>NewAnnotationWizardPage</b></a>允许用户定义新的Java注释。客户端可以实例化和配置向导页面。实现自己的类型向导子类<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewTypeWizardPage.html"><b>NewTypeWizardPage</b></a> 。要简单地打开原始的“New Java Annotation向导”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewAnnotationWizardAction.html"><b>OpenNewAnnotationWizardAction</b></a> 。</li>
<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewPackageWizardPage.html"><b>NewPackageWizardPage</b></a>允许用户创建新的Java包。客户端可以实例化和配置向导页面。要简单地打开原始的“New Java Package wizard”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewPackageWizardAction.html"><b>OpenNewPackageWizardAction</b></a> 。</li>

<li><a href="../reference/api/org/eclipse/jdt/ui/wizards/NewJavaProjectWizardPageOne.html"><b>NewJavaProjectWizardPageOne</b></a>和<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewJavaProjectWizardPageTwo.html"><b>NewJavaProjectWizardPageTwo</b></a>允许用户创建新的Java项目向导。客户端可以在自己的项目向导中使用和配置这些页面。要简单地打开原始的“New Java Project向导”，请使用<a href="../reference/api/org/eclipse/jdt/ui/actions/OpenNewJavaProjectWizardAction.html"><b>OpenNewJavaProjectWizardAction</b></a></li>
</ul>
<h3>提供类路径容器向导页面</h3>
<p>接口<a href="../reference/api/org/eclipse/jdt/ui/wizards/IClasspathContainerPage.html"><b>IClasspathContainerPage</b></a>定义了一个用于提供向导页面的结构，该向导页面允许用户定义新的类路径容器条目或编辑现有的容器条目。如果您的插件使用JDT Core <b><a href="../reference/extension-points/org_eclipse_jdt_core_classpathContainerInitializer.html">org.eclipse.jdt.core.classpathContainerInitializer</a></b>扩展点定义了自己类型的类路径容器，那么您可能需要定义相应的向导页面以编辑和创建此类型的类路径容器。</p>
<p>您的插件标记应提供扩展名<b><a href="../reference/extension-points/org_eclipse_jdt_ui_classpathContainerPage.html">org.eclipse.jdt.ui.classpathContainerPage</a> 。</b>在扩展标记中，您提供实现<a href="../reference/api/org/eclipse/jdt/ui/wizards/IClasspathContainerPage.html"><b>IClasspathContainerPage</b></a>的类的名称。如果在向导页面中需要有关类路径选择的上下文的其他信息，则可以实现<a href="../reference/api/org/eclipse/jdt/ui/wizards/IClasspathContainerPageExtension.html"><b>IClasspathContainerPageExtension</b></a> 。如果配置页面在添加时想要返回多个条目，请实现<a href="../reference/api/org/eclipse/jdt/ui/wizards/IClasspathContainerPageExtension.html"><b>IClasspathContainerPageExtension2</b></a> 。</p>
<h3>自定义向导页面</h3>

<p>除了使用预制页面之外，您还可以将向导页面子类化以添加自己的输入字段或影响代码生成。您应该使用<a href="../reference/api/org/eclipse/jdt/ui/wizards/NewElementWizardPage.html"><b>NewElementWizardPage</b></a>层次结构中的抽象类来自定义向导，而不是子类化具体类。</p>
<p>下面是一个新类型向导页面的示例，该页面是为了创建JUnit测试用例类而自定义的。该页面使用“junit.framework”初始化超类字段。TestCase“并添加一个复选框，控制是否要创建<code>setUp()</code>和<code>tearDown()</code>方法的方法存根。</p>
<pre class="color1">
public class TestCaseWizardPage extends NewTypeWizardPage {
    private Button fCreateStubs;

    public TestCaseWizardPage() {
        super(true, "TestCaseWizardPage");
    }

    /**
     * The wizard managing this wizard page must call this method
     * during initialization with a corresponding selection.
     */   
    public void init(IStructuredSelection selection) {
        IJavaElement jelem= getInitialJavaElement(selection);
        initContainerPage(jelem);
        initTypePage(jelem);
        doStatusUpdate();
    }

    private void doStatusUpdate() {
        // define the components for which a status is desired
        IStatus[] status= new IStatus[] {
            fContainerStatus,
            isEnclosingTypeSelected() ? fEnclosingTypeStatus : fPackageStatus,
            fTypeNameStatus,
        };
        updateStatus(status);
    }


    protected void handleFieldChanged(String fieldName) {
        super.handleFieldChanged(fieldName);

        doStatusUpdate();
    }
 
    public void createControl(Composite parent) {
        initializeDialogUnits(parent);
        Composite composite= new Composite(parent, SWT.NONE);
        int nColumns= 4;
        GridLayout layout= new GridLayout();
        layout.numColumns= nColumns;
        composite.setLayout(layout);

        // Create the standard input fields
        createContainerControls(composite, nColumns);
        createPackageControls(composite, nColumns);
        createSeparator(composite, nColumns);
        createTypeNameControls(composite, nColumns);
        createSuperClassControls(composite, nColumns);

        // Create the checkbox controlling whether we want stubs
        fCreateStubs= new Button(composite, SWT.CHECK);
        fCreateStubs.setText("Add 'setUp()' and 'tearDown()' to new class");
        GridData gd= new GridData();
        gd.horizontalSpan= nColumns;
        fCreateStubs.setLayoutData(gd);

        setControl(composite);

        // Initialize the super type field and mark it as read-only
        setSuperClass("junit.framework.TestCase", false);
    }

    protected void createTypeMembers(IType newType, ImportsManager imports, IProgressMonitor monitor) throws CoreException {
        if (fCreateStubs.getSelection()) {
            String setUpMathod= "public void setUp() {}";
            newType.createMethod(setUpMathod, null, false, null);

            String tearDownMathod= "public void tearDown() {}";
            newType.createMethod(tearDownMathod, null, false, null); 
        }
   }
}

</pre>
</body>
</html>