<html lang="zh-Hans" >
<head>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2013. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page.">

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">

<link rel="STYLESHEET" href="../book.css" type="text/css" charset="ISO-8859-1">
<title>最大化和最小化</title>

</head>
<body bgcolor="#ffffff" >

<h1>最大化和最小化Eclipse演示文稿的元素</h1>

<p>eclipse表示提供了一个丰富的环境，包括（以其基本形式）一个<i>编辑区</i> （包含一个或多个显示开放编辑器的堆栈），由一个或多个<i>View Stacks</i> （每个包含一个或多个视图）包围。这些不同的部分争夺有价值的屏幕空间，正确管理每个部分的屏幕数量可以大大提高您在IDE中的生产力。</p>
<p>管理这个问题的两种最常见的机制是“最小化”（即让我尽可能少地使用空间）和“最大化”（即尽可能多地给我空间）。eclipse表示提供了多种访问这些操作的方法：</p>
<ol>
  <li>使用堆栈边框上提供的最小化和最大化按钮</li>
  <li>双击堆栈</li>
  <li>使用'Ctrl + M'：这是一个命令的键绑定，它将在当前活动部分的“最大化”和“恢复”（即正常）状态之间切换。</li>
</ol>

<p class="Para">
   <img src="../images/minmaxOptions.png" alt="访问最小化和最大化操作" border="0">
</p>

<h4>最大化：</h4>
<p>有时希望将注意力集中在一个特定部分上，而将其他部分排除在外。当然，最受欢迎的候选者是最大化编辑器区域，以便尽可能多地显示可用于编辑的显示（但是有一些工作流程也可以集中在视图上）。
</p>
<p>从3.3开始，默认表示通过最小化除最大化<i>之外</i>的所有堆栈来实现最大化行为。这允许最大化的堆栈完全占据主要演示，同时仍允许通过使用其<i>修剪堆栈中</i>的图标来访问透视图中的任何打开视图（窗口边缘周围的区域称为“修剪”）。
</p>
<p>同样在3.3中，管理编辑器最大化的行为已经更改为在完整的编辑器区域上运行（而不是像3.0和2.1演示文稿中那样简单地最大化特定的编辑器堆栈）。这允许“比较”工作流，这些工作流需要能够同时在拆分编辑器区域中查看这两个文件。
</p>

<h4>最小化：</h4>
<p>优化屏幕区域使用的另一种方法是直接最小化当前没有兴趣的堆栈。从3.3开始，最小化堆栈的默认表示将使其移动到工作台窗口边缘的修剪区域，从而创建<i>修剪堆栈</i> 。视图堆栈最小化为修剪表示，其中包含堆栈中每个视图的图标。
</p>

<p class="Para">
   <img src="../images/TrimStack.png" alt="修剪视图堆栈的表示" border="0">
</p>
<p>编辑器区域的最小化行为有些不同;最小化编辑区域导致修剪堆栈仅包含代表整个编辑器区域的占位符图标，而不是每个打开编辑器的图标（因为在大多数情况下，所有图标都是相同的，使它们基本上无用）。
</p>
<p class="Para">
   <img src="../images/EATrim.png" alt="编辑区域的修剪表示" border="0">
</p>
<p>如果您的特定工作流程需要有多个元素（即同时在演示文稿中包含编辑区<i>和</i>视图堆栈），您仍然可以通过最小化非当前的堆栈来获得额外的屏幕空间利益。这将从主要演示文稿中删除它们并将它们作为<i>Trim Stacks</i>放置在工作台窗口的外边缘，从而为演示文稿中的剩余堆栈留出更多空间。
</p>
<p>
<b>注意：</b>有两种方法可以在装饰中结束堆栈：</p>
<ul>
<li>直接最小化堆栈</li>
<li>由于另一个堆栈被最大化</li>
</ul>

<p>根据Trim Stack的创建方式，它的行为是不同的;当取消最大化时，只有在初始最大化期间创建的修剪堆栈将恢复到主要演示文稿，而独立最小化的堆栈将保持这种方式。
</p>
<p>
<b><i>提示：</i></b>这种差异很重要，因为它允许您对演示文稿进行细粒度控制。虽然使用最大化是单击操作，但它是“全有或全无”范例（即，不允许其他堆栈与最大化堆栈共享演示文稿）。虽然适合大多数任务，但您可能会发现自己希望演示文稿显示多个堆栈。在这些情况下不要最大化;尽量减少， <i>除非</i>你在演示文稿中想要的那些所有其他栈。设置完成后，您仍可以随后最大化编辑器区域，但非最大化将仅恢复共享演示文稿的特定堆栈，而不是您已明确最小化的堆栈。
</p>
<h4>正常演示</h4>
<p class="Para">
   <img src="../images/EANormal.png" alt="正常演示" border="0">
</p>

<h4>编辑区最大化</h4>
<p class="Para">
   <img src="../images/EAMaxed.png" alt="编辑区最大化" border="0">
</p>

<h3 class="related">相关任务</h3>
    <a href="qs-39.htm">重新排列视图和编辑器</a><br>
    <a href="qs-39d.htm">重新排列视图</a><br>
    <a href="qs-39e.htm">平铺编辑</a><br>
    <a href="qs-39f.htm">重新排列选项卡式视图</a>

</body>
</html>