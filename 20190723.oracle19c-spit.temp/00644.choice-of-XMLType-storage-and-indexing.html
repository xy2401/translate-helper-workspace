<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">
      <meta name="description" content="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">
      <title>Choice of XMLType Storage and Indexing</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Developer's Guide ">
      <meta property="og:description" content="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96222-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="XML-Schema-and-object-relational-XMLType.html" title="Previous" type="text/html">
      <link rel="next" href="XML-Schema-and-query-basic.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer's Guide">
    <meta name="dcterms.isVersionOf" content="ADXDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="XML-Schema-and-object-relational-XMLType.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="XML-Schema-and-query-basic.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-Schema-and-object-relational-XMLType.html" property="item" typeof="WebPage"><span property="name">XML Schema and Object-Relational XMLType </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Choice of XMLType Storage and Indexing</li>
            </ol>
            <a id="GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" name="GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1"></a><a id="ADXDB6348"></a>
            
            <h2 id="ADXDB-GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" class="sect2"><span class="enumeration_chapter">16 </span>Choice of XMLType Storage and Indexing
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Important design choices for your application include what <code class="codeph">XMLType</code> storage model to use and which indexing approaches to use.
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF">Introduction to Choosing an XMLType Storage Model and Indexing Approaches</a><br><code class="codeph">XMLType</code> is an abstract SQL data type that provides different storage and indexing models to best fit your XML data and your use of it. Because it is an abstract data type, your applications and database queries gain in flexibility: the same interface is available for all <code class="codeph">XMLType</code> operations.
                  </li>
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-D91AC581-73C0-4211-AA20-E524CCDCB285">XMLType Use Case Spectrum: Data-Centric to Document-Centric</a><br>When choosing an <code class="codeph">XMLType</code> storage model, consider the nature of your XML data and the ways you use it. There is a spectrum of use cases, ranging from most data-centric to most document-centric.
                  </li>
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604">Common Use Cases for XML Data Stored as XMLType</a><br>Recommendations are provided for application use cases that correspond to common use cases for XML data stored as <code class="codeph">XMLType</code>.
                  </li>
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-320807FC-DB58-4600-8F92-A1247A354AE5">XMLType Storage Model Considerations</a><br>For most use cases, Oracle recommends that you use binary XML storage of <code class="codeph">XMLType</code>. Object-relational storage is appropriate in special cases.
                  </li>
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780">XMLType Indexing Considerations</a><br>For <code class="codeph">XMLType</code> data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use <code class="codeph">XMLIndex</code> indexing with <code class="codeph">XMLType</code> data that is stored as binary XML.
                  </li>
                  <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7">XMLType Storage Options: Relative Advantages</a><br>Each <code class="codeph">XMLType</code> storage model has particular advantages and disadvantages.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="The use of XML Schema and object-relational storage of XMLType data is covered.">XML Schema and Object-Relational XMLType</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB6349"></a><div class="props_rev_3"><a id="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF" name="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF"></a><h3 id="ADXDB-GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF" class="sect3"><span class="enumeration_section">16.1 </span>Introduction to Choosing an XMLType Storage Model and Indexing Approaches
               </h3>
               <div>
                  <p><code class="codeph">XMLType</code> is an abstract SQL data type that provides different storage and indexing models to best fit your XML data and your use of it. Because it is an abstract data type, your applications and database queries gain in flexibility: the same interface is available for all <code class="codeph">XMLType</code> operations.
                  </p>
                  <p>Different applications use XML data in different ways. Sometimes it is constructed from relational data sources, so it is relatively structured. Sometimes it is used for extraction, transformation, and loading (ETL) operations, in which case it is also quite structured. Sometimes it is used for free-form documents (unstructured or semi-structured) such as books and articles. </p>
                  <p>Retrieval approaches can also be different for different kinds of data. Data-centric use cases often involve a fixed set of queries, whereas document-centric use cases often involve arbitrary (ad-hoc) queries.</p>
                  <p>Because there is a broad spectrum of XML usage, there is no one-size-fits-all storage model that offers optimal performance and flexibility for every use case. Oracle XML&nbsp;DB offers two storage models for <code class="codeph">XMLType</code>, and several indexing methods appropriate to these different storage models. You can tailor performance and functionality to best fit the kind of XML data you have and the ways you use it. 
                  </p>
                  <p>Therefore, one key decision to make is which <code class="codeph">XMLType</code> storage model to use for which XML data. This chapter helps you choose the best storage option for a given use case.
                  </p>
                  <p><code class="codeph">XMLType</code> tables and columns can be stored in the following ways:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="bold">Binary XML storage</span> &#x2013; This is also referred to as <strong class="term">post-parse persistence</strong>. It is the default storage model for Oracle XML&nbsp;DB. It is a post-parse, binary format designed specifically for XML data. Binary XML is compact and XML schema-aware. The biggest advantage of Binary XML storage is <span class="italic">flexibility</span>: you can use it for XML schema-based documents or for documents that are not based on an XML schema. You can use it with an XML schema that allows for high data variability or that evolves considerably or unexpectedly. This storage model also provides efficient partial updating and streamable query evaluation.
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">Object-relational storage</span> &#x2013; This is also referred to as <a id="d79426e186" class="indexterm-anchor"></a><strong class="term">structured</strong> storage and <strong class="term">object-based persistence</strong>. This storage model represents an entity-relationship (ER) decomposition of the XML data. It provides the best performance for highly structured data with a known and more or less fixed set of queries. Query performance matches that of relational data, and updates can be performed in place.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF__GUID-23E8420B-C100-4F76-A389-F9FB801864A6">
                     <p class="notep1">Note:</p>
                     <p>Starting with Oracle Database&nbsp;12c Release 1 (12.1.0.1), the unstructured (<code class="codeph">CLOB</code>) storage model for <code class="codeph">XMLType</code> is <span class="italic">deprecated</span>. Use binary XML storage instead. 
                     </p>
                     <p>If you have exising <code class="codeph">XMLType</code> data that is stored as <code class="codeph">CLOB</code> data then consider moving it to binary XML storage format using Oracle GoldenGate. If document fidelity is important for a particular XML document then store a copy of it in a relational <code class="codeph">CLOB</code> column.
                     </p>
                  </div>
                  <p>Oracle XML&nbsp;DB supports the following kinds of indexes on <code class="codeph">XMLType</code> data. 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>B-tree functional indexes on object-relational storage</p>
                     </li>
                     <li>
                        <p>XML search index on binary XML storage</p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLIndex</code> with structured and unstructured components on binary XML storage
                        </p>
                     </li>
                     <li>
                        <p>B-tree indexes on the secondary tables created automatically for <code class="codeph">XMLIndex</code> (both structured and unstructured components) on binary XML storage
                        </p>
                     </li>
                  </ul>
                  <p>Different use cases call for different combinations of <code class="codeph">XMLType</code> storage model and indexes.
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></li>
                        <li><a href="choice-of-XMLType-storage-and-indexing.html#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB3979"></a><a id="ADXDB6350"></a><div class="props_rev_3"><a id="GUID-D91AC581-73C0-4211-AA20-E524CCDCB285" name="GUID-D91AC581-73C0-4211-AA20-E524CCDCB285"></a><h3 id="ADXDB-GUID-D91AC581-73C0-4211-AA20-E524CCDCB285" class="sect3"><span class="enumeration_section">16.2 </span>XMLType Use Case Spectrum: Data-Centric to Document-Centric
               </h3>
               <div>
                  <p>When choosing an <code class="codeph">XMLType</code> storage model, consider the nature of your XML data and the ways you use it. There is a spectrum of use cases, ranging from most data-centric to most document-centric.
                  </p>
                  <p>This is illustrated in <a href="choice-of-XMLType-storage-and-indexing.html#GUID-D91AC581-73C0-4211-AA20-E524CCDCB285__CHDGBEFE">Figure 16-1</a> , which shows the most data-centric cases at the left and the most document-centric cases at the right.
                  </p>
                  <div class="figure" id="GUID-D91AC581-73C0-4211-AA20-E524CCDCB285__CHDGBEFE">
                     <p class="titleinfigure">Figure 16-1 XML Use Cases and XMLType Storage Models</p><img src="img/adxdb057.png" width="584" alt="Description of Figure 16-1 follows" title="Description of Figure 16-1 follows" longdesc="img_text/adxdb057.html"><br><a href="img_text/adxdb057.html">Description of "Figure 16-1 XML Use Cases and XMLType Storage Models"</a></div>
                  <!-- class="figure" -->
                  <p><strong class="term">Data-centric</strong> data is highly structured, with relatively static and predictable structure, and your applications take advantage of this structure. The data conforms to an XML schema. 
                  </p>
                  <p><strong class="term">Document-centric</strong> data can be divided into two cases:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The data is generally without structure or is of variable structure. This includes the case of documents that have both structured and unstructured parts. Document structure can vary over time (evolution), and the content can be <strong class="term">mixed</strong> (<strong class="term">semi-structured</strong>), with many elements containing both text nodes and child elements. Many XML elements can be absent or can appear in different orders. Documents might or might not conform to an XML schema.
                        </p>
                     </li>
                     <li>
                        <p>The data is relatively structured, but your applications do not take advantage of that structure: they treat the data as if it were without structure.</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6351"></a><div class="props_rev_3"><a id="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" name="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604"></a><h3 id="ADXDB-GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" class="sect3"><span class="enumeration_section">16.3 </span>Common Use Cases for XML Data Stored as XMLType
               </h3>
               <div>
                  <p>Recommendations are provided for application use cases that correspond to common use cases for XML data stored as <code class="codeph">XMLType</code>.
                  </p>
                  <p>If your use case is <span class="italic">not</span> a common one, so that it is not covered here, then refer to the rest of this chapter for information about special cases.
                  </p>
                  <div class="infoboxnote" id="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604__GUID-B4579E66-655F-4C5E-9676-B1B950172DC0">
                     <p class="notep1">Note:</p>
                     <p>This section is about the use of XML data that is persisted as <code class="codeph">XMLType</code>. One common use case for XML data involves the generation of XML data from relational data. That case is not covered here, as it involves relational storage and the generated XML data is not necessarily persisted. 
                     </p>
                     <p>(For cases where generated XML data is persisted as <code class="codeph">XMLType</code>, see <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D" title="In this use case, data is extracted from outside sources, transformed to fit operational needs (typically relational), and then loaded into the database: extract, transform, load (ETL). In particular, transformation distinguishes this use case.">XMLType Use Case: Staged XML Data for ETL</a>.)
                     </p>
                  </div>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23">XMLType Use Case: No XML Fragment Updating or Querying</a><br>In this use case there is no requirement to update or query fragments of XML data that is stored in the database. 
                     </li>
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-2871EBBB-4724-46B6-BB91-13C76014A263">XMLType Use Case: Data Integration from Diverse Sources with Different XML Schemas</a><br>If your XML data comes from multiple data sources that use different XML schemas then use <span class="italic">binary XML storage</span>.
                     </li>
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D">XMLType Use Case: Staged XML Data for ETL</a><br>In this use case, data is extracted from outside sources, transformed to fit operational needs (typically relational), and then loaded into the database: <span class="italic">extract</span>, <span class="italic">transform</span>, <span class="italic">load</span> (ETL). In particular, transformation distinguishes this use case.
                     </li>
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-D5020A68-9D12-4EDB-9315-7F027C008226">XMLType Use Case: Semi-Structured XML Data</a><br>In this use case, either your XML data is of variable form or large portions of it are not well defined. There might not be an associated XML schema, or the XML schema might allow for high data variability or evolve considerably or in unexpected ways.
                     </li>
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6">XMLType Use Case: Business Intelligence Queries</a><br> To enable business-intelligence (BI) queries over XML data, you can use SQL/XML function <code class="codeph">XMLTable</code> to project values contained in the data as columns of a virtual table. Then use analytic-function windows, together with SQL <code class="codeph">ORDER BY</code>and <code class="codeph">GROUP BY</code>, to operate on columns of the virtual table.
                     </li>
                     <li class="ulchildlink"><a href="choice-of-XMLType-storage-and-indexing.html#GUID-681F290F-581D-4344-BDE4-6FF98CD890FA">XMLType Use Case: XML Queries Involving Full-Text Search</a><br>If your application needs to perform full-text searches on XML data then use <span class="italic">binary XML storage</span> and create XML search indexes that correspond to your queries.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="choice-of-XMLType-storage-and-indexing.html#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" title="For XMLType data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use XMLIndex indexing with XMLType data that is stored as binary XML.">XMLType Indexing Considerations</a></li>
                        <li><a href="choice-of-XMLType-storage-and-indexing.html#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6352"></a><div class="props_rev_3"><a id="GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23" name="GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23"></a><h4 id="ADXDB-GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23" class="sect4"><span class="enumeration_section">16.3.1 </span>XMLType Use Case: No XML Fragment Updating or Querying
                  </h4>
                  <div>
                     <p>In this use case there is no requirement to update or query fragments of XML data that is stored in the database. </p>
                     <p>You have these options for this use case:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Store it as <code class="codeph">XMLType</code> using <span class="italic">binary XML storage</span>.
                           </p>
                        </li>
                        <li>
                           <p>Store it in a <span class="italic">relational</span> <code class="codeph">BLOB</code> or <code class="codeph">CLOB</code> column, preferably a SecureFiles LOB.
                           </p>
                        </li>
                     </ul>
                     <p>If you store the XML data in a relational LOB column, not as <code class="codeph">XMLType</code>, Oracle Database does not parse the data and it cannot guarantee its validity. (And you cannot perform <code class="codeph">XMLType</code> operations on the data.)
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6353"></a><div class="props_rev_3"><a id="GUID-2871EBBB-4724-46B6-BB91-13C76014A263" name="GUID-2871EBBB-4724-46B6-BB91-13C76014A263"></a><h4 id="ADXDB-GUID-2871EBBB-4724-46B6-BB91-13C76014A263" class="sect4"><span class="enumeration_section">16.3.2 </span>XMLType Use Case: Data Integration from Diverse Sources with Different XML Schemas
                  </h4>
                  <div>
                     <p>If your XML data comes from multiple data sources that use different XML schemas then use <span class="italic">binary XML storage</span>.
                     </p>
                     <p>This use case has three subcases:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If the XML data contains islands of structured, predictable data, and your queries are known, then use <code class="codeph">XMLIndex</code> with a <span class="italic">structured component</span> to index the structured islands (even if the data surrounding these islands is unstructured). A structured index component reflects the queries you use. An RSS news aggregator is an example of such a use case.
                           </p>
                        </li>
                        <li>
                           <p>If there are no such structured islands or your queries are unknown ahead of time (ad hoc) then use <code class="codeph">XMLIndex</code> with an unstructured component.
                           </p>
                        </li>
                        <li>
                           <p>If you use queries that involve full-text search then use an XML search index, together with XQuery pragma <code class="codeph">ora:no_schema</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></li>
                           <li><a href="xquery-and-XML-DB.html#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" title="The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces ({,&nbsp;}) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.">Oracle XQuery Extension-Expression Pragmas</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6354"></a><div class="props_rev_3"><a id="GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D" name="GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D"></a><h4 id="ADXDB-GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D" class="sect4"><span class="enumeration_section">16.3.3 </span>XMLType Use Case: Staged XML Data for ETL
                  </h4>
                  <div>
                     <p>In this use case, data is extracted from outside sources, transformed to fit operational needs (typically relational), and then loaded into the database: <span class="italic">extract</span>, <span class="italic">transform</span>, <span class="italic">load</span> (ETL). In particular, transformation distinguishes this use case.
                     </p>
                     <p>ETL use cases often integrate data from multiple applications that are maintained or hosted by multiple parties using different software and hardware systems. The data that is extracted is often the responsibility of parties other than those who transform it or use it after transformation.</p>
                     <p>The XML data involved is typically highly structured and conforms to an XML schema. This use case covers both producing relational data from XML data and generating XML data from relational data.</p>
                     <p>A subset of ETL use cases involve the need to efficiently <span class="italic">update</span> the XML data. Updating can involve replacement of an entire XML document or changes to only fragments of a document (partial updating).
                     </p>
                     <p><span class="italic">Object-relational storage</span> of <code class="codeph">XMLType</code> data is generally appropriate for this use case.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="relational-views-over-XML-data.html#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a></li>
                           <li><a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6355"></a><div class="props_rev_3"><a id="GUID-D5020A68-9D12-4EDB-9315-7F027C008226" name="GUID-D5020A68-9D12-4EDB-9315-7F027C008226"></a><h4 id="ADXDB-GUID-D5020A68-9D12-4EDB-9315-7F027C008226" class="sect4"><span class="enumeration_section">16.3.4 </span>XMLType Use Case: Semi-Structured XML Data
                  </h4>
                  <div>
                     <p>In this use case, either your XML data is of variable form or large portions of it are not well defined. There might not be an associated XML schema, or the XML schema might allow for high data variability or evolve considerably or in unexpected ways.</p>
                     <p><span class="italic">Binary XML storage</span> of <code class="codeph">XMLType</code> data is generally appropriate for this use case.
                     </p>
                     <p>Use structured-component <code class="codeph">XMLIndex</code> indexing when query paths are known, and use path-subsetted unstructured-component <code class="codeph">XMLIndex</code> indexing when paths are not known beforehand (ad hoc queries). Use an XML search index for XQuery Full-Text queries.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6356"></a><div class="props_rev_3"><a id="GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6" name="GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6"></a><h4 id="ADXDB-GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6" class="sect4"><span class="enumeration_section">16.3.5 </span>XMLType Use Case: Business Intelligence Queries
                  </h4>
                  <div>
                     <p> To enable business-intelligence (BI) queries over XML data, you can use SQL/XML function <code class="codeph">XMLTable</code> to project values contained in the data as columns of a virtual table. Then use analytic-function windows, together with SQL <code class="codeph">ORDER BY</code>and <code class="codeph">GROUP BY</code>, to operate on columns of the virtual table.
                     </p>
                     <p>For business-intelligence queries, you will generally do all of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Store your <code class="codeph">XMLType</code> data as binary XML.
                           </p>
                        </li>
                        <li>
                           <p>Use an <code class="codeph">XMLIndex</code> index with a structured component.
                           </p>
                        </li>
                        <li>
                           <p>Create relational views over the data using SQL/XML function <code class="codeph">XMLTable</code>, where the views project all columns of interest to the BI application. 
                           </p>
                        </li>
                        <li>
                           <p>Write your application queries against these relational views.</p>
                        </li>
                     </ul>
                     <p>If the <code class="codeph">XMLIndex</code> index is created in one-to-one correspondence to these views, Oracle Database automatically translates queries over the views to queries over the relational tables of the structured <code class="codeph">XMLIndex</code> component, providing relational performance.
                     </p>
                     <p>When you use analytic-function windows, <code class="codeph">ORDER BY</code>, or <code class="codeph">GROUP BY</code> on a column of the virtual table, these operations are translated to windows, <code class="codeph">ORDER BY</code>, and <code class="codeph">GROUP BY</code> operations on the corresponding physical columns of the structured-component <code class="codeph">XMLIndex</code> tables.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></li>
                           <li><a href="relational-views-over-XML-data.html#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6357"></a><div class="props_rev_3"><a id="GUID-681F290F-581D-4344-BDE4-6FF98CD890FA" name="GUID-681F290F-581D-4344-BDE4-6FF98CD890FA"></a><h4 id="ADXDB-GUID-681F290F-581D-4344-BDE4-6FF98CD890FA" class="sect4"><span class="enumeration_section">16.3.6 </span>XMLType Use Case: XML Queries Involving Full-Text Search
                  </h4>
                  <div>
                     <p>If your application needs to perform full-text searches on XML data then use <span class="italic">binary XML storage</span> and create XML search indexes that correspond to your queries.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6361"></a><a id="ADXDB6360"></a><div class="props_rev_3"><a id="GUID-320807FC-DB58-4600-8F92-A1247A354AE5" name="GUID-320807FC-DB58-4600-8F92-A1247A354AE5"></a><h3 id="ADXDB-GUID-320807FC-DB58-4600-8F92-A1247A354AE5" class="sect3"><span class="enumeration_section">16.4 </span>XMLType Storage Model Considerations
               </h3>
               <div>
                  <p>For most use cases, Oracle recommends that you use binary XML storage of <code class="codeph">XMLType</code>. Object-relational storage is appropriate in special cases.
                  </p>
                  <p>Object-relational storage is not appropriate unless <span class="italic">all</span> of the following are true:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You have an XML schema that rigorously specifies the detailed data format of all XML documents that you intend to store in a given <code class="codeph">XMLType</code> column or table. Your applications are data-centric.
                        </p>
                     </li>
                     <li>
                        <p>You do not expect your XML schema to evolve frequently in ways that do not allow in-place schema evolution.</p>
                     </li>
                     <li>
                        <p>Your data is not especially sparse (does not include many elements that are empty or missing).</p>
                     </li>
                     <li>
                        <p>You do not necessarily insert and select whole XML documents at a time. Partial updates and selections are common.</p>
                     </li>
                     <li>
                        <p>You do not need document fidelity (DOM fidelity is sufficient).</p>
                     </li>
                  </ul>
                  <p><a href="choice-of-XMLType-storage-and-indexing.html#GUID-320807FC-DB58-4600-8F92-A1247A354AE5__BABCJHFI" title="This table shows guidelines for selecting an XMLType storage model.">Table 16-1</a> provides more detail about this. The guidelines it presents for choosing an <code class="codeph">XMLType</code> storage model are <span class="italic">not</span> independent: follow them <span class="italic">in the order presented</span>, row by row, until a requirement in column <span class="bold">If... </span>is satisfied. 
                  </p>
                  <div class="tblformal" id="GUID-320807FC-DB58-4600-8F92-A1247A354AE5__BABCJHFI">
                     <p class="titleintable">Table 16-1 XMLType Storage Model Considerations</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="XMLType Storage Model Considerations" summary="This table shows guidelines for selecting an XMLType storage model." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="50%" id="d79426e1130">If...</th>
                              <th align="left" valign="bottom" width="50%" id="d79426e1133">Then...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1138" headers="d79426e1130 ">
                                 <p>1. You need the property of document fidelity, preserving all original whitespace.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1138 d79426e1133 ">
                                 <p>Use binary XML storage for database use and XML processing. But also store a copy of the original documents in a <code class="codeph">CLOB</code> (relational) column.
                                 </p>
                                 <p>(It is your responsibility to keep the two versions synchronized, if you update the data.)</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1150" headers="d79426e1130 ">
                                 <p>2. You rarely need to select or update only a portion of your XML data. Instead, you typically insert and select whole XML documents at a time.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1150 d79426e1133 ">
                                 <p>Use binary XML storage.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1157" headers="d79426e1130 ">
                                 <p>3. You need to store <code class="codeph">XMLType</code> instances that conform to different XML schemas in the <span class="italic">same</span> <code class="codeph">XMLType</code> table or column.
                                 </p>
                                 <p>(Oracle does <span class="italic">not</span> recommend this practice in general, because it prohibits Oracle XML&nbsp;DB from using the XML schemas to optimize XML queries and other operations.)
                                 </p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1157 d79426e1133 ">
                                 <p>Use binary XML storage.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1178" headers="d79426e1130 ">
                                 <p>4. You do <span class="italic">not</span> have an XML schema for your data.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1178 d79426e1133 ">
                                 <p>Use binary XML storage.</p>
                                 <p>If you think that your data could benefit from XML schema validation, then consider also whether you can generate an XML schema for it using a schema-generation tool.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1190" headers="d79426e1130 ">
                                 <p>5. You expect your XML schema to evolve frequently or in unexpected ways, and you <span class="italic">cannot</span> take advantage of in-place XML schema evolution.
                                 </p>
                                 <p>In-place evolution is generally permitted only if the changes do not invalidate existing documents and they do not involve changing the storage model. See <a href="XML-Schema-evolution.html#GUID-F2E920B3-C6D7-428B-9E75-5CE9C21F9B5F" title="You can use XML schema evolution to update your XML schema after you have registered it with Oracle XML&nbsp;DB.">XML Schema Evolution</a>.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1190 d79426e1133 ">
                                 <p>Use binary XML storage. </p>
                                 <p>Use PL/SQL procedure <code class="codeph">DBMS_XMLSCHEMA.copyEvolve</code> to update the XML schema.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1213" headers="d79426e1130 ">
                                 <p>6. Your XML data is very sparse.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1213 d79426e1133 ">
                                 <p>Use binary XML storage. </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1220" headers="d79426e1130 ">
                                 <p>7. Your XML schema does <span class="italic">not</span> make use of constructs such as elements <code class="codeph">any</code> and <code class="codeph">choice</code>, which do not provide a detailed specification of the data format.
                                 </p>
                                 <p>(XML schema generators often include such constructs in the generated schemas.)</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1220 d79426e1133 ">
                                 <p>Use object-relational storage.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1238" headers="d79426e1130 ">
                                 <p>8. You can modify your XML schema to remove constructs such as <code class="codeph">any</code> and <code class="codeph">choice</code> that prevent a rigorous definition of the structure of your XML data.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1238 d79426e1133 ">
                                 <p>Remove such constructs, then use object-relational storage.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1251" headers="d79426e1130 ">
                                 <p>9. You cannot remove such constructs.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1251 d79426e1133 ">
                                 <p>Use binary XML storage.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6363"></a><a id="ADXDB6362"></a><div class="props_rev_3"><a id="GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" name="GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780"></a><h3 id="ADXDB-GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" class="sect3"><span class="enumeration_section">16.5 </span>XMLType Indexing Considerations
               </h3>
               <div>
                  <p>For <code class="codeph">XMLType</code> data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use <code class="codeph">XMLIndex</code> indexing with <code class="codeph">XMLType</code> data that is stored as binary XML.
                  </p>
                  <p>For general indexing of document-centric XML data, use <code class="codeph">XMLIndex</code> with an <span class="italic">unstructured component</span>. This is appropriate for queries that are ad hoc (arbitrary).
                  </p>
                  <p>For data that contains predictable, fixed parts that you query frequently, use <code class="codeph">XMLIndex</code> with <span class="italic">structured components</span> for those parts. An example of this use case is a specification that is generally free-form but that has fixed fields for the author, date, and title.
                  </p>
                  <p>To handle islands of structure within generally unstructured content, create an <code class="codeph">XMLIndex</code> index that has both structured and unstructured components. A use case where you might use both components would be to support queries that extract an XML fragment from a document whenever some structured data is present. The structured component of the index would be used for a query <code class="codeph">WHERE</code> clause condition that checks for the structured data. The unstructured component would be used for the fragment extraction. 
                  </p>
                  <p><a href="choice-of-XMLType-storage-and-indexing.html#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780__BABDBDBA" title="This table is a checklist for indexing binary XML data.">Table 16-2</a> provides simple guidelines for indexing <code class="codeph">XMLType</code> data that is stored as binary XML. These guidelines are <span class="italic">independent</span>: you can use a combination of indexing approaches if their <span class="bold">If...</span> conditions are satisfied.
                  </p>
                  <div class="tblformal" id="GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780__BABDBDBA">
                     <p class="titleintable">Table 16-2 XMLType Indexing Considerations</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="XMLType Indexing Considerations" summary="This table is a checklist for indexing binary XML data." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="50%" id="d79426e1353">If...</th>
                              <th align="left" valign="bottom" width="50%" id="d79426e1356">Then...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1361" headers="d79426e1353 ">
                                 <p>Your data contains predictable islands of structured data.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1361 d79426e1356 ">
                                 <p>Use <code class="codeph">XMLIndex</code>, with a structured component for each of the structured islands.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1371" headers="d79426e1353 ">
                                 <p>You need to support full-text queries.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1371 d79426e1356 ">
                                 <p>Use XML search indexes.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d79426e1378" headers="d79426e1353 ">
                                 <p>You need to support ad-hoc XML queries involving predicates.</p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d79426e1378 d79426e1356 ">
                                 <p>Use <code class="codeph">XMLIndex</code>, with an unstructured component.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6365"></a><a id="ADXDB6364"></a><div class="props_rev_3"><a id="GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" name="GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7"></a><h3 id="ADXDB-GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" class="sect3"><span class="enumeration_section">16.6 </span>XMLType Storage Options: Relative Advantages
               </h3>
               <div>
                  <p>Each <code class="codeph">XMLType</code> storage model has particular advantages and disadvantages.
                  </p>
                  <p><a href="choice-of-XMLType-storage-and-indexing.html#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7__BIHIIJBA" title="This table has 3 columns and 8 rows. It summarizes structured and unstructured storage options and their benefits. The first row summarizes throughoutput features, the second row, flexibility, and so on.">Table 16-3</a> summarizes the advantages and disadvantages of each <code class="codeph">XMLType</code> storage model. Symbols + and &#x2013; provide a rough indication of strength and weakness, respectively.
                  </p>
                  <div class="tblformalwide" id="GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7__BIHIIJBA">
                     <p class="titleintable">Table 16-3 XMLType Storage Models: Relative Advantages</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="XMLType Storage Models: Relative Advantages" summary="This table has 3 columns and 8 rows. It summarizes structured and unstructured storage options and their benefits. The first row summarizes throughoutput features, the second row, flexibility, and so on." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="21%" id="d79426e1447">Quality</th>
                              <th align="left" valign="bottom" width="40%" id="d79426e1450">Binary XML Storage</th>
                              <th align="left" valign="bottom" width="40%" id="d79426e1453">Object-Relational Storage</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1458" headers="d79426e1447 ">
                                 <p>Throughput</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1458 d79426e1450 ">
                                 <p>(+) High throughput. Fast DOM loading. There is a slight overhead from the binary encoder/decoder.</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1458 d79426e1453 ">
                                 <p>(&#x2013;) XML decomposition can result in reduced throughput when ingesting or retrieving the entire content of an XML document.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1468" headers="d79426e1447 ">
                                 <p>Indexing support</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1468 d79426e1450 ">
                                 <p><code class="codeph">XMLIndex</code> and XML search indexes.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1468 d79426e1453 ">
                                 <p>B-tree, bitmap, and Oracle Text indexes on specific elements or attributes.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1480" headers="d79426e1447 ">
                                 <p>Queries</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1480 d79426e1450 ">
                                 <p>(+) Fast when using <code class="codeph">XMLIndex</code>. Queries that cannot use an index use streaming XPath evaluation, which can also be fast.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1480 d79426e1453 ">
                                 <p>(++) Relational query performance. You can create B-tree indexes on the underlying object-relational columns.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1493" headers="d79426e1447 ">
                                 <p>Update operations (DML)</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1493 d79426e1450 ">
                                 <p>(+) In-place, piecewise update for SecureFiles LOB storage.</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1493 d79426e1453 ">
                                 <p>(++) Relational update performance. Columns are updated in place.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1503" headers="d79426e1447 ">
                                 <p>Data flexibility</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1503 d79426e1450 ">
                                 <p>(+) Flexibility in the structure of the XML documents that can be stored in an <code class="codeph">XMLType</code> column or table.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1503 d79426e1453 ">
                                 <p>(&#x2013;) Limited flexibility. Only documents that conform to the XML schema can be stored.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1516" headers="d79426e1447 ">
                                 <p>XML schema flexibility</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1516 d79426e1450 ">
                                 <p>(++) Both XML schema-based and non-schema-based documents can be stored. Documents conforming to any XML schemas that have been registered can be stored in the same <code class="codeph">XMLType</code> table or column.
                                 </p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1516 d79426e1453 ">
                                 <p>(&#x2013;) Only documents that conform to the same XML schema can be stored in a given <code class="codeph">XMLType</code> table or column. 
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1532" headers="d79426e1447 ">
                                 <p>Validation upon insert</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1532 d79426e1450 ">
                                 <p>(++) XML schema-based data can be fully validated when it is inserted, but this takes time.</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1532 d79426e1453 ">
                                 <p>(+) XML data is partially validated when it is inserted.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d79426e1542" headers="d79426e1447 ">
                                 <p>Compression and Encryption</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1542 d79426e1450 ">
                                 <p>(+) Binary XML with SecureFiles LOB storage can be compressed/encrypted.</p>
                              </td>
                              <td align="left" valign="top" width="40%" headers="d79426e1542 d79426e1453 ">
                                 <p>(++) Each XML element/attribute can be compressed/encrypted individually.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="choice-of-XMLType-storage-and-indexing.html#GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" title="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use.">Choice of XMLType Storage and Indexing</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>