<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>New Features</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="writing-user-exits.html" title="Previous" type="text/html">
      <link rel="next" href="Oracle-reserved-words-keywords-namespaces.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="writing-user-exits.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="Oracle-reserved-words-keywords-namespaces.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> New Features</li>
            </ol>
            <a id="GUID-72AD8498-57D9-4D46-833D-49388783C750" name="GUID-72AD8498-57D9-4D46-833D-49388783C750"></a><a id="ZZPRE942"></a>
            
            <h2 id="ZZPRE-GUID-72AD8498-57D9-4D46-833D-49388783C750" class="sect2"><span class="enumeration_chapter">A </span> New Features
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d75586e19" class="indexterm-anchor"></a>This appendix looks at the improvements and <a id="d75586e22" class="indexterm-anchor"></a>new features offered by the Oracle Precompilers Release 1.8. Designed to meet the practical needs of professional software developers, these features will help you build effective, reliable applications.
               </p>
            </div><a id="ZZPRE943"></a><div class="props_rev_3"><a id="GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F" name="GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F"></a><h3 id="ZZPRE-GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F" class="sect3"><span class="enumeration_section">A.1 </span>About Fetching NULLs without Using Indicator Variables
               </h3>
               <div>
                  <p><a id="d75586e48" class="indexterm-anchor"></a>With releases 1.5, 1.6, and 1.7 of the Oracle Precompilers, source files that <code class="codeph">FETCH</code> data into host variables without associated indicator variables return an <code class="codeph">ORA-01405</code> message at run time if a <code class="codeph">NULL</code> is returned to the host variable. With release 1.8, when you specify <code class="codeph">MODE=ORACLE</code> and <code class="codeph">DBMS=V7</code>, you can disable the <code class="codeph">ORA-01405</code> message by also specifying <code class="codeph">UNSAFE_NULL=YES</code>.
                  </p>
                  <p>When developing applications for the Oracle Database, the preferred practice is to include indicator variables for any host variable that might have a <code class="codeph">NULL</code> returned to it. When migrating applications from Oracle Version 6 to Oracle database version 7, however, the <code class="codeph">UNSAFE_NULL</code> option can significantly ease the process.
                  </p>
                  <p>For more information, see <span class="q">"<a href="running-Oracle-precompilers.html#GUID-9BD762BA-BFF8-4B91-8188-8D5E64ADF6A7">UNSAFE_NULL</a>"</span> and <span class="q">"<a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">About Using Indicator Variables</a>"</span>.
                  </p>
               </div><a id="ZZPRE944"></a><div class="props_rev_3"><a id="GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA" name="GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA"></a><h4 id="ZZPRE-GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA" class="sect4"><span class="enumeration_section">A.1.1 </span>About Using DBMS=V7 and MODE=ORACLE
                  </h4>
                  <div>
                     <p>Applications precompiled with <code class="codeph">MODE=ORACLE</code> and <code class="codeph">DBMS=V7</code> return the <code class="codeph">ORA-01405</code> error at run time if a <code class="codeph">NULL</code> is returned to a host variable when there is no associated indicator variable. When upgrading to Oracle database version 7 with these options specified, you will need to migrate your applications in one of two ways:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Modify your source code to include the necessary indicator variables</p>
                        </li>
                        <li>
                           <p>Specify <code class="codeph">UNSAFE_NULL=YES</code> on the command line
                           </p>
                        </li>
                     </ul>
                     <p>If you are upgrading to Oracle database version 7 and use <code class="codeph">DBMS=V7</code> when precompiling, or if you intend to use new Oracle database version 7 features that are different from Oracle Version 6, in most instances, the change requires minimal modification to your source files. However, if your application may <code class="codeph">FETCH</code> null values into host variables without associated indicator variables, specify <code class="codeph">UNSAFE_NULL</code><code class="codeph">=YES</code> to disable the <code class="codeph">ORA-01405</code> message and avoid adding the relevant indicator variables to your source files.
                     </p>
                  </div>
               </div><a id="ZZPRE945"></a><div class="props_rev_3"><a id="GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9" name="GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9"></a><h4 id="ZZPRE-GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9" class="sect4"><span class="enumeration_section">A.1.2 </span>Related Error Messages
                  </h4>
                  <div>
                     <p>For information about precompile time messages associated with the <code class="codeph">UNSAFE_NULL</code> option, see <a href="../errmg/index.html" target="_blank"><span class="italic">Oracle Database Error Messages</span></a>.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE946"></a><div class="props_rev_3"><a id="GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE" name="GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE"></a><h3 id="ZZPRE-GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE" class="sect3"><span class="enumeration_section">A.2 </span>Additional Array Insert/Select Syntax
               </h3>
               <div>
                  <p>The array INSERT and array SELECT syntax of the DB2 precompiler is now supported by the Oracle precompiler. The optional ROWSET and ROWSET STARTING AT clauses are used in the fetch-orientation (FIRST, PRIOR, NEXT, LAST, CURRENT, RELATIVE and ABSOLUTE). For more information about the new INSERT/SELECT syntax, please refer the <a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro*COBOL Programmer's Guide</span></a> and <a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro*C/C++ Programmer's Guide</span></a>.
                  </p>
               </div>
            </div><a id="ZZPRE947"></a><div class="props_rev_3"><a id="GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09" name="GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09"></a><h3 id="ZZPRE-GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09" class="sect3"><span class="enumeration_section">A.3 </span>SQL99 Syntax Support
               </h3>
               <div>
                  <p>The SQL standard enables the portability of SQL applications across all conforming software products. Oracle features are compliant with the ANSI/ISO SQL99 standard, including ANSI compliant joins. Pro*Cobol supports all SQL99 features that are supported by Oracle database, which means that the SQL99 syntax for the SELECT, INSERT, DELETE, and UPDATE statements and the body of the cursor in a DECLARE CURSOR statement are supported.</p>
               </div>
            </div><a id="ZZPRE948"></a><div class="props_rev_3"><a id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9" name="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9"></a><h3 id="ZZPRE-GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9" class="sect3"><span class="enumeration_section">A.4 </span>About Fixing Execution Plans
               </h3>
               <div>
                  <p>To fix execution plans for SQL's used in Pro*C/C++ or Pro*Cobol development environment, you need to use the outline feature of Oracle at the time of precompiling. An outline is implemented as a set of optimizer hints that are associated with the SQL statement. If you enable the use of the outline for the statement, Oracle automatically considers the stored hints and tries to generate an execution plan in accordance with those hints. In this way, you can ensure that the performance is not affected when the modules are integrated or deployed into different environments.</p>
                  <p>You can use the following SQL statements to create outlines in Pro*C/C++ and Pro*Cobol:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">SELECT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DELETE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">INSERT... SELECT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">CREATE TABLE... AS SELECT</code></p>
                     </li>
                  </ul>
                  <p>If the outline option is set, then the precompiler generates two files, a SQL file and a LOG file at the end of successful precompilation. Command line options <code class="codeph">outline</code> and <code class="codeph">outlnprefix</code> control the generation of the outlines.Each generated outline name is unique. Because the file names used in the application are unique, this information is used in generating the outline name. In addition, the category name is also prefixed.
                  </p>
                  <div class="infoboxnote" id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9__GUID-8A54F838-45D1-4BBB-9A5C-8951818D8B84">
                     <p class="notep1">Note:</p>
                     <p>Oracle allows only 30 bytes for the outline name. If you exceed the limit, the precompiler will flag an error. You can restrict the length of the outline name by using the <code class="codeph">outlnprefix</code> option.
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9__GUID-D0319107-60D0-4D18-9924-44D18FBB7BE8">
                     <p class="notep1">See Also:</p>
                     <p></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro*COBOL Programmer's Guide</span></a></p>
                        </li>
                        <li>
                           <p><a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro*C/C++ Programmer's Guide</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ZZPRE949"></a><div class="props_rev_3"><a id="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1" name="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1"></a><h3 id="ZZPRE-GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1" class="sect3"><span class="enumeration_section">A.5 </span>About Using Implicit Buffered Insert
               </h3>
               <div>
                  <p>For improved performance, application developers can reference host arrays in their embedded SQL statements. This provides a means to execute an array of SQL statements with a single round-trip to the database. Despite the significant performance improvements afforded by array execution, some developers choose not to use this capability because it is not ANSI standard. For example, an application written to exploit array execution in Oracle cannot be precompiled using IBM's precompiler.</p>
                  <p>One workaround is to use buffered INSERT statements, which enable you to gain performance benefits while retaining ANSI standard embedded SQL syntax.</p>
                  <p>The command line option "max_row_insert" controls the number of rows to be buffered before executing the INSERT statement. By default it is zero and the feature is disabled. To enable this feature, specify any number greater than zero.</p>
                  <div class="infoboxnotealso" id="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1__GUID-F30EA12A-8B0E-42B5-99B6-194BD7CE2A07">
                     <p class="notep1">See Also:</p>
                     <p>For more information on using the implicit buffer insert feature, please refer to:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro*COBOL Programmer's Guide</span></a></p>
                        </li>
                        <li>
                           <p><a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro*C/C++ Programmer's Guide</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ZZPRE951"></a><a id="ZZPRE950"></a><div class="props_rev_3"><a id="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81" name="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81"></a><h3 id="ZZPRE-GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81" class="sect3"><span class="enumeration_section">A.6 </span>Dynamic SQL Statement Caching
               </h3>
               <div>
                  <p>Statement caching refers to the feature that provides and manages a cache of statements for each session. In the server, it means that cursors are ready to be used without the statement being parsed again. Statement caching can be enabled in the precompiler applications, which will help in the performance improvement of all applications that rely on the dynamic SQL statements. Performance improvement is achieved by removing the overhead of parsing the dynamic statements on reuse. </p>
                  <p>You can obtain this performance improvement by using a new command line option, <code class="codeph">stmt_cache</code>  (for the statement cache size), which will enable the statement caching of the dynamic statements. By enabling the new option, the statement cache will be created at session creation time. The caching is only applicable for the dynamic statements and the cursor cache for the static statements co-exists with this feature.
                  </p>
                  <p>The command line option <code class="codeph">stmt_cache</code> can be given any value in the range of 0 to 65535. Statement caching is disabled by default (value 0). The <code class="codeph">stmt_cache</code> option can be set to hold the anticipated number of distinct dynamic SQL statements in the application.
                  </p>
                  <div class="example" id="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81__GUID-86D78131-0D4B-46C6-B8F3-F635A0A05A5F">
                     <p class="titleinexample">Example A-1 Using the stmt_cache Option</p>
                     <p>This example demonstrates the use of the <code class="codeph">stmt_cache</code> option. In this program, you insert rows into a table and select the inserted rows by using the cursor in the loop. When the stmt_cache option is used to precompile this program, the performance increases compared to a normal precompilation.
                     </p><pre class="oac_no_warn" dir="ltr">/*
 *  stmtcache.pc
 *
 *  NOTE: 
 *  When this program is used to measure the performance with and without
 *  stmt_cache option, do the following changes in the program,
 *  1. Increase ROWSCNT to high value, say 10000.
 *  2. Remove all the print statements, usually which comsumes significant
 *     portion of the total program execution time.
 * 
 *  HINT: In Linux, gettimeofday() can be used to measure time. 
 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;oraca.h&gt;
 
#define ROWSCNT 10
 
char    *username = "aaaaa";
char    *password = "bbbbb";
 
/* Function prototypes */
void sql_error(char *msg);
void selectdata();
void insertdata();
 
int main()
{
  EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error");
 
  /* Connect using the default schema aaaaa/bbbbb */
  EXEC SQL CONNECT :username IDENTIFIED BY :password;
 
  /* core functions to insert and select the data */
  insertdata();
  selectdata();
 
/* Rollback pll the changes and disconnect from Oracle. */
  EXEC SQL ROLLBACK WORK RELEASE;
 
  exit(0);
}
 
/*Insert the data for ROWSCNT items into tpc2sc01 */
void insertdata()
{
  varchar dynstmt[80];
  int i;
  varchar ename[10];
  float comm;
  char *str;
 
  /* Allocates temporary buffer */
  str = (char *)malloc (11 * sizeof(char));
 
  strcpy ((char *)dynstmt.arr,
          "INSERT INTO bonus (ename, comm) VALUES (:ename, :comm)");
  dynstmt.len = strlen(dynstmt.arr);
  EXEC SQL PREPARE S FROM :dynstmt;
 
  printf ("Inserts %d rows into bonus table using dynamic SQL statement\n",
          ROWSCNT);
  for (i=1; i&lt;=ROWSCNT; i++)
  {
    sprintf (str, "EMP_%05d",i);
    strcpy (ename.arr, str);
    comm = i;
    ename.len = strlen (ename.arr);
    EXEC SQL EXECUTE S USING :ename, :comm;
  }
 
  free(str);
}
 
/* Select the data using the cursor */
void selectdata()
{
  varchar dynstmt[80];
  varchar ename[10];
  float comm;
  int i;
 
  strcpy((char *)dynstmt.arr,
         "SELECT ename, comm FROM bonus WHERE comm = :v1");
  dynstmt.len = (unsigned short)strlen((char *)dynstmt.arr);
 
  printf ("Fetches the inserted rows using using dynamic SQL statement\n\n");
  printf ("  ENAME      COMMISSION\n\n");
 
  for (i=1; i&lt;=ROWSCNT; i++)
  {
    /* Do the prepare in the loop so that the advantage of stmt_caching 
       is visible*/
    EXEC SQL PREPARE S FROM :dynstmt;
 
    EXEC SQL DECLARE C CURSOR FOR S;
    EXEC SQL OPEN C USING :i;
 
    EXEC SQL WHENEVER NOT FOUND DO break;
 
    /* Loop until the NOT FOUND condition is detected. */
    for (;;)
    {
      EXEC SQL FETCH C INTO :ename, :comm;
      ename.arr[ename.len] = '\0';
      printf ("%10s    %7.2f\n", ename.arr, comm);
    }
    /* Close the cursor so that the reparsing is not required for stmt_cache */
    EXEC SQL CLOSE C;
  }
}
 
void sql_error(char *msg)
{
    printf("\n%s", msg);
    sqlca.sqlerrm.sqlerrmc[sqlca.sqlerrm.sqlerrml] = '\0';
    oraca.orastxt.orastxtc[oraca.orastxt.orastxtl] = '\0';
    oraca.orasfnm.orasfnmc[oraca.orasfnm.orasfnml] = '\0';
    printf("\n%s\n", sqlca.sqlerrm.sqlerrmc);
    printf("in \"%s...\"\n", oraca.orastxt.orastxtc);
    printf("on line %d of %s.\n\n", oraca.oraslnr,
       oraca.orasfnm.orasfnmc);
 
   /* Disable ORACLE error checking to avoid an infinite loop
    * should another error occur within this routine.
    */
    EXEC SQL WHENEVER SQLERROR CONTINUE;
 
    /* Release resources associated with the cursor. */
    EXEC SQL CLOSE C;
 
    /* Roll back any pending changes and disconnect from Oracle. */  
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(1);
}</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ZZPRE952"></a><div class="props_rev_3"><a id="GUID-F19378A8-414F-43CA-868C-52B6B8864D90" name="GUID-F19378A8-414F-43CA-868C-52B6B8864D90"></a><h3 id="ZZPRE-GUID-F19378A8-414F-43CA-868C-52B6B8864D90" class="sect3"><span class="enumeration_section">A.7 </span>Scrollable Cursors
               </h3>
               <div>
                  <p>A scrollable cursor is a work area where Oracle executes SQL statements and stores information that is processed during execution.When a cursor is executed, the results of the query are placed into a a set of rows called the result set. The result set can be fetched either sequentially or non-sequentially. Non-sequential result sets are called scrollable cursors. A scrollable cursor enables users to access the rows of a database result set in a forward, backward, and random manner. This scrollable cursor enables the program to fetch any row in the result set. For more information about scrollable cursors, please see <a href="../lnpcb/embedded-SQL.html#LNPCB-GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611" target="_blank">Scrollable Cursors</a>.
                  </p>
               </div>
            </div><a id="ZZPRE954"></a><a id="ZZPRE953"></a><div class="props_rev_3"><a id="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D" name="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D"></a><h3 id="ZZPRE-GUID-96057B71-B6B9-4A6F-86FA-05946649E82D" class="sect3"><span class="enumeration_section">A.8 </span>Platform Endianness Support
               </h3>
               <div>
                  <p>Oracle stored unicode data (UTF16) is always in big-endian form. Currently, client applications run on different platforms. Linux and Windows have little-endian representation and Solaris has big-endian representation. When UTF16 data is inserted or selected, Pro*Cobol doesn't convert endian form between server and the client. This leads to corrupted UTF16 (UCS2) strings in the PIC N variable.</p>
                  <p>Platform endianness (Little-endian form for Linux and Windows, Big-endian form for Solaris) in PIC N variables can be maintained using the command line option <code class="codeph">picn_endian</code>.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D__GUID-DAE430A3-7956-4258-A938-EE0E1B369D8B">New Command Line Option</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">picn_endian={BIG|OS}
</pre><p>If picn_endian=big, then PIC N variables are bound with character set ID AL16UTF16.</p>
                     <p>If picn_endian=os then PIC N variables are bound with character set ID UCS2.</p>
                     <p>The default value for this option is "big" to preserve the current behavior. This option is ignored if NLS_NCHAR is not AL16UTF16.</p>
                     <p>Character set form for PIC N variables can be set by using the existing Pro*Cobol command line option:</p><pre class="oac_no_warn" dir="ltr">charset_picn={nchar_charset|db_charset}</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE955"></a><div class="props_rev_3"><a id="GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C" name="GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C"></a><h3 id="ZZPRE-GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C" class="sect3"><span class="enumeration_section">A.9 </span>Flexible B Area Length
               </h3>
               <div>
                  <p>The length of B Area for a Pro*Cobol program is limited to 72 when the format is set to ANSI. Cobol compilers now can support B Area length up to 253. This provides a programmer with the flexibility to type a line that is longer than 72 columns. Pro*Cobol now supports B area length up to 253 when a Pro*Cobol application is precompiled with the</p>
                  <p><code class="codeph">FORMAT=VARIABLE</code> 
                  </p>
                  <p>option.</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>