<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">
      <meta name="description" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">
      <title>Request Routing in a Sharded Database Environment</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Using Oracle Sharding">
      <meta property="og:description" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Using Oracle Sharding">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="using-oracle-sharding.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-14T12:19:13-08:00">
      <meta name="dcterms.title" content="Using Oracle Sharding">
      <meta name="dcterms.dateCopyrighted" content="2018, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E87088-04">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="sharding-application-development.html" title="Previous" type="text/html">
      <link rel="next" href="sharding-high-availability.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="SHARD">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sharding-application-development.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="sharding-high-availability.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Using Oracle Sharding</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Request Routing in a Sharded Database Environment</li>
            </ol>
            <a id="GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" name="GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D"></a>
            
            <h2 id="SHARD-GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" class="sect2"><span class="enumeration_chapter">6 </span>Request Routing in a Sharded Database Environment
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.</p>
               <p>The following topics describe routing in an sharded database environment.</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8">Direct Routing to a Shard</a><br>Oracle clients and connections pools are able to recognize sharding keys specified in the connection string for high performance data dependent routing. A shard routing cache in the connection layer is used to route database requests directly to the shard where the data resides.
                  </li>
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4">Queries and DMLs with Proxy Routing in a Sharded Database</a><br>Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including <code>SELECT</code> and <code>DML</code>) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.
                  </li>
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550">Creating Affinity Between Middle-Tier Connection Pools and Shards</a><br>A Oracle Universal Connection Pool (UCP) feature called middle-tier routing allows smart routers (F5 BigIP, for example) to route to the middle tier associated with a sharding key. It publishes the sharded database topology to the router tier so that requests based on specific sharding keys are routed to the appropriate&nbsp;application middle tier, which in turn establishes connections on the given subset of shards.
                  </li>
               </ul>
            </div>
            
            <div class="sect2"><a id="GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" name="GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8"></a><h3 id="SHARD-GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" class="sect3"><span class="enumeration_section">6.1 </span>Direct Routing to a Shard
               </h3>
               <div>
                  <p>Oracle clients and connections pools are able to recognize sharding keys specified in the connection string for high performance data dependent routing. A shard routing cache in the connection layer is used to route database requests directly to the shard where the data resides.</p>
                  <p>The following topics describe direct, key-based, routing to a shard:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4">About Direct Routing to a Shard</a><br>In direct, key-based, routing to a shard, a connection is established to a single, relevant shard which contains the data pertinent to the required transaction using a sharding key.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E">Sharding APIs</a><br>Oracle connection pools and drivers support Oracle Sharding.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">Request Routing in a Sharded Database Environment</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4" name="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4"></a><h4 id="SHARD-GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4" class="sect4"><span class="enumeration_section">6.1.1 </span>About Direct Routing to a Shard
                  </h4>
                  <div>
                     <p>In direct, key-based, routing to a shard, a connection is established to a single, relevant shard which contains the data pertinent to the required transaction using a sharding key.</p>
                     <p>A sharding key is used to route database connection requests at a user session level during connection checkout. The composite sharding method requires both a sharding key and a super sharding key. Direct, key-based, routing requires the sharding key (or super sharding key) be passed as part of the connection. Based on this information, a connection is established to the relevant shard which contains the data pertinent to the given sharding key or super sharding key. </p>
                     <p>Once the session is established with a shard, all SQL queries and DMLs are supported and executed in the scope of the given shard. This routing is fast and is used for all OLTP workloads that perform intra-shard transactions. It is recommended that direct routing be employed for all OLTP workloads that require the highest performance and availability.  </p>
                     <p>In support of Oracle Sharding, key enhancements have been made to Oracle connection pools and drivers. JDBC, Universal Connection Pool (UCP), OCI Session Pool (OCI), and Oracle Data Provider for .NET (ODP.NET)  provide APIs to pass sharding keys during the connection creation. Apache Tomcat, IBM Websphere, Oracle WebLogic Server, and JBOSS can leverage JDBC/UCP support and use sharding. PHP, Python, Perl, and Node.js can leverage OCI support.</p>
                     <p>A shard topology cache is a mapping of the sharding key ranges to the shards. Oracle Integrated Connection Pools maintain this shard topology cache in their memory. Upon the first connection to a given shard (during pool initialization or when the pool connects to newer shards),  the sharding key range mapping is collected from the shards to dynamically build the shard topology cache.</p>
                     <p>Caching the shard topology creates a fast path to the shards and expedites the process of creating a connection to a shard. When a connection request is made with a sharding key, the connection pool looks up the corresponding shard on which this particular sharding key exists (from its topology cache). If a matching connection is available in the pool then the pool returns a connection to the shard by applying its internal connection selection algorithm.</p>
                     <p>A database connection request for a given sharding key that is in any of the cached topology map, goes directly to the shard (that is, bypassing the shard director). Connection Pool also subscribes to RLB notifications from the SDB and dispenses the best connection based on runtime load balancing advisory. Once the connection is established, the client executes transactions directly on the shard. After all transactions for the given sharding key have been executed, the application must return the connection to the pool and obtain a connection for another key.</p>
                     <p>If a matching connection is not available in the pool, then a new connection is created by forwarding the connection request with the sharding key to the shard director.</p>
                     <p>Once the pools are initialized and the shard topology cache is built based on all shards, a shard director outage has no impact on direct routing.</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4__GUID-973B0EBF-CCF4-4352-B8C2-CCC171BCDC36">
                        <p class="notep1">See Also:</p>
                        <p><a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle clients and connections pools are able to recognize sharding keys specified in the connection string for high performance data dependent routing. A shard routing cache in the connection layer is used to route database requests directly to the shard where the data resides.">Direct Routing to a Shard</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle clients and connections pools are able to recognize sharding keys specified in the connection string for high performance data dependent routing. A shard routing cache in the connection layer is used to route database requests directly to the shard where the data resides.">Direct Routing to a Shard</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E" name="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E"></a><h4 id="SHARD-GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E" class="sect4"><span class="enumeration_section">6.1.2 </span>Sharding APIs
                  </h4>
                  <div>
                     <p>Oracle connection pools and drivers support Oracle Sharding.</p>
                     <p>JDBC, UCP, OCI, and Oracle Data Provider for .NET (ODP.NET) recognize sharding keys as part of the connection check. Apache Tomcat, Websphere, and WebLogic leverage UCP support for sharding and PHP, Python, Perl, and Node.js leverage OCI support.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-F897CC91-29E8-4C95-9151-5922E6F4EC6D">Sharding APIs for Oracle UCP</p>
                        <p>A shard-aware application gets a connection to a given shard by specifying the sharding key using the enhanced sharding API calls <code class="codeph">createShardingKeyBuilder</code> and <code class="codeph">createConnectionBuilder</code>.
                        </p>
                        <p>At a high-level, the following steps have to be followed in making an application work with a Sharded Database:</p>
                        <ol>
                           <li>
                              <p>Update the URL to reflect the Shard Directors and Global Service.</p>
                           </li>
                           <li>
                              <p>Set the pool parameters at the pool level and the shard level:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Initial number of connections to be created when UCP is started using <code class="codeph">setInitialPoolSize</code></p>
                                 </li>
                                 <li>
                                    <p>Minimum number of connections maintained by pool at runtime using <code class="codeph">setMinPoolSize</code></p>
                                 </li>
                                 <li>
                                    <p>UCP property to set maximum number of connections allowed on connection pool using <code class="codeph">setMaxPoolSize</code></p>
                                 </li>
                                 <li>
                                    <p>Set max connections per shard with <code class="codeph">setMaxConnectionsPerShard</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Build a sharding key object with <code class="codeph">createShardingKeyBuilder</code>.
                              </p>
                           </li>
                           <li>
                              <p>Establish a connection using <code class="codeph">createConnectionBuilder</code>.
                              </p>
                           </li>
                           <li>
                              <p>Execute transactions within the scope of the given shard.</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-0C81050C-FC81-4CE1-8EAE-59AC42C587C1">
                        <p class="titleinexample">Example 6-1 Establishing a Connection Using UCP Sharding API</p>
                        <p>The following is a code fragment which illustrates how the sharding keys are built and connections established using UCP Sharding API calls.</p><pre class="pre codeblock"><code>...

PoolDataSource pds =                                
     PoolDataSourceFactory.getPoolDataSource();
  
  // Set Connection Pool properties
pds.setURL(DB_URL);
pds.setUser("hr");  
pds.setPassword("****");
pds.setInitialPoolSize(10);
pds.setMinPoolSize(20);
pds.setMaxPoolSize(30);
                
// build the sharding key object

OracleShardingKey shardingKey = 
    pds.createShardingKeyBuilder() 
      .subkey("mary.smith@example.com", OracleType.VARCHAR2)
      .build(); 

  // Get an UCP connection for a shard
Connection conn = 
    pds.createConnectionBuilder()
     .shardingKey(shardingKey)
     .build();
...</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-33BFD16B-5472-41D4-A38B-12A7ECEB7E9F">
                        <p class="titleinexample">Example 6-2 Sample Shard-Aware Application Code Using UCP Connection Pool</p>
                        <p> In this example the pool settings are defined at the pool level and at the shard level.</p><pre class="pre codeblock"><code>import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import oracle.jdbc.OracleShardingKey;
import oracle.jdbc.OracleType;
import oracle.jdbc.pool.OracleDataSource;
import oracle.ucp.jdbc.PoolDataSource;
import oracle.ucp.jdbc.PoolDataSourceFactory;

public class MaxConnPerShard
{    
  public static void main(String[] args) throws SQLException
  {    
    <span class="bold">String url = "jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(HOST=<span class="variable" translate="no">shard-dir1</span>)(PORT=3216)
 (PROTOCOL=tcp))(CONNECT_DATA=(SERVICE_NAME=shsvc.shpool.oradbcloud)(REGION=east)))";
    String user="testuser1", pwd = "testuser1";</span>  
  
    <span class="bold">int maxPerShard = 100, initPoolSize = 20;</span>    

    PoolDataSource pds = PoolDataSourceFactory.getPoolDataSource();
    pds.setConnectionFactoryClassName(OracleDataSource.class.getName());
    pds.setURL(url);
    pds.setUser(user);
    pds.setPassword(pwd);
    pds.setConnectionPoolName("testpool");
    <span class="bold">pds.setInitialPoolSize(initPoolSize);</span>    

    <span class="bold">// set max connection per shard
    pds.setMaxConnectionsPerShard(maxPerShard);</span>
    System.out.println("Max-connections per shard is: "+pds.getMaxConnectionsPerShard());
                
    <span class="bold">// build the sharding key object
    int shardingKeyVal = 123;    
    OracleShardingKey sdkey = pds.createShardingKeyBuilder()
        .subkey(shardingKeyVal, OracleType.NUMBER)
        .build();</span>

    // try to build maxPerShard connections with the sharding key
    Connection[] conns = new Connection[maxPerShard];
    for (int i=0; i&lt;maxPerShard; i++)
    {      
      <span class="bold">conns[i] = pds.createConnectionBuilder()
          .shardingKey(sdkey)
          .build();</span>
    
Statement stmt = conns[i].createStatement();
      ResultSet rs = stmt.executeQuery("select sys_context('userenv', 'instance_name'),
       sys_context('userenv', 'chunk_id') from dual");
      while (rs.next()) {
        System.out.println((i+1)+" - inst:"+rs.getString(1)+", chunk:"+rs.getString(2));
      }
      rs.close();
      stmt.close();
    }      

    System.out.println("Try to build "+(maxPerShard+1)+" connection ...");
    try {
      Connection conn = pds.createConnectionBuilder()
          .shardingKey(sdkey)
          .build();

      Statement stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery("select sys_context('userenv', 'instance_name'),
       sys_context('userenv', 'chunk_id') from dual");
      while (rs.next()) {
        System.out.println((maxPerShard+1)+" - inst:"+rs.getString(1)+",
         chunk:"+rs.getString(2));
      }
      rs.close();
      stmt.close();

      System.out.println("Problem!!! could not build connection as max-connections per
        shard exceeded");
      conn.close();
    } catch (SQLException e) {
      System.out.println("Max-connections per shard met, could not build connection
        any more, expected exception: "+e.getMessage());
    }    
    for (int i=0; i&lt;conns.length; i++)
    {
      conns[i].close();
    }        
  }
}</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-594E12DA-8248-43D3-877B-FA8F27A99032">ODP.NET Sharding APIs</p>
                        <p>A shard-aware application gets a connection to a given shard by specifying the sharding key and super sharding key using ODP.NET APIs, such as the <code class="codeph">SetShardingKey(OracleShardingKey shardingKey, OracleShardingKey superShardingKey)</code> instance method on the <code class="codeph">OracleConnection</code> class.
                        </p>
                        <p>At a high level, the following steps are necessary for a .NET application to work with a Sharded Database:</p>
                        <ol>
                           <li>
                              <p>Use ODP.NET, Unmanaged Driver.</p>
                              <p>Sharding is supported with or without ODP.NET connection pooling. Each pool can maintain connections to different shards of the sharded database.</p>
                           </li>
                           <li>
                              <p>Use an <code class="codeph">OracleShardingKey</code> class to set the sharding key and another instance for the super sharding key.
                              </p>
                           </li>
                           <li>
                              <p>&nbsp;Invoke the <code class="codeph">OracleConnection.SetShardingKey()</code> method prior to calling <code class="codeph">OracleConnection.Open()</code> so that ODP.NET can return a connection with the specified sharding key and super sharding key.
                              </p>
                              <p>These keys must be set while the <code class="codeph">OracleConnection</code> is in a Closed state, otherwise an exception is thrown.
                              </p>
                           </li>
                        </ol>
                        <p></p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-5DD88D24-08B8-4EAC-A094-076301374AE5">
                        <p class="titleinexample">Example 6-3 Sample Shard-Aware Application Code Using ODP.NET</p><pre class="pre codeblock"><code>using System;
using Oracle.DataAccess.Client;
 
class Sharding
{
  static void Main()
  {
    OracleConnection con = new OracleConnection
      ("user id=hr;password=hr;Data Source=orcl;");
    //Setting a shard key
    OracleShardingKey shardingKey = new OracleShardingKey(OracleDbType.Int32, 123);
    //Setting a second shard key value for a composite key
    shardingKey.SetShardingKey(OracleDbType.Varchar2, "gold");
    //Creating and setting the super shard key
    OracleShardingKey superShardingKey = new OracleShardingKey();
    superShardingKey.SetShardingKey(OracleDbType.Int32, 1000);
    
    //Setting super sharding key and sharding key on the connection
    con.SetShardingKey(shardingKey, superShardingKey);
    con.Open();

    //perform SQL query
  }
}</code></pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-57C6BE35-A449-4212-96F9-3333A3B61125">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJDBC-GUID-1D7795CA-79DC-452B-9FCC-0EF430F87461" target="_blank"><span><cite>Oracle Database JDBC Developer’s Guide</cite></span></a> for information about JDBC support for Oracle Sharding
                        </p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJUCP-GUID-12685D3A-F083-433A-90DF-C5533009B841" target="_blank"><span><cite>Oracle Universal Connection Pool Developer’s Guide</cite></span></a> for information about UCP support for Oracle Sharding
                        </p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=ODPNT8599" target="_blank"><span><cite>Oracle Data Provider for .NET Developer's Guide for Microsoft Windows</cite></span></a> for information about ODP.NET support for Oracle Sharding
                        </p>
                        <p><a href="../lnoci/oci-interface-for-using-shards.html#LNOCI-GUID-C64136C2-CF65-4507-8811-9A03946CC817" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a> for information about the OCI interface for using shards
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle clients and connections pools are able to recognize sharding keys specified in the connection string for high performance data dependent routing. A shard routing cache in the connection layer is used to route database requests directly to the shard where the data resides.">Direct Routing to a Shard</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" name="GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4"></a><h3 id="SHARD-GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" class="sect3"><span class="enumeration_section">6.2 </span>Queries and DMLs with Proxy Routing in a Sharded Database
               </h3>
               <div>
                  <p>Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including <code>SELECT</code> and <code>DML</code>) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.
                  </p>
                  <p>The following topics describe proxy routing in detail:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1">About Proxy Routing in a Sharded Database</a><br>Proxy routing is an ancillary usage pattern targeted for developer convenience. It requires a connection be established to the coordinator.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-9C13DCC4-0018-4049-94D8-70F518008504">Oracle Sharding Multi-Shard Query Coordinator</a><br>The multi-shard query coordinator database contains the metadata of the sharded topology and provides query processing support for sharded databases.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624">Querying and DMLs Using Proxy Routing</a><br>Proxy routing enables aggregation of data and reporting across shards. It also allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the sharding key (during connect) where the statement should execute.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC">Proxy Routing for Single-Shard Queries</a><br>A single-shard query is a query which needs to scan data from only one shard and does not need to lookup data from any other shards.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76">Proxy Routing for Multi-Shard Queries</a><br>A multi-shard query must scan data from more than one shard, and the processing on each shard is independent of any other shard.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B">Supported Query Shapes in Proxy Routing</a><br>Oracle Sharding supports single and multi-shard query shapes with some restrictions.
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-51377035-217B-4624-88CD-A5D5DE125606">Execution Plans for Proxy Routing</a><br>In a multi-shard query, each shard produces an independent execution plan that is potentially different from the plans on the other shards in the query.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">Request Routing in a Sharded Database Environment</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1" name="GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1"></a><h4 id="SHARD-GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1" class="sect4"><span class="enumeration_section">6.2.1 </span>About Proxy Routing in a Sharded Database
                  </h4>
                  <div>
                     <p>Proxy routing is an ancillary usage pattern targeted for developer convenience. It requires a connection be established to the coordinator.</p>
                     <p>The shard catalog database assumes the role of the coordinator database. The coordinator uses the metadata of the sharded topology and provides query processing support for sharded databases. The SQL compiler identifies the relevant shards automatically and coordinates the query execution across all of the participating shards. Once the session is made with the coordinator, SQL queries and DMLs are executed and require no modification.</p>
                     <p>Proxy routing is suitable for the following scenarios:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When the application cannot pass the sharding key during connect</p>
                        </li>
                        <li>
                           <p>When the application needs to access data from sharded tables residing on multiple shards</p>
                        </li>
                        <li>
                           <p>SQL queries typically used in reporting such as aggregates on sales data</p>
                        </li>
                     </ul>
                     <p>Routing using the coordinator allows your application to submit SQL statements without a sharding key value passed during connect. The coordinator’s SQL compiler analyzes and rewrites the query into query fragments  that are sent and executed by the participating shards. The queries are rewritten so that most of the query processing is done on the participating shards and then aggregated by the coordinator. In essence, the shards act as compute nodes for the queries executed by coordinator. Because the computation is pushed to the data, there is reduced movement of data between shards and the coordinator. This arrangement also enables the effective use of resources by offloading processing from the coordinator on to the shards as much as possible.</p>
                     <p>It is recommended that applications separate their workloads for direct routing and proxy routing. Separate connection pools must be created for these workloads.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-9C13DCC4-0018-4049-94D8-70F518008504" name="GUID-9C13DCC4-0018-4049-94D8-70F518008504"></a><h4 id="SHARD-GUID-9C13DCC4-0018-4049-94D8-70F518008504" class="sect4"><span class="enumeration_section">6.2.2 </span>Oracle Sharding Multi-Shard Query Coordinator
                  </h4>
                  <div>
                     <p>The multi-shard query coordinator database contains the metadata of the sharded topology and provides query processing support for sharded databases.</p>
                     <p> </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-09E91297-065F-45C1-827E-1CC49B0A6660">Connecting to the Multi-Shard Coordinator</p>
                        <p>To perform multi-shard queries, connect to the multi-shard coordinator using the GDS$CATALOG service on the shard catalog database:</p><pre class="pre codeblock"><code>sqlplus app_schema/app_schema@shardcatvm:1521/GDS\$CATALOG.oradbcloud</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-82F6FFDB-0121-4827-9A14-68D40BBD5A8E">Multi-Shard Coordinator High Availability</p>
                        <p>The availability of the multi-shard coordinator impacts proxy-routing based workloads, so it is highly recommended that the coordinator be protected with Data Guard in Maximum Availability protection mode (zero data loss failover) with fast-start failover enabled. The coordinator may optionally be Oracle RAC-enabled for additional availability and scalability.</p>
                        <p>To improve the scalability and availability of multi-shard query workloads, Oracle Active Data Guard standby shard catalog databases in read-only mode can act as multi-shard query coordinators. For each active replica of the catalog database, a special coordinator service, GDS$COORDINATOR.<span class="variable" translate="no">cloud_name</span> (where <span class="variable" translate="no">cloud_name</span> is the value specified for the <code class="codeph">configname</code> parameter in the GDSCTL command, <code class="codeph">create shardcatalog</code>, and is oradbcloud by default) is running and registered on all shard directors. Clients can connect to this service on any of the replicas and perform multi-shard queries, allowing shard directors to distribute the multi-shard query workload with respect to runtime load balancing and decrease the load on in the primary shard catalog, which is the central component of the Oracle Sharding framework. Additionally, if the database’s region is set, and the client specifies the region in the connection string, a shard director routes a connection with respect to regional affinity.
                        </p>
                        <p>Availability of the multi-shard query coordinator has zero impact on workloads using direct routing.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-A3330ED0-5051-4ED4-8033-B5ADDF4CC94A">Multi-Shard Query Coordinator Database Sizing</p>
                        <p>The shard catalog and multi-shard query coordinator host the following key information:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Metadata of the sharded database topology</p>
                           </li>
                           <li>
                              <p>Schema of the sharded application</p>
                           </li>
                           <li>
                              <p>Master copies of the duplicated tables </p>
                           </li>
                        </ul>
                        <p>The size of the metadata and the schema is nominal; however, the number of duplicated tables and the space they occupy should be planned for when sizing the multi-shard query coordinator.</p>
                        <p>In addition to the above, the multi-shard query coordinator should also be sized to handle proxy routing, which can be CPU, I/O, and memory intensive based on the SQL queries and the amount of data being processed.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-8CB6442A-9326-4242-892A-4383E05C1C48">Resiliency of Proxy Routing</a><br>It is highly recommended that the coordinator be protected with Data Guard with fast-start failover and optionally be Oracle RAC-enabled for availability and scalability
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-8CB6442A-9326-4242-892A-4383E05C1C48" name="GUID-8CB6442A-9326-4242-892A-4383E05C1C48"></a><h5 id="SHARD-GUID-8CB6442A-9326-4242-892A-4383E05C1C48" class="sect5"><span class="enumeration_section">6.2.2.1 </span>Resiliency of Proxy Routing
                     </h5>
                     <div>
                        <p>It is highly recommended that the coordinator be protected with Data Guard with fast-start failover and optionally be Oracle RAC-enabled for availability and scalability</p>
                        <p>Failure of the coordinator affects multi- and single-shard queries that are routed through the coordinator. The following are failure scenarios while querying and the expected behavior of proxy routing:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If a participating shard is down, then the coordinator sends the query to another shard with same data.</p>
                           </li>
                           <li>
                              <p>If failure happens during execution of the query on a participating shard, then the user will receive an error.</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-9C13DCC4-0018-4049-94D8-70F518008504" title="The multi-shard query coordinator database contains the metadata of the sharded topology and provides query processing support for sharded databases.">Oracle Sharding Multi-Shard Query Coordinator</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624" name="GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624"></a><h4 id="SHARD-GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624" class="sect4"><span class="enumeration_section">6.2.3 </span>Querying and DMLs Using Proxy Routing
                  </h4>
                  <div>
                     <p>Proxy routing enables aggregation of data and reporting across shards. It also allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the sharding key (during connect) where the statement should execute.</p>
                     <p>In both aggregation and SQL execution without a sharding key use-cases, the user accepts a reduced level of performance compared to direct, key-based, routing.</p>
                     <p>In a sharded database (SDB), there are two types of tables: sharded tables and duplicated tables.</p>
                     <p>Sharded tables are equi-partitioned on a sharding key.</p><pre class="pre codeblock"><code>S=S1 <span class="bold">U</span> S2 <span class="bold">U</span> … <span class="bold">U</span> Sn</code></pre><p>Duplicated tables are identical on all shards.</p><pre class="pre codeblock"><code>R = R1 = … = Rn</code></pre><p>Proxy routing in an SDB provides a transparent mechanism to execute typical SQL queries that access data from sharded and duplicated tables without requiring the application to specify the relevant shards The SQL compiler identifies the relevant shards automatically and coordinates the query execution across all the participating shards. Database links are used for the communication between the coordinator and the shards.</p>
                     <p>At a high level the coordinator rewrites each incoming query, Q, into a distributive form composed of two queries, CQ and SQ, where SQ (Shard Query) is the portion of Q that executes on each participating shard and CQ (Coordinator Query) is the portion that executes on the coordinator shard. </p><pre class="pre codeblock"><code>Q  =&gt;  CQ ( Shard_Iterator( SQ ) )</code></pre><p>The following is an example of an aggregate query Q1 rewritten into Q1’ for an inter shard execution:</p><pre class="pre codeblock"><code>Q1 : SELECT COUNT(*) FROM customers

Q1’: SELECT SUM(sc) FROM (Shard_Iterator(SELECT COUNT(*) sc FROM s1 (i) ))</code></pre><p>There are two key elements in this process: (1) identifying the relevant shards  (2) rewriting the query into a distributive form, and shard iteration.</p>
                     <p>During the compilation of a query on the coordinator database, the query compiler analyzes the predicates on the sharding key and extracts the ones that can be used to identify the participating shards, i.e. shards that will contribute rows for the sharded tables referenced in the query. The rest of the shards are referred to as pruned shards. </p>
                     <p>In the case where only one participating shard was identified, the full query is routed to that shard for full execution. This is called a single-shard query. If there is more than one participating shard the query is known as multi-shard query and is rewritten. The rewriting process takes into account the expressions computed by the query as well as the query shape. </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC" name="GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC"></a><h4 id="SHARD-GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC" class="sect4"><span class="enumeration_section">6.2.4 </span>Proxy Routing for Single-Shard Queries
                  </h4>
                  <div>
                     <p>A single-shard query is a query which needs to scan data from only one shard and does not need to lookup data from any other shards.</p>
                     <p>The single-shard query is similar to a client connecting to a specific shard and issuing a query on that shard. In this scenario, the entire query will be executed on the single participating shard, and the coordinator just passes processed rows back to the client. The plan on the coordinator is similar to the remote mapped cursor.</p>
                     <p>For example, the following query is fully mapped to a single shard because the data for customer 123 is located only on that shard.</p><pre class="pre codeblock"><code>SELECT count(*) FROM customers c, orders o WHERE c.custno = o.custno and c.custno = 123;
</code></pre><p>The query contains a condition on the shard key that maps to one and only one shard which is known at query compilation time (literals) or query start time (bind). The query is fully executed on the qualifying shard.</p>
                     <p>Single-shard queries are supported for:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Equality and In-list, such as <code class="codeph">Area = ‘West’</code></p>
                        </li>
                        <li>
                           <p>Conditions containing literal, bind, or expression of literals and binds, such as </p><pre class="pre codeblock"><code>Area = :bind

Area = CASE :bind &lt;10 THEN ‘West’ ELSE ‘East’ END</code></pre></li>
                        <li>
                           <p><code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, <code class="codeph">INSERT</code>, <code class="codeph">FOR UPDATE</code>, and <code class="codeph">MERGE</code>. <code class="codeph">UPSERT</code> is not supported.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" name="GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76"></a><h4 id="SHARD-GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" class="sect4"><span class="enumeration_section">6.2.5 </span>Proxy Routing for Multi-Shard Queries
                  </h4>
                  <div>
                     <p>A multi-shard query must scan data from more than one shard, and the processing on each shard is independent of any other shard.</p>
                     <p>A multi-shard query maps to more than one shard and the coordinator may need to do some processing before sending the result to the client. For example, the following query fetches the number of orders placed by each customer.</p><pre class="pre codeblock"><code>SELECT count(*), c.custno FROM customers c, orders o WHERE c.custno = o.custno
 GROUP BY c.custno;
</code></pre><p>The query is transformed to the following by the coordinator.</p><pre class="pre codeblock"><code>SELECT sum(count_col), custno FROM (SELECT count(*) count_col, c.custno
 FROM customers c, orders o 
 WHERE c.custno = o.custno GROUP BY c.custno) GROUP BY custno;
</code></pre><p>The inline query block is mapped to every shard just as a remote mapped query block. The coordinator performs further aggregation and <code class="codeph">GROUP BY</code> on top of the result set from all shards. The unit of execution on every shard is the inline query block.
                     </p>
                     <p>Multi-shard queries are supported for <code class="codeph">SELECT</code> statements only. A query can either access a single shard (in case of equality filter), or ALL shards (in case of no filter predicate on sharding key).
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03">Specifying Consistency Levels in a Multi-Shard Query</a><br>You can use the initialization parameter MULTISHARD_QUERY_DATA_CONSISTENCY to set different consistency levels when executing multi-shard queries across shards.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" name="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03"></a><h5 id="SHARD-GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" class="sect5"><span class="enumeration_section">6.2.5.1 </span>Specifying Consistency Levels in a Multi-Shard Query
                     </h5>
                     <div>
                        <p>You can use the initialization parameter MULTISHARD_QUERY_DATA_CONSISTENCY to set different consistency levels when executing multi-shard queries across shards.</p>
                        <p>You can specify different consistency levels for multi-shard queries. For example, you might want some queries to avoid the cost of SCN synchronization across shards, and these shards could be globally distributed. Another use case is when you use standbys for replication and slightly stale data is acceptable for multi-shard queries, as the results could be fetched from the primary and its standbys.</p>
                        <p>The default mode is strong, which performs SCN synchronization across all shards. Other modes skip SCN synchronization. The delayed_standby_allowed level allows fetching data from the standbys as well, depending on load balancing and other factors, and could contain stale data.</p>
                        <p>This parameter can be set either at the system level or at the session level.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03__GUID-411DF42A-BBD9-438B-ADF2-459FFB35F647">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=REFRN-GUID-313D79DE-1A42-482C-BF41-6F821C8F3307" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for more information about MULTISHARD_QUERY_DATA_CONSISTENCY usage.
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" title="A multi-shard query must scan data from more than one shard, and the processing on each shard is independent of any other shard.">Proxy Routing for Multi-Shard Queries</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B" name="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B"></a><h4 id="SHARD-GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B" class="sect4"><span class="enumeration_section">6.2.6 </span>Supported Query Shapes in Proxy Routing
                  </h4>
                  <div>
                     <p>Oracle Sharding supports single and multi-shard query shapes with some restrictions.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-ACE4058D-5510-4CD5-887B-8BFA731BB5D2">Restrictions</p>
                        <p>The following are restrictions on the use of query constructs in Oracle Sharding:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Restrictions on DMLs are given with examples in the Transactions section below.</p>
                           </li>
                           <li>
                              <p><code class="codeph">CONNECT BY</code> queries are not supported.
                              </p>
                           </li>
                           <li>
                              <p>User-defined PL/SQL is allowed in multi-shard queries only in the <code class="codeph">SELECT</code> clause. If it is specified in the <code class="codeph">WHERE</code> clause then an error is thrown.
                              </p>
                              <p>XLATE, XML query and Object type column are not supported.</p>
                           </li>
                           <li>
                              <p>IAS on sharded table on coordinator is not supported.</p>
                           </li>
                           <li>
                              <p><code class="codeph">MODEL</code> clause is not supported.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-91DF1B49-1CE2-4C41-B697-A139003AF5B0">Query Involves Only Duplicated Tables</p>
                        <p>For queries that involve only duplicated tables there are no restrictions on the query shape. The query is executed on the coordinator.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-22F4E52A-FDE3-4096-93F6-E11CC42190C8">Query Involves Only Sharded Tables</p>
                        <p>For a single table query, the query can have an equality filter on the sharding key that qualifies a shard. For join queries, all of the tables should be joined using equality on the sharding key. The following are some examples of queries involving sharded tables.</p>
                        <p>Inner join where equi-join is only on sharding key.</p><pre class="pre codeblock"><code>SELECT … FROM s1 INNER JOIN s2 ON s1.sk=s2.sk 
WHERE any_filter(s1) AND any_filter(s2)
</code></pre><p>Left outer join only on sharding key.</p><pre class="pre codeblock"><code>SELECT … FROM s1 LEFT OUTER JOIN s2 ON s1.sk=s2.sk</code></pre><p>Right outer join, same as left outer join.</p><pre class="pre codeblock"><code>SELECT … FROM s1 RIGHT OUTER JOIN s2 ON s1.sk=s2.sk</code></pre><p>Full outer join only on the sharding key, but only if Native is valid which requires equi-join.</p><pre class="pre codeblock"><code>SELECT … FROM s1 FULL OUTER JOIN s2 ON s1.sk=s2.sk
WHERE any_filter(s1) AND any_filter(s2)
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-D71A9767-639F-422D-90D5-71CF5E691507">Query Involves Sharded and Duplicated Tables</p>
                        <p>A query involving both sharded and duplicated tables can be either a single-shard or multi-shard query, based on the predicates on the sharding key. The only difference is that the query will contain a non sharded table which is duplicated on each shard.</p>
                        <p>Joins between a sharded table and a duplicated table can be on any column using any comparison operator (= &lt; &gt; &lt;= &gt;=) or even arbitrary join expression. The following are examples of join patterns.</p>
                        <p>Inner join</p><pre class="pre codeblock"><code>SELECT … FROM s1 INNER JOIN r1 ON any_join_condition(s1,r1) 
WHERE any_filter(s1) AND any_filter(r1)
</code></pre><p>Left/Right outer join</p>
                        <p>Where sharded table is the first table in <code class="codeph">LEFT OUTER JOIN</code>:
                        </p><pre class="pre codeblock"><code>SELECT … FROM <span class="bold">s1</span> LEFT OUTER JOIN r1 ON any_join_condition(s1,r1) 
WHERE any_filter(s1) AND any_filter(r1)

SELECT … FROM r1 LEFT OUTER JOIN <span class="bold">s1</span> ON any_join_condition(s1,s2) 
AND any_filter(r1) AND <span class="bold">filter_one_shard(s1)</span></code></pre><p>Where sharded table is second table in <code class="codeph">RIGHT OUTER JOIN</code>:
                        </p><pre class="pre codeblock"><code>SELECT … FROM r1 RIGHT OUTER JOIN <span class="bold">s1</span> ON any_join_condition(s1,r1) 
WHERE any_filter(s1) AND any_filter(r1)

SELECT … FROM <span class="bold">s1</span> RIGHT OUTER JOIN r1 ON any_join_condition(s1,s2) 
AND <span class="bold">filter_one_shard(s1)</span> AND any_filter(r1)
</code></pre><p>Full outer join</p><pre class="pre codeblock"><code>SELECT … FROM s1 FULL OUTER JOIN r1 ON s1.sk=s2.sk
WHERE any_filter(s1) AND any_filter(s2)
</code></pre><p>Semi-join (<code class="codeph">EXISTS</code>)
                        </p><pre class="pre codeblock"><code>SELECT … FROM s1 EXISTS 
(SELECT 1 FROM r1 WHERE r1.anykey=s1.anykey)

SELECT … FROM r1 EXISTS 
(SELECT 1 FROM s1 WHERE r1.anykey=s1.anykey and filter_one_shard(s1))
</code></pre><p>Anti-join (<code class="codeph">NOT EXISTS</code>)
                        </p><pre class="pre codeblock"><code>SELECT … FROM s1 NOT EXISTS 
(SELECT 1 FROM r1 WHERE r1.anykey=s1.anykey)	
</code></pre><p>Left/Right outer join</p>
                        <p>Where the duplicated table is the first table in <code class="codeph">LEFT OUTER JOIN</code>, or the sharded table is first and it maps to a single shard based on filter predicate on sharding key:
                        </p><pre class="pre codeblock"><code>SELECT … FROM r1 LEFT OUTER JOIN s1 ON any_join_condition(s1,s2) 
AND any_filter(r1) AND any_filter(s1)
</code></pre><p>Where the duplicated table is the second table in <code class="codeph">RIGHT OUTER JOIN</code>, or the sharded table is second and it maps to a single shard based on filter predicate on sharding key:
                        </p><pre class="pre codeblock"><code>SELECT … FROM s1 RIGHT OUTER JOIN r1 ON any_join_condition(s1,s2) 
AND any_filter (s1) AND any_filter(r1)
</code></pre><p>Full Outer Join</p>
                        <p>Sharded table requiring access to multiple shards:</p><pre class="pre codeblock"><code>SELECT … FROM s1 FULL OUTER JOIN r1 ON s1.non_sk=s2.non_sk
WHERE any_filter(s1) AND any_filter(s2)
</code></pre><p>Semi-join (<code class="codeph">EXISTS</code>)
                        </p>
                        <p>Sharded table is in a subquery that requires access of multiple shards:</p><pre class="pre codeblock"><code>SELECT … FROM r1 EXISTS 
(SELECT 1 FROM s1 WHERE r1.anykey=s1.anykey)
</code></pre><p>Anti-join (<code class="codeph">NOT EXISTS</code>)
                        </p>
                        <p>Sharded table is in the sub-query:</p><pre class="pre codeblock"><code>SELECT … FROM r1 NOT EXISTS 
(SELECT 1 FROM s1 WHERE r1.anykey=s1.anykey</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-885861C9-D473-4B22-9D74-6AC1951C0D50">Aggregate Functions</p>
                        <p>The following aggregations are supported by proxy routing:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">COUNT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SUM</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MIN</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MAX</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">AVG</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-1974D8DE-2376-47DA-85DF-92E7EFA3ED0F">Multi-shard Queries and Global CR</p>
                        <p>A multi-shard query must maintain global read consistency (CR) by issuing the query at the highest common SCN across all the shards. See <a href="sharding-data-routing.html#GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" title="You can use the initialization parameter MULTISHARD_QUERY_DATA_CONSISTENCY to set different consistency levels when executing multi-shard queries across shards.">Specifying Consistency Levels in a Multi-Shard Query</a> for information about how to set consistency levels.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-153720B4-2DF6-452C-9F69-0AE9B37FABFC">Transactions</p>
                        <p>A DML statement that <span class="underline">affects only one shard</span> is supported. For example,
                        </p><pre class="pre codeblock"><code>update S1 set col = … where <span class="bold">sk = &lt;constant&gt;</span>;</code></pre><p>A DML statement that affects more than one shard is not supported. For example,</p><pre class="pre codeblock"><code>update S1 set col = …;</code></pre><p>Within a transaction, multiple single shard DMLs can be performed on different shards. For example,</p><pre class="pre codeblock"><code>insert into S1 values (…);
Update S1 set col = … where <span class="bold">sk = <span class="variable" translate="no">constant</span></span>;
Delete S1 where <span class="bold">sk = <span class="variable" translate="no">constant</span></span>;
Commit;</code></pre><p>For multi-shard DML, the coordinator uses database link, starts a distributed transaction and performs two phase commit to guarantee the consistency of the distributed transaction. In the case of an in-doubt transaction, the database administrator has to recover it manually.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-66A389F7-D1F0-46F7-8A4C-7116E83F4489">Passing Hints in Multi-Shard Queries</p>
                        <p>Any hint specified in the original query on the coordinator is propagated to the shards.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-EBD29518-E44D-42CB-9DC4-FC9A95B1DC98">Tracing and Troubleshooting Slow Running Multi-Shard Queries</p>
                        <p>Set the trace event <code class="codeph">shard_sql</code> on the coordinator to trace the query rewrite and shard pruning. One of the common performance issues observed is when the GROUP BY is not pushed to the shards because of certain limitations of the sharding. Check if all of the possible operations are pushed to the shards and the coordinator has minimal work to consolidate the results from shards.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-51377035-217B-4624-88CD-A5D5DE125606" name="GUID-51377035-217B-4624-88CD-A5D5DE125606"></a><h4 id="SHARD-GUID-51377035-217B-4624-88CD-A5D5DE125606" class="sect4"><span class="enumeration_section">6.2.7 </span>Execution Plans for Proxy Routing
                  </h4>
                  <div>
                     <p>In a multi-shard query, each shard produces an independent execution plan that is potentially different from the plans on the other shards in the query.</p>
                     <p>You do not need to connect to individual shards to see the explain plan for SQL fragments. Interfaces provided in <code class="codeph">dbms_xplan.display_cursor()</code> display on the coordinator the plans for the SQL segments executed on the shards, and <code class="codeph">[V/X]$SHARD_SQL</code> uniquely maps a shard SQL fragment of a multi-shard query to the target shard database.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-94DB70CE-D8C0-4DD8-960F-836AA88EFC86">SQL segment interfaces for dbms_xplan.display_cursor()</p>
                        <p>Two interfaces display the plan of a SQL segment executed on shards. The interfaces take shard IDs as the argument to display the plans from the specified shards . The <code class="codeph">ALL_SHARDS</code> format displays the plans from all of the shards.
                        </p>
                        <p>To print all the plans from shards use the format ALL_SHARDS as shown here.</p><pre class="pre codeblock"><code>select * from table(dbms_xplan.display_cursor(sql_id=&gt;:sqlid,
                                              cursor_child_no=&gt;:childno,
                                              format=&gt;'BASIC +<span class="bold">ALL_SHARDS</span>‘,
                                              shard_ids=&gt;shard_ids))</code></pre><p>To print selective plans from the shards, pass shard IDs in the <code class="codeph">display_cursor()</code> function. For plans from multiple shards pass an array of numbers containing shard IDs of interest in the <code class="codeph">shard_ids</code> parameter as shown here.
                        </p><pre class="pre codeblock"><code>select * from table(dbms_xplan.display_cursor(sql_id=&gt;:sqlid, 
                                               cursor_child_no=&gt;:childno,
                                               format=&gt;'BASIC',
                                               <span class="bold">shard_ids=&gt;ids</span>))</code></pre><p>To return a plan from one shard pass the shard ID directly to the <code class="codeph">shard_id</code> parameter, as shown here.
                        </p><pre class="pre codeblock"><code>select * from table(dbms_xplan.display_cursor(sql_id=&gt;:sqlid,
                                              cursor_child_no=&gt;:childno,
                                              format=&gt;'BASIC',
                                              <span class="bold">shard_id=&gt;1</span>))
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-C827DA36-3151-42EC-9606-2AD0D0963C7D">[V/X]$SHARD_SQL</p>
                        <p><code class="codeph">[V/X]$SHARD_SQL</code> uniquely maps a shard SQL fragment of a multi-shard query to the target shard database. This view is relevant only for the shard coordinator database to store a list of shards accessed for each shard SQL fragment for a given multi-shard query. Every execution of a multi-shard query can execute a shard SQL fragment on different set of shards, so every execution updates the shard IDs. This view maintains the SQL ID of a shard SQL fragment for each REMOTE node and the SHARD IDs on which the shard SQL fragment was executed.
                        </p><pre class="pre codeblock"><code>Name                                      Null?    Type
----------------------------------------- -------- ----------------------------
 SQL_ID                                            VARCHAR2(13)
 CHILD_NUMBER                                      NUMBER
 NODE_ID                                           NUMBER
 SHARD_SQL_ID                                      VARCHAR2(13)
 SHARD_ID                                          NUMBER
 SHARD_CHILD_NUMBER                                NUMBER</code></pre><ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">SQL_ID</span> &#x2013; SQL ID of a multi-shard query on coordinator 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">CHILD_NUMBER</span> &#x2013; cursor child number of a multi-shard query on coordinator 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">NODE_ID</span> &#x2013; ID of REMOTE node for a shard SQL fragment of a multi-shard query
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD_SQL_ID</span> &#x2013; SQL ID of the shard SQL fragment for given remote NODE ID
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD_ID</span> &#x2013; IDs of shards where the shard SQL fragment was executed
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD _CHILD_NUMBER</span>&#x2013; cursor child number of a shard SQL fragment on a shard (default 0)
                              </p>
                           </li>
                        </ul>
                        <p>The following is an example of a multi-shard query on the sharded database and the execution plan.</p><pre class="pre codeblock"><code>SQL&gt; select count(*) from departments a where exists (select distinct department_id
 from departments b where b.department_id=60);
------------------------------------------------
| Id  | Operation          | Name              |
------------------------------------------------
|   0 | SELECT STATEMENT   |                   |
|   1 |  SORT AGGREGATE    |                   |
|   2 |   FILTER           |                   |
|   3 |    VIEW            | VW_SHARD_377C5901 |
|   4 |     SHARD ITERATOR |                   |
|   5 |      <span class="bold">REMOTE</span>        |                   |
|   6 |    VIEW            | VW_SHARD_EEC581E4 |
|   7 |     SHARD ITERATOR |                   |
|   8 |      <span class="bold">REMOTE</span>        |                   |
------------------------------------------------
</code></pre><p>A query of SQL_ID on the <code class="codeph">V$SHARD_SQL</code> view.
                        </p><pre class="pre codeblock"><code>SQL&gt; Select * from v$shard_sql where SQL_ID = ‘1m024z033271u’;
SQL_ID        NODE_ID   SHARD_SQL_ID  SHARD_ID
------------- -------  -------------- --------
1m024z033271u       5   5z386yz9suujt        1
1m024z033271u       5   5z386yz9suujt       11 
1m024z033271u       5   5z386yz9suujt       21 
1m024z033271u       8   8f50ctj1a2tbs 	    11
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-570F1CD0-8191-4F5C-BCBD-1CBED91EA578">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=ARPLS-GUID-BEE6D488-0381-4864-9B19-6299DE2B6210" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=REFRN-GUID-35400A54-B329-4C50-96AB-830152437737" target="_blank"><span><cite>Oracle Database Reference</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding supports routing for queries that do not specify a sharding key. This allows the flexibility for any database application to execute SQL statements (including SELECT and DML) in a system where tables are sharded or duplicated without the need to specify the shards where the query should be executed.">Queries and DMLs with Proxy Routing in a Sharded Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550" name="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550"></a><h3 id="SHARD-GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550" class="sect3"><span class="enumeration_section">6.3 </span>Creating Affinity Between Middle-Tier Connection Pools and Shards
               </h3>
               <div>
                  <p>A Oracle Universal Connection Pool (UCP) feature called middle-tier routing allows smart routers (F5 BigIP, for example) to route to the middle tier associated with a sharding key. It publishes the sharded database topology to the router tier so that requests based on specific sharding keys are routed to the appropriate&nbsp;application middle tier, which in turn establishes connections on the given subset of shards.</p>
                  <p>In a typical Oracle Sharding environment, middle-tier connection pools route database requests to specific shards. This can lead to a situation where each middle-tier connection pool establishes connections to each shard. This can create too many connections to the database. The issue can be solved by creating an affinity between the middle tiers and shards. In this scenario it would be ideal to dedicate a middle tier (web server, application server) for each data center or cloud, and to have client requests routed directly to the middle tier where the shard containing the client data (corresponding to the client shard key) resides. A common term used for this kind of setup is swim lanes, where each swim lane is a dedicated stack, from web server to application server all the way to the database.</p>
                  <p>Oracle Universal Connection Pool (UCP) solves this problem by providing a middle-tier routing API which can be used to route client requests to the relevant middle tier. The UCP middle tier API is exposed by the <code class="codeph">OracleShardRoutingCache</code> class. An instance of this class represents the UCP internal shard routing cache, which can be created by providing connection properties such as user, password, and URL. The routing cache connects to the sharding catalog to retrieve the key to shard mapping topology and stores it in its cache.
                  </p>
                  <p>The routing cache is used by UCP middle-tier API <code class="codeph">getShardInfoForKey(shardKey,superShardKey)</code>, which accepts a sharding key as input and returns a set of <code class="codeph">ShardInfo</code> instances mapped to the input sharding key. The <code class="codeph">ShardInfo</code> instance encapsulates a unique shard name and priority of the shard. An application using the middle-tier API can map the returned unique shard name value to a middle tier that has connections to a specific shard. The routing cache is automatically updated when chunks are split or moved to other shards by subscribing to respective ONS events.
                  </p>
                  <p>The following code example illustrates the usage of Oracle UCP middle-tier routing API.</p>
                  <div class="example" id="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550__GUID-5D4DAF99-8CF1-4D44-B188-DC10264559E1">
                     <p class="titleinexample">Example 6-4 Middle-Tier Routing Using UCP API</p><pre class="pre codeblock"><code>import java.sql.SQLException;
import java.util.Properties;
import java.util.Random;
import java.util.Set;

import oracle.jdbc.OracleShardingKey;
import oracle.jdbc.OracleType;
import oracle.ucp.UniversalConnectionPoolException;
import oracle.ucp.routing.ShardInfo;
import oracle.ucp.routing.oracle.OracleShardRoutingCache;

/**
 * The code example illustrates the usage of UCP's mid-tier routing feature.  
 * The API accepts sharding key as input and returns the set of ShardInfo 
 * instances mapped to the sharding key. The ShardInfo instance encapsulates 
 * unique shard name and priority. The unique shard name then can be mapped 
 * to a mid-tier server which connects to a specific shard.
 *
 */
public class MidtierShardingExample {

  private static String user = "testuser1";
  private static String password = "testuser1";

  // catalog DB URL
  private static String url = "jdbc:oracle:thin:@//hostName:1521/catalogServiceName";
  private static String region = "regionName";

  public static void main(String args[]) throws Exception {
    testMidTierRouting();
  }

  static void testMidTierRouting() throws UniversalConnectionPoolException,
      SQLException {

    Properties dbConnectProperties = new Properties();
    dbConnectProperties.setProperty(OracleShardRoutingCache.USER, user);
    dbConnectProperties.setProperty(OracleShardRoutingCache.PASSWORD, password);
    // Mid-tier routing API accepts catalog DB URL
    dbConnectProperties.setProperty(OracleShardRoutingCache.URL, url);

    // Region name is required to get the ONS config string
    dbConnectProperties.setProperty(OracleShardRoutingCache.REGION, region);

    OracleShardRoutingCache routingCache = new OracleShardRoutingCache(
        dbConnectProperties);

    final int COUNT = 10;
    Random random = new Random();

    for (int i = 0; i &lt; COUNT; i++) {
      int key = random.nextInt();
      OracleShardingKey shardKey = routingCache.getShardingKeyBuilder()
          .subkey(key, OracleType.NUMBER).build();
      OracleShardingKey superShardKey = null;

      Set&lt;ShardInfo&gt; shardInfoSet = routingCache.getShardInfoForKey(shardKey,
          superShardKey);

      for (ShardInfo shardInfo : shardInfoSet) {
        System.out.println("Sharding Key=" + key + " Shard Name="
            + shardInfo.getName() + " Priority=" + shardInfo.getPriority());
      }
    }

  }
}
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJUCP-GUID-6B3483EE-6E38-4B76-AAAC-0192E5827C3A" target="_blank">Middle-Tier Routing Using UCP</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers.">Request Routing in a Sharded Database Environment</a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>