<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter discusses the memory architecture of a database instance.">
      <meta name="description" content="This chapter discusses the memory architecture of a database instance.">
      <title>Memory Architecture</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Concepts">
      <meta property="og:description" content="This chapter discusses the memory architecture of a database instance.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Concepts">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00">
      <meta name="dcterms.title" content="Database Concepts">
      <meta name="dcterms.dateCopyrighted" content="1993, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96138-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="oracle-database-instance.html" title="Previous" type="text/html">
      <link rel="next" href="process-architecture.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-database-instance.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="process-architecture.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Concepts</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-instance-architecture.html" property="item" typeof="WebPage"><span property="name">Oracle Instance Architecture</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Memory Architecture</li>
            </ol>
            <a id="GUID-913335DF-050A-479A-A653-68A064DCCA41" name="GUID-913335DF-050A-479A-A653-68A064DCCA41"></a><a id="CNCPT007"></a>
            
            <h2 id="CNCPT-GUID-913335DF-050A-479A-A653-68A064DCCA41" class="sect2"><span class="enumeration_chapter">14 </span>Memory Architecture
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses the memory architecture of a database instance.</p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="memory-architecture.html#GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" title="When an instance is started, Oracle Database allocates a memory area and starts background processes.">Introduction to Oracle Database Memory Structures</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-61B574AB-8493-4D43-8B30-0050A30550AD" title="The UGA is session memory, which is memory allocated for session variables, such as logon information, and other information required by a database session. Essentially, the UGA stores the session state.">Overview of the User Global Area</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-859795E2-87CD-442B-B36F-584A77755F59" title="The PGA is memory specific to an operating process or thread that is not shared by other processes or threads on the system. Because the PGA is process-specific, it is never allocated in the SGA.">Overview of the Program Global Area (PGA)</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" title="The SGA is a read/write memory area that, along with the Oracle background processes, form a database instance.">Overview of the System Global Area (SGA)</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" title="A software code area is a portion of memory that stores code that is being run or can be run. Oracle Database code is stored in a software area that is typically more exclusive and protected than the location of user programs.">Overview of Software Code Areas</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-913335DF-050A-479A-A653-68A064DCCA41__GUID-A380A7A7-B722-4313-BF06-3548919FA5A1">
                  <p class="notep1">See Also:</p>
                  <p><a href="../admin/managing-memory.html#ADMIN00207" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for instructions for configuring and managing memory
                  </p>
               </div>
            </div><a id="CNCPT7776"></a><div class="props_rev_3"><a id="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" name="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774"></a><h3 id="CNCPT-GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" class="sect3">Introduction to Oracle Database Memory Structures</h3>
               <div>
                  <p>When an instance is started, Oracle Database allocates a memory area and starts background processes.</p>
                  <p>The memory area stores information such as the following: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Program code</p>
                     </li>
                     <li>
                        <p>Information about each connected <a href="glossary.html#GUID-0F44C072-9841-4E2E-B846-FB16A2E54139"><span class="xrefglossterm">session</span></a>, even if it is not currently active
                        </p>
                     </li>
                     <li>
                        <p>Information needed during program execution, for example, the current state of a <a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">query</span></a> from which rows are being fetched
                        </p>
                     </li>
                     <li>
                        <p>Information such as <a href="glossary.html#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C"><span class="xrefglossterm">lock</span></a> data that is shared and communicated among processes
                        </p>
                     </li>
                     <li>
                        <p>Cached data, such as data blocks and redo records, that also exists on disk</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774__GUID-07FDFA76-13C8-462F-AD2A-1EDADA321CCE">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="process-architecture.html#GUID-85D9852E-5BF1-4AC0-9E5A-49F0570DBD7A" title="This chapter discusses the processes in an Oracle database.">Process Architecture</a>"</span></p>
                  </div>
               </div><a id="CNCPT89066"></a><a id="CNCPT7777"></a><div class="props_rev_3"><a id="GUID-02378E7A-865B-456B-8725-1E73D16A34BE" name="GUID-02378E7A-865B-456B-8725-1E73D16A34BE"></a><h4 id="CNCPT-GUID-02378E7A-865B-456B-8725-1E73D16A34BE" class="sect4">Basic Memory Structures</h4>
                  <div>
                     <p>Oracle Database includes several memory areas, each of which contains multiple subcomponents.</p>
                     <p>The basic memory structures associated with Oracle Database include:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>System global area (SGA)</p>
                           <p>The SGA is a group of shared memory structures, known as <span class="italic">SGA components</span>, that contain data and control information for one Oracle Database instance. All server and background processes share the SGA. Examples of data stored in the SGA include cached data blocks and shared SQL areas.
                           </p>
                        </li>
                        <li>
                           <p>Program global area (PGA)</p>
                           <p>A PGA is a nonshared memory region that contains data and control information exclusively for use by an Oracle process. Oracle Database creates the PGA when an Oracle process starts.</p>
                           <p>One PGA exists for each <a href="glossary.html#GUID-E660AC1C-B704-4DC1-A35A-DB49EFB34F4A"><span class="xrefglossterm">server process</span></a> and background process. The collection of individual PGAs is the total instance PGA, or <a href="glossary.html#GUID-8341392A-07AD-45A0-8E71-E330584EEE74"><span class="xrefglossterm">instance PGA</span></a>. Database initialization parameters set the size of the instance PGA, not individual PGAs.
                           </p>
                        </li>
                        <li>
                           <p>User global area (UGA)</p>
                           <p>The UGA is memory associated with a user session.</p>
                        </li>
                        <li>
                           <p>Software code areas</p>
                           <p>Software code areas are portions of memory used to store code that is being run or can be run. Oracle Database code is stored in a software area that is typically at a different location from user programs—a more exclusive or protected location.</p>
                        </li>
                     </ul>
                     <p>The following figure illustrates the relationships among these memory structures.</p>
                     <div class="figure" id="GUID-02378E7A-865B-456B-8725-1E73D16A34BE__CHDHAHIJ">
                        <p class="titleinfigure">Figure 14-1 Oracle Database Memory Structures</p><img src="img/cncpt217.gif" alt="Description of Figure 14-1 follows" title="Description of Figure 14-1 follows" longdesc="img_text/cncpt217.html"><br><a href="img_text/cncpt217.html">Description of "Figure 14-1 Oracle Database Memory Structures"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="CNCPT7778"></a><div class="props_rev_3"><a id="GUID-079064A0-DBFC-45C4-B10A-1442D4667036" name="GUID-079064A0-DBFC-45C4-B10A-1442D4667036"></a><h4 id="CNCPT-GUID-079064A0-DBFC-45C4-B10A-1442D4667036" class="sect4">Oracle Database Memory Management</h4>
                  <div>
                     <p>Memory management involves maintaining optimal sizes for the Oracle instance memory structures as demands on the database change. Oracle Database manages memory based on the settings of memory-related initialization parameters.</p>
                     <p>The basic options for memory management are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Automatic memory management</p>
                           <p>You specify the target size for the database instance memory. The instance automatically tunes to the target memory size, redistributing memory as needed between the SGA and the instance PGA.</p>
                        </li>
                        <li>
                           <p>Automatic shared memory management</p>
                           <p>This management mode is partially automated. You set a target size for the SGA and then have the option of setting an aggregate target size for the PGA or managing PGA work areas individually.</p>
                        </li>
                        <li>
                           <p>Manual memory management</p>
                           <p>Instead of setting the total memory size, you set many initialization parameters to manage components of the SGA and instance PGA individually.</p>
                        </li>
                     </ul>
                     <p>If you create a database with Database Configuration Assistant (DBCA) and choose the basic installation option, then automatic memory management is the default.</p>
                     <div class="infoboxnotealso" id="GUID-079064A0-DBFC-45C4-B10A-1442D4667036__GUID-F2F3F67F-D0CD-4CD1-8226-A351C51FC434">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-D39DB708-CC94-4EE6-ACDA-ACED36DA4DA5" title="Memory management involves maintaining optimal sizes for the Oracle instance memory structures as demands on the database change. Initialization parameter settings determine how SGA and instance PGA memory is managed.">Memory Management</a>"</span> for more information about memory management options for DBAs
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-87ACF317-FEBC-418C-9BE6-253F2C43F482" title="Oracle provides several tools to simplify the task of installing and configuring Oracle Database software.">Tools for Database Installation and Configuration</a>"</span> to learn about DBCA
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN11197" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn about memory management options
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT89067"></a><a id="CNCPT1238"></a><div class="props_rev_3"><a id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD" name="GUID-61B574AB-8493-4D43-8B30-0050A30550AD"></a><h3 id="CNCPT-GUID-61B574AB-8493-4D43-8B30-0050A30550AD" class="sect3">Overview of the User Global Area</h3>
               <div>
                  <p>The UGA is session memory, which is memory allocated for session variables, such as logon information, and other information required by a database session. Essentially, the UGA stores the session state.</p>
                  <p>The following figure depicts the UGA.</p>
                  <div class="figure" id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD__BGBJCDEA">
                     <p class="titleinfigure">Figure 14-2 User Global Area (UGA)</p><img src="img/cncpt222.gif" alt="Description of Figure 14-2 follows" title="Description of Figure 14-2 follows" longdesc="img_text/cncpt222.html"><br><a href="img_text/cncpt222.html">Description of "Figure 14-2 User Global Area (UGA)"</a></div>
                  <!-- class="figure" -->
                  <p>If a session loads a <a href="glossary.html#GUID-FE40E95B-5EB8-46D6-8ED2-5DB2D26C8726"><span class="xrefglossterm">PL/SQL package</span></a> into memory, then the UGA contains the <span class="italic">package state</span>, which is the set of values stored in all the package variables at a specific time. The package state changes when a package subprogram changes the variables. By default, the package variables are unique to and persist for the life of the session.
                  </p>
                  <p>The <a href="glossary.html#GUID-D802897B-B87B-462C-9E55-5C36226CE128"><span class="xrefglossterm">OLAP page pool</span></a> is also stored in the UGA. This pool manages <a href="glossary.html#GUID-A6734D1E-A45B-4BE3-ABF8-F6201A40F6B3"><span class="xrefglossterm">OLAP</span></a> data pages, which are equivalent to data blocks. The page pool is allocated at the start of an OLAP session and released at the end of the session. An OLAP session opens automatically whenever a user queries a dimensional object such as a <a href="glossary.html#GUID-A41DC92E-57F1-4ECB-96EA-E641EEC33748"><span class="xrefglossterm">cube</span></a>.
                  </p>
                  <p>The UGA must be available to a database session for the life of the session. For this reason, the UGA cannot be stored in the PGA when using a <a href="glossary.html#GUID-E94CE0E3-CC86-4F46-B8EF-54945F026326"><span class="xrefglossterm">shared server</span></a> connection because the PGA is specific to a single process. Therefore, the UGA is stored in the SGA when using shared server connections, enabling any shared server process access to it. When using a <a href="glossary.html#GUID-8B14C804-9D68-471C-A581-5AEE673A9FCD"><span class="xrefglossterm">dedicated server</span></a> connection, the UGA is stored in the PGA.
                  </p>
                  <div class="infoboxnotealso" id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD__GUID-D46BD30E-0CF3-49A1-8709-4491CD633EBB">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="server-side-programming.html#GUID-87FA8137-A449-4542-8869-441C63810C63" title="A PL/SQL package is a group of related subprograms, along with the cursors and variables they use, stored together in the database for continued use as a unit. Packaged subprograms can be called explicitly by applications or users.">PL/SQL Packages</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="process-architecture.html#GUID-3A11FF2F-50EE-4839-A1A6-F746DFF634AB" title="A database connection is a physical communication pathway between a client process and a database instance.">Connections and Sessions</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="../netag/understanding-oracle-net-architecture.html#NETAG210" target="_blank"><span><cite>Oracle Database Net Services Administrator's Guide</cite></span></a> to learn about shared server connections
                           </p>
                        </li>
                        <li>
                           <p><a href="../olaug/overview.html#OLAUG100" target="_blank"><span><cite>Oracle OLAP User’s Guide</cite></span></a> for an overview of Oracle OLAP
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="CNCPT89068"></a><a id="CNCPT803"></a><div class="props_rev_3"><a id="GUID-859795E2-87CD-442B-B36F-584A77755F59" name="GUID-859795E2-87CD-442B-B36F-584A77755F59"></a><h3 id="CNCPT-GUID-859795E2-87CD-442B-B36F-584A77755F59" class="sect3">Overview of the Program Global Area (PGA)</h3>
               <div>
                  <p>The PGA is memory specific to an operating process or thread that is not shared by other processes or threads on the system. Because the PGA is process-specific, it is never allocated in the SGA.</p>
                  <p>The PGA is a memory heap that contains session-dependent variables required by a dedicated or shared server process. The server process allocates memory structures that it requires in the PGA.</p>
                  <p>An analogy for a PGA is a temporary countertop workspace used by a file clerk. In this analogy, the file clerk is the server process doing work on behalf of the customer (client process). The clerk clears a section of the countertop, uses the workspace to store details about the customer request and to sort the folders requested by the customer, and then gives up the space when the work is done.</p>
                  <p>The following figure shows an instance PGA (collection of all PGAs) for an instance that is not configured for shared servers. You can use an initialization parameter to set a target maximum size of the instance PGA. Individual PGAs can grow as needed up to this target size.</p>
                  <div class="figure" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__BGBFGGFF">
                     <p class="titleinfigure">Figure 14-3 Instance PGA</p><img src="img/cncpt218.gif" width="257" alt="Description of Figure 14-3 follows" title="Description of Figure 14-3 follows" longdesc="img_text/cncpt218.html"><br><a href="img_text/cncpt218.html">Description of "Figure 14-3 Instance PGA"</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnote" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__GUID-A3441764-26D0-4269-9F89-50A9B1825587">
                     <p class="notep1">Note:</p>
                     <p>Background processes also allocate their own PGAs. This discussion focuses on server process PGAs only.</p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__GUID-73AE7CC2-C339-4403-A147-62B7CC658325">
                     <p class="notep1">See Also:</p>
                     <p> <span class="q">"<a href="concepts-for-database-administrators.html#GUID-17DC29B0-9741-4B80-8091-D9E1A886B357" title="Memory management is either automatic or manual.">Summary of Memory Management Methods</a>"</span></p>
                  </div>
               </div><a id="CNCPT89069"></a><a id="CNCPT1237"></a><div class="props_rev_3"><a id="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1" name="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1"></a><h4 id="CNCPT-GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1" class="sect4">Contents of the PGA</h4>
                  <div>
                     <p>The PGA is subdivided into different areas, each with a different purpose. </p>
                     <p>The following figure shows the possible contents of the PGA for a dedicated server session. Not all of the PGA areas will exist in every case.</p>
                     <div class="figure" id="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1__BGBCICEI">
                        <p class="titleinfigure">Figure 14-4 PGA Contents</p><img src="img/cncpt219.gif" alt="Description of Figure 14-4 follows" title="Description of Figure 14-4 follows" longdesc="img_text/cncpt219.html"><br><a href="img_text/cncpt219.html">Description of "Figure 14-4 PGA Contents"</a></div>
                     <!-- class="figure" -->
                  </div><a id="CNCPT89189"></a><a id="CNCPT1239"></a><div class="props_rev_3"><a id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" name="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810"></a><h5 id="CNCPT-GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" class="sect5">Private SQL Area</h5>
                     <div>
                        <p>A <span class="bold">private SQL area</span> holds information about a parsed SQL statement and other session-specific information for processing. 
                        </p>
                        <p>When a server process executes SQL or PL/SQL code, the process uses the private SQL area to store <a href="glossary.html#GUID-456A73CB-75F4-4197-B1CD-12A51A1CBDC7"><span class="xrefglossterm">bind variable</span></a> values, query execution state information, and query execution work areas. 
                        </p>
                        <p>Do not confuse a <span class="italic">private</span> SQL area, which is in the PGA, with the <span class="italic">shared</span> SQL area, which stores execution plans in the SGA. Multiple private SQL areas in the same or different sessions can point to a single execution plan in the SGA. For example, 20 executions of <code class="codeph">SELECT * FROM sales</code> in one session and 10 executions of the same query in a different session can share the same plan. The private SQL areas for each execution are not shared and may contain different values and data.
                        </p>
                        <p>A <a href="glossary.html#GUID-D1D3E8DD-CD5C-4C0D-93E4-DE0BF0BD53A3"><span class="xrefglossterm">cursor</span></a> is a name or handle to a specific private SQL area. As shown in the following graphic, you can think of a cursor as a pointer on the client side and as a state on the server side. Because cursors are closely associated with private SQL areas, the terms are sometimes used interchangeably.
                        </p>
                        <div class="figure" id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810__BGBJBFAE">
                           <p class="titleinfigure">Figure 14-5 Cursor</p><img src="img/cncpt324.gif" alt="Description of Figure 14-5 follows" title="Description of Figure 14-5 follows" longdesc="img_text/cncpt324.html"><br><a href="img_text/cncpt324.html">Description of "Figure 14-5 Cursor"</a></div>
                        <!-- class="figure" -->
                        <p>A private SQL area is divided into the following areas:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The run-time area</p>
                              <p>This area contains query execution state information. For example, the run-time area tracks the number of rows retrieved so far in a <a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a>. 
                              </p>
                              <p>Oracle Database creates the run-time area as the first step of an execute request. For <a href="glossary.html#GUID-B5F2F112-1B33-41B5-B63D-9DC8F99A369D"><span class="xrefglossterm">DML</span></a> statements, the run-time area is freed when the SQL statement is closed.
                              </p>
                           </li>
                           <li>
                              <p>The persistent area</p>
                              <p>This area contains <a href="glossary.html#GUID-456A73CB-75F4-4197-B1CD-12A51A1CBDC7"><span class="xrefglossterm">bind variable</span></a> values. A bind variable value is supplied to a SQL statement at run time when the statement is executed. The persistent area is freed only when the cursor is closed.
                              </p>
                           </li>
                        </ul>
                        <p>The client process is responsible for managing private SQL areas. The allocation and deallocation of private SQL areas depends largely on the application, although the number of private SQL areas that a client process can allocate is limited by the initialization parameter <code class="codeph">OPEN_CURSORS</code>. 
                        </p>
                        <p>Although most users rely on the automatic cursor handling of database utilities, the Oracle Database programmatic interfaces offer developers more control over cursors. In general, applications should close all open cursors that will not be used again to free the persistent area and to minimize the memory required for application users.</p>
                        <div class="infoboxnotealso" id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810__GUID-A2D832E3-D2AB-446E-9C2E-2EF928024AF0">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" title="The database represents each SQL statement that it runs in the shared SQL area and private SQL area.">Shared SQL Areas</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS00903" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> and <a href="../lnpls/static-sql.html#LNPLS00602" target="_blank"><span><cite>Oracle Database PL/SQL Language Reference</cite></span></a> to learn how to use cursors
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT89070"></a><a id="CNCPT1242"></a><div class="props_rev_3"><a id="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82" name="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82"></a><h5 id="CNCPT-GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82" class="sect5">SQL Work Areas</h5>
                     <div>
                        <p>A <span class="bold">work area</span> is a private allocation of PGA memory used for memory-intensive operations. 
                        </p>
                        <p>For example, a sort operator uses the sort area to sort a set of rows. Similarly, a <a href="glossary.html#GUID-D2587A67-E1CB-4F35-8830-4599717C47BC"><span class="xrefglossterm">hash join</span></a> operator uses a hash area to build a <a href="glossary.html#GUID-1EBD10A8-7E0A-45B9-94CB-0859F4773082"><span class="xrefglossterm">hash table</span></a> from its left input, whereas a <a href="glossary.html#GUID-85F90309-D2DA-455C-A726-81C33043566E"><span class="xrefglossterm">bitmap merge</span></a> uses the bitmap merge area to merge data retrieved from scans of multiple bitmap indexes.
                        </p>
                        <p>The following example shows a <a href="glossary.html#GUID-71A4D429-D0A6-4979-AACA-EDE5F4BCFC8B"><span class="xrefglossterm">join</span></a> of <code class="codeph">employees</code> and <code class="codeph">departments</code> with its <a href="glossary.html#GUID-78BCF1CD-1865-4AEB-8F14-AFA4FF1981BF"><span class="xrefglossterm">query plan</span></a>:
                        </p><pre class="pre codeblock"><code>SQL&gt; SELECT * 
  2  FROM   employees e JOIN departments d 
  3  ON     e.department_id=d.department_id 
  4  ORDER BY last_name;
.
.
.
--------------------------------------------------------------------------------
| Id| Operation           | Name        | Rows  | Bytes | Cost (%CPU)| Time    |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT    |             |   106 |  9328 |    7  (29)| 00:00:01 |
| 1 |  SORT ORDER BY      |             |   106 |  9328 |    7  (29)| 00:00:01 |
|*2 |   HASH JOIN         |             |   106 |  9328 |    6  (17)| 00:00:01 |
| 3 |    TABLE ACCESS FULL| DEPARTMENTS |    27 |   540 |    2   (0)| 00:00:01 |
| 4 |    TABLE ACCESS FULL| EMPLOYEES   |   107 |  7276 |    3   (0)| 00:00:01 |
--------------------------------------------------------------------------------
</code></pre><p>In the preceding example, the run-time area tracks the progress of the full table scans. The session performs a hash join in the hash area to match rows from the two tables. The <code class="codeph">ORDER BY</code> sort occurs in the sort area.
                        </p>
                        <p>If the amount of data to be processed by the operators does not fit into a work area, then Oracle Database divides the input data into smaller pieces. In this way, the database processes some data pieces in memory while writing the rest to temporary disk storage for processing later.</p>
                        <p>The database automatically tunes work area sizes when automatic PGA memory management is enabled. You can also manually control and tune the size of a work area. See <span class="q">"<a href="concepts-for-database-administrators.html#GUID-D39DB708-CC94-4EE6-ACDA-ACED36DA4DA5" title="Memory management involves maintaining optimal sizes for the Oracle instance memory structures as demands on the database change. Initialization parameter settings determine how SGA and instance PGA memory is managed.">Memory Management</a>"</span> for more information.
                        </p>
                        <p>Generally, larger work areas can significantly improve performance of an operator at the cost of higher memory consumption. Optimally, the size of a work area is sufficient to accommodate the input data and auxiliary memory structures allocated by its associated SQL operator. If not, response time increases because part of the input data must be cached on disk. In the extreme case, if the size of a work area is too small compared to input data size, then the database must perform multiple passes over the data pieces, dramatically increasing response time.</p>
                        <div class="infoboxnotealso" id="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82__GUID-F88BA790-8DEF-4180-A59C-DFBF076839F3">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-memory.html#ADMIN11233" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to use automatic PGA management
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/tuning-program-global-area.html#TGDBA346" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to tune PGA memory
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89071"></a><a id="CNCPT1243"></a><div class="props_rev_3"><a id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE" name="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE"></a><h4 id="CNCPT-GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE" class="sect4">PGA Usage in Dedicated and Shared Server Modes</h4>
                  <div>
                     <p>PGA memory allocation depends on whether the database uses dedicated or shared server connections.</p>
                     <p>The following table shows the differences.</p>
                     <div class="tblformal" id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE__G26073">
                        <p class="titleintable">Table 14-1 Differences in Memory Allocation Between Dedicated and Shared Servers</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Differences in Memory Allocation Between Dedicated and Shared Servers" summary="This table shows the differences between dedicated and shared server architecture." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d75455e3144">Memory Area</th>
                                 <th align="left" valign="bottom" width="30%" id="d75455e3147">Dedicated Server</th>
                                 <th align="left" valign="bottom" width="30%" id="d75455e3150">Shared Server</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3155" headers="d75455e3144 ">
                                    <p>Nature of session memory</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3155 d75455e3147 ">
                                    <p>Private</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3155 d75455e3150 ">
                                    <p>Shared</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3165" headers="d75455e3144 ">
                                    <p>Location of the persistent area</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3165 d75455e3147 ">
                                    <p>PGA</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3165 d75455e3150 ">
                                    <p>SGA</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3175" headers="d75455e3144 ">
                                    <p>Location of the run-time area for DML and DDL statements</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3175 d75455e3147 ">
                                    <p>PGA</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3175 d75455e3150 ">
                                    <p>PGA</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE__GUID-3F7C0208-F532-4AF2-AD08-5B1A4709B086">
                        <p class="notep1">See Also:</p>
                        <p><a href="../admin/managing-processes.html#GUID-1EC99B97-38DC-4061-A2F5-3890828616B5" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to configure a database for shared server
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT802"></a><div class="props_rev_3"><a id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" name="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73"></a><h3 id="CNCPT-GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" class="sect3">Overview of the System Global Area (SGA)</h3>
               <div>
                  <p>The <span class="bold">SGA</span> is a read/write memory area that, along with the Oracle background processes, form a database instance.
                  </p>
                  <div class="infoboxnote" id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73__GUID-26164DEF-334F-494A-9DE2-DF996A2FDB3B">
                     <p class="notep1">Note:</p>
                     <p>The server and background processes do not reside <span class="italic">within</span> the SGA, but exist in a separate memory space.
                     </p>
                  </div>
                  <p>All server processes that execute on behalf of users can read information in the instance SGA. Several processes write to the SGA during database operation.</p>
                  <p>Each database instance has its own SGA. Oracle Database automatically allocates memory for an SGA at instance startup and reclaims the memory at instance shutdown. When you start an instance with SQL*Plus or Oracle Enterprise Manager, the size of the SGA is shown as in the following example:</p><pre class="pre codeblock"><code>SQL&gt; STARTUP
ORACLE instance started.
 
Total System Global Area  368283648 bytes
Fixed Size                  1300440 bytes
Variable Size             343935016 bytes
Database Buffers           16777216 bytes
Redo Buffers                6270976 bytes
Database mounted.
Database opened.
</code></pre><p>As shown in <a href="memory-architecture.html#GUID-02378E7A-865B-456B-8725-1E73D16A34BE__CHDHAHIJ">Figure 14-1</a>, the SGA consists of several memory components, which are pools of memory used to satisfy a particular class of memory allocation requests. All SGA components except the redo log buffer allocate and deallocate space in units of contiguous memory called <span class="italic">granules</span>. Granule size is platform-specific and is determined by total SGA size.
                  </p>
                  <p>You can query the <code class="codeph">V$SGASTAT</code> view for information about SGA components.
                  </p>
                  <p>The most important SGA components are the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="memory-architecture.html#GUID-4FF66585-E469-4631-9225-29D75594CD14" title="The database buffer cache, also called the buffer cache, is the memory area that stores copies of data blocks read from data files.">Database Buffer Cache</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" title="The In-Memory Area is an optional SGA component that contains the In-Memory Column Store (IM column store).">In-Memory Area</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" title="The redo log buffer is a circular buffer in the SGA that stores redo entries describing changes made to the database.">Redo Log Buffer</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" title="The shared pool caches various types of program data.">Shared Pool</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" title="The large pool is an optional memory area intended for memory allocations that are larger than is appropriate for the shared pool.">Large Pool</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" title="The Java pool is an area of memory that stores all session-specific Java code and data within the Java Virtual Machine (JVM). This memory includes Java objects that are migrated to the Java session space at end-of-call.">Java Pool</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" title="The fixed SGA is an internal housekeeping area.">Fixed SGA</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" title="Some SGA subareas are only enabled for specific performance features.">Optional Performance-Related SGA Subareas</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73__GUID-F5E90AF3-0D70-400E-A85F-24BC049AA484">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="oracle-database-instance.html#GUID-2942B648-70FA-47B4-8950-0CC6884B1F80" title="A database instance is a set of memory structures that manage database files.">Introduction to the Oracle Database Instance</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="../tgdba/tuning-system-global-area.html#GUID-8059B22B-0F5F-4492-A6D0-256E6FDF1E59" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn more about granule sizing
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT1222"></a><div class="props_rev_3"><a id="GUID-4FF66585-E469-4631-9225-29D75594CD14" name="GUID-4FF66585-E469-4631-9225-29D75594CD14"></a><h4 id="CNCPT-GUID-4FF66585-E469-4631-9225-29D75594CD14" class="sect4">Database Buffer Cache</h4>
                  <div>
                     <p>The <span class="bold">database buffer cache</span>, also called the <span class="italic">buffer cache</span>, is the memory area that stores copies of data blocks read from data files. 
                     </p>
                     <p>A <a href="glossary.html#GUID-F789350A-9B90-4361-9BEF-68DECB15E755"><span class="xrefglossterm">buffer</span></a> is a main memory address in which the buffer manager temporarily caches a currently or recently used data block. All users concurrently connected to a database instance share access to the buffer cache.
                     </p>
                  </div><a id="CNCPT94670"></a><div class="props_rev_3"><a id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9" name="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9"></a><h5 id="CNCPT-GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9" class="sect5">Purpose of the Database Buffer Cache</h5>
                     <div>
                        <p>Oracle Database uses the buffer cache to achieve multiple goals.</p>
                        <p>The goals include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Optimize physical I/O</p>
                              <p>The database updates data blocks in the cache and stores metadata about the changes in the redo log buffer. After a <code class="codeph">COMMIT</code>, the database writes the redo buffers to the online redo log but does not immediately write data blocks to the data files. Instead, <a href="glossary.html#GUID-C27AAA54-E60B-49BC-AB04-7B3848EBAFD6"><span class="xrefglossterm">database writer (DBW)</span></a> performs lazy writes in the background.
                              </p>
                           </li>
                           <li>
                              <p>Keep frequently accessed blocks in the buffer cache and write infrequently accessed blocks to disk</p>
                              <p>When Database Smart Flash Cache (flash cache) is enabled, part of the buffer cache can reside in the flash cache. This buffer cache extension is stored on one or more flash disk devices, which are solid state storage devices that uses flash memory. The database can improve performance by caching buffers in flash memory instead of reading from magnetic disk.</p>
                              <p>Use the <code class="codeph">DB_FLASH_CACHE_FILE</code> and <code class="codeph">DB_FLASH_CACHE_SIZE</code> initialization parameters to configure multiple flash devices. The buffer cache tracks each device and distributes buffers to the devices uniformly.
                              </p>
                              <div class="infoboxnote" id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9__GUID-DF24B739-1B05-425C-914A-C12DA376E428">
                                 <p class="notep1">Note:</p>
                                 <p>Database Smart Flash Cache is available only in Solaris and Oracle Linux.</p>
                              </div>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9__GUID-5D8D8F72-76B0-4580-B6CD-4185F629F7DC">
                           <p class="notep1">See Also:</p>
                           <p><a href="../refrn/DB_FLASH_CACHE_FILE.html#REFRN10315" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">DB_FLASH_CACHE_FILE</code> initialization parameter
                           </p>
                        </div>
                     </div>
                  </div><a id="CNCPT1223"></a><div class="props_rev_3"><a id="GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85" name="GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85"></a><h5 id="CNCPT-GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85" class="sect5">Buffer States</h5>
                     <div>
                        <p>The database uses internal algorithms to manage buffers in the cache.</p>
                        <p>A buffer can be in any of the following mutually exclusive states:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Unused</p>
                              <p>The buffer is available for use because it has never been used or is currently unused. This type of buffer is the easiest for the database to use.</p>
                           </li>
                           <li>
                              <p>Clean</p>
                              <p>This buffer was used earlier and now contains a read-consistent version of a block as of a point in time. The block contains data but is "clean" so it does not need to be checkpointed. The database can pin the block and reuse it.</p>
                           </li>
                           <li>
                              <p>Dirty</p>
                              <p>The buffer contain modified data that has not yet been written to disk. The database must checkpoint the block before reusing it.</p>
                           </li>
                        </ul>
                        <p>Every buffer has an access mode: pinned or free (unpinned). A buffer is "pinned" in the cache so that it does not age out of memory while a user session accesses it. Multiple sessions cannot modify a pinned buffer at the same time.</p>
                     </div>
                  </div><a id="CNCPT89169"></a><div class="props_rev_3"><a id="GUID-23325842-C7CB-4939-8698-FD52F36A564C" name="GUID-23325842-C7CB-4939-8698-FD52F36A564C"></a><h5 id="CNCPT-GUID-23325842-C7CB-4939-8698-FD52F36A564C" class="sect5">Buffer Modes</h5>
                     <div>
                        <p>When a client requests data, Oracle Database retrieves buffers from the database buffer cache in either current mode or consistent mode.</p>
                        <p>The modes differ as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Current mode</p>
                              <p>A <a href="glossary.html#GUID-FEFF09C7-3935-4DA6-B85B-BB1350B79C14"><span class="xrefglossterm">current mode get</span></a>, also called a <span class="italic">db block get</span>, is a retrieval of a block as it currently appears in the buffer cache. For example, if an uncommitted transaction has updated two rows in a block, then a current mode get retrieves the block with these uncommitted rows. The database uses db block gets most frequently during modification statements, which must update only the current version of the block.
                              </p>
                           </li>
                           <li>
                              <p>Consistent mode</p>
                              <p>A <a href="glossary.html#GUID-F881B50F-FA19-48CB-B512-05841067F42C"><span class="xrefglossterm">consistent read get</span></a> is a retrieval of a read-consistent version of a block. This retrieval may use <a href="glossary.html#GUID-297B963A-989C-4720-B061-A2352FF72892"><span class="xrefglossterm">undo data</span></a>. For example, if an uncommitted transaction has updated two rows in a block, and if a query in a separate session requests the block, then the database uses undo data to create a read-consistent version of this block (called a <span class="italic">consistent read clone</span>) that does not include the uncommitted updates. Typically, a query retrieves blocks in consistent mode.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-23325842-C7CB-4939-8698-FD52F36A564C__GUID-75EAE1D6-73F7-4680-92ED-FC3510455A44">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="data-concurrency-and-consistency.html#GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1" title="To manage the multiversion read consistency model, the database must create a read-consistent set of data when a table is simultaneously queried and updated.">Read Consistency and Undo Segments</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/statistics-descriptions.html#REFRN103" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for descriptions of database statistics such as db block get and consistent read get
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT89146"></a><div class="props_rev_3"><a id="GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53" name="GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53"></a><h5 id="CNCPT-GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53" class="sect5">Buffer I/O</h5>
                     <div>
                        <p>A <span class="bold">logical I/O</span>, also known as a <span class="italic">buffer I/O</span>, refers to reads and writes of buffers in the buffer cache.
                        </p>
                        <p>When a requested buffer is not found in memory, the database performs a physical I/O to copy the buffer from either the flash cache or disk into memory. The database then performs a logical I/O to read the cached buffer.</p>
                     </div><a id="CNCPT94671"></a><div class="props_rev_3"><a id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18" name="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18"></a><h6 id="CNCPT-GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18" class="sect6">Buffer Replacement Algorithms</h6>
                        <div>
                           <p>To make buffer access efficient, the database must decide which buffers to cache in memory, and which to access from disk.</p>
                           <p>The database uses the following algorithms:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>LRU-based, block-level replacement algorithm </p>
                                 <p>This sophisticated algorithm, which is the default, uses a least recently used (LRU) list that contains pointers to dirty and non-dirty buffers. The LRU list has a hot end and cold end. A <a href="glossary.html#GUID-B427531D-6550-4071-A0C2-C46BAE6680A1"><span class="xrefglossterm">cold buffer</span></a> is a buffer that has not been recently used. A <a href="glossary.html#GUID-6CBD65A1-DC66-44DF-B642-42EC36FE4984"><span class="xrefglossterm">hot buffer</span></a> is frequently accessed and has been recently used. Conceptually, there is only one LRU, but for <a href="glossary.html#GUID-D7E696DB-944C-4798-B70D-5C2381FE971F"><span class="xrefglossterm">data concurrency</span></a> the database actually uses several LRUs.
                                 </p>
                              </li>
                              <li>
                                 <p>Temperature-based, object-level replacement algorithm</p>
                                 <p>Starting in <span>Oracle Database 12c</span> Release 1 (12.1.0.2), the automatic big table caching feature enables table scans to use a different algorithm in the following scenarios:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Parallel queries</p>
                                       <p>In single-instance and Oracle Real Applications Cluster (Oracle RAC) databases, parallel queries can use the big table cache when the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter is set to a nonzero value, and <code class="codeph">PARALLEL_DEGREE_POLICY</code> is set to <code class="codeph">auto</code> or <code class="codeph">adaptive</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>Serial queries</p>
                                       <p>In a single-instance configuration only, serial queries can use the big table cache when the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter is set to a nonzero value.
                                       </p>
                                    </li>
                                 </ul>
                                 <p>When a table does not fit in memory, the database decides which buffers to cache based on access patterns. For example, if only 95% of a popular table fits in memory, then the database may choose to leave 5% of the blocks on disk rather than cyclically reading blocks into memory and writing blocks to disk—a phenomenon known as <span class="italic">thrashing</span>. When caching multiple large objects, the database considers more popular tables hotter and less popular tables cooler, which influences which blocks are cached. The <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter sets the percentage of the buffer cache that uses this algorithm.
                                 </p>
                                 <div class="infoboxnote" id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18__GUID-539C4682-EEF5-4D5E-BF16-1CC4E2C31F35">
                                    <p class="notep1">Note:</p>
                                    <p>This document explains the LRU-based, block level replacement algorithm.</p>
                                 </div>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18__GUID-81A18A9C-DC96-4371-B334-B03D1A960F9E">
                              <p class="notep1">See Also:</p>
                              <p><a href="../vldbg/inmemory-parallel-exec.html#GUID-A553169D-C6CD-443E-88C3-B746D5E32923" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn more about the temperature-based algorithm
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT89074"></a><div class="props_rev_3"><a id="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019" name="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019"></a><h6 id="CNCPT-GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019" class="sect6">Buffer Writes</h6>
                        <div>
                           <p>The <span class="bold">database writer (DBW)</span> process periodically writes cold, dirty buffers to disk. 
                           </p>
                           <p>DBW writes buffers in the following circumstances:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>A server process cannot find clean buffers for reading new blocks into the database buffer cache.</p>
                                 <p>As buffers are dirtied, the number of free buffers decreases. If the number drops below an internal threshold, and if clean buffers are required, then server processes signal DBW to write.</p>
                                 <p>The database uses the LRU to determine which dirty buffers to write. When dirty buffers reach the cold end of the LRU, the database moves them off the LRU to a write queue. DBW writes buffers in the queue to disk, using multiblock writes if possible. This mechanism prevents the end of the LRU from becoming clogged with dirty buffers and allows clean buffers to be found for reuse.</p>
                              </li>
                              <li>
                                 <p>The database must advance the <a href="glossary.html#GUID-95DBDA37-4C57-444F-B660-D52B4A99D919"><span class="xrefglossterm">checkpoint</span></a>, which is the position in the redo thread from which <a href="glossary.html#GUID-FFDBC27D-CE99-49C7-8BB9-C8C2D8D52801"><span class="xrefglossterm">instance recovery</span></a> must begin.
                                 </p>
                              </li>
                              <li>
                                 <p>Tablespaces are changed to read-only status or taken offline.</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019__GUID-91053C0C-FEEA-4F87-AFA0-ABC3F0E4930D">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="process-architecture.html#GUID-DC9CBDED-3978-450A-9D7A-0A94CE8FF233" title="The database writer process (DBW) writes the contents of database buffers to data files. DBW processes write modified buffers in the database buffer cache to disk.">Database Writer Process (DBW)</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-F2D11BC8-986F-4A8B-A37F-530BE9EB2DA8" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to diagnose and tune buffer write issues
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT89177"></a><a id="CNCPT89073"></a><div class="props_rev_3"><a id="GUID-57D00A42-6C41-4655-A268-691E84158294" name="GUID-57D00A42-6C41-4655-A268-691E84158294"></a><h6 id="CNCPT-GUID-57D00A42-6C41-4655-A268-691E84158294" class="sect6">Buffer Reads</h6>
                        <div>
                           <p>When the number of unused buffers is low, the database must remove buffers from the buffer cache.</p>
                           <p>The algorithm depends on whether the flash cache is enabled:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Flash cache disabled</p>
                                 <p>The database re-uses each clean buffer as needed, overwriting it. If the overwritten buffer is needed later, then the database must read it from magnetic disk.</p>
                              </li>
                              <li>
                                 <p>Flash cache enabled</p>
                                 <p>DBW can write the body of a clean buffer to the flash cache, enabling reuse of its in-memory buffer. The database keeps the buffer header in an LRU list in main memory to track the state and location of the buffer body in the flash cache. If this buffer is needed later, then the database can read it from the flash cache instead of from magnetic disk.</p>
                              </li>
                           </ul>
                           <p>When a client process requests a buffer, the server process searches the buffer cache for the buffer. A cache hit occurs if the database finds the buffer in memory. The search order is as follows:</p>
                           <ol>
                              <li>
                                 <p>The server process searches for the whole buffer in the buffer cache.</p>
                                 <p>If the process finds the whole buffer, then the database performs a <a href="glossary.html#GUID-267C24F9-BB8A-4D14-8513-0D7DC97D8F8D"><span class="xrefglossterm">logical read</span></a> of this buffer.
                                 </p>
                              </li>
                              <li>
                                 <p>The server process searches for the buffer header in the flash cache LRU list.</p>
                                 <p>If the process finds the buffer header, then the database performs an optimized physical read of the buffer body from the flash cache into the in-memory cache.</p>
                              </li>
                              <li>
                                 <p>If the process does <span class="italic">not</span> find the buffer in memory (a cache miss), then the server process performs the following steps:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>Copies the block from a data file on disk into memory (a physical read)</p>
                                    </li>
                                    <li>
                                       <p>Performs a logical read of the buffer that was read into memory</p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                           <p><a href="memory-architecture.html#GUID-57D00A42-6C41-4655-A268-691E84158294__BGBHEHBG">Figure 14-6</a> illustrates the buffer search order. The extended buffer cache includes both the in-memory buffer cache, which contains whole buffers, and the flash cache, which contains buffer bodies. In the figure, the database searches for a buffer in the buffer cache and, not finding the buffer, reads it into memory from magnetic disk.
                           </p>
                           <div class="figure" id="GUID-57D00A42-6C41-4655-A268-691E84158294__BGBHEHBG">
                              <p class="titleinfigure">Figure 14-6 Buffer Search</p><img src="img/cncpt304.gif" alt="Description of Figure 14-6 follows" title="Description of Figure 14-6 follows" longdesc="img_text/cncpt304.html"><br><a href="img_text/cncpt304.html">Description of "Figure 14-6 Buffer Search"</a></div>
                           <!-- class="figure" -->
                           <p>In general, accessing data through a cache hit is faster than through a cache miss. The <a href="glossary.html#GUID-51C6BAE1-58AA-4C6A-9FC3-5C4014DB2470"><span class="xrefglossterm">buffer cache hit ratio</span></a> measures how often the database found a requested block in the buffer cache without needing to read it from disk.
                           </p>
                           <p>The database can perform physical reads from either a data file or a <a href="glossary.html#GUID-5760E541-E0BB-4246-A423-E725E599A9D0"><span class="xrefglossterm">temp file</span></a>. Reads from a data file are followed by logical I/Os. Reads from a temp file occur when insufficient memory forces the database write data to a <a href="glossary.html#GUID-41501962-A37B-4D37-BAF2-59030048FE08"><span class="xrefglossterm">temporary table</span></a> and read it back later. These physical reads bypass the buffer cache and do not incur a logical I/O.
                           </p>
                           <div class="infoboxnotealso" id="GUID-57D00A42-6C41-4655-A268-691E84158294__GUID-35576A87-8C40-4FE3-B68B-F7F4988B2D69">
                              <p class="notep1">See Also:</p>
                              <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to calculate the buffer cache hit ratio
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT9833"></a><div class="props_rev_3"><a id="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2" name="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2"></a><h6 id="CNCPT-GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2" class="sect6">Buffer Touch Counts</h6>
                        <div>
                           <p>The database measures the frequency of access of buffers on the LRU list using a touch count. This mechanism enables the database to increment a counter when a buffer is pinned instead of constantly shuffling buffers on the LRU list.</p>
                           <div class="infoboxnote" id="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2__GUID-33BCEE66-99EC-4B9F-A4D8-13BF66B5E28C">
                              <p class="notep1">Note:</p>
                              <p>The database does not physically move blocks in memory. The movement is the change in location of a pointer on a list.</p>
                           </div>
                           <p>When a buffer is pinned, the database determines when its touch count was last incremented. If the count was incremented over three seconds ago, then the count is incremented; otherwise, the count stays the same. The three-second rule prevents a burst of pins on a buffer counting as many touches. For example, a session may insert several rows in a data block, but the database considers these inserts as one touch.</p>
                           <p>If a buffer is on the cold end of the LRU, but its touch count is high, then the buffer moves to the hot end. If the touch count is low, then the buffer ages out of the cache.</p>
                        </div>
                     </div>
                  </div><a id="CNCPT89072"></a><a id="CNCPT9832"></a><div class="props_rev_3"><a id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437" name="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437"></a><h5 id="CNCPT-GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437" class="sect5">Buffer Pools</h5>
                     <div>
                        <p>A <strong class="term">buffer pool</strong> is a collection of buffers.
                        </p>
                        <p>The database buffer cache is divided into one or more buffer pools, which manage blocks in mostly the same way. The pools do not have radically different algorithms for aging or caching blocks.</p>
                        <p>You can manually configure separate buffer pools that either keep data in the buffer cache or make the buffers available for new data immediately after using the data blocks. You can then assign specific schema objects to the appropriate buffer pool to control how blocks age out of the cache. For example, you can segregate segments into hot, warm, and cold buffer pools.</p>
                        <p>The possible buffer pools are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Default pool</p>
                              <p>This pool is the location where blocks are normally cached. Unless you manually configure separate pools, the default pool is the only buffer pool. The optional configuration of the other pools has no effect on the default pool.</p>
                              <p>Starting in <span>Oracle Database 12c</span> Release 1 (12.1.0.2), the <a href="glossary.html#GUID-46A51ED5-DC39-47B0-9592-81C56414487B"><span class="xrefglossterm">big table cache</span></a> is an optional section of the default pool that uses a temperature-based, object-level replacement algorithm. In single-instance and Oracle RAC databases, parallel queries can use the big table cache when the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter is set to a nonzero value, and <code class="codeph">PARALLEL_DEGREE_POLICY</code> is set to <code class="codeph">auto</code> or <code class="codeph">adaptive</code>. In single-instance configurations only, serial queries can use the big table cache when <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> is set.
                              </p>
                           </li>
                           <li>
                              <p>Keep pool</p>
                              <p>This pool is intended for blocks that were accessed frequently, but which aged out of the default pool because of lack of space. The purpose of the keep buffer pool is to retain objects in memory, thus avoiding I/O operations.</p>
                              <div class="infoboxnote" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__GUID-F208A310-95A3-4D07-B76F-451F26EC93D4">
                                 <p class="notep1">Note:</p>
                                 <p> The keep pool manages buffers in the same way as the other pools: it does not use a special algorithm to pin buffers. The word "keep" is a naming convention. You can place tables that you want to keep in the larger keep pool, and place tables that you do not want to keep in the smaller recycle pool.</p>
                              </div>
                           </li>
                           <li>
                              <p>Recycle pool</p>
                              <p>This pool is intended for blocks that are used infrequently. A recycle pool prevent objects from consuming unnecessary space in the cache.</p>
                           </li>
                        </ul>
                        <p>A database has a standard block size. You can create a tablespace with a block size that differs from the standard size. Each nondefault block size has its own pool. Oracle Database manages the blocks in these pools in the same way as in the default pool.</p>
                        <p>The following figure shows the structure of the buffer cache when multiple pools are used. The cache contains default, keep, and recycle pools. The default block size is 8 KB. The cache contains separate pools for tablespaces that use the nonstandard block sizes of 2 KB, 4 KB, and 16 KB.</p>
                        <div class="figure" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__BGBBEBCH">
                           <p class="titleinfigure">Figure 14-7 Database Buffer Cache</p><img src="img/cncpt220.gif" alt="Description of Figure 14-7 follows" title="Description of Figure 14-7 follows" longdesc="img_text/cncpt220.html"><br><a href="img_text/cncpt220.html">Description of "Figure 14-7 Database Buffer Cache"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__GUID-C89B5770-2DFC-46B4-90D9-1FBB1763A7D1">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="logical-storage-structures.html#GUID-39B58094-478C-4DD9-8419-504439F4E8F7" title="Every database has a database block size.">Database Block Size</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-memory.html#ADMIN11222" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn more about buffer pools
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/tuning-database-buffer-cache.html#TGDBA315" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to use multiple buffer pools
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/DB_BIG_TABLE_CACHE_PERCENT_TARGET.html#GUID-122865EE-4589-434D-8DD5-4E201C6CC739" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1224"></a><div class="props_rev_3"><a id="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3" name="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3"></a><h5 id="CNCPT-GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3" class="sect5">Buffers and Full Table Scans</h5>
                     <div>
                        <p>The database uses a complicated algorithm to manage table scans. By default, when buffers must be read from disk, the database inserts the buffers into the middle of the LRU list. In this way, hot blocks can remain in the cache so that they do not need to be read from disk again.</p>
                        <p>A problem is posed by a <a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a>, which sequentially reads all rows under the table <a href="glossary.html#GUID-F3F5ACB2-94C8-483F-B427-1981836D0609"><span class="xrefglossterm">high water mark (HWM)</span></a>. Suppose that the total size of the blocks in a table segment is greater than the size of the buffer cache. A full scan of this table could clean out the buffer cache, preventing the database from maintaining a cache of frequently accessed blocks.
                        </p>
                        <div class="infoboxnotealso" id="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3__GUID-63FA5FB5-B7CA-42F1-AC89-AE0757F648CC">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" title="To manage space, Oracle Database tracks the state of blocks in the segment. The high water mark (HWM) is the point in a segment beyond which data blocks are unformatted and have never been used.">Segment Space and the High Water Mark</a>"</span></p>
                        </div>
                     </div><a id="CNCPT94672"></a><div class="props_rev_3"><a id="GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57" name="GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57"></a><h6 id="CNCPT-GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57" class="sect6">Default Mode for Full Table Scans</h6>
                        <div>
                           <p>By default, the database takes a conservative approach to full table scans, loading a small table into memory only when the table size is a small percentage of the buffer cache.</p>
                           <p>To determine whether medium sized tables should be cached, the database uses an algorithm that incorporates the interval between the last table scan, the aging timestamp of the buffer cache, and the space remaining in the buffer cache.</p>
                           <p>For very large tables, the database typically uses a <a href="glossary.html#GUID-F824D5F8-5826-48F6-AB0D-7855B73BFB4B"><span class="xrefglossterm">direct path read</span></a>, which loads blocks directly into the PGA and bypasses the SGA altogether, to avoid populating the buffer cache. For medium size tables, the database may use a direct read or a cache read. If it decides to use a cache read, then the database places the blocks at the end of the LRU list to prevent the scan from effectively cleaning out the buffer cache.
                           </p>
                           <p>Starting in <span>Oracle Database 12c</span> Release 1 (12.1.0.2), the buffer cache of a database instance automatically performs an internal calculation to determine whether memory is sufficient for the database to be fully cached in the instance SGA, and if caching tables on access would be beneficial for performance. If the whole database can fully fit in memory, and if various other internal criteria are met, then Oracle Database treats all tables in the database as small tables, and considers them eligible for caching. However, the database does not cache LOBs marked with the <code class="codeph">NOCACHE</code> attribute.
                           </p>
                        </div>
                     </div><a id="CNCPT94667"></a><div class="props_rev_3"><a id="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1" name="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1"></a><h6 id="CNCPT-GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1" class="sect6">Parallel Query Execution</h6>
                        <div>
                           <p>When performing a full table scan, the database can sometimes improve response time by using multiple parallel execution servers. </p>
                           <p>In some cases, as when the database has a large amount of memory, the database can cache parallel query data in the system global area (SGA) instead of using direct path reads into the program global area (PGA). Typically, parallel queries occur in low-concurrency data warehouses because of the potential resource usage.</p>
                           <div class="infoboxnotealso" id="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1__GUID-CD90D906-005C-404A-B565-74C3E67BCA79">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../dwhsg/introduction-data-warehouse-concepts.html#GUID-452FBA23-6976-4590-AA41-1369647AD14D" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for an introduction to data warehouses
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn more about parallel execution
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT94673"></a><div class="props_rev_3"><a id="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A" name="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A"></a><h6 id="CNCPT-GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A" class="sect6">CACHE Attribute</h6>
                        <div>
                           <p>In the rare case where the default caching behavior is not desired, you can use <code class="codeph">ALTER TABLE ... CACHE</code> to change how blocks from large tables are read into the database buffer cache.
                           </p>
                           <p>For tables with the <code class="codeph">CACHE</code> attribute set, the database does not force or pin the blocks in the buffer cache. Instead, the database ages the blocks out of the cache in the same way as any other table block. Use care when exercising this option because a full scan of a large table may clean most of the other blocks out of the cache.
                           </p>
                           <div class="infoboxnote" id="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A__GUID-72A80A37-B8D9-44A1-BB73-D2A1530840E9">
                              <p class="notep1">Note:</p>
                              <p>Executing <code class="codeph">ALTER TABLE ... CACHE</code> does not <span class="italic">cause</span> a table to be cached.
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT94674"></a><div class="props_rev_3"><a id="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58" name="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58"></a><h6 id="CNCPT-GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58" class="sect6">KEEP Attribute</h6>
                        <div>
                           <p>For large tables, you can use <code class="codeph">ALTER TABLE ... STORAGE BUFFER_POOL KEEP</code> to cause scans to load blocks for these tables into the keep pool. 
                           </p>
                           <p>Placing a table into the keep pool changes the part of the buffer cache where the blocks are stored. Instead of caching blocks in the default buffer pool, the database caches them in the keep buffer pool. No separate algorithm controls keep pool caching.</p>
                           <div class="infoboxnotealso" id="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58__GUID-CA23C813-940F-4DE8-BBF0-C646FB1FA9EF">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF54597" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code class="codeph">CACHE</code> clause and the <code class="codeph">KEEP</code> attribute
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to learn how to interpret buffer cache advisory statistics
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT94675"></a><div class="props_rev_3"><a id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48" name="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48"></a><h6 id="CNCPT-GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48" class="sect6">Force Full Database Caching Mode</h6>
                        <div>
                           <p>To improve performance in some situations, you can explicitly execute the <code class="codeph">ALTER DATABASE ... FORCE FULL DATABASE CACHING</code> statement to enable the <strong class="term">force full database caching mode</strong>.
                           </p>
                           <p>In contrast to the default mode, which is automatic, the force full database caching mode considers the entire database, including <code class="codeph">NOCACHE</code> LOBs, as eligible for caching in the database buffer cache. This mode is available starting in <span>Oracle Database 12c</span> Release 1 (12.1.0.2).
                           </p>
                           <div class="infoboxnote" id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48__GUID-9C27C724-D24F-418C-A05C-9988F457051B">
                              <p class="notep1">Note:</p>
                              <p>Enabling force full database caching mode does <span class="italic">not</span> force the database into memory. Rather, the entire database is <span class="italic">eligible</span> to be cached in the buffer cache. Oracle Database caches tables only when they are accessed.
                              </p>
                           </div>
                           <p>Oracle recommends that you enable force full database caching mode only when the buffer cache size of each individual instance is greater than the database size. This guideline applies to both single-instance and Oracle RAC databases. However, when Oracle RAC applications are well partitioned, you can enable force full database caching mode when the combined buffer cache of all instances, with extra space to handle duplicate cached blocks between instances, is greater than the database size.</p>
                           <div class="infoboxnotealso" id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48__GUID-3A7D5C4C-5206-4E6A-84E0-9B3B12F58900">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../admin/managing-memory.html#ADMIN14237" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to enable force full database caching mode
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/ALTER-DATABASE.html#SQLRF56678" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information about <code class="codeph">ALTER DATABASE ... FORCE FULL DATABASE CACHING</code> statement
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89075"></a><a id="CNCPT1225"></a><div class="props_rev_3"><a id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" name="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B"></a><h4 id="CNCPT-GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" class="sect4">Redo Log Buffer </h4>
                  <div>
                     <p>The <span class="bold">redo log buffer</span> is a circular buffer in the SGA that stores redo entries describing changes made to the database.
                     </p>
                     <p>A <a href="glossary.html#GUID-F73D3BEC-7C9E-4BE0-A30F-D7E1DA4F217A"><span class="xrefglossterm">redo record</span></a> is a data structure that contains the information necessary to reconstruct, or redo, changes made to the database by DML or DDL operations. Database recovery applies redo entries to data files to reconstruct lost changes.
                     </p>
                     <p>The database processes copy redo entries from the user memory space to the redo log buffer in the SGA. The redo entries take up continuous, sequential space in the buffer. The background process <a href="glossary.html#GUID-E96BC851-0B78-4250-8EAB-26EBDF4FE5A6"><span class="xrefglossterm">log writer process (LGWR)</span></a> writes the redo log buffer to the active online redo log group on disk. <a href="memory-architecture.html#GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__BGBFDAHB">Figure 14-8</a> shows this redo buffer activity.
                     </p>
                     <div class="figure" id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__BGBFDAHB">
                        <p class="titleinfigure">Figure 14-8 Redo Log Buffer</p><img src="img/cncpt226.gif" alt="Description of Figure 14-8 follows" title="Description of Figure 14-8 follows" longdesc="img_text/cncpt226.html"><br><a href="img_text/cncpt226.html">Description of "Figure 14-8 Redo Log Buffer"</a></div>
                     <!-- class="figure" -->
                     <p>LGWR writes redo sequentially to disk while DBW performs scattered writes of data blocks to disk. Scattered writes tend to be much slower than sequential writes. Because LGWR enable users to avoid waiting for DBW to complete its slow writes, the database delivers better performance.</p>
                     <p>The <code class="codeph">LOG_BUFFER</code> initialization parameter specifies the amount of memory that Oracle Database uses when buffering redo entries. Unlike other SGA components, the redo log buffer and fixed SGA buffer do not divide memory into granules.
                     </p>
                     <div class="infoboxnotealso" id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__GUID-C0180021-8641-4BF3-A2D9-D5A28C4AF40F">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="process-architecture.html#GUID-B6BE2C31-1543-4504-9763-6FFBBF99DC85" title="The log writer process (LGWR) manages the online redo log buffer.">Log Writer Process (LGWR)</a>"</span> and <span class="q">"<a href="oracle-database-instance.html#GUID-19F515DA-AA77-4138-853B-1C41A759D76E" title="Instance recovery uses checkpoints to determine which changes must be applied to the data files. The checkpoint position guarantees that every committed change with an SCN lower than the checkpoint SCN is saved to the data files.">Importance of Checkpoints for Instance Recovery</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-the-redo-log.html#ADMIN11302" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for information about the online redo log
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT89076"></a><a id="CNCPT1226"></a><div class="props_rev_3"><a id="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" name="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6"></a><h4 id="CNCPT-GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" class="sect4">Shared Pool</h4>
                  <div>
                     <p>The <span class="bold">shared pool</span> caches various types of program data.
                     </p>
                     <p>For example, the shared pool stores parsed SQL, PL/SQL code, system parameters, and <a href="glossary.html#GUID-D6A3934F-BA6D-464F-9612-C683E20514A4"><span class="xrefglossterm">data dictionary</span></a> information. The shared pool is involved in almost every operation that occurs in the database. For example, if a user executes a SQL statement, then Oracle Database accesses the shared pool.
                     </p>
                     <p>The shared pool is divided into several subcomponents, the most important of which are shown in <a href="memory-architecture.html#GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6__BGBIAJIG">Figure 14-9</a>.
                     </p>
                     <div class="figure" id="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6__BGBIAJIG">
                        <p class="titleinfigure">Figure 14-9 Shared Pool</p><img src="img/cncpt225.gif" alt="Description of Figure 14-9 follows" title="Description of Figure 14-9 follows" longdesc="img_text/cncpt225.html"><br><a href="img_text/cncpt225.html">Description of "Figure 14-9 Shared Pool"</a></div>
                     <!-- class="figure" -->
                     <p>This section includes the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="memory-architecture.html#GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" title="The library cache is a shared pool memory structure that stores executable SQL and PL/SQL code.">Library Cache</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-66430838-7862-4389-96B5-795B99A72473" title="The data dictionary is a collection of database tables and views containing reference information about the database, its structures, and its users.">Data Dictionary Cache</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-675AAFFB-E915-4197-8159-C0CF1C009973" title="The server result cache is a memory pool within the shared pool. Unlike the buffer pools, the server result cache holds result sets and not data blocks.">Server Result Cache</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" title="The reserved pool is a memory area in the shared pool that Oracle Database can use to allocate large contiguous chunks of memory.">Reserved Pool</a></p>
                        </li>
                     </ul>
                  </div><a id="CNCPT1227"></a><div class="props_rev_3"><a id="GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" name="GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0"></a><h5 id="CNCPT-GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" class="sect5">Library Cache</h5>
                     <div>
                        <p>The <span class="bold">library cache</span> is a shared pool memory structure that stores executable SQL and PL/SQL code.
                        </p>
                        <p>This cache contains the shared SQL and PL/SQL areas and control structures such as locks and library cache handles. In a shared server architecture, the library cache also contains private SQL areas.</p>
                        <p>When a SQL statement is executed, the database attempts to reuse previously executed code. If a parsed representation of a SQL statement exists in the library cache and can be shared, then the database reuses the code, known as a <a href="glossary.html#GUID-A9D78636-6F7B-472B-8AC6-4B07C775DE00"><span class="xrefglossterm">soft parse</span></a> or a <span class="italic">library cache hit</span>. Otherwise, the database must build a new executable version of the application code, known as a <a href="glossary.html#GUID-1BFB2AF7-BC88-4A93-B9AA-C75CA62C5824"><span class="xrefglossterm">hard parse</span></a> or a <span class="italic">library cache miss</span>.
                        </p>
                     </div><a id="CNCPT89077"></a><a id="CNCPT1228"></a><div class="props_rev_3"><a id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" name="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8"></a><h6 id="CNCPT-GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" class="sect6">Shared SQL Areas</h6>
                        <div>
                           <p>The database represents each SQL statement that it runs in the shared SQL area and private SQL area.</p>
                           <p>The database uses the shared SQL area to process the first occurrence of a SQL statement. This area is accessible to all users and contains the statement parse tree and <a href="glossary.html#GUID-2DF33B85-94BB-44F3-93B7-06916FB18361"><span class="xrefglossterm">execution plan</span></a>. Only one shared SQL area exists for a unique statement. Each session issuing a SQL statement has a private SQL area in its PGA. Each user that submits the same statement has a private SQL area pointing to the same shared SQL area. Thus, many private SQL areas in separate PGAs can be associated with the same shared SQL area.
                           </p>
                           <p>The database automatically determines when applications submit similar SQL statements. The database considers both SQL statements issued directly by users and applications and recursive SQL statements issued internally by other statements. </p>
                           <p>The database performs the following steps:</p>
                           <ol>
                              <li>
                                 <p>Checks the shared pool to see if a shared SQL area exists for a syntactically and semantically identical statement:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>If an identical statement exists, then the database uses the shared SQL area for the execution of the subsequent new instances of the statement, thereby reducing memory consumption.</p>
                                    </li>
                                    <li>
                                       <p>If an identical statement does not exist, then the database allocates a new shared SQL area in the shared pool. A statement with the same syntax but different semantics uses a <a href="glossary.html#GUID-8230A43B-CD9B-4A64-9D59-182F747A0BD5"><span class="xrefglossterm">child cursor</span></a>.
                                       </p>
                                    </li>
                                 </ul>
                                 <p>In either case, the private SQL area for the user points to the shared SQL area that contains the statement and execution plan.</p>
                              </li>
                              <li>
                                 <p>Allocates a private SQL area on behalf of the session</p>
                                 <p>The location of the private SQL area depends on the connection established for the session. If a session is connected through a shared server, then part of the private SQL area is kept in the SGA.</p>
                              </li>
                           </ol>
                           <p><a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__BGBGFFFF">Figure 14-10</a> shows a dedicated server architecture in which two sessions keep a copy of the same SQL statement in their own PGAs. In a shared server, this copy is in the UGA, which is in the large pool or in the shared pool when no large pool exists.
                           </p>
                           <div class="figure" id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__BGBGFFFF">
                              <p class="titleinfigure">Figure 14-10 Private SQL Areas and Shared SQL Area</p><img src="img/cncpt252.gif" alt="Description of Figure 14-10 follows" title="Description of Figure 14-10 follows" longdesc="img_text/cncpt252.html"><br><a href="img_text/cncpt252.html">Description of "Figure 14-10 Private SQL Areas and Shared SQL Area"</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__GUID-9994EA56-128F-4651-95E7-0B3DFCBB0449">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="memory-architecture.html#GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" title="A private SQL area holds information about a parsed SQL statement and other session-specific information for processing.">Private SQL Area</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-shared-pool-and-large-pool.html#TGDBA562" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn more about managing the library cache
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS99965" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> for more information about shared SQL
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT1230"></a><div class="props_rev_3"><a id="GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE" name="GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE"></a><h6 id="CNCPT-GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE" class="sect6">Program Units and the Library Cache</h6>
                        <div>
                           <p>The library cache holds executable forms of PL/SQL programs and Java classes. These items are collectively referred to as <span class="italic">program units</span>.
                           </p>
                           <p>The database processes program units similarly to SQL statements. For example, the database allocates a shared area to hold the parsed, compiled form of a PL/SQL program. The database allocates a private area to hold values specific to the session that runs the program, including local, global, and package variables, and buffers for executing SQL. If multiple users run the same program, then each user maintains a separate copy of his or her private SQL area, which holds session-specific values, and accesses a single shared SQL area.</p>
                           <p>The database processes individual SQL statements within a PL/SQL program unit as previously described. Despite their origins within a PL/SQL program unit, these SQL statements use a shared area to hold their parsed representations and a private area for each session that runs the statement.</p>
                        </div>
                     </div><a id="CNCPT1232"></a><div class="props_rev_3"><a id="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F" name="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F"></a><h6 id="CNCPT-GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F" class="sect6">Allocation and Reuse of Memory in the Shared Pool</h6>
                        <div>
                           <p>The database allocates shared pool memory when a new SQL statement is parsed, unless the statement is DDL, which is not considered sharable. The size of memory allocated depends on the complexity of the statement.</p>
                           <p>In general, an item in the shared pool stays until the database removes it according to a least recently used (LRU) algorithm. The database allows shared pool items used by many sessions to remain in memory as long as they are useful, even if the database process that created the item terminates. This mechanism minimizes the overhead and processing of SQL statements. If space is needed for new items, then the database frees memory consumed by infrequently used items.</p>
                           <p>The <code class="codeph">ALTER SYSTEM FLUSH SHARED_POOL</code> statement removes all information in the shared pool, as does changing the <a href="glossary.html#GUID-2820B9D9-E349-4A2D-9BDA-E0B3BD1772D1"><span class="xrefglossterm">global database name</span></a>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F__GUID-0619567A-5B52-4AC8-8B55-4D56790AF7C3">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../tgsql/improving-rwp-cursor-sharing.html#TGSQL-GUID-E04CF45D-CC70-4122-9BAC-EAB5B4D0E17A" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> for an overview of the life cycle of a shared SQL area
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/ALTER-SYSTEM.html#SQLRF53120" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about using <code class="codeph">ALTER SYSTEM FLUSH SHARED_POOL</code></p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=REFRN30246" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for information about <code class="codeph">V$SQL</code> and <code class="codeph">V$SQLAREA</code> dynamic views
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT1231"></a><div class="props_rev_3"><a id="GUID-66430838-7862-4389-96B5-795B99A72473" name="GUID-66430838-7862-4389-96B5-795B99A72473"></a><h5 id="CNCPT-GUID-66430838-7862-4389-96B5-795B99A72473" class="sect5">Data Dictionary Cache</h5>
                     <div>
                        <p>The <strong class="term">data dictionary</strong> is a collection of database tables and views containing reference information about the database, its structures, and its users.
                        </p>
                        <p>Oracle Database accesses the data dictionary frequently during SQL statement parsing. The data dictionary is accessed so often by Oracle Database that the following special memory locations are designated to hold dictionary data:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Data dictionary cache</p>
                              <p>This cache holds information about database objects. The cache is also known as the <span class="italic">row cache</span> because it holds data as rows instead of buffers.
                              </p>
                           </li>
                           <li>
                              <p>Library cache</p>
                           </li>
                        </ul>
                        <p>All server processes share these caches for access to data dictionary information.</p>
                        <div class="infoboxnotealso" id="GUID-66430838-7862-4389-96B5-795B99A72473__GUID-92447A87-B604-414F-B9AB-D205278EB02C">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="data-dictionary-and-dynamic-performance-views.html#GUID-BDF5B748-EB43-4B48-938E-89099069C3BB" title="The central set of read-only reference tables and views of each Oracle database is known collectively as the data dictionary. The dynamic performance views are special views that are continuously updated while a database is open and in use.">Data Dictionary and Dynamic Performance Views</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA593" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to allocate additional memory to the data dictionary cache
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1919"></a><div class="props_rev_3"><a id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973" name="GUID-675AAFFB-E915-4197-8159-C0CF1C009973"></a><h5 id="CNCPT-GUID-675AAFFB-E915-4197-8159-C0CF1C009973" class="sect5">Server Result Cache</h5>
                     <div>
                        <p>The <span class="bold">server result cache</span> is a memory pool within the shared pool. Unlike the buffer pools, the server result cache holds result sets and not data blocks. 
                        </p>
                        <p>The server result cache contains the <a href="glossary.html#GUID-EAEA5633-B660-4D51-99FF-48B596750DB8"><span class="xrefglossterm">SQL query result cache</span></a> and <a href="glossary.html#GUID-9804DF97-092F-48A5-827B-67F1065ADAB3"><span class="xrefglossterm">PL/SQL function result cache</span></a>, which share the same infrastructure.
                        </p>
                        <div class="infoboxnote" id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973__GUID-423E25C2-A44B-443C-BAA8-341F7F571C8F">
                           <p class="notep1">Note:</p>
                           <p>A client result cache differs from the server result cache. A client cache is configured at the application level and is located in client memory, not in database memory.</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973__GUID-2FF2AC7A-F5D1-4995-AD57-D9F507BA14D3">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../admin/managing-memory.html#ADMIN11228" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for information about sizing the result cache
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ARPLS202" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information about the <code class="codeph">DBMS_RESULT_CACHE</code> package
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA638" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> for more information about the client result cache
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="CNCPT1920"></a><div class="props_rev_3"><a id="GUID-A778611A-E802-4D9B-A645-90CDA658D61F" name="GUID-A778611A-E802-4D9B-A645-90CDA658D61F"></a><h6 id="CNCPT-GUID-A778611A-E802-4D9B-A645-90CDA658D61F" class="sect6">SQL Query Result Cache</h6>
                        <div>
                           <p>The <span class="bold">SQL query result cache</span> is a subset of the server result cache that stores the results of queries and query fragments.
                           </p>
                           <p>Most applications benefit from this performance improvement. Consider an application that runs the same <code class="codeph">SELECT</code> statement repeatedly. If the results are cached, then the database returns them immediately. In this way, the database avoids the expensive operation of rereading blocks and recomputing results. 
                           </p>
                           <p>When a query executes, the database searches memory to determine whether the result exists in the result cache. If the result exists, then the database retrieves the result from memory instead of executing the query. If the result is not cached, then the database executes the query, returns the result as output, and then stores the result in the result cache. The database automatically invalidates a cached result whenever a transaction modifies the data or metadata of database objects used to construct that cached result.</p>
                           <p>Users can annotate a query or query fragment with a <code class="codeph">RESULT_CACHE</code> <a href="glossary.html#GUID-B2534A3C-7E63-45E3-A61F-3746124B7CCA"><span class="xrefglossterm">hint</span></a> to indicate that the database should store results in the SQL query result cache. The <code class="codeph">RESULT_CACHE_MODE</code> initialization parameter determines whether the SQL query result cache is used for all queries (when possible) or only for annotated queries.
                           </p>
                           <div class="infoboxnotealso" id="GUID-A778611A-E802-4D9B-A645-90CDA658D61F__GUID-35051DAA-5A96-42DF-92C1-CD280D4A636F">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=REFRN10270" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about the <code class="codeph">RESULT_CACHE_MODE</code> initialization parameter
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=SQLRF20004" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">RESULT_CACHE</code> hint
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT1921"></a><div class="props_rev_3"><a id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767" name="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767"></a><h6 id="CNCPT-GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767" class="sect6">PL/SQL Function Result Cache</h6>
                        <div>
                           <p>The <span class="bold">PL/SQL function result cache</span> is a subset of the server result cache that stores function result sets.
                           </p>
                           <p>Without caching, 1000 calls of a function at 1 second per call would take 1000 seconds. With caching, 1000 function calls with the same inputs could take 1 second <span class="italic">total</span>. Good candidates for result caching are frequently invoked functions that depend on relatively static data.
                           </p>
                           <p>PL/SQL function code can include a request to cache its results. Upon invocation of this function, the system checks the cache. If the cache contains the result from a previous function call with the same parameter values, then the system returns the cached result to the invoker and does not reexecute the function body. If the cache does not contain the result, then the system executes the function body and adds the result (for these parameter values) to the cache before returning control to the invoker.</p>
                           <div class="infoboxnote" id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767__GUID-A6601CDA-7D49-484C-BA32-C81129F6E79C">
                              <p class="notep1">Note:</p>
                              <p>You can specify the database objects that Oracle Database uses to compute a cached result, so that if any of them are updated, the cached result becomes invalid and must be recomputed.</p>
                           </div>
                           <p>The cache can accumulate many results—one result for every unique combination of parameter values with which each result-cached function was invoked. If the database needs more memory, then it ages out one or more cached results.</p>
                           <div class="infoboxnotealso" id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767__GUID-5C5CBFD5-A598-49EF-81F9-46F978727B7E">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADFNS333" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> to learn more about the PL/SQL function result cache
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=LNPLS00817" target="_blank"><span><cite>Oracle Database PL/SQL Language Reference</cite></span></a> to learn more about the PL/SQL function result cache
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT9835"></a><div class="props_rev_3"><a id="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" name="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8"></a><h5 id="CNCPT-GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" class="sect5">Reserved Pool</h5>
                     <div>
                        <p>The <span class="bold">reserved pool</span> is a memory area in the shared pool that Oracle Database can use to allocate large contiguous chunks of memory.
                        </p>
                        <p>The database allocates memory from the shared pool in chunks. Chunking allows large objects (over 5 KB) to be loaded into the cache without requiring a single contiguous area. In this way, the database reduces the possibility of running out of contiguous memory because of fragmentation.</p>
                        <p>Infrequently, Java, PL/SQL, or SQL cursors may make allocations out of the shared pool that are larger than 5 KB. To allow these allocations to occur most efficiently, the database segregates a small amount of the shared pool for the reserved pool.</p>
                        <div class="infoboxnotealso" id="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8__GUID-4A8B314F-BEF2-436B-AA82-10E0804A9843">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA605" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to configure the reserved pool
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89078"></a><a id="CNCPT1233"></a><div class="props_rev_3"><a id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" name="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34"></a><h4 id="CNCPT-GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" class="sect4">Large Pool</h4>
                  <div>
                     <p>The <strong class="term">large pool</strong> is an optional memory area intended for memory allocations that are larger than is appropriate for the shared pool.
                     </p>
                     <p>The large pool can provide large memory allocations for the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>UGA for the shared server and the <a href="glossary.html#GUID-4805B3F4-1858-473B-A802-3496C73CE818"><span class="xrefglossterm">Oracle XA</span></a> interface (used where transactions interact with multiple databases)
                           </p>
                        </li>
                        <li>
                           <p>Message buffers used in parallel execution</p>
                        </li>
                        <li>
                           <p>Buffers for Recovery Manager (RMAN) I/O slaves</p>
                        </li>
                        <li>
                           <p>Buffers for <span>deferred insert</span>s (inserts with the <code class="codeph">MEMOPTIMIZE_WRITE</code> hint)
                           </p>
                        </li>
                     </ul>
                     <p>The following figure depicts the large pool.</p>
                     <div class="figure" id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34__BGBDJBCF">
                        <p class="titleinfigure">Figure 14-11 Large Pool</p><img src="img/cncpt221.png" alt="Description of Figure 14-11 follows" title="Description of Figure 14-11 follows" longdesc="img_text/cncpt221.html"><br><a href="img_text/cncpt221.html">Description of "Figure 14-11 Large Pool"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34__GUID-76E7713A-12B1-4CF6-9AF9-D7C42291CC47">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="process-architecture.html#GUID-6487F7FA-2299-4428-8588-7937BD8675D3" title="In parallel execution, the server process acts as the query coordinator (also called the parallel execution coordinator).">Query Coordinator</a>"</span> for information about allocating memory for parallel execution
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="application-and-networking-architecture.html#GUID-EC8F8778-02B7-4CF9-9E6F-A5D88C777235" title="A request from a user is a single API call that is part of the user's SQL statement.">Dispatcher Request and Response Queues</a>"</span> to learn about allocating session memory for shared server
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADFNS017" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> to learn about Oracle XA
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA609" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> for more information about the large pool
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759" name="GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759"></a><h5 id="CNCPT-GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759" class="sect5">Large Pool Memory Management</h5>
                     <div>
                        <p>The large pool manages memory differently from the shared pool, which uses an LRU list so that portions of memory can age out.</p>
                        <p>The large pool does not have an LRU list. When the database allocates large pool memory to a database session, this memory is not eligible to be released unless the session releases it. As soon as a portion of memory is freed, other processes can use it. By allocating session memory from the large pool, the database avoids the fragmentation that can occur in the shared pool.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058" name="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058"></a><h5 id="CNCPT-GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058" class="sect5">Large Pool Buffers for <span>Deferred Insert</span>s
                     </h5>
                     <div>
                        <p>For a special type of insert known as a <strong class="term">deferred insert</strong>, the database allocates buffers from the large pool.
                        </p>
                        <p>For rapid “fire and forget” inserts from Internet of Things (IoT) applications, the database infrastructure creates performance overhead. For example, the code path includes buffer cache navigation, buffer pins, and concurrency protections. Array inserts minimize these costs, but the array must be built on the client side, which is not typical for Internet of Things applications. To address this issue, an Oracle application can use a hint to insert rows into a table specified as <code class="codeph">MEMOPTIMIZE FOR WRITE</code>.
                        </p>
                        <p>The inserts are deferred because they are buffered in the large pool, and then later written to disk asynchronously by background processes. The database processes <span>deferred insert</span>s as follows:
                        </p>
                        <ol>
                           <li>
                              <p>The application sends <code class="codeph">MEMOPTIMIZE_WRITE</code> inserts to a middle tier, which can aggregate the data. While an IoT application will almost always send inserts to the middle tier, it is also possible to send inserts directly to the database. For example, using SQL*Plus sends the inserts directly to the database.
                              </p>
                           </li>
                           <li>
                              <p>The middle tier writes the aggregation of inserts to the database server.</p>
                           </li>
                           <li>
                              <p>Optionally, the middle tier client retains a local copy of the data that it wrote in the previous step.</p>
                           </li>
                           <li>
                              <p>A server process writes data to a buffer or buffers in the large pool.</p>
                              <p>To avoid contention, each buffer has its own internal locking mechanism. This locking mechanism is separate from the locking mechanism that the database buffer cache uses for its buffers. The basic write process is as follows:</p>
                              <ol type="a">
                                 <li>
                                    <p>After instance startup, the first <code class="codeph">MEMOPTIMIZE_WRITE</code> insert allocates the buffers from the large pool.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The writer chooses a buffer from the list of available buffers.</p>
                                 </li>
                                 <li>
                                    <p>If the chosen buffer is not locked, and if this buffer has free space, then the client writes to the buffer, stamping each buffer write with a session-specific sequence number. If not, then the writer returns to the preceding step, and continues in this way until either a buffer is found or sufficient space has been freed in the large pool.</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>The database creates a server-side array from the buffered data.</p>
                           </li>
                           <li>
                              <p>The Space Management Coordinator (SMCO) and its helper processes (W<span class="italic">nnn</span>) write the array to disk asynchronously using the standard data block format.
                              </p>
                              <p>Unlike standard inserts, deferred inserts are automatically committed and cannot be rolled back. The database commits the inserts to a given object in the order in which they appear within a session. There is no guarantee of ordering <span class="italic">between</span> objects or sessions.
                              </p>
                              <p>The database supports constraints and index maintenance just as for regular inserts. However, the database performs evaluations during the write to disk, not the write to the large pool.</p>
                              <div class="infoboxnote" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-4C814566-52F5-49E0-A509-B0AC0BD2B6D9">
                                 <p class="notep1">Note:</p>
                                 <p>For best performance, Oracle recommends disabling constraints.</p>
                              </div>
                           </li>
                           <li>
                              <p>If a primary key violation occurs when the background processes write to the data files, then the database writes the flagged row to the trace file of the apply process.</p>
                           </li>
                        </ol>
                        <p>The following figure depicts the workflow for <span>deferred insert</span>s.
                        </p>
                        <div class="figure" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-B78B885C-D404-4887-A165-F71909DAC62B">
                           <p class="titleinfigure">Figure 14-12 <span>Deferred Insert</span> Mechanism
                           </p><img src="img/cncpt_pb_002a.png" alt="Description of Figure 14-12 follows" title="Description of Figure 14-12 follows" longdesc="img_text/cncpt_pb_002a.html"><br><a href="img_text/cncpt_pb_002a.html">Description of "Figure 14-12 Deferred Insert Mechanism"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-AC54067B-AE7F-485C-A20A-BB0113D454F6">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="data-concurrency-and-consistency.html#GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC" title="A special type of insert known as a deferred insert does not use the standard read consistency mechanism.">Read Consistency and Deferred Inserts</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA-GUID-CFADC9EA-2E2F-4EBB-BA2C-3663291DCC25" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to specify tables as <code class="codeph">MEMOPTIMIZE FOR WRITE</code></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=SQLRF-GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">INSERT</code> syntax and semantics
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=GUID-D33BB2FE-94A7-475F-B8C8-CC9AC61B502F" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1234"></a><div class="props_rev_3"><a id="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" name="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D"></a><h4 id="CNCPT-GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" class="sect4">Java Pool</h4>
                  <div>
                     <p>The <span class="bold">Java pool</span> is an area of memory that stores all session-specific Java code and data within the Java Virtual Machine (JVM). This memory includes Java objects that are migrated to the Java session space at end-of-call.
                     </p>
                     <p>For dedicated server connections, the Java pool includes the shared part of each Java class, including methods and read-only memory such as code vectors, but not the per-session Java state of each session. For shared server, the pool includes the shared part of each class and some UGA used for the state of each session. Each UGA grows and shrinks as necessary, but the total UGA size must fit in the Java pool space.</p>
                     <p>The Java Pool Advisor statistics provide information about library cache memory used for Java and predict how changes in the size of the Java pool can affect the parse rate. The Java Pool Advisor is internally turned on when <code class="codeph">statistics_level</code> is set to <code class="codeph">TYPICAL</code> or higher. These statistics reset when the advisor is turned off.
                     </p>
                     <div class="infoboxnotealso" id="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D__GUID-A7B0BD15-211A-4085-A633-F45DFB403D69">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=JJDEV01000" target="_blank"><span><cite>Oracle Database Java Developer’s Guide</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA589" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn about views containing Java pool advisory statistics
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT9837"></a><div class="props_rev_3"><a id="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" name="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19"></a><h4 id="CNCPT-GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" class="sect4">Fixed SGA</h4>
                  <div>
                     <p>The <strong class="term">fixed SGA</strong> is an internal housekeeping area.
                     </p>
                     <p>For example, the fixed SGA contains:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>General information about the state of the database and the instance, which the background processes need to access</p>
                        </li>
                        <li>
                           <p>Information communicated between processes, such as information about locks</p>
                        </li>
                     </ul>
                     <p>The size of the fixed SGA is set by Oracle Database and cannot be altered manually. The fixed SGA size can change from release to release.</p>
                     <div class="infoboxnotealso" id="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19__GUID-DE542EB4-4294-4469-8A0C-3C3208420091">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="data-concurrency-and-consistency.html#GUID-E926E638-0161-4389-887B-4A31A529478A" title="Oracle Database automatically locks a resource on behalf of a transaction to prevent other transactions from doing something that requires exclusive access to the same resource.">Overview of Automatic Locks</a>"</span></p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" name="GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851"></a><h4 id="CNCPT-GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" class="sect4">Optional Performance-Related SGA Subareas</h4>
                  <div>
                     <p>Some SGA subareas are only enabled for specific performance features.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="memory-architecture.html#GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" title="The In-Memory Area is an optional SGA component that contains the In-Memory Column Store (IM column store).">In-Memory Area</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" title="The memoptimize pool stores buffers and related structures for heap-organized tables specified as MEMOPTIMIZE FOR READ.">Memoptimize Pool</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" name="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209"></a><h5 id="CNCPT-GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" class="sect5">In-Memory Area</h5>
                     <div>
                        <p>The In-Memory Area is an optional SGA component that contains the <span class="bold">In-Memory Column Store</span> (IM column store). 
                        </p>
                        <p>The IM column store contains copies of tables, partitions, and materialized views in a <a href="glossary.html#GUID-DDC39B24-BE95-406A-986F-D760308CA26D"><span class="xrefglossterm">columnar format</span></a> optimized for rapid scans. The IM column store supplements the database buffer cache, which stores data in traditional row format.
                        </p>
                        <div class="infoboxnote" id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209__GUID-FD650FFC-B680-4938-ACA6-3F045222B1FC">
                           <p class="notep1">Note:</p>
                           <p>To enable an IM column store, you must have the Oracle Database In-Memory option.</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209__GUID-4F10D212-BD66-43B5-8C55-43F6072E9CEB">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=INMEM-GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a> to learn more about the In-Memory Area and the IM column store
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" name="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12"></a><h5 id="CNCPT-GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" class="sect5"><span>Memoptimize Pool</span></h5>
                     <div>
                        <p>The <span class="bold"><span>memoptimize pool</span></span> stores buffers and related structures for heap-organized tables specified as <code class="codeph">MEMOPTIMIZE FOR READ</code>.
                        </p>
                        <p>This structure provides high performance and scalability for key-based queries such as <code class="codeph">SELECT * FROM cust WHERE cid = 10</code>. To reduce end-to-end response time, clients pull requested buffers directly from the SGA over the network, avoiding CPU and operating system overhead. Applications can benefit from the <span>memoptimize pool</span> without requiring code changes.
                        </p>
                        <p>The <span>memoptimize pool</span> contains two parts:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Memoptimize buffer area</p>
                              <p>To avoid disk I/O, the database permanently locks buffers for <code class="codeph">MEMOPTIMIZE FOR READ</code> tables in the <span>memoptimize pool</span>, until the table is marked <code class="codeph">NO MEMOPTIMIZE FOR READ</code>. The memoptimize buffers use the same structure as buffers in the database buffer cache. However, the buffers in the <span>memoptimize pool</span> are completely separate from the database buffer cache and do not count toward its size. The memoptimize buffer area occupies 75% of the <span>memoptimize pool</span>.
                              </p>
                           </li>
                           <li>
                              <p>Hash index</p>
                              <p>A <a href="glossary.html#GUID-EE5E8238-C900-46DB-A688-6A5D0BDFEA7C"><span class="xrefglossterm">hash index</span></a> is a non-persistent, segment data structure. The database allocates the hash index as multiple, noncontiguous memory units. Each unit contains a number of hash buckets. A separate map structure correlates a memory unit with a primary key. The hash index occupies 25% of the <span>memoptimize pool</span>.
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12__GUID-A81EFC1E-BEA0-488C-9ADE-42746438A85F">
                           <p class="titleinfigure">Figure 14-13 <span>Memoptimize Pool</span></p><img src="img/cncpt_pb_001a.png" alt="Description of Figure 14-13 follows" title="Description of Figure 14-13 follows" longdesc="img_text/cncpt_pb_001a.html"><br><a href="img_text/cncpt_pb_001a.html">Description of "Figure 14-13 Memoptimize Pool"</a></div>
                        <!-- class="figure" -->
                        <p>To enable the <span>memoptimize pool</span>, set the <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> initialization parameter to an integer value (the pool is disabled by default). The value specifies the amount of SGA to allocate to the pool. The <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> value <span class="italic">does</span> count toward <code class="codeph">SGA_TARGET</code>, but the database does <span class="italic">not</span> grow and shrink the <span>memoptimize pool</span> automatically. For example, if <code class="codeph">SGA_TARGET</code> is 10 GB, and if <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> is 1 GB, then a total of 9 GB is available for SGA memory other than the <span>memoptimize pool</span>. 
                        </p>
                        <p>To change the size of the <span>memoptimize pool</span>, you must set <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> manually and restart the database instance. You cannot change the pool size dynamically using <code class="codeph">ALTER SYSTEM</code>.
                        </p>
                        <p>The <code class="codeph">DBMS_MEMOPTIMIZE</code> package enables you to explicitly populate a table into the <span>memoptimize pool</span>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12__GUID-D6BA968E-6232-4E85-95DE-93514493377B">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="concepts-for-database-administrators.html#GUID-C7AFB6E3-195E-4269-A871-D514CD9A84BE" title="In automatic memory management, Oracle Database manages the SGA and instance PGA memory completely automatically. This method is the simplest and is strongly recommended by Oracle.">Automatic Memory Management</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA-GUID-9752E93D-55A7-4584-B09B-9623B33B5CCF" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn how to improve query performance by enabling the <span>memoptimize pool</span></p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_MEMOPTIMIZE.html#ARPLS-GUID-49F0E799-97F0-41E7-9CD3-24AE3CAA8105" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn more about the <code class="codeph">DBMS_MEMOPTIMIZE</code> package
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF-GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about <code class="codeph">CREATE TABLE ... MEMOPTIMIZE FOR READ</code></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/MEMOPTIMIZE_POOL_SIZE.html#GUID-D33BB2FE-94A7-475F-B8C8-CC9AC61B502F" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about <code class="codeph">MEMOPTIMIZE_POOL_SIZE</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT804"></a><div class="props_rev_3"><a id="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" name="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963"></a><h3 id="CNCPT-GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" class="sect3">Overview of Software Code Areas</h3>
               <div>
                  <p>A <span class="bold">software code area</span> is a portion of memory that stores code that is being run or can be run. Oracle Database code is stored in a software area that is typically more exclusive and protected than the location of user programs.
                  </p>
                  <p>Software areas are usually static in size, changing only when software is updated or reinstalled. The required size of these areas varies by operating system.</p>
                  <p>Software areas are read-only and can be installed shared or nonshared. Some database tools and utilities, such as Oracle Forms and SQL*Plus, can be installed shared, but some cannot. When possible, database code is shared so that all users can access it without having multiple copies in memory, resulting in reduced main memory and overall improvement in performance. Multiple instances of a database can use the same database code area with different databases if running on the same computer.</p>
                  <div class="infoboxnote" id="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963__GUID-1543C5D6-3DE6-400C-A008-C771B365EBE3">
                     <p class="notep1">Note:</p>
                     <p>The option of installing software shared is not available for all operating systems, for example, on PCs operating Microsoft Windows. See your operating system-specific documentation for more information.</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>