<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>C++ Applications</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="applications.html" title="Previous" type="text/html">
      <link rel="next" href="Oracle-dynamic-SQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="Oracle-dynamic-SQL.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name"> Applications </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> C++ Applications</li>
            </ol>
            <a id="GUID-320589F8-AE9F-4440-9551-1C52F449E486" name="GUID-320589F8-AE9F-4440-9551-1C52F449E486"></a><a id="LNPCC012"></a>
            
            <h2 id="LNPCC-GUID-320589F8-AE9F-4440-9551-1C52F449E486" class="sect2"><span class="enumeration_chapter">12 </span> C++ Applications
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes how you can use the Pro*C/C++ Precompiler to precompile your C++ embedded SQL application, and how Pro*C/C++ generates C++ compatible code. This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E">Understanding C++ Support</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">Precompiling for C++</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392">Example Programs</a> <a id="d72932e39" class="indexterm-anchor"></a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3979"></a><div class="props_rev_3"><a id="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" name="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E"></a><h3 id="LNPCC-GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" class="sect3"><span class="enumeration_section">12.1 </span>Understanding C++ Support
               </h3>
               <div>
                  <p>To understand how Pro*C/C++ supports C++, you must understand the basic functional capabilities of Pro*C/C++. In particular, you must be aware of how Pro*C/C++ differs from Pro*C Version 1.</p>
                  <p>The basic capabilities of Pro*C/C++ are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Full C preprocessor support. You can use <code class="codeph">#define</code>, <code class="codeph">#include</code>, <code class="codeph">#ifdef</code>, and other preprocessor directives in your Pro*C/C++ program, to handle constructs that the precompiler itself must process.
                        </p>
                     </li>
                     <li>
                        <p>Use of native C structures as host variables, including the ability to pass structs (or pointers to structs) as host variables to functions, and write functions that return host structures or struct pointers.</p>
                     </li>
                  </ul>
                  <p>To support its C preprocessor capabilities and to enable host variables to be declared outside a special Declare Section, Pro*C/C++ incorporates a complete C parser. The Pro*C/C++ parser is a C parser; it cannot parse C++ code.</p>
                  <p>This means that for C++ support, you must be able to disable the C parser, or at least partially disable it. To disable the C parser, the Pro*C/C++ Precompiler includes command-line options to give you control over the extent of C parsing that Pro*C/C++ performs on your source code.</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="datatypes-and-host-variables.html#GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED">Oracle Datatypes</a></li>
                        <li><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">Precompiling for C++</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3980"></a><div class="props_rev_3"><a id="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" name="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF"></a><h4 id="LNPCC-GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" class="sect4"><span class="enumeration_section">12.1.1 </span>No Special Macro Processing
                  </h4>
                  <div>
                     <p>Using C++ with Pro*C/C++ does not require any special preprocessing or special macro processors that are external to Pro*C/C++. There is no need to run a macro processor on the output of the precompiler to achieve C++ compatibility.</p>
                     <p>If you are a user of a release of Pro*C/C++ Precompiler before this one, and you did use macro processors on the precompiler output, you should be able to precompile your C++ applications using Pro*C/C++ with no changes to your code.</p>
                  </div>
               </div>
            </div><a id="LNPCC3981"></a><div class="props_rev_3"><a id="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" name="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224"></a><h3 id="LNPCC-GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" class="sect3"><span class="enumeration_section">12.2 </span>Precompiling for C++
               </h3>
               <div>
                  <p>To control precompilation so that it accommodates C++, there are four considerations:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Code emission by the precompiler</p>
                     </li>
                     <li>
                        <p>Parsing capability</p>
                     </li>
                     <li>
                        <p>The output filename extension</p>
                     </li>
                     <li>
                        <p>The location of system header files</p>
                     </li>
                  </ul>
               </div><a id="LNPCC3982"></a><div class="props_rev_3"><a id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" name="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0"></a><h4 id="LNPCC-GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" class="sect4"><span class="enumeration_section">12.2.1 </span>Code Generation
                  </h4>
                  <div>
                     <p>You must be able to specify what kind of code, C compatible code or C++ compatible code, the precompiler generates. Pro*C/C++ by default generates C code. C++ is not a perfect superset of C. Some changes are required in generated code so that it can be compiled by a C++ compiler.</p>
                     <p>For example, in addition to emitting your application code, the precompiler interposes calls to its runtime library, SQLLIB. The functions in SQLLIB are C functions. There is no special C++ version of SQLLIB. For this reason, if you want to compile the generated code using a C++ compiler, Pro*C/C++ must declare the functions called in SQLLIB as C functions.</p>
                     <p>For C output, the precompiler would generate a prototype such as</p><pre class="oac_no_warn" dir="ltr">void sqlora(unsigned long *, void *);
</pre><p>But for C++ compatible code, the precompiler must generate</p><pre class="oac_no_warn" dir="ltr">extern "C" {
void sqlora(unsigned long *, void *);
};
</pre><p>You control the kind of code Pro*C/C++ generates using the precompiler option CODE. There are three values for this option: CPP, KR_C, and ANSI_C. The differences between these options can be illustrated by considering how the declaration of the SQLLIB function <span class="italic">sqlora</span> differs among the three values for the CODE option:
                     </p><pre class="oac_no_warn" dir="ltr">void sqlora( /*_ unsigned long *, void * _*/);  /* K&amp;R C */

void sqlora(unsigned long *, void *);           /* ANSI C */

extern "C" {                                    /* CPP */
void sqlora(unsigned long *, void *);
};
</pre><p>When you specify CODE=CPP, the precompiler <a id="d72932e208" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Generates C++ compilable code.</p>
                        </li>
                        <li>
                           <p>Gives the output file a platform-specific file extension (suffix), such as ".C" or ".cc", rather than the standard ".c" extension. (You can override this by using the CPP_SUFFIX option.)</p>
                        </li>
                        <li>
                           <p>Causes the value of the PARSE option to default to PARTIAL. You can also specify PARSE=NONE. If you specify PARSE=FULL, an error is issued at precompile time.</p>
                        </li>
                        <li>
                           <p>Allows the use of the C++ style // Comments in your code. This style of Commenting is also permitted inside SQL statements and PL/SQL blocks when CODE=CPP.</p>
                        </li>
                        <li>
                           <p>Pro*C/C++ recognizes SQL optimizer hints that begin with //+. <a id="d72932e228" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>Requires that header files generated by OTT (Object Type Translator) must be included inside a declare section.</p>
                           <div class="infoboxnotealso" id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0__GUID-56991AFB-CD1F-410B-AF85-4CBC47CCE2E1">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="precompiler-options.html#GUID-EA4E8928-3B92-4A29-BC1B-C726BFE4B79A">CODE</a>"</span> for information about the KR_C and ANSI_C values for the CODE option.
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3984"></a><a id="LNPCC3983"></a><div class="props_rev_3"><a id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" name="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D"></a><h4 id="LNPCC-GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" class="sect4"><span class="enumeration_section">12.2.2 </span>About Parsing Code
                  </h4>
                  <div>
                     <p>You must be able to control the effect of the Pro*C/C++ C parser on your code. You do this by using the PARSE precompiler option, which controls how the precompiler's C parser treats your code.</p>
                     <p>The values and effects of the PARSE option are:</p>
                     <div class="tblformal" id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D__GUID-899802DA-238A-4581-9803-EBE92B86CA7E">
                        <p class="titleintable">Table 12-1 Values and Effects of the PARSE Option</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Values and Effects of the PARSE Option" summary="Values and Effects of the PARSE Option" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d72932e279">Values</th>
                                 <th align="left" valign="bottom" width="69%" id="d72932e282">Effects</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e287" headers="d72932e279 ">
                                    <p>PARSE=NONE </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e287 d72932e282 ">
                                    <p>The value NONE has the following effects:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>C preprocessor directives are understood only inside a declare section.</p>
                                       </li>
                                       <li>
                                          <p>You must declare all host variables inside a Declare Section.</p>
                                       </li>
                                       <li>
                                          <p> Precompiler release 1.x behavior</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e304" headers="d72932e279 ">
                                    <p>PARSE=PARTIAL </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e304 d72932e282 ">
                                    <p>The value PARTIAL has the following effects:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>All preprocessor directives are understood</p>
                                       </li>
                                       <li>
                                          <p>You must declare all host variables inside a Declare Section</p>
                                       </li>
                                    </ul>
                                    <p>This option value is the default if CODE=CPP</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e320" headers="d72932e279 ">
                                    <p>PARSE=FULL </p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e320 d72932e282 ">
                                    <p>The value FULL has the following effects:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>The precompiler C parser runs on your code.</p>
                                       </li>
                                       <li>
                                          <p>All Preprocessor directives are understood.</p>
                                       </li>
                                       <li>
                                          <p>You can declare host variables at any place that they can be declared legally in C.</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>This option value is the default if the value of the CODE option is anything other than CPP. It is an error to specify PARSE=FULL when CODE=CPP.</p>
                     <p>To generate C++ compatible code, the PARSE option must be either NONE or PARTIAL. If PARSE=FULL, the C parser runs, and it does not understand C++ constructs in your code, such as classes.</p>
                  </div>
               </div><a id="LNPCC3985"></a><div class="props_rev_3"><a id="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" name="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4"></a><h4 id="LNPCC-GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" class="sect4"><span class="enumeration_section">12.2.3 </span>Output Filename Extension
                  </h4>
                  <div>
                     <p>Most C compilers expect a default extension of ".c" for their input files. Different C++ compilers, however, can expect different filename extensions. The CPP_SUFFIX option provides the ability to specify the filename extension that the precompiler generates. The value of this option is a string, without the quotes or the period. For example, CPP_SUFFIX=cc, or CPP_SUFFIX=C. <a id="d72932e365" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3986"></a><div class="props_rev_3"><a id="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" name="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912"></a><h4 id="LNPCC-GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" class="sect4"><span class="enumeration_section">12.2.4 </span>System Header Files 
                  </h4>
                  <div>
                     <p><a id="d72932e392" class="indexterm-anchor"></a>Pro*C/C++ searches for standard system header files, such as <code class="codeph">stdio.h</code>, in standard locations that are platform specific. Pro*C/C++ does not search for header files with extensions such as <code class="codeph">hpp</code> or <code class="codeph">h</code>++. For example, on almost all UNIX systems, the file <code class="codeph">stdio.h</code> has the full path name <code class="codeph">/usr/include/stdio.h</code>. 
                     </p>
                     <p>But a C++ compiler has its own version of <code class="codeph">stdio.h</code> that is not in the standard system location. When you are precompiling for C++, you must use the SYS_INCLUDE precompiler option to specify the directory paths that Pro*C/C++ searches to look for system header files. For example:<a id="d72932e417" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">SYS_INCLUDE=(/usr/lang/SC2.0.1/include,/usr/lang/SC2.1.1/include)
</pre><p>Use the INCLUDE precompiler option to specify the location of non-system header files. The directories specified by the SYS_INCLUDE option are searched before directories specified by the INCLUDE option.</p>
                     <p>If PARSE=NONE, the values specified in SYS_INCLUDE and INCLUDE for system files are not relevant, since there is no need for Pro*C/C++ to include system header files. (You can, of course, still include Pro*C/C++-specific headers, such <code class="codeph">sqlca.h</code>, using the EXEC SQL INCLUDE statement.)
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">INCLUDE</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3987"></a><div class="props_rev_3"><a id="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" name="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392"></a><h3 id="LNPCC-GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" class="sect3"><span class="enumeration_section">12.3 </span>Example Programs
               </h3>
               <div>
                  <div class="section">
                     <p>This section includes three example Pro*C/C++ programs that include C++ constructs. Each of these programs is available on-line, in your <code class="codeph">demo</code> directory.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC3988"></a><div class="props_rev_3"><a id="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" name="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0"></a><h4 id="LNPCC-GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" class="sect4"><span class="enumeration_section">12.3.1 </span>cppdemo1.pc
                  </h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">
/*  cppdemo1.pc
 *
 *  Prompts the user for an employee number, then queries the 
 *  emp table for the employee's name, salary and commission.
 *  Uses indicator variables (in an indicator struct) to 
 *  determine if the commission is NULL.
 */

#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Parse=partial by default when code=cpp,
// so preprocessor directives are recognized and parsed fully.
#define     UNAME_LEN      20
#define     PWD_LEN        40

// Declare section is required when CODE=CPP or
// PARSE={PARTIAL|NONE} or both.
EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR username[UNAME_LEN];  // VARCHAR is an ORACLE pseudotype
  varchar password[PWD_LEN];    // can be in lower case also

  // Define a host structure for the output values
  // of a SELECT statement
  struct empdat {
      VARCHAR   emp_name[UNAME_LEN];
      float     salary;
      float     commission;
  } emprec;

  // Define an indicator struct to correspond to the
  // host output struct
  struct empind {
      short     emp_name_ind;
      short     sal_ind;
      short     comm_ind;
  } emprec_ind;


  // Input host variables
  int   emp_number;
  int   total_queried;
EXEC SQL END DECLARE SECTION;

// Define a C++ class object to match the desired
// struct from the preceding declare section.
class emp {
  char  ename[UNAME_LEN];
  float salary;
  float commission;
public:
  // Define a constructor for this C++ object that
  // takes ordinary C objects.
  emp(empdat&amp;, empind&amp;);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, emp&amp;);
};

emp::emp(empdat&amp; dat, empind&amp; ind)
{
  strncpy(ename, (char *)dat.emp_name.arr, dat.emp_name.len);
  ename[dat.emp_name.len] = '\0';
  this-&gt;salary = dat.salary;
  this-&gt;commission = (ind.comm_ind &lt; 0) ? 0 : dat.commission;
}

ostream&amp; operator&lt;&lt;(ostream&amp; s, emp&amp; e)
{
  return s &lt;&lt; e.ename &lt;&lt; " earns " &lt;&lt; e.salary &lt;&lt; 
              " plus " &lt;&lt; e.commission &lt;&lt; " commission." 
           &lt;&lt; endl &lt;&lt; endl;
}

// Include the SQL Communications Area
// You can use #include or EXEC SQL INCLUDE
#include &lt;sqlca.h&gt;

// Declare error handling function
void sql_error(char *msg);

main()
{
  char temp_char[32];

  // Register sql_error() as the error handler
  EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error:");

  // Connect to ORACLE.  Program calls sql_error()
  // if an error occurs
  // when connecting to the default database.
  // Note the (char *) cast when
  // copying into the VARCHAR array buffer.
  username.len = strlen(strcpy((char *)username.arr, "SCOTT"));
  password.len = strlen(strcpy((char *)password.arr, "TIGER"));
  
  EXEC SQL CONNECT :username IDENTIFIED BY :password;

  // Here again, note the (char *) cast when using VARCHARs
  cout &lt;&lt; "\nConnected to ORACLE as user: "
       &lt;&lt; (char *)username.arr &lt;&lt; endl &lt;&lt; endl;

  // Loop, selecting individual employee's results
  total_queried = 0;
  while (1)
  {
      emp_number = 0;
      printf("Enter employee number (0 to quit): ");
      gets(temp_char);
      emp_number = atoi(temp_char);
      if (emp_number == 0)
        break;

      // Branch to the notfound label when the 
      // 1403 ("No data found") condition occurs
      EXEC SQL WHENEVER NOT FOUND GOTO notfound;

      EXEC SQL SELECT ename, sal, comm
         INTO :emprec INDICATOR :emprec_ind // You can also use 
                                            // C++ style
         FROM EMP                  // Comments in SQL statemtents.
         WHERE EMPNO = :emp_number;

      {
        // Basic idea is to pass C objects to
        // C++ constructors thus
        // creating equivalent C++ objects used in the
        // usual C++ way
        emp e(emprec, emprec_ind);
        cout &lt;&lt; e;
      }

      total_queried++;
      continue;
notfound:
      cout &lt;&lt; "Not a valid employee number - try again." 
           &lt;&lt; endl &lt;&lt; endl;
  } // end while(1)

  cout &lt;&lt; endl &lt;&lt; "Total rows returned was " 
       &lt;&lt; total_queried &lt;&lt; endl;
  cout &lt;&lt; "Have a nice day!" &lt;&lt; endl &lt;&lt; endl;

  // Disconnect from ORACLE
  EXEC SQL COMMIT WORK RELEASE;
  exit(0);
}


void sql_error(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    cout &lt;&lt; endl &lt;&lt; msg &lt;&lt; endl;
    cout &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3989"></a><div class="props_rev_3"><a id="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" name="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075"></a><h4 id="LNPCC-GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" class="sect4"><span class="enumeration_section">12.3.2 </span>cppdemo2.pc
                  </h4>
                  <div>
                     <div class="section">
                        <p>The next application is a simple modular example. First, execute the following SQL script, <code class="codeph">cppdemo2.sql</code>, in SQL*Plus:
                        </p><pre class="oac_no_warn" dir="ltr"><a id="d72932e528" class="indexterm-anchor"></a>Rem  This is the SQL script that accompanies the cppdemo2 C++ Demo
Rem  Program.  Run this prior to Precompiling the empclass.pc file.
/
CONNECT SCOTT/TIGER
/
CREATE OR REPLACE VIEW emp_view AS SELECT ename, empno FROM EMP
/
CREATE OR REPLACE PACKAGE emp_package AS
  TYPE emp_cursor_type IS REF CURSOR RETURN emp_view%ROWTYPE;
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type);
END emp_package;
/
CREATE OR REPLACE PACKAGE BODY emp_package AS
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type) IS
  BEGIN
    OPEN curs FOR SELECT ename, empno FROM emp_view ORDER BY ename ASC;
  END;
END emp_package;
/
EXIT
/
</pre><p>The header file <code class="codeph">empclass.h</code> defines the class <code class="codeph">emp</code>:
                        </p><pre class="oac_no_warn" dir="ltr">
// This class definition may be included in a Pro*C/C++ application
// program using the EXEC SQL INCLUDE directive only.  Because it
// contains EXEC SQL syntax, it may not be included using a #include
// directive.  Any program that includes this header must be
// precompiled with the CODE=CPP option.  This emp class definition
// is used when building the cppdemo2 C++ Demo Program.

class emp
{
  public:
    emp();   // Constructor: ALLOCATE Cursor Variable
    ~emp();  // Desctructor: FREE Cursor Variable

    void open();              // Open Cursor
    void fetch() throw (int); // Fetch (throw NOT FOUND condition)
    void close();             // Close Cursor

    void emp_error();         // Error Handler

    EXEC SQL BEGIN DECLARE SECTION;
      // When included using EXEC SQL INCLUDE, class variables have 
      // global scope and are thus basically treated as ordinary
      // global variables by Pro*C/C++ during precompilation.
      char ename[10];
      int empno;
    EXEC SQL END DECLARE SECTION;

  private:
    EXEC SQL BEGIN DECLARE SECTION;
      // Pro*C/C++ treats this as a simple global variable also.
      SQL_CURSOR emp_cursor;
    EXEC SQL END DECLARE SECTION;
};
</pre><p>The code in <code class="codeph">empclass.pc</code> contains the <code class="codeph">emp</code> methods:
                        </p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// This example uses a single (global) SQLCA that is shared by the
// emp class implementation as well as the main program for this
// application.
#define SQLCA_STORAGE_CLASS extern
#include &lt;sqlca.h&gt;

// Include the emp class specification in the implementation of the
// class body as well as the application program that makes use of it.
EXEC SQL INCLUDE empclass.h;

emp::emp()
{
  // The scope of this WHENEVER statement spans the entire module.
  // Note that the error handler function is really a member function
  // of the emp class.
  EXEC SQL WHENEVER SQLERROR DO emp_error();
  EXEC SQL ALLOCATE :emp_cursor;  // Constructor - ALLOCATE Cursor.
}

emp::~emp()
{
  EXEC SQL FREE :emp_cursor;      // Destructor - FREE Cursor.
}

void emp::open()
{
  EXEC SQL EXECUTE
    BEGIN
      emp_package.open_cursor(:emp_cursor);
    END;
  END-EXEC;
}

void emp::close()
{
  EXEC SQL CLOSE :emp_cursor;
}

void emp::fetch() throw (int)
{
  EXEC SQL FETCH :emp_cursor INTO :ename, :empno;
  if (sqlca.sqlcode == 1403)
    throw sqlca.sqlcode;     // Like a WHENEVER NOT FOUND statement.
}

void emp::emp_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);
}
</pre><p>The main program, <code class="codeph">cppdemo2.pc</code>, uses the cursor variable:
                        </p><pre class="oac_no_warn" dir="ltr">// Pro*C/C++ sample program demonstrating a simple use of Cursor Variables
// implemented within a C++ class framework.  Build this program as follows
//
//   1. Execute the cppdemo2.sql script within SQL*Plus
//   2. Precompile the empclass.pc program as follows
//      &gt; proc code=cpp sqlcheck=full user=scott/tiger lines=yes empclass
//   3. Precompile the cppdemo2.pc program as follows
//      &gt; proc code=cpp lines=yes cppdemo2
//   4. Compile and Link
//
// Note that you may have to specify various include directories using the
// include option when precompiling.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;

static void sql_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);  
}

// Physically include the emp class definition in this module.
EXEC SQL INCLUDE empclass.h;

int main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO sql_error();
  EXEC SQL CONNECT :uid;

  emp *e = new emp(); // Invoke Constructor - ALLOCATE Cursor Variable.

  e-&gt;open();          // Open the Cursor.

  while (1)
    {
      // Fetch from the Cursor, catching the NOT FOUND condition
      // thrown by the fetch() member function.
      try { e-&gt;fetch(); } catch (int code)  
        { if (code == 1403) break; }
      printf("Employee:  %s[%d]\n", e-&gt;ename, e-&gt;empno);
    }

  e-&gt;close();         // Close the Cursor.

  delete e;           // Invoke Destructor - FREE Cursor Variable.

  EXEC SQL ROLLBACK WORK RELEASE;
  return (0);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3990"></a><div class="props_rev_3"><a id="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" name="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF"></a><h4 id="LNPCC-GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" class="sect4"><span class="enumeration_section">12.3.3 </span>cppdemo3.pc   
                  </h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">/*
 * cppdemo3.pc : An example of C++ Inheritance
 *
 * This program finds all salesman and prints their names
 * followed by how much they earn in total (ie; including 
 * any commissions).
 */
 
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;

#define NAMELEN 10

class employee {    // Base class is a simple employee
public:
  char ename[NAMELEN];
  int sal;
  employee(char *, int);
};

employee::employee(char *ename, int sal)
{
  strcpy(this-&gt;ename, ename);
  this-&gt;sal = sal;
}

// A salesman is a kind of employee
class salesman : public employee
{
  int comm;
public:
  salesman(char *, int, int);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, salesman&amp;);
};

// Inherits employee attributes
salesman::salesman(char *ename, int sal, int comm)
  : employee(ename, sal), comm(comm) {}  

ostream&amp; operator&lt;&lt;(ostream&amp; s, salesman&amp; m)
{
  return s &lt;&lt; m.ename &lt;&lt; m.sal + m.comm &lt;&lt; endl;  
}

void print(char *ename, int sal, int comm)
{
  salesman man(ename, sal, comm);
  cout &lt;&lt; man;
}

main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
    char  ename[NAMELEN];
    int   sal, comm;
    short comm_ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO error;

  EXEC SQL CONNECT :uid;
  EXEC SQL DECLARE c CURSOR FOR
    SELECT ename, sal, comm FROM emp WHERE job = 'SALESMAN'
      ORDER BY ename;
  EXEC SQL OPEN c;

  cout &lt;&lt; "Name    Salary" &lt;&lt; endl &lt;&lt; "------  ------" &lt;&lt; endl;

  EXEC SQL WHENEVER NOT FOUND DO break;
  while(1)
   {
     EXEC SQL FETCH c INTO :ename, :sal, :comm:comm_ind;
     print(ename, sal, (comm_ind &lt; 0) ? 0 : comm);
   }
  EXEC SQL CLOSE c;
  exit(0);

error:
  cout &lt;&lt; endl &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
  exit(1);
}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>