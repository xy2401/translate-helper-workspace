<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.">
      <meta name="description" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.">
      <title>Partitions, Views, and Other Schema Objects</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Concepts">
      <meta property="og:description" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Concepts">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00">
      <meta name="dcterms.title" content="Database Concepts">
      <meta name="dcterms.dateCopyrighted" content="1993, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96138-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="indexes-and-index-organized-tables.html" title="Previous" type="text/html">
      <link rel="next" href="data-integrity.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="indexes-and-index-organized-tables.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="data-integrity.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Concepts</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-relational-structures.html" property="item" typeof="WebPage"><span property="name">Oracle Relational Data Structures</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Partitions, Views, and Other Schema Objects </li>
            </ol>
            <a id="GUID-3E154566-50D6-48C1-BAE5-57EF20266B43" name="GUID-3E154566-50D6-48C1-BAE5-57EF20266B43"></a><a id="CNCPT88858"></a>
            
            <h2 id="CNCPT-GUID-3E154566-50D6-48C1-BAE5-57EF20266B43" class="sect2"><span class="enumeration_chapter">4 </span>Partitions, Views, and Other Schema Objects 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.</p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" title="In an Oracle database, partitioning enables you to decompose very large tables and indexes into smaller and more manageable pieces called partitions. Each partition is an independent object with its own name and optionally its own storage characteristics.">Overview of Partitions</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" title="In an Oracle database, sharding enables you to break up a large table into more manageable pieces called shards that can be stored in multiple databases.">Overview of Sharded Tables</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" title="A view is a logical representation of one or more tables. In essence, a view is a stored query.">Overview of Views</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="A materialized view is a query result that has been stored or "materialized" in advance as a schema object. The FROM clause of the query can name tables, views, or materialized views.">Overview of Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" title="A sequence is a schema object from which multiple users can generate unique integers. A sequence generator provides a highly scalable and well-performing method to generate surrogate keys for a number data type.">Overview of Sequences</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" title="A typical data warehouse has two important components: dimensions and facts.">Overview of Dimensions</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" title="A synonym is an alias for a schema object. For example, you can create a synonym for a table or view, sequence, PL/SQL program unit, user-defined object type, or another synonym. Because a synonym is simply an alias, it requires no storage other than its definition in the data dictionary.">Overview of Synonyms</a></p>
                  </li>
               </ul>
            </div><a id="CNCPT112"></a><div class="props_rev_3"><a id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" name="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF"></a><h3 id="CNCPT-GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" class="sect3">Overview of Partitions</h3>
               <div>
                  <p>In an Oracle database, <span class="bold">partitioning</span> enables you to decompose very large tables and indexes into smaller and more manageable pieces called <span class="bold">partitions</span>. Each partition is an independent object with its own name and optionally its own storage characteristics.
                  </p>
                  <p>For an analogy that illustrates partitioning, suppose an HR manager has one big box that contains employee folders. Each folder lists the employee hire date. Queries are often made for employees hired in a particular month. One approach to satisfying such requests is to create an index on employee hire date that specifies the locations of the folders scattered throughout the box. In contrast, a partitioning strategy uses many smaller boxes, with each box containing folders for employees hired in a given month.</p>
                  <p>Using smaller boxes has several advantages. When asked to retrieve the folders for employees hired in June, the HR manager can retrieve the June box. Furthermore, if any small box is temporarily damaged, the other small boxes remain available. Moving offices also becomes easier because instead of moving a single heavy box, the manager can move several small boxes.</p>
                  <p>From the perspective of an application, only one schema object exists. SQL statements require no modification to access partitioned tables. Partitioning is useful for many different types of database applications, particularly those that manage large volumes of data. Benefits include:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Increased availability</p>
                        <p>The unavailability of a partition does not entail the unavailability of the object. The query <a href="glossary.html#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">optimizer</span></a> automatically removes unreferenced partitions from the <a href="glossary.html#GUID-78BCF1CD-1865-4AEB-8F14-AFA4FF1981BF"><span class="xrefglossterm">query plan</span></a> so queries are not affected when the partitions are unavailable.
                        </p>
                     </li>
                     <li>
                        <p>Easier administration of schema objects</p>
                        <p>A partitioned object has pieces that can be managed either collectively or individually. <a href="glossary.html#GUID-64F19D78-A73F-44A5-AA2E-60EBC800CB22"><span class="xrefglossterm">DDL</span></a> statements can manipulate partitions rather than entire tables or indexes. Thus, you can break up resource-intensive tasks such as rebuilding an index or table. For example, you can move one table partition at a time. If a problem occurs, then only the partition move must be redone, not the table move. Also, dropping a partition avoids executing numerous <code class="codeph">DELETE</code> statements.
                        </p>
                     </li>
                     <li>
                        <p>Reduced contention for shared resources in <a href="glossary.html#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a> systems
                        </p>
                        <p>In some OLTP systems, partitions can decrease contention for a shared resource. For example, DML is distributed over many segments rather than one segment.</p>
                     </li>
                     <li>
                        <p>Enhanced query performance in data warehouses</p>
                        <p>In a <a href="glossary.html#GUID-0881E18F-D245-4980-8272-64964B64E3CC"><span class="xrefglossterm">data warehouse</span></a>, partitioning can speed processing of ad hoc queries. For example, a sales table containing a million rows can be partitioned by quarter.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF__GUID-1B96F7A7-B650-46B5-81B1-85980E541F0C">
                     <p class="notep1">See Also:</p>
                     <p><a href="../vldbg/partition-intro.html#VLDBG00101" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for an introduction to partitioning
                     </p>
                  </div>
               </div><a id="CNCPT88859"></a><div class="props_rev_3"><a id="GUID-E3C5EDAA-01F2-4077-915E-133045C43095" name="GUID-E3C5EDAA-01F2-4077-915E-133045C43095"></a><h4 id="CNCPT-GUID-E3C5EDAA-01F2-4077-915E-133045C43095" class="sect4">Partition Characteristics</h4>
                  <div>
                     <p>Each partition of a table or index must have the same logical attributes, such as column names, data types, and constraints. </p>
                     <p>For example, all partitions in a table share the same column and constraint definitions. However, each partition can have separate physical attributes, such as the tablespace to which it belongs.</p>
                  </div><a id="CNCPT1512"></a><div class="props_rev_3"><a id="GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D" name="GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D"></a><h5 id="CNCPT-GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D" class="sect5">Partition Key</h5>
                     <div>
                        <p>The <span class="bold">partition key</span> is a set of one or more columns that determines the partition in which each row in a partitioned table should go. Each row is unambiguously assigned to a single partition.
                        </p>
                        <p>In the <code class="codeph">sales</code> table, you could specify the <code class="codeph">time_id</code> column as the key of a range partition. The database assigns rows to partitions based on whether the date in this column falls in a specified range. Oracle Database automatically directs insert, update, and delete operations to the appropriate partition by using the partition key.
                        </p>
                     </div>
                  </div><a id="CNCPT1911"></a><div class="props_rev_3"><a id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914" name="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914"></a><h5 id="CNCPT-GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914" class="sect5">Partitioning Strategies</h5>
                     <div>
                        <p>Oracle Partitioning offers several partitioning strategies that control how the database places data into partitions. The basic strategies are range, list, and hash partitioning.</p>
                        <p>A <a href="glossary.html#GUID-33A45DE7-008D-4724-9BCC-9CEA6ED95337"><span class="xrefglossterm">single-level partitioning</span></a> uses only one method of data distribution, for example, only list partitioning or only range partitioning. In <a href="glossary.html#GUID-2CBB2535-77AE-43F7-97C9-5AB9543A4742"><span class="xrefglossterm">composite partitioning</span></a>, a table is partitioned by one data distribution method and then each partition is further divided into subpartitions using a second data distribution method. For example, you could use a list partition for <code class="codeph">channel_id</code> and a range subpartition for <code class="codeph">time_id</code>.
                        </p>
                        <div class="example" id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">
                           <p class="titleinexample">Example 4-1 Sample Row Set for Partitioned Table</p>
                           <p>This partitioning example assumes that you want to populate a partitioned table <code class="codeph">sales</code> with the following rows:
                           </p><pre class="pre codeblock"><code>  PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      116      11393 05-JUN-99          2        999             1       12.18
       40     100530 30-NOV-98          9         33             1       44.99
      118        133 06-JUN-01          2        999             1       17.12
      133       9450 01-DEC-00          2        999             1       31.28
       36       4523 27-JAN-99          3        999             1       53.89
      125       9417 04-FEB-98          3        999             1       16.86
       30        170 23-FEB-01          2        999             1         8.8
       24      11899 26-JUN-99          4        999             1       43.04
       35       2606 17-FEB-00          3        999             1       54.94
       45       9491 28-AUG-98          4        350             1       47.45 
</code></pre></div>
                        <!-- class="example" -->
                     </div><a id="CNCPT89159"></a><a id="CNCPT89158"></a><a id="CNCPT88860"></a><a id="CNCPT88862"></a><div class="props_rev_3"><a id="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" name="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967"></a><h6 id="CNCPT-GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" class="sect6">Range Partitioning</h6>
                        <div>
                           <p>In <span class="bold">range partitioning</span>, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.
                           </p>
                           <p>Suppose that you create <code class="codeph">time_range_sales</code> as a partitioned table using the following SQL statement, with the <code class="codeph">time_id</code> column as the partition key:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE time_range_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , <span class="bold">time_id</span>        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY RANGE (<span class="bold">time_id</span>)
 (PARTITION SALES_1998 VALUES LESS THAN (TO_DATE('01-JAN-1999','DD-MON-YYYY')),
  PARTITION SALES_1999 VALUES LESS THAN (TO_DATE('01-JAN-2000','DD-MON-YYYY')),
  PARTITION SALES_2000 VALUES LESS THAN (TO_DATE('01-JAN-2001','DD-MON-YYYY')),
  PARTITION SALES_2001 VALUES LESS THAN (MAXVALUE)
 ); 
</pre><p>Afterward, you load <code class="codeph">time_range_sales</code> with the rows from <a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>.  The code shows the row distributions in the four partitions. The database chooses the partition for each row based on the <code class="codeph">time_id</code> value according to the rules specified in the <code class="codeph">PARTITION BY RANGE</code> clause. The range partition key value determines the non-inclusive high bound for a specified partition.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3" name="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3"></a><h6 id="CNCPT-GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3" class="sect6">Interval Partitioning</h6>
                        <div>
                           <p><strong class="term">Interval partitioning</strong> is an extension of range partitioning.
                           </p>
                           <p>If you insert data that exceeds existing range partitions, then Oracle Database automatically creates partitions of a specified interval. For example, you could create a sales history table that stores data for each month in a separate partition.</p>
                           <p>Interval partitions enable you to avoid creating range partitions explicitly. You can use interval partitioning for almost every table that is range partitioned and uses fixed intervals for new partitions. Unless you create range partitions with different intervals, or unless you always set specific partition attributes, consider using interval partitions.</p>
                           <p> When partitioning by interval, you must specify at least one range partition. The range partitioning key value determines the high value of the range partitions, which is called the <a href="glossary.html#GUID-B22E1450-CB82-4771-ACF3-0243C4748951"><span class="xrefglossterm">transition point</span></a>. The database automatically creates interval partitions for data with values that are beyond the transition point. The lower boundary of every interval partition is the inclusive upper boundary of the previous range or interval partition. Thus, in <a href="partitions-views-and-other-schema-objects.html#GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">Example 4-2</a>, value <code class="codeph">01-JAN-2011</code> is in partition <code class="codeph">p2</code>.
                           </p>
                           <p>The database creates interval partitions for data beyond the transition point. An <a href="glossary.html#GUID-553D825F-C025-4BA5-80F3-86BBC6047B03"><span class="xrefglossterm">interval partition</span></a> extends range partitioning by instructing the database to create partitions of the specified range or interval. The database automatically creates the partitions when data inserted into the table exceeds all existing range partitions. In <a href="partitions-views-and-other-schema-objects.html#GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">Example 4-2</a>, the <code class="codeph">p3</code> partition contains rows with partitioning key <code class="codeph">time_id</code> values greater than or equal to <code class="codeph">01-JAN-2013</code>.
                           </p>
                           <div class="example" id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">
                              <p class="titleinexample">Example 4-2 Interval Partitioning</p>
                              <p>Assume that you create a sales table with four partitions of varying widths. You specify that above the transition point of January 1, 2013, the database should create partitions in one month intervals. The high bound of partition <code class="codeph">p3</code> represents the transition point. Partition <code class="codeph">p3</code> and all partitions below it are in the range section, whereas all partitions above it fall into the interval section.
                              </p><pre class="pre codeblock"><code>CREATE TABLE interval_sales
    ( prod_id        NUMBER(6)
    , cust_id        NUMBER
    , time_id        DATE
    , channel_id     CHAR(1)
    , promo_id       NUMBER(6)
    , quantity_sold  NUMBER(3)
    , amount_sold    NUMBER(10,2)
    ) 
  PARTITION BY RANGE (time_id) 
  INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
    ( PARTITION p0 VALUES LESS THAN (TO_DATE('1-1-2010', 'DD-MM-YYYY'))
    , PARTITION p1 VALUES LESS THAN (TO_DATE('1-1-2011', 'DD-MM-YYYY'))
    , PARTITION p2 VALUES LESS THAN (TO_DATE('1-7-2012', 'DD-MM-YYYY'))
    , PARTITION p3 VALUES LESS THAN (TO_DATE('1-1-2013', 'DD-MM-YYYY')) );</code></pre><p>You insert a sale made on date October 10, 2014:</p><pre class="pre codeblock"><code>SQL&gt; INSERT INTO interval_sales VALUES (39,7602,'10-OCT-14',9,null,1,11.79);

1 row created.
</code></pre><p>A query of <code class="codeph">USER_TAB_PARTITIONS</code> shows that the database created a new partition for the October 10 sale because the sale date was later than the transition point:
                              </p><pre class="pre codeblock"><code>SQL&gt; COL PNAME FORMAT a9
SQL&gt; COL HIGH_VALUE FORMAT a40
SQL&gt; SELECT PARTITION_NAME AS PNAME, HIGH_VALUE 
  2  FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'INTERVAL_SALES';

PNAME     HIGH_VALUE
--------- ----------------------------------------
P0        TO_DATE(' 2007-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P1        TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P2        TO_DATE(' 2009-07-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P3        TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
SYS_P1598 TO_DATE(' 2014-11-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre><div class="infoboxnotealso" id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-7364EE52-2AAC-416C-A74A-853597F5E979">
                                 <p class="notep1">See Also:</p>
                                 <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-C121EA1B-2725-4464-B2C9-EEDE0C3C95AB" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn more about interval partitions
                                 </p>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="CNCPT89161"></a><a id="CNCPT89160"></a><a id="CNCPT88863"></a><div class="props_rev_3"><a id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881" name="GUID-B8381DAE-3187-4137-9A07-065A3F40E881"></a><h6 id="CNCPT-GUID-B8381DAE-3187-4137-9A07-065A3F40E881" class="sect6">List Partitioning</h6>
                        <div>
                           <p>In <strong class="term">list partitioning</strong>, the database uses a list of discrete values as the partition key for each partition. The partitioning key consists of one or more columns.
                           </p>
                           <p>You can use list partitioning to control how individual rows map to specific partitions. By using lists, you can group and organize related sets of data when the key used to identify them is not conveniently ordered.</p>
                           <div class="example" id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881__GUID-51254A5F-3F1A-458C-B616-A799C865B973">
                              <p class="titleinexample">Example 4-3 List Partitioning</p>
                              <p>Assume that you create <code class="codeph">list_sales</code> as a list-partitioned table using the following statement, where the <code class="codeph">channel_id</code> column is the partition key:
                              </p><pre class="pre codeblock"><code>CREATE TABLE list_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , <span class="bold">channel_id</span>     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY LIST (<span class="bold">channel_id</span>)
 ( PARTITION even_channels VALUES ('2','4'),
   PARTITION odd_channels VALUES ('3','9')
 ); 
</code></pre><p>Afterward, you load the table with the rows from <a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>. The code shows the row distribution in the two partitions. The database chooses the partition for each row based on the <code class="codeph">channel_id</code> value according to the rules specified in the <code class="codeph">PARTITION BY LIST</code> clause. Rows with a <code class="codeph">channel_id</code> value of 2 or 4 are stored in the <code class="codeph">EVEN_CHANNELS</code> partitions, while rows with a <code class="codeph">channel_id</code> value of 3 or 9 are stored in the <code class="codeph">ODD_CHANNELS</code> partition.
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="CNCPT89163"></a><a id="CNCPT89162"></a><a id="CNCPT88864"></a><div class="props_rev_3"><a id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" name="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0"></a><h6 id="CNCPT-GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" class="sect6">Hash Partitioning</h6>
                        <div>
                           <p>In <span class="bold">hash partitioning</span>, the database maps rows to partitions based on a hashing algorithm that the database applies to the user-specified partitioning key. 
                           </p>
                           <p>The destination of a row is determined by the internal <a href="glossary.html#GUID-DDDDC4BC-ADB8-40D7-9733-60CED8E4A83E"><span class="xrefglossterm">hash function</span></a> applied to the row by the database. When the number of partitions is a power of 2, the hashing algorithm creates a roughly even distribution of rows across all partitions.
                           </p>
                           <p>Hash partitioning is useful for dividing large tables to increase manageability. Instead of one large table to manage, you have several smaller pieces. The loss of a single hash partition does not affect the remaining partitions and can be recovered independently. Hash partitioning is also useful in <a href="glossary.html#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a> systems with high update contention. For example, a segment is divided into several pieces, each of which is updated, instead of a single segment that experiences contention.
                           </p>
                           <p>Assume that you create the partitioned <code class="codeph">hash_sales</code> table using the following statement, with the <code class="codeph">prod_id</code> column as the partition key:
                           </p><pre class="pre codeblock"><code>CREATE TABLE hash_sales
   ( <span class="bold">prod_id</span>        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY HASH (<span class="bold">prod_id</span>)
PARTITIONS 2; 
</code></pre><p>Afterward, you load the table with the rows from <a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>. The code shows a possible row distribution in the two partitions. The names of these partitions are system-generated.
                           </p>
                           <p>As you insert rows, the database attempts to randomly and evenly distribute them across partitions. You cannot specify the partition into which a row is placed. The database applies the hash function, whose outcome determines which partition contains the row.</p>
                           <div class="infoboxnotealso" id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0__GUID-1CA60423-2800-4131-A8EC-68CB612BA4CF">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../vldbg/partition-admin.html#VLDBG003" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to create partitions
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF54655" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE TABLE ... PARTITION BY</code> examples
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A" name="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A"></a><h6 id="CNCPT-GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A" class="sect6">Reference Partitioning</h6>
                        <div>
                           <p>In <span class="bold">reference partitioning</span>, the partitioning strategy of a child table is solely defined through the foreign key relationship with a parent table. For every partition in the parent table, exactly one corresponding partition exists in the child table. The parent table stores the parent records in a specific partition, and the child table stores the child records in the corresponding partition.
                           </p>
                           <p>For example, an <code class="codeph">orders</code> table is the parent of the <code class="codeph">line_items</code> table, with a primary key and foreign key defined on <code class="codeph">order_id</code>. The tables are partitioned by reference. For example, if the database stores order 233 in partition <code class="codeph">Q3_2015</code> of <code class="codeph">orders</code>, then the database stores all line items for order 233 in partition <code class="codeph">Q3_2015</code> of <code class="codeph">line_items</code>. If partition <code class="codeph">Q4_2015</code> is added to <code class="codeph">orders</code>, then the database automatically adds <code class="codeph">Q4_2015</code> to <code class="codeph">line_items</code>.
                           </p>
                           <p>The advantages of reference partitioning are:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>By using the same partitioning strategy for both the parent and child tables, you avoid duplicating all partitioning key columns. This strategy reduces the manual overhead of denormalization, and saves space.</p>
                              </li>
                              <li>
                                 <p>Maintenance operations on a parent table occur on the child table automatically. For example, when you add a partition to the master table, the database automatically propagates this addition to its descendents.</p>
                              </li>
                              <li>
                                 <p>The database automatically uses partition-wise joins of the partitions in the parent and child table, improving performance.</p>
                              </li>
                           </ul>
                           <p>You can use reference partitioning with all basic partitioning strategies, including interval partitioning. You can also create reference partitioned tables as composite partitioned tables.</p>
                           <div class="example" id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A__GUID-48EA96F9-0B6B-414E-9BF3-DF2541442AFF">
                              <p class="titleinexample">Example 4-4 Creating Reference-Partitioned Tables</p>
                              <p>This example creates a parent table orders which is range-partitioned on <code class="codeph">order_date</code>. The reference-partitioned child table <code class="codeph">order_items</code> is created with four partitions, <code class="codeph">Q1_2015</code>, <code class="codeph">Q2_2015</code>, <code class="codeph">Q3_2015</code>, and <code class="codeph">Q4_2015</code>, where each partition contains the <code class="codeph">order_items</code> rows corresponding to orders in the respective parent partition.
                              </p><pre class="pre codeblock"><code>CREATE TABLE orders
    ( order_id           NUMBER(12),
      order_date         DATE,
      order_mode         VARCHAR2(8),
      customer_id        NUMBER(6),
      order_status       NUMBER(2),
      order_total        NUMBER(8,2),
      sales_rep_id       NUMBER(6),
      promotion_id       NUMBER(6),
      CONSTRAINT orders_pk PRIMARY KEY(order_id)
    )
  PARTITION BY RANGE(order_date)
    ( PARTITION Q1_2015 VALUES LESS THAN (TO_DATE('01-APR-2015','DD-MON-YYYY')),
      PARTITION Q2_2015 VALUES LESS THAN (TO_DATE('01-JUL-2015','DD-MON-YYYY')),
      PARTITION Q3_2015 VALUES LESS THAN (TO_DATE('01-OCT-2015','DD-MON-YYYY')),
      PARTITION Q4_2015 VALUES LESS THAN (TO_DATE('01-JAN-2006','DD-MON-YYYY'))
    );

CREATE TABLE order_items
    ( order_id           NUMBER(12) NOT NULL,
      line_item_id       NUMBER(3)  NOT NULL,
      product_id         NUMBER(6)  NOT NULL,
      unit_price         NUMBER(8,2),
      quantity           NUMBER(8),
      CONSTRAINT order_items_fk
      FOREIGN KEY(order_id) REFERENCES orders(order_id)
    )
    PARTITION BY REFERENCE(order_items_fk);</code></pre><div class="infoboxnotealso" id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A__GUID-446DA81B-AA00-4F92-9EE3-125F955D5CD4">
                                 <p class="notep1">See Also:</p>
                                 <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-54D18B18-6838-4115-9389-E1FB0D20A8CA" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for an overview of reference partitioning
                                 </p>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79" name="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79"></a><h6 id="CNCPT-GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79" class="sect6">Composite Partitioning</h6>
                        <div>
                           <p>In <span class="bold">composite partitioning</span>, a table is partitioned by one data distribution method and then each partition is further subdivided into subpartitions using a second data distribution method. Thus, composite partitioning combines the basic data distribution methods. All subpartitions for a given partition represent a logical subset of the data.
                           </p>
                           <p>Composite partitioning provides several advantages:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Depending on the SQL statement, partition pruning on one or two dimensions may improve performance.</p>
                              </li>
                              <li>
                                 <p>Queries may be able to use full or partial partition-wise joins on either dimension.</p>
                              </li>
                              <li>
                                 <p>You can perform parallel backup and recovery of a single table.</p>
                              </li>
                              <li>
                                 <p>The number of partitions is greater than in single-level partitioning, which may be beneficial for parallel execution.</p>
                              </li>
                              <li>
                                 <p>You can implement a rolling window to support historical data and still partition on another dimension if many statements can benefit from partition pruning or partition-wise joins.</p>
                              </li>
                              <li>
                                 <p>You can store data differently based on identification by a partitioning key. For example, you may decide to store data for a specific product type in a read-only, compressed format, and keep other product type data uncompressed.</p>
                              </li>
                           </ul>
                           <p>Range, list, and hash partitioning are eligible as subpartitioning strategies for composite partitioned tables. The following figure offers a graphical view of range-hash and range-list composite partitioning.</p>
                           <div class="figure" id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79__COMPOSITERANGE-LISTPARTITIONING-EC1E52A1">
                              <p class="titleinfigure">Figure 4-1 Composite Range-List Partitioning</p><img src="img/vldbg009.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows" longdesc="img_text/vldbg009.html"><br><a href="img_text/vldbg009.html">Description of "Figure 4-1 Composite Range-List Partitioning"</a></div>
                           <!-- class="figure" -->
                           <p>The database stores every subpartition in a composite partitioned table as a separate <a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">segment</span></a>. Thus, subpartition properties may differ from the properties of the table or from the partition to which the subpartitions belong. 
                           </p>
                           <div class="infoboxnotealso" id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79__ORACLEDATABASEVLDBANDPARTITIONINGGU-EC1E5EA6">
                              <p class="notep1">See Also:</p>
                              <p><a href="../vldbg/partition-concepts.html#GUID-BE424ACC-F746-4CA8-973C-F578CF98FF10" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn more about composite partitioning
                              </p>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1136"></a><div class="props_rev_3"><a id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649" name="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649"></a><h4 id="CNCPT-GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649" class="sect4">Partitioned Tables</h4>
                  <div>
                     <p>A <strong class="term">partitioned table</strong> consists of one or more partitions, which are managed individually and can operate independently of the other partitions.
                     </p>
                     <p>A table is either partitioned or nonpartitioned. Even if a partitioned table consists of only one partition, this table is different from a nonpartitioned table, which cannot have partitions added to it.</p>
                     <div class="infoboxnotealso" id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="partitions-views-and-other-schema-objects.html#GUID-E3C5EDAA-01F2-4077-915E-133045C43095" title="Each partition of a table or index must have the same logical attributes, such as column names, data types, and constraints.">Partition Characteristics</a>"</span> for examples of partitioned tables
                        </p>
                        <p><span class="q">"<a href="indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="An index-organized table is a table stored in a variation of a B-tree index structure. In contrast, a heap-organized table inserts rows where they fit.">Overview of Index-Organized Tables</a>"</span> to learn about the purpose and characteristics of Index-Organized Tables, which can also benefit from partitioning that provides improved manageability, availability, and performance. 
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57" name="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57"></a><h5 id="CNCPT-GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57" class="sect5">Segments for Partitioned Tables</h5>
                     <div>
                        <p>A partitioned table is made up of one or more table partition segments.</p>
                        <p>If you create a partitioned table named <code class="codeph">hash_products</code>, then no table <a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">segment</span></a> is allocated for this table. Instead, the database stores data for each table partition in its own partition segment. Each table partition segment contains a portion of the table data.
                        </p>
                        <p>When an <a href="glossary.html#GUID-1B18B978-29DD-4961-BD39-86838CB5F7D0"><span class="xrefglossterm">external table</span></a> is partitioned, all partitions reside outside the database. In a hybrid partitioned table, some partitions are stored in segments, whereas others are stored externally. For example, some partitions of the <code class="codeph">sales</code> table might be stored in data files and others in spreadsheets.
                        </p>
                        <div class="infoboxnotealso" id="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-97FC9DFF-A6CF-46CD-9F6F-D88A37C0E79C" title="An external table accesses data in external sources as if this data were in a table in the database.">Overview of External Tables</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="logical-storage-structures.html#GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" title="A segment is a set of extents that contains all the data for a logical storage structure within a tablespace.">Overview of Segments</a>"</span></p> to learn about the relationship between objects and segments
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76" name="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76"></a><h5 id="CNCPT-GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76" class="sect5">Compression for Partitioned Tables</h5>
                     <div>
                        <p>Some or all partitions of a heap-organized table can be stored in a compressed format.</p>
                        <p>Compression saves space and can speed query execution. For this reason, compression can be useful in environments such as data warehouses, where the amount of insert and update operations is small, and in OLTP environments.</p>
                        <p>You can declare the attributes for <a href="glossary.html#GUID-9C21768F-A722-47F1-B54C-5563BDA38074"><span class="xrefglossterm">table compression</span></a> for a tablespace, table, or table partition. If declared at the tablespace level, then tables created in the tablespace are compressed by default. You can alter the compression attribute for a table, in which case the change only applies to new data going into that table. Consequently, a single table or partition may contain compressed and uncompressed blocks, which guarantees that data size will not increase because of compression. If compression could increase the size of a block, then the database does not apply it to the block.
                        </p>
                        <div class="infoboxnotealso" id="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="tables-and-table-clusters.html#GUID-54EE5325-0894-4869-B3AD-8912D9B4A329" title="The database can use table compression to reduce the amount of storage required for the table.">Table Compression</a>"</span> to learn about types of table compression, including basic, advanced row, and Hybrid Columnar Compression
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG8913" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> to learn about table compression in a data warehouse
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT312"></a><div class="props_rev_3"><a id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7" name="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7"></a><h4 id="CNCPT-GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7" class="sect4">Partitioned Indexes</h4>
                  <div>
                     <p>A <strong class="term">partitioned index</strong> is an index that, like a partitioned table, has been divided into smaller and more manageable pieces.
                     </p>
                     <p>Global indexes are partitioned independently of the table on which they are created, whereas local indexes are automatically linked to the partitioning method for a table. Like partitioned tables, partitioned indexes improve manageability, availability, performance, and scalability.</p>
                     <p>The following graphic shows index partitioning options.</p>
                     <div class="figure" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-949D2696-9990-4E05-986A-4442C882B558">
                        <p class="titleinfigure">Figure 4-2 Index Partitioning Options</p><img src="img/cncpt301.gif" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows" longdesc="img_text/cncpt301.html"><br><a href="img_text/cncpt301.html">Description of "Figure 4-2 Index Partitioning Options"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-E9A650C9-525A-457B-B035-81EA4712229C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="indexes-and-index-organized-tables.html#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">Introduction to Indexes</a>"</span> to learn about the difference between unique and nonunique indexes, and the different index types
                              </p>
                           </li>
                           <li>
                              <p><a href="../vldbg/partition-concepts.html#VLDBG00203" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for more information about partitioned indexes and how to decide which type to use
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT88867"></a><a id="CNCPT88866"></a><a id="CNCPT1520"></a><div class="props_rev_3"><a id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" name="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF"></a><h5 id="CNCPT-GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" class="sect5">Local Partitioned Indexes</h5>
                     <div>
                        <p>In a <span class="bold">local partitioned index</span>, the index is partitioned on the same columns, with the same number of partitions and the same partition bounds as its table. 
                        </p>
                        <p>Each index partition is associated with exactly one partition of the underlying table, so that all keys in an index partition refer only to rows stored in a single table partition. In this way, the database automatically synchronizes index partitions with their associated table partitions, making each table-index pair independent.</p>
                        <p>Local partitioned indexes are common in data warehousing environments. Local indexes offer the following advantages:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Availability is increased because actions that make data invalid or unavailable in a partition affect this partition only.</p>
                           </li>
                           <li>
                              <p>Partition maintenance is simplified. When moving a table partition, or when data ages out of a partition, only the associated local index partition must be rebuilt or maintained. In a global index, all index partitions must be rebuilt or maintained.</p>
                           </li>
                           <li>
                              <p>If point-in-time recovery of a partition occurs, then the indexes can be recovered to the recovery time (see <span class="q">"<a href="concepts-for-database-administrators.html#GUID-7F5703F9-CAE5-4736-895B-B45A51974A7C" title="Data file recovery repairs a lost or damaged current data file or control file. It can also recover changes lost when a tablespace went offline without the OFFLINE NORMAL option.">Data File Recovery</a>"</span>). The entire index does not need to be rebuilt.
                              </p>
                           </li>
                        </ul>
                        <p>The example in <a href="partitions-views-and-other-schema-objects.html#GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" title="In hash partitioning, the database maps rows to partitions based on a hashing algorithm that the database applies to the user-specified partitioning key.">Hash Partitioning</a> shows the creation statement for the partitioned <code class="codeph">hash_sales</code> table, using the <code class="codeph">prod_id</code> column as partition key. The following example creates a local partitioned index on the <code class="codeph">time_id</code> column of the <code class="codeph">hash_sales</code> table:
                        </p><pre class="pre codeblock"><code>CREATE INDEX hash_sales_idx ON hash_sales(time_id) LOCAL;
</code></pre><p>In <a href="partitions-views-and-other-schema-objects.html#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">Figure 4-3</a>, the <code class="codeph">hash_products</code> table has two partitions, so <code class="codeph">hash_sales_idx</code> has two partitions. Each index partition is associated with a different table partition. Index partition <code class="codeph">SYS_P38</code> indexes rows in table partition <code class="codeph">SYS_P33</code>, whereas index partition <code class="codeph">SYS_P39</code> indexes rows in table partition <code class="codeph">SYS_P34</code>.
                        </p>
                        <div class="figure" id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">
                           <p class="titleinfigure">Figure 4-3 Local Index Partitions</p><img src="img/cncpt302.gif" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows" longdesc="img_text/cncpt302.html"><br><a href="img_text/cncpt302.html">Description of "Figure 4-3 Local Index Partitions"</a></div>
                        <!-- class="figure" -->
                        <p>You cannot explicitly add a partition to a local index. Instead, new partitions are added to local indexes only when you add a partition to the underlying table. Likewise, you cannot explicitly drop a partition from a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.</p>
                        <p>Like other indexes, you can create a <a href="glossary.html#GUID-20C91FE3-E7A0-44AC-8AC1-9C4301877B65"><span class="xrefglossterm">bitmap index</span></a> on partitioned tables. The only restriction is that bitmap indexes must be local to the partitioned table—they cannot be global indexes. Global bitmap indexes are supported only on nonpartitioned tables.
                        </p>
                     </div><a id="CNCPT88868"></a><div class="props_rev_3"><a id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F" name="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F"></a><h6 id="CNCPT-GUID-C83926F0-9AEA-4437-942C-9A80394DB63F" class="sect6">Local Prefixed and Nonprefixed Indexes</h6>
                        <div>
                           <p>Local partitioned indexes are either prefixed or nonprefixed.</p>
                           <p>The index subtypes are defined as follows:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Local prefixed indexes</p>
                                 <p>In this case, the partition keys are on the leading edge of the index definition. In the <code class="codeph">time_range_sales</code> example in <a href="partitions-views-and-other-schema-objects.html#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="In range partitioning, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.">Range Partitioning</a>, the table is partitioned by range on <code class="codeph">time_id</code>. A local prefixed index on this table would have <code class="codeph">time_id</code> as the first column in its list.
                                 </p>
                              </li>
                              <li>
                                 <p>Local nonprefixed indexes</p>
                                 <p>In this case, the partition keys are not on the leading edge of the indexed column list and need not be in the list at all. In the <code class="codeph">hash_sales_idx</code> example in <a href="partitions-views-and-other-schema-objects.html#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" title="In a local partitioned index, the index is partitioned on the same columns, with the same number of partitions and the same partition bounds as its table.">Local Partitioned Indexes</a>, the index is local nonprefixed because the partition key <code class="codeph">product_id</code> is not on the leading edge.
                                 </p>
                              </li>
                           </ul>
                           <p>Both types of indexes can take advantage of <a href="glossary.html#GUID-17D46EB4-6C99-419E-86D7-91C4370BE8BF"><span class="xrefglossterm">partition elimination</span></a> (also called <span class="italic">partition pruning</span>), which occurs when the optimizer speeds data access by excluding partitions from consideration. Whether a <a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">query</span></a> can eliminate partitions depends on the query <a href="glossary.html#GUID-891CF9E9-78CD-470C-9C4A-D65A101B2C38"><span class="xrefglossterm">predicate</span></a>. A query that uses a local prefixed index always allows for index partition elimination, whereas a query that uses a local nonprefixed index might not.
                           </p>
                           <div class="infoboxnotealso" id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F__GUID-691674B7-CCA0-4CE4-A78C-7EFEC8993E2B">
                              <p class="notep1">See Also:</p>
                              <p><a href="../vldbg/index-partitioning.html#VLDBG1251" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to use prefixed and nonprefixed indexes
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT88869"></a><div class="props_rev_3"><a id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277" name="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277"></a><h6 id="CNCPT-GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277" class="sect6">Local Partitioned Index Storage</h6>
                        <div>
                           <p>Like a table partition, a local index partition is stored in its own segment. Each segment contains a portion of the total index data. Thus, a local index made up of four partitions is not stored in a single index segment, but in four separate segments.</p>
                           <div class="infoboxnotealso" id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277__GUID-A58D2412-6CA0-4982-8145-2A2B837F95D5">
                              <p class="notep1">See Also:</p>
                              <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF54053" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE INDEX ... LOCAL</code> examples
                              </p>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT88870"></a><a id="CNCPT89164"></a><a id="CNCPT1521"></a><div class="props_rev_3"><a id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB" name="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB"></a><h5 id="CNCPT-GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB" class="sect5">Global Partitioned Indexes</h5>
                     <div>
                        <p>A <span class="bold">global partitioned index</span> is a B-tree index that is partitioned independently of the underlying table on which it is created. A single index partition can point to any or all table partitions, whereas in a locally partitioned index, a one-to-one parity exists between index partitions and table partitions.
                        </p>
                        <p>In general, global indexes are useful for OLTP applications, where rapid access, data integrity, and availability are important. In an OLTP system, a table may be partitioned by one key, for example, the <code class="codeph">employees.department_id</code> column, but an application may need to access the data with many different keys, for example, by <code class="codeph">employee_id</code> or <code class="codeph">job_id</code>. Global indexes can be useful in this scenario.
                        </p>
                        <p>As an illustration, suppose that you create a global partitioned index on the <code class="codeph">time_range_sales</code> table from <span class="q">"<a href="partitions-views-and-other-schema-objects.html#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="In range partitioning, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.">Range Partitioning</a>"</span>. In this table, rows for sales from 1998 are stored in one partition, rows for sales from 1999 are in another, and so on. The following example creates a global index partitioned by range on the <code class="codeph">channel_id</code> column:
                        </p><pre class="pre codeblock"><code>CREATE INDEX time_channel_sales_idx ON time_range_sales (<span class="bold">channel_id</span>)
   GLOBAL PARTITION BY RANGE (<span class="bold">channel_id</span>)
      (PARTITION p1 VALUES LESS THAN (3),
       PARTITION p2 VALUES LESS THAN (4),
       PARTITION p3 VALUES LESS THAN (MAXVALUE));
</code></pre><p>As shown in <a href="partitions-views-and-other-schema-objects.html#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">Figure 4-4</a>, a global index partition can contain entries that point to multiple table partitions. Index partition <code class="codeph">p1</code> points to the rows with a <code class="codeph">channel_id</code> of 2, index partition <code class="codeph">p2</code> points to the rows with a <code class="codeph">channel_id</code> of 3, and index partition <code class="codeph">p3</code> points to the rows with a <code class="codeph">channel_id</code> of 4 or 9. 
                        </p>
                        <div class="figure" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">
                           <p class="titleinfigure">Figure 4-4 Global Partitioned Index</p><img src="img/cncpt300.gif" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows" longdesc="img_text/cncpt300.html"><br><a href="img_text/cncpt300.html">Description of "Figure 4-4 Global Partitioned Index"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__GUID-5B2F1E5D-76C6-40AB-AD1C-556AE76689C5">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../vldbg/index-partitioning.html#VLDBG1256" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to manage global partitioned indexes
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF54012" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">GLOBAL PARTITION</code> clause of <code class="codeph">CREATE INDEX</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89215"></a><a id="CNCPT89298"></a><div class="props_rev_3"><a id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316" name="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316"></a><h4 id="CNCPT-GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316" class="sect4">Partial Indexes for Partitioned Tables</h4>
                  <div>
                     <p>A <strong class="term">partial index</strong> is an index that is correlated with the indexing properties of an associated partitioned table.
                     </p>
                     <p>The correlation enables you to specify which table partitions are indexed. Partial indexes provide the following advantages:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Table partitions that are not indexed avoid consuming unnecessary index storage space.</p>
                        </li>
                        <li>
                           <p>Performance of loads and queries can improve.</p>
                           <p>Before <span>Oracle Database 12c</span>, an exchange partition operation required a physical update of an associated global index to retain it as usable. Starting with <span>Oracle Database 12c</span>, if the partitions involved in a partition maintenance operation are not part of a partial global index, then the index remains usable without requiring any global index maintenance.
                           </p>
                        </li>
                        <li>
                           <p>If you index only some table partitions at index creation, and if you later index other partitions, then you can reduce the sort space required by index creation.</p>
                        </li>
                     </ul>
                     <p>You can turn indexing on or off for the individual partitions of a table. A partial local index does not have usable index partitions for all table partitions that have indexing turned off. A global index, whether partitioned or not, excludes the data from all partitions that have indexing turned off. The database does not support partial indexes for indexes that enforce unique constraints.</p>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">Figure 4-5</a> shows the same global index as in <a href="partitions-views-and-other-schema-objects.html#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">Figure 4-4</a>, except that the global index is partial. Table partitions <code class="codeph">SALES_1998</code> and <code class="codeph">SALES_2000</code> have the indexing property set to <code class="codeph">OFF</code>, so the partial global index does not index them.
                     </p>
                     <div class="figure" id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">
                        <p class="titleinfigure">Figure 4-5 Partial Global Partitioned Index</p><img src="img/cncpt342.png" alt="Description of Figure 4-5 follows" title="Description of Figure 4-5 follows" longdesc="img_text/cncpt342.html"><br><a href="img_text/cncpt342.html">Description of "Figure 4-5 Partial Global Partitioned Index"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" name="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16"></a><h3 id="CNCPT-GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" class="sect3">Overview of Sharded Tables</h3>
               <div>
                  <p>In an Oracle database, sharding enables you to break up a large table into more manageable pieces called shards that can be stored in multiple databases. </p>
                  <p>Each <span>database is hosted on dedicated server with its own local resources - CPU, memory, flash, or disk.</span> <span>Each database in such configuration is called a <strong class="term">shard</strong>.</span> <span>All of the shards together make up a single logical database, which is referred to as a <strong class="term">sharded database (SDB)</strong>.</span></p>
                  <p><span>Horizontal partitioning involves splitting a database table across shards so that each shard contains the table with the same columns but a different subset of rows. A table split up in this manner is also known as a <span class="italic">sharded table</span>.</span></p>
                  <p>The following figure shows a table horizontally partitioned across three shards.</p>
                  <div class="figure" id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__GUID-4242B296-023B-4842-981C-DFE75CA2E713">
                     <p class="titleinfigure">Figure 4-6 Horizontal Partitioning of a Table Across Shards</p><img id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__IMAGE_CJZ_5VC_KGB" src="img/admin_3v_134a.png" alt="Description of Figure 4-6 follows" title="Description of Figure 4-6 follows" longdesc="img_text/admin_3v_134a.html"><br><a href="img_text/admin_3v_134a.html">Description of "Figure 4-6 Horizontal Partitioning of a Table Across Shards"</a></div>
                  <!-- class="figure" -->
                  <p>Sharding is based on shared-nothing hardware infrastructure and it eliminates single points of failure because shards do not share physical resources such as CPU, memory, or storage devices. Shards are also loosely coupled in terms of software; they do not run clusterware.</p>
                  <p>Shards are typically hosted on dedicated servers. These servers can be commodity hardware or engineered systems. The shards can run on single instance or Oracle RAC databases. They can be placed on-premises, in a cloud, or in a hybrid on-premises and cloud configuration.</p>
                  <p>From the perspective of a database administrator, an SDB consists of multiple databases that can be managed either collectively or individually. However, from the perspective of the application, an SDB looks like a single database: the number of shards and distribution of data across those shards are completely transparent to database applications.</p>
                  <p>Sharding is intended for custom OLTP applications that are suitable for a sharded database architecture. Applications that use sharding must have a well-defined data model and data distribution strategy (consistent hash, range, list, or composite) that primarily accesses data using a sharding key. Examples of a sharding key include <code class="codeph">customer_id</code>, <code class="codeph">account_no</code>, or <code class="codeph">country_id</code>.
                  </p>
                  <div class="infoboxnotealso" id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__GUID-37255C2A-55CF-45E9-B526-079589A1CC27">
                     <p class="notep1">See Also:</p>
                     <p><a href="../shard/sharding-overview.html#SHARD-GUID-0F39B1FB-DCF9-4C8A-A2EA-88705B90C5BF" target="_blank"><span><cite>Using Oracle Sharding</cite></span></a></p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" name="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3"></a><h4 id="CNCPT-GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" class="sect4">Sharded Tables</h4>
                  <div>
                     <p>A sharded table is a table that is partitioned into smaller and more manageable pieces among multiple databases, called shards.</p>
                     <p>Key benefits of sharding include:</p>
                     <ul style="list-style-type: disc;" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_VLV_C1D_KGB">
                        <li>
                           <p><span class="bold">Linear Scalability</span>. Sharding eliminates performance bottlenecks and makes it possible to linearly scale performance and capacity by adding shards.
                           </p>
                        </li>
                        <li>
                           <p> <span class="bold">Fault Containment</span>. Sharding is a shared nothing hardware infrastructure that eliminates single points of failure, such as shared disk, SAN, and clusterware, and provides strong fault isolation—the failure or slow-down of one shard does not affect the performance or availability of other shards.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Geographical Distribution of Data</span>. Sharding makes it possible to store particular data close to its consumers and satisfy regulatory requirements when data must be located in a particular jurisdiction.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Rolling Upgrades</span>. Applying configuration changes on one shard at a time does not affect other shards, and allows administrators to first test the changes on a small subset of data.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Simplicity of Cloud Deployment</span>. Sharding is well suited to deployment in the cloud. Shards may be sized as required to accommodate whatever cloud infrastructure is available and still achieve required service levels. Oracle Sharding supports on-premises, cloud, and hybrid deployment models.
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FEA6F86B-09E1-4DF5-A5DE-B980A45DFBB9">Shard Architecture</p>
                        <p>Applications perceive the pool of databases as a single logical database. Applications can elastically scale data, transactions, and users to any level, on any platform, by adding databases (shards) to the pool. Oracle Database supports scaling up to 1000 shards.</p>
                        <p>The following figure illustrates the major architectural components of Oracle Sharding:</p>
                        <ul style="list-style-type: disc;" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_NDW_M1D_KGB">
                           <li>
                              <p>Sharded database (SDB) &#x2013; a single logical Oracle Database that is horizontally partitioned across a pool of physical Oracle Databases (shards) that share no hardware or software</p>
                           </li>
                           <li>
                              <p>Shards - independent physical Oracle databases that host a subset of the sharded database</p>
                           </li>
                           <li>
                              <p>Global service - database services that provide access to data in an SDB</p>
                           </li>
                           <li>
                              <p>Shard catalog &#x2013; an Oracle Database that supports automated shard deployment, centralized management of a sharded database, and multi-shard queries</p>
                           </li>
                           <li>
                              <p>Shard directors &#x2013; network listeners that enable high performance connection routing based on a sharding key</p>
                           </li>
                           <li>
                              <p>Connection pools - at runtime, act as shard directors by routing database requests across pooled connections</p>
                           </li>
                           <li>
                              <p>Management interfaces - GDSCTL (command-line utility) and Oracle Enterprise Manager (GUI)</p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-65F25F7E-0A7B-4DC2-8B45-21DE4055DFA2">
                           <p class="titleinfigure">Figure 4-7 Oracle Sharding Architecture</p><img id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__IMAGE_ODW_M1D_KGB" src="img/admin_3v_143d.png" alt="Description of Figure 4-7 follows" title="Description of Figure 4-7 follows" longdesc="img_text/admin_3v_143d.html"><br><a href="img_text/admin_3v_143d.html">Description of "Figure 4-7 Oracle Sharding Architecture"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-628DEA40-7CAF-4662-9BD5-799AB25D68BA">Sharding and Partitioning</p>
                        <p>Oracle Sharding is essentially distributed partitioning because it extends partitioning by supporting the distribution of table partitions across shards.</p>
                        <p>Partitions are distributed across shards at the tablespace level, based on a sharding key. Examples of keys include customer ID, account number, and country ID. The following data types are supported for the sharding key:</p>
                        <ul style="list-style-type: disc;" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_OHB_5ZC_KGB">
                           <li>
                              <p><code class="codeph">NUMBER</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INTEGER</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SMALLINT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">RAW</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">(N)VARCHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">(N)VARCHAR2</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">(N)CHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DATE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP</code></p>
                           </li>
                        </ul>
                        <p>Each partition of a sharded table resides in a separate tablespace, and each tablespace is associated with a specific shard. Depending on the sharding method, the association can be established automatically or defined by the administrator.</p>
                        <p>Even though the partitions of a sharded table reside in multiple shards, to the application, the table looks and behaves exactly the same as a partitioned table in a single database. SQL statements issued by an application never have to refer to shards or depend on the number of shards and their configuration.</p>
                        <p></p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FA524CC9-8238-40D6-AA6A-BAFC7E5A93C1">
                        <p class="titleinexample">Example 4-5 Sharded Table</p>
                        <p>The familiar SQL syntax for table partitioning specifies how rows should be partitioned across shards. For example, the following SQL statement creates a sharded table, horizontally partitioning the table across shards based on sharding key <code class="codeph">cust_id</code>:
                        </p><pre class="pre codeblock"><code>CREATE SHARDED TABLE customers 
( cust_id     NUMBER NOT NULL
, name        VARCHAR2(50)
, address     VARCHAR2(250)
, region      VARCHAR2(20)
, class       VARCHAR2(3)
, signup      DATE
CONSTRAINT cust_pk PRIMARY KEY(cust_id)
)
PARTITION BY CONSISTENT HASH (cust_id)
PARTITIONS AUTO
TABLESPACE SET ts1
;</code></pre><p>The preceding table is partitioned by consistent hash, a special type of hash partitioning commonly used in scalable distributed systems. This technique automatically spreads tablespaces across shards to provide an even distribution of data and workload. Note that global indexes on sharded tables are not supported, but local indexes are supported.</p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-49480A54-1E79-4E26-983D-3566D39B7EB5">Tablespace Sets</p>
                        <p>Oracle Sharding creates and manages tablespaces as a unit called a <strong class="term">tablespace set</strong>. The <code class="codeph">PARTITIONS AUTO</code> clause specifies that the number of partitions should be automatically determined. This type of hashing provides more flexibility and efficiency in migrating data between shards, which is important for elastic scalability.
                        </p>
                        <p>A tablespace is a logical unit of data distribution in an SDB. The distribution of partitions across shards is achieved by automatically creating partitions in tablespaces that reside on different shards. To minimize the number of multi-shard joins, the corresponding partitions of related tables are always stored in the same shard. Each partition of a sharded table is stored in a separate tablespace.</p>
                        <div class="infoboxnote" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-A6E8D269-524F-453D-8E43-2730AEAF190B">
                           <p class="notep1">Note:</p>
                           <p>Only Oracle Managed Files are supported by tablespace sets.</p>
                           <p>Individual tablespaces cannot be dropped or altered independently of the entire tablespace set.</p>
                           <p><code class="codeph">TABLESPACE SET</code> cannot be used with the user-defined sharding method.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="introduction-to-oracle-database.html#GUID-8F1E6C26-A65A-4D62-B236-BFE3DA6CD43F" title="Oracle Sharding is a database scaling technique based on horizontal partitioning of data across multiple Oracle databases. Applications perceive the pool of databases as a single logical database.">Sharding Architecture</a></li>
                           <li><a href="../shard/sharding-overview.html#SHARD-GUID-0F39B1FB-DCF9-4C8A-A2EA-88705B90C5BF" target="_blank"><span><cite>Using Oracle Sharding</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="CNCPT88871"></a><a id="CNCPT311"></a><div class="props_rev_3"><a id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" name="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5"></a><h3 id="CNCPT-GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" class="sect3">Overview of Views</h3>
               <div>
                  <p>A <span class="bold">view</span> is a logical representation of one or more tables. In essence, a view is a stored query. 
                  </p>
                  <p>A view derives its data from the tables on which it is based, called <span class="italic">base tables</span>. Base tables can be tables or other views. All operations performed on a view actually affect the base tables. You can use views in most places where tables are used.
                  </p>
                  <div class="infoboxnote" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-7E33B4D0-E237-4051-A508-011502739BC5">
                     <p class="notep1">Note:</p>
                     <p>Materialized views use a different data structure from standard views.</p>
                  </div>
                  <p>Views enable you to tailor the presentation of data to different types of users. Views are often used to:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Provide an additional level of table security by restricting access to a predetermined set of rows or columns of a table </p>
                        <p>For example, <a href="partitions-views-and-other-schema-objects.html#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">Figure 4-8</a> shows how the <code class="codeph">staff</code> view does not show the <code class="codeph">salary</code> or <code class="codeph">commission_pct</code> columns of the base table <code class="codeph">employees</code>. 
                        </p>
                     </li>
                     <li>
                        <p>Hide data complexity</p>
                        <p>For example, a single view can be defined with a <a href="glossary.html#GUID-71A4D429-D0A6-4979-AACA-EDE5F4BCFC8B"><span class="xrefglossterm">join</span></a>, which is a collection of related columns or rows in multiple tables. However, the view hides the fact that this information actually originates from several tables. A query might also perform extensive calculations with table information. Thus, users can query a view without knowing how to perform a join or calculations. 
                        </p>
                     </li>
                     <li>
                        <p>Present the data in a different perspective from that of the base table </p>
                        <p>For example, the columns of a view can be renamed without affecting the tables on which the view is based. </p>
                     </li>
                     <li>
                        <p>Isolate applications from changes in definitions of base tables</p>
                        <p>For example, if the defining query of a view references three columns of a four column table, and a fifth column is added to the table, then the definition of the view is not affected, and all applications using the view are not affected.</p>
                     </li>
                  </ul>
                  <p>For an example of the use of views, consider the <code class="codeph">hr.employees</code> table, which has several columns and numerous rows. To allow users to see only five of these columns or only specific rows, you could create a view as follows:
                  </p><pre class="pre codeblock"><code>CREATE VIEW staff AS
  SELECT employee_id, last_name, job_id, manager_id, department_id
  FROM   employees;
</code></pre><p>As with all subqueries, the query that defines a view cannot contain the <code class="codeph">FOR UPDATE</code> clause. The following graphic illustrates the view named <code class="codeph">staff</code>. Notice that the view shows only five of the columns in the base table.
                  </p>
                  <div class="figure" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">
                     <p class="titleinfigure">Figure 4-8 View</p><img src="img/cncpt045.gif" alt="Description of Figure 4-8 follows" title="Description of Figure 4-8 follows" longdesc="img_text/cncpt045.html"><br><a href="img_text/cncpt045.html">Description of "Figure 4-8 View"</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-E83635A7-C789-413E-954F-8BE44F222B84">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="A materialized view is a query result that has been stored or "materialized" in advance as a schema object. The FROM clause of the query can name tables, views, or materialized views.">Overview of Materialized Views</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11774" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage views
                           </p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/CREATE-VIEW.html#SQLRF01504" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE VIEW</code> syntax and semantics
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT1145"></a><div class="props_rev_3"><a id="GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586" name="GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586"></a><h4 id="CNCPT-GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586" class="sect4">Characteristics of Views</h4>
                  <div>
                     <p>Unlike a table, a view is not allocated storage space, nor does a view contain data. Rather, a view is defined by a query that extracts or derives data from the base tables referenced by the view. Because a view is based on other objects, it requires no storage other than storage for the query that defines the view in the data dictionary.</p>
                     <p>A view has dependencies on its referenced objects, which are automatically handled by the database. For example, if you drop and re-create a base table of a view, then the database determines whether the new base table is acceptable to the view definition.</p>
                  </div><a id="CNCPT88872"></a><div class="props_rev_3"><a id="GUID-322500BA-F86A-4C80-834F-7AD46C921817" name="GUID-322500BA-F86A-4C80-834F-7AD46C921817"></a><h5 id="CNCPT-GUID-322500BA-F86A-4C80-834F-7AD46C921817" class="sect5">Data Manipulation in Views</h5>
                     <div>
                        <p>Because views are derived from tables, they have many similarities. Users can query views, and with some restrictions they can perform DML on views. Operations performed on a view affect data in some base table of the view and are subject to the integrity constraints and triggers of the base tables.</p>
                        <p>The following example creates a view of the <code class="codeph">hr.employees</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW staff_dept_10 AS
SELECT employee_id, last_name, job_id, 
       manager_id, department_id
FROM   employees
WHERE  department_id = 10
WITH CHECK OPTION CONSTRAINT staff_dept_10_cnst;
</pre><p>The defining query references only rows for department 10. The <code class="codeph">CHECK OPTION</code> creates the view with a constraint so that <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> statements issued against the view cannot result in rows that the view cannot select. Thus, rows for employees in department 10 can be inserted, but not rows for department 30.
                        </p>
                        <div class="infoboxnotealso" id="GUID-322500BA-F86A-4C80-834F-7AD46C921817__GUID-F5A74FC6-EDB3-48B9-9564-172C45D76F62">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/SELECT.html#SQLRF55299" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about subquery restrictions in <code class="codeph">CREATE VIEW</code> statements
                           </p>
                        </div>
                     </div>
                  </div><a id="CNCPT1147"></a><div class="props_rev_3"><a id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A" name="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A"></a><h5 id="CNCPT-GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A" class="sect5">How Data Is Accessed in Views</h5>
                     <div>
                        <p>Oracle Database stores a view definition in the data dictionary as the text of the query that defines the view.</p>
                        <p>When you reference a view in a SQL statement, Oracle Database performs the following tasks:</p>
                        <ol>
                           <li>
                              <p>Merges a query (whenever possible) against a view with the queries that define the view and any underlying views</p>
                              <p>Oracle Database optimizes the merged query as if you issued the query without referencing the views. Therefore, Oracle Database can use indexes on any referenced base table columns, whether the columns are referenced in the view definition or in the user query against the view. </p>
                              <p>Sometimes Oracle Database cannot merge the view definition with the user query. In such cases, Oracle Database may not use all indexes on referenced columns.</p>
                           </li>
                           <li>
                              <p>Parses the merged statement in a <a href="glossary.html#GUID-E0BE3164-B0A9-4ED8-AD19-2048ADFFC9BB"><span class="xrefglossterm">shared SQL area</span></a></p>
                              <p>Oracle Database parses a statement that references a view in a new shared SQL area <span class="italic">only</span> if no existing shared SQL area contains a similar statement. Thus, views provide the benefit of reduced memory use associated with shared SQL.
                              </p>
                           </li>
                           <li>
                              <p>Executes the SQL statement</p>
                           </li>
                        </ol>
                        <p>The following example illustrates data access when a view is queried. Assume that you create <code class="codeph">employees_view</code> based on the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables:
                        </p><pre class="pre codeblock"><code>CREATE VIEW employees_view AS 
  SELECT employee_id, last_name, salary, location_id
  FROM   employees JOIN departments USING (department_id)
  WHERE  department_id = 10; 
</code></pre><p>A user executes the following query of <code class="codeph">employees_view</code>: 
                        </p><pre class="pre codeblock"><code>SELECT last_name 
FROM   employees_view
WHERE  employee_id = 200;
</code></pre><p>Oracle Database merges the view and the user query to construct the following query, which it then executes to retrieve the data:</p><pre class="pre codeblock"><code>SELECT last_name
FROM   employees, departments
WHERE  employees.department_id = departments.department_id 
AND    departments.department_id = 10 
AND    employees.employee_id = 200;</code></pre><div class="infoboxnotealso" id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A__GUID-FA88DF34-4E10-4C30-B024-91266535E864">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" title="The database represents each SQL statement that it runs in the shared SQL area and private SQL area.">Shared SQL Areas</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../tgsql/query-optimizer-concepts.html#TGSQL193" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> to learn about query optimization
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT88873"></a><a id="CNCPT1151"></a><div class="props_rev_3"><a id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA" name="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA"></a><h4 id="CNCPT-GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA" class="sect4">Updatable Join Views</h4>
                  <div>
                     <p>A <strong class="term">join view</strong> has multiple tables or views in its <code class="codeph">FROM</code> clause.
                     </p>
                     <p>In the following example, the <code class="codeph">staff_dept_10_30</code> view joins the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables, including only employees in departments 10 or 30:
                     </p><pre class="pre codeblock"><code>CREATE VIEW staff_dept_10_30 AS
SELECT employee_id, last_name, job_id, e.department_id
FROM   employees e, departments d
WHERE  e.department_id IN (10, 30)
AND    e.department_id = d.department_id;
</code></pre><p>An <a href="glossary.html#GUID-F510D35A-83C5-4974-B6F0-5E4073F73DE1"><span class="xrefglossterm">updatable join view</span></a>, also called a <span class="italic">modifiable join view</span>, involves two or more base tables or views and permits DML operations. An updatable view contains multiple tables in the top-level <code class="codeph">FROM</code> clause of the <code class="codeph">SELECT</code> statement and is not restricted by the <code class="codeph">WITH READ ONLY</code> clause.
                     </p>
                     <p>To be inherently updatable, a view must meet several criteria. For example, a general rule is that an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> operation on a join view can modify only one base table at a time. The following query of the <code class="codeph">USER_UPDATABLE_COLUMNS</code> data dictionary view shows that  the <code class="codeph">staff_dept_10_30</code> view is updatable:
                     </p><pre class="pre codeblock"><code>SQL&gt; SELECT TABLE_NAME, COLUMN_NAME, UPDATABLE 
  2  FROM   USER_UPDATABLE_COLUMNS 
  3  WHERE  TABLE_NAME = 'STAFF_DEPT_10_30';
 
TABLE_NAME                     COLUMN_NAME                    UPD
------------------------------ ------------------------------ ---
STAFF_DEPT_10_30               EMPLOYEE_ID                    YES
STAFF_DEPT_10_30               LAST_NAME                      YES
STAFF_DEPT_10_30               JOB_ID                         YES
STAFF_DEPT_10_30               DEPARTMENT_ID                  YES
</code></pre><p>All updatable columns of a join view must map to columns of a <a href="glossary.html#GUID-481043B7-88C3-4492-8949-68ECE8077702"><span class="xrefglossterm">key-preserved table</span></a>, which is a table in which each row of the underlying table appears at most one time in the query output. In  the <code class="codeph">staff_dept_10_30</code> view, <code class="codeph">department_id</code> is the primary key of the <code class="codeph">departments</code> table, so each row from the <code class="codeph">employees</code> table appears at most once in the result set, making the <code class="codeph">employees</code> table key-preserved. The <code class="codeph">departments</code> table is not key-preserved because each of its rows may appear many times in the result set.
                     </p>
                     <div class="infoboxnotealso" id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA__GUID-871DBA67-313B-456B-B688-763137512B0F">
                        <p class="notep1">See Also:</p>
                        <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11782" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to update join views
                        </p>
                     </div>
                  </div>
               </div><a id="CNCPT1152"></a><div class="props_rev_3"><a id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F" name="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F"></a><h4 id="CNCPT-GUID-15BCE53C-7A32-40B9-923F-151DABF4647F" class="sect4">Object Views</h4>
                  <div>
                     <p>Just as a view is a virtual table, an <span class="bold">object view</span> is a virtual object table. Each row in the view is an object, which is an instance of an <span class="bold">object type</span>. An object type is a user-defined data type.
                     </p>
                     <p>You can retrieve, update, insert, and delete relational data as if it were stored as an object type. You can also define views with columns that are object data types, such as objects, <code class="codeph">REF</code>s, and collections (nested tables and <code class="codeph">VARRAY</code>s).
                     </p>
                     <p>Like relational views, object views can present only the data that database administrators want users to see. For example, an object view could present data about IT programmers but omit sensitive data about salaries. The following example creates an <code class="codeph">employee_type</code> object and then the view <code class="codeph">it_prog_view</code> based on this object:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee_type AS OBJECT
(
  employee_id  NUMBER (6),
  last_name    VARCHAR2 (25),
  job_id       VARCHAR2 (10)
);
/

CREATE VIEW it_prog_view OF employee_type
  WITH OBJECT IDENTIFIER (employee_id) AS 
SELECT  e.employee_id, e.last_name, e.job_id
FROM    employees e
WHERE   job_id = 'IT_PROG';
</pre><p>Object views are useful in prototyping or transitioning to object-oriented applications because the data in the view can be taken from relational tables and accessed as if the table were defined as an object table. You can run object-oriented applications without converting existing tables to a different physical structure.</p>
                     <div class="infoboxnotealso" id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F__GUID-27CDE188-60BC-4A5D-A834-04C427FD4DE2">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../adobj/key-features-object-relational-model.html#ADOBJ7026" target="_blank"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> to learn about object types and object views
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TYPE.html#SQLRF01506" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code class="codeph">CREATE TYPE</code> statement
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT88874"></a><a id="CNCPT411"></a><div class="props_rev_3"><a id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" name="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829"></a><h3 id="CNCPT-GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" class="sect3">Overview of Materialized Views</h3>
               <div>
                  <p>A <strong class="term">materialized view</strong> is a query result that has been stored or "materialized" in advance as a schema object. The <code class="codeph">FROM</code> clause of the query can name tables, views, or materialized views.
                  </p>
                  <p>A materialized view often serves as a <a href="glossary.html#GUID-9C63F1D2-89B7-4AAF-B10F-325A82078B76"><span class="xrefglossterm">master table</span></a> in <a href="glossary.html#GUID-A011519D-7113-462D-B9A5-9BAC31E50B8D"><span class="xrefglossterm">replication</span></a> and a <a href="glossary.html#GUID-B6DD258C-FFA5-4CDC-B5FB-98B3B9F20F99"><span class="xrefglossterm">fact table</span></a> in data warehousing. Materialized views summarize, compute, replicate, and distribute data. They are suitable in various computing environments, such as the following:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>In data warehouses, materialized views can compute and store data generated from aggregate functions such as sums and averages.</p>
                        <p>A <a href="glossary.html#GUID-6952CA8E-DB69-4C4B-887F-9624565B1835"><span class="xrefglossterm">summary</span></a> is an aggregate view that reduces query time by precalculating joins and aggregation operations and storing the results in a table. Materialized views are equivalent to summaries. You can also use materialized views to compute joins with or without aggregations.
                        </p>
                     </li>
                     <li>
                        <p>In materialized view replication, which is achieved using XStream and Oracle GoldenGate, the view contains a complete or partial copy of a table from a single point in time. Materialized views replicate data at distributed sites and synchronize updates performed at several sites. This form of replication is suitable for environments such as field sales when databases are not always connected to the network.</p>
                     </li>
                     <li>
                        <p>In mobile computing environments, materialized views can download a data subset from central servers to mobile clients, with periodic refreshes from the central servers and propagation of updates by clients to the central servers.</p>
                     </li>
                  </ul>
                  <p>In a replication environment, a materialized view shares data with a table in a different database, called a <a href="glossary.html#GUID-DC13C5A2-6D35-4169-B546-C8B8AC393163"><span class="xrefglossterm">master database</span></a>. The table associated with the materialized view at the master site is the master table. <a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">Figure 4-9</a> illustrates a materialized view in one database based on a master table in another database. Updates to the master table replicate to the materialized view database.
                  </p>
                  <div class="figure" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">
                     <p class="titleinfigure">Figure 4-9 Materialized View</p><img src="img/cncpt260.gif" alt="Description of Figure 4-9 follows" title="Description of Figure 4-9 follows" longdesc="img_text/cncpt260.html"><br><a href="img_text/cncpt260.html">Description of "Figure 4-9 Materialized View"</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__GUID-00B3BCAB-1185-4782-820B-AF1B8E4E9BD9">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="topics-for-database-administrators-and-developers.html#GUID-1E03C284-42EE-4542-AB79-A966AD7BEA47" title="At the heart of any integration is the sharing of data among applications in the enterprise.">Information Sharing</a>"</span> to learn about replication with XStream and Oracle GoldenGate
                           </p>
                        </li>
                        <li>
                           <p> <span class="q">"<a href="topics-for-database-administrators-and-developers.html#GUID-8B11C762-AF20-4B7A-A95B-D5423FE7B646" title="In a simple data warehouse architecture, end users directly access data that was transported from several source systems to the data warehouse.">Data Warehouse Architecture (Basic)</a>"</span> to learn more about summaries
                           </p>
                        </li>
                        <li>
                           <p><a href="../xstrm/introduction-to-xstream.html#GUID-5939CB6C-8BA9-4594-8F96-B0453D246722" target="_blank"><span><cite>Oracle Database XStream Guide</cite></span></a> for an introduction to XStream
                           </p>
                        </li>
                        <li>
                           <p><a href="http://www.oracle.com/technetwork/middleware/goldengate/documentation/index.html" target="_blank"><code class="codeph">http://www.oracle.com/technetwork/middleware/goldengate/documentation/index.html</code></a> to learn more about Oracle GoldenGate
                           </p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF01302" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT88875"></a><div class="props_rev_3"><a id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193" name="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193"></a><h4 id="CNCPT-GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193" class="sect4">Characteristics of Materialized Views</h4>
                  <div>
                     <p>Materialized views share some characteristics of indexes and nonmaterialized views.</p>
                     <p>Materialized views are similar to indexes in the following ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>They contain actual data and consume storage space.</p>
                        </li>
                        <li>
                           <p>They can be refreshed when the data in their master tables changes.</p>
                        </li>
                        <li>
                           <p>They can improve performance of SQL execution when used for query rewrite operations.</p>
                        </li>
                        <li>
                           <p>Their existence is transparent to SQL applications and users. </p>
                        </li>
                     </ul>
                     <p>A materialized view is similar to a nonmaterialized view because it represents data in other tables and views. Unlike indexes, users can query materialized views directly using <code class="codeph">SELECT</code> statements. Depending on the types of refresh that are required, the views can also be updated with DML statements.
                     </p>
                     <p>The following example creates and populates a materialized aggregate view based on three master tables in the <code class="codeph">sh</code> sample schema:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_mv AS 
  SELECT t.calendar_year, p.prod_id, SUM(s.amount_sold) AS sum_sales
  FROM   times t, products p, sales s
  WHERE  t.time_id = s.time_id 
  AND    p.prod_id = s.prod_id
  GROUP BY t.calendar_year, p.prod_id;
</pre><p>The following example drops table <code class="codeph">sales</code>, which is a master table for <code class="codeph">sales_mv</code>, and then queries <code class="codeph">sales_mv</code>. The query selects data because the rows are stored (materialized) separately from the data in the master tables.
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; DROP TABLE sales;

Table dropped.

SQL&gt; SELECT * FROM sales_mv WHERE ROWNUM &lt; 4;
 
CALENDAR_YEAR    PROD_ID  SUM_SALES
------------- ---------- ----------
         1998         13  936197.53
         1998         26  567533.83
         1998         27  107968.24
</pre><p>A materialized view can be partitioned. You can define a materialized view on a partitioned table and one or more indexes on the materialized view.</p>
                     <div class="infoboxnotealso" id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193__GUID-37CC358F-64EF-4BCF-ADAD-AFB8DFA770ED">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=DWHSG008" target="_blank"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to use materialized views in a data warehouse
                        </p>
                     </div>
                  </div>
               </div><a id="CNCPT1155"></a><div class="props_rev_3"><a id="GUID-824BEF3A-193B-4A72-894A-105F0AEAD607" name="GUID-824BEF3A-193B-4A72-894A-105F0AEAD607"></a><h4 id="CNCPT-GUID-824BEF3A-193B-4A72-894A-105F0AEAD607" class="sect4">Refresh Methods for Materialized Views</h4>
                  <div>
                     <p>The database maintains data in materialized views by refreshing them after changes to the base tables. The refresh method can be incremental or a complete refresh. </p>
                  </div><a id="CNCPT89392"></a><div class="props_rev_3"><a id="GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3" name="GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3"></a><h5 id="CNCPT-GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3" class="sect5">Complete Refresh</h5>
                     <div>
                        <p>A <span class="bold">complete refresh</span> executes the query that defines the materialized view. A complete refresh occurs when you initially create the materialized view, unless the materialized view references a prebuilt table, or you define the table as <code class="codeph">BUILD DEFERRED</code>. 
                        </p>
                        <p>A complete refresh can be slow, especially if the database must read and process huge amounts of data. You can perform a complete refresh at any time after creation of the materialized view.</p>
                     </div>
                  </div><a id="CNCPT89393"></a><div class="props_rev_3"><a id="GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F" name="GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F"></a><h5 id="CNCPT-GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F" class="sect5">Incremental Refresh</h5>
                     <div>
                        <p>An <span class="bold">incremental refresh</span>, also called a <span class="italic">fast refresh</span>, processes only the changes to the existing data. This method eliminates the need to rebuild materialized views from the beginning. Processing only the changes can result in a very fast refresh time.
                        </p>
                        <p></p>
                        <p>You can refresh materialized views either on demand or at regular time intervals. Alternatively, you can configure materialized views in the same database as their base tables to refresh whenever a transaction commits changes to the base tables.</p>
                        <p>Fast refresh comes in either of the following forms:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Log-Based refresh</p>
                              <p>In this type of refresh, a materialized view log or a direct loader log keeps a record of changes to the base tables. A materialized view log is a schema object that records changes to a base table so that a materialized view defined on the base table can be refreshed incrementally. Each materialized view log is associated with a single base table.</p>
                           </li>
                           <li>
                              <p>Partition change tracking (PCT) refresh</p>
                              <p>PCT refresh is valid only when the base tables are partitioned. PCT refresh removes all data in the affected materialized view partitions or affected portions of data, and then recomputes them. The database uses the modified base table partitions to identify the affected partitions or portions of data in the view. When partition maintenance operations have occurred on the base tables, PCT refresh is the only usable incremental refresh method.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89394"></a><div class="props_rev_3"><a id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC" name="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC"></a><h5 id="CNCPT-GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC" class="sect5">In-Place and Out-of-Place Refresh</h5>
                     <div>
                        <p>For the complete and incremental methods, the database can refresh the materialized view in place, which refreshes statements directly on the view, or out of place. </p>
                        <p>An out-of-place refresh creates one or more outside tables, executes the refresh statements on them, and then switches the materialized view or affected partitions with the outside tables. This technique achieves high availability during refresh, especially when refresh statements take a long time to finish.</p>
                        <p>Oracle Database 12c introduces synchronous refresh, which is a type of out-of-place refresh. A synchronous refresh does not modify the contents of the base tables, but instead uses the APIs in the synchronous refresh package, which ensures consistency by applying these changes to the base tables and materialized views at the same time. This approach enables a set of tables and the materialized views defined on them to be always synchronized. In a data warehouse, synchronous refresh method is well-suited for the following reasons:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The loading of incremental data is tightly controlled and occurs at periodic intervals.</p>
                           </li>
                           <li>
                              <p>Tables and their materialized views are often partitioned in the same way, or their partitions are related by a functional dependency.</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC__GUID-8B615BF7-7A10-4E97-8B09-04CBBD4659EE">
                           <p class="notep1">See Also:</p>
                           <p><a href="../dwhsg/refreshing-materialized-views.html#DWHSG03003" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a>to learn how to refresh materialized views
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT88877"></a><a id="CNCPT88876"></a><div class="props_rev_3"><a id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62" name="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62"></a><h4 id="CNCPT-GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62" class="sect4">Query Rewrite</h4>
                  <div>
                     <p>An optimization technique known as <span class="bold">query rewrite</span> transforms a user request written in terms of master tables into a semantically equivalent request that includes materialized views.
                     </p>
                     <p>When base tables contain large amounts of data, computing an aggregate or join is expensive and time-consuming. Because materialized views contain precomputed aggregates and joins, query rewrite can quickly answer queries using materialized views.</p>
                     <p>The <a href="glossary.html#GUID-648CCA52-2DB0-405D-9737-B7CB9B8E7CBC"><span class="xrefglossterm">query transformer</span></a> transparently rewrites the request to use the materialized view, requiring no user intervention and no reference to the materialized view in the SQL statement. Because query rewrite is transparent, materialized views can be added or dropped without invalidating the SQL in the application code.
                     </p>
                     <p>In general, rewriting queries to use materialized views rather than detail tables improves response time. The following figure shows the database generating an <a href="glossary.html#GUID-2DF33B85-94BB-44F3-93B7-06916FB18361"><span class="xrefglossterm">execution plan</span></a> for the original and rewritten query and choosing the lowest-cost plan.
                     </p>
                     <div class="figure" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__CFABICCA">
                        <p class="titleinfigure">Figure 4-10 Query Rewrite</p><img src="img/cncpt334.gif" alt="Description of Figure 4-10 follows" title="Description of Figure 4-10 follows" longdesc="img_text/cncpt334.html"><br><a href="img_text/cncpt334.html">Description of "Figure 4-10 Query Rewrite"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__GUID-9D58C628-DD88-43B6-889E-1631F9CD099F">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>"</span></p> to learn more about query transformation
                           </li>
                           <li>
                              <p><a href="../dwhsg/index.html" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> to learn how to use query rewrite
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT611"></a><div class="props_rev_3"><a id="GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" name="GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B"></a><h3 id="CNCPT-GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" class="sect3">Overview of Sequences</h3>
               <div>
                  <p>A <span class="bold">sequence</span> is a schema object from which multiple users can generate unique integers. A sequence generator provides a highly scalable and well-performing method to generate surrogate keys for a number data type.
                  </p>
               </div><a id="CNCPT88878"></a><div class="props_rev_3"><a id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED" name="GUID-F485DFE7-DA07-4943-9844-C97D31064EED"></a><h4 id="CNCPT-GUID-F485DFE7-DA07-4943-9844-C97D31064EED" class="sect4">Sequence Characteristics</h4>
                  <div>
                     <p>A sequence definition indicates general information about the sequence, including its name and whether the sequence ascends or descends.</p>
                     <p>A sequence definition also indicates:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The interval between numbers</p>
                        </li>
                        <li>
                           <p>Whether the database should cache sets of generated sequence numbers in memory</p>
                        </li>
                        <li>
                           <p>Whether the sequence should cycle when a limit is reached</p>
                        </li>
                     </ul>
                     <p>The following example creates the sequence <code class="codeph">customers_seq</code> in the sample schema <code class="codeph">oe</code>. An application could use this sequence to provide customer ID numbers when rows are added to the <code class="codeph">customers</code> table.
                     </p><pre class="pre codeblock"><code>CREATE SEQUENCE customers_seq
START WITH      1000
INCREMENT BY    1
NOCACHE
NOCYCLE;
</code></pre><p>The first reference to <code class="codeph">customers_seq.nextval</code> returns <code class="codeph">1000</code>. The second returns <code class="codeph">1001</code>. Each subsequent reference returns a value 1 greater than the previous reference.
                     </p>
                     <div class="infoboxnotealso" id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED__GUID-26613A8B-F33C-470A-822E-E5BE33328734">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../tdddg/creating-managing-schema-objects.html#TDDDG34000" target="_blank"><span><cite>Oracle Database 2 Day Developer's Guide</cite></span></a> for a tutorial that shows you how to create a sequence
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11796" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to reference a sequence in a SQL statement
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-SEQUENCE.html#SQLRF01314" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE SEQUENCE</code> syntax and semantics
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88879"></a><div class="props_rev_3"><a id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65" name="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65"></a><h4 id="CNCPT-GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65" class="sect4">Concurrent Access to Sequences</h4>
                  <div>
                     <p>The same sequence generator can generate numbers for multiple tables.</p>
                     <p> The generator can create primary keys automatically and coordinate keys across multiple rows or tables. For example, a sequence can generate primary keys for an <code class="codeph">orders</code> table and a <code class="codeph">customers</code> table.
                     </p>
                     <p>The sequence generator is useful in multiuser environments for generating unique numbers without the overhead of disk I/O or transaction locking. For example, two users simultaneously insert new rows into the <code class="codeph">orders</code> table. By using a sequence to generate unique numbers for the <code class="codeph">order_id</code> column, neither user has to wait for the other to enter the next available order number. The sequence automatically generates the correct values for each user.
                     </p>
                     <p>Each user that references a sequence has access to his or her current sequence number, which is the last sequence generated in the <a href="glossary.html#GUID-0F44C072-9841-4E2E-B846-FB16A2E54139"><span class="xrefglossterm">session</span></a>. A user can issue a statement to generate a new sequence number or use the current number last generated by the session. After a statement in a session generates a sequence number, it is available only to this session. Individual sequence numbers can be skipped if they were generated and used in a transaction that was ultimately rolled back.
                     </p>
                     <div class="infoboxnotewarn" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-99A0F55F-E395-4BCA-A175-3A03407A1CAC">
                        <p class="notep1">WARNING:</p>
                        <p>If your application requires a gap-free set of numbers, then you cannot use Oracle sequences. You must serialize activities in the database using your own developed code.</p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-5AB1218F-539E-494A-A189-1F337C191888">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="data-concurrency-and-consistency.html#GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C" title="This chapter explains how Oracle Database maintains consistent data in a multiuser database environment.">Data Concurrency and Consistency</a>"</span> to learn how sessions access data at the same time
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT511"></a><div class="props_rev_3"><a id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" name="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2"></a><h3 id="CNCPT-GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" class="sect3">Overview of Dimensions</h3>
               <div>
                  <p>A typical data warehouse has two important components: dimensions and facts. </p>
                  <p>A <span class="bold">dimension</span> is any category used in specifying business questions, for example, time, geography, product, department, and distribution channel. A <span class="bold">fact</span> is an event or entity associated with a particular set of dimension values, for example, units sold or profits.
                  </p>
                  <p>Examples of multidimensional requests include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Show total sales across all products at increasing aggregation levels for a geography dimension, from state to country to region, for 2013 and 2014.</p>
                     </li>
                     <li>
                        <p>Create a cross-tabular analysis of our operations showing expenses by territory in South America for 2013 and 2014. Include all possible subtotals.</p>
                     </li>
                     <li>
                        <p>List the top 10 sales representatives in Asia according to 2014 sales revenue for automotive products, and rank their commissions.</p>
                     </li>
                  </ul>
                  <p>Many multidimensional questions require aggregated data and comparisons of data sets, often across time, geography or budgets.</p>
                  <p>Creating a dimension permits the broader use of the query rewrite feature. By transparently rewriting queries to use materialized views, the database can improve query performance.</p>
                  <div class="infoboxnotealso" id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2__GUID-AAC63A16-C1F3-424D-9D09-5AF520FD0414">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="topics-for-database-administrators-and-developers.html#GUID-E1451108-464E-4B5F-B173-11212278E308" title="A data warehouse is a relational database designed for query and analysis rather than for transaction processing.">Overview of Data Warehousing and Business Intelligence</a>"</span> to learn about the differences between data warehouses and OLTP databases
                     </p>
                  </div>
               </div><a id="CNCPT88880"></a><div class="props_rev_3"><a id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C" name="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C"></a><h4 id="CNCPT-GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C" class="sect4">Hierarchical Structure of a Dimension</h4>
                  <div>
                     <p>A <strong class="term">dimension table</strong> is a logical structure that defines hierarchical (parent/child) relationships between pairs of columns or column sets.
                     </p>
                     <p> For example, a dimension can indicate that within a row the <code class="codeph">city</code> column implies the value of the <code class="codeph">state</code> column, and the <code class="codeph">state</code> column implies the value of the <code class="codeph">country</code> column.
                     </p>
                     <p>Within a customer dimension, customers could roll up to city, state, country, subregion, and region. Data analysis typically starts at higher levels in the dimensional hierarchy and gradually drills down if the situation warrants such analysis.</p>
                     <p>Each value at the child level is associated with one and only one value at the parent level. A hierarchical relationship is a functional dependency from one level of a hierarchy to the next level in the hierarchy.</p>
                     <p>A dimension has no data storage assigned to it. Dimensional information is stored in dimension tables, whereas fact information is stored in a fact table.</p>
                     <div class="infoboxnotealso" id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C__GUID-C26CCE50-EDA0-4E1C-B691-6B6E232A5E83">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../dwhsg/index.html" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> to learn about dimensions
                              </p>
                           </li>
                           <li>
                              <p><a href="../olaug/creating-dimensions-and-cubes.html#OLAUG300" target="_blank"><span><cite>Oracle OLAP User’s Guide</cite></span></a> to learn how to create dimensions
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88881"></a><div class="props_rev_3"><a id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA" name="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA"></a><h4 id="CNCPT-GUID-62DD0306-D019-4B21-AA81-17670CB44DDA" class="sect4">Creation of Dimensions</h4>
                  <div>
                     <p>You create dimensions with the <code class="codeph">CREATE DIMENSION</code> SQL statement.
                     </p>
                     <p> This statement specifies:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Multiple <code class="codeph">LEVEL</code> clauses, each of which identifies a column or column set in the dimension 
                           </p>
                        </li>
                        <li>
                           <p>One or more <code class="codeph">HIERARCHY</code> clauses that specify the parent/child relationships between adjacent levels 
                           </p>
                        </li>
                        <li>
                           <p>Optional <code class="codeph">ATTRIBUTE</code> clauses, each of which identifies an additional column or column set associated with an individual level 
                           </p>
                        </li>
                     </ul>
                     <p>The following statement was used to create the <code class="codeph">customers_dim</code> dimension in the sample schema <code class="codeph">sh</code>:
                     </p><pre class="pre codeblock"><code>CREATE DIMENSION customers_dim 
   LEVEL customer   IS (customers.cust_id)
   LEVEL city       IS (customers.cust_city) 
   LEVEL state      IS (customers.cust_state_province) 
   LEVEL country    IS (countries.country_id) 
   LEVEL subregion  IS (countries.country_subregion) 
   LEVEL region     IS (countries.country_region) 
   HIERARCHY geog_rollup (
      customer      CHILD OF
      city          CHILD OF 
      state         CHILD OF 
      country       CHILD OF 
      subregion     CHILD OF 
      region 
   JOIN KEY (customers.country_id) REFERENCES country )
   ATTRIBUTE customer DETERMINES
   (cust_first_name, cust_last_name, cust_gender, 
    cust_marital_status, cust_year_of_birth, 
    cust_income_level, cust_credit_limit) 
   ATTRIBUTE country DETERMINES (countries.country_name);
</code></pre><p>The columns in a dimension can come either from the same table (denormalized) or from multiple tables (fully or partially normalized). For example, a normalized time dimension can include a date table, a month table, and a year table, with join conditions that connect each date row to a month row, and each month row to a year row. In a fully denormalized time dimension, the date, month, and year columns are in the same table. Whether normalized or denormalized, the hierarchical relationships among the columns must be specified in the <code class="codeph">CREATE DIMENSION</code> statement.
                     </p>
                     <div class="infoboxnotealso" id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA__GUID-E30202F0-1006-4254-A07F-12A9A49BC9AE">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/CREATE-DIMENSION.html#SQLRF01206" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE DIMENSION</code> syntax and semantics
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT88882"></a><a id="CNCPT88883"></a><a id="CNCPT711"></a><div class="props_rev_3"><a id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" name="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2"></a><h3 id="CNCPT-GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" class="sect3">Overview of Synonyms</h3>
               <div>
                  <p>A <span class="bold">synonym</span> is an alias for a schema object. For example, you can create a synonym for a table or view, sequence, PL/SQL program unit, user-defined object type, or another synonym. Because a synonym is simply an alias, it requires no storage other than its definition in the data dictionary.
                  </p>
                  <p>Synonyms can simplify SQL statements for database users. Synonyms are also useful for hiding the identity and location of an underlying schema object. If the underlying object must be renamed or moved, then only the synonym must be redefined. Applications based on the synonym continue to work without modification.</p>
                  <p>You can create both private and public synonyms. A private synonym is in the schema of a specific user who has control over its availability to others. A public synonym is owned by the user group named <code class="codeph">PUBLIC</code> and is accessible by every database user.
                  </p>
                  <div class="example" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-B139ADF2-8005-4FA1-B503-052F39700285">
                     <p class="titleinexample">Example 4-6 Public Synonym</p>
                     <p>Suppose that a database administrator creates a public synonym named <code class="codeph">people</code> for the <code class="codeph">hr.employees</code> table. The user then connects to the <code class="codeph">oe</code> schema and counts the number of rows in the table referenced by the synonym.
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM people FOR hr.employees;
 
Synonym created.
 
SQL&gt; CONNECT oe
Enter password: <span class="italic">password</span>
Connected.

SQL&gt; SELECT COUNT(*) FROM people;

  COUNT(*)
----------
       107
</pre><p>Use public synonyms sparingly because they make database consolidation more difficult. As shown in the following example, if another administrator attempts to create the public synonym <code class="codeph">people</code>, then the creation fails because only one public synonym <code class="codeph">people</code> can exist in the database. Overuse of public synonyms causes namespace conflicts between applications.
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM people FOR oe.customers;
CREATE PUBLIC SYNONYM people FOR oe.customers
                      *
ERROR at line 1:
ORA-00955: name is already used by an existing object

SQL&gt; SELECT OWNER, SYNONYM_NAME, TABLE_OWNER, TABLE_NAME 
  2  FROM DBA_SYNONYMS 
  3  WHERE SYNONYM_NAME = 'PEOPLE';
 
OWNER      SYNONYM_NAME TABLE_OWNER TABLE_NAME
---------- ------------ ----------- ----------
PUBLIC     PEOPLE       HR          EMPLOYEES
</pre><p>Synonyms themselves are not securable. When you grant object privileges on a synonym, you are really granting privileges on the underlying object. The synonym is acting only as an alias for the object in the <code class="codeph">GRANT</code> statement.
                     </p>
                     <div class="infoboxnotealso" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-02F272D0-B29B-49AA-8A14-09A1BE53EC9E">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11805" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to manage synonyms
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-SYNONYM.html#SQLRF01401" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE SYNONYM</code> syntax and semantics
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>