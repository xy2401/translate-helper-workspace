<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Advanced Analytical SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="sql-modeling-data-warehouses.html" title="Previous" type="text/html">
      <link rel="next" href="part-analytic-views.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-modeling-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="part-analytic-views.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">Relational Analytics </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Advanced Analytical SQL</li>
            </ol>
            <a id="GUID-9C65845E-BC8B-405D-B990-2A604D4DEE05" name="GUID-9C65845E-BC8B-405D-B990-2A604D4DEE05"></a>
            
            <h2 id="DWHSG-GUID-9C65845E-BC8B-405D-B990-2A604D4DEE05" class="sect2"><span class="enumeration_chapter">23 </span>Advanced Analytical SQL
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This <a id="d96703e19" class="indexterm-anchor"></a>chapter illustrates techniques for handling advanced business intelligence queries. We hope to enhance your understanding of how different SQL features can be used together to perform demanding analyses. Although the features shown here have been addressed on an individual basis in <a href="sql-aggregation-data-warehouses.html#GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2">SQL for Aggregation in Data Warehouses</a>, <a href="sql-analysis-reporting-data-warehouses.html#GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" title="Approximate aggregates are computed using SQL functions that return approximate results. They are used primarily in data exploration queries where exact values are not required and approximations are acceptable.The LISTAGG function orders data within each group based on the ORDER BY clause and then concatenates the values of the measure column.Oracle Database provides a set of SQL functions that return approximate percentile results. These functions can be used to monitor quality, track social media activity, monitor performance, and search for outliers within a data set.">SQL for Analysis and Reporting</a>, and <a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a>, seeing features one at a time gives only a limited sense of how they can work together. Here we show the analytic power available when the features are combined.
               </p>
               <p>What makes a business intelligence query "advanced"? The label is best applied to multistep queries, often involving dimension hierarchies. In such queries, the final result depends on several sets of retrieved data, multiple calculation steps, and the data retrieved may involve multiple levels of a dimension hierarchy. Prime examples of advanced queries are market share calculations based on multiple conditions and sales projections that require filling gaps in data.</p>
               <p>The examples in this chapter illustrate using nested inline views, <code class="codeph">CASE</code> expressions, partitioned outer join, the <code class="codeph">MODEL</code> and <code class="codeph">WITH</code> clauses, analytic SQL functions, and more. Where relevant to the discussion, query plans will be discussed. This chapter includes:
               </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="advanced-analytical-sql-data-warehouses.html#GUID-572061B5-E08C-461A-8FB6-F4CA6F3F6B7F">Examples of Business Intelligence Queries</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8818"></a><div class="props_rev_3"><a id="GUID-572061B5-E08C-461A-8FB6-F4CA6F3F6B7F" name="GUID-572061B5-E08C-461A-8FB6-F4CA6F3F6B7F"></a><h3 id="DWHSG-GUID-572061B5-E08C-461A-8FB6-F4CA6F3F6B7F" class="sect3"><span class="enumeration_section">23.1 </span>Examples of Business Intelligence Queries
               </h3>
               <div>
                  <p>The queries in this chapter illustrate various business intelligence tasks. The topics of the queries and the features used in each query are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Percent change in market share based on complex multistep conditions. It illustrates nested inline views, <code class="codeph">CASE</code> expression, and analytic SQL functions.
                        </p>
                        <p>See <span class="q">"<a href="advanced-analytical-sql-data-warehouses.html#GUID-537C717B-14EC-4227-988F-CC50B34C8941">Business Intelligence Query Example 1: Percent Change in Market Share of Products in a Calculated Set</a>"</span></p>
                     </li>
                     <li>
                        <p>Sales projection with gaps in data filled in. It illustrates the <code class="codeph">MODEL</code> clause together with partitioned outer join and the <code class="codeph">CASE</code> expression.
                        </p>
                        <p>See <span class="q">"<a href="advanced-analytical-sql-data-warehouses.html#GUID-9881193F-6ADD-4BA1-9B3D-0FF0B57FBE37">Business Intelligence Query Example 2: Sales Projection that Fills in Missing Data</a>"</span></p>
                     </li>
                     <li>
                        <p>Customer analysis grouping customers into purchase-size buckets. It illustrates the <code class="codeph">WITH</code> clause (query subfactoring) and the analytic SQL functions <code class="codeph">percentile_cont</code> and <code class="codeph">width_bucket</code>.
                        </p>
                        <p>See <span class="q">"<a href="advanced-analytical-sql-data-warehouses.html#GUID-DD2ABDF8-F4AC-4E0C-AF6F-8FEE66C3D777">Business Intelligence Query Example 3: Customer Analysis by Grouping Customers into Buckets</a>"</span></p>
                     </li>
                     <li>
                        <p>Customer item grouping into itemsets. It illustrates calculating frequent itemsets using <code class="codeph">DBMS_FREQUENT_ITEMSET.FI_TRANSACTIONAL</code> as a table function.
                        </p>
                        <p>See <span class="q">"<a href="advanced-analytical-sql-data-warehouses.html#GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434">Business Intelligence Query Example 4: Frequent Itemsets</a>"</span></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9213"></a><div class="props_rev_3"><a id="GUID-537C717B-14EC-4227-988F-CC50B34C8941" name="GUID-537C717B-14EC-4227-988F-CC50B34C8941"></a><h4 id="DWHSG-GUID-537C717B-14EC-4227-988F-CC50B34C8941" class="sect4"><span class="enumeration_section">23.1.1 </span>Business Intelligence Query Example 1: Percent Change in Market Share of Products in a Calculated Set
                  </h4>
                  <div>
                     <div class="section">
                        <p>What was the percent change in market share for a grouping of my top 20% of products for the current three-month period versus same period year ago for accounts that grew by more than 20 percent in revenue?</p>
                        <p>We define market share as a product's share of total sales. We do this because there is no data for competitors in the <code class="codeph">sh</code> sample schema, so the typical share calculation of product sales and competitors' sales is not possible. The processing required for our share calculation is logically similar to a competitive market share calculation.
                        </p>
                        <p>Here are the pieces of information we find in the query, in the order we need to find them:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>Cities whose purchases grew by more than 20% during the specified 3-month period, versus the same 3-month period last year. Note that cities are limited to one country, and sales involving no promotion.</span></li>
                        <li><span>Top 20% of the products for the group of cities found in the prior step. That is, find sales by product summed across this customer group, and then select the 20% of products with the best sales.</span></li>
                        <li><span>The share of sales for each product found in the prior step. That is, using the products group found in the prior step, find each product's share of sales of all products. Find the shares for the same period a year ago and then calculate the change in share between the two years.</span></li>
                     </ol>
                     <div class="section">
                        <p>The techniques used in this example are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>This query is performed using the <code class="codeph">WITH</code> clause and nested inline views. Each inline view has been given a descriptive alias to show its data element, and comment lines indicate the boundaries of each inline view. Although inline views are powerful, we believe that readability and maintenance are much easier if queries are structured to maximize the use of the <code class="codeph">WITH</code> clause.
                              </p>
                           </li>
                           <li>
                              <p>This query does not use the <code class="codeph">WITH</code> clause as extensively as it might: some of the nested inline views could have been expressed as separate subclauses of the <code class="codeph">WITH</code> clause. For instance, in the main query, we use two inline views that return just one value. These are used for the denominator of the share calculations. We could have factored out these items and placed them in the <code class="codeph">WITH</code> clause for greater readability. For a contrast that does use the <code class="codeph">WITH</code> clause to its maximum, see <span class="q">"<a href="advanced-analytical-sql-data-warehouses.html#GUID-DD2ABDF8-F4AC-4E0C-AF6F-8FEE66C3D777">Business Intelligence Query Example 3: Customer Analysis by Grouping Customers into Buckets</a>"</span> regarding customer purchase analysis.
                              </p>
                           </li>
                           <li>
                              <p>Note the use of <code class="codeph">CASE</code> expressions within the arguments to <code class="codeph">SUM</code> functions. The <code class="codeph">CASE</code> expressions simplify the SQL by acting as an extra set of data filters after the <code class="codeph">WHERE</code> clause. They allow us to sum one column of sales for a desired date and another column for a different date.
                              </p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">WITH prod_list AS                     --START: Top 20% of products
   ( SELECT prod_id prod_subset, cume_dist_prod
    FROM                              --START: All products Sales for city subset
    ( SELECT s.prod_id, SUM(amount_sold),
         CUME_DIST() OVER (ORDER BY SUM(amount_sold)) cume_dist_prod
      FROM sales s, customers c, channels ch,  products p, times t
      WHERE s.prod_id = p.prod_id AND p.prod_total_id = 1 AND
            s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
            s.cust_id = c.cust_id AND
            s.promo_id = 999 AND
            s.time_id  = t.time_id AND t.calendar_quarter_id = 1776 AND
            c.cust_city_id IN
       (SELECT cust_city_id            --START: Top 20% of cities
       FROM
         (
           SELECT cust_city_id, ((new_cust_sales - old_cust_sales)
                / old_cust_sales ) pct_change, old_cust_sales
           FROM
           (
              SELECT cust_city_id, new_cust_sales, old_cust_sales
              FROM
              (          --START: Cities AND sales for 1 country in 2 periods
                SELECT cust_city_id,
                  SUM(CASE WHEN t.calendar_quarter_id = 1776
                     THEN amount_sold  ELSE  0  END ) new_cust_sales,
                  SUM(CASE WHEN t.calendar_quarter_id = 1772
                     THEN amount_sold ELSE 0 END) old_cust_sales
                FROM sales s, customers c, channels ch,
                     products p, times t
                WHERE s.prod_id = p.prod_id AND p.prod_total_id = 1 AND
                      s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
                      s.cust_id = c.cust_id AND c.country_id = 52790 AND
                      s.promo_id = 999 AND
                      s.time_id  = t.time_id AND
                     (t.calendar_quarter_id = 1776 OR t.calendar_quarter_id =1772)
                GROUP BY cust_city_id
              ) cust_sales_wzeroes
              WHERE old_cust_sales &gt; 0
           )  cust_sales_woutzeroes
         )         --END: Cities and sales for country in 2 periods
         WHERE old_cust_sales &gt; 0 AND  pct_change &gt;= 0.20)
                                 --END: Top 20% of cities
GROUP BY s.prod_id
)  prod_sales                    --END: All products sales for city subset
    WHERE cume_dist_prod &gt; 0.8   --END: Top 20% products
)
                                 --START: Main query bloc
SELECT  prod_id, ( (new_subset_sales/new_tot_sales)
              -    (old_subset_sales/old_tot_sales)
                 ) *100  share_changes
FROM
(                                --START: Total sales for country in later period
  SELECT  prod_id,
     SUM(CASE WHEN t.calendar_quarter_id = 1776
                   THEN amount_sold  ELSE  0  END )  new_subset_sales,
        (SELECT SUM(amount_sold) FROM sales s, times t, channels ch,
                customers c, countries co, products p
          WHERE s.time_id  = t.time_id AND t.calendar_quarter_id = 1776 AND
                s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
                s.cust_id = c.cust_id AND 
                c.country_id = co.country_id AND co.country_total_id = 52806 AND
                s.prod_id = p.prod_id AND p.prod_total_id = 1 AND
                s.promo_id = 999
        )   new_tot_sales,

                                --END: Total sales for country in later period
                                --START: Total sales for country in earlier period
     SUM(CASE WHEN t.calendar_quarter_id = 1772
                   THEN amount_sold  ELSE  0  END)  old_subset_sales,
        (SELECT SUM(amount_sold) FROM sales s, times t, channels ch, 
                customers c, countries co, products p
          WHERE s.time_id  = t.time_id AND t.calendar_quarter_id = 1772 AND
                s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
                s.cust_id = c.cust_id AND
                c.country_id = co.country_id AND co.country_total_id = 52806 AND
                       s.prod_id = p.prod_id AND p.prod_total_id = 1 AND
                s.promo_id = 999
        )   old_tot_sales
                                --END: Total sales for country in earlier period
 FROM sales s, customers c, countries co, channels ch, times t
 WHERE s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
       s.cust_id = c.cust_id AND
       c.country_id = co.country_id AND co.country_total_id = 52806 AND
       s.promo_id = 999 AND
       s.time_id  = t.time_id AND 
      (t.calendar_quarter_id = 1776 OR t.calendar_quarter_id = 1772)
         AND s.prod_id IN
     (SELECT prod_subset FROM prod_list)
  GROUP BY prod_id);</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9214"></a><div class="props_rev_3"><a id="GUID-9881193F-6ADD-4BA1-9B3D-0FF0B57FBE37" name="GUID-9881193F-6ADD-4BA1-9B3D-0FF0B57FBE37"></a><h4 id="DWHSG-GUID-9881193F-6ADD-4BA1-9B3D-0FF0B57FBE37" class="sect4"><span class="enumeration_section">23.1.2 </span>Business Intelligence Query Example 2: Sales Projection that Fills in Missing Data
                  </h4>
                  <div>
                     <div class="section">
                        <p>This query projects sales for 2002 based on the sales of 2000 and 2001. It finds the most percentage changes in sales from 2000 to 2001 and then adds that to the sales of 2002. While this is a simple calculation, there is an important thing to consider: many products have months with no sales in 2000 and 2001. We want to fill in blank values with the average sales value for the year (based on the months with actual sales). It converts currency values by country into US dollars. Finally, the query returns just the 2002 projection values.</p>
                        <p>The techniques used in this example are:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>By predefining all possible rows of data with the cross join ahead of the <code class="codeph">MODEL</code> clause, we reduce the processing required by <code class="codeph">MODEL</code>.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">MODEL</code> clause uses a reference model to perform currency conversion.
                              </p>
                           </li>
                           <li>
                              <p>By using the <code class="codeph">CV</code> function extensively, we reduce the total number of rules needed to just three.
                              </p>
                           </li>
                           <li>
                              <p>The most interesting expression is found in the last rule, which uses a nested rule to find the currency conversion factor. To supply the country name needed for this expression, we define country as both a dimension <code class="codeph">c</code> in the reference model, and a measure <code class="codeph">cc</code> in the main model.
                              </p>
                           </li>
                        </ul>
                        <p>The way this example proceeds is to begin by creating a reference table of currency conversion factors. The table will hold conversion factors for each month for each country. Note that we use a cross join to specify the rows inserted into the table. For our purposes, we only set the conversion factor for one country, Canada.</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE currency (
   country         VARCHAR2(20),
   year            NUMBER,
   month           NUMBER,
   to_us           NUMBER);

INSERT INTO currency
(SELECT distinct
SUBSTR(country_name,1,20), calendar_year, calendar_month_number, 1
FROM countries
CROSS JOIN times t
WHERE calendar_year IN (2000,2001,2002)
);
UPDATE currency set to_us=.74 WHERE country='Canada';
</pre><p>Here is the projection query. It starts with a <code class="codeph">WITH</code> clause that has two subclauses. The first subclause finds the monthly sales per product by country for the years 2000, 2001, and 2002. The second subclause finds a list of distinct times at the month level.
                        </p><pre class="oac_no_warn" dir="ltr">WITH  prod_sales_mo AS       --Product sales per month for one country
(
SELECT country_name c, prod_id p, calendar_year  y,
   calendar_month_number  m, SUM(amount_sold) s
FROM sales s, customers c, times t, countries cn, promotions p, channels ch
WHERE  s.promo_id = p.promo_id AND p.promo_total_id = 1 AND
       s.channel_id = ch.channel_id AND ch.channel_total_id = 1 AND
       s.cust_id=c.cust_id  AND 
       c.country_id=cn.country_id AND country_name='France' AND
       s.time_id=t.time_id  AND t.calendar_year IN  (2000, 2001,2002)
GROUP BY cn.country_name, prod_id, calendar_year, calendar_month_number
),
                    -- Time data used for ensuring that model has all dates
time_summary AS(  SELECT DISTINCT calendar_year cal_y, calendar_month_number cal_m
  FROM times
  WHERE  calendar_year IN  (2000, 2001, 2002)
)
                   --START: main query block
SELECT c, p, y, m, s,  nr FROM (
SELECT c, p, y, m, s,  nr
FROM prod_sales_mo s
                   --Use partitioned outer join to make sure that each combination
                   --of country and product has rows for all month values
  PARTITION BY (s.c, s.p)
     RIGHT OUTER JOIN time_summary ts ON
        (s.m = ts.cal_m
         AND s.y = ts.cal_y
        )
MODEL
  REFERENCE curr_conversion ON
      (SELECT country, year, month, to_us
      FROM currency)
      DIMENSION BY (country, year y,month m) MEASURES (to_us)
                                --START: main model
   PARTITION BY (s.c c)
   DIMENSION BY (s.p p, ts.cal_y y, ts.cal_m m)
   MEASURES (s.s s, CAST(NULL AS NUMBER) nr,
             s.c cc ) --country is used for currency conversion
   RULES (
                      --first rule fills in missing data with average values
      nr[ANY, ANY, ANY]
         = CASE WHEN s[CV(), CV(), CV()] IS NOT NULL
              THEN s[CV(), CV(), CV()]
              ELSE ROUND(AVG(s)[CV(), CV(), m BETWEEN 1 AND 12],2)
           END,
                      --second rule calculates projected values for 2002
      nr[ANY, 2002, ANY] = ROUND(
         ((nr[CV(),2001,CV()] - nr[CV(),2000, CV()])
          / nr[CV(),2000, CV()]) * nr[CV(),2001, CV()]
         + nr[CV(),2001, CV()],2),
                      --third rule converts 2002 projections to US dollars
      nr[ANY,y != 2002,ANY]
         = ROUND(nr[CV(),CV(),CV()]
           * curr_conversion.to_us[ cc[CV(),CV(),CV()], CV(y), CV(m)], 2)
)
ORDER BY c, p, y, m)
WHERE y = '2002'
ORDER BY c, p, y, m;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9215"></a><div class="props_rev_3"><a id="GUID-DD2ABDF8-F4AC-4E0C-AF6F-8FEE66C3D777" name="GUID-DD2ABDF8-F4AC-4E0C-AF6F-8FEE66C3D777"></a><h4 id="DWHSG-GUID-DD2ABDF8-F4AC-4E0C-AF6F-8FEE66C3D777" class="sect4"><span class="enumeration_section">23.1.3 </span>Business Intelligence Query Example 3: Customer Analysis by Grouping Customers into Buckets
                  </h4>
                  <div>
                     <div class="section">
                        <p>One important way to understand customers is by studying their purchasing patterns and learning the profitability of each customer. This can help us decide if a customer is worth cultivating and what kind of treatment to give it. Because the <code class="codeph">sh</code> sample schema data set includes many customers, a good way to start a profitability analysis is with a high level view: we will find data for a histogram of customer profitability, dividing profitability into 10 ranges (often called "buckets" for histogram analyses).For each country at an aggregation level of 1 month, we show:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The data needed for a 10-bucket equiwidth histogram of customer profitability. That is, show the count of customers falling into each of 10 profitability buckets. This is just 10 rows of results, but it involves significant calculations.</p>
                           </li>
                        </ul>
                        <p>For each profitability bucket, we also show:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The median count of transactions per customer during the month (treating each day's purchases by 1 customer in 1 channel as a single transaction).</p>
                           </li>
                           <li>
                              <p>The median transaction size (in local currency) per customer.</p>
                           </li>
                           <li>
                              <p>Products that generated the most and least profit.</p>
                           </li>
                           <li>
                              <p>Percent change of median transaction count and median transaction size versus last year.</p>
                           </li>
                        </ul>
                        <p>The techniques used in this example illustrate the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Using the <code class="codeph">WITH</code> clause to clarify a query. By dividing the needed data into logical chunks, each of which is expressed in its own <code class="codeph">WITH</code> subclause, we greatly improve readability and maintenance compared to nested inline views. The thorough use of <code class="codeph">WITH</code> subclauses means that the main <code class="codeph">SELECT</code> clause does not need to perform any calculations on the data it retrieves, again contributing to the readability and maintainability of the query.
                              </p>
                           </li>
                           <li>
                              <p>Using two analytic SQL functions, <code class="codeph">width_bucket</code> equiwidth histogram buckets and <code class="codeph">percentile_cont</code> to median transaction size and count.
                              </p>
                           </li>
                        </ul>
                        <p>This query shows us the analytic challenges inherent in data warehouse designs: because the <code class="codeph">sh</code> data does not include entries for every transaction, nor a count of transactions, we are forced to make an assumption. In this query, we will make the minimalist interpretation and assume that all products sold to a single customer through a single channel on a single day are part of the same transaction. This approach inevitably undercounts transactions, because some customers will in fact make multiple purchases through the same channel on the same day.
                        </p>
                        <p>Note that the query below should not be run until a materialized view is created for the initial query subfactor <code class="codeph">cust_prod_mon_profit</code>. Before creating the materialized view, create two additional indexes. Unless these preparatory steps are taken, the query may require significant time to run.The two additional indexes needed and the main query are as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX costs_chan_bix
      ON costs (channel_id)
      LOCAL NOLOGGING COMPUTE STATISTICS;
 
CREATE BITMAP INDEX costs_promo_bix
      ON costs (promo_id)
      LOCAL NOLOGGING COMPUTE STATISTICS;
</pre><pre class="oac_no_warn" dir="ltr">WITH cust_prod_mon_profit AS
-- profit by cust, prod, day, channel, promo
  (SELECT s.cust_id, s.prod_id, s.time_id,
          s.channel_id, s.promo_id,
          s.quantity_sold*(c.unit_price-c.unit_cost) profit,
          s.amount_sold dol_sold, c.unit_price price, c.unit_cost cost
   FROM sales s, costs c
   WHERE s.prod_id=c.prod_id
     AND s.time_id=c.time_id
     AND s.promo_id=c.promo_id
     AND s.channel_id=c.channel_id
     AND s.cust_id in (SELECT cust_id FROM customers cst
                       WHERE cst.country_id = 52770
     AND s.time_id IN (SELECT time_id FROM times t 
                       WHERE t.calendar_month_desc = '2000-12'
   ),
-- Transaction Definition:  All products sold through a single channel to a 
-- single cust on a single day are assumed to be sold in 1 transaction.
-- Some products in a transacton
-- may be on promotion
-- A customers  daily transaction amount is the sum of ALL products
-- purchased in the same channel in the same day
cust_daily_trans_amt  AS
(  SELECT cust_id, time_id, channel_id,  SUM(dol_sold) cust_daily_trans_amt
   FROM  cust_prod_mon_profit
   GROUP BY cust_id, time_id, channel_id
--A customers  monthly transaction count is the count of all channels
--used to purchase items in the same day, over all days in the month.
--It is really a count of the minimum possible number of transactions
cust_purchase_cnt  AS(  SELECT cust_id,  COUNT(*) cust_purchase_cnt
   FROM  cust_daily_trans_amt
   GROUP BY cust_id
), 
--  Total profit for a customer over 1 month
cust_mon_profit AS
( SELECT cust_id, SUM(profit) cust_profit
       FROM  cust_prod_mon_profit
       GROUP BY cust_id
-- Minimum and maximum profit across all customer
-- sets endpoints for histogram data.
min_max_p AS   
-- Note max profit + 0.1 to allow 10th bucket to include max value
(SELECT 0.1 + MAX(cust_profit) max_p, MIN(cust_profit) min_p 
FROM cust_mon_profit),
-- Profitability bucket found for each customer
cust_bucket AS
(SELECT cust_id, cust_profit,
   width_bucket(cust_profit,
         min_max_p.min_p,
FROM cust_mon_profit,  min_max_p
-- Aggregated data needed for each bucket
histo_data AS
(  SELECT bucket,
     bucket*(( max_p-min_p) /10) top_end , count(*)  histo_count
   FROM  cust_bucket, min_max_p 
   GROUP BY bucket, bucket*(( max_p - min_p) /10)
-- Median count of transactions per cust per month median_trans_count AS 
-- Find median count of transactions per cust per month
(SELECT cust_bucket.bucket, 
      PERCENTILE_CONT(0.5) WITHIN GROUP 
          (ORDER BY cust_purchase_cnt.cust_purchase_cnt) median_trans_count 
    FROM cust_bucket, cust_purchase_cnt
    WHERE cust_bucket.cust_id=cust_purchase_cnt.cust_id
    GROUP BY cust_bucket.bucket
-- Find Mmedian transaction size for custs by profit bucket
cust_median_trans_size AS
(  SELECT cust_bucket.bucket,
      PERCENTILE_CONT(0.5) WITHIN GROUP
          (ORDER BY cust_daily_trans_amt.cust_daily_trans_amt)
           cust_median_trans_ size
    FROM cust_bucket, cust_daily_trans_amt
    WHERE cust_bucket.cust_id=cust_daily_trans_amt.cust_id
    GROUP BY cust_bucket.bucket
-- Profitability of each product sold within each bucket
bucket_prod_profits AS
(  SELECT  cust_bucket.bucket, prod_id, SUM(profit) tot_prod_profit
   FROM  cust_bucket, cust_prod_mon_profit
   WHERE  cust_bucket.cust_id=cust_prod_mon_profit.cust_id
   GROUP BY cust_bucket.bucket, prod_id
),  -- Most and least profitable product by bucket
prod_profit AS
(  SELECT bucket, MIN(tot_prod_profit) min_profit_prod,
                  MAX(tot_prod_profit) max_profit_prod
   FROM bucket_prod_profits 
   GROUP BY bucket
-- Main query block
SELECT  histo_data.bucket, histo_data.histo_count,
        median_trans_count.median_trans_count,
        cust_median_trans_size.cust_median_trans_size,
        prod_profit.min_profit_prod, prod_profit.max_profit_prod
FROM  histo_data, median_trans_count, cust_median_trans_size,
      prod_profit
WHERE  histo_data.bucket=median_trans_count.bucket
  AND  histo_data.bucket=cust_median_trans_size.bucket
  AND  histo_data.bucket=prod_profit.bucket;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9216"></a><div class="props_rev_3"><a id="GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434" name="GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434"></a><h4 id="DWHSG-GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434" class="sect4"><span class="enumeration_section">23.1.4 </span>Business Intelligence Query Example 4: Frequent Itemsets
                  </h4>
                  <div>
                     <div class="section">
                        <p>Consider a marketing manager who wants to know which pieces of his firm's collateral are downloaded by users during a single session. That is, the manager wants to know which groupings of collateral are the most frequent itemsets. This is easy to do with the integrated frequent itemsets facility, as long as the Web site's activity log records a user ID and session ID for each collateral piece that is downloaded. For context, first we show a list of the aggregate number of downloads for individual white papers. (In our example data here, we use names of Oracle papers.)</p><pre class="oac_no_warn" dir="ltr">White paper titles                                               #
-------------------------------------------------------          ----
Table Compression in Oracle Database 10g                          696
Field Experiences with Large Data Warehouses                      439
Key Data Warehouse Features: A Comparative Performance Analysis   181
Materialized Views in Oracle Database 10g                         167
Parallel Execution in Oracle Database 10g                         166
</pre><p>Here is a sample of the type of query that would be used for such analysis. The query uses <code class="codeph">DBMS_FREQUENT_ITEMSET.FI_TRANSACTIONAL</code> as a table function. To understand the details of the query structure, see the <a href="../arpls/DBMS_FREQUENT_ITEMSET.html#ARPLS007" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>. The query returns the itemset of pairs of papers that were downloaded in a single session:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT itemset, support, length, rnk
FROM
  (SELECT itemset, support, length,
   RANK() OVER (PARTITION BY length ORDER BY support DESC) rnk
FROM
(SELECT CAST(itemset AS fi_char) itemset, support, length, total_tranx
 FROM table(DBMS_FREQUENT_ITEMSET.FI_TRANSACTIONAL
  (CURSOR(SELECT session_id, command
          FROM web_log
          WHERE time_stamp BETWEEN '01-APR-2002' AND '01-JUN-2002'),
          (60/2600), 2, 2, CURSOR(SELECT 'a' FROM DUAL WHERE 1=0),
          CURSOR(SELECT 'a' FROM DUAL WHERE 1=0)))))
   WHERE rnk &lt;= 10;</pre><p>Here are the first three items of results:</p><pre class="oac_no_warn" dir="ltr">White paper titles                                                    #
---------------------------------------------------------         -----
Table Compression in Oracle Database 10g                            115
Field Experiences with Large Data Warehouses                           

Data Warehouse Performance Enhancements with Oracle Database 10g    109
Oracle Performance and Scalability in DSS Environments

Materialized Views in Oracle Database 10g                           107
Query Optimization in Oracle Database 10g
</pre><p>This analysis yielded some interesting results. If one were to look at the list of the most popular single papers, one would expect the most popular pairs of downloaded papers would often include the white paper "Table Compression in Oracle Database 10<span class="italic">g</span>", because it was the most popular download of all papers. However, only one of the top three pairs included this paper.
                        </p>
                        <p>By using frequent itemsets to analyze the Web log information, a manager can glean much more information than available in a simple report that only lists the most popular pieces of collateral. From these results, the manager can see that visitors to this Web site tend to search for information on a single topic area during a single session: visitors interested in scalability download white papers on compression and large data warehouses, while visitors interested in complex query capabilities download papers on query optimization and materialized views. For a marketing manager, this type of information is helpful in determining what sort of collateral should be written in the future; for a Web designer, this information can provide additional suggestions on how to organize the Web site.</p>
                        <p>See <span class="q">"<a href="sql-analysis-reporting-data-warehouses.html#GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D">Frequent Itemsets in SQL Analytics</a>"</span> for more information.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>