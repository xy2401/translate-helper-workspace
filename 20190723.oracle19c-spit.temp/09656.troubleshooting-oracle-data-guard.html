<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="These are some of the problems that can occur on a standby database, and the troubleshooting procedures to address them.">
      <meta name="description" content="These are some of the problems that can occur on a standby database, and the troubleshooting procedures to address them.">
      <title>Troubleshooting Oracle Data Guard</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Concepts and Administration ">
      <meta property="og:description" content="These are some of the problems that can occur on a standby database, and the troubleshooting procedures to address them.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Concepts and Administration">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="data-guard-concepts-and-administration.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T10:50:21-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96244-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="oracle-data-guard-supplemental-information.html" title="Previous" type="text/html">
      <link rel="next" href="upgrading-patching-downgrading-oracle-data-guard-configuration.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Data Guard Concepts and Administration">
    <meta name="dcterms.isVersionOf" content="SBYDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-data-guard-supplemental-information.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="upgrading-patching-downgrading-oracle-data-guard-configuration.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Concepts and Administration </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-data-guard-supplemental-information.html" property="item" typeof="WebPage"><span property="name"> Appendixes </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Troubleshooting Oracle Data Guard</li>
            </ol>
            <a id="GUID-1AF3825C-C58B-4362-ADD5-A21FEF75912F" name="GUID-1AF3825C-C58B-4362-ADD5-A21FEF75912F"></a><a id="SBYDB01400"></a>
            
            <h2 id="SBYDB-GUID-1AF3825C-C58B-4362-ADD5-A21FEF75912F" class="sect2"><span class="enumeration_chapter">A </span> Troubleshooting Oracle Data Guard
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>These are some of the problems that can occur on a standby database, and the troubleshooting procedures to address them.</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-07FDFFCC-6FFB-458B-B7A3-F0833EE3BF8B" title="These are some of the common problems you may encounter when using a standby database.">Common Problems</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-397ED7EA-1A1C-4224-82A3-746448BE6944" title="If you specify REOPEN for a MANDATORY destination, redo transport services stall the primary database when redo data cannot be successfully transmitted.">Log File Destination Failures</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-3BC98594-CFA0-4EDC-92B9-52F19088B224" title="An important tool for handling logical standby database failures is the DBMS_LOGSTDBY.SKIP_ERROR procedure.">Handling Logical Standby Database Failures</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-05C15D55-8CD8-4CB3-ADD3-642AED0FB3A3" title="These are some of the problems that can cause a switchover to be unsuccessful, and possible solutions.">Problems Switching Over to a Physical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-0D1E5C2A-A8E9-4866-89F4-47AA1D86BB7C" title="A switchover operation involving a logical standby database usually consists of two phases: preparing and committing. The exceptions to this are for rolling upgrades of Oracle software using a logical standby database or if you are using Oracle Data Guard broker.">Problems Switching Over to a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A" title="When an unsupported statement or package is encountered, SQL Apply stops.">What to Do If SQL Apply Stops</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-5B879B01-2433-4B08-8D58-E91DBA58FEF7" title="For optimal performance, set the Oracle Net SDU parameter to its maximum value of 65535 bytes in each Oracle Net connect descriptor used by redo transport services.">Network Tuning for Redo Data Transmission</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-5F933817-AD03-43D7-878D-E4B115448DAD" title="If asynchronous I/O on the file system itself is showing performance problems, try mounting the file system using the Direct I/O option or setting the FILESYSTEMIO_OPTIONS=SETALL initialization parameter.">Slow Disk Performance on Standby Databases</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-82348347-C02B-4179-A325-3192E6F94737" title="If you have configured a standby redo log on one or more standby databases in the configuration, ensure the size of the standby redo log files on each standby database exactly matches the size of the online redo log files on the primary database.">Log Files Must Match to Avoid Primary Database Shutdown</a></p>
                  </li>
                  <li>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-B1551FC6-1B9F-49A5-A462-124697A449C3" title="These troubleshooting tips can help you recover from errors.">Troubleshooting a Logical Standby Database</a></p>
                  </li>
               </ul>
            </div><a id="SBYDB01405"></a><div class="props_rev_3"><a id="GUID-07FDFFCC-6FFB-458B-B7A3-F0833EE3BF8B" name="GUID-07FDFFCC-6FFB-458B-B7A3-F0833EE3BF8B"></a><h3 id="SBYDB-GUID-07FDFFCC-6FFB-458B-B7A3-F0833EE3BF8B" class="sect3"><span class="enumeration_section">A.1 </span>Common Problems
               </h3>
               <div>
                  <p>These are some of the common problems you may encounter when using a standby database.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-AFDF503B-600D-4B7E-A476-2E7E0CB489C0" title="You cannot rename the data file on the standby site when the STANDBY_FILE_MANAGEMENT initialization parameter is set to AUTO.">Renaming Data Files with the ALTER DATABASE Statement</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-E0F5B423-208F-4F7E-8CA4-0350D3A7CF0B" title="If the standby site is not receiving redo data, query the V$ARCHIVE_DEST view and check for error messages.">Standby Database Does Not Receive Redo Data from the Primary Database</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-A0AF4052-4B12-496A-AC20-820E184C5A05" title="You cannot mount the standby database if the standby control file was not created with the ALTER DATABASE CREATE [LOGICAL] STANDBY CONTROLFILE ... statement or RMAN command.">You Cannot Mount the Physical Standby Database</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4905"></a><div class="props_rev_3"><a id="GUID-AFDF503B-600D-4B7E-A476-2E7E0CB489C0" name="GUID-AFDF503B-600D-4B7E-A476-2E7E0CB489C0"></a><h4 id="SBYDB-GUID-AFDF503B-600D-4B7E-A476-2E7E0CB489C0" class="sect4"><span class="enumeration_section">A.1.1 </span>Renaming Data Files with the ALTER DATABASE Statement
                  </h4>
                  <div>
                     <p>You cannot rename the data file on the standby site when the <code class="codeph">STANDBY_FILE_MANAGEMENT</code> initialization parameter is set to <code class="codeph">AUTO</code>.
                     </p>
                     <p> When you set the <code class="codeph">STANDBY_FILE_MANAGEMENT</code> initialization parameter to <code class="codeph">AUTO</code>, use of the following SQL statements is<a id="d58098e358" class="indexterm-anchor"></a> not allowed:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ALTER DATABASE RENAME</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER DATABASE ADD/DROP LOGFILE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER DATABASE ADD/DROP STANDBY LOGFILE MEMBER</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER DATABASE CREATE DATAFILE AS</code></p>
                        </li>
                     </ul>
                     <p>If you attempt to use any of these statements on the standby database, an error is returned. For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; <a id="d58098e384" class="indexterm-anchor"></a><a id="d58098e388" class="indexterm-anchor"></a>ALTER DATABASE RENAME FILE '/disk1/oracle/oradata/payroll/t_db2.log' to 'dummy';

alter database rename file '/disk1/oracle/oradata/payroll/t_db2.log' to 'dummy' 
* 
ERROR at line 1: 
ORA-01511: error in renaming log/datafiles 
ORA-01270: RENAME operation is not allowed if STANDBY_FILE_MANAGEMENT is auto
</pre><p>See <a href="managing-oracle-data-guard-physical-standby-databases.html#GUID-C60E4DB4-F424-454D-B4DF-7A97B2F09540" title="The STANDBY_FILE_MANAGEMENT database initialization parameter controls whether the addition of a data file to the primary database is automatically propagated to a physical standby databases.">Adding a Data File or Creating a Tablespace</a> to learn how to add data files to a physical standby database.
                     </p>
                  </div>
               </div><a id="SBYDB4906"></a><div class="props_rev_3"><a id="GUID-E0F5B423-208F-4F7E-8CA4-0350D3A7CF0B" name="GUID-E0F5B423-208F-4F7E-8CA4-0350D3A7CF0B"></a><h4 id="SBYDB-GUID-E0F5B423-208F-4F7E-8CA4-0350D3A7CF0B" class="sect4"><span class="enumeration_section">A.1.2 </span>Standby Database Does Not Receive Redo Data from the Primary Database
                  </h4>
                  <div>
                     <p>If the standby site is not receiving redo data, query the <code class="codeph">V$ARCHIVE_DEST</code> view and check for error messages. 
                     </p>
                     <p>For example, enter the following query:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DEST_ID "ID", -
&gt; STATUS "DB_status", -
&gt; DESTINATION "Archive_dest", -
&gt; ERROR "Error" -
&gt; FROM V$ARCHIVE_DEST WHERE DEST_ID &lt;=5;

ID DB_status Archive_dest                   Error   
-- --------- ------------------------------ ------------------------------------
 1  VALID    /vobs/oracle/work/arc_dest/arc                          
 2  ERROR    standby1                       ORA-16012: Archivelog standby database identifier mismatch  
 3  INACTIVE                            
 4  INACTIVE                    
 5  INACTIVE                                           
5 rows selected.
</pre><p>If the output of the query does not help you, then check the following list of possible issues. If any of the following conditions exist, then redo transport services fail to transmit redo data to the standby database:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The service name for the standby instance is not configured correctly in the <a id="d58098e499" class="indexterm-anchor"></a><a id="d58098e503" class="indexterm-anchor"></a><a id="d58098e507" class="indexterm-anchor"></a><a id="d58098e511" class="indexterm-anchor"></a><code class="codeph">tnsnames.ora</code> file for the primary database.
                           </p>
                        </li>
                        <li>
                           <p>The Oracle Net service name specified by the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> parameter for the primary database is incorrect.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">LOG_ARCHIVE_DEST_STATE_</code><span class="italic"><code class="codeph">n</code></span> parameter for the standby database is not set to the value <code class="codeph">ENABLE.</code></p>
                        </li>
                        <li>
                           <p>The <code class="codeph">listener.ora</code> file has not been configured correctly for the standby database.
                           </p>
                        </li>
                        <li>
                           <p>The listener is not started at the standby site.</p>
                        </li>
                        <li>
                           <p>The standby instance is not started.</p>
                        </li>
                        <li>
                           <p>You have added a standby archiving destination to the primary SPFILE or text initialization parameter file, but have not yet enabled the change.</p>
                        </li>
                        <li>
                           <p>Redo transport authentication has not been configured properly. See section 3.1.2 for redo transport authentication configuration requirements.</p>
                        </li>
                        <li>
                           <p>You used an invalid backup as the basis for the standby database (for example, you used a backup from the wrong database, or did not create the standby control file using the correct method).</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="SBYDB4907"></a><div class="props_rev_3"><a id="GUID-A0AF4052-4B12-496A-AC20-820E184C5A05" name="GUID-A0AF4052-4B12-496A-AC20-820E184C5A05"></a><h4 id="SBYDB-GUID-A0AF4052-4B12-496A-AC20-820E184C5A05" class="sect4"><span class="enumeration_section">A.1.3 </span>You Cannot Mount the Physical Standby Database
                  </h4>
                  <div>
                     <p>You cannot mount the standby database if the standby control file was not created with the <code class="codeph">ALTER DATABASE CREATE [LOGICAL] STANDBY CONTROLFILE ...</code> statement or RMAN command. 
                     </p>
                     <p>You cannot use the following types of control file backups:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>An operating system-created backup</p>
                        </li>
                        <li>
                           <p>A backup created using an <code class="codeph">ALTER DATABASE</code> statement <span class="italic">without</span> the <code class="codeph">PHYSICAL STANDBY</code> or <code class="codeph">LOGICAL STANDBY</code> option
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="SBYDB5084"></a><a id="SBYDB5085"></a><a id="SBYDB4908"></a><div class="props_rev_3"><a id="GUID-397ED7EA-1A1C-4224-82A3-746448BE6944" name="GUID-397ED7EA-1A1C-4224-82A3-746448BE6944"></a><h3 id="SBYDB-GUID-397ED7EA-1A1C-4224-82A3-746448BE6944" class="sect3"><span class="enumeration_section">A.2 </span>Log File Destination Failures
               </h3>
               <div>
                  <p>If you specify <code class="codeph">REOPEN</code> for a <code class="codeph">MANDATORY</code> destination, redo transport services stall the primary database when redo data cannot be successfully transmitted.
                  </p>
                  <div class="section">
                     <p>The <code class="codeph">REOPEN</code> attribute is required when you use the <code class="codeph">MAX_FAILURE</code> attribute. <a href="troubleshooting-oracle-data-guard.html#GUID-397ED7EA-1A1C-4224-82A3-746448BE6944__I635145">Example A-1</a> shows how to set a retry time of 5 seconds and limit retries to 3 times.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-397ED7EA-1A1C-4224-82A3-746448BE6944__I635145">
                     <p class="titleinexample">Example A-1 Setting a Retry Time and Limit</p><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_1='LOCATION=/arc_dest REOPEN=5 MAX_FAILURE=3'
</pre><p><a id="d58098e765" class="indexterm-anchor"></a><a id="d58098e771" class="indexterm-anchor"></a><a id="d58098e775" class="indexterm-anchor"></a><a id="d58098e779" class="indexterm-anchor"></a>Use the <code class="codeph">ALTERNATE</code> attribute of the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> parameter to specify alternate archive destinations. An alternate archiving destination can be used when the transmission of redo data to a standby database fails. If transmission fails and the <code class="codeph">REOPEN</code> attribute was not specified or the <code class="codeph">MAX_FAILURE</code> attribute threshold was exceeded, redo transport services attempts to transmit redo data to the alternate destination on the next archival operation.
                     </p>
                     <p><a id="d58098e801" class="indexterm-anchor"></a><a id="d58098e805" class="indexterm-anchor"></a>Use the <code class="codeph">NOALTERNATE</code> attribute to prevent the original archive destination from automatically changing to an alternate archive destination when the original archive destination fails.
                     </p>
                     <p><a href="troubleshooting-oracle-data-guard.html#GUID-397ED7EA-1A1C-4224-82A3-746448BE6944__I635159">Example A-2</a> shows how to set the <a id="d58098e816" class="indexterm-anchor"></a><a id="d58098e822" class="indexterm-anchor"></a>initialization parameters so that a single, mandatory, local destination automatically fails over to a different destination if any error occurs.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-397ED7EA-1A1C-4224-82A3-746448BE6944__I635159">
                     <p class="titleinexample">Example A-2 Specifying an Alternate Destination</p><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_1='LOCATION=/disk1 MANDATORY ALTERNATE=LOG_ARCHIVE_DEST_2'
LOG_ARCHIVE_DEST_STATE_1=ENABLE
LOG_ARCHIVE_DEST_2='LOCATION=/disk2 MANDATORY'
LOG_ARCHIVE_DEST_STATE_2=ALTERNATE
</pre><p>If the <code class="codeph">LOG_ARCHIVE_DEST_1</code> destination fails, the archiving process automatically switches to the <code class="codeph">LOG_ARCHIVE_DEST_2</code> destination at the next log file switch on the primary database.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="SBYDB4909"></a><div class="props_rev_3"><a id="GUID-3BC98594-CFA0-4EDC-92B9-52F19088B224" name="GUID-3BC98594-CFA0-4EDC-92B9-52F19088B224"></a><h3 id="SBYDB-GUID-3BC98594-CFA0-4EDC-92B9-52F19088B224" class="sect3"><span class="enumeration_section">A.3 </span>Handling Logical Standby Database Failures
               </h3>
               <div>
                  <p>An important tool for handling logical standby database failures is the <code class="codeph">DBMS_LOGSTDBY.SKIP_ERROR</code> procedure.
                  </p>
                  <p> Depending on how important a table is, you might want to do one of the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Ignore failures for a table or specific DDL</p>
                     </li>
                     <li>
                        <p>Associate a stored procedure with a filter so at runtime a determination can be made about skipping the statement, executing this statement, or executing a replacement statement</p>
                     </li>
                  </ul>
                  <p>Taking one of these actions prevents SQL Apply from stopping. Later, you can query the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view to find and correct any problems that exist. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about using the <code class="codeph">DBMS_LOGSTDBY</code> package with PL/SQL callout procedures.
                  </p>
               </div>
            </div><a id="SBYDB01410"></a><div class="props_rev_3"><a id="GUID-05C15D55-8CD8-4CB3-ADD3-642AED0FB3A3" name="GUID-05C15D55-8CD8-4CB3-ADD3-642AED0FB3A3"></a><h3 id="SBYDB-GUID-05C15D55-8CD8-4CB3-ADD3-642AED0FB3A3" class="sect3"><span class="enumeration_section">A.4 </span>Problems Switching Over to a Physical Standby Database
               </h3>
               <div>
                  <p>These are some of the problems that can cause a switchover to be unsuccessful, and possible solutions.</p>
                  <p></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-616EF287-25CE-4F6D-A0C3-9A4DEDA3A97C" title="If the switchover does not complete successfully, you can query the SEQUENCE# column in the V$ARCHIVED_LOG view to see if the last redo data transmitted from the original primary database was applied on the standby database.">Switchover Fails Because Redo Data Was Not Transmitted</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-2BE05596-2E74-4FEE-84AB-81777B5B9E13" title="This is an explanation of why you may receive an ORA-01102 error during a switchover, and what action to take.">Switchover Fails with the ORA-01102 Error</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-ACDE1813-1DBD-48E1-8C42-0A2E4ED36631" title="If the archived redo log files are not applied to the new standby database after the switchover, it could be because some environment or initialization parameters were not properly set after the switchover.">Redo Data Is Not Applied After Switchover</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-97282862-4EA0-42D9-97EF-34E75A29F87F" title="For physical standby databases in situations where an error occurred and it is not possible to continue with the switchover, it might still be possible to revert the new physical standby database back to the primary role.">Roll Back After Unsuccessful Switchover and Start Over</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4910"></a><div class="props_rev_3"><a id="GUID-616EF287-25CE-4F6D-A0C3-9A4DEDA3A97C" name="GUID-616EF287-25CE-4F6D-A0C3-9A4DEDA3A97C"></a><h4 id="SBYDB-GUID-616EF287-25CE-4F6D-A0C3-9A4DEDA3A97C" class="sect4"><span class="enumeration_section">A.4.1 </span>Switchover Fails Because Redo Data Was Not Transmitted
                  </h4>
                  <div>
                     <p>If the switchover does not complete successfully, you can query the <code class="codeph">SEQUENCE#</code> column in the <code class="codeph">V$ARCHIVED_LOG</code> view to see if the last redo data transmitted from the original primary database was applied on the standby database.
                     </p>
                     <p>If the last redo data was not transmitted to the standby database, you can manually copy the archived redo log file containing the redo data from the original primary database to the old standby database and register it with the SQL <code class="codeph">ALTER DATABASE REGISTER LOGFILE</code> <span class="variable" translate="no">file_specification</span> statement. If you then start apply services, the archived redo log file is applied automatically. Query the <code class="codeph">SWITCHOVER_STATUS</code> column in the <code class="codeph">V$DATABASE</code> view. A switchover to the primary role is now possible if the <code class="codeph">SWITCHOVER_STATUS</code> column returns <code class="codeph">TO PRIMARY</code> or <code class="codeph">SESSIONS ACTIVE</code>.
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SWITCHOVER_STATUS FROM V$DATABASE;

SWITCHOVER_STATUS 
----------------- 
TO PRIMARY 
1 row selected 
</pre><p>To continue with the switchover, follow the instructions in <a href="managing-oracle-data-guard-role-transitions.html#GUID-AAD70601-D248-4309-B8DD-F461EE31A5FF" title="These steps describe how to perform a switchover to a physical standby database.">Performing a Switchover to a Physical Standby Database</a> for physical standby databases or <a href="managing-oracle-data-guard-role-transitions.html#GUID-42B8B448-90E0-4D7D-82A3-AAA273E6E49B" title="When you perform a switchover that changes roles between a primary database and a logical standby database, always initiate the switchover on the primary database and complete it on the logical standby database.">Performing a Switchover to a Logical Standby Database</a> for logical standby databases, and try again to switch the target standby database to the primary role.
                     </p>
                  </div>
               </div><a id="SBYDB4913"></a><div class="props_rev_3"><a id="GUID-2BE05596-2E74-4FEE-84AB-81777B5B9E13" name="GUID-2BE05596-2E74-4FEE-84AB-81777B5B9E13"></a><h4 id="SBYDB-GUID-2BE05596-2E74-4FEE-84AB-81777B5B9E13" class="sect4"><span class="enumeration_section">A.4.2 </span>Switchover Fails with the ORA-01102 Error
                  </h4>
                  <div>
                     <p>This is an explanation of why you may receive an <code class="codeph">ORA-01102</code> error during a switchover, and what action to take.
                     </p>
                     <p>Suppose the standby database and the primary database reside on the same site. After the <code class="codeph">ALTER DATABASE SWITCHOVER TO</code> <span class="italic"><code class="codeph">target_db_name</code></span> statement is successfully executed, shut down and restart the physical standby database and the primary database.
                     </p>
                     <div class="infoboxnote" id="GUID-2BE05596-2E74-4FEE-84AB-81777B5B9E13__GUID-911F3AA6-A1EC-47FC-8C75-12411224C05C">
                        <p class="notep1">Note:</p>
                        <p> It is not necessary to shut down and restart the physical standby database if it has not been opened read-only since the instance was started.</p>
                     </div>
                     <p>However, the startup of the second database fails with <code class="codeph">ORA-01102</code> error "cannot mount database in <code class="codeph">EXCLUSIVE</code> mode."
                     </p>
                     <p>This could happen during the switchover if you did not set the <code class="codeph">DB_UNIQUE_NAME</code> parameter in the initialization parameter file that is used by the standby database (the original primary database). If the <code class="codeph">DB_UNIQUE_NAME</code> parameter of the standby database is not set, the standby and the primary databases both use the same mount lock and cause the <code class="codeph">ORA-01102</code> error during the startup of the second database.
                     </p>
                     <p>Action: Add <code class="codeph">DB_UNIQUE_NAME=</code><span class="italic"><code class="codeph">unique_database_name</code></span> to the initialization parameter file used by the standby database, and shut down and restart the standby and primary databases.
                     </p>
                  </div>
               </div><a id="SBYDB4914"></a><div class="props_rev_3"><a id="GUID-ACDE1813-1DBD-48E1-8C42-0A2E4ED36631" name="GUID-ACDE1813-1DBD-48E1-8C42-0A2E4ED36631"></a><h4 id="SBYDB-GUID-ACDE1813-1DBD-48E1-8C42-0A2E4ED36631" class="sect4"><span class="enumeration_section">A.4.3 </span>Redo Data Is Not Applied After Switchover
                  </h4>
                  <div>
                     <p>If the archived redo log files are not applied to the new standby database after the switchover, it could be because some environment or initialization parameters were not properly set after the switchover.</p>
                     <div class="section">
                        <p></p>
                        <p></p>
                        <p>Action:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Check the <code class="codeph">tnsnames.ora</code> file at the new primary site and the <code class="codeph">listener.ora</code> file at the new standby site. There should be entries for a listener at the standby site and a corresponding service name at the primary site. 
                              </p>
                           </li>
                           <li>
                              <p>Start the listener at the standby site if it has not been started.</p>
                           </li>
                           <li>
                              <p>Check if the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> initialization parameter was set to properly transmit redo data from the primary site to the standby site. For example, query the <code class="codeph">V$ARCHIVE_DEST</code> fixed view at the primary site as follows:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DEST_ID, STATUS, DESTINATION FROM V$ARCHIVE_DEST;
</pre><p>If you do not see an entry corresponding to the standby site, you need to set <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> and <code class="codeph">LOG_ARCHIVE_DEST_STATE_</code><span class="italic"><code class="codeph">n</code></span> initialization parameters.
                              </p>
                           </li>
                           <li>
                              <p>Verify that the <code class="codeph">LOG_ARCHIVE_FORMAT</code> initialization parameter is set correctly at the standby site. 
                              </p>
                           </li>
                           <li>
                              <p>At the standby site, set the <code class="codeph">DB_FILE_NAME_CONVERT</code> and <code class="codeph">LOG_FILE_NAME_CONVERT</code> initialization parameters. Set the <code class="codeph">STANDBY_FILE_MANAGEMENT </code>initialization parameter to <code class="codeph">AUTO</code> to enable the standby site to automatically add new data files that are created at the primary site.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4915"></a><div class="props_rev_3"><a id="GUID-97282862-4EA0-42D9-97EF-34E75A29F87F" name="GUID-97282862-4EA0-42D9-97EF-34E75A29F87F"></a><h4 id="SBYDB-GUID-97282862-4EA0-42D9-97EF-34E75A29F87F" class="sect4"><span class="enumeration_section">A.4.4 </span>Roll Back After Unsuccessful Switchover and Start Over
                  </h4>
                  <div>
                     <p>For physical standby databases in situations where an error occurred and it is not possible to continue with the switchover, it might still be possible to revert the new physical standby database back to the primary role.</p>
                     <div class="section">
                        <p>Take the following steps. (This functionality is available starting with Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2).)
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Shut down and mount the new standby database (old primary).</span></li>
                        <li class="stepexpand"><span>Start Redo Apply on the new standby database.</span></li>
                        <li class="stepexpand"><span>Verify that the new standby database is ready to be switched back to the primary role. Query the <code class="codeph">SWITCHOVER_STATUS</code> column of the <code class="codeph">V$DATABASE</code> view on the new standby database. For example:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SWITCHOVER_STATUS FROM V$DATABASE;
 
SWITCHOVER_STATUS 
----------------- 
TO_PRIMARY 
1 row selected
</pre><p>A value of <code class="codeph">TO PRIMARY</code> or <code class="codeph">SESSIONS ACTIVE</code> indicates that the new standby database is ready to be switched to the primary role. Continue to query this column until the value returned is either <code class="codeph">TO PRIMARY</code> or <code class="codeph">SESSIONS ACTIVE</code>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Issue the following statement to convert the new standby database back to the primary role:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE SWITCHOVER TO <span class="italic">target_db_name</span> [FORCE];
</pre><p>If this statement is successful, then the database runs in the primary database role, and you do not need to perform any more steps.</p>
                              <p>If this statement is unsuccessful, then continue with Step 5.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>When the switchover to change the role from primary to physical standby was initiated, a trace file was written in the log directory. This trace file contains the SQL statements required to re-create the original primary control file. Locate the trace file and extract the SQL statements into a temporary file. Execute the temporary file from SQL*Plus. This reverts the new standby database back to the primary role.</span></li>
                        <li class="stepexpand"><span>Shut down the original physical standby database.</span></li>
                        <li class="stepexpand"><span>Create a new standby control file. This is necessary to resynchronize the primary database and physical standby database. Copy the physical standby control file to the original physical standby system. <a href="creating-oracle-data-guard-physical-standby.html#GUID-B471D788-AFD3-48B3-9709-D63C34DBC269" title="Create the control file for the standby database (the primary database does not have to be open, but it must at least be mounted).">Create a Control File for the Standby Database</a> describes how to create a physical standby control file.</span></li>
                        <li class="stepexpand"><span>Restart the original physical standby instance.</span><div>
                              <p>If this procedure is successful and archive gap management is enabled, then the FAL processes start and re-archive any missing archived redo log files to the physical standby database. Force a log switch on the primary database and examine the alert logs on both the primary database and physical standby database to ensure the archived redo log file sequence numbers are correct.</p>
                              <p>See <a href="oracle-data-guard-redo-transport-services.html#GUID-97EB433B-4125-4082-9276-2454349BC4F8" title="In some situations, gap resolution cannot be performed automatically and it must be performed manually.">Manual Gap Resolution</a> for information about archive gap management and <a href="setting-LOG_ARCHIVE_TRACE-initialization-parameter.html#GUID-515A27B2-5163-42E1-A78D-B6E979BA54EB" title="The Oracle database uses the LOG_ARCHIVE_TRACE initialization parameter to enable and control the generation of comprehensive trace information for log archiving and redo transport activity."> Setting Archive Tracing</a> for information about locating the trace files.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Try the switchover again.</span><div>
                              <p>At this point, the Oracle Data Guard configuration has been rolled back to its initial state, and you can try the switchover operation again (after correcting any problems that might have led to the initial unsuccessful switchover).</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4916"></a><div class="props_rev_3"><a id="GUID-0D1E5C2A-A8E9-4866-89F4-47AA1D86BB7C" name="GUID-0D1E5C2A-A8E9-4866-89F4-47AA1D86BB7C"></a><h3 id="SBYDB-GUID-0D1E5C2A-A8E9-4866-89F4-47AA1D86BB7C" class="sect3"><span class="enumeration_section">A.5 </span>Problems Switching Over to a Logical Standby Database
               </h3>
               <div>
                  <p>A switchover operation involving a logical standby database usually consists of two phases: preparing and committing. The exceptions to this are for rolling upgrades of Oracle software using a logical standby database or if you are using Oracle Data Guard broker.</p>
                  <p>If you experience failures in the context of doing a rolling upgrade using a logical standby database or during a switchover operation initiated by Oracle Data Guard broker, then go directly to <a href="troubleshooting-oracle-data-guard.html#GUID-A97E4093-B9C0-48E7-BCBE-77DB570A16C2" title="Although committing to a switchover involves a single SQL statement, internally a number of operations are performed.">Failures During the Commit Phase of a Switchover Operation</a>.
                  </p>
                  <div class="infoboxnote" id="GUID-0D1E5C2A-A8E9-4866-89F4-47AA1D86BB7C__GUID-D8BAD7F7-74E4-4C53-B3C1-B197570B786E">
                     <p class="notep1">Note:</p>
                     <p>Oracle recommends that Flashback Database be enabled for all databases in an Oracle Data Guard configuration. The steps in this section assume that you have Flashback Database enabled on all databases in your Oracle Data Guard configuration.</p>
                  </div>
               </div><a id="SBYDB4917"></a><div class="props_rev_3"><a id="GUID-7B380888-6FEF-4B79-93B9-0D25821E704E" name="GUID-7B380888-6FEF-4B79-93B9-0D25821E704E"></a><h4 id="SBYDB-GUID-7B380888-6FEF-4B79-93B9-0D25821E704E" class="sect4"><span class="enumeration_section">A.5.1 </span>Failures During the Prepare Phase of a Switchover Operation
                  </h4>
                  <div>
                     <p>If a failure occurs during the preparation phase of a switchover operation, then cancel the switchover and retry the switchover operation from the very beginning.</p>
                  </div><a id="SBYDB4918"></a><div class="props_rev_3"><a id="GUID-3A7971C1-3593-4F68-873C-26A2CCA33258" name="GUID-3A7971C1-3593-4F68-873C-26A2CCA33258"></a><h5 id="SBYDB-GUID-3A7971C1-3593-4F68-873C-26A2CCA33258" class="sect5"><span class="enumeration_section">A.5.1.1 </span>Failure While Preparing the Primary Database
                     </h5>
                     <div>
                        <p>If you encounter failure while executing the <code class="codeph">ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY</code> statement, you can cancel the prepare phase of a switchover. 
                        </p>
                        <div class="section">
                           <p>To do so, issue the following SQL statement at the primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY CANCEL;
</pre><p>You can now retry the switchover operation from the beginning.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB4919"></a><div class="props_rev_3"><a id="GUID-7A07B541-BD0D-440D-92A3-EC305F3D9821" name="GUID-7A07B541-BD0D-440D-92A3-EC305F3D9821"></a><h5 id="SBYDB-GUID-7A07B541-BD0D-440D-92A3-EC305F3D9821" class="sect5"><span class="enumeration_section">A.5.1.2 </span> Failure While Preparing the Logical Standby Database
                     </h5>
                     <div>
                        <p>If you encounter failure while executing the <code class="codeph">ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY</code> statement, you need to cancel the prepare operation at the primary database and at the target standby database.
                        </p>
                        <div class="section">
                           <p>Take the following steps:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>At the primary database, cancel the statement you had issued to prepare for the switchover:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY CANCEL;
</pre></div>
                           </li>
                           <li class="stepexpand"><span>At the logical standby database that was the target of the switchover, cancel the statement you had issued to prepare to switch over:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY CANCEL;
</pre><p>You can now retry the switchover operation from the beginning.</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div><a id="SBYDB4920"></a><div class="props_rev_3"><a id="GUID-A97E4093-B9C0-48E7-BCBE-77DB570A16C2" name="GUID-A97E4093-B9C0-48E7-BCBE-77DB570A16C2"></a><h4 id="SBYDB-GUID-A97E4093-B9C0-48E7-BCBE-77DB570A16C2" class="sect4"><span class="enumeration_section">A.5.2 </span>Failures During the Commit Phase of a Switchover Operation
                  </h4>
                  <div>
                     <p>Although committing to a switchover involves a single SQL statement, internally a number of operations are performed. </p>
                     <p>The corrective actions that you need to take depend on the state of the commit to switchover operation when the error was encountered.</p>
                  </div><a id="SBYDB01415"></a><div class="props_rev_3"><a id="GUID-46D11649-5971-4A47-BA25-6FFAD2D4B83E" name="GUID-46D11649-5971-4A47-BA25-6FFAD2D4B83E"></a><h5 id="SBYDB-GUID-46D11649-5971-4A47-BA25-6FFAD2D4B83E" class="sect5"><span class="enumeration_section">A.5.2.1 </span>Failure to Convert the Original Primary Database
                     </h5>
                     <div>
                        <p>If you encounter failures while executing the <code class="codeph">ALTER DATABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code> statement, there are corrective steps you can take. 
                        </p>
                        <div class="section">
                           <p></p>
                           <ol>
                              <li>
                                 <p>Check the <code class="codeph">DATABASE_ROLE</code> column of the <code class="codeph">V$DATABASE</code> fixed view on the original primary database:
                                 </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DATABASE_ROLE FROM V$DATABASE;
</pre><ul style="list-style-type: disc;">
                                    <li>
                                       <p>If the column contains a value of <code class="codeph">LOGICAL STANDBY</code>, the switchover operation has completed, but has failed during a post-switchover task. In this situation, Oracle recommends that you shut down and reopen the database.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If the column contains a value of <code class="codeph">PRIMARY</code>, proceed to Step 2.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Perform the following query on the original primary:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME = 'END_PRIMARY';
</pre><ul style="list-style-type: disc;">
                                    <li>
                                       <p>If the query returns a 0, the primary is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any corrective action. You can proceed with the commit to switchover operation or cancel the switchover operation as outlined in <a href="troubleshooting-oracle-data-guard.html#GUID-7A07B541-BD0D-440D-92A3-EC305F3D9821" title="If you encounter failure while executing the ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY statement, you need to cancel the prepare operation at the primary database and at the target standby database."> Failure While Preparing the Logical Standby Database</a>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If the query returns a 1, the primary is in an inconsistent state, and you need to proceed to Step 3.</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Take corrective action at the original primary database to maintain its ability to be protected by existing or newly instantiated logical standby databases. </p>
                                 <p>You can either fix the underlying cause of the error raised during the commit to switchover operation and reissue the SQL statement (<code class="codeph">ALTER DTABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code>) or you can take the following steps:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>From the alert log of the instance where you initiated the commit to switchover command, determine the SCN needed to flash back to the original primary. This information is displayed after the <code class="codeph">ALTER DATABASE COMMIT TO SWITCHOVER TO LOGICAL STANDBY</code> SQL statement:
                                       </p><pre class="oac_no_warn" dir="ltr">LOGSTDBY: Preparing the COMMIT TO SWITCHOVER TO LOGICAL STANDBY DDL at scn [flashback_scn].
</pre></li>
                                    <li>
                                       <p>Shut down all instances of the primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
</pre></li>
                                    <li>
                                       <p>Mount the primary database in exclusive mode:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP MOUNT;
</pre></li>
                                    <li>
                                       <p>Flash back the database to the SCN taken from the alert log:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; FLASHBACK DATABASE TO BEFORE SCN &lt;flashback_scn&gt;;
</pre></li>
                                    <li>
                                       <p>Open the primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP;
</pre></li>
                                    <li>
                                       <p>Lower the database guard at the original primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD NONE;
</pre></li>
                                 </ol>
                                 <p>At this point the primary is in a state identical to that it was in before the commit	switchover command was issued. You do not need to take any corrective action. you can proceed with the commit to switchover operation or cancel the switchover 	operation as outlined in <a href="troubleshooting-oracle-data-guard.html#GUID-3A7971C1-3593-4F68-873C-26A2CCA33258" title="If you encounter failure while executing the ALTER DATABASE PREPARE TO SWITCHOVER TO LOGICAL STANDBY statement, you can cancel the prepare phase of a switchover.">Failure While Preparing the Primary Database </a>.
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB01420"></a><div class="props_rev_3"><a id="GUID-8EF3068B-4A91-43A9-8004-5B6418CE9482" name="GUID-8EF3068B-4A91-43A9-8004-5B6418CE9482"></a><h5 id="SBYDB-GUID-8EF3068B-4A91-43A9-8004-5B6418CE9482" class="sect5"><span class="enumeration_section">A.5.2.2 </span>Failure to Convert the Target Logical Standby Database
                     </h5>
                     <div>
                        <p>If you encounter failures while executing the <code class="codeph">ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code> statement, there are corrective steps you can take.
                        </p>
                        <div class="section">
                           <ol>
                              <li>
                                 <p>Check the <code class="codeph">DATABASE_ROLE</code> column of the <code class="codeph">V$DATABASE</code> fixed view on the target standby database:
                                 </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DATABASE_ROLE FROM V$DATABASE;
</pre><ul style="list-style-type: disc;">
                                    <li>
                                       <p>If the column contains a value <code class="codeph">PRIMARY</code>, the switchover operation has completed, but has failed during a post-switchover task. In this situation, you must perform the following steps:
                                       </p>
                                       <ol type="a">
                                          <li>
                                             <p>Shut down and reopen the database.</p>
                                          </li>
                                          <li>
                                             <p>Issue an <code class="codeph">ALTER DATABASE GUARD NONE</code> command to remove write restrictions to the database.
                                             </p>
                                          </li>
                                       </ol>
                                    </li>
                                    <li>
                                       <p>If the column contains a value of <code class="codeph">LOGICAL STANDBY</code>, proceed to Step 2.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Perform the following query on the target logical standby:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME = 'BEGIN_PRIMARY';
</pre><ul style="list-style-type: disc;">
                                    <li>
                                       <p>If the query returns a 0, the logical standby is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any corrective action. You can proceed with the commit to switchover operations or cancel the switchover operation as outlined in <a href="troubleshooting-oracle-data-guard.html#GUID-7A07B541-BD0D-440D-92A3-EC305F3D9821" title="If you encounter failure while executing the ALTER DATABASE PREPARE TO SWITCHOVER TO PRIMARY statement, you need to cancel the prepare operation at the primary database and at the target standby database."> Failure While Preparing the Logical Standby Database</a>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If the query returns a 1, then the logical standby is in an inconsistent state. Proceed to Step 3.</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Take corrective action at the logical standby to maintain its ability to either become the new primary or become a bystander to a different new primary. </p>
                                 <p>You can either fix the underlying cause of the error raised during the commit to switchover operation and reissue the SQL statement (<code class="codeph">ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code>) or you can take the following steps to flash back the logical standby database to a point of consistency just prior to the commit to switchover attempt:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>From the alert log of the instance where you initiated the commit to switchover command, determine the SCN needed to flash back to the logical standby. This information is displayed after the <code class="codeph">ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY</code> SQL statement:
                                       </p><pre class="oac_no_warn" dir="ltr">LOGSTDBY: Preparing the COMMIT TO SWITCHOVER TO PRIMARY DDL at scn [flashback_scn].
</pre></li>
                                    <li>
                                       <p>Shut down all instances of the target standby database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
</pre></li>
                                    <li>
                                       <p>Mount the target logical standby database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP MOUNT;
</pre></li>
                                    <li>
                                       <p>Flash back the target logical standby to the desired SCN:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; FLASHBACK DATABASE TO BEFORE SCN &lt;flashback_scn&gt;;
</pre></li>
                                    <li>
                                       <p>Open the database (in case of an Oracle RAC, open all instances);</p><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP OPEN;
</pre></li>
                                 </ol>
                              </li>
                           </ol>
                           <p>At this point the target standby is in a state identical to that it was in before the commit to switchover command was issued. You do not need to take any further corrective action. You can proceed with the commit to switchover operation.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="SBYDB5087"></a><a id="SBYDB4921"></a><div class="props_rev_3"><a id="GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A" name="GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A"></a><h3 id="SBYDB-GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A" class="sect3"><span class="enumeration_section">A.6 </span>What to Do If SQL Apply Stops
               </h3>
               <div>
                  <p>When an unsupported statement or package is encountered, SQL Apply stops. </p>
                  <div class="section">
                     <p>Apply services cannot apply unsupported DML statements, DDL statements, and Oracle supplied packages to a logical standby database running SQL Apply. </p>
                     <p>If SQL Apply has stopped because of an unsupported statement or package, you can take the actions described in <a href="troubleshooting-oracle-data-guard.html#GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A__G640603" title="This 2 column table lists typical reasons why SQL Apply stops and describes possible solutions to correct each situation.">Table A-1</a> to correct the situation and start SQL Apply on the logical standby database again.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformalwide" id="GUID-E2C9EEB9-CDCE-46B4-A7ED-D60B7FCD657A__G640603">
                     <p class="titleintable">Table A-1 Fixing Typical SQL Apply Errors</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Fixing Typical SQL Apply Errors" summary="This 2 column table lists typical reasons why SQL Apply stops and describes possible solutions to correct each situation." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d58098e2584">If...</th>
                              <th align="left" valign="bottom" width="57%" id="d58098e2587">Then...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d58098e2592" headers="d58098e2584 ">
                                 <p>You suspect an unsupported statement or Oracle supplied package was encountered</p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d58098e2592 d58098e2587 ">
                                 <p>Find the last statement in the <a id="d58098e2598" class="indexterm-anchor"></a><a id="d58098e2600" class="indexterm-anchor"></a><code class="codeph">DBA_LOGSTDBY_EVENTS</code> view. It shows the statement and error that caused SQL Apply to fail. If an incorrect SQL statement caused SQL Apply to fail, transaction information, as well as the statement and error information, can be viewed. The transaction information can be used with LogMiner tools to understand the cause of the problem.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d58098e2608" headers="d58098e2584 ">
                                 <p>An error requiring database management occurred, such as running out of space in a particular tablespace</p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d58098e2608 d58098e2587 ">
                                 <p>Fix the problem and resume SQL Apply using the <a id="d58098e2614" class="indexterm-anchor"></a><a id="d58098e2618" class="indexterm-anchor"></a><code class="codeph">ALTER DATABASE START LOGICAL STANDBY APPLY</code> statement.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d58098e2626" headers="d58098e2584 ">
                                 <p>An error occurred because a SQL statement was entered incorrectly, such as an incorrect standby database filename being entered in a tablespace statement</p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d58098e2626 d58098e2587 ">
                                 <p>Enter the correct SQL statement and use the <a id="d58098e2632" class="indexterm-anchor"></a><a id="d58098e2636" class="indexterm-anchor"></a><code class="codeph">DBMS_LOGSTDBY.SKIP_TRANSACTION</code> procedure to ensure the incorrect statement is ignored the next time SQL Apply is run. Then, restart SQL Apply using the <code class="codeph">ALTER DATABASE START LOGICAL STANDBY APPLY</code> statement.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d58098e2647" headers="d58098e2584 ">
                                 <p>An error occurred because skip parameters were incorrectly set up, such as specifying that all DML for a given table be skipped but <code class="codeph">CREATE</code>, <code class="codeph">ALTER</code>, and <code class="codeph">DROP TABLE</code> statements were not specified to be skipped
                                 </p>
                              </td>
                              <td align="left" valign="top" width="57%" headers="d58098e2647 d58098e2587 ">
                                 <p>Issue the <a id="d58098e2662" class="indexterm-anchor"></a><a id="d58098e2666" class="indexterm-anchor"></a><code class="codeph">DBMS_LOGSTDBY.SKIP('TABLE','schema_name','table_name',null)</code> procedure, then restart SQL Apply.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>See <a href="oracle-data-guard-in-oracle-database-views.html#GUID-FF72163C-78B0-475F-B4CE-135EF288A32A" title="There are a number of views that are especially useful when monitoring an Oracle Data Guard environment."> Views Relevant to Oracle Data Guard </a> for information about querying the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view to determine the cause of failures.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="SBYDB00440"></a><div class="props_rev_3"><a id="GUID-5B879B01-2433-4B08-8D58-E91DBA58FEF7" name="GUID-5B879B01-2433-4B08-8D58-E91DBA58FEF7"></a><h3 id="SBYDB-GUID-5B879B01-2433-4B08-8D58-E91DBA58FEF7" class="sect3"><span class="enumeration_section">A.7 </span>Network Tuning for Redo Data Transmission
               </h3>
               <div>
                  <p>For optimal performance, set the Oracle Net SDU parameter to its maximum value of 65535 bytes in each Oracle Net connect descriptor used by redo transport services.</p>
                  <p>The following example shows a database initialization parameter file segment that defines a remote destination <code class="codeph">netserv</code>:
                  </p><pre class="oac_no_warn" dir="ltr">LOG_ARCHIVE_DEST_3='SERVICE=netserv'
</pre><p>The f<a id="d58098e2781" class="indexterm-anchor"></a><a id="d58098e2785" class="indexterm-anchor"></a>ollowing example shows the definition of that service name in the <a id="d58098e2790" class="indexterm-anchor"></a><a id="d58098e2794" class="indexterm-anchor"></a><a id="d58098e2798" class="indexterm-anchor"></a><a id="d58098e2802" class="indexterm-anchor"></a><code class="codeph">tnsnames.ora</code> file:
                  </p><pre class="oac_no_warn" dir="ltr">netserv=(DESCRIPTION=(SDU=32768)(ADDRESS=(PROTOCOL=tcp)(HOST=host) (PORT=1521)) (CONNECT_DATA=(SERVICE_NAME=srvc)))
</pre><p>The following example shows the definition in the <code class="codeph">listener.ora</code> file:
                  </p><pre class="oac_no_warn" dir="ltr">LISTENER=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=tcp)
(HOST=host)(PORT=1521))))

SID_LIST_LISTENER=(SID_LIST=(SID_DESC=(SDU=32768)(SID_NAME=sid)
(GLOBALDBNAME=srvc)(ORACLE_HOME=/oracle)))
</pre><p>If you archive to a remote site using a high-latency or high-bandwidth network link, you can improve performance by using the <code class="codeph">SQLNET.SEND_BUF_SIZE</code> and <code class="codeph">SQLNET.RECV_BUF_SIZE</code> Oracle Net profile parameters to increase the size of the network send and receive I/O buffers.
                  </p>
                  <p>See <a href="../netag/optimizing-performance.html#NETAG0141" target="_blank"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a> for information about other ways to change the Oracle NET SDU parameter.
                  </p>
               </div>
            </div><a id="SBYDB4922"></a><div class="props_rev_3"><a id="GUID-5F933817-AD03-43D7-878D-E4B115448DAD" name="GUID-5F933817-AD03-43D7-878D-E4B115448DAD"></a><h3 id="SBYDB-GUID-5F933817-AD03-43D7-878D-E4B115448DAD" class="sect3"><span class="enumeration_section">A.8 </span>Slow Disk Performance on Standby Databases
               </h3>
               <div>
                  <p>If asynchronous I/O on the file system itself is showing performance problems, try mounting the file system using the Direct I/O option or setting the <code class="codeph">FILESYSTEMIO_OPTIONS=SETALL</code> initialization parameter. 
                  </p>
                  <p>The maximum I/O size setting is 1 MB.</p>
               </div>
            </div><a id="SBYDB4923"></a><div class="props_rev_3"><a id="GUID-82348347-C02B-4179-A325-3192E6F94737" name="GUID-82348347-C02B-4179-A325-3192E6F94737"></a><h3 id="SBYDB-GUID-82348347-C02B-4179-A325-3192E6F94737" class="sect3"><span class="enumeration_section">A.9 </span>Log Files Must Match to Avoid Primary Database Shutdown
               </h3>
               <div>
                  <p>If you have configured a standby redo log on one or more standby databases in the configuration, ensure the size of the standby redo log files on each standby database exactly matches the size of the online redo log files on the primary database.</p>
                  <p>At log switch time, if there are no available standby redo log files that match the size of the new current online redo log file on the primary database:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The primary database shuts down if it is operating in maximum protection mode, </p>
                        <p><span class="italic"><span class="bold">or</span></span> 
                        </p>
                     </li>
                     <li>
                        <p>The RFS process on the standby database creates an archived redo log file on the standby database and writes the following message in the alert log:</p><pre class="oac_no_warn" dir="ltr">No standby log files of size &lt;#&gt; blocks available.
</pre></li>
                  </ul>
                  <p>For example, if the primary database uses two online redo log groups whose log files are 100K, then the standby database should have 3 standby redo log groups with log file sizes of 100K. </p>
                  <p>Also, whenever you add a redo log group to the primary database, you must add a corresponding standby redo log group to the standby database. This reduces the probability of adverse effects on the primary database because a standby redo log file of the required size is not available at log switch time.</p>
               </div>
            </div><a id="SBYDB4924"></a><div class="props_rev_3"><a id="GUID-B1551FC6-1B9F-49A5-A462-124697A449C3" name="GUID-B1551FC6-1B9F-49A5-A462-124697A449C3"></a><h3 id="SBYDB-GUID-B1551FC6-1B9F-49A5-A462-124697A449C3" class="sect3"><span class="enumeration_section">A.10 </span>Troubleshooting a Logical Standby Database
               </h3>
               <div>
                  <p>These troubleshooting tips can help you recover from errors.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-1D92D18C-488C-4896-9592-33FBB4BEEAB2" title="Logical standby databases maintain user tables, sequences, and jobs. To maintain other objects, you must reissue the DDL statements seen in the redo data stream.">Recovering from Errors</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-0AB63229-F105-44EF-AB5E-29E19946DC2F" title="Oracle SQL*Loader provides a method of loading data from different sources into the Oracle Database.">Troubleshooting SQL*Loader Sessions</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-0C23E281-5ED2-4411-851C-B609EA1C350E" title="One of the primary causes for long-running transactions in a SQL Apply environment is full table scans.">Troubleshooting Long-Running Transactions</a></p>
                     </li>
                     <li>
                        <p><a href="troubleshooting-oracle-data-guard.html#GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD" title="If SQL Apply returns the ORA-1403: No Data Found error, then it may be possible to use Flashback Transaction to reconstruct the missing data.">Troubleshooting ORA-1403 Errors with Flashback Transactions</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4925"></a><div class="props_rev_3"><a id="GUID-1D92D18C-488C-4896-9592-33FBB4BEEAB2" name="GUID-1D92D18C-488C-4896-9592-33FBB4BEEAB2"></a><h4 id="SBYDB-GUID-1D92D18C-488C-4896-9592-33FBB4BEEAB2" class="sect4"><span class="enumeration_section">A.10.1 </span>Recovering from Errors
                  </h4>
                  <div>
                     <p>Logical standby databases maintain user tables, sequences, and jobs. To maintain other objects, you must reissue the DDL statements seen in the redo data stream.</p>
                     <p>If SQL Apply fails, an error is recorded in the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> table. The following sections demonstrate how to recover from two such errors.
                     </p>
                  </div><a id="SBYDB4926"></a><div class="props_rev_3"><a id="GUID-16CE2533-7190-4717-88E0-BDC53DBD887B" name="GUID-16CE2533-7190-4717-88E0-BDC53DBD887B"></a><h5 id="SBYDB-GUID-16CE2533-7190-4717-88E0-BDC53DBD887B" class="sect5"><span class="enumeration_section">A.10.1.1 </span>DDL Transactions Containing File Specifications
                     </h5>
                     <div>
                        <p>DDL statements are executed the same way on the primary database and the logical standby database.</p>
                        <div class="section">
                           <p>If the underlying file structure is the same on both databases, then the DDL executes on the standby database as expected.</p>
                           <p>If an error was caused by a DDL transaction containing a file specification that did not match in the logical standby database environment, perform the following steps to fix the problem:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Use the <code class="codeph">ALTER SESSION DISABLE</code> <code class="codeph">GUARD</code> statement to bypass the database guard so you can make modifications to the logical standby database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD;
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Execute the DDL statement, using the correct file specification, and then reenable the database guard. For example:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; <a id="d58098e3290" class="indexterm-anchor"></a><a id="d58098e3294" class="indexterm-anchor"></a>ALTER TABLESPACE t_table ADD DATAFILE '/dbs/t_db.f' SIZE 100M REUSE;
SQL&gt; ALTER SESSION ENABLE GUARD;
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Start SQL Apply on the logical standby database and skip the failed transaction.</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE -
&gt; SKIP FAILED TRANSACTION;
</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>In some situations, the problem that caused the transaction to fail can be corrected and SQL Apply restarted without skipping the transaction. An example of this might be when available space is exhausted. (Do not let the primary and logical standby databases diverge when skipping DDL transactions. If possible, manually execute a compensating transaction in place of the skipped transaction.)</p>
                           <p>The following example shows SQL Apply stopping, the error being corrected, and then restarting SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SET LONG 1000
SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT  = 'DD-MON-YY HH24:MI:SS';

Session altered.

SQL&gt; SELECT EVENT_TIME, COMMIT_SCN, EVENT, STATUS FROM DBA_LOGSTDBY_EVENTS;

EVENT_TIME              COMMIT_SCN
------------------ ---------------
EVENT
-------------------------------------------------------------------------------
STATUS
-------------------------------------------------------------------------------
22-OCT-03 15:47:58

ORA-16111: log mining and apply setting up

22-OCT-03 15:48:04          209627
insert into "SCOTT"."EMP"
values
   "EMPNO" = 7900,
   "ENAME" = 'ADAMS',
   "JOB" = 'CLERK',
   "MGR" IS NULL,
   "HIREDATE" = TO_DATE('22-OCT-03', 'DD-MON-RR'),
   "SAL" = 950,
   "COMM" IS NULL,
   "DEPTNO" IS NULL
ORA-01653: unable to extend table SCOTT.EMP by %200 bytes in tablespace T_TABLE
</pre><p>In the example, the <code class="codeph">ORA-01653</code> message indicates that the tablespace was full and unable to extend itself. To correct the problem, add a new data file to the tablespace. For example:
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; <a id="d58098e3321" class="indexterm-anchor"></a><a id="d58098e3323" class="indexterm-anchor"></a><a id="d58098e3327" class="indexterm-anchor"></a>ALTER TABLESPACE t_table ADD DATAFILE '/dbs/t_db.f' SIZE 60M;
Tablespace altered.
</pre><p>Then, restart SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.
</pre><p>When SQL Apply restarts, the transaction that failed is reexecuted and applied to the logical standby database. </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB4927"></a><div class="props_rev_3"><a id="GUID-A146A62B-550F-4520-9001-C11C043E3A64" name="GUID-A146A62B-550F-4520-9001-C11C043E3A64"></a><h5 id="SBYDB-GUID-A146A62B-550F-4520-9001-C11C043E3A64" class="sect5"><span class="enumeration_section">A.10.1.2 </span>Recovering from DML Failures
                     </h5>
                     <div>
                        <p>Do not use the <code class="codeph">SKIP_TRANSACTION</code> procedure to filter DML failures because it will skip not only the DML seen in the events table, but all the DML associated with the transaction as well. 
                        </p>
                        <div class="section">
                           <p>DML failures usually indicate a problem with a specific table. For example, assume the failure is an out-of-storage error that you cannot resolve immediately. The following steps demonstrate one way to respond to this problem.</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Bypass the table, but not the transaction, by adding the table to the skip list:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP('DML','SCOTT','EMP');
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre><p>From this point on, DML activity for the <code class="codeph">SCOTT.EMP</code> table is not applied. After you correct the storage problem, you can fix the table, provided you set up a database link to the primary database that has administrator privileges to run procedures in the <code class="codeph">DBMS_LOGSTDBY</code> package. 
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>Using the database link to the primary database, drop the local <code class="codeph">SCOTT.EMP</code> table and then re-create it, and pull the data over to the standby database.</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
SQL&gt; EXECUTE DBMS_LOGSTDBY.INSTANTIATE_TABLE('SCOTT','EMP','PRIMARYDB');
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre></div>
                           </li>
                           <li class="stepexpand"><span>To ensure a consistent view across the newly instantiated table and the rest of the database, wait for SQL Apply to catch up with the primary database before querying this table. Refer to <a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" title="Typically, you use the DBMS_LOGSTDBY.INSTANTIATE_TABLE procedure to re-create a table after an unrecoverable operation.">Adding or Re-Creating Tables On a Logical Standby Database</a> for a detailed example.</span></li>
                        </ol>
                     </div>
                  </div>
               </div><a id="SBYDB4928"></a><div class="props_rev_3"><a id="GUID-0AB63229-F105-44EF-AB5E-29E19946DC2F" name="GUID-0AB63229-F105-44EF-AB5E-29E19946DC2F"></a><h4 id="SBYDB-GUID-0AB63229-F105-44EF-AB5E-29E19946DC2F" class="sect4"><span class="enumeration_section">A.10.2 </span>Troubleshooting SQL*Loader Sessions
                  </h4>
                  <div>
                     <p>Oracle SQL*Loader provides a method of loading data from different sources into the Oracle Database.</p>
                     <p>This topic analyzes some of the features of the SQL*Loader utility as it pertains to SQL Apply.</p>
                     <p>Regardless of the method of data load chosen, the SQL*Loader control files contain an instruction on what to do to the current contents of the Oracle table into which the new data is to be loaded, via the keywords of <code class="codeph">APPEND</code> and <code class="codeph">REPLACE</code>. The following examples show how to use these keywords on a table named <code class="codeph">LOAD_STOK</code>:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When using the <code class="codeph">APPEND keyword</code>, the new data to be loaded is appended to the contents of the <code class="codeph">LOAD_STOK</code> table:
                           </p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INTO TABLE LOAD_STOK APPEND
</pre></li>
                        <li>
                           <p>When using the <code class="codeph">REPLACE</code> keyword, the contents of the <code class="codeph">LOAD_STOK</code> table are deleted prior to loading new data. Oracle SQL*Loader uses the <code class="codeph">DELETE</code> statement to purge the contents of the table, in a single transaction:
                           </p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INTO TABLE LOAD_STOK REPLACE
</pre></li>
                     </ul>
                     <p>Rather than using the <code class="codeph">REPLACE</code> keyword in the SQL*Loader script, Oracle recommends that prior to loading the data, you issue the SQL*Plus <code class="codeph">TRUNCATE TABLE</code> command against the table on the primary database. This has the same effect of purging both the primary and standby databases copy of the table in a manner that is both fast and efficient because the <code class="codeph">TRUNCATE TABLE</code> command is recorded in the online redo log files and is issued by SQL Apply on the logical standby database. 
                     </p>
                     <p>The SQL*Loader script may continue to contain the <code class="codeph">REPLACE</code> keyword, but it now attempts to <code class="codeph">DELETE</code> zero rows from the object on the primary database. Because no rows were deleted from the primary database, there is no redo recorded in the redo log files. Therefore, no <code class="codeph">DELETE</code> statement is issued against the logical standby database.
                     </p>
                     <p>Issuing the <code class="codeph">REPLACE</code> keyword without the SQL statement <code class="codeph">TRUNCATE TABLE</code> provides the following potential problems for SQL Apply when the transaction needs to be applied to the logical standby database.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If the table currently contains a significant number of rows, then these rows need to be deleted from the standby database. Because SQL Apply is not able to determine the original syntax of the statement, SQL Apply must issue a <code class="codeph">DELETE</code> statement for each row purged from the primary database.
                           </p>
                           <p>For example, if the table on the primary database originally had 10,000 rows, then Oracle SQL*Loader issues a single <code class="codeph">DELETE</code> statement to purge the 10,000 rows. On the standby database, SQL Apply does not know that all rows are to be purged, and instead must issue 10,000 individual <code class="codeph">DELETE</code> statements, with each statement purging a single row.
                           </p>
                        </li>
                        <li>
                           <p>If the table on the standby database does not contain an index that can be used by SQL Apply, then the <code class="codeph">DELETE</code> statement issues a Full Table Scan to purge the information.
                           </p>
                           <p>Continuing with the previous example, because SQL Apply has issued 10,000 individual <code class="codeph">DELETE</code> statements, this could result in 10,000 Full Table Scans being issued against the standby database.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="SBYDB5088"></a><a id="SBYDB5089"></a><a id="SBYDB5091"></a><a id="SBYDB5092"></a><a id="SBYDB5093"></a><a id="SBYDB4929"></a><div class="props_rev_3"><a id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E" name="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E"></a><h4 id="SBYDB-GUID-0C23E281-5ED2-4411-851C-B609EA1C350E" class="sect4"><span class="enumeration_section">A.10.3 </span>Troubleshooting Long-Running Transactions
                  </h4>
                  <div>
                     <p>One of the primary causes for long-running transactions in a SQL Apply environment is full table scans.</p>
                     <p>Additionally, long-running transactions could be the result of SQL statements being replicated to the standby database, such as when creating or rebuilding an index.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-63E4BBA7-7A71-4123-BA89-DDB5393067C6">Identifying Long-Running Transactions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If SQL Apply is executing a single SQL statement for a long period of time, then a warning message similar to the following is reported in the alert log of the SQL Apply instance:</p><pre class="oac_no_warn" dir="ltr">Mon Feb 17 14:40:15 2003
WARNING: the following transaction makes no progress
WARNING: in the last 30 seconds for the given message!
WARNING: xid =
0x0016.007.000017b6 cscn = 1550349, message# = 28, slavid = 1
knacrb: no offending session found (not ITL pressure)
</pre><p>Note the following about the warning message:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>This warning is similar to the warning message returned for interested transaction list (ITL) pressure, with the exception being the last line that begins with <code class="codeph">knacrb</code>. The final line indicates:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>A Full Table Scan may be occurring</p>
                                 </li>
                                 <li>
                                    <p>This issue has nothing to do with interested transaction list (ITL) pressure</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>This warning message is reported only if a single statement takes more than 30 seconds to execute.</p>
                           </li>
                        </ul>
                        <p>It may not be possible to determine the SQL statement being executed by the long-running statement, but the following SQL statement may help in identifying the database objects on which SQL Apply is operating:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SAS.SERVER_ID -
&gt;  , SS.OWNER -
&gt;  , SS.OBJECT_NAME -
&gt;  , SS.STATISTIC_NAME -
&gt;  , SS.VALUE -
&gt;  FROM V$SEGMENT_STATISTICS SS -
&gt;  , V$LOCK L -
&gt;  , V$STREAMS_APPLY_SERVER SAS -
&gt;  WHERE SAS.SERVER_ID = &amp;SLAVE_ID -
&gt;  AND L.SID = SAS.SID -
&gt;  AND L.TYPE = 'TM' -
&gt;  AND SS.OBJ# = L.ID1;
</pre><p>Additionally, you can issue the following SQL statement to identify the SQL statement that has resulted in a large number of disk reads being issued per execution:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SUBSTR(SQL_TEXT,1,40) -
&gt;  , DISK_READS -
&gt;  , EXECUTIONS -
&gt;  , DISK_READS/EXECUTIONS -
&gt;  , HASH_VALUE -
&gt;  , ADDRESS -
&gt;  FROM V$SQLAREA -
&gt;  WHERE DISK_READS/GREATEST(EXECUTIONS,1) &gt; 1 -
&gt;  AND ROWNUM &lt; 10 -
&gt;  ORDER BY DISK_READS/GREATEST(EXECUTIONS,1) DESC;
</pre><p>Oracle recommends that all tables have primary key constraints defined, which automatically means that the column is defined as <code class="codeph">NOT NULL</code>. For any table where a primary-key constraint cannot be defined, define an index on an appropriate column that is defined as <code class="codeph">NOT NULL</code>. If a suitable column does not exist on the table, then the table should be reviewed and, if possible, skipped by SQL Apply. The following steps describe how to skip all DML statements issued against the <code class="codeph">FTS</code> table on the <code class="codeph">SCOTT</code> schema:
                        </p>
                        <ol>
                           <li>
                              <p>Stop SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered
</pre></li>
                           <li>
                              <p>Configure the skip procedure for the <code class="codeph">SCOTT.FTS</code> table for all DML transactions:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP(stmt =&gt; 'DML' , -
&gt;  schema_name =&gt; 'SCOTT' , -
&gt;  object_name =&gt; 'FTS');
PL/SQL procedure successfully completed
</pre></li>
                           <li>
                              <p>Start SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-E29F181A-1263-4EA0-B736-910DBE293ECB">Troubleshooting ITL Pressure</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Interested transaction list (ITL) pressure is reported in the alert log of the SQL Apply instance. The following shows an example of the warning messages.</p><pre class="oac_no_warn" dir="ltr">Tue Apr 22 15:50:42 2003
WARNING: the following transaction makes no progress
WARNING: in the last 30 seconds for the given message!
WARNING: xid =
0x0006.005.000029fa cscn = 2152982, message# = 2, slavid = 17</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-2F5B37CF-D061-4498-B18C-C5E21E40C7F7">Real-Time Analysis</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The messages shown in the above output indicate that the SQL Apply process (<code class="codeph">slavid</code>) #17 has not made any progress in the last 30 seconds. To determine the SQL statement being issued by the Apply process, issue the following query:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SA.SQL_TEXT -
&gt;  FROM V$SQLAREA SA -
  &gt;  , V$SESSION S -
  &gt;  , V$STREAMS_APPLY_SERVER SAS -
  &gt;  WHERE SAS.SERVER_ID = &amp;SLAVEID -
  &gt;  AND S.SID = SAS.SID -
  &gt;  AND SA.ADDRESS = S.SQL_ADDRESS

SQL_TEXT
------------------------------------------------------------
insert into "APP"."LOAD_TAB_1" p("PK","TEXT")values(:1,:2)
</pre><p>An alternative method to identifying ITL pressure is to query the <code class="codeph">V$LOCK</code> view, as shown in the following example. Any session that has a request value of 4 on a <code class="codeph">TX</code> lock, is waiting for an ITL to become available.
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SID,TYPE,ID1,ID2,LMODE,REQUEST -
&gt; FROM V$LOCK -
&gt; WHERE TYPE = 'TX'

SID        TY ID1        ID2        LMODE      REQUEST
---------- -- ---------- ---------- ---------- ----------
         8 TX     327688         48          6          0
        10 TX     327688         48          0          4
</pre><p>In this example, <code class="codeph">SID 10</code> is waiting for the <code class="codeph">TX</code> lock held by <code class="codeph">SID 8</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-6D90F34F-5EF9-440E-8F32-B4885586A57B">Post-Incident Review</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Pressure for a segment's ITL is unlikely to last for an extended period of time. In addition, ITL pressure that lasts for less than 30 seconds is not reported in the standby databases alert log. Therefore, to determine which objects have been subjected to ITL pressure, issue the following statement:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT OWNER, OBJECT_NAME, OBJECT_TYPE -
&gt;  FROM V$SEGMENT_STATISTICS -
&gt;  WHERE STATISTIC_NAME = 'ITL waits' -
&gt;  AND VALUE &gt; 0 -
&gt;  ORDER BY VALUE;
</pre><p>This statement reports all database segments that have had ITL pressure at some time since the instance was last started.</p>
                        <div class="infoboxnote" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-77DCB093-F8D8-42C6-AB03-3D8F7AACC1A8">
                           <p class="notep1">Note:</p>
                           <p>This SQL statement is not limited to a logical standby databases in the Oracle Data Guard environment. It is applicable to any Oracle database.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-3E5573C0-38F5-4CAC-A5B4-7E86C15E5BF6">Resolving ITL Pressure</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To increase the <code class="codeph">INITRANS</code> integer for a particular database object, it is necessary to first stop SQL Apply.
                        </p>
                        <div class="infoboxnotealso" id="GUID-0C23E281-5ED2-4411-851C-B609EA1C350E__GUID-8F389FAA-0AD0-442D-803C-697AAFB05332">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=SQLRF52296" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about specifying the <code class="codeph">INITRANS</code> integer, which is the initial number of concurrent transaction entries allocated within each data block allocated to the database object
                           </p>
                        </div>
                        <p>The following example shows the necessary steps to increase the <code class="codeph">INITRANS</code> for table <code class="codeph">load_tab_1</code> in the schema <code class="codeph">app</code>.
                        </p>
                        <ol>
                           <li>
                              <p>Stop SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered.
</pre></li>
                           <li>
                              <p>Temporarily bypass the database guard:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD;
Session altered.
</pre></li>
                           <li>
                              <p>Increase the <code class="codeph">INITRANS</code> on the standby database. For example:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER TABLE APP.LOAD_TAB_1 INITRANS 30;
Table altered
</pre></li>
                           <li>
                              <p>Reenable the database guard:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION ENABLE GUARD;
Session altered
</pre></li>
                           <li>
                              <p>Start SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.
</pre></li>
                        </ol>
                        <p>Also, consider modifying the database object on the primary database, so that in the event of a switchover, the error does not occur on the new standby database.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB5094"></a><a id="SBYDB5095"></a><a id="SBYDB4930"></a><div class="props_rev_3"><a id="GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD" name="GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD"></a><h4 id="SBYDB-GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD" class="sect4"><span class="enumeration_section">A.10.4 </span>Troubleshooting ORA-1403 Errors with Flashback Transactions
                  </h4>
                  <div>
                     <p>If SQL Apply returns the <code class="codeph">ORA-1403: No Data Found</code> error, then it may be possible to use Flashback Transaction to reconstruct the missing data.
                     </p>
                     <p>This strategy relies upon the <code class="codeph">UNDO_RETENTION</code> initialization parameter specified on the standby database instance.
                     </p>
                     <p>Under normal circumstances, the <code class="codeph">ORA-1403</code> error is not seen in a logical standby database environment. The error occurs when data in a table that is being managed by SQL Apply is modified directly on the standby database and then the same data is modified on the primary database. When the modified data is updated on the primary database and is subsequently received on the logical standby database, SQL Apply verifies the original version of the data is present on the standby database before updating the record. When this verification fails, the <code class="codeph">ORA-1403: No Data Found</code> error is returned.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD__GUID-3DD3D17C-AFB2-49B0-9E61-4B6CD7EB0DBA">The Initial Error</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When SQL Apply verification fails, the error message is reported in the alert log of the logical standby database and a record is inserted in the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view. The information in the alert log is truncated, while the error is reported in it's entirety in the database view. For example:
                        </p><pre class="oac_no_warn" dir="ltr">LOGSTDBY stmt: UPDATE "SCOTT"."MASTER"
  SET
    "NAME" = 'john'
  WHERE 
    "PK" = 1 and 
    "NAME" = 'andrew' and 
    ROWID = 'AAAAAAAAEAAAAAPAAA'
LOGSTDBY status: ORA-01403: no data found
LOGSTDBY PID 1006, oracle@staco03 (P004)
LOGSTDBY XID 0x0006.00e.00000417, Thread 1, RBA 0x02dd.00002221.10</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B25EE583-E622-4F0C-AA50-84582DFDD5DD__GUID-000D9C0B-F852-43FA-86E8-F39CC5C2C481">The Investigation</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The first step is to analyze the historical data of the table that caused the error. This can be achieved using the <code class="codeph">VERSIONS</code> clause of the <code class="codeph">SELECT</code> statement. For example, you can issue the following query on the primary database:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT VERSIONS_XID
      , VERSIONS_STARTSCN
      , VERSIONS_ENDSCN
      , VERSIONS_OPERATION
      , PK
      , NAME
   FROM SCOTT.MASTER
        VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE
  WHERE PK = 1
  ORDER BY NVL(VERSIONS_STARTSCN,0);

VERSIONS_XID     VERSIONS_STARTSCN VERSIONS_ENDSCN V  PK NAME
---------------- ----------------- --------------- - --- -------
03001900EE070000           3492279         3492290 I   1 andrew
02000D00E4070000           3492290                 D   1 andrew
</pre><p>Depending upon the amount of undo retention that the database is configured to retain (<code class="codeph">UNDO_RETENTION</code>) and the activity on the table, the information returned might be extensive and you may need to change the versions between syntax to restrict the amount of information returned. From the information returned, you can see that the record was first inserted at SCN 3492279 and then was deleted at SCN 3492290 as part of transaction ID 02000D00E4070000. Using the transaction ID, query the database to find the scope of the transaction. This is achieved by querying the <code class="codeph">FLASHBACK_TRANSACTION_QUERY</code> view.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION
     , UNDO_SQL
  FROM FLASHBACK_TRANSACTION_QUERY
 WHERE XID = HEXTORAW('02000D00E4070000');

OPERATION  UNDO_SQL
---------- ------------------------------------------------
DELETE     insert into "SCOTT"."MASTER"("PK","NAME") values
           ('1','andrew');
BEGIN
</pre><p>There is always one row returned representing the start of the transaction. In this transaction, only one row was deleted in the master table. The <code class="codeph">UNDO_SQL</code> column, when executed, restores the original data into the table.
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; INSERT INTO "SCOTT"."MASTER"("PK","NAME") VALUES ('1','ANDREW');SQL&gt; COMMIT;
</pre><p>When you restart SQL Apply, the transaction is applied to the standby database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>