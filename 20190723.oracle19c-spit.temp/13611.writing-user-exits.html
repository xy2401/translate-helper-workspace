<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Writing User Exits</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="using-dynamic-SQL.html" title="Previous" type="text/html">
      <link rel="next" href="new-features.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-dynamic-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="new-features.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">    Writing User Exits</li>
            </ol>
            <a id="GUID-B7C64641-93A1-4F04-8DAA-03187A91300C" name="GUID-B7C64641-93A1-4F04-8DAA-03187A91300C"></a><a id="ZZPRE910"></a>
            
            <h2 id="ZZPRE-GUID-B7C64641-93A1-4F04-8DAA-03187A91300C" class="sect2"><span class="enumeration_chapter">11 </span>    Writing User Exits
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter contains the following:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="writing-user-exits.html#GUID-840004FC-6F29-4046-961A-6155BD9F6927">What Is a User Exit?</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-587366A7-08C6-47AE-B6D3-E05377581E24">Why Write a User Exit?</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5">Developing a User Exit</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-CC5745DB-7907-449A-B9B7-412EE286231C">Writing a User Exit</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-A952614C-B862-4B3C-A466-BC6B002A0899">Calling a User Exit</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-FFE01920-2950-4847-BE2E-0CD2B184A028">Passing Parameters to a User Exit</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D">Returning Values to a Form</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-16350EA4-0AF0-4800-8852-A44BF707247E">An Example</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9">About Precompiling and Compiling a User Exit</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55">About Using the GENXTB Utility</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C">About Linking a User Exit into SQL*Forms</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E">Guidelines for SQL*Forms User Exits</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178">EXEC TOOLS Statements</a></p>
                  </li>
               </ul>
               <p>This chapter focuses on writing user exits for your SQL*Forms and Oracle Forms applications. First, you learn the EXEC IAF statements that allow a SQL*Forms application to interface with user exits. Then, you learn how to write and link a SQL*Forms user exit. You also learn how to use EXEC TOOLS statements with Oracle Forms. (SQL*Forms does not support EXEC TOOLS.) That way, you can use EXEC IAF statements to enhance your existing applications and EXEC TOOLS statements to build new applications. The following topics are covered:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>Common uses for user exits</p>
                  </li>
                  <li>
                     <p>Writing a user exit</p>
                  </li>
                  <li>
                     <p>Passing values between SQL*Forms and a user exit</p>
                  </li>
                  <li>
                     <p>Implementing a user exit</p>
                  </li>
                  <li>
                     <p>Calling a user exit</p>
                  </li>
                  <li>
                     <p>Guidelines for SQL*Forms user exits</p>
                  </li>
                  <li>
                     <p>Using EXEC TOOLS statements with Oracle Forms</p>
                  </li>
               </ul>
               <p>This chapter is supplemental. For more information about user exits, see the <span class="italic">SQL*Forms Designer's Reference</span>, the <span class="italic">Oracle Forms Reference Manual, Vol. 2</span>, and your system-specific Oracle manuals.
               </p>
            </div><a id="ZZPRE912"></a><a id="ZZPRE911"></a><div class="props_rev_3"><a id="GUID-840004FC-6F29-4046-961A-6155BD9F6927" name="GUID-840004FC-6F29-4046-961A-6155BD9F6927"></a><h3 id="ZZPRE-GUID-840004FC-6F29-4046-961A-6155BD9F6927" class="sect3"><span class="enumeration_section">11.1 </span>What Is a User Exit?
               </h3>
               <div>
                  <p><a id="d73980e141" class="indexterm-anchor"></a>A <span class="italic">user exit</span> is a host-language subroutine written by you and called by SQL*Forms to do special-purpose processing. You can embed SQL commands and PL/SQL blocks in your user exit, then precompile it as you would a host program. 
                  </p>
                  <p>When called by a SQL*Forms trigger, the user exit runs, then returns a status code to SQL*Forms (refer to <a href="writing-user-exits.html#GUID-840004FC-6F29-4046-961A-6155BD9F6927__CHDHCGFF">Figure 11-1</a>). Your user exit can display messages on the <a id="d73980e151" class="indexterm-anchor"></a>SQL*Forms status line, get and put field values, manipulate Oracle data, do high-speed computations and table lookups -- even log on to different databases. 
                  </p>
                  <div class="figure" id="GUID-840004FC-6F29-4046-961A-6155BD9F6927__CHDHCGFF">
                     <p class="titleinfigure">Figure 11-1 SQL*Forms </p><img src="img/image014.gif" alt="Description of Figure 11-1 follows" title="Description of Figure 11-1 follows" longdesc="img_text/image014.html"><br><a href="img_text/image014.html">Description of "Figure 11-1 SQL*Forms "</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ZZPRE913"></a><div class="props_rev_3"><a id="GUID-587366A7-08C6-47AE-B6D3-E05377581E24" name="GUID-587366A7-08C6-47AE-B6D3-E05377581E24"></a><h3 id="ZZPRE-GUID-587366A7-08C6-47AE-B6D3-E05377581E24" class="sect3"><span class="enumeration_section">11.2 </span>Why Write a User Exit?
               </h3>
               <div>
                  <p>SQL*Forms Version 3 enables use PL/SQL blocks in triggers. So, in most cases, instead of calling a user exit, you can use the procedural power of PL/SQL. If the need arises, you can call user exits from a PL/SQL block with the <code class="codeph">USER_EXIT</code> function.
                  </p>
                  <p>User exits are harder to write and implement than SQL, PL/SQL, or SQL*Forms commands. So, you will probably use them only to do processing that is beyond the scope of SQL, PL/SQL, and SQL*Forms. Some <a id="d73980e188" class="indexterm-anchor"></a>common uses follow:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Operations more quickly or easily performed in third generation languages like C and FORTRAN (for example, numeric integration)</p>
                     </li>
                     <li>
                        <p>Controlling real time devices or processes (for example, issuing a sequence of instructions to a printer or graphics device)</p>
                     </li>
                     <li>
                        <p>Data manipulations that need extended procedural capabilities (for example, recursive sorting)</p>
                     </li>
                     <li>
                        <p>Special file I/O operations</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE914"></a><div class="props_rev_3"><a id="GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5" name="GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5"></a><h3 id="ZZPRE-GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5" class="sect3"><span class="enumeration_section">11.3 </span>Developing a User Exit
               </h3>
               <div>
                  <div class="section">
                     <p>This section outlines the way to develop a SQL*Forms user exit; later sections go into more detail. For information about EXEC TOOLS statements, which are available with Oracle Forms, see <a href="writing-user-exits.html#GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178">EXEC TOOLS Statements</a>'' 
                     </p>
                     <p>To incorporate a user exit into a form, you take the following steps:</p>
                     <p>1. Write the user exit in a supported host language.</p>
                     <p>2. Precompile the source code.</p>
                     <p>3. Compile the modified source code.</p>
                     <p>4. Use the GENXTB utility to create a database table, IAPXTB.</p>
                     <p>5. Use the GENXTB form in SQL*Forms to insert your user exit information into the database table.</p>
                     <p>6. Use the GENXTB utility to read the information from the table and create an IAPXIT source module. Then, compile the source module.</p>
                     <p>7. Create a new IAP (the SQL*Forms component that runs a form) by linking the standard IAP object modules, your user exit object module, and the IAPXIT object module created in step 6.</p>
                     <p>8. In the form, define a trigger to call the user exit.</p>
                     <p>9. Instruct operators to use the new IAP when running the form. This is unnecessary if the new IAP replaces the standard one. For details, refer to your system-specific Oracle manuals.</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE915"></a><div class="props_rev_3"><a id="GUID-CC5745DB-7907-449A-B9B7-412EE286231C" name="GUID-CC5745DB-7907-449A-B9B7-412EE286231C"></a><h3 id="ZZPRE-GUID-CC5745DB-7907-449A-B9B7-412EE286231C" class="sect3"><span class="enumeration_section">11.4 </span>Writing a User Exit
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e282" class="indexterm-anchor"></a>You can use the following kinds of statements to write your SQL*Forms user exit:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>host-language</p>
                        </li>
                        <li>
                           <p>EXEC SQL</p>
                        </li>
                        <li>
                           <p>EXEC ORACLE</p>
                        </li>
                        <li>
                           <p>EXEC IAF GET</p>
                        </li>
                        <li>
                           <p>EXEC IAF PUT</p>
                        </li>
                     </ul>
                     <p>This section focuses on the EXEC IAF <code class="codeph">GET</code> and <code class="codeph">PUT</code> statements, which let you pass values between SQL*Forms and a user exit.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE916"></a><div class="props_rev_3"><a id="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C" name="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C"></a><h4 id="ZZPRE-GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C" class="sect4"><span class="enumeration_section">11.4.1 </span>Requirements for Variables
                  </h4>
                  <div>
                     <p><a id="d73980e339" class="indexterm-anchor"></a>The variables used in EXEC IAF statements must correspond to field names used in the form definition. If a field reference is ambiguous because you did not specify a block name, you get an error. An invalid or ambiguous reference to a form field generates an error.
                     </p>
                     <p>Host variables must be named in the user exit Declare Section and must be prefixed with a colon (:) in EXEC IAF statements.</p>
                     <div class="infoboxnote" id="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C__GUID-D120B469-EAA8-4D64-8E1D-ED5026DF1334">
                        <p class="notep1">Note:</p>
                        <p>: Indicator variables are <span class="italic">not</span> allowed in EXEC IAF <code class="codeph">GET</code> and <code class="codeph">PUT</code> statements.
                        </p>
                     </div>
                  </div>
               </div><a id="ZZPRE917"></a><div class="props_rev_3"><a id="GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5" name="GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5"></a><h4 id="ZZPRE-GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5" class="sect4"><span class="enumeration_section">11.4.2 </span>The IAF GET Statement
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e386" class="indexterm-anchor"></a>This statement allows your user exit to "get" values from fields on a form and assign them to host variables. The user exit can then use the values in calculations, data manipulations, updates, and so on. The syntax of the <code class="codeph">GET</code> statement follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC IAF GET field_name1, field_name2, ...
 INTO :host_variable1, :host_variable2, ...;
</pre><p>where <span class="italic">field_name</span> can be any of the following SQL*Forms variables:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>field</p>
                           </li>
                           <li>
                              <p>block.field</p>
                           </li>
                           <li>
                              <p>system variable</p>
                           </li>
                           <li>
                              <p>global variable</p>
                           </li>
                           <li>
                              <p>host variable (prefixed with a colon) containing the value of a field, block.field, system variable, or global variable</p>
                           </li>
                        </ul>
                        <p>If <span class="italic">field_name</span> is not qualified, it must be unique.
                        </p>
                        <p><a id="d73980e423" class="indexterm-anchor"></a>The following example shows how a user exit GETs a field value and assigns it to a host variable:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC IAF GET employee.job INTO :new_job;
</pre><p>All field values are character strings. If it can, <code class="codeph">GET</code> converts a field value to the datatype of the corresponding host variable. If an illegal or unsupported datatype conversion is attempted, an error is generated.
                        </p>
                        <p><a id="d73980e436" class="indexterm-anchor"></a>In the last example, a constant is used to specify <span class="italic">block.field</span>. You can also use a host string to specify block and field names, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">set blkfld = 'employee.job';
EXEC IAF GET :blkfld INTO :new_job;
</pre><p>Unless the field is unique, the host string must contain the full <span class="italic">block.field</span> reference with intervening period. For example, the following usage is <span class="italic">invalid</span>:
                        </p><pre class="oac_no_warn" dir="ltr">set blk = 'employee';
set fld = 'job';
EXEC IAF GET :blk.:fld INTO :new_job;
</pre><p>You can mix explicit and stored field names in a <code class="codeph">GET</code> statement field list, but not in a single field reference. For example, the following usage is <span class="italic">invalid</span>:
                        </p><pre class="oac_no_warn" dir="ltr">set fld = 'job';
EXEC IAF GET employee.:fld INTO :new_job;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE918"></a><div class="props_rev_3"><a id="GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA" name="GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA"></a><h4 id="ZZPRE-GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA" class="sect4"><span class="enumeration_section">11.4.3 </span>The IAF PUT Statement
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e490" class="indexterm-anchor"></a>This statement allows your user exit to put the values of constants and host variables into fields on a form. Thus, the user exit can display on the SQL*Forms screen any value or message you like. The syntax of the <code class="codeph">PUT</code> statement follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC IAF PUT field_name1, field_name2, ...
 VALUES (:host_variable1, :host_variable2, ...);
</pre><p>where <span class="italic">field_name</span> can be any of the following SQL*Forms variables:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>field</p>
                           </li>
                           <li>
                              <p>block.field</p>
                           </li>
                           <li>
                              <p>system variable</p>
                           </li>
                           <li>
                              <p>global variable</p>
                           </li>
                           <li>
                              <p>host variable (prefixed with a colon) containing the value of a field, block.field, system variable, or global variable</p>
                           </li>
                        </ul>
                        <p><a id="d73980e522" class="indexterm-anchor"></a>The following example shows how a user exit PUTs the values of a numeric constant, string constant, and host variable into fields on a form:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC IAF PUT employee.number, employee.name, employee.job
 VALUES (7934, 'MILLER', :new_job);
</pre><p><a id="d73980e530" class="indexterm-anchor"></a>Like <code class="codeph">GET</code>, <code class="codeph">PUT</code> lets you use a host string to specify block and field names, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">set blkfld = 'employee.job';
EXEC IAF PUT :blkfld VALUES (:new_job);
</pre><p>On character-mode terminals, a value <code class="codeph">PUT</code> into a field is displayed when the user exit returns, rather than when the assignment is made, provided the field is on the current display page. On block-mode terminals, the value is displayed the next time a field is read from the device.
                        </p>
                        <p>If a user exit changes the value of a field several times, only the last change takes effect.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE919"></a><div class="props_rev_3"><a id="GUID-A952614C-B862-4B3C-A466-BC6B002A0899" name="GUID-A952614C-B862-4B3C-A466-BC6B002A0899"></a><h3 id="ZZPRE-GUID-A952614C-B862-4B3C-A466-BC6B002A0899" class="sect3"><span class="enumeration_section">11.5 </span>Calling a User Exit
               </h3>
               <div>
                  <div class="section">
                     <p>You call a user exit from a SQL*Forms trigger using a packaged procedure named <code class="codeph">USER_EXIT</code> (supplied with SQL*Forms). The syntax you use is
                     </p><pre class="oac_no_warn" dir="ltr">USER_EXIT(user_exit_string [, error_string]);
</pre><p>where <span class="italic">user_exit_string</span> contains the name of the user exit plus optional parameters and <span class="italic">error_string</span> contains an error message issued by SQL*Forms if the user exit fails. For example, the following trigger command calls a user exit named <code class="codeph">LOOKUP</code>: 
                     </p><pre class="oac_no_warn" dir="ltr">USER_EXIT('LOOKUP');
</pre><p>Notice that the user exit string is enclosed by single (not double) quotes.</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE920"></a><div class="props_rev_3"><a id="GUID-FFE01920-2950-4847-BE2E-0CD2B184A028" name="GUID-FFE01920-2950-4847-BE2E-0CD2B184A028"></a><h3 id="ZZPRE-GUID-FFE01920-2950-4847-BE2E-0CD2B184A028" class="sect3"><span class="enumeration_section">11.6 </span>Passing Parameters to a User Exit
               </h3>
               <div>
                  <div class="section">
                     <p>When you call a user exit, SQL*Forms passes it the following parameters automatically: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Command Line is the user exit string.</p>
                        </li>
                        <li>
                           <p>Command Line Length is the length (in characters) of the user exit string.</p>
                        </li>
                        <li>
                           <p>Error Message is the error string (failure message) if one is defined.</p>
                        </li>
                        <li>
                           <p>Error Message Length is the length of the error string.</p>
                        </li>
                        <li>
                           <p>In-Query is a Boolean value indicating whether the exit was called in normal or query mode.</p>
                        </li>
                     </ul>
                     <p>However, the user exit string enables pass additional parameters to the user exit. For example, the following trigger command passes two parameters and an error message to the user exit <code class="codeph">LOOKUP</code>:
                     </p><pre class="oac_no_warn" dir="ltr">USER_EXIT('LOOKUP 2025 A', 'Lookup failed');
</pre><p>You can use this feature to pass field names to the user exit, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">USER_EXIT('CONCAT firstname, lastname, address');
</pre><p>However, it is up to the user exit, not SQL*Forms, to parse the user exit string.</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE921"></a><div class="props_rev_3"><a id="GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D" name="GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D"></a><h3 id="ZZPRE-GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D" class="sect3"><span class="enumeration_section">11.7 </span>Returning Values to a Form
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e686" class="indexterm-anchor"></a>When a user exit returns control to SQL*Forms, it must also return a code indicating whether it succeeded, failed, or suffered an  irrecoverable error. The return code is an integer <a id="d73980e691" class="indexterm-anchor"></a>constant generated by precompiler (refer to this section: <a href="writing-user-exits.html#GUID-16350EA4-0AF0-4800-8852-A44BF707247E">An Example</a>). The three results have the following meanings: 
                     </p>
                     <p>Success: The user exit encountered no errors. SQL*Forms proceeds to the <span class="italic">success</span> label or the next step, unless the <a id="d73980e703" class="indexterm-anchor"></a>Reverse Return Code switch is set by the calling trigger step.
                     </p>
                     <p>Failure: The user exit detected an error, such as an invalid value in a field. An optional message passed by the exit appears on the message line at the bottom of the <a id="d73980e710" class="indexterm-anchor"></a>SQL*Forms screen and on the Display Error screen. SQL*Forms responds as it does to a SQL statement that affects no rows.
                     </p>
                     <p>Fatal error: The user exit detected a condition that makes further processing impossible, such as an execution error in a SQL statement. An optional error message passed by the exit appears on the SQL*Forms Display Error screen. SQL*Forms responds as it does to an irrecoverable SQL error.</p>
                     <p>If a user exit changes the value of a field, then returns a <span class="italic">failure</span> or <span class="italic">fatal error</span> code, SQL*Forms does <span class="italic">not</span> discard the change. Nor does SQL*Forms discard changes when the Reverse Return Code switch is set and a <span class="italic">success</span> code is returned.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE922"></a><div class="props_rev_3"><a id="GUID-F68AC490-6AE3-43FD-977B-865FC3B93169" name="GUID-F68AC490-6AE3-43FD-977B-865FC3B93169"></a><h4 id="ZZPRE-GUID-F68AC490-6AE3-43FD-977B-865FC3B93169" class="sect4"><span class="enumeration_section">11.7.1 </span>The IAP Constants
                  </h4>
                  <div>
                     <p>The precompiler generates three symbolic constants for use as return codes. They are prefixed with IAP. For example, the three constants might be IAPSUCC, IAPFAIL, and IAPFTL.</p>
                  </div>
               </div><a id="ZZPRE923"></a><div class="props_rev_3"><a id="GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E" name="GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E"></a><h4 id="ZZPRE-GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E" class="sect4"><span class="enumeration_section">11.7.2 </span>Using the SQLIEM Function
                  </h4>
                  <div>
                     <div class="section">
                        <p>By calling the function SQLIEM, your user exit can specify an error message that SQL*Forms will display on the message line if the trigger step fails or on the Display Error screen if the step causes an irrecoverable error. The specified message replaces any message defined for the step.</p>
                        <p>The syntax of the SQLIEM function call is</p><pre class="oac_no_warn" dir="ltr">SQLIEM (error_message, message_length);
</pre><p>where <span class="italic">error_message</span> and <span class="italic">message_length</span> are character and integer variables, respectively. The Oracle Precompilers generate the appropriate external function declaration for you. You pass both parameters by reference; that is, you pass their addresses, not their values. SQLIEM is a SQL*Forms function; it cannot be called from other Oracle tools.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE924"></a><div class="props_rev_3"><a id="GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3" name="GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3"></a><h4 id="ZZPRE-GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3" class="sect4"><span class="enumeration_section">11.7.3 </span>Using WHENEVER
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use the <code class="codeph">WHENEVER</code> statement in an exit to detect invalid datatype conversions (SQLERROR), truncated values <code class="codeph">PUT</code> into form fields (SQLWARNING), and queries that return no rows (<code class="codeph">NOT</code> <code class="codeph">FOUND</code>).
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE925"></a><div class="props_rev_3"><a id="GUID-16350EA4-0AF0-4800-8852-A44BF707247E" name="GUID-16350EA4-0AF0-4800-8852-A44BF707247E"></a><h3 id="ZZPRE-GUID-16350EA4-0AF0-4800-8852-A44BF707247E" class="sect3"><span class="enumeration_section">11.8 </span>An Example
               </h3>
               <div>
                  <p>The following example shows how a typical user exit is coded. Notice that, like a host program, the user exit has a Declare Section and a SQLCA.</p><pre class="oac_no_warn" dir="ltr">-- subroutine MYEXIT
EXEC SQL BEGIN DECLARE SECTION;
 field1 CHARACTER(20);
 field2 CHARACTER(20);
 value1 CHARACTER(20);
 value2 CHARACTER(20);
 result_val CHARACTER(20);
EXEC SQL END DECLARE SECTION;
 errmsg CHARACTER(80);
 errlen INTEGER;
EXEC SQL INCLUDE SQLCA;
EXEC SQL WHENEVER SQLERROR GOTO sqlerror;
-- get field values from form
EXEC IAF GET :field1, :field2 INTO :value1, :value2;
-- manipulate values to obtain result_val
-- put result_val into form field
EXEC IAF PUT result VALUES (:result_val);
return(IAPSUCC); -- trigger step succeeded
sqlerror:
 set errmsg = CONCAT('MYEXIT: ', sqlca.sqlerrm.sqlerrmc);
 set errlen = LENGTH(errmsg);
 sqliem(errmsg, errlen); -- pass error message to SQL*Forms
 return(IAPFAIL); -- trigger step failed
</pre><p>For a complete host-language example, see your host -language supplement.</p>
               </div>
            </div><a id="ZZPRE926"></a><div class="props_rev_3"><a id="GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9" name="GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9"></a><h3 id="ZZPRE-GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9" class="sect3"><span class="enumeration_section">11.9 </span>About Precompiling and Compiling a User Exit
               </h3>
               <div>
                  <p>User exits are precompiled like standalone host programs. Refer to <a href="running-Oracle-precompilers.html#GUID-203DF8C5-3073-4914-8B92-9F81AF09CB92"> Running the Oracle Precompilers</a></p>
                  <p>For instructions on compiling a user exit, see your system-specific Oracle manuals.</p>
               </div>
            </div><a id="ZZPRE927"></a><div class="props_rev_3"><a id="GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55" name="GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55"></a><h3 id="ZZPRE-GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55" class="sect3"><span class="enumeration_section">11.10 </span>About Using the GENXTB Utility
               </h3>
               <div>
                  <p><a id="d73980e929" class="indexterm-anchor"></a>The IAP program table IAPXTB in module IAPXIT contains an entry for each user exit linked into IAP. IAPXTB tells IAP the name, location, and host language of each user exit. When you add a new user exit to IAP, you must add a corresponding entry to IAPXTB.
                  </p>
                  <p>IAPXTB is derived from a database table, also named IAPXTB. You can modify the database table by running the GENXTB form on the operating system command line, as follows: </p><pre class="oac_no_warn" dir="ltr">RUNFORM GENXTB username/password
</pre><p>A form is displayed that enables you to enter the following information for each user exit you define:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>exit name</p>
                     </li>
                     <li>
                        <p>host-language code (<code class="codeph">COB</code>, <code class="codeph">FOR</code>, <code class="codeph">PAS</code>, or <code class="codeph">PLI</code>)
                        </p>
                     </li>
                     <li>
                        <p>date created</p>
                     </li>
                     <li>
                        <p>date last modified</p>
                     </li>
                     <li>
                        <p>comments</p>
                     </li>
                  </ul>
                  <p>After modifying the IAPXTB database table, use the GENXTB utility to read the table and create an Assembler or C source program that defines the module IAPXIT and the IAPXTB program table it contains. The source language used depends on your operating system. The syntax you use to run the GENXTB utility is</p><pre class="oac_no_warn" dir="ltr">GENXTB username/password outfile
</pre><p>where <span class="italic">outfile</span> is the name you give the Assembler or source program that GENXTB creates.
                  </p>
               </div>
            </div><a id="ZZPRE928"></a><div class="props_rev_3"><a id="GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C" name="GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C"></a><h3 id="ZZPRE-GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C" class="sect3"><span class="enumeration_section">11.11 </span>About Linking a User Exit into SQL*Forms
               </h3>
               <div>
                  <p>Before running a form that calls a user exit, you must link the user exit into IAP. The user exit can be linked into your standard version of IAP or into a special version for those forms that call the exit. </p>
                  <p>To produce a new executable copy of <a id="d73980e1005" class="indexterm-anchor"></a>IAP, link your user exit object module, the standard IAP modules, the IAPXIT module, and any modules needed from the Oracle and host-language link libraries. The details of linking are system-dependent, so check your system-specific Oracle manuals.
                  </p>
               </div>
            </div><a id="ZZPRE929"></a><div class="props_rev_3"><a id="GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E" name="GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E"></a><h3 id="ZZPRE-GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E" class="sect3"><span class="enumeration_section">11.12 </span>Guidelines for SQL*Forms User Exits
               </h3>
               <div>
                  <p><a id="d73980e1036" class="indexterm-anchor"></a>The guidelines in this section will help you avoid some common pitfalls. 
                  </p>
               </div><a id="ZZPRE930"></a><div class="props_rev_3"><a id="GUID-96F68A68-8094-4E66-9299-745EEA516478" name="GUID-96F68A68-8094-4E66-9299-745EEA516478"></a><h4 id="ZZPRE-GUID-96F68A68-8094-4E66-9299-745EEA516478" class="sect4"><span class="enumeration_section">11.12.1 </span>Naming the Exit
                  </h4>
                  <div>
                     <p><a id="d73980e1068" class="indexterm-anchor"></a>The name of your user exit cannot be an Oracle reserved word. Also avoid using names that conflict with the names of SQL*Forms commands, function codes, and externally defined names used by SQL*Forms. 
                     </p>
                     <p>SQL*Forms converts the name of a user exit to upper case before searching for the exit. Therefore, the exit name must be in upper case in your source code if your host language is case-sensitive. </p>
                     <p>The name of the user exit entry point in the source code becomes the name of the user exit itself. The exit name must be a valid file name for your host language and operating system.</p>
                  </div>
               </div><a id="ZZPRE931"></a><div class="props_rev_3"><a id="GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028" name="GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028"></a><h4 id="ZZPRE-GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028" class="sect4"><span class="enumeration_section">11.12.2 </span>Connecting to Oracle
                  </h4>
                  <div>
                     <p>User exits communicate with Oracle through the connection made by SQL*Forms. However, a user exit can establish additional connections to any database through SQL*Net. For more information, refer to <a href="meeting-program-requirements.html#GUID-288DC379-A0FE-404F-971A-4919D35325DD">Concurrent Logons</a>".
                     </p>
                  </div>
               </div><a id="ZZPRE932"></a><div class="props_rev_3"><a id="GUID-BA84171D-01BF-4B54-8732-B704AF20D57C" name="GUID-BA84171D-01BF-4B54-8732-B704AF20D57C"></a><h4 id="ZZPRE-GUID-BA84171D-01BF-4B54-8732-B704AF20D57C" class="sect4"><span class="enumeration_section">11.12.3 </span>Issuing I/O Calls
                  </h4>
                  <div>
                     <p>SQL*Forms I/O routines might conflict with host-language printer I/O routines. If they do, your user exit will be unable to issue printer I/O calls. File I/O is supported but screen I/O is not.</p>
                  </div>
               </div><a id="ZZPRE933"></a><div class="props_rev_3"><a id="GUID-E0E1427C-A353-43AB-B376-A1034572C396" name="GUID-E0E1427C-A353-43AB-B376-A1034572C396"></a><h4 id="ZZPRE-GUID-E0E1427C-A353-43AB-B376-A1034572C396" class="sect4"><span class="enumeration_section">11.12.4 </span>Using Host Variables
                  </h4>
                  <div>
                     <p>Restrictions on the use of host variables in a standalone program also apply to user exits. Host variables must be named in the user exit Declare Section and must be prefixed with a colon in EXEC SQL and EXEC IAF statements. However, the use of host arrays is not allowed in EXEC IAF statements.</p>
                  </div>
               </div><a id="ZZPRE934"></a><div class="props_rev_3"><a id="GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241" name="GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241"></a><h4 id="ZZPRE-GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241" class="sect4"><span class="enumeration_section">11.12.5 </span>Updating Tables
                  </h4>
                  <div>
                     <p>Generally, a user exit should not <code class="codeph">UPDATE</code> database tables associated with a form. For example, suppose an operator updates a record in the SQL*Forms work space, then a user exit <code class="codeph">UPDATEs</code> the corresponding row in the associated database table. When the transaction is <code class="codeph">COMMITted</code>, the record in the SQL*Forms work space is applied to the table, overwriting the user exit <code class="codeph">UPDATE</code>.
                     </p>
                  </div>
               </div><a id="ZZPRE935"></a><div class="props_rev_3"><a id="GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776" name="GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776"></a><h4 id="ZZPRE-GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776" class="sect4"><span class="enumeration_section">11.12.6 </span>Issuing Commands
                  </h4>
                  <div>
                     <p>Avoid issuing a <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> command from your user exit because Oracle will commit or roll back work begun by the SQL*Forms operator, not just work done by the user exit. Instead, issue the <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> from the SQL*Forms trigger. This also applies to data definition commands (such as <code class="codeph">ALTER</code> <code class="codeph">and CREATE</code>) because they issue an implicit <code class="codeph">COMMIT</code> before and after executing.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE936"></a><div class="props_rev_3"><a id="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178" name="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178"></a><h3 id="ZZPRE-GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178" class="sect3"><span class="enumeration_section">11.13 </span>EXEC TOOLS Statements
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e1257" class="indexterm-anchor"></a>EXEC <code class="codeph">TOOLS</code> statements support the basic <a id="d73980e1265" class="indexterm-anchor"></a>Oracle Toolset (<a id="d73980e1268" class="indexterm-anchor"></a>Oracle Forms, Oracle Reports, and Oracle Graphics) by providing a generic way to handle get, set, and exception callbacks from user exits. The following discussion focuses on Oracle Forms but the same concepts apply to Oracle Reports and Oracle Graphics.
                     </p>
                     <p>Besides EXEC SQL, EXEC ORACLE, and host language statements, you can use the following EXEC TOOLS statements to write an Oracle Forms user exit:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">SET</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">GET</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SET CONTEXT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">GET CONTEXT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">MESSAGE</code></p>
                        </li>
                     </ul>
                     <p>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> and <code class="codeph">SET</code> statements replace the EXEC IAF <code class="codeph">GET</code> and <code class="codeph">PUT</code> statements used with SQL*Forms. Unlike IAF GET and <code class="codeph">PUT</code>, <code class="codeph">TOOLS</code> <code class="codeph">GET</code> and <code class="codeph">SET</code> <a id="d73980e1324" class="indexterm-anchor"></a>accept indicator variables. The EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code> statement replaces the message-handling function SQLIEM. The EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> <code class="codeph">CONTEXT</code> and <code class="codeph">GET</code> <code class="codeph">CONTEXT</code> statements are new and not available with SQL*Forms, Version 3.
                     </p>
                     <div class="infoboxnote" id="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178__GUID-BBADC839-B133-478D-9F3A-C106D3FE48DC">
                        <p class="notep1">Note:</p>
                        <p>COBOL and FORTRAN do not have a pointer datatype, so you cannot use the <code class="codeph">SET</code> <code class="codeph">CONTEXT</code> and <code class="codeph">GET</code> <code class="codeph">CONTEXT</code> statements in a Pro*COBOL or Pro*FORTRAN program.
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE937"></a><div class="props_rev_3"><a id="GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB" name="GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB"></a><h4 id="ZZPRE-GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB" class="sect4"><span class="enumeration_section">11.13.1 </span>EXEC TOOLS SET
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e1394" class="indexterm-anchor"></a>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> statement passes values from your user exit to Oracle Forms. Specifically, it assigns the values of host variables and constants to Oracle Forms variables and items. The values are displayed after the user exit returns control to the form.
                        </p>
                        <p>To code the EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> statement, you use the syntax
                        </p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS SET form_variable[, ...]
 VALUES ({:host_variable[:indicator] | constant}[, ...]);
</pre><p>where <span class="italic">form_variable</span> is an Oracle Forms field, parameter, system variable, or global variable, or a host variable (prefixed with a colon) containing the name of one of the foregoing items.
                        </p>
                        <p>In the following Pro*C example, your user exit passes an employee name (with optional indicator) to Oracle Forms:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 char ename[20];
 short ename_ind;
EXEC SQL END DECLARE SECTION;
...
strcpy(ename, "MILLER");
ename_ind = 0;
EXEC TOOLS SET emp.ename VALUES (:ename:ename_ind);
</pre><p>In this example, <span class="italic">emp.ename</span> is an Oracle Forms block.field.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE938"></a><div class="props_rev_3"><a id="GUID-65EFD031-F206-49D0-B70C-581B899C801A" name="GUID-65EFD031-F206-49D0-B70C-581B899C801A"></a><h4 id="ZZPRE-GUID-65EFD031-F206-49D0-B70C-581B899C801A" class="sect4"><span class="enumeration_section">11.13.2 </span>EXEC TOOLS GET
                  </h4>
                  <div>
                     <div class="section">
                        <p>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> statement passes values from Oracle Forms to your user exit. Specifically, it assigns the values of Oracle Forms variables and items to host variables. As soon as the values are passed, the user exit can use them for any purpose. 
                        </p>
                        <p>To code the EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> statement, you use the syntax
                        </p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS GET form_variable[, ...]
 INTO :host_variable[:indicator][, ...];
</pre><p>where <span class="italic">form_variable</span> is an Oracle Forms field, parameter, system variable, or global variable, or a host variable containing the name of one of the foregoing items.
                        </p>
                        <p>In the following example, Oracle Forms passes an employee name from the block.field <span class="italic">emp.ename</span> to your user exit:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 char ename[20];
EXEC SQL END DECLARE SECTION;
...
EXEC TOOLS GET emp.ename INTO :ename;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE939"></a><div class="props_rev_3"><a id="GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB" name="GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB"></a><h4 id="ZZPRE-GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB" class="sect4"><span class="enumeration_section">11.13.3 </span>EXEC TOOLS SET CONTEXT
                  </h4>
                  <div>
                     <div class="section">
                        <p>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">SE</code>T <code class="codeph">CONTEXT</code> statement lets you save context information from one user exit call to another. <code class="codeph">SET</code> <code class="codeph">CONTEXT</code> names a host-language pointer variable that you can reference later in an EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code> statement. The pointer variable points to the block of memory in which the context information is stored. With the <code class="codeph">SET</code> <code class="codeph">CONTEXT</code> statement, you need not declare a global variable to hold the information.
                        </p>
                        <p>To code the EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> <code class="codeph">CONTEXT</code> statement, use the syntax
                        </p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS SET CONTEXT :host_pointer_variable
 [IDENTIFIED] BY context_name;
</pre><p>where the optional keyword IDENTIFIED can be used to improve readability and <span class="italic">context_name</span> is an undeclared identifier or a character host variable that names the context area.
                        </p>
                        <p>In the following example, your user exit saves context information for later use:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 char context1[30];
EXEC SQL END DECLARE SECTION;
...
strcpy(context1, "This is context1");
EXEC TOOLS SET CONTEXT :context1 BY my_app1;
</pre><p>In this example, the context name <span class="italic">my_app1</span> is an undeclared identifier. Note that in C, when a char array is used as an argument, the array name is synonymous with a pointer to that array.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE940"></a><div class="props_rev_3"><a id="GUID-D12653C0-F09A-48A6-AE47-128850AACD85" name="GUID-D12653C0-F09A-48A6-AE47-128850AACD85"></a><h4 id="ZZPRE-GUID-D12653C0-F09A-48A6-AE47-128850AACD85" class="sect4"><span class="enumeration_section">11.13.4 </span>EXEC TOOLS GET CONTEXT
                  </h4>
                  <div>
                     <div class="section">
                        <p>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code> statement retrieves the value of a host-language pointer variable into your user exit. The pointer variable points to a block of memory in which context information is stored. 
                        </p>
                        <p>To code the EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code> statement, use the syntax
                        </p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS GET CONTEXT context_name INTO :host_pointer_variable;
</pre><p>where <span class="italic">context_name</span> is an undeclared identifier or a character host variable that names the context area.
                        </p>
                        <p>In the following Pro*C example, your user exit retrieves a pointer to context information saved earlier:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 char *ctx_ptr;
EXEC SQL END DECLARE SECTION;
...
EXEC TOOLS GET CONTEXT my_app1 INTO :ctx_ptr;
</pre><p>In this example, the context name <span class="italic">my_app1</span> is an undeclared identifier.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE941"></a><div class="props_rev_3"><a id="GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3" name="GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3"></a><h4 id="ZZPRE-GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3" class="sect4"><span class="enumeration_section">11.13.5 </span>EXEC TOOLS MESSAGE
                  </h4>
                  <div>
                     <div class="section">
                        <p>The EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code> statement passes a message from your user exit to Oracle Forms. The message is displayed on the Oracle Forms message line after the user exit returns control to the form. 
                        </p>
                        <p>To code the EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code> statement, you use the syntax
                        </p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS MESSAGE message_text [severity_code];
</pre><p>where <span class="italic">message_text</span> is a quoted string or a character host variable, and the optional <span class="italic">severity_code</span> is an integer constant or host variable. The <code class="codeph">MESSAGE</code> statement does <span class="italic">not</span> accept indicator variables.
                        </p>
                        <p>In the following Pro*C example, your user exit passes an error message and severity code to Oracle Forms:</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS MESSAGE 'Bad field name! Please reenter.' 15;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>