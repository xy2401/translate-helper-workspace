<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Performance and Debugging</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQLJ Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQLJ Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96458-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="translator-run-time-functionality.html" title="Previous" type="text/html">
      <link rel="next" href="appendix.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JSQLJ">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="translator-run-time-functionality.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="appendix.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Performance and Debugging</li>
            </ol>
            <a id="GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375" name="GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375"></a><a id="JSQLJ740"></a>
            
            <h2 id="JSQLJ-GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375" class="sect2"><span class="enumeration_chapter">11 </span> Performance and Debugging
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses features, utilities, and tips to enhance performance of your SQLJ application and to debug your SQLJ source code at run time. The following topics are discussed:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C">Performance Enhancement Features</a></p>
                  </li>
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-630E713D-C1AA-4ED8-8061-153B6880EB61">SQLJ Debugging Features</a></p>
                  </li>
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585">SQLJ Support for Oracle Performance Monitoring</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ741"></a><div class="props_rev_3"><a id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C" name="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C"></a><h3 id="JSQLJ-GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C" class="sect3">Performance Enhancement Features</h3>
               <div>
                  <p>The Oracle SQLJ implementation includes features to enhance performance by making data access more efficient. These include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-BB73F408-2751-4050-A174-F9B2AD525AD7">Row Prefetching</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A">Statement Caching</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803">Update Batching</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50">Column Definitions</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D">Parameter Size Definitions</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-39C2B05E-C724-4617-903D-AFEFC3726565">
                     <p class="notep1">See Also:</p>
                     <p><a href="../jjdbc/data-access-and-manipulation.html#JJDBC-GUID-C4FB8486-E19B-4EF3-BC67-053EF49E6FF4" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                  </div>
                  <p>Your application will likely benefit from the default Oracle-specific code generation. The generated code will be optimized with direct calls to Oracle Java Database Connectivity (JDBC) driver, eliminating the overhead of intermediate calls to the SQLJ run time, which in turn would call JDBC.</p>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-20E7B340-7A2E-43A6-BD2A-56544588B676">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="key-programming-considerations.html#GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD">Oracle-Specific Code Generation (No Profiles)</a>"</span></p>
                  </div>
                  <div class="infoboxnote" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-62CCE6F3-8B47-49F1-8C4E-56872FAA16D3">
                     <p class="notep1">Note:</p>
                     <p>The Oracle SQLJ implementation does <span class="italic">not</span> support batch fetches, which is the fetching of sets of rows into arrays of values. However, you may be able to use Oracle row prefetching to obtain some of the benefits of batch fetching.
                     </p>
                  </div>
                  <p>In addition to the preceding SQLJ performance enhancements, you can use optimizer hints in the SQL operations within a SQLJ program, as you can in any Oracle SQL operations.</p>
                  <p>The Ora<a id="d66179e124" class="indexterm-anchor"></a><a id="d66179e126" class="indexterm-anchor"></a><a id="d66179e128" class="indexterm-anchor"></a><a id="d66179e130" class="indexterm-anchor"></a><a id="d66179e132" class="indexterm-anchor"></a><a id="d66179e134" class="indexterm-anchor"></a>cle SQL implementation enables you to tune your SQL statements by using "<code class="codeph">/*+</code>" or "<code class="codeph">--+</code>" comment notation to pass hints to Oracle SQL optimizer. The SQLJ translator recognizes and supports these optimizer hints, passing them at run time as part of your SQL statement.
                  </p>
                  <p>You can also define cost and selectivity information for a SQLJ stored function, as for any other stored function, using the extensibility features for SQL optimization in Oracle Database 12<span class="italic">c </span>Release 2 (12.2). During SQL execution, the optimizer invokes the cost and selectivity methods for the stored function, evaluates alternate strategies for execution, and chooses an efficient execution plan.
                  </p>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-3D110D49-2610-47DD-A416-C83821564928">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF-GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information
                     </p>
                  </div>
                  <p>Note that using Oracle performance extensions in your code requires the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Use one of Oracle JDBC drivers.</p>
                     </li>
                     <li>
                        <p>Use the default Oracle-specific code generation, or customize profiles appropriately.</p>
                        <p>For ISO standard code generation, the default customizer, <code class="codeph">oracle.sqlj.runtime.util.OraCustomizer</code>, is recommended.
                        </p>
                     </li>
                     <li>
                        <p>Use Oracle SQLJ run time when your application runs.</p>
                     </li>
                  </ul>
                  <p> Oracle SQLJ run time and an Oracle JDBC driver are required by your application whenever you customize profiles with Oracle customizer, even if you do not actually use Oracle extensions in your code.</p>
               </div><a id="JSQLJ742"></a><div class="props_rev_3"><a id="GUID-BB73F408-2751-4050-A174-F9B2AD525AD7" name="GUID-BB73F408-2751-4050-A174-F9B2AD525AD7"></a><h4 id="JSQLJ-GUID-BB73F408-2751-4050-A174-F9B2AD525AD7" class="sect4">Row Prefetching</h4>
                  <div>
                     <p>Standard JDBC receives the results of a query one row at a time, with each row requiring a separate round trip to the database. Row prefetching enables you to receive the results more efficiently, in groups of multiple rows each.</p>
                     <p>Use the <code class="codeph">setFetchSize()</code> method of an <code class="codeph">ExecutionContext</code> instance to set the number of rows to be prefetched whenever you execute a <code class="codeph">SELECT</code> statement (for SQLJ statements using the particular <code class="codeph">ExecutionContext</code> instance).
                     </p>
                     <p>The <code class="codeph">getFetchSize()</code> method of an <code class="codeph">ExecutionContext</code> instance returns the current prefetch size, as an <code class="codeph">int</code> value.
                     </p>
                     <p>The following is an example of setting the prefetch size to 20 by getting the default execution context instance of the default connection context instance and calling the <code class="codeph">setFetchSize()</code> method:
                     </p><pre class="oac_no_warn" dir="ltr">DefaultContext.getDefaultContext().getExecutionContext().setFetchSize(20);
</pre><p>It is also possible to set the prefetch size directly on the underlying <code class="codeph">OracleConnection</code> object using the JDBC application programming interface (API), but in SQLJ this is discouraged.
                     </p>
                     <p>To specify the number of rows to prefetch for queries that use a given connection context instance, use the underlying JDBC connection, cast to an Oracle<code class="codeph">Connection</code> instance. Following is an example that sets the prefetch value to 20 for your default connection:
                     </p><pre class="oac_no_warn" dir="ltr">((OracleConnection)DefaultContext.getDefaultContext().getConnection()).setDefaultRowPrefetch(20);</pre><pre class="oac_no_warn" dir="ltr"></pre><p>Also, please note that the prefetch size set on the SQLJ connection context overrides the prefetch size set on the underlying JDBC connection.</p>
                     <p><span>Each additional connection context instance you use must be set separately, as desired.</span>The prefetch value needs to be setup on each individual connection context. For example, if <code class="codeph">ctx</code> is an instance of a declared connection context class, set its prefetch value as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">((Connection)ctx.getConnection()).setDefaultRowPrefetch(20);</pre><pre class="oac_no_warn" dir="ltr">ctx.getExecutionContext().setFetchSize(20);
</pre><p>There is no maximum row-prefetch value. The default is 10 in JDBC, and this is inherited by SQLJ. This value is effective in typical circumstances, although you might want to increase it if you receive a large number of rows.</p>
                  </div>
               </div><a id="JSQLJ744"></a><a id="JSQLJ745"></a><a id="JSQLJ746"></a><a id="JSQLJ747"></a><a id="JSQLJ748"></a><a id="JSQLJ749"></a><a id="JSQLJ750"></a><a id="JSQLJ743"></a><div class="props_rev_3"><a id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A" name="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A"></a><h4 id="JSQLJ-GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A" class="sect4">Statement Caching</h4>
                  <div>
                     <p>SQLJ offers a statement caching feature that improves performance by saving executable statements that are used repeatedly, such as in a loop or in a method that is called repeatedly. When a statement is cached before it is reexecuted, the code does not have to be reparsed (either on the server or on the client), the statement object does not have to be recreated, and the parameter size definitions do not have to be recalculated. Without this feature, repeated statements would have to be reparsed on the client, and perhaps in the server as well, depending on whether a statement is still available in the general server-side SQL cache when it is encountered again.</p>
                     <p>For Oracle-specific code generation, SQLJ statement caching relies on Oracle JDBC driver, using the JDBC explicit caching mechanism. This is distinct from the JDBC implicit caching mechanism, although there are interdependencies. With Oracle-specific code, statement caching is controlled through connection methods.</p>
                     <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-3EB4E6B4-DA9C-4350-8295-54BFDC464A39">
                        <p class="notep1">See Also:</p>
                        <p><a href="../jjdbc/statement-and-resultset-caching.html#JJDBC-GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                     </div>
                     <p>For ISO code generation, SQLJ has its own statement caching mechanism through functionality of the SQLJ run time. With ISO code, statement caching is controlled through the Oracle customizer <code class="codeph">stmtcache</code> option.
                     </p>
                     <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-81A8E895-AEC2-4D36-BF1E-90C31CB19B31">
                        <p class="notep1">Note:</p>
                        <p>For Oracle-specific code generation, explicit caching is the only statement caching mechanism that can be manipulated through SQLJ APIs. For the discussion in this document, it will be referred to as SQLJ/explicit statement caching.</p>
                     </div>
                     <p>In Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the default statement cache size is set to 5, provided the JDBC connection is being created by the connection context. If a connection context is created using an already available JDBC connection or data source, then the statement cache size will be set to that of the JDBC connection or the data source.
                     </p>
                     <div class="section" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__I1005665">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-D305621B-3E5E-4F5B-846B-4C93F934729E">Connection Context Methods for Statement Caching (Oracle-Specific Code)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you use Oracle-specific code generation, which is the case with the SQLJ translator default <code class="codeph">-codegen=oracle</code> setting, use connection context methods for statement caching functionality. Note that any statement cache size greater than 0 results in SQLJ/explicit statement caching being enabled. By default, it is enabled with a cache size of 5, that is, five statements.
                        </p>
                        <p>The following Oracle-specific (nonstandard) static methods have been added to the <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class, and are also included in any connection context classes you declare:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">static void setDefaultStmtCacheSize(int)</code></p>
                              <p>This sets the default statement cache size for <span class="italic">all</span> connection contexts. This becomes the initial statement cache size for any subsequently created instance of <span class="italic">any</span> connection context class, not just the class upon which you call the method. The method call does not affect connection context instances that already exist. 
                              </p>
                              <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-D02D50B6-5271-452A-8FA0-07E43C4E003E">
                                 <p class="notep1">Note:</p>
                                 <p><code class="codeph">setDefaultStmtCacheSize(int)</code> affects the statement cache size only for the connections that are created using the SQLJ connection contexts. It does not affect the statement cache size for the connections that are created using JDBC connections.
                                 </p>
                                 <p>Consider the following two code snippets:</p>
                                 <p>Example 1:</p><pre class="oac_no_warn" dir="ltr">...
MyContext.setDefaultStmtCacheSize(10); 
OracleConnection conn = DriverManager.getConnection(url, user, passwd); 
myctx = new MyContext(conn); 
</pre><p>Example 2:</p><pre class="oac_no_warn" dir="ltr">...
MyContext.setDefaultStmtCacheSize(10); 
myctx = new MyContext(url, user, passwd,true);

</pre><p>In the preceding two examples, the statement cache size will be set to 10 only in the second example. In the first example, the statement cache size corresponding to this connection will not be affected because the connection is created using the <code class="codeph">getConnection</code> method of the <code class="codeph">DriverManager</code> interface from JDBC specification.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p><code class="codeph">static int getDefaultStmtCacheSize()</code></p>
                              <p>This retrieves the current default statement cache size for connection contexts.</p>
                           </li>
                        </ul>
                        <p>And the following Oracle-specific instance methods have also been added to the <code class="codeph">DefaultContext</code> class and are included in any other connection context classes:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">void setStmtCacheSize(int) throws java.sql.SQLException</code></p>
                              <p>This sets the statement cache size for the underlying connection of the particular connection context instance (overrides the default).</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-F0F1BFCE-4D45-4727-8835-B970BDDC9CFB">
                           <p class="notep1">Note:</p>
                           <p>If SQLJ/explicit caching is already disabled, then setting the size to 0 leaves it disabled. If it is already enabled, then setting the size to 0 leaves it enabled, but renders it nonfunctional.</p>
                        </div>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">int getStmtCacheSize()</code></p>
                              <p>This verifies whether SQLJ/explicit statement caching is enabled for the underlying connection of the connection context. If so, it returns the current statement cache size. It can also return either of the following integer constants:</p><pre class="oac_no_warn" dir="ltr">static int STMT_CACHE_NOT_ENABLED
static int STMT_CACHE_EXCEPTION
</pre><p>It is possible for a <code class="codeph">getStmtCacheSize()</code> call to cause a SQL exception. However, for backward compatibility, this method does not throw the exception directly. When an exception occurs, the method returns the constant <code class="codeph">STMT_CACHE_EXCEPTION</code>. In this case, you can call the <code class="codeph">getStmtCacheException()</code> method to find out what exception occurred.
                              </p>
                              <p>If you call <code class="codeph">getStmtCacheSize()</code> when SQLJ/explicit caching is disabled, then the method returns the constant <code class="codeph">STMT_CACHE_NOT_ENABLED</code>. This is distinguished from a cache size of 0. Technically, it is possible for SQLJ/explicit caching to be enabled (though useless) with a cache size of 0.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql.Exception getStmtCacheException()</code></p>
                              <p>See if there is a statement caching exception. There are two scenarios for using this method:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Call it if a <code class="codeph">getStmtCacheSize()</code> call returns <code class="codeph">STMT_CACHE_EXCEPTION</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Call it whenever you create a connection context instance with which you want to use statement caching. This is because of automatic manipulation that occurs with respect to statement cache size whenever you create a connection context instance. If you care about statement caching for the connection context instance, call <code class="codeph">getStmtCacheException()</code> after creating the instance, to verify there were no problems.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__I1005700">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-626710D2-E6D5-40D8-9899-4212999D004D">Enabling and Disabling Statement Caching (Oracle-Specific Code)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With Oracle-specific code, to reiterate what was stated earlier, any nonzero statement cache size results in SQLJ/explicit caching being enabled. Because the default size is 5, statement caching is enabled by default.</p>
                        <p>You cannot explicitly disable SQLJ/explicit statement caching through SQLJ APIs, although you can effectively disable it (render it nonfunctional) by setting the statement cache size to 0. In this case, the connection context <code class="codeph">getStmtCacheSize()</code> method might return 0, <span class="italic">not</span> <code class="codeph">STMT_CACHE_NOT_ENABLED</code>.
                        </p>
                        <p>You <span class="italic">can</span> explicitly disable SQLJ/explicit statement caching or JDBC implicit caching, through JDBC connection APIs. Because SQLJ/explicit caching and JDBC implicit caching use the same cache size, there might sometimes be reason to do so. The following methods are available through the <code class="codeph">OracleConnection</code> class:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">void setExplicitCachingEnabled(boolean)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean getExplicitCachingEnabled()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">void setImplicitCachingEnabled(boolean)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean getImplicitCachingEnabled()</code></p>
                           </li>
                        </ul>
                        <p>You have access to these methods if you retrieve the <code class="codeph">OracleConnection</code> instance from within a SQLJ connection context instance.
                        </p>
                        <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-79B5E5ED-8797-466E-8A48-CBB5F433BC71">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310">SQLJ Connection Context and JDBC Connection Interoperability</a>"</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-ABEC7041-B798-41AD-B9FE-33EE3C84066E">
                           <p class="notep1">Note:</p>
                           <p>In SQLJ, JDBC implicit caching is disabled by default and remains disabled unless you explicitly enable it through the <code class="codeph">setImplicitCachingEnabled()</code> method.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-2CF05912-E06A-4997-ABAC-B0D535406903">Key Interactions Between SQLJ/Explicit Caching and JDBC Implicit Caching</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With regard to statement caching in Oracle-specific code, this document naturally emphasizes SQLJ/explicit caching rather than JDBC implicit caching. If you do not use JDBC code in your application, SQLJ/explicit caching is the only statement caching that is relevant. However, there are situations where you might want to use both SQLJ and JDBC code in your application, and in these circumstances you might also want to use implicit caching.</p>
                        <p>SQLJ/explicit caching and JDBC implicit caching are enabled independently of each other. Furthermore, you do not have access to the implicit cache through SQLJ. However, there is a key interaction between the two, in that they share the same cache size. If, for example, the statement cache size is 5, then you can have a maximum of five statements cached for SQLJ/explicit caching and implicit caching combined.</p>
                        <p>An important point related to this is that if you choose to effectively disable SQLJ/explicit statement caching by setting the cache size to 0, then you have also effectively disabled implicit caching.</p>
                        <p>Also be aware that if SQLJ/explicit caching is disabled, changing the cache size to a value greater than 0 will enable it, but this does not affect whether implicit caching is enabled.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-9BE5E251-69D2-4230-9CF3-D32B25053D1B">JDBC Support for Statement Caching (ISO Code)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With ISO standard code generation, specified through the SQLJ translator <code class="codeph">-codegen=iso</code> setting, statement caching is a standard SQLJ feature that does not require any particular JDBC driver. However, using a driver that implements the <code class="codeph">sqlj.runtime.profile.ref.ClientDataSupport</code> interface enables more robust caching. Oracle Database 12<span class="italic">c </span>Release 1 (12.1) JDBC drivers implement this interface, providing the following features:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A separate cache for each database connection, instead of a single static cache for the entire application</p>
                           </li>
                           <li>
                              <p>The ability to share cached statements between multiple instances of a connection context class that share the same underlying connection</p>
                           </li>
                        </ul>
                        <p>When a single cache is used, as is the case with a generic JDBC driver that does not implement <code class="codeph">ClientDataSupport</code>, a statement executed in one connection can cause a cached statement from another connection to be flushed (if the statement cache size, the maximum number of statements that can be cached, is exceeded).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-5C735039-390C-4F4F-81BB-484B6328812F">Oracle Customizer Option for Statement Cache Size (ISO Code)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With ISO standard code generation, statement caching is enabled in your application by default with a cache size of 5 (the same default size as with Oracle-specific code) when you use Oracle customizer, which is typically executed as part of Oracle SQLJ translation.</p>
                        <p>You can alter the statement cache size as desired, or effectively disable statement caching with a cache size of 0, through the Oracle customizer <code class="codeph">stmtcache</code> option. This is set as <code class="codeph">-P-Cstmtcache=</code><span class="italic"><code class="codeph">n</code></span>, where <span class="italic"><code class="codeph">n</code></span> is an integer.
                        </p>
                        <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-B7DD5DBC-BB84-47E9-BF98-D634CD2BEC1B">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="appendix.html#GUID-2EF347A8-53D3-404B-8702-A9C6E8ECFF8B">Oracle Customizer Statement Cache Size Option (stmtcache)</a>"</span></p>
                        </div>
                        <p>If you use multiple connection context classes and, therefore, have multiple profiles, you can set their statement cache sizes individually by running SQLJ (actually, the customizer) separately for each profile.</p>
                        <p>At run time, the appropriate SQLJ profile determines the statement cache size for a connection. This would be the profile that corresponds to the first connection context class instantiated for this connection. Its statement cache size setting, if any, is determined according to how you set the Oracle customizer <code class="codeph">stmtcache</code> option when you customized the profile. The run-time statement cache size for a connection is set when the first statement on that connection is executed.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-1E818457-7BC9-4DF1-A294-41E60D066193">Additional Statement Caching Behavior</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When a SQLJ connection context object is instantiated, if the statement cache size on the underlying JDBC connection is smaller than the default size for the connection context class, then the SQLJ run time will attempt to increase the JDBC statement cache size to the connection context default value. This manipulation occurs even with ISO code generation, enabling explicit statement caching in the process, although this is actually of no relevance in the ISO code case.</p>
                        <p>If, on the other hand, the actual JDBC statement cache size is larger, then the SQLJ run time will not attempt to perform a change in the cache size. The SQLJ run time checks the actual JDBC cache size against the default size set whenever it creates a SQLJ connection context instance.</p>
                        <p>It is important to note that these methods have the same effect regardless of the context class on which they are issued, because they modify or report the same underlying static field.</p>
                        <p>As an example, assume the following connection context class declarations:</p><pre class="oac_no_warn" dir="ltr">#sql context CtxtA;
#sql context CtxtB;
</pre><p>In this case, each of the following three code instructions has the effect that whenever a new SQLJ connection context instance is subsequently created, it will <span class="italic">not</span> try to enable SQLJ/explicit statement caching:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ref.DefaultContext.setDefaultStmtCacheSize(0);
</pre><pre class="oac_no_warn" dir="ltr">CtxtA.setDefaultStmtCacheSize(0);
</pre><pre class="oac_no_warn" dir="ltr">CtxtB.setDefaultStmtCacheSize(0);
</pre><div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-4199F5FE-3D1B-4189-9C90-97B56673CA29">
                           <p class="notep1">Note:</p>
                           <p>If a SQLJ connection context instance is created on an underlying JDBC pooled connection, then SQLJ will not be able to change the JDBC statement cache size. For Oracle-specific code, you can retrieve the resulting exception through the connection context <code class="codeph">getStmtCacheException()</code> method. In this case, the desired JDBC statement cache size must be set explicitly on the underlying physical connections. For data sources, the cache size is set through vendor-specific data source attributes.
                           </p>
                        </div>
                        <p>SQLJ/explicit caching and JDBC implicit caching functionality have different semantics and behaviors. As noted earlier, SQLJ statement caching applies only to single statements used repeatedly, such as in a loop or through repeated calls to the same method. Consider the following example:</p><pre class="oac_no_warn" dir="ltr">...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #1
...
<span class="italic">Java code</span>
...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #2
...
<span class="italic">Java code</span>
...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #3
...
</pre><p>Assume the three SQL operations are identical, including white space.</p>
                        <p>SQLJ caching would consider these three occurrences of the same SQL operation to be three different statements. They will occupy three separate slots in the cache. JDBC implicit caching, however, would recognize these as identical statements, using only a single cache slot for all three. The statement would be reused for occurrence #2 and occurrence #3. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-9ABD8A04-8109-42E5-BE59-51FCD21FF2EA">Statement Caching Limitations and Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Using a statement cache, even of size 1, will improve the performance of almost any SQLJ application. Be aware of the following, however:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>There is no benefit if each statement is executed only once.</p>
                           </li>
                           <li>
                              <p>Try to avoid interleaving statements executed once with statements executed multiple times. The statements being executed only once would needlessly take up space in the statement cache, which becomes an issue when you reach the statement cache size limit. As an alternative, if you use ISO code generation you can use a separate connection context class for statements that are executed only once and disable statement caching for that connection context class.</p>
                           </li>
                           <li>
                              <p>Distinct statements with identical SQL operations are treated the same way as any distinct statements. Each is processed and cached separately. As an alternative, put the SQL operation in a method and call the method repeatedly, instead of using distinct statements.</p>
                           </li>
                           <li>
                              <p>Be careful in choosing an appropriate statement cache size. If it is too small, then the cache might fill up resulting in statements being flushed before they are reexecuted. If it is too large, then database resources or program resources may be exhausted.</p>
                           </li>
                        </ul>
                        <p>Also be aware of the following general notes regarding statement caching:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>With Oracle-specific code generation, using separate SQLJ connection context instances to have separate statement caching behavior will not work if the connection contexts share the same underlying JDBC connection instance. This is because under Oracle-specific code generation, SQLJ uses the JDBC statement cache.</p>
                           </li>
                        </ul>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>For Oracle applications, the statement cache size plus the maximum number of open JDBC statements in your application, both directly and through SQLJ, should be less than the maximum number of cursors available for a session. This is because the maximum number of cursors defines the maximum number of statements that can be open simultaneously.</p>
                           </li>
                           <li>
                              <p>Using a statement cache generally does not change the execution semantics of an operation itself, although there are some scenarios where it does. For example, if you have a statement that throws an exception when its resources are released, then using a cache would mean that the exception would not be thrown until the connection is closed or the statement is flushed from the cache, which happens when the cache size is exceeded.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ752"></a><a id="JSQLJ753"></a><a id="JSQLJ754"></a><a id="JSQLJ755"></a><a id="JSQLJ756"></a><a id="JSQLJ757"></a><a id="JSQLJ758"></a><a id="JSQLJ759"></a><a id="JSQLJ760"></a><a id="JSQLJ761"></a><a id="JSQLJ762"></a><a id="JSQLJ751"></a><div class="props_rev_3"><a id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803" name="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803"></a><h4 id="JSQLJ-GUID-E764E87E-1320-4DBE-B59E-7B03150BF803" class="sect4">Update Batching</h4>
                  <div>
                     <p>Update batching, referred to as batch updates in the Sun Microsystems JDBC 2.0 specification, allows <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, and <code class="codeph">INSERT</code> statements that are batchable and compatible to be collected into a batch and sent to the database for execution at once, saving round trips to the database. This feature is included in the JDBC and SQLJ specifications and is supported by the Oracle JDBC and SQLJ implementations. Update batching is typically used for an operation that is executed repeatedly within a loop.
                     </p>
                     <p>In SQLJ, update batching is tied to execution context usage. This feature is enabled or disabled in each execution context, independently of any other execution context, and each execution context instance maintains its own batch.</p>
                     <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-4A529E01-5F5A-4BE5-AB61-4871B12353EB">
                        <p class="notep1">Note:</p>
                        <p>Be aware of the following for update batching:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must use the default Oracle-specific code generation or, for ISO code generation, customize your application with Oracle customizer.</p>
                           </li>
                           <li>
                              <p>It is highly advisable to disable auto-commit mode. This gives you control of what to commit and what to roll back in case of an error during batch execution.</p>
                           </li>
                        </ul>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-F1F14248-C158-463E-BA4B-3741C20617B9">Batchable and Compatible Statements</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Two criteria determine whether a statement can be added to an existing batch of statements:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Is it batchable? You cannot batch some kinds of statements under any circumstances.</p>
                           </li>
                           <li>
                              <p>Is it compatible with statements in the existing batch?</p>
                           </li>
                        </ul>
                        <p>For SQLJ, the following kinds of statements are batchable:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">UPDATE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INSERT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DELETE</code></p>
                           </li>
                        </ul>
                        <p>However <code class="codeph">UPDATE</code> and <code class="codeph">INSERT</code> statements with one or more stream host expressions are <span class="italic">not</span> batchable.
                        </p>
                        <p>In SQLJ, only multiple instances of the same statement are compatible. This can occur in either of two circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A statement is executed repeatedly in a loop.</p>
                           </li>
                           <li>
                              <p>A statement is executed in a method, and the method is called repeatedly.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-F319E347-1236-4AD9-9387-C0C5C1079F76">Enabling and Disabling Update Batching</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>SQLJ performs update batching separately for each execution context instance. Each one can have update batching enabled independently of your other execution context instances, and each maintains its own batch.</p>
                        <p>To enable or disable update batching for a particular execution context instance, use the <code class="codeph">setBatching()</code> method of that execution context instance. This method takes boolean input, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(false);
...
</pre><p>Update batching is disabled by default.</p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-2C21EBA5-95C9-4E44-BF8B-D41130CAF60B">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">setBatching()</code> method does not affect an existing statement batch. Neither enabling nor disabling update batching causes an existing batch to be executed or canceled.
                           </p>
                        </div>
                        <p>Use the <code class="codeph">isBatching()</code> method of an execution context instance to determine if update batching is enabled for that execution context:
                        </p><pre class="oac_no_warn" dir="ltr">ExecutionContext ec = new ExecutionContext();
...
boolean batchingOn = ec.isBatching();
</pre><p>This does not, however, indicate whether a batch is currently pending.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1005910">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-5D1F6F28-8AAE-4E70-854E-6968FFF7D847">Explicit and Implicit Batch Execution</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>You can explicitly execute a pending update batch as desired, but it might also be implicitly executed under certain circumstances. </p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-CAA4C8A0-2209-4256-A438-934AED734B56">
                           <p class="notep1">Note:</p>
                           <p>It is important to be aware of what happens when an exception occurs in the middle of a batch execution.</p>
                        </div>
                        <p>Use the <code class="codeph">executeBatch()</code> method of the execution context instance to explicitly execute an update batch. This method returns an <code class="codeph">int</code> array of update counts.
                        </p>
                        <p>Following is an example of explicitly executing a batch:</p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...;
for (int i = 0; i &lt; empnos.length; i++)
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}
int[] updateCounts = ec.executeBatch();
...
</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-B7037974-B3D0-49F6-9B62-E13D3DB6219F">
                           <p class="notep1">Note:</p>
                           <p>If you invoke <code class="codeph">executeBatch()</code> when the execution context instance has no pending batch, then the method returns <code class="codeph">null</code>.
                           </p>
                        </div>
                        <p>When a pending update batch exists, it is implicitly executed in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>An executable statement is encountered that is not batchable. In this case the existing batch is executed first, then the nonbatchable statement is executed.</p>
                           </li>
                           <li>
                              <p>An update statement is encountered that is batchable, but is not compatible with the statements in the existing batch, in other words, is not an instance of the same statement. In this case the batch is executed, then a new batch is created, starting with the incompatible statement.</p>
                           </li>
                           <li>
                              <p>A predefined batch limit, that is, a specified number of statements, is reached.</p>
                           </li>
                        </ul>
                        <p>Following is an example. First one batch is created and executed implicitly when an unbatchable statement is encountered, then a new batch is created and executed implicitly when a batchable, but incompatible, statement is encountered:</p><pre class="oac_no_warn" dir="ltr">ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
/* Statements in the following loop will be placed in a batch */
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}

/* a SELECT is unbatchable so causes the batch to be executed */
double avg;
#sql [ec] { SELECT avg(salary) INTO :avg FROM employees };

/* Statements in the following loop will be placed in a new batch */
double[] comms = ...;
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE employees SET commission_pct = :(comms[i]) WHERE employee_id = :(empnos[i]) };
}

/* the following update is incompatible with the second batch, so causes it to be executed */
int smithdeptno = ...;
#sql [ec] { UPDATE employees SET department_no = :deptno WHERE first_name = 'Smith' };
</pre><p>To obtain the update count array for a batch executed implicitly, invoke the <code class="codeph">getBatchUpdateCounts()</code> method of the execution context instance. This returns the update counts for the last batch to be executed successfully in this execution context instance. The following code statement could be inserted after the <code class="codeph">SELECT</code> and after the last <code class="codeph">UPDATE</code>:
                        </p><pre class="oac_no_warn" dir="ltr">int[] updateCounts = ec.getBatchUpdateCounts();
</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-9B6FEFB5-D57A-4761-9053-A6AC4B3DA370">
                           <p class="notep1">Note:</p>
                           <p>If no update batch has been executed successfully for the execution context instance, then <code class="codeph">getBatchUpdateCounts()</code> returns <code class="codeph">null</code>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006005">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A6CA4450-1862-4346-B0FF-7E8DB241019A">Canceling a Batch</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To cancel the batch that is pending in an execution context, use the <code class="codeph">cancel()</code> method of the execution context instance. You can, for example, cancel a batch that has been executed, but not yet committed, in the event that an exception occurred during batch execution. Following is an example:
                        </p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...;
for (int i = 0; i &lt; empnos.length; i++)
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
   if (!check(sals[i], empnos[i])) //assume "check" is a user-supplied function
   {
      ec.cancel();
      throw new SQLException("Process canceled.");
   }
}

try 
{ 
   int[] updateCounts = ec.executeBatch();
} catch ( SQLException exception) { ec.cancel(); }
...
</pre><p>When you cancel a batch, the next batchable statement will start a new batch.</p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-E269016C-CA32-414B-A9B7-C8AAC3EF5562">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Calling <code class="codeph">cancel()</code> will also cancel any statement currently executing.
                                 </p>
                              </li>
                              <li>
                                 <p>Canceling a batch does <span class="italic">not</span> disable update batching.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006039">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-736D0F9D-35E9-4EA9-9899-EC8A56949D36">Execution Context Update Counts</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In the Oracle Database 12<span class="italic">c </span>Release 1 (12.1) SQLJ implementation, the array of update counts returned by the <code class="codeph">executeBatch()</code> or <code class="codeph">getBatchUpdateCounts()</code> method of an execution context instance does <span class="italic">not</span> contain counts of the number of rows updated by the batched statements, but simply values indicating whether each statement was successful. So its functionality differs from that of the single update count returned by the <code class="codeph">getUpdateCount()</code> method of the execution context instance when batching is not enabled. As statements are batched, and after batch execution, the single update count returned by <code class="codeph">getUpdateCount()</code> is also affected.
                        </p>
                        <p>In a batch-enabled environment, the value available from the <code class="codeph">getUpdateCount()</code> method of the execution context instance is modified after each statement is encountered. It will be updated with one of several <code class="codeph">ExecutionContext</code> class static <code class="codeph">int</code> constant values, as follows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">NEW_BATCH_COUNT</code>: Indicates that a new batch was created for the last statement encountered.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ADD_BATCH_COUNT</code>: Indicates that the last statement encountered was added to an existing batch.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EXEC_BATCH_COUNT</code>: Indicates that the pending batch was executed, either explicitly or implicitly, after the last statement was encountered.
                              </p>
                           </li>
                        </ul>
                        <p>If you want to refer to these constants, then use the following qualified names: </p><pre class="oac_no_warn" dir="ltr">ExecutionContext.NEW_BATCH_COUNT
ExecutionContext.ADD_BATCH_COUNT
ExecutionContext.EXEC_BATCH_COUNT
</pre><p>After a batch has been executed, either explicitly or implicitly, the array of values returned by <code class="codeph">executeBatch()</code> or <code class="codeph">getBatchUpdateCounts()</code> indicates only whether the statements executed successfully. There is an array element for each batched statement. In accordance with the JDBC 2.0 specification, a value of <code class="codeph">-2</code> for an array element indicates that the corresponding statement completed successfully, but that the number of rows it affected is unknown.
                        </p>
                        <p>Checking all the array values after execution of a batch would not be meaningful. As currently implemented, the only useful test of this array would be to verify the number of statements that were in the batch prior to execution, by checking the number of elements in the array after a successful execution (essentially, after a batch execution that does not produce an exception).</p>
                        <p>Note that the update counts array is not modified as statements are batched, only as the batch is executed.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006064">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-799B803A-A09C-4F5B-9703-69A97AE24225">Setting a Batch Limit</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>You can specify that each update batch be executed after a predefined number of statements have been batched, before the next statement would be added. Use the <code class="codeph">setBatchLimit()</code> method of the execution context instance, inputting a positive, nonzero integer as follows:
                        </p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
ec.setBatchLimit(10);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; 20; i++) 
{
   #sql [ec] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
</pre><p>This loop is executed 20 times, with the statements being batched and the batch being executed during the 11th time through the loop, before the 11th statement would be added to the batch. Note that the batch would not be executed a second time in the loop, however. When your application exits the loop, the last ten statements would still be in the batch and would not be executed until another statement is encountered or you execute the batch explicitly.</p>
                        <p>You can use two special static <code class="codeph">int</code> constants of the <code class="codeph">ExecutionContext</code> class as input to the <code class="codeph">setBatchLimit()</code> method:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">AUTO_BATCH</code>: Enables the SQLJ run time to determine the batch limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">UNLIMITED_BATCH</code> (default): Specifies that there is no batch limit.
                              </p>
                           </li>
                        </ul>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
ec.setBatchLimit(ExecutionContext.AUTO_BATCH);
...
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">ec.setBatchLimit(ExecutionContext.UNLIMITED_BATCH);
...
</pre><p>To check the current batch limit, use the <code class="codeph">getBatchLimit()</code> method of the execution context instance.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-858CDEA9-304B-4472-9210-2ED966190C2D">Batching Incompatible Statements</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you want to batch a statement that is incompatible with statements in an existing batch, without implicitly executing the existing batch, then you will have to use a separate execution context instance. Following is an example:</p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec1 = new ExecutionContext();
ec1.setBatching(true);
ExecutionContext ec2 = new ExecutionContext();
ec2.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec1] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
   #sql [ec2] { UPDATE emp2 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
int[] updateCounts1 = ec1.executeBatch();
int[] updateCounts2 = ec2.executeBatch();
...
</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-018A97CE-20B5-4156-A760-C6A268DA8F13">
                           <p class="notep1">Note:</p>
                           <p>This example assumes that the two <code class="codeph">UPDATE</code> statements are completely independent of each other. Do not batch interdependent statements in different execution contexts because you cannot completely assure the order in which they will be executed.
                           </p>
                        </div>
                        <p>An alternative is to use a single execution context and separate loops so that all the <code class="codeph">EMP1</code> updates are batched and executed prior to the <code class="codeph">EMP2</code> updates:
                        </p><pre class="oac_no_warn" dir="ltr">...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE emp2 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
ec.executeBatch();
...
</pre><p>This example executes the first batch implicitly and the second batch explicitly.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-507081B0-2691-4FDC-BFDA-0382143BF567">Using Implicit Execution Contexts for Update Batching</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>All the update batching examples so far have created and specified explicit execution context instances. This is not necessary, however, given that every connection context instance has an implicit execution context instance. For example, you can access the implicit execution context instance of the default connection as follows:</p><pre class="oac_no_warn" dir="ltr">DefaultContext.getDefaultContext().getExecutionContext().setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}
// implicitly execute the batch and commit
#sql { COMMIT };
</pre><p>Or, you could execute the batch explicitly, as follows:</p><pre class="oac_no_warn" dir="ltr">DefaultContext.getDefaultContext().getExecutionContext().executeBatch();
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-23DC0E98-FFED-43CF-A525-E15722C90E8D">General Cautions Regarding Update Batching</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you use update batching, especially if you mix statements using an unbatched execution context instance with statements using a batched execution context instance, then remember the following points:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If an unbatched statement depends on a batched statement, then be sure the batch is executed prior to the unbatched statement.</p>
                           </li>
                           <li>
                              <p>A JDBC <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> operation, that is, an auto-commit or any explicit use of the <code class="codeph">commit()</code> or <code class="codeph">rollback()</code> method of a JDBC <code class="codeph">Connection</code> instance, does not execute pending statements in a batch.
                              </p>
                              <p>It is important to note, however, that using a SQLJ <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> statement, such as follows, <span class="italic">will</span> execute pending statements in a batch:
                              </p><pre class="oac_no_warn" dir="ltr">#sql { COMMIT };
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">#sql { ROLLBACK };
</pre><p>This is another reason that you should always commit or roll back changes using <code class="codeph">#sql</code> syntax, which cleans up both SQLJ resources and JDBC resources.
                              </p>
                           </li>
                           <li>
                              <p>When a batch is implicitly executed as a result of an unbatchable or incompatible statement being encountered, the batch is executed <span class="italic">before</span> the unbatchable or incompatible statement is executed, but <span class="italic">after</span> the input parameters of that statement have been evaluated and passed to the statement.
                              </p>
                           </li>
                           <li>
                              <p>If you no longer intend to use a particular batch-enabled execution context instance, then explicitly execute or cancel its pending batch to free resources.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006173">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-9D77ED43-AAFE-43C3-9D3B-B1B1AFC35D70">Error Conditions During Batch Execution</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In the event that a statement causes an exception in the middle of a batch execution, be aware of the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Batched statements following the statement that caused the exception are <span class="italic">not</span> executed.
                              </p>
                           </li>
                           <li>
                              <p>Batched statements that had already been executed prior to the exception are <span class="italic">not</span> rolled back.
                              </p>
                           </li>
                           <li>
                              <p>If the batch where the exception occurred was executed implicitly as the result of another (unbatchable or incompatible) statement being encountered, that statement is <span class="italic">not</span> executed.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A83607A9-3148-4EE6-BD76-1EAFE11CA42D">
                           <p class="notep1">Note:</p>
                           <p>Presumably you have disabled auto-commit mode when using update batching. This gives you commit/rollback control in case of an error during batch execution.</p>
                        </div>
                        <p>When an exception occurs during batch execution under JDBC 2.0 or later, it is typically an instance of the standard <code class="codeph">java.sql.BatchUpdateException</code> class, a subclass of the <code class="codeph">java.sql.SQLException</code> class. The <code class="codeph">BatchUpdateException</code> class has a <code class="codeph">getUpdateCounts()</code> method that, for batched statements successfully executed before the exception occurred, returns an array of update counts equivalent to what would be returned by the <code class="codeph">executeBatch()</code> or <code class="codeph">getBatchUpdateCounts()</code> method of the <code class="codeph">ExecutionContext</code> class.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A7CE4C74-ABF1-4F86-8829-AC234982E270">Recursive Call-ins and Update Batching</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Execution of SQLJ stored procedures, where one calls the other, can result in situations where the two procedures are simultaneously using the same execution context instance. The update-batching flag, set using the <code class="codeph">setBatching()</code> method of the execution context instance, would act in the same way as other execution context attributes. Regardless of which stored procedure sets it, it would affect the next executable statement in either stored procedure.
                        </p>
                        <p>For this reason, update batching is automatically disabled in the server whenever a recursive call-in occurs. The pending batch is executed, and no batching occurs in the recursively invoked procedure. To avoid this behavior, use explicit execution context instances in batch-enabled stored procedures.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ764"></a><a id="JSQLJ765"></a><a id="JSQLJ763"></a><div class="props_rev_3"><a id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50" name="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50"></a><h4 id="JSQLJ-GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50" class="sect4">Column Definitions</h4>
                  <div>
                     <p>The Oracle SQLJ implementation reflects Oracle JDBC support for column type and size definitions. Depending on the driver implementation, which differs somewhat among the different Oracle JDBC drivers, registering column types and sizes can save a trip to the database for each query. In particular, this is true for Oracle JDBC Thin driver and use of positional iterators.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50__GUID-DCC0030F-C486-40D5-BBD9-24CFDA877839">Oracle Implementation of Column Definitions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you enable column definitions, then the Oracle SQLJ implementation takes the following steps to automatically register column types and sizes:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>During customization or during translation when the default Oracle-specific code generation is used, SQLJ connects to a specified database schema to determine types and sizes of columns being retrieved. With ISO standard SQLJ code generation, the column defaults become part of the SQLJ profile. This can be accomplished during the customization step of source code translation or during separate customization of an existing profile.</p>
                           </li>
                           <li>
                              <p>When your application executes, the SQLJ run time will use the column information to register the column types and sizes with the JDBC driver, using a call to the <code class="codeph">defineColumnType()</code> method available in the Oracle JDBC statement classes.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50__GUID-8044C763-F4AC-4E23-A1D0-E1D7212B91F3">Customizer and Translator Options for Column Definitions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To enable column definitions, set SQLJ options as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Enable the <code class="codeph">optcols</code> flag. For Oracle-specific code generation, use the SQLJ translator <code class="codeph">-optcols</code> option. For ISO standard code generation, use either the translator option or the Oracle customizer option (<code class="codeph">-P-Coptcols</code> on the SQLJ command line).
                              </p>
                           </li>
                           <li>
                              <p>Set the user, password, and URL for a database connection. For Oracle-specific code generation, this is through the SQLJ translator <code class="codeph">-user</code>, <code class="codeph">-password</code>, and <code class="codeph">-url</code> options. For ISO standard code generation, this can be through the translator options or you can separately use the customizer options (<code class="codeph">-P-user</code>, <code class="codeph">-P-password</code>, and <code class="codeph">-P-url</code> on the SQLJ command line). In addition, set the JDBC driver class (<code class="codeph">-P-driver</code> on the SQLJ command line) if you are not using the default <code class="codeph">OracleDriver</code> class.
                              </p>
                           </li>
                        </ul>
                        <p>For information about the customizer options, refer to the <code class="codeph">optcols</code> section under <span class="q">"<a href="appendix.html#GUID-0BBEA4C2-0474-40DE-9082-D55813F8BE02">Overview of Customizer-Specific Options</a>"</span>, and the <code class="codeph">user</code>, <code class="codeph">password</code>, <code class="codeph">url</code>, and <code class="codeph">driver</code> sections under <span class="q">"<a href="appendix.html#GUID-4E316F9C-E16F-45D4-A5ED-B77B7BCF44A6">Overview of Customizer Harness Options</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ767"></a><a id="JSQLJ768"></a><a id="JSQLJ769"></a><a id="JSQLJ766"></a><div class="props_rev_3"><a id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D" name="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D"></a><h4 id="JSQLJ-GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D" class="sect4">Parameter Size Definitions</h4>
                  <div>
                     <p>The Oracle JDBC and SQLJ implementations enable you to optimize JDBC resource allocation by defining parameter sizes (sizes of Java host variables) used as any of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Input or output parameters in stored procedure or function calls</p>
                        </li>
                        <li>
                           <p>Return values from stored function calls</p>
                        </li>
                        <li>
                           <p>Input or output parameters in SET statements </p>
                        </li>
                        <li>
                           <p>Input or output parameters in PL/SQL blocks</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-6213773C-5889-48A8-A081-850606DDEEE2">Oracle Implementation of Parameter Size Definitions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle implements parameter size definitions through option settings, in combination with hints embedded in source code comments. For ISO standard SQLJ code generation, Oracle customizer options are available. For the default Oracle-specific code generation, equivalent SQLJ translator options are available.</p>
                        <p>Use options and hints as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Enable parameter size definitions through the SQLJ translator or Oracle customizer parameter definition flag.</p>
                           </li>
                           <li>
                              <p>Specify default sizes for particular data types through the SQLJ translator or Oracle customizer parameter default size option.</p>
                           </li>
                           <li>
                              <p>Override data type default sizes for particular parameters by embedding hints in source code comments, following a prescribed format.</p>
                           </li>
                        </ul>
                        <p>For any given host variable, when parameter size definitions are enabled, resources are allocated according to the source code hint if there is one. If there is no source code hint, then the default size for the corresponding data type is used if one was specified. If there is no source code hint or appropriate default size, then maximum resources are allocated according to the JDBC implementation.</p>
                        <p>When your application executes, the parameter sizes are registered through calls to the <code class="codeph">defineParameterType()</code> and <code class="codeph">registerOutParameter()</code> methods available in the Oracle JDBC statement classes.
                        </p>
                        <div class="infoboxnote" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-33D99FBA-07BA-432F-802F-8547894645B8">
                           <p class="notep1">Note:</p>
                           <p>If you do not enable the parameter definition flag, then parameter size defaults and source code hints will be ignored and maximum or default resources will be allocated according to the JDBC implementation.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-6B4EE248-90F4-4984-AB56-EC9EABE3BD2F">Customizer and Translator Options for Parameter Size Definitions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use the following SQLJ options for parameter size definitions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Use the <code class="codeph">optparams</code> flag to enable parameter size definitions. For Oracle-specific code generation, use the SQLJ translator <code class="codeph">-optparams</code> option. For ISO standard code generation, use either the translator option or the Oracle customizer option, <code class="codeph">-P-Coptparams</code> on the SQLJ command line.
                              </p>
                           </li>
                           <li>
                              <p>Use <code class="codeph">optparamdefaults</code> to set default sizes for particular data types. For Oracle-specific code generation, use the SQLJ translator <code class="codeph">-optparamdefaults=</code><span class="italic"><code class="codeph">xxxx</code></span> option. For ISO standard code generation, use either the translator option or the Oracle customizer option, <code class="codeph">-P-Coptparamdefaults=</code><span class="italic"><code class="codeph">xxxx</code></span> on the SQLJ command line.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-1D3BD376-A9A2-436C-B77B-B7548CFCD96A">Source Code Hints for Parameter Size Definitions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Embed source code hints for parameter size definitions within your SQLJ statements in the following format (you can add white space within the comment, as desired):</p><pre class="oac_no_warn" dir="ltr">/*(<span class="italic">size</span>)*/
</pre><p>The size is in bytes. Hints are ignored if the <code class="codeph">optparams</code> flag is disabled.
                        </p>
                        <p>You can override the default parameter size, without specifying a new size (leaving size allocation to the JDBC implementation), as follows:</p><pre class="oac_no_warn" dir="ltr">/*()*/
</pre><p>Here is an example:</p><pre class="oac_no_warn" dir="ltr">byte[] hash;
String name=Tyrone;
String street=2020 Meryl Street;
String city=Wichita;
String state=Kansas;
String zipcode=77777;
#sql hash = { /* (5) */ VALUES (ADDR_HASH(:name /* (20) */, :street /* () */, 
                               :city, :state, :INOUT zipcode /* (10) */ )) };
</pre><p>A hint for a result expression, such as the result expression <code class="codeph">hash</code> in the example, must be the first item appearing inside the brackets of the SQLJ statement, as shown. Hints for input and output host variables must immediately follow the variables, as shown.
                        </p>
                        <p>The example sets parameter sizes as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">hash</code>: 5 bytes
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">name</code>: 20 bytes
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">street</code>: override default, but with no setting (leave allocation up to JDBC)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">city</code>: none (use appropriate data type default, if any)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">state</code>: none (use appropriate data type default, if any)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">zipcode</code>: 10 bytes
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-C63A6FF8-4F21-4D98-89C1-34E967D7CCBC">
                           <p class="notep1">Note:</p>
                           <p>If any parameter size is altered such that its actual size exceeds its registered size at run time, then a SQL exception will be thrown.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ770"></a><div class="props_rev_3"><a id="GUID-630E713D-C1AA-4ED8-8061-153B6880EB61" name="GUID-630E713D-C1AA-4ED8-8061-153B6880EB61"></a><h3 id="JSQLJ-GUID-630E713D-C1AA-4ED8-8061-153B6880EB61" class="sect3">SQLJ Debugging Features</h3>
               <div>
                  <p>This section summarizes debugging features in the Oracle SQLJ implementation. It covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-35667B8F-391D-4B14-BE21-0C76BE642D14">SQLJ -linemap Flag for Debugging</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4">Overview of the AuditorInstaller Specialized Customizer</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-4D44802F-CF56-4C60-BFA3-F783570806F4">Overview of Developing and Debugging in Oracle10g JDeveloper</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ771"></a><div class="props_rev_3"><a id="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14" name="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14"></a><h4 id="JSQLJ-GUID-35667B8F-391D-4B14-BE21-0C76BE642D14" class="sect4">SQLJ -linemap Flag for Debugging</h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">-linemap</code> flag instructs SQLJ to map line numbers from a SQLJ source code file to locations in the corresponding <code class="codeph">.class</code> file. This will be the <code class="codeph">.class</code> file created during compilation of the <code class="codeph">.java</code> file generated by the SQLJ translator. As a result of this, when Java run-time errors occur, the line number reported by the Java virtual machine (JVM) is the line number in the SQLJ source code, making it much easier to debug.
                        </p>
                        <p>If you are using the Sun Microsystems <code class="codeph">jdb</code> debugger, then use the <code class="codeph">-jdblinemap</code> option instead of the <code class="codeph">-linemap</code> option. The options are equivalent, except that <code class="codeph">-jdblinemap</code> does some special processing, necessitated by the fact that <code class="codeph">jdb</code> does not support Java source files with file name extensions other than the <code class="codeph">.java</code> extension.
                        </p>
                        <div class="infoboxnote" id="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14__GUID-6DA504C7-6AD4-41AC-AE9E-F9BB1FCF5FFF">
                           <p class="notep1">Note:</p>
                           <p>If you are translating in the server, then class schema objects created during server-side translation automatically reference line numbers that map to the SQLJ source code. This is equivalent to enabling the <code class="codeph">-linemap</code> option when you translate on a client. 
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ773"></a><div class="props_rev_3"><a id="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4" name="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4"></a><h4 id="JSQLJ-GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4" class="sect4">Overview of the AuditorInstaller Specialized Customizer</h4>
                  <div>
                     <p>For ISO code generation, SQLJ provides a special customizer, <code class="codeph">AuditorInstaller</code>. This customizer will insert sets of debugging statements, known as auditors, into profiles specified on the SQLJ command line. These profiles must already exist from previous customization. The debugging statements will execute during SQLJ run time (when someone runs your application), displaying a trace of method calls and values returned.
                     </p>
                     <p>Use the customizer harness <code class="codeph">debug</code> option, preceded by <code class="codeph">-P-</code> as with any general customization option, to insert the debugging statements.
                     </p>
                     <div class="infoboxnotealso" id="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4__GUID-5FBFE829-924C-4830-AECE-B52F4891DE33">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="appendix.html#GUID-B820810A-DDDF-4E42-A3C9-AF04F4DC7075">AuditorInstaller Customizer for Debugging</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ774"></a><div class="props_rev_3"><a id="GUID-4D44802F-CF56-4C60-BFA3-F783570806F4" name="GUID-4D44802F-CF56-4C60-BFA3-F783570806F4"></a><h4 id="JSQLJ-GUID-4D44802F-CF56-4C60-BFA3-F783570806F4" class="sect4">Overview of Developing and Debugging in Oracle10<span class="italic">g</span> JDeveloper
                  </h4>
                  <div>
                     <p>The Oracle SQLJ product is fully integrated into the Oracle10<span class="italic">g</span> JDeveloper visual programming tool. 
                     </p>
                     <p>JDeveloper also includes an integrated debugger that supports SQLJ. SQLJ statements, as with standard Java statements, can be debugged in-line as your application executes. Reported line numbers are according to the line numbers in your SQLJ source code (as opposed to in the generated Java code).</p>
                  </div>
               </div>
            </div><a id="JSQLJ775"></a><div class="props_rev_3"><a id="GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585" name="GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585"></a><h3 id="JSQLJ-GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585" class="sect3">SQLJ Support for Oracle Performance Monitoring</h3>
               <div>
                  <p>FUTURE (post-10i/10.1): SQLJ DMS monitoring stored locally as hierarchy; -sqlmonitor.dms=false setting (for storing locally instead of sending to DMS);use of SQLJ DMS APIs (to access results stored locally).</p>
                  <p>FUTURE (post-10i/10.1): SQLJ -components=append; multiple translation runs for DMS.</p>
                  <p>FUTURE: Update Oracle9iAS to Oracle10iAS when appropriate.</p>
                  <p>The following sections discuss Oracle SQLJ implementation support for Oracle Dynamic Monitoring Service (DMS):</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-5C441E4C-075B-46E3-A518-A5D6E8745764">Overview of SQLJ DMS Support</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661">Summary of SQLJ Command-Line Options for DMS</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-2AE24805-697C-4C28-9E27-1301DBD100C7">SQLJ Run-Time Commands and Properties File Settings for DMS</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-994A9604-3FD1-4A2E-9378-4606E1863B33">SQLJ DMS Sensors and Metrics</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-AB176F74-4B1D-478E-A896-99FB750805F2">SQLJ DMS Examples</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ776"></a><div class="props_rev_3"><a id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764" name="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764"></a><h4 id="JSQLJ-GUID-5C441E4C-075B-46E3-A518-A5D6E8745764" class="sect4">Overview of SQLJ DMS Support</h4>
                  <div>
                     <p>DMS enables users to measure performance statistics for SQLJ programs. SQLJ support for DMS focuses on the overall performance per SQL statement, such as its execution time, but can also provide method-level or class-level performance information, such as with Oracle JDBC support for DMS. You can choose a client-side perspective, such as the overall performance of each <code class="codeph">#sql</code> statement, a server-side perspective, such as server-side tracing of each SQL operation, or both.
                     </p>
                     <p>Instrumenting a program, which is specified at translation time through SQLJ options, is required in order to enable DMS setup. Specifically, instrumenting is the process of inserting DMS calls into system or application code for measuring its performance.</p>
                     <p>At run time, any components that were instrumented during translation can be monitored during execution, according to instructions in a SQLJ DMS properties file. During run time, statistics are sent to DMS through DMS APIs. This requires a running DMS system in your environment. You can then access the statistics through DMS tools.</p>
                     <p>The statistics are intended to help you track and understand SQL statement performance and are reported according to the following hierarchy (from top to bottom):</p>
                     <ol>
                        <li>
                           <p>Application: The application, in this context, is defined to consist of the SQLJ and Java components specified in the SQLJ command line for translation. However, only the SQLJ components can be instrumented.</p>
                        </li>
                        <li>
                           <p>Module: A module corresponds to a Java package.</p>
                        </li>
                        <li>
                           <p>Action: An action maps to a Java class defined in a SQLJ program.</p>
                        </li>
                        <li>
                           <p>Statement: A statement is a SQL statement in a SQLJ program.</p>
                        </li>
                     </ol>
                     <p>The following DMS statistics are measured for client-side monitoring:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Elapsed time for each <code class="codeph">#sql</code> statement, including parsing and execution
                           </p>
                        </li>
                        <li>
                           <p>Get-next time, the time to execute each <code class="codeph">next()</code> call
                           </p>
                        </li>
                        <li>
                           <p>Get-XXX time, the time to extract a database column through each <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">()</code> call
                           </p>
                        </li>
                     </ul>
                     <p>These statistics require the DMS library to be in your classpath at both translation time and run time, so are not supported on the server, where the DMS library is not available. Server-side SQLJ code cannot be monitored in the way that client-side code can.</p>
                     <p>The following statistics are measured for server-side SQL monitoring of your SQLJ client program:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Parsing time</p>
                        </li>
                        <li>
                           <p>Execution time</p>
                        </li>
                        <li>
                           <p>Fetching time</p>
                        </li>
                     </ul>
                     <p>These statistics are available from the Oracle Database 12<span class="italic">c </span>Release 1 (12.1) trace file, through SQL tracing functionality. This is independent of DMS, but you can enable it through the SQLJ DMS properties file <code class="codeph">sqlmonitor.servertracing</code> setting.
                     </p>
                     <div class="infoboxnotealso" id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764__GUID-877289C4-84BE-49AB-8D63-E824BF1D598A">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="performance-and-debugging.html#GUID-2AE24805-697C-4C28-9E27-1301DBD100C7">SQLJ Run-Time Commands and Properties File Settings for DMS</a>"</span></p>
                     </div>
                     <p>For a client-side SQLJ program, you can use both DMS statistics and server-side tracing. For example, from DMS you can get the total time required for a <code class="codeph">#sql</code> statement that consists of a query, then from server-side tracing you can find out how much of that time was actually spent executing the SQL query in the server.
                     </p>
                     <div class="infoboxnote" id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764__GUID-2E4EA613-E409-4225-B644-E16F60A02F79">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>DMS support currently requires Oracle-specific code generation, which is enabled by default.</p>
                           </li>
                           <li>
                              <p>In Oracle Database 12<span class="italic">c </span>Release 1 (12.1), instrumented code requires Java Development Kit (JDK) 6.
                              </p>
                           </li>
                           <li>
                              <p>Only SQLJ declarations and statements are instrumented.</p>
                           </li>
                           <li>
                              <p>The DMS library is in the file <code class="codeph">dms.jar</code>, in <span class="italic"><code class="codeph">ORACLE_HOME</code></span><code class="codeph">/oc4j/lib</code> in Oracle Database 12<span class="italic">c </span>Release 1 (12.1) 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ777"></a><div class="props_rev_3"><a id="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661" name="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661"></a><h4 id="JSQLJ-GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661" class="sect4">Summary of SQLJ Command-Line Options for DMS</h4>
                  <div>
                     <p>FUTURE (post-10i/10.1): -components=append; multiple translation runs.</p>
                     <p>The Oracle SQLJ implementation provides following translator front-end options to support DMS:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">-instrument</code>: Enable instrumentation and designate a name for the application (the collective of the components being translated).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-components</code>: Specify the components (packages and classes) to be instrumented.
                           </p>
                        </li>
                     </ul>
                     <p>Typically you would enable instrumentation by specifying a desired application name in the <code class="codeph">-instrument</code> setting, optionally specifying a package as well. Or specify a setting of <code class="codeph">true</code> to use the default application, <code class="codeph">defaultApp</code>. For DMS instrumentation, the term application refers to all the SQLJ and Java components specified for translation in the SQLJ command line.
                     </p>
                     <p>If instrumentation is enabled, a SQLJ DMS properties file is created according to the <code class="codeph">-instrument</code> setting, starting from the current directory, and also according to any setting of the SQLJ <code class="codeph">-d</code> option. For a setting of <code class="codeph">true</code>, the properties file is named <code class="codeph">sqlmonitor.properties</code> in the current directory.
                     </p>
                     <div class="infoboxnote" id="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661__GUID-B556D9B1-8919-421F-A5C4-58C0C5DBCE7C">
                        <p class="notep1">Note:</p>
                        <p>A setting of <code class="codeph">-instrument</code> is equivalent to <code class="codeph">-instrument=true</code>. A setting of <code class="codeph">-instrument=false</code> (the default) disables instrumentation.
                        </p>
                     </div>
                     <p>As a simple example, a setting of <code class="codeph">-instrument=myapp</code> will result in creation of the properties file <code class="codeph">myapp.properties</code>. Now consider the following example, for an application name of <code class="codeph">stock</code> and a package name of <code class="codeph">com.acme</code>:
                     </p><pre class="oac_no_warn" dir="ltr">% sqlj -instrument=com.acme/stock -d /home Stock.sqlj Trading.sqlj
</pre><p>Because of the <code class="codeph">-d</code> option, the <code class="codeph">/home/com/acme/stock.properties</code> file is created.
                     </p>
                     <p>When instrumentation is enabled through the<code class="codeph"> -instrument</code> option, use the <code class="codeph">-components</code> option to specify the subset of translated components to be instrumented for DMS monitoring, typically most or all of them to allow flexibility in what you can monitor during run time. Specify a comma-delimited list of packages (to instrument all classes in each package) or specific classes, or use the default <code class="codeph">all</code> setting to instrument all components being translated.
                     </p>
                     <p>For example, to instrument the classes <code class="codeph">Stock</code> and <code class="codeph">Trading</code>:
                     </p><pre class="oac_no_warn" dir="ltr">% sqlj ... -components=com.acme.Stock,com.acme.Trading
</pre><p>At run time, instrumented components are monitored according to what is specified in the SQLJ DMS properties file. Any components that are not instrumented during translation cannot be monitored during run time, regardless of what is specified in the properties file.</p>
                  </div>
               </div><a id="JSQLJ778"></a><div class="props_rev_3"><a id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7" name="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7"></a><h4 id="JSQLJ-GUID-2AE24805-697C-4C28-9E27-1301DBD100C7" class="sect4">SQLJ Run-Time Commands and Properties File Settings for DMS</h4>
                  <div>
                     <p>While the SQLJ <code class="codeph">-instrument</code> option specifies whether the SQLJ translator instruments files for monitoring capability, it is the SQLJ DMS properties file that actually determines what is monitored and how, at run time.
                     </p>
                     <p>This properties file is created by SQLJ during translation, and then you can modify it as desired. Be aware that if you run SQLJ again, however, SQLJ overwrites the properties file. Any changes that you made are lost.</p>
                     <p>Settings in the SQLJ DMS properties file are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">sqlmonitor.components</code>: This is a comma-delimited list of components (packages or classes) that have been instrumented. This is set automatically by the translator to reflect the setting of the SQLJ <code class="codeph">-components</code> option.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.monitorcomp</code>: This is a comma-delimited list of components (packages or classes) to be monitored and denotes a subset of the components in the <code class="codeph">sqlmonitor.components</code> setting. The setting for <code class="codeph">sqlmonitor.monitorcomp</code> is initially determined during translation to reflect the <code class="codeph">sqlmonitor.components</code> setting, but you can then adjust it as desired. A setting of <code class="codeph">all</code> means to monitor all components listed in the <code class="codeph">sqlmonitor.components</code> setting.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.dms</code>: This boolean flag, with a default value of <code class="codeph">true</code>, specifies whether to deliver collected statistics to DMS. This requires a running Oracle Application Server 10<span class="italic">g</span> instance where you can use DMS tools. Statistics can be accessed through a Web browser or written into a file.
                           </p>
                           <div class="infoboxnote" id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7__GUID-0539F721-4034-4FBE-9A24-80C3C9EF7C21">
                              <p class="notep1">Note:</p>
                              <p>A setting of <code class="codeph">sqlmonitor.dms=false</code> is not currently supported.
                              </p>
                           </div>
                           <p>FUTURE (post-10i/10.1): Support for sqlmonitor.dms=false. (Is DMS library still required if sqlmonitor.dms=false?)</p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.sysurl</code>: For server-side tracing, this specifies the database URL.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.sysuser</code>: For server-side tracing, this specifies the database user. This user must have <code class="codeph">sysdba</code> privileges.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.syspassword</code>: For server-side tracing, this specifies the password for the <code class="codeph">sysuser</code>.
                           </p>
                           <div class="infoboxnote" id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7__GUID-38EC633F-2F20-4B73-BC0D-AEA922DA8F1D">
                              <p class="notep1">Note:</p>
                              <p>For <code class="codeph">sysurl</code>, <code class="codeph">sysuser</code>, and <code class="codeph">syspassword</code>, default values are according to the <code class="codeph">user</code>, <code class="codeph">password</code>, and <code class="codeph">url</code> values supplied to SQLJ, either through the SQLJ command line or through the SQLJ properties file.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.servertracing</code>: Use this to enable server-side tracing, to collect performance statistics in the server, such as for SQL operations. Supported settings are <code class="codeph">true</code> or <code class="codeph">false</code> (the default).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.dumpfile</code>: If delivering statistics to DMS, then you can use this option to specify a file into which the DMS tool writes the statistics. The default is <span class="italic"><code class="codeph">application_name</code></span><code class="codeph">.mtr</code>, where <span class="italic"><code class="codeph">application_name</code></span> is according to the <code class="codeph">-instrument</code> option setting (or is <code class="codeph">defaultApp</code> by default).
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ779"></a><div class="props_rev_3"><a id="GUID-994A9604-3FD1-4A2E-9378-4606E1863B33" name="GUID-994A9604-3FD1-4A2E-9378-4606E1863B33"></a><h4 id="JSQLJ-GUID-994A9604-3FD1-4A2E-9378-4606E1863B33" class="sect4">SQLJ DMS Sensors and Metrics</h4>
                  <div>
                     <p>Sensors are used by DMS to calculate performance metrics during the execution of instrumented SQLJ programs and delivered to DMS. They are organized as a hierarchy, with each sensor having a path name. Here are typical sensor formats:</p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/<span class="italic">sensor_name</span>
</pre><p>A sensor is an instance of the <code class="codeph">oracle.dms.instrument.Sensor</code> class, which has methods for calculating and organizing performance statistics. For example, there are methods to instruct the sensor to derive additional metrics and to get the value of one of the metrics.
                     </p>
                     <p>Be aware that before the end of an instrumented application, there must be a call to the <code class="codeph">close()</code> method of the <code class="codeph">oracle.sqlj.runtime.sqlmonitor.SQLMonitor</code> class, such as in the following example (which also uses the <code class="codeph">Oracle</code> class <code class="codeph">close()</code> method to close the connection context):
                     </p><pre class="oac_no_warn" dir="ltr">try
{
   Oracle.close();
   oracle.sqlj.runtime.sqlmonitor.SQLMonitor.close();
} 
catch( Throwable e ) { ... }
</pre><p>Note the following terms:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <span class="italic"><code class="codeph">application_name</code></span> is the name of the application according to the SQLJ <code class="codeph">-instrument</code> option, or <code class="codeph">defaultApp</code> by default.
                           </p>
                        </li>
                        <li>
                           <p>If a sensor is associated with a package, then the item <span class="italic"><code class="codeph">module</code></span> is the package name. The setting <code class="codeph">*TopLevel*</code> is used if the package name is empty.
                           </p>
                        </li>
                        <li>
                           <p>If a sensor is associated with a class, then <span class="italic"><code class="codeph">class</code></span> is the class name.
                           </p>
                        </li>
                        <li>
                           <p>If a sensor is associated with a SQL statement, then <span class="italic"><code class="codeph">linenum</code></span> denotes the line number of the SQL statement in the SQLJ program being instrumented. If multiple SQL statements appear in the same line, then their starting column positions are used to distinguish them. For example, a <span class="italic"><code class="codeph">linenum</code></span> value of 8.13 indicates that 8 is the line number and 13 is the column number.
                           </p>
                        </li>
                     </ul>
                     <p>The following sensors and associated metrics are typically of particular interest:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Sensor name: <code class="codeph">ContextType</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ContextType
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">value</code>: A string indicating the connection context type
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">SQLString</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/SQLString
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">value</code>: A string consisting of the SQL statement
                                 </p>
                                 <p>This is the exact string that is passed to JDBC, including any transformations made from the original <code class="codeph">#sql</code> statement.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">Execute</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/Execute
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">time</code>: The total time, in milliseconds, of all the executions of the JDBC <code class="codeph">execute()</code> method for this statement
                                 </p>
                                 <p>If the statement executes five times, for example, then <code class="codeph">time</code> would be the total time spent in the <code class="codeph">execute()</code> method for the five executions.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">completed</code>: The number of executions completed (such as 5)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">minTime</code>: The shortest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxTime</code>: The longest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">avg</code>: The average execution time, which is <code class="codeph">time</code> divided by <code class="codeph">completed</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">active</code>: The number of threads executing the statement at the end of program execution, typically 0.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxActive</code>: The maximum number of threads that executed the statement during program execution
                                 </p>
                              </li>
                           </ul>
                           <p>To measure the execution time of a JDBC statement, the clock is started immediately before the statement is executed and stopped when a result set is obtained or the statement otherwise finishes executing, or when an exception is caught.</p>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">ServerExecute</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerExecute
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">value</code>: The total execution time in the server, in milliseconds, for all executions of this SQL statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code>: The number of executions completed
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code>: The shortest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code>: The longest time of any single execution
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">ServerFetch</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerFetch
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">value</code>: The total fetch time in the server, in milliseconds, for all executions of this SQL statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code>: The number of executions completed
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code>: The shortest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code>: The longest time of any single execution
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">ServerParse</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerParse
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">value</code>: The total time spent parsing the SQL statement in the server, in milliseconds, for all executions of this SQL statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code>: The number of executions completed
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code>: The shortest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code>: The longest time of any single execution
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sensor name: <code class="codeph">Next</code></p><pre class="oac_no_warn" dir="ltr">/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/Next
</pre><p>Metrics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">time</code>: The total time, in milliseconds, spent in the <code class="codeph">next()</code> method of the result set iterator for all executions of this SQL statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">completed</code>: The number of executions completed (such as 5)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">minTime</code>: The shortest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxTime</code>: The longest time of any single execution
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">avg</code>: The average execution time, which is <code class="codeph">time</code> divided by <code class="codeph">count</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">active</code>: The number of threads executing the statement at the end of program execution, typically 0.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxActive</code>: The maximum number of threads that executed the statement during program execution
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ781"></a><a id="JSQLJ782"></a><a id="JSQLJ783"></a><a id="JSQLJ784"></a><a id="JSQLJ780"></a><div class="props_rev_3"><a id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2" name="GUID-AB176F74-4B1D-478E-A896-99FB750805F2"></a><h4 id="JSQLJ-GUID-AB176F74-4B1D-478E-A896-99FB750805F2" class="sect4">SQLJ DMS Examples</h4>
                  <div>
                     <div class="section">
                        <p>Following is a sample command line (a single wraparound line) to instrument the SQLJ program <code class="codeph">ExprDemo.sqlj</code>:
                        </p><pre class="oac_no_warn" dir="ltr">% sqlj -dir=. -instrument=a.b.c/app -components=all 
       -user=HR -url=jdbc:oracle:oci:@ ExprDemo.sqlj
Password: <span class="italic">password</span>
</pre><div class="infoboxnote" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-88E82C9D-46C6-4E2B-A977-742F2D148C9F">
                           <p class="notep1">Note:</p>
                           <p>Ensure that <code class="codeph">dms.jar</code> is in your classpath.
                           </p>
                        </div>
                        <p>This command results in generation of the following files:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">./a/b/c/ExprDemo.java</code> (due to the <code class="codeph">-dir</code> option setting and because package <code class="codeph">a.b.c</code> is declared in <code class="codeph">ExprDemo.sqlj</code>)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">./a/b/c/app.properties</code> (due to the <code class="codeph">-instrument</code> option setting)
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-4433A73D-AF98-4C06-8259-5EF894333864">Sample SQLJ DMS Properties File</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following is sample content for <code class="codeph">app.properties</code>. This assumes you edited the file after SQLJ created it, given that some of the settings here are nondefault.
                        </p><pre class="oac_no_warn" dir="ltr">sqlmonitor.components=all
sqlmonitor.monitorcomp=all
sqlmonitor.dms=true
sqlmonitor.servertracing=true
sqlmonitor.sysurl=jdbc:oracle:oci:@
sqlmonitor.sysuser=HR
sqlmonitor.syspassword=hr
sqlmonitor.dumpfile=a/b/c/app.mtr
</pre><div class="infoboxnote" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-5224214C-04D9-49FB-B7E1-1B1ABCCAC17D">
                           <p class="notep1">Note:</p>
                           <p>If you run the SQLJ translator again, then <code class="codeph">app.properties</code> is overwritten and you will lose any changes you made.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-F6F65F5E-A897-4EEF-BF8F-562B902F45D9">Sample Statistics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">sqlmonitor.dms=true</code> setting specifies that monitoring statistics are to be delivered to DMS. Given the <code class="codeph">sqlmonitor.dumpfile</code> value, the DMS tool writes the statistics to the <code class="codeph">./a/b/c/app.mtr</code> file when you compile and run the program. 
                        </p>
                        <p>To examine statistics for a particular code sample, here is a segment of <code class="codeph">ExprDemo.sqlj</code>:
                        </p><pre class="oac_no_warn" dir="ltr">     #sql
     {
       DECLARE
         n NUMBER;
         s NUMBER;
       BEGIN
         n := 0;
         s := 0;
         WHILE n &lt; 100 LOOP
           n := n + 1;
           s := s + :IN (indx++);
         END LOOP;
         :OUT total := s;
       END;
     };
</pre><p>And here is a segment of statistics from <code class="codeph">app.mtr</code>, relating to the preceding code example and showing the execution time and server execution times:
                        </p><pre class="oac_no_warn" dir="ltr">       SQLString.value:      DECLARE         n NUMBER;        s NUMBER;
       BEGIN         n :=  0;         s := 0;       WHILE n &lt; 100 LOOP 
             n := n + 1;
             s := s +  :1 ;         
       END LOOP;          :2  := s;       END; statement SQL string
            ServerExecute.maxValue:       20.0 server_execute_time
            ServerExecute.minValue:       20.0 server_execute_time
            ServerExecute.count:  0 ops
            ServerExecute.value:  20.0 server execute time
            ServerFetch.maxValue: 0.0 server_fetch_time
            ServerFetch.minValue: 0.0 server_fetch_time
            ServerFetch.count:    0 ops
            ServerFetch.value:    0.0 server fetch time
            ServerParse.maxValue: 0.0 server_parse_time
            ServerParse.minValue: 0.0 server_parse_time
            ServerParse.count:    0 ops
            ServerParse.value:    0.0 server parse time
           193.5
            ContextType.value:    class sqlj.runtime.ref.DefaultContext
       statement connection context
            Execute.maxActive:    1 threads
            Execute.active:       0 threads
            Execute.avg:  37.0 msecs
            Execute.maxTime:      37 msecs
            Execute.minTime:      37 msecs
            Execute.completed:    1 ops
            Execute.time: 37 msecs
</pre><p>These statistics indicate that the total execution time at the JDBC client was 37 milliseconds (in one execution), while the execution time in the server was 20 milliseconds.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-8802F6C4-6A70-4BAF-BF5F-949C6C7E4662">Sample Statistics for Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ExprDemo.sqlj</code> also defines and executes an iterator type, <code class="codeph">Iter</code>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">   #sql public static iterator Iter(String ename);

      ....

     Iter iter;
     #sql iter = { select first_name from employees};
     while (iter.next())
     {
      System.out.println(iter.ename());
     }
</pre><p>For iterators, DMS collects the execution time for the <code class="codeph">next()</code> operation. Here is a sample DMS result for the iterator type <code class="codeph">Iter</code>:
                        </p><pre class="oac_no_warn" dir="ltr">         Iter
          Next.time:    5 msecs
</pre><p>This shows that the total time spent on the <code class="codeph">next()</code> operation while iterating through the <code class="codeph">Iter</code> instance was 5 milliseconds.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-672B51D7-7549-4FFF-BEEA-8E9E80A655CC">Sample Statistics for Connection Contexts</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">#sql</code> statements in <code class="codeph">ExprDemo.sqlj</code> use the default connection context. For the <code class="codeph">DefaultContext</code> instance used throughout the program, DMS returns the following statistics:
                        </p><pre class="oac_no_warn" dir="ltr">         class_sqlj.runtime.ref.DefaultContext
         StmtCacheSize.value:  5 statement cache size
         StmtsExecuted.count:  7 ops
         StmtsCacheExecuted.count:     7 ops
</pre><p>This shows that the context has a statement cache size of five statements. Altogether, seven SQL statements are executed.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>