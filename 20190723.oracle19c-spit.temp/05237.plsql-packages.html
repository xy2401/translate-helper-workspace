<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <meta name="description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <title>PL/SQL Packages</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database PL/SQL Language Reference ">
      <meta property="og:description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database PL/SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96448-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="plsql-triggers.html" title="Previous" type="text/html">
      <link rel="next" href="plsql-error-handling.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="LNPLS">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-triggers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="plsql-error-handling.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database PL/SQL Language Reference </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL/SQL Packages</li>
            </ol>
            <a id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" name="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0"></a><a id="LNPLS692"></a><a id="LNPLS009"></a>
            
            <h2 id="LNPLS-GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" class="sect2"><span class="enumeration_chapter">10 </span>PL/SQL Packages
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0__GUID-CA5BA22A-6C2D-4D9F-B5EE-32E5D9F30883">Topics</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="plsql-packages.html#GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" title="A package is a schema object that groups logically related PL/SQL types, variables, constants, subprograms, cursors, and exceptions. A package is compiled and stored in the database, where many applications can share its contents.">What is a Package?</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5">Reasons to Use Packages</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">Package Specification</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">Package Body</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">Package Instantiation and Initialization</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="The values of the variables, constants, and cursors that a package declares (in either its specification or body) comprise its package state.">Package State</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="For a SERIALLY_REUSABLE package, the work unit is a server call.">SERIALLY_REUSABLE Packages</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2">Package Writing Guidelines</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97">Package Example</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF">How STANDARD Package Defines the PL/SQL Environment</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS00901"></a><div class="props_rev_3"><a id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" name="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5"></a><h3 id="LNPLS-GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" class="sect3"><span class="enumeration_section">10.1 </span>What is a Package?
               </h3>
               <div>
                  <p>A <span class="bold">package</span> is a schema object that groups logically related PL/SQL types, variables, constants, subprograms, cursors, and exceptions. A package is compiled and stored in the database, where many applications can share its contents.
                  </p>
                  <p>A package always has a <span class="bold">specification</span>, which declares the <span class="bold">public items</span> that can be referenced from outside the package.
                  </p>
                  <p>If the public items include cursors or subprograms, then the package must also have a <span class="bold">body</span>. The body must define queries for public cursors and code for public subprograms. The body can also declare and define <span class="bold">private items</span> that cannot be referenced from outside the package, but are necessary for the internal workings of the package. Finally, the body can have an <span class="bold">initialization part</span>, whose statements initialize variables and do other one-time setup steps, and an exception-handling part. You can change the body without changing the specification or the references to the public items; therefore, you can think of the package body as a black box.
                  </p>
                  <p>In either the package specification or package body, you can map a package subprogram to an external Java or C subprogram by using a <span class="bold">call specification</span>, which maps the external subprogram name, parameter types, and return type to their SQL counterparts. 
                  </p>
                  <p>The <span class="bold"><code class="codeph">AUTHID</code></span> <span class="bold">clause</span> of the package specification determines whether the subprograms and cursors in the package run with the privileges of their definer (the default) or invoker, and whether their unqualified references to schema objects are resolved in the schema of the definer or invoker.
                  </p>
                  <p>The <span class="bold"><code class="codeph">ACCESSIBLE</code></span> <span class="bold"><code class="codeph">BY</code></span> <span class="bold">clause</span> of the package specification lets you specify a white list of PL/SQL units that can access the package. You use this clause in situations like these:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You implement a PL/SQL application as several packages—one package that provides the application programming interface (API) and helper packages to do the work. You want clients to have access to the API, but not to the helper packages. Therefore, you omit the <code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code> clause from the API package specification and include it in each helper package specification, where you specify that only the API package can access the helper package.
                        </p>
                     </li>
                     <li>
                        <p>You create a utility package to provide services to some, but not all, PL/SQL units in the same schema. To restrict use of the package to the intended units, you list them in the <code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code> clause in the package specification.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5__GUID-AAFC67D5-018E-485D-9CE9-D5B557AFF22C">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">Package Specification</a>"</span> for more information about the package specification
                           </p>
                        </li>
                        <li>
                           <p> <span class="q">"<a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">Package Body</a>"</span> for more information about the package body
                           </p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="Before invoking a function, you must declare and define it. You can either declare it first (with function_declaration) and then define it later in the same block, subprogram, or package (with function_definition) or declare and define it at the same time (with function_definition).">Function Declaration and Definition</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="procedure-declaration-and-definition.html#GUID-9A48D7CE-3720-46A4-B5CA-C2250CA86AF2" title="Before invoking a procedure, you must declare and define it. You can either declare it first (with procedure_declaration) and then define it later in the same block, subprogram, or package (with procedure_definition) or declare and define it at the same time (with procedure_definition).">Procedure Declaration and Definition</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="If you include a connected user database link in a DR unit (definer's rights unit), then you must grant the user who will run the DR unit the INHERIT REMOTE PRIVILEGES privilege.">Invoker's Rights and Definer's Rights (AUTHID Property)</a>"</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS00902"></a><div class="props_rev_3"><a id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" name="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5"></a><h3 id="LNPLS-GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" class="sect3"><span class="enumeration_section">10.2 </span>Reasons to Use Packages
               </h3>
               <div>
                  <p>Packages support the development and maintenance of reliable, reusable code with the following features:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="bold">Modularity</span></p>
                        <p>Packages let you encapsulate logically related types, variables, constants, subprograms, cursors, and exceptions in named PL/SQL modules. You can make each package easy to understand, and make the interfaces between packages simple, clear, and well defined. This practice aids application development.</p>
                     </li>
                     <li>
                        <p><span class="bold">Easier Application Design</span></p>
                        <p>When designing an application, all you need initially is the interface information in the package specifications. You can code and compile specifications without their bodies. Next, you can compile standalone subprograms that reference the packages. You need not fully define the package bodies until you are ready to complete the application.</p>
                     </li>
                     <li>
                        <p><span class="bold">Hidden Implementation Details</span></p>
                        <p>Packages let you share your interface information in the package specification, and hide the implementation details in the package body. Hiding the implementation details in the body has these advantages:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can change the implementation details without affecting the application interface.</p>
                           </li>
                           <li>
                              <p>Application users cannot develop code that depends on implementation details that you might want to change.</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p><span class="bold">Added Functionality</span></p>
                        <p>Package public variables and cursors can persist for the life of a session. They can be shared by all subprograms that run in the environment. They let you maintain data across transactions without storing it in the database. (For the situations in which package public variables and cursors do not persist for the life of a session, see <span class="q">"<a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="The values of the variables, constants, and cursors that a package declares (in either its specification or body) comprise its package state.">Package State</a>"</span>.)
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">Better Performance</span></p>
                        <p>The first time you invoke a package subprogram, Oracle Database loads the whole package into memory. Subsequent invocations of other subprograms in same the package require no disk I/O.</p>
                        <p>Packages prevent cascading dependencies and unnecessary recompiling. For example, if you change the body of a package function, Oracle Database does not recompile other subprograms that invoke the function, because these subprograms depend only on the parameters and return value that are declared in the specification.</p>
                     </li>
                     <li>
                        <p><span class="bold">Easier to Grant Roles</span></p>
                        <p>You can grant roles on the package, instead of granting roles on each object in the package.</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5__GUID-57E93D66-5C59-410F-96B1-4726B9A4A9A3">
                     <p class="notep1">Note:</p>
                     <p>You cannot reference host variables from inside a package.</p>
                  </div>
               </div>
            </div><a id="LNPLS694"></a><a id="LNPLS00904"></a><div class="props_rev_3"><a id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7" name="GUID-85E86008-3460-4596-B43A-13D54D6E04C7"></a><h3 id="LNPLS-GUID-85E86008-3460-4596-B43A-13D54D6E04C7" class="sect3"><span class="enumeration_section">10.3 </span>Package Specification
               </h3>
               <div>
                  <p>A <span class="bold">package specification</span> declares <span class="bold">public items</span>. The scope of a public item is the schema of the package. A public item is visible everywhere in the schema. To reference a public item that is in scope but not visible, qualify it with the package name. (For information about scope, visibility, and qualification, see <span class="q">"<a href="plsql-language-fundamentals.html#GUID-2FC17012-FC99-4614-90DD-ADC99F2EDBE9" title="The scope of an identifier is the region of a PL/SQL unit from which you can reference the identifier. The visibility of an identifier is the region of a PL/SQL unit from which you can reference the identifier without qualifying it. An identifier is local to the PL/SQL unit that declares it. If that unit has subunits, the identifier is global to them.">Scope and Visibility of Identifiers</a>"</span>.)
                  </p>
                  <p>Each public item declaration has all information needed to use the item. For example, suppose that a package specification declares the function <code class="codeph">factorial</code> this way:
                  </p><pre class="oac_no_warn" dir="ltr">FUNCTION factorial (n INTEGER) RETURN INTEGER; -- returns n!
</pre><p>The declaration shows that <code class="codeph">factorial</code> needs one argument of type <code class="codeph">INTEGER</code> and returns a value of type <code class="codeph">INTEGER</code>, which is invokers must know to invoke <code class="codeph">factorial</code>. Invokers need not know how <code class="codeph">factorial</code> is implemented (for example, whether it is iterative or recursive).
                  </p>
                  <div class="infoboxnote" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-DEEAEC15-6D37-4052-91AD-095C01B1BCF2">
                     <p class="notep1">Note:</p>
                     <p>To restrict the use of your package to specified PL/SQL units, include the <code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code> clause in the package specification.
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-994130FA-079D-4358-9351-A66991E375FD">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-packages.html#GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D">Appropriate Public Items</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80">Creating Package Specifications</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS00911"></a><div class="props_rev_3"><a id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" name="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D"></a><h4 id="LNPLS-GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" class="sect4"><span class="enumeration_section">10.3.1 </span>Appropriate Public Items
                  </h4>
                  <div>
                     <p>Appropriate public items are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Types, variables, constants, subprograms, cursors, and exceptions used by multiple subprograms</p>
                           <p>A type defined in a package specification is either a PL/SQL user-defined subtype (described in <span class="q">"<a href="plsql-data-types.html#GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" title="PL/SQL lets you define your own subtypes.">User-Defined PL/SQL Subtypes</a>"</span>) or a PL/SQL composite type (described in <a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL/SQL lets you define two kinds of composite data types: collection and record.">PL/SQL Collections and Records</a>).
                           </p>
                           <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-1C153CA6-0861-4FDA-8A8F-07EC4E60C4DA">
                              <p class="notep1">Note:</p>
                              <p>A PL/SQL composite type defined in a package specification is incompatible with an identically defined local or standalone type (see <a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">Example 5-33</a>, <a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">Example 5-34</a>, and <a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">Example 5-39</a>).
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>Associative array types of standalone subprogram parameters</p>
                           <p>You cannot declare an associative array type at schema level. Therefore, to pass an associative array variable as a parameter to a standalone subprogram, you must declare the type of that variable in a package specification. Doing so makes the type available to both the invoked subprogram (which declares a formal parameter of that type) and to the invoking subprogram or anonymous block (which declares a variable of that type). See <a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">Example 10-2</a>.
                           </p>
                        </li>
                        <li>
                           <p>Variables that must remain available between subprogram invocations in the same session</p>
                        </li>
                        <li>
                           <p>Subprograms that read and write public variables ("get" and "set" subprograms)</p>
                           <p>Provide these subprograms to discourage package users from reading and writing public variables directly.</p>
                        </li>
                        <li>
                           <p>Subprograms that invoke each other</p>
                           <p>You need not worry about compilation order for package subprograms, as you must for standalone subprograms that invoke each other.</p>
                        </li>
                        <li>
                           <p>Overloaded subprograms</p>
                           <p>Overloaded subprograms are variations of the same subprogram. That is, they have the same name but different formal parameters. For more information about them, see <span class="q">"<a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">Overloaded Subprograms</a>"</span>.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-DCCE5C66-1170-4A4B-BB1B-97023EB7C547">
                        <p class="notep1">Note:</p>
                        <p>You cannot reference remote package public variables, even indirectly. For example, if a subprogram refers to a package public variable, you cannot invoke the subprogram through a database link.</p>
                     </div>
                  </div>
               </div><a id="LNPLS813"></a><a id="LNPLS720"></a><a id="LNPLS99922"></a><div class="props_rev_3"><a id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" name="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80"></a><h4 id="LNPLS-GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" class="sect4"><span class="enumeration_section">10.3.2 </span>Creating Package Specifications
                  </h4>
                  <div>
                     <div class="section">
                        <p>To create a package specification, use the <span class="q">"<a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="The CREATE PACKAGE statement creates or replaces the specification for a stored package, which is an encapsulated collection of related procedures, functions, and other program objects stored as a unit in the database.">CREATE PACKAGE Statement</a>"</span>.
                        </p>
                        <p>Because the package specifications in <a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">Example 10-1</a> and <a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">Example 10-2</a> do not declare cursors or subprograms, the packages <code class="codeph">trans_data</code> and <code class="codeph">aa_pkg</code> do not need bodies.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">
                        <p class="titleinexample">Example 10-1 Simple Package Specification</p>
                        <p>In this example, the specification for the package <code class="codeph">trans_data</code> declares two public types and three public variables.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE trans_data AUTHID DEFINER AS
  TYPE TimeRec IS RECORD (
    minutes SMALLINT,
    hours   SMALLINT);
  TYPE TransRec IS RECORD (
    category VARCHAR2(10),
    account  INT,
    amount   REAL,
    time_of  TimeRec);
  minimum_balance     CONSTANT REAL := 10.00;
  number_processed    INT;
  insufficient_funds  EXCEPTION;
  PRAGMA EXCEPTION_INIT(insufficient_funds, -4097);
END trans_data;
/
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">
                        <p class="titleinexample">Example 10-2 Passing Associative Array to Standalone Subprogram</p>
                        <p>In this example, the specification for the package <code class="codeph">aa_pkg</code> declares an associative array type, <code class="codeph">aa_type</code>. Then, the standalone procedure <code class="codeph">print_aa</code> declares a formal parameter of type <code class="codeph">aa_type</code>. Next, the anonymous block declares a variable of type <code class="codeph">aa_type</code>, populates it, and passes it to the procedure <code class="codeph">print_aa</code>, which prints it.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE <span class="bold">aa_pkg</span> AUTHID DEFINER IS
  TYPE <span class="bold">aa_type</span> IS TABLE OF INTEGER INDEX BY VARCHAR2(15);
END;
/
CREATE OR REPLACE PROCEDURE print_aa (
  <span class="bold">aa aa_pkg.aa_type</span>
) AUTHID DEFINER IS
  i  VARCHAR2(15);
BEGIN
  i := aa.FIRST;
 
  WHILE i IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE (aa(i) || '  ' || i);
    i := aa.NEXT(i);
  END LOOP;
END;
/
DECLARE
  <span class="bold">aa_var  aa_pkg.aa_type</span>;
BEGIN
  aa_var('zero') := 0;
  aa_var('one') := 1;
  aa_var('two') := 2;
  <span class="bold">print_aa(aa_var)</span>;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">1  one
2  two
0  zero
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS721"></a><a id="LNPLS00905"></a><div class="props_rev_3"><a id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" name="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750"></a><h3 id="LNPLS-GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" class="sect3"><span class="enumeration_section">10.4 </span>Package Body
               </h3>
               <div>
                  <p>If a package specification declares cursors or subprograms, then a package body is required; otherwise, it is optional. The package body and package specification must be in the same schema.</p>
                  <p>Every cursor or subprogram declaration in the package specification must have a corresponding definition in the package body. The headings of corresponding subprogram declarations and definitions must match word for word, except for white space.</p>
                  <p>To create a package body, use the <span class="q">"<a href="CREATE-PACKAGE-BODY-statement.html#GUID-68526FF2-96A1-4F14-A10B-4DD3E1CD80BE" title="The CREATE PACKAGE BODY statement creates or replaces the body of a stored package, which is an encapsulated collection of related procedures, stored functions, and other program objects stored as a unit in the database.">CREATE PACKAGE BODY Statement</a>"</span>.
                  </p>
                  <p>The cursors and subprograms declared in the package specification and defined in the package body are public items that can be referenced from outside the package. The package body can also declare and define <span class="bold">private items</span> that cannot be referenced from outside the package, but are necessary for the internal workings of the package.
                  </p>
                  <p>Finally, the body can have an <span class="bold">initialization part</span>, whose statements initialize public variables and do other one-time setup steps. The initialization part runs only the first time the package is referenced. The initialization part can include an exception handler.
                  </p>
                  <p>You can change the package body without changing the specification or the references to the public items.</p>
                  <div class="example" id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750__CJAGEFEB">
                     <p class="titleinexample">Example 10-3 Matching Package Specification and Body</p>
                     <p>In this example, the headings of the corresponding subprogram declaration and definition do not match word for word; therefore, PL/SQL raises an exception, even though <code class="codeph">employees.hire_date%TYPE</code> is <code class="codeph">DATE</code>.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_bonus AS
  PROCEDURE calc_bonus (date_hired <span class="bold">employees.hire_date%TYPE</span>);
END emp_bonus;
/
CREATE PACKAGE BODY emp_bonus AS
  -- DATE does not match employees.hire_date%TYPE
  PROCEDURE calc_bonus (date_hired <span class="bold">DATE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Warning: Package Body created with compilation errors.
</pre><p>Show errors (in SQL*Plus):</p><pre class="oac_no_warn" dir="ltr">SHOW ERRORS
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Errors for PACKAGE BODY EMP_BONUS:
 
LINE/COL ERROR
-------- -----------------------------------------------------------------
2/13     PLS-00323: subprogram or cursor 'CALC_BONUS' is declared in a
         package specification and must be defined in the package body
</pre><p>Correct problem:</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE BODY emp_bonus AS
  PROCEDURE calc_bonus
    (<span class="bold">date_hired employees.hire_date%TYPE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Package body created.
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS99926"></a><div class="props_rev_3"><a id="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" name="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A"></a><h3 id="LNPLS-GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" class="sect3"><span class="enumeration_section">10.5 </span>Package Instantiation and Initialization
               </h3>
               <div>
                  <p>When a session references a package item, Oracle Database instantiates the package for that session. Every session that references a package has its own instantiation of that package.</p>
                  <p>When Oracle Database instantiates a package, it initializes it. Initialization includes whichever of the following are applicable:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Assigning initial values to public constants</p>
                     </li>
                     <li>
                        <p>Assigning initial values to public variables whose declarations specify them</p>
                     </li>
                     <li>
                        <p>Executing the initialization part of the package body</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS804"></a><div class="props_rev_3"><a id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" name="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4"></a><h3 id="LNPLS-GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" class="sect3"><span class="enumeration_section">10.6 </span>Package State
               </h3>
               <div>
                  <p>The values of the variables, constants, and cursors that a package declares (in either its specification or body) comprise its <strong class="term">package state</strong>.
                  </p>
                  <p> If a PL/SQL package declares at least one variable, constant, or cursor, then the package is <span class="bold">stateful</span>; otherwise, it is <span class="bold">stateless</span>.
                  </p>
                  <p>Each session that references a package item has its own instantiation of that package. If the package is stateful, the instantiation includes its state. </p>
                  <p>The package state persists for the life of a session, except in these situations:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The package is <code class="codeph">SERIALLY_REUSABLE</code>.
                        </p>
                     </li>
                     <li>
                        <p>The package body is recompiled.</p>
                        <p>If the body of an instantiated, stateful package is recompiled (either explicitly, with the <span class="q">"<a href="ALTER-PACKAGE-statement.html#GUID-61273667-8D8F-4E79-9D81-072CFFE3A7F1" title="The ALTER PACKAGE statement explicitly recompiles a package specification, body, or both. Explicit recompilation eliminates the need for implicit runtime recompilation and prevents associated runtime compilation errors and performance overhead.">ALTER PACKAGE Statement</a>"</span>, or implicitly), the next invocation of a subprogram in the package causes Oracle Database to discard the existing package state and raise the exception ORA-04068.
                        </p>
                        <p>After PL/SQL raises the exception, a reference to the package causes Oracle Database to re-instantiate the package, which re-initializes it. Therefore, previous changes to the package state are lost.</p>
                     </li>
                     <li>
                        <p>Any of the session's instantiated packages are invalidated and revalidated.</p>
                        <p>All of a session's package instantiations (including package states) can be lost if any of the session's instantiated packages are invalidated and revalidated. </p>
                     </li>
                  </ul>
                  <p>Oracle Database treats a package as stateless if its state is constant for the life of a session (or longer). This is the case for a package whose items are all compile-time constants.</p>
                  <p>A <span class="bold">compile-time constant</span> is a constant whose value the PL/SQL compiler can determine at compilation time. A constant whose initial value is a literal is always a compile-time constant. A constant whose initial value is not a literal, but which the optimizer reduces to a literal, is also a compile-time constant. Whether the PL/SQL optimizer can reduce a nonliteral expression to a literal depends on optimization level. Therefore, a package that is stateless when compiled at one optimization level might be stateful when compiled at a different optimization level.
                  </p>
                  <div class="infoboxnotealso" id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4__GUID-27A37E69-47C5-41AA-98F7-3D2045845476">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="For a SERIALLY_REUSABLE package, the work unit is a server call.">SERIALLY_REUSABLE Packages</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">Package Instantiation and Initialization</a>"</span> for information about initialization
                           </p>
                        </li>
                        <li>
                           <p><a href="../adfns/schema-object-dependency.html#ADFNS99967" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for information about invalidation and revalidation of schema objects
                           </p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="One optimization that the compiler can perform is subprogram inlining.">PL/SQL Optimizer</a>"</span> for information about the optimizer
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS722"></a><a id="LNPLS99977"></a><div class="props_rev_3"><a id="GUID-001EF960-7491-411B-A5F3-D1260A45794B" name="GUID-001EF960-7491-411B-A5F3-D1260A45794B"></a><h3 id="LNPLS-GUID-001EF960-7491-411B-A5F3-D1260A45794B" class="sect3"><span class="enumeration_section">10.7 </span>SERIALLY_REUSABLE Packages
               </h3>
               <div>
                  <p><code class="codeph">SERIALLY_REUSABLE</code> packages let you design applications that manage memory better for scalability.
                  </p>
                  <p>If a package is not <code class="codeph">SERIALLY_REUSABLE</code>, its package state is stored in the user global area (UGA) for each user. Therefore, the amount of UGA memory needed increases linearly with the number of users, limiting scalability. The package state can persist for the life of a session, locking UGA memory until the session ends. In some applications, such as Oracle Office, a typical session lasts several days.
                  </p>
                  <p>If a package is <code class="codeph">SERIALLY_REUSABLE</code>, its package state is stored in a work area in a small pool in the system global area (SGA). The package state persists only for the life of a server call. After the server call, the work area returns to the pool. If a subsequent server call references the package, then Oracle Database reuses an instantiation from the pool. Reusing an instantiation re-initializes it; therefore, changes made to the package state in previous server calls are invisible. (For information about initialization, see <span class="q">"<a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">Package Instantiation and Initialization</a>"</span>.)
                  </p>
                  <div class="infoboxnote" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-8AA9A74C-FD0E-4762-92C0-56557D80C81A">
                     <p class="notep1">Note:</p>
                     <p>Trying to access a <code class="codeph">SERIALLY_REUSABLE</code> package from a database trigger, or from a PL/SQL subprogram invoked by a SQL statement, raises an error.
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-3F0B0AE1-BEE9-4931-95B6-42397FC196CA">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69">Creating SERIALLY_REUSABLE Packages</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-0881061B-1F72-4F13-8BBA-B0959199851B" title="For a SERIALLY_REUSABLE package, the work unit is a server call.">SERIALLY_REUSABLE Package Work Unit</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19">Explicit Cursors in SERIALLY_REUSABLE Packages</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS810"></a><a id="LNPLS99925"></a><div class="props_rev_3"><a id="GUID-78DA1333-7938-472E-9A67-37C50370AB69" name="GUID-78DA1333-7938-472E-9A67-37C50370AB69"></a><h4 id="LNPLS-GUID-78DA1333-7938-472E-9A67-37C50370AB69" class="sect4"><span class="enumeration_section">10.7.1 </span>Creating SERIALLY_REUSABLE Packages
                  </h4>
                  <div>
                     <div class="section">
                        <p>To create a <code class="codeph">SERIALLY_REUSABLE</code> package, include the <code class="codeph">SERIALLY_REUSABLE</code> pragma in the package specification and, if it exists, the package body.
                        </p>
                        <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">Example 10-4</a> creates two very simple <code class="codeph">SERIALLY_REUSABLE</code> packages, one with only a specification, and one with both a specification and a body.
                        </p>
                        <div class="infoboxnotealso" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__GUID-E8D82F0C-DEFA-41DF-800D-524D392C7F3C">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="SERIALLY_REUSABLE-pragma.html#GUID-35B02603-B794-403C-9E0D-E40208CEAF35" title="The SERIALLY_REUSABLE pragma specifies that the package state is needed for only one call to the server (for example, an OCI call to the database or a stored procedure invocation through a database link).">SERIALLY_REUSABLE Pragma</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">
                        <p class="titleinexample">Example 10-4 Creating SERIALLY_REUSABLE Packages</p><pre class="oac_no_warn" dir="ltr"><span class="bold">-- Create bodiless SERIALLY_REUSABLE package:</span>
 
CREATE OR REPLACE PACKAGE bodiless_pkg AUTHID DEFINER IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
<span class="bold">-- Create SERIALLY_REUSABLE package with specification and body:</span>
 
CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
CREATE OR REPLACE PACKAGE BODY pkg IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
BEGIN
  n := 5;
END;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS809"></a><a id="LNPLS99924"></a><div class="props_rev_3"><a id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B" name="GUID-0881061B-1F72-4F13-8BBA-B0959199851B"></a><h4 id="LNPLS-GUID-0881061B-1F72-4F13-8BBA-B0959199851B" class="sect4"><span class="enumeration_section">10.7.2 </span>SERIALLY_REUSABLE Package Work Unit
                  </h4>
                  <div>
                     <p>For a <code class="codeph">SERIALLY_REUSABLE</code> package, the work unit is a server call. 
                     </p>
                     <p>You must use its public variables only within the work unit.</p>
                     <div class="infoboxnote" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__GUID-57B4ECE9-9259-4880-A05C-C8E8E0E9532F">
                        <p class="notep1">Note:</p>
                        <p>If you make a mistake and depend on the value of a public variable that was set in a previous work unit, then your program can fail. PL/SQL cannot check for such cases.</p>
                     </div>
                     <p>After the work unit (server call) of a <code class="codeph">SERIALLY_REUSABLE</code> package completes, Oracle Database does the following:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Closes any open cursors.</p>
                        </li>
                        <li>
                           <p>Frees some nonreusable memory (for example, memory for collection and long <code class="codeph">VARCHAR2</code> variables)
                           </p>
                        </li>
                        <li>
                           <p>Returns the package instantiation to the pool of reusable instantiations kept for this package.</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__BABFAFDC">
                        <p class="titleinexample">Example 10-5 Effect of SERIALLY_REUSABLE Pragma</p>
                        <p>In this example, the bodiless packages <code class="codeph">pkg</code> and <code class="codeph">sr_pkg</code> are the same, except that <code class="codeph">sr_pkg</code> is <code class="codeph">SERIALLY_REUSABLE</code> and <code class="codeph">pkg</code> is not. Each package declares public variable <code class="codeph">n</code> with initial value 5. Then, an anonymous block changes the value of each variable to 10. Next, another anonymous block prints the value of each variable. The value of <code class="codeph">pkg</code>.<code class="codeph">n</code> is still 10, because the state of <code class="codeph">pkg</code> persists for the life of the session. The value of <code class="codeph">sr_pkg</code>.<code class="codeph">n</code> is 5, because the state of <code class="codeph">sr_pkg</code> persists only for the life of the server call.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE <span class="bold">PACKAGE pkg</span> IS
  n NUMBER := 5;
END pkg;
/

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END sr_pkg;
/

BEGIN
  pkg.n := 10;
  sr_pkg.n := 10;
END;
/

BEGIN
  DBMS_OUTPUT.PUT_LINE('pkg.n: ' || pkg.n);
  DBMS_OUTPUT.PUT_LINE('sr_pkg.n: ' || sr_pkg.n);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">pkg.n: 10</span>
<span class="bold">sr_pkg.n: 5</span>
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS811"></a><a id="LNPLS99923"></a><div class="props_rev_3"><a id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" name="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19"></a><h4 id="LNPLS-GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" class="sect4"><span class="enumeration_section">10.7.3 </span>Explicit Cursors in SERIALLY_REUSABLE Packages
                  </h4>
                  <div>
                     <p>An explicit cursor in a <code class="codeph">SERIALLY_REUSABLE</code> package remains open until either you close it or its work unit (server call) ends. To re-open the cursor, you must make a new server call. A server call can be different from a subprogram invocation, as <a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">Example 10-6</a> shows.
                     </p>
                     <p>In contrast, an explicit cursor in a package that is not <code class="codeph">SERIALLY_REUSABLE</code> remains open until you either close it or disconnect from the session.
                     </p>
                     <div class="example" id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">
                        <p class="titleinexample">Example 10-6 Cursor in SERIALLY_REUSABLE Package Open at Call Boundary</p><pre class="oac_no_warn" dir="ltr">DROP TABLE people;
CREATE TABLE people (name VARCHAR2(20));
 
INSERT INTO people (name) VALUES ('John Smith');
INSERT INTO people (name) VALUES ('Mary Jones');
INSERT INTO people (name) VALUES ('Joe Brown');
INSERT INTO people (name) VALUES ('Jane White');

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  <span class="bold">CURSOR c</span> IS SELECT name FROM people;
END sr_pkg;
/
 
CREATE OR REPLACE PROCEDURE fetch_from_cursor IS
  v_name  people.name%TYPE;
BEGIN
  IF sr_pkg.c%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor is open.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Cursor is closed; opening now.');
    OPEN sr_pkg.c;
  END IF;
 
  FETCH sr_pkg.c INTO v_name;
  DBMS_OUTPUT.PUT_LINE('Fetched: ' || v_name);
 
  FETCH sr_pkg.c INTO v_name;
    DBMS_OUTPUT.PUT_LINE('Fetched: ' || v_name);
  END fetch_from_cursor;
/
 </pre><p>First call to server:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White
 </pre><p>New call to server:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS826"></a><a id="LNPLS1996"></a><a id="LNPLS00909"></a><div class="props_rev_3"><a id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" name="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2"></a><h3 id="LNPLS-GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" class="sect3"><span class="enumeration_section">10.8 </span>Package Writing Guidelines
               </h3>
               <div>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Become familiar with the packages that Oracle Database supplies, and avoid writing packages that duplicate their features.</p>
                        <p>For more information about the packages that Oracle Database supplies, see <a href="../arpls/introduction-to-oracle-supplied-plsql-packages-and-types.html#ARPLS-GUID-4AA6AA30-CAEE-4DCD-B214-9AD51D0229B4" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.
                        </p>
                     </li>
                     <li>
                        <p>Keep your packages general so that future applications can reuse them.</p>
                     </li>
                     <li>
                        <p>Design and define the package specifications before the package bodies.</p>
                     </li>
                     <li>
                        <p>In package specifications, declare only items that must be visible to invoking programs.</p>
                        <p>This practice prevents other developers from building unsafe dependencies on your implementation details and reduces the need for recompilation.</p>
                        <p>If you change the package specification, you must recompile any subprograms that invoke the public subprograms of the package. If you change only the package body, you need not recompile those subprograms.</p>
                     </li>
                     <li>
                        <p>Declare public cursors in package specifications and define them in package bodies, as in <a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">Example 10-7</a>.
                        </p>
                        <p>This practice lets you hide cursors' queries from package users and change them without changing cursor declarations.</p>
                     </li>
                     <li>
                        <p>Assign initial values in the initialization part of the package body instead of in declarations.</p>
                        <p>This practice has these advantages:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The code for computing the initial values can be more complex and better documented.</p>
                           </li>
                           <li>
                              <p>If computing an initial value raises an exception, the initialization part can handle it with its own exception handler.</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>If you implement a database application as several PL/SQL packages—one package that provides the API and helper packages to do the work, then make the helper packages available only to the API package, as in <a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">Example 10-8</a>.
                        </p>
                     </li>
                  </ul>
                  <p>In <a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">Example 10-7</a>, the declaration and definition of the cursor <code class="codeph">c1</code> are in the specification and body, respectively, of the package <code class="codeph">emp_stuff</code>. The cursor declaration specifies only the data type of the return value, not the query, which appears in the cursor definition (for complete syntax and semantics, see <span class="q">"<a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="An explicit cursor is a named pointer to a private SQL area that stores information for processing a specific query or DML statement—typically, one that returns or affects multiple rows.">Explicit Cursor Declaration and Definition</a>"</span>).
                  </p>
                  <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">Example 10-8</a> creates an API package and a helper package. Because of the <code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code> clause in the helper package specification, only the API package can access the helper package.
                  </p>
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">
                     <p class="titleinexample">Example 10-7 Separating Cursor Declaration and Definition in Package</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE;  -- Declare cursor</span>
END emp_stuff;
/
CREATE PACKAGE BODY emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE IS</span>
    <span class="bold">SELECT * FROM employees WHERE salary &gt; 2500;  -- Define cursor</span>
END emp_stuff;
/
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">
                     <p class="titleinexample">Example 10-8 ACCESSIBLE BY Clause</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE helper
  AUTHID DEFINER
  <span class="bold">ACCESSIBLE BY (api)</span>
IS
  PROCEDURE h1;
  PROCEDURE h2;
END;
/
 
CREATE OR REPLACE PACKAGE BODY helper
IS
  PROCEDURE h1 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Helper procedure h1');
  END;
 
  PROCEDURE h2 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Helper procedure h2');
  END;
END;
/
 
CREATE OR REPLACE PACKAGE api
  AUTHID DEFINER
IS
  PROCEDURE p1;
  PROCEDURE p2;
END;
/
 
CREATE OR REPLACE PACKAGE BODY api
IS
  PROCEDURE p1 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('API procedure p1');
    helper.h1;
  END;
 
  PROCEDURE p2 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('API procedure p2');
    helper.h2;
  END;
END;
/
 </pre><p>Invoke procedures in API package:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  api.p1;
  api.p2;
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">API procedure p1
Helper procedure h1
API procedure p2
Helper procedure h2
</pre><p>Invoke a procedure in helper package:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  helper.h1;
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; BEGIN
  2    helper.h1;
  3  END;
  4  /
  helper.h1;
  *
ERROR at line 2:
ORA-06550: line 2, column 3:
<span class="bold">PLS-00904: insufficient privilege to access object HELPER</span>
ORA-06550: line 2, column 3:
PL/SQL: Statement ignored</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS816"></a><a id="LNPLS00906"></a><div class="props_rev_3"><a id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" name="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97"></a><h3 id="LNPLS-GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" class="sect3"><span class="enumeration_section">10.9 </span>Package Example
               </h3>
               <div>
                  <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">Example 10-9</a> creates a table, <code class="codeph">log</code>, and a package, <code class="codeph">emp_admin</code>, and then invokes package subprograms from an anonymous block. The package has both specification and body.
                  </p>
                  <p>The specification declares a public type, cursor, and exception, and three public subprograms. One public subprogram is overloaded (for information about overloaded subprograms, see <span class="q">"<a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">Overloaded Subprograms</a>"</span>).
                  </p>
                  <p>The body declares a private variable, defines the public cursor and subprograms that the specification declares, declares and defines a private function, and has an initialization part.</p>
                  <p>The initialization part (which runs only the first time the anonymous block references the package) inserts one row into the table <code class="codeph">log</code> and initializes the private variable <code class="codeph">number_hired</code> to zero. Every time the package procedure <code class="codeph">hire_employee</code> is invoked, it updates the private variable <code class="codeph">number_hired</code>.
                  </p>
                  <div class="example" id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">
                     <p class="titleinexample">Example 10-9 Creating emp_admin Package</p><pre class="oac_no_warn" dir="ltr"><span class="bold">-- Log to track changes (not part of package):</span>

DROP TABLE log;
CREATE TABLE log (
  date_of_action  DATE,
  user_id         VARCHAR2(20),
  package_name    VARCHAR2(30)
);

<span class="bold">-- Package specification:</span>

CREATE OR REPLACE PACKAGE emp_admin AUTHID DEFINER AS
  <span class="bold">-- Declare public type, cursor, and exception:</span>
  TYPE EmpRecTyp IS RECORD (emp_id NUMBER, sal NUMBER);
  CURSOR desc_salary RETURN EmpRecTyp;
  invalid_salary EXCEPTION;

  <span class="bold">-- Declare public subprograms:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER;

  <span class="bold">-- Overload preceding public subprogram:</span>
  PROCEDURE fire_employee (emp_id NUMBER);
  PROCEDURE fire_employee (emp_email VARCHAR2);

  PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER);
  FUNCTION nth_highest_salary (n NUMBER) RETURN EmpRecTyp;
END emp_admin;
/
<span class="bold">-- Package body:</span>

CREATE OR REPLACE PACKAGE BODY emp_admin AS
  number_hired  NUMBER;  <span class="bold">-- private variable, visible only in this package</span>

  <span class="bold">-- Define cursor declared in package specification:</span>

  CURSOR desc_salary RETURN EmpRecTyp IS
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC;

  <span class="bold">-- Define subprograms declared in package specification:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER
  IS
    new_emp_id NUMBER;
  BEGIN
    new_emp_id := employees_seq.NEXTVAL;
    INSERT INTO employees (
      employee_id,
      last_name,
      first_name,
      email,
      phone_number,
      hire_date,
      job_id,
      salary,
      commission_pct,
      manager_id,
      department_id
    )
    VALUES (
      new_emp_id,
      hire_employee.last_name,
      hire_employee.first_name,
      hire_employee.email,
      hire_employee.phone_number,
      SYSDATE,
      hire_employee.job_id,
      hire_employee.salary,
      hire_employee.commission_pct,
      hire_employee.manager_id,
      hire_employee.department_id
    );
    number_hired := number_hired + 1;
    DBMS_OUTPUT.PUT_LINE('The number of employees hired is ' 
                         || TO_CHAR(number_hired) );   
    RETURN new_emp_id;
  END hire_employee;

  PROCEDURE fire_employee (emp_id NUMBER) IS
  BEGIN
    DELETE FROM employees WHERE employee_id = emp_id;
  END fire_employee;

  PROCEDURE fire_employee (emp_email VARCHAR2) IS
  BEGIN
    DELETE FROM employees WHERE email = emp_email;
  END fire_employee;

  <span class="bold">-- Define private function, available only inside package:</span>

  FUNCTION sal_ok (
    jobid VARCHAR2,
    sal NUMBER
  ) RETURN BOOLEAN
  IS
    min_sal NUMBER;
    max_sal NUMBER;
  BEGIN
    SELECT MIN(salary), MAX(salary)
    INTO min_sal, max_sal
    FROM employees
    WHERE job_id = jobid;

    RETURN (sal &gt;= min_sal) AND (sal &lt;= max_sal);
  END sal_ok;

  PROCEDURE raise_salary (
    emp_id NUMBER,
    amount NUMBER
  )
  IS
    sal NUMBER(8,2);
    jobid VARCHAR2(10);
  BEGIN
    SELECT job_id, salary INTO jobid, sal
    FROM employees
    WHERE employee_id = emp_id;

    IF <span class="bold">sal_ok(jobid, sal + amount)</span> THEN  <span class="bold">-- Invoke private function</span>
      UPDATE employees
      SET salary = salary + amount
      WHERE employee_id = emp_id;
    ELSE
      RAISE invalid_salary;
    END IF;
  EXCEPTION
    WHEN invalid_salary THEN
      DBMS_OUTPUT.PUT_LINE ('The salary is out of the specified range.');
  END raise_salary;

  FUNCTION nth_highest_salary (
    n NUMBER
  ) RETURN EmpRecTyp
  IS
    emp_rec  EmpRecTyp;
  BEGIN
    OPEN desc_salary;
    FOR i IN 1..n LOOP
      FETCH desc_salary INTO emp_rec;
    END LOOP;
    CLOSE desc_salary;
    RETURN emp_rec;
  END nth_highest_salary;

BEGIN  <span class="bold">-- initialization part of package body</span>
   INSERT INTO log (date_of_action, user_id, package_name)
   VALUES (SYSDATE, USER, 'EMP_ADMIN');
   number_hired := 0;
END emp_admin;
/
<span class="bold">-- Invoke packages subprograms in anonymous block:</span>

DECLARE
  new_emp_id NUMBER(6);
BEGIN
  new_emp_id := <span class="bold">emp_admin.hire_employee</span> (
    'Belden',
    'Enrique',
    'EBELDEN',
    '555.111.2222',
    'ST_CLERK',
    2500,
    .1,
    101,
    110
  );
  DBMS_OUTPUT.PUT_LINE ('The employee id is ' || TO_CHAR(new_emp_id));
  <span class="bold">emp_admin.raise_salary</span> (new_emp_id, 100);

  DBMS_OUTPUT.PUT_LINE (
    'The 10th highest salary is '||
    TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).sal</span>) ||
             ', belonging to employee: ' ||
             TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).emp_id</span>)
  );

  <span class="bold">emp_admin.fire_employee(new_emp_id)</span>;
  -- You can also delete the newly added employee as follows:
  -- <span class="bold">emp_admin.fire_employee('EBELDEN')</span>;
END;
/
</pre><p>Result is similar to:</p><pre class="oac_no_warn" dir="ltr">The number of employees hired is 1
The employee id is 210
The 10th highest salary is 11500, belonging to employee: 168</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS00907"></a><div class="props_rev_3"><a id="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" name="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF"></a><h3 id="LNPLS-GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" class="sect3"><span class="enumeration_section">10.10 </span>How STANDARD Package Defines the PL/SQL Environment
               </h3>
               <div>
                  <p>A package named <code class="codeph">STANDARD</code> defines the PL/SQL environment. The package specification declares public types, variables, exceptions, subprograms, which are available automatically to PL/SQL programs. For example, package <code class="codeph">STANDARD</code> declares function <code class="codeph">ABS</code>, which returns the absolute value of its argument, as follows:
                  </p><pre class="oac_no_warn" dir="ltr">FUNCTION ABS (n NUMBER) RETURN NUMBER;
</pre><p>The contents of package <code class="codeph">STANDARD</code> are directly visible to applications. You need not qualify references to its contents by prefixing the package name. For example, you might invoke <code class="codeph">ABS</code> from a database trigger, stored subprogram, Oracle tool, or 3GL application, as follows:
                  </p><pre class="oac_no_warn" dir="ltr">abs_diff := ABS(x - y);
</pre><p>If you declare your own version of <code class="codeph">ABS</code>, your local declaration overrides the public declaration. You can still invoke the SQL function by specifying its full name:
                  </p><pre class="oac_no_warn" dir="ltr">abs_diff := STANDARD.ABS(x - y);
</pre><p>Most SQL functions are overloaded. For example, package <code class="codeph">STANDARD</code> contains these declarations:
                  </p><pre class="oac_no_warn" dir="ltr">FUNCTION TO_CHAR (right DATE) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER) RETURN VARCHAR2;
FUNCTION TO_CHAR (left DATE, right VARCHAR2) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER, right VARCHAR2) RETURN VARCHAR2;
</pre><p>PL/SQL resolves an invocation of <code class="codeph">TO_CHAR</code> by matching the number and data types of the formal and actual parameters.
                  </p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>