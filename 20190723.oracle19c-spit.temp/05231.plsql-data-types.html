<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Every PL/SQL constant, variable, parameter, and function return value has a data type that determines its storage format and its valid values and operations.">
      <meta name="description" content="Every PL/SQL constant, variable, parameter, and function return value has a data type that determines its storage format and its valid values and operations.">
      <title>PL/SQL Data Types</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database PL/SQL Language Reference ">
      <meta property="og:description" content="Every PL/SQL constant, variable, parameter, and function return value has a data type that determines its storage format and its valid values and operations.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database PL/SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96448-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="plsql-language-fundamentals.html" title="Previous" type="text/html">
      <link rel="next" href="plsql-control-statements.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="LNPLS">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-language-fundamentals.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="plsql-control-statements.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database PL/SQL Language Reference </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL/SQL Data Types</li>
            </ol>
            <a id="GUID-391C58FD-16AF-486C-AF28-173E309CDBA5" name="GUID-391C58FD-16AF-486C-AF28-173E309CDBA5"></a><a id="LNPLS283"></a><a id="LNPLS003"></a>
            
            <h2 id="LNPLS-GUID-391C58FD-16AF-486C-AF28-173E309CDBA5" class="sect2"><span class="enumeration_chapter">3 </span>PL/SQL Data Types
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='plsql-data-types'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>Every PL/SQL constant, variable, parameter, and function return value has a <span class="bold">data type</span> that determines its storage format and its valid values and operations.
               </p>
               <p>This chapter explains <span class="bold">scalar data types</span>, which store values with no internal components. 
               </p>
               <p>A scalar data type can have subtypes. A <span class="bold">subtype</span> is a data type that is a subset of another data type, which is its <span class="bold">base type</span>. A subtype has the same valid operations as its base type. A data type and its subtypes comprise a <span class="bold">data type family</span>.
               </p>
               <p>PL/SQL predefines many types and subtypes in the package <code class="codeph">STANDARD</code> and lets you define your own subtypes.
               </p>
               <p>The PL/SQL scalar data types are:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>The SQL data types</p>
                  </li>
                  <li>
                     <p><code class="codeph">BOOLEAN</code></p>
                  </li>
                  <li>
                     <p><code class="codeph">PLS_INTEGER</code></p>
                  </li>
                  <li>
                     <p><code class="codeph">BINARY_INTEGER</code></p>
                  </li>
                  <li>
                     <p><code class="codeph">REF</code> <code class="codeph">CURSOR</code></p>
                  </li>
                  <li>
                     <p>User-defined subtypes</p>
                  </li>
               </ul>
               <div class="section">
                  <p class="subhead1" id="GUID-391C58FD-16AF-486C-AF28-173E309CDBA5__GUID-8655FDCD-B723-4494-A164-D7A434746C4B">Topics</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="plsql-data-types.html#GUID-239A89A6-4CBC-46F5-8A6A-10E8B465B7E8" title="The PL/SQL data types include the SQL data types.">SQL Data Types</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-data-types.html#GUID-02AEA63C-9A27-43F4-80B7-4781343445D0" title="The PL/SQL data type BOOLEAN stores logical values, which are the boolean values TRUE and FALSE and the value NULL. NULL represents an unknown value.">BOOLEAN Data Type</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" title="The PL/SQL data types PLS_INTEGER and BINARY_INTEGER are identical.">PLS_INTEGER and BINARY_INTEGER Data Types</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-data-types.html#GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" title="SIMPLE_INTEGER is a predefined subtype of the PLS_INTEGER data type.">SIMPLE_INTEGER Subtype of PLS_INTEGER</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-data-types.html#GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" title="PL/SQL lets you define your own subtypes.">User-Defined PL/SQL Subtypes</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-391C58FD-16AF-486C-AF28-173E309CDBA5__GUID-10A6FF0B-092D-457A-9CF1-9B9889862FB3">
                  <p class="notep1">See Also:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="q">"<a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL/SQL lets you define two kinds of composite data types: collection and record.">PL/SQL Collections and Records</a>"</span> for information about <span class="bold">composite data types</span></p>
                     </li>
                     <li>
                        <p><span class="q">"<a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a>"</span> for information about <code class="codeph">REF</code> <code class="codeph">CURSOR</code></p>
                     </li>
                     <li>
                        <p><span class="q">"<a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="The CREATE TYPE statement specifies the name of the type and its attributes, methods, and other properties.">CREATE TYPE Statement</a>"</span> for information about creating schema-level user-defined data types
                        </p>
                     </li>
                     <li>
                        <p><span class="q">"<a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL/SQL Predefined Data Types</a>"</span> for the predefined PL/SQL data types and subtypes, grouped by data type family
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS286"></a><div class="props_rev_3"><a id="GUID-239A89A6-4CBC-46F5-8A6A-10E8B465B7E8" name="GUID-239A89A6-4CBC-46F5-8A6A-10E8B465B7E8"></a><h3 id="LNPLS-GUID-239A89A6-4CBC-46F5-8A6A-10E8B465B7E8" class="sect3"><span class="enumeration_section">3.1 </span>SQL Data Types
               </h3>
               <div>
                  <p>The PL/SQL data types include the SQL data types.</p>
                  <p>For information about the SQL data types, see <a href="../sqlrf/Basic-Elements-of-Oracle-SQL.html#SQLRF002" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>—all information there about data types and subtypes, data type comparison rules, data conversion, literals, and format models applies to both SQL and PL/SQL, except as noted here:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="plsql-data-types.html#GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0">Different Maximum Sizes</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-data-types.html#GUID-9410B67C-0E65-45BE-9376-0BD97E39D678">Additional PL/SQL Constants for BINARY_FLOAT and BINARY_DOUBLE</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-data-types.html#GUID-48101DAA-B168-4648-A05A-CA81A9512E8C">Additional PL/SQL Subtypes of BINARY_FLOAT and BINARY_DOUBLE</a></p>
                     </li>
                  </ul>
                  <p>Unlike SQL, PL/SQL lets you declare variables, to which the following topics apply:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="plsql-data-types.html#GUID-43BB16CE-9D77-419B-ACE9-32D8A91B3D43" title="This explains the differences and considerations of using blank-padding with CHAR and VARCHAR2.The SQL rules for comparing character values apply to PL/SQL character variables.">CHAR and VARCHAR2 Variables</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-data-types.html#GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9">LONG and LONG RAW Variables</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-data-types.html#GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650">ROWID and UROWID Variables</a></p>
                     </li>
                  </ul>
               </div><a id="LNPLS2172"></a><a id="LNPLS99943"></a><div class="props_rev_3"><a id="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0" name="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0"></a><h4 id="LNPLS-GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0" class="sect4"><span class="enumeration_section">3.1.1 </span>Different Maximum Sizes
                  </h4>
                  <div>
                     <p>The SQL data types listed in <a href="plsql-data-types.html#GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAHEEJF" title="This table has three columns. The first column lists the predefined SQL data types that have different maximum values in PL/SQL and SQL, the second column gives their maximum sizes in PL/SQL, and the third column gives their maximum values in SQL.">Table 3-1</a> have different maximum sizes in PL/SQL and SQL.
                     </p>
                     <div class="tblformal" id="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAHEEJF">
                        <p class="titleintable">Table 3-1 Data Types with Different Maximum Sizes in PL/SQL and SQL</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Data Types with Different Maximum Sizes in PL/SQL and SQL" summary="This table has three columns. The first column lists the predefined SQL data types that have different maximum values in PL/SQL and SQL, the second column gives their maximum sizes in PL/SQL, and the third column gives their maximum values in SQL." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d27514e500">Data Type</th>
                                 <th align="left" valign="bottom" width="32%" id="d27514e503">Maximum Size in PL/SQL</th>
                                 <th align="left" valign="bottom" width="48%" id="d27514e506">Maximum Size in SQL</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e511" headers="d27514e500 ">
                                    <p><code class="codeph">CHAR</code><a id="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJADBCHJ" name="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJADBCHJ" href="#GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJADBCHJ" onclick="footdisplay(1, "When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.")"><sup>Foot&nbsp;1</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e511 d27514e503 ">
                                    <p>32,767 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e511 d27514e506 ">
                                    <p>2,000 bytes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e525" headers="d27514e500 ">
                                    <p><code class="codeph">NCHAR</code><a id="fnsrc_d27514e529" name="fnsrc_d27514e529" href="#fnsrc_d27514e529" onclick="footdisplay(1, "When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.")"><sup>Footref&nbsp;1</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e525 d27514e503 ">
                                    <p>32,767 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e525 d27514e506 ">
                                    <p>2,000 bytes</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e538" headers="d27514e500 ">
                                    <p><code class="codeph">RAW</code><a id="fnsrc_d27514e542" name="fnsrc_d27514e542" href="#fnsrc_d27514e542" onclick="footdisplay(1, "When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.")"><sup>Footref&nbsp;1</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e538 d27514e503 ">
                                    <p>32,767 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e538 d27514e506 ">
                                    <p>2,000 bytes<a id="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAGGFGH" name="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAGGFGH" href="#GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAGGFGH" onclick="footdisplay(2, "To eliminate this size difference, follow the instructions in Oracle Database SQL Language Reference.")"><sup>Foot&nbsp;2</sup></a></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e559" headers="d27514e500 ">
                                    <p><code class="codeph">VARCHAR2</code><a id="fnsrc_d27514e563" name="fnsrc_d27514e563" href="#fnsrc_d27514e563" onclick="footdisplay(1, "When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.")"><sup>Footref&nbsp;1</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e559 d27514e503 ">
                                    <p>32,767 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e559 d27514e506 ">
                                    <p>4,000 bytes<a id="fnsrc_d27514e571" name="fnsrc_d27514e571" href="#fnsrc_d27514e571" onclick="footdisplay(2, "To eliminate this size difference, follow the instructions in Oracle Database SQL Language Reference.")"><sup>Footref&nbsp;2</sup></a></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e574" headers="d27514e500 ">
                                    <p><code class="codeph">NVARCHAR2</code><a id="fnsrc_d27514e578" name="fnsrc_d27514e578" href="#fnsrc_d27514e578" onclick="footdisplay(1, "When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.")"><sup>Footref&nbsp;1</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e574 d27514e503 ">
                                    <p>32,767 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e574 d27514e506 ">
                                    <p>4,000 bytes<a id="fnsrc_d27514e586" name="fnsrc_d27514e586" href="#fnsrc_d27514e586" onclick="footdisplay(2, "To eliminate this size difference, follow the instructions in Oracle Database SQL Language Reference.")"><sup>Footref&nbsp;2</sup></a></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e589" headers="d27514e500 ">
                                    <p><code class="codeph">LONG</code><a id="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAFECGG" name="GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAFECGG" href="#GUID-C3B938C9-7B0B-4AAC-8323-FEB2ED0225D0__CJAFECGG" onclick="footdisplay(3, "Supported only for backward compatibility with existing applications.")"><sup>Foot&nbsp;3</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e589 d27514e503 ">
                                    <p>32,760 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e589 d27514e506 ">
                                    <p>2 gigabytes (GB) - 1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e603" headers="d27514e500 ">
                                    <p><code class="codeph">LONG</code> <code class="codeph">RAW</code><a id="fnsrc_d27514e610" name="fnsrc_d27514e610" href="#fnsrc_d27514e610" onclick="footdisplay(3, "Supported only for backward compatibility with existing applications.")"><sup>Footref&nbsp;3</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e603 d27514e503 ">
                                    <p>32,760 bytes</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e603 d27514e506 ">
                                    <p>2 GB</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e619" headers="d27514e500 ">
                                    <p><code class="codeph">BLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e619 d27514e503 ">
                                    <p>128 terabytes (TB)</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e619 d27514e506 ">
                                    <p>(4 GB - 1) * <span class="italic"><code class="codeph">database_block_size</code></span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e633" headers="d27514e500 ">
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e633 d27514e503 ">
                                    <p>128 TB</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e633 d27514e506 ">
                                    <p>(4 GB - 1) * <span class="italic"><code class="codeph">database_block_size</code></span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d27514e647" headers="d27514e500 ">
                                    <p><code class="codeph">NCLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d27514e647 d27514e503 ">
                                    <p>128 TB</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d27514e647 d27514e506 ">
                                    <p>(4 GB - 1) * <span class="italic"><code class="codeph">database_block_size</code></span></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1 </sup></p><p>When specifying the maximum size of a value of this data type in PL/SQL, use an integer literal (not a constant or variable) whose value is in the range from 1 through 32,767.</p>
                     <p></p>
                     <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2 </sup></p><p>To eliminate this size difference, follow the instructions in <a href="../sqlrf/Data-Types.html#SQLRF55623" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                        </p>
                     <p></p>
                     <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3 </sup></p><p>Supported only for backward compatibility with existing applications.</p>
                     <p></p>
                  </div>
               </div><a id="LNPLS327"></a><a id="LNPLS326"></a><div class="props_rev_3"><a id="GUID-9410B67C-0E65-45BE-9376-0BD97E39D678" name="GUID-9410B67C-0E65-45BE-9376-0BD97E39D678"></a><h4 id="LNPLS-GUID-9410B67C-0E65-45BE-9376-0BD97E39D678" class="sect4"><span class="enumeration_section">3.1.2 </span>Additional PL/SQL Constants for BINARY_FLOAT and BINARY_DOUBLE
                  </h4>
                  <div>
                     <p>The SQL data types <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> represent single-precision and double-precision IEEE 754-format floating-point numbers, respectively.
                     </p>
                     <p><code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> computations do not raise exceptions, so you must check the values that they produce for conditions such as overflow and underflow by comparing them to predefined constants (for examples, see <a href="../sqlrf/Literals.html#SQLRF51060" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>). PL/SQL has more of these constants than SQL does.
                     </p>
                     <p><a href="plsql-data-types.html#GUID-9410B67C-0E65-45BE-9376-0BD97E39D678__CIHHEAFG" title="This table summarizes the predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE constants (with asterisks indicating which constants SQL also defines).">Table 3-2</a> lists and describes the predefined PL/SQL constants for <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code>, and identifies those that SQL also defines.
                     </p>
                     <div class="tblformal" id="GUID-9410B67C-0E65-45BE-9376-0BD97E39D678__CIHHEAFG">
                        <p class="titleintable">Table 3-2 Predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE Constants</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE Constants" summary="This table summarizes the predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE constants (with asterisks indicating which constants SQL also defines)." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="41%" id="d27514e794">Constant</th>
                                 <th align="left" valign="bottom" width="59%" id="d27514e797">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e802" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_NAN</code> (*)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e802 d27514e797 ">
                                    <p><code class="codeph">BINARY_FLOAT</code> value for which the condition <code class="codeph">IS</code> <code class="codeph">NAN</code> (not a number) is true
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e819" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_INFINITY</code> (*)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e819 d27514e797 ">
                                    <p>Single-precision positive infinity</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e828" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_MAX_NORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e828 d27514e797 ">
                                    <p>Maximum normal <code class="codeph">BINARY_FLOAT</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e839" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_MIN_NORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e839 d27514e797 ">
                                    <p>Minimum normal <code class="codeph">BINARY_FLOAT</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e850" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_MAX_SUBNORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e850 d27514e797 ">
                                    <p>Maximum subnormal <code class="codeph">BINARY_FLOAT</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e861" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_FLOAT_MIN_SUBNORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e861 d27514e797 ">
                                    <p>Minimum subnormal <code class="codeph">BINARY_FLOAT</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e872" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_NAN</code> (*)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e872 d27514e797 ">
                                    <p><code class="codeph">BINARY_DOUBLE</code> value for which the condition <code class="codeph">IS</code> <code class="codeph">NAN</code> (not a number) is true
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e889" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_INFINITY</code> (*)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e889 d27514e797 ">
                                    <p>Double-precision positive infinity</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e898" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_MAX_NORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e898 d27514e797 ">
                                    <p>Maximum normal <code class="codeph">BINARY_DOUBLE</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e909" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_MIN_NORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e909 d27514e797 ">
                                    <p>Minimum normal <code class="codeph">BINARY_DOUBLE</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e920" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_MAX_SUBNORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e920 d27514e797 ">
                                    <p>Maximum subnormal <code class="codeph">BINARY_DOUBLE</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d27514e932" headers="d27514e794 ">
                                    <p><code class="codeph">BINARY_DOUBLE_MIN_SUBNORMAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d27514e932 d27514e797 ">
                                    <p>Minimum subnormal <code class="codeph">BINARY_DOUBLE</code> value
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p id="GUID-9410B67C-0E65-45BE-9376-0BD97E39D678__SQLALSOPREDEFINESTHISCONSTANT.-5C523FE8">(*) SQL also predefines this constant.</p>
                  </div>
               </div><a id="LNPLS99942"></a><div class="props_rev_3"><a id="GUID-48101DAA-B168-4648-A05A-CA81A9512E8C" name="GUID-48101DAA-B168-4648-A05A-CA81A9512E8C"></a><h4 id="LNPLS-GUID-48101DAA-B168-4648-A05A-CA81A9512E8C" class="sect4"><span class="enumeration_section">3.1.3 </span>Additional PL/SQL Subtypes of BINARY_FLOAT and BINARY_DOUBLE
                  </h4>
                  <div>
                     <p>PL/SQL predefines these subtypes:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">SIMPLE_FLOAT</code>, a subtype of SQL data type <code class="codeph">BINARY_FLOAT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SIMPLE_DOUBLE</code>, a subtype of SQL data type <code class="codeph">BINARY_DOUBLE</code></p>
                        </li>
                     </ul>
                     <p>Each subtype has the same range as its base type and has a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint (explained in <span class="q">"<a href="plsql-language-fundamentals.html#GUID-6705CC7D-470A-4B4A-BCAD-6843F227C012" title="You can impose the NOT NULL constraint on a scalar variable or constant (or scalar component of a composite variable or constant).">NOT NULL Constraint</a>"</span>).
                     </p>
                     <p>If you know that a variable will never have the value <code class="codeph">NULL</code>, declare it as <code class="codeph">SIMPLE_FLOAT</code> or <code class="codeph">SIMPLE_DOUBLE</code>, rather than <code class="codeph">BINARY_FLOAT</code> or <code class="codeph">BINARY_DOUBLE</code>. Without the overhead of checking for nullness, the subtypes provide significantly better performance than their base types. The performance improvement is greater with <code class="codeph">PLSQL_CODE_TYPE='NATIVE'</code> than with <code class="codeph">PLSQL_CODE_TYPE='INTERPRETED'</code> (for more information, see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0">Use Data Types that Use Hardware Arithmetic</a>"</span>).
                     </p>
                  </div>
               </div><a id="LNPLS288"></a><a id="LNPLS332"></a><div class="props_rev_3"><a id="GUID-43BB16CE-9D77-419B-ACE9-32D8A91B3D43" name="GUID-43BB16CE-9D77-419B-ACE9-32D8A91B3D43"></a><h4 id="LNPLS-GUID-43BB16CE-9D77-419B-ACE9-32D8A91B3D43" class="sect4"><span class="enumeration_section">3.1.4 </span>CHAR and VARCHAR2 Variables
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-43BB16CE-9D77-419B-ACE9-32D8A91B3D43__GUID-04046E77-E6A6-434F-828C-040EAA5A96BE">Topics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-data-types.html#GUID-FB44B23B-0F5C-4507-AC5C-17D29339BD8A">Assigning or Inserting Too-Long Values</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-042904FC-F495-45D1-BF3F-17378D397C00">Declaring Variables for Multibyte Characters</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-7D0D76A5-D921-4823-91F5-FC9887598795" title="This explains the differences and considerations of using blank-padding with CHAR and VARCHAR2.The SQL rules for comparing character values apply to PL/SQL character variables.">Differences Between CHAR and VARCHAR2 Data Types</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS99941"></a><div class="props_rev_3"><a id="GUID-FB44B23B-0F5C-4507-AC5C-17D29339BD8A" name="GUID-FB44B23B-0F5C-4507-AC5C-17D29339BD8A"></a><h5 id="LNPLS-GUID-FB44B23B-0F5C-4507-AC5C-17D29339BD8A" class="sect5"><span class="enumeration_section">3.1.4.1 </span>Assigning or Inserting Too-Long Values
                     </h5>
                     <div>
                        <div class="section">
                           <p>If the value that you assign to a character variable is longer than the maximum size of the variable, an error occurs. For example:</p><pre class="oac_no_warn" dir="ltr">DECLARE
  c VARCHAR2(<span class="bold">3 CHAR</span>);
BEGIN
  c := <span class="bold">'abc  '</span>;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
<span class="bold">ORA-06502: PL/SQL: numeric or value error: character string buffer too small</span>
<span class="bold">ORA-06512: at line 4</span>
</pre><p>Similarly, if you insert a character variable into a column, and the value of the variable is longer than the defined width of the column, an error occurs. For example:</p><pre class="oac_no_warn" dir="ltr">DROP TABLE t;
CREATE TABLE t (c CHAR(<span class="bold">3 CHAR</span>));
 
DECLARE
  <span class="bold">s VARCHAR2(5 CHAR) := 'abc  '</span>;
BEGIN
  INSERT INTO t(c) VALUES(<span class="bold">s</span>);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">BEGIN
*
ERROR at line 1:
<span class="bold">ORA-12899: value too large for column "HR"."T"."C" (actual: 5, maximum: 3)</span>
<span class="bold">ORA-06512: at line 4</span>
</pre><p>To strip trailing blanks from a character value before assigning it to a variable or inserting it into a column, use the <code class="codeph">RTRIM</code> function, explained in <a href="../sqlrf/RTRIM.html#SQLRF06104" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>. For example:
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE
  c VARCHAR2(3 CHAR);
BEGIN
  c := <span class="bold">RTRIM('abc  ')</span>;
  INSERT INTO t(c) VALUES(<span class="bold">RTRIM('abc  ')</span>);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">PL/SQL procedure successfully completed.</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS99940"></a><div class="props_rev_3"><a id="GUID-042904FC-F495-45D1-BF3F-17378D397C00" name="GUID-042904FC-F495-45D1-BF3F-17378D397C00"></a><h5 id="LNPLS-GUID-042904FC-F495-45D1-BF3F-17378D397C00" class="sect5"><span class="enumeration_section">3.1.4.2 </span>Declaring Variables for Multibyte Characters
                     </h5>
                     <div>
                        <div class="section">
                           <p>The maximum <span class="italic">size</span> of a <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code> variable is 32,767 bytes, whether you specify the maximum size in characters or bytes. The maximum <span class="italic">number of characters</span> in the variable depends on the character set type and sometimes on the characters themselves:
                           </p>
                           <div class="tblformal" id="GUID-042904FC-F495-45D1-BF3F-17378D397C00__GUID-751238CD-9C01-42A4-A1A9-90ED5EC43C85">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="The left column lists the types of character sets and the right column lists the maximum number of characters that the character set type can have." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="40%" id="d27514e1456">Character Set Type</th>
                                       <th align="left" valign="bottom" width="60%" id="d27514e1459">Maximum Number of Characters</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d27514e1464" headers="d27514e1456 ">
                                          <p>Single-byte character set</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d27514e1464 d27514e1459 ">
                                          <p>32,767</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d27514e1471" headers="d27514e1456 ">
                                          <p><span class="italic">n</span>-byte fixed-width multibyte character set (for example, AL16UTF16)
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d27514e1471 d27514e1459 ">
                                          <p><code class="codeph">FLOOR(32,767/</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code></p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d27514e1486" headers="d27514e1456 ">
                                          <p><span class="italic">n</span>-byte variable-width multibyte character set with character widths between 1 and <span class="italic">n</span> bytes (for example, JA16SJIS or AL32UTF8)
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d27514e1486 d27514e1459 ">
                                          <p>Depends on characters themselves—can be anything from 32,767 (for a string containing only 1-byte characters) through <code class="codeph">FLOOR(32,767/</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> (for a string containing only <span class="italic">n</span>-byte characters).
                                          </p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>When declaring a <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code> variable, to ensure that it can always hold <span class="italic">n</span> characters in any multibyte character set, declare its length in characters—that is, <code class="codeph">CHAR(</code><span class="italic"><code class="codeph">n</code></span> <code class="codeph">CHAR)</code> or <code class="codeph">VARCHAR2(</code><span class="italic"><code class="codeph">n</code></span> <code class="codeph">CHAR)</code>, where <span class="italic">n</span> does not exceed <code class="codeph">FLOOR(32767/4)</code> = 8191.
                           </p>
                           <div class="infoboxnotealso" id="GUID-042904FC-F495-45D1-BF3F-17378D397C00__GUID-19106AF6-B38A-4D94-9974-6069A994C9A8">
                              <p class="notep1">See Also:</p>
                              <p><a href="../nlspg/overview-of-globalization-support.html#NLSPG153" target="_blank"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about Oracle Database character set support
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS99939"></a><div class="props_rev_3"><a id="GUID-7D0D76A5-D921-4823-91F5-FC9887598795" name="GUID-7D0D76A5-D921-4823-91F5-FC9887598795"></a><h5 id="LNPLS-GUID-7D0D76A5-D921-4823-91F5-FC9887598795" class="sect5"><span class="enumeration_section">3.1.4.3 </span>Differences Between CHAR and VARCHAR2 Data Types
                     </h5>
                     <div>
                        <p><code class="codeph">CHAR</code> and <code class="codeph">VARCHAR2</code> data types differ in:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-data-types.html#GUID-6E2DB5F5-FB20-456D-9861-B0846207F53C">Predefined Subtypes</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-91989965-9087-4091-8B37-01E025E33FD7" title="This explains the differences and considerations of using blank-padding with CHAR and VARCHAR2.">How Blank-Padding Works</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-624E93C5-2115-44FB-9F75-F5513FD25204" title="The SQL rules for comparing character values apply to PL/SQL character variables.">Value Comparisons</a></p>
                           </li>
                        </ul>
                     </div><a id="LNPLS333"></a><div class="props_rev_3"><a id="GUID-6E2DB5F5-FB20-456D-9861-B0846207F53C" name="GUID-6E2DB5F5-FB20-456D-9861-B0846207F53C"></a><h6 id="LNPLS-GUID-6E2DB5F5-FB20-456D-9861-B0846207F53C" class="sect6"><span class="enumeration_section">3.1.4.3.1 </span>Predefined Subtypes
                        </h6>
                        <div>
                           <p>The <code class="codeph">CHAR</code> data type has one predefined subtype in both PL/SQL and SQL—<code class="codeph">CHARACTER</code>.
                           </p>
                           <p>The <code class="codeph">VARCHAR2</code> data type has one predefined subtype in both PL/SQL and SQL, <code class="codeph">VARCHAR</code>, and an additional predefined subtype in PL/SQL, <code class="codeph">STRING</code>.
                           </p>
                           <p>Each subtype has the same range of values as its base type.</p>
                           <div class="infoboxnote" id="GUID-6E2DB5F5-FB20-456D-9861-B0846207F53C__GUID-821BD336-F10E-4F22-9B99-A45CF44A7AF8">
                              <p class="notep1">Note:</p>
                              <p>In a future PL/SQL release, to accommodate emerging SQL standards, <code class="codeph">VARCHAR</code> might become a separate data type, no longer synonymous with <code class="codeph">VARCHAR2</code>.
                              </p>
                           </div>
                        </div>
                     </div><a id="LNPLS289"></a><a id="LNPLS335"></a><div class="props_rev_3"><a id="GUID-91989965-9087-4091-8B37-01E025E33FD7" name="GUID-91989965-9087-4091-8B37-01E025E33FD7"></a><h6 id="LNPLS-GUID-91989965-9087-4091-8B37-01E025E33FD7" class="sect6"><span class="enumeration_section">3.1.4.3.2 </span>How Blank-Padding Works
                        </h6>
                        <div>
                           <p>This explains the differences and considerations of using  blank-padding with CHAR and VARCHAR2.</p>
                           <p>Consider these situations:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The value that you assign to a variable is shorter than the maximum size of the variable.</p>
                              </li>
                              <li>
                                 <p>The value that you insert into a column is shorter than the defined width of the column.</p>
                              </li>
                              <li>
                                 <p>The value that you retrieve from a column into a variable is shorter than the maximum size of the variable.</p>
                              </li>
                           </ul>
                           <p>If the data type of the receiver is <code class="codeph">CHAR</code>, PL/SQL blank-pads the value to the maximum size. Information about trailing blanks in the original value is lost.
                           </p>
                           <p>If the data type of the receiver is <code class="codeph">VARCHAR2</code>, PL/SQL neither blank-pads the value nor strips trailing blanks. Character values are assigned intact, and no information is lost.
                           </p>
                           <div class="example" id="GUID-91989965-9087-4091-8B37-01E025E33FD7__CHDBABGF">
                              <p class="titleinexample">Example 3-1 CHAR and VARCHAR2 Blank-Padding Difference</p>
                              <p>In this example, both the <code class="codeph">CHAR</code> variable and the <code class="codeph">VARCHAR2</code> variable have the maximum size of 10 characters. Each variable receives a five-character value with one trailing blank. The value assigned to the <code class="codeph">CHAR</code> variable is blank-padded to 10 characters, and you cannot tell that one of the six trailing blanks in the resulting value was in the original value. The value assigned to the <code class="codeph">VARCHAR2</code> variable is not changed, and you can see that it has one trailing blank.
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE
  first_name  CHAR(10 CHAR);
  last_name   VARCHAR2(10 CHAR);
BEGIN
  first_name := 'John ';
  last_name  := 'Chen ';
 
  DBMS_OUTPUT.PUT_LINE('*' || first_name || '*');
  DBMS_OUTPUT.PUT_LINE('*' || last_name || '*');
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">*John      *
*Chen *</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS336"></a><div class="props_rev_3"><a id="GUID-624E93C5-2115-44FB-9F75-F5513FD25204" name="GUID-624E93C5-2115-44FB-9F75-F5513FD25204"></a><h6 id="LNPLS-GUID-624E93C5-2115-44FB-9F75-F5513FD25204" class="sect6"><span class="enumeration_section">3.1.4.3.3 </span>Value Comparisons
                        </h6>
                        <div>
                           <p>The SQL rules for comparing character values apply to PL/SQL character variables. </p>
                           <p>Whenever one or both values in the comparison have the data type <code class="codeph">VARCHAR2</code> or <code class="codeph">NVARCHAR2</code>, nonpadded comparison semantics apply; otherwise, blank-padded semantics apply. For more information, see <a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51040" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPLS346"></a><div class="props_rev_3"><a id="GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9" name="GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9"></a><h4 id="LNPLS-GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9" class="sect4"><span class="enumeration_section">3.1.5 </span>LONG and LONG RAW Variables
                  </h4>
                  <div>
                     <div class="infoboxnote" id="GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9__GUID-7F06927A-56ED-4AEC-94F7-419D3CE6D474">
                        <p class="notep1">Note:</p>
                        <p>Oracle supports the <code class="codeph">LONG</code> and <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types only for backward compatibility with existing applications. For new applications:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Instead of <code class="codeph">LONG</code>, use <code class="codeph">VARCHAR2(32760)</code>, <code class="codeph">BLOB</code>, <code class="codeph">CLOB</code> or <code class="codeph">NCLOB</code>.
                              </p>
                           </li>
                           <li>
                              <p>Instead of <code class="codeph">LONG</code> <code class="codeph">RAW</code>, use <code class="codeph">BLOB</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>You can insert any <code class="codeph">LONG</code> value into a <code class="codeph">LONG</code> column. You can insert any <code class="codeph">LONG</code> <code class="codeph">RAW</code> value into a <code class="codeph">LONG</code> <code class="codeph">RAW</code> column. You cannot retrieve a value longer than 32,760 bytes from a <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> column into a <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> variable.
                     </p>
                     <p>You can insert any <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code> value into a <code class="codeph">LONG</code> column. You cannot retrieve a value longer than 32,767 bytes from a <code class="codeph">LONG</code> column into a <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code> variable.
                     </p>
                     <p>You can insert any <code class="codeph">RAW</code> value into a <code class="codeph">LONG</code> <code class="codeph">RAW</code> column. You cannot retrieve a value longer than 32,767 bytes from a <code class="codeph">LONG</code> <code class="codeph">RAW</code> column into a <code class="codeph">RAW</code> variable.
                     </p>
                     <div class="infoboxnotealso" id="GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9__GUID-BF1DF5EB-DC4B-4165-80E0-126E49F9C2F9">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="plsql-triggers.html#GUID-CC076546-C00D-4CC6-A664-82CCE4F64533">Trigger LONG and LONG RAW Data Type Restrictions</a>"</span> for restrictions on <code class="codeph">LONG</code> and <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types in triggers
                        </p>
                     </div>
                  </div>
               </div><a id="LNPLS347"></a><div class="props_rev_3"><a id="GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650" name="GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650"></a><h4 id="LNPLS-GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650" class="sect4"><span class="enumeration_section">3.1.6 </span>ROWID and UROWID Variables
                  </h4>
                  <div>
                     <p>When you retrieve a rowid into a <code class="codeph">ROWID</code> variable, use the <code class="codeph">ROWIDTOCHAR</code> function to convert the binary value to a character value. For information about this function, see <a href="../sqlrf/ROWIDTOCHAR.html#SQLRF06101" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                     </p>
                     <p>To convert the value of a <code class="codeph">ROWID</code> variable to a rowid, use the <code class="codeph">CHARTOROWID</code> function, explained in <a href="../sqlrf/CHARTOROWID.html#SQLRF00615" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>. If the value does not represent a valid rowid, PL/SQL raises the predefined exception <code class="codeph">SYS_INVALID_ROWID</code>.
                     </p>
                     <p>To retrieve a rowid into a <code class="codeph">UROWID</code> variable, or to convert the value of a <code class="codeph">UROWID</code> variable to a rowid, use an assignment statement; conversion is implicit.
                     </p>
                     <div class="infoboxnote" id="GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650__GUID-20833E69-059E-4F40-8B7A-0D522C52D5D6">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">UROWID</code> is a more versatile data type than <code class="codeph">ROWID</code>, because it is compatible with both logical and physical rowids.
                              </p>
                           </li>
                           <li>
                              <p>When you update a row in a table compressed with Hybrid Columnar Compression (HCC), the <code class="codeph">ROWID</code> of the row changes. HCC, a feature of certain Oracle storage systems, is described in <a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle Database Concepts</span></a>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-378DD770-A137-44F7-9F0C-C4AB9A5E1650__GUID-4B362DDB-EF06-4519-8551-C58CF805E1AE">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/DBMS_ROWID.html#ARPLS053" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code class="codeph">DBMS_ROWID</code> package, whose subprograms let you create and return information about <code class="codeph">ROWID</code> values (but not <code class="codeph">UROWID</code> values)
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS290"></a><a id="LNPLS518"></a><a id="LNPLS348"></a><div class="props_rev_3"><a id="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0" name="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0"></a><h3 id="LNPLS-GUID-02AEA63C-9A27-43F4-80B7-4781343445D0" class="sect3"><span class="enumeration_section">3.2 </span>BOOLEAN Data Type
               </h3>
               <div>
                  <p>The PL/SQL data type <code class="codeph">BOOLEAN</code> stores <span class="bold">logical values</span>, which are the boolean values <code class="codeph">TRUE</code> and <code class="codeph">FALSE</code> and the value <code class="codeph">NULL</code>. <code class="codeph">NULL</code> represents an unknown value.
                  </p>
                  <p>The syntax for declaring an <code class="codeph">BOOLEAN</code> variable is:
                  </p><pre class="oac_no_warn" dir="ltr"><span class="italic">variable_name</span> BOOLEAN
</pre><p>The only value that you can assign to a <code class="codeph">BOOLEAN</code> variable is a <code class="codeph">BOOLEAN</code> expression. For details, see <span class="q">"<a href="plsql-language-fundamentals.html#GUID-E277B6FF-866F-486A-BCB1-58235C0AFC69" title="A BOOLEAN expression is an expression that returns a BOOLEAN value—TRUE, FALSE, or NULL.">BOOLEAN Expressions</a>"</span>.
                  </p>
                  <p>Because SQL has no data type equivalent to <code class="codeph">BOOLEAN</code>, you cannot:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Assign a <code class="codeph">BOOLEAN</code> value to a database table column
                        </p>
                     </li>
                     <li>
                        <p>Select or fetch the value of a database table column into a <code class="codeph">BOOLEAN</code> variable
                        </p>
                     </li>
                     <li>
                        <p>Use a <code class="codeph">BOOLEAN</code> value in a SQL function
                        </p>
                        <p>(However, a SQL query can invoke a PL/SQL function that has a <code class="codeph">BOOLEAN</code> parameter, as in <span class="q">"<a href="plsql-data-types.html#GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__CJAJAJIC">Example 3-3</a>"</span>.)
                        </p>
                     </li>
                     <li>
                        <p>Use a <code class="codeph">BOOLEAN</code> expression in a SQL statement, except as an argument to a PL/SQL function invoked in a SQL query, or in a PL/SQL anonymous block.
                        </p>
                        <div class="infoboxnote" id="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__GUID-768CF4E6-867D-4EF2-97D3-021CCDD30F47">
                           <p class="notep1">Note:</p>
                           <p>An argument to a PL/SQL function invoked in a static SQL query cannot be a <code class="codeph">BOOLEAN</code> literal. The workaround is to assign the literal to a variable and then pass the variable to the function, as in <span class="q">"<a href="plsql-data-types.html#GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__CJAJAJIC">Example 3-3</a>"</span>.
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>You cannot pass a <code class="codeph">BOOLEAN</code> value to the <code class="codeph">DBMS_OUTPUT</code>.<code class="codeph">PUT</code> or <code class="codeph">DBMS_OUTPUT</code>.<code class="codeph">PUTLINE</code> subprogram. To print a <code class="codeph">BOOLEAN</code> value, use an <code class="codeph">IF</code> or <code class="codeph">CASE</code> statement to translate it to a character value (for information about these statements, see <span class="q">"<a href="plsql-control-statements.html#GUID-B7DD4E62-3ED2-41E9-AAE5-90A78788BB31" title="The conditional selection statements, IF and CASE, run different statements for different data values.">Conditional Selection Statements</a>"</span>).
                  </p>
                  <div class="example" id="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__CHDHDHHA">
                     <p class="titleinexample">Example 3-2 Printing BOOLEAN Values</p>
                     <p>In this example, the procedure accepts a <code class="codeph">BOOLEAN</code> parameter and uses a <code class="codeph">CASE</code> statement to print <code class="codeph">Unknown</code> if the value of the parameter is <code class="codeph">NULL</code>, <code class="codeph">Yes</code> if it is <code class="codeph">TRUE</code>, and <code class="codeph">No</code> if it is <code class="codeph">FALSE</code>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__GUID-95CBF1E9-1457-458C-A0D7-84E772F30FDE">
                        <p class="notep1">See Also:</p>
                        <p><a href="plsql-language-fundamentals.html#GUID-9D19FEBB-A397-47F5-A4EC-D71B0DE91738__CIHDAFEJ">Example 2-34</a>, which creates a <code class="codeph">print_boolean</code> procedure that uses an <code class="codeph">IF</code> statement.
                        </p>
                     </div><pre class="oac_no_warn" dir="ltr">PROCEDURE print_boolean (b BOOLEAN)
AS
BEGIN
  DBMS_OUTPUT.PUT_LINE (
    CASE
      WHEN b IS NULL THEN 'Unknown'
      WHEN b THEN 'Yes'
      WHEN NOT b THEN 'No'
    END
  );
END;

BEGIN
  print_boolean(TRUE);
  print_boolean(FALSE);
  print_boolean(NULL);
END;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Yes
No
Unknown</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-02AEA63C-9A27-43F4-80B7-4781343445D0__CJAJAJIC">
                     <p class="titleinexample">Example 3-3 SQL Statement Invokes PL/SQL Function with BOOLEAN Parameter</p>
                     <p>In this example, a SQL statement invokes a PL/SQL function that has a <code class="codeph">BOOLEAN</code> parameter.
                     </p><pre class="oac_no_warn" dir="ltr">FUNCTION f (<span class="bold">x BOOLEAN</span>, y PLS_INTEGER)
  RETURN employees.employee_id%TYPE
  AUTHID CURRENT_USER AS
BEGIN
  IF x THEN
    RETURN y;
  ELSE
    RETURN 2*y;
  END IF;
END;
 
DECLARE
  name employees.last_name%TYPE;
  <span class="bold">b BOOLEAN := TRUE;</span>
BEGIN
  SELECT last_name INTO name
  FROM employees
  WHERE employee_id = <span class="bold">f(b, 100)</span>;
 
  DBMS_OUTPUT.PUT_LINE(name);
 
  <span class="bold">b := FALSE;</span>
 
  SELECT last_name INTO name
  FROM employees
  WHERE employee_id = <span class="bold">f(b, 100)</span>;
 
  DBMS_OUTPUT.PUT_LINE(name);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">King
Whalen</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS291"></a><a id="LNPLS319"></a><div class="props_rev_3"><a id="GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" name="GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F"></a><h3 id="LNPLS-GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" class="sect3"><span class="enumeration_section">3.3 </span>PLS_INTEGER and BINARY_INTEGER Data Types
               </h3>
               <div>
                  <p>The PL/SQL data types <code class="codeph">PLS_INTEGER</code> and <code class="codeph">BINARY_INTEGER</code> are identical. 
                  </p>
                  <p>For simplicity, this document uses <code class="codeph">PLS_INTEGER</code> to mean both <code class="codeph">PLS_INTEGER</code> and <code class="codeph">BINARY_INTEGER</code>.
                  </p>
                  <p>The <code class="codeph">PLS_INTEGER</code> data type stores signed integers in the range -2,147,483,648 through 2,147,483,647, represented in 32 bits.
                  </p>
                  <p>The <code class="codeph">PLS_INTEGER</code> data type has these advantages over the <code class="codeph">NUMBER</code> data type and <code class="codeph">NUMBER</code> subtypes:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">PLS_INTEGER</code> values require less storage.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">PLS_INTEGER</code> operations use hardware arithmetic, so they are faster than <code class="codeph">NUMBER</code> operations, which use library arithmetic.
                        </p>
                     </li>
                  </ul>
                  <p>For efficiency, use <code class="codeph">PLS_INTEGER</code> values for all calculations in its range.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F__GUID-4E80819D-0420-48DE-A9A7-649BC0C6DA3B">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-data-types.html#GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965" title="A calculation with two PLS_INTEGER values that overflows the PLS_INTEGER range raises an overflow exception.">Preventing PLS_INTEGER Overflow</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-data-types.html#GUID-00859F04-85FC-422D-B35B-93F5B5F4B912" title="This summary lists the predefined subtypes of the PLS_INTEGER data type and describes the data they store.">Predefined PLS_INTEGER Subtypes</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-data-types.html#GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" title="SIMPLE_INTEGER is a predefined subtype of the PLS_INTEGER data type.">SIMPLE_INTEGER Subtype of PLS_INTEGER</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS292"></a><a id="LNPLS293"></a><a id="LNPLS99938"></a><div class="props_rev_3"><a id="GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965" name="GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965"></a><h4 id="LNPLS-GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965" class="sect4"><span class="enumeration_section">3.3.1 </span>Preventing PLS_INTEGER Overflow
                  </h4>
                  <div>
                     <p>A calculation with two <code class="codeph">PLS_INTEGER</code> values that overflows the <code class="codeph">PLS_INTEGER</code> range raises an overflow exception.
                     </p>
                     <div class="section">
                        <p>For calculations outside the <code class="codeph">PLS_INTEGER</code> range, use <code class="codeph">INTEGER</code>, a predefined subtype of the <code class="codeph">NUMBER</code> data type.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965__CHDDIAEG">
                        <p class="titleinexample">Example 3-4 PLS_INTEGER Calculation Raises Overflow Exception</p>
                        <p>This example shows that a calculation with two <code class="codeph">PLS_INTEGER</code> values that overflows the <code class="codeph">PLS_INTEGER</code> range raises an overflow exception, even if you assign the result to a <code class="codeph">NUMBER</code> data type.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  p1 PLS_INTEGER := 2147483647;
  p2 PLS_INTEGER := 1;
  n NUMBER;
BEGIN
  n := p1 + p2;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
<span class="bold">ORA-01426: numeric overflow</span>
ORA-06512: at line 6</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965__CHDEDAGD">
                        <p class="titleinexample">Example 3-5 Preventing <span><a href="plsql-data-types.html#GUID-EC45A8BA-1D95-4A36-AE06-6F1E77EC4965__CHDDIAEG">Example 3-4</a></span> Overflow
                        </p>
                        <p> This example shows the correct use of the <code class="codeph">INTEGER</code> predefined subtype for calculations outside the <code class="codeph">PLS_INTEGER</code> range.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  p1 PLS_INTEGER := 2147483647;
  p2 <span class="bold">INTEGER</span> := 1;
  n NUMBER;
BEGIN
  n := p1 + p2;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">PL/SQL procedure successfully completed.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS309"></a><a id="LNPLS311"></a><a id="LNPLS99937"></a><div class="props_rev_3"><a id="GUID-00859F04-85FC-422D-B35B-93F5B5F4B912" name="GUID-00859F04-85FC-422D-B35B-93F5B5F4B912"></a><h4 id="LNPLS-GUID-00859F04-85FC-422D-B35B-93F5B5F4B912" class="sect4"><span class="enumeration_section">3.3.2 </span>Predefined PLS_INTEGER Subtypes
                  </h4>
                  <div>
                     <p>This summary lists the predefined subtypes of the <code class="codeph">PLS_INTEGER</code> data type and describes the data they store.
                     </p>
                     <div class="tblformal" id="GUID-00859F04-85FC-422D-B35B-93F5B5F4B912__CHDDFGFG">
                        <p class="titleintable">Table 3-3 Predefined Subtypes of PLS_INTEGER Data Type</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Predefined Subtypes of PLS_INTEGER Data Type" summary="This table summarizes the predefined subtypes of the PLS_INTEGER datatype." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="22%" id="d27514e3109">Data Type</th>
                                 <th align="left" valign="bottom" width="78%" id="d27514e3112">Data Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3117" headers="d27514e3109 ">
                                    <p><code class="codeph">NATURAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3117 d27514e3112 ">
                                    <p>Nonnegative <code class="codeph">PLS_INTEGER</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3128" headers="d27514e3109 ">
                                    <p><code class="codeph">NATURALN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3128 d27514e3112 ">
                                    <p>Nonnegative <code class="codeph">PLS_INTEGER</code> value with <code class="codeph">NOT NULL</code> constraint
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3142" headers="d27514e3109 ">
                                    <p><code class="codeph">POSITIVE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3142 d27514e3112 ">
                                    <p>Positive <code class="codeph">PLS_INTEGER</code> value
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3153" headers="d27514e3109 ">
                                    <p><code class="codeph">POSITIVEN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3153 d27514e3112 ">
                                    <p>Positive <code class="codeph">PLS_INTEGER</code> value with <code class="codeph">NOT NULL</code> constraint
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3167" headers="d27514e3109 ">
                                    <p><code class="codeph">SIGNTYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3167 d27514e3112 ">
                                    <p><code class="codeph">PLS_INTEGER</code> value -1, 0, or 1 (useful for programming tri-state logic)
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d27514e3177" headers="d27514e3109 ">
                                    <p><code class="codeph">SIMPLE_INTEGER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d27514e3177 d27514e3112 ">
                                    <p><code class="codeph">PLS_INTEGER</code> value with <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint. 
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><code class="codeph">PLS_INTEGER</code> and its subtypes can be implicitly converted to these data types:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">CHAR</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">VARCHAR2</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">NUMBER</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">LONG</code></p>
                        </li>
                     </ul>
                     <p>All of the preceding data types except <code class="codeph">LONG</code>, and all <code class="codeph">PLS_INTEGER</code> subtypes, can be implicitly converted to <code class="codeph">PLS_INTEGER</code>.
                     </p>
                     <p>A <code class="codeph">PLS_INTEGER</code> value can be implicitly converted to a <code class="codeph">PLS_INTEGER</code> subtype only if the value does not violate a constraint of the subtype. 
                     </p>
                     <div class="p">
                        <div class="infoboxnotealso" id="GUID-00859F04-85FC-422D-B35B-93F5B5F4B912__GUID-3B696C9A-95DC-4972-804F-E1E419347D02">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="plsql-language-fundamentals.html#GUID-6705CC7D-470A-4B4A-BCAD-6843F227C012" title="You can impose the NOT NULL constraint on a scalar variable or constant (or scalar component of a composite variable or constant).">NOT NULL Constraint</a>"</span>for information about the <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="plsql-data-types.html#GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" title="SIMPLE_INTEGER is a predefined subtype of the PLS_INTEGER data type.">SIMPLE_INTEGER Subtype of PLS_INTEGER</a>"</span> for more information about <code class="codeph">SIMPLE_INTEGER</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <div class="example" id="GUID-00859F04-85FC-422D-B35B-93F5B5F4B912__CHDBJFJE">
                        <p class="titleinexample">Example 3-6 Violating Constraint of SIMPLE_INTEGER Subtype</p>
                        <p>This example shows that casting the <code class="codeph">PLS_INTEGER</code> value <code class="codeph">NULL</code> to the <code class="codeph">SIMPLE_INTEGER</code> subtype raises an exception. 
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  a SIMPLE_INTEGER := 1;
  b PLS_INTEGER := NULL;
BEGIN
  a := b;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error
ORA-06512: at line 5</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS314"></a><a id="LNPLS00305"></a><div class="props_rev_3"><a id="GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" name="GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF"></a><h4 id="LNPLS-GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" class="sect4"><span class="enumeration_section">3.3.3 </span>SIMPLE_INTEGER Subtype of PLS_INTEGER
                  </h4>
                  <div>
                     <p><code class="codeph">SIMPLE_INTEGER</code> is a predefined subtype of the <code class="codeph">PLS_INTEGER</code> data type.
                     </p>
                     <p><code class="codeph">SIMPLE_INTEGER</code> has the same range as <code class="codeph">PLS_INTEGER</code> and has a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint. It differs significantly from <code class="codeph">PLS_INTEGER</code> in its overflow semantics.
                     </p>
                     <p>If you know that a variable will never have the value <code class="codeph">NULL</code> or need overflow checking, declare it as <code class="codeph">SIMPLE_INTEGER</code> rather than <code class="codeph">PLS_INTEGER</code>. Without the overhead of checking for nullness and overflow, <code class="codeph">SIMPLE_INTEGER</code> performs significantly better than <code class="codeph">PLS_INTEGER</code>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF__GUID-AE120E3E-0891-49C2-9735-FC5742BBC510">Topics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-data-types.html#GUID-508CD868-0C7A-431B-9BA8-419ACD3F1964" title="If and only if all operands in an expression have the data type SIMPLE_INTEGER, PL/SQL uses two's complement arithmetic and ignores overflows.">SIMPLE_INTEGER Overflow Semantics</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-55F1EF5E-77CA-4AFA-A577-94710502470C" title="If an expression has both SIMPLE_INTEGER and other operands, PL/SQL implicitly converts the SIMPLE_INTEGER values to PLS_INTEGER NOT NULL.">Expressions with Both SIMPLE_INTEGER and Other Operands</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-data-types.html#GUID-5F982083-9915-420C-A73F-FCD3D7ECE5C2" title="Integer literals in the SIMPLE_INTEGER range have the data type SIMPLE_INTEGER.">Integer Literals in SIMPLE_INTEGER Range</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF__GUID-552BD564-3870-4043-A4EF-F1BB5B862C8A">
                           <p class="notep1">See Also:</p><span class="q">"<a href="plsql-language-fundamentals.html#GUID-6705CC7D-470A-4B4A-BCAD-6843F227C012" title="You can impose the NOT NULL constraint on a scalar variable or constant (or scalar component of a composite variable or constant).">NOT NULL Constraint</a>"</span></div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS321"></a><div class="props_rev_3"><a id="GUID-508CD868-0C7A-431B-9BA8-419ACD3F1964" name="GUID-508CD868-0C7A-431B-9BA8-419ACD3F1964"></a><h5 id="LNPLS-GUID-508CD868-0C7A-431B-9BA8-419ACD3F1964" class="sect5"><span class="enumeration_section">3.3.3.1 </span>SIMPLE_INTEGER Overflow Semantics
                     </h5>
                     <div>
                        <p>If and only if all operands in an expression have the data type <code class="codeph">SIMPLE_INTEGER</code>, PL/SQL uses two's complement arithmetic and ignores overflows. 
                        </p>
                        <p>Because overflows are ignored, values can wrap from positive to negative or from negative to positive; for example:</p>
                        <p>2<sup>30</sup> + 2<sup>30</sup> = 0x40000000 + 0x40000000 = 0x80000000 = -2<sup>31</sup></p>
                        <p>-2<sup>31</sup> + -2<sup>31</sup> = 0x80000000 + 0x80000000 = 0x00000000 = 0
                        </p>
                        <p>For example, this block runs without errors:</p><pre class="oac_no_warn" dir="ltr">DECLARE
  n <span class="bold">SIMPLE_INTEGER</span> := 2147483645;
BEGIN
  FOR j IN 1..4 LOOP
    n := n + 1;
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(n, 'S9999999999'));
  END LOOP;
  FOR j IN 1..4 LOOP
   n := n - 1;
   DBMS_OUTPUT.PUT_LINE(TO_CHAR(n, 'S9999999999'));
  END LOOP;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">+2147483646
+2147483647
-2147483648
-2147483647
-2147483648
+2147483647
+2147483646
+2147483645

PL/SQL procedure successfully completed.</pre></div>
                  </div><a id="LNPLS99936"></a><div class="props_rev_3"><a id="GUID-55F1EF5E-77CA-4AFA-A577-94710502470C" name="GUID-55F1EF5E-77CA-4AFA-A577-94710502470C"></a><h5 id="LNPLS-GUID-55F1EF5E-77CA-4AFA-A577-94710502470C" class="sect5"><span class="enumeration_section">3.3.3.2 </span>Expressions with Both SIMPLE_INTEGER and Other Operands
                     </h5>
                     <div>
                        <p>If an expression has both <code class="codeph">SIMPLE_INTEGER</code> and other operands, PL/SQL implicitly converts the <code class="codeph">SIMPLE_INTEGER</code> values to <code class="codeph">PLS_INTEGER</code> <code class="codeph">NOT</code> <code class="codeph">NULL</code>.
                        </p>
                        <p>The PL/SQL compiler issues a warning when <code class="codeph">SIMPLE_INTEGER</code> and other values are mixed in a way that might negatively impact performance by inhibiting some optimizations.
                        </p>
                     </div>
                  </div><a id="LNPLS323"></a><div class="props_rev_3"><a id="GUID-5F982083-9915-420C-A73F-FCD3D7ECE5C2" name="GUID-5F982083-9915-420C-A73F-FCD3D7ECE5C2"></a><h5 id="LNPLS-GUID-5F982083-9915-420C-A73F-FCD3D7ECE5C2" class="sect5"><span class="enumeration_section">3.3.3.3 </span>Integer Literals in SIMPLE_INTEGER Range
                     </h5>
                     <div>
                        <p>Integer literals in the <code class="codeph">SIMPLE_INTEGER</code> range have the data type <code class="codeph">SIMPLE_INTEGER</code>. 
                        </p>
                        <p>However, to ensure backward compatibility, when all operands in an arithmetic expression are integer literals, PL/SQL treats the integer literals as if they were cast to <code class="codeph">PLS_INTEGER</code>.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS315"></a><a id="LNPLS99935"></a><div class="props_rev_3"><a id="GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" name="GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670"></a><h3 id="LNPLS-GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" class="sect3"><span class="enumeration_section">3.4 </span>User-Defined PL/SQL Subtypes
               </h3>
               <div>
                  <p>PL/SQL lets you define your own subtypes.</p>
                  <p>The base type can be any scalar or user-defined PL/SQL data type specifier such as <code class="codeph">CHAR</code>, <code class="codeph">DATE</code>, or <code class="codeph">RECORD</code> (including a previously defined user-defined subtype).
                  </p>
                  <div class="infoboxnote" id="GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670__GUID-2DF9F3A6-8991-4354-8CFE-39DFAC5BC295">
                     <p class="notep1">Note:</p>
                     <p>The information in this topic applies to both user-defined subtypes and the predefined subtypes listed in <a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL/SQL Predefined Data Types</a>.
                     </p>
                  </div>
                  <p>Subtypes can:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Provide compatibility with ANSI/ISO data types</p>
                     </li>
                     <li>
                        <p>Show the intended use of data items of that type</p>
                     </li>
                     <li>
                        <p>Detect out-of-range values</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670__GUID-4982318C-C573-4176-9FE2-8CA7BDB40809">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-data-types.html#GUID-31F465A3-F8F7-413A-AB6F-7EF422D052E0" title="An unconstrained subtype has the same set of values as its base type, so it is only another name for the base type.">Unconstrained Subtypes</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-data-types.html#GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" title="A constrained subtype has only a subset of the values of its base type.">Constrained Subtypes</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-data-types.html#GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7" title="If two subtypes have different base types in the same data type family, then one subtype can be implicitly converted to the other only if the source value does not violate a constraint of the target subtype.">Subtypes with Base Types in Same Data Type Family</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS316"></a><a id="LNPLS99934"></a><div class="props_rev_3"><a id="GUID-31F465A3-F8F7-413A-AB6F-7EF422D052E0" name="GUID-31F465A3-F8F7-413A-AB6F-7EF422D052E0"></a><h4 id="LNPLS-GUID-31F465A3-F8F7-413A-AB6F-7EF422D052E0" class="sect4"><span class="enumeration_section">3.4.1 </span>Unconstrained Subtypes
                  </h4>
                  <div>
                     <p>An <span class="bold">unconstrained subtype</span> has the same set of values as its base type, so it is only another name for the base type. 
                     </p>
                     <p>Therefore, unconstrained subtypes of the same base type are interchangeable with each other and with the base type. No data type conversion occurs.</p>
                     <p>To define an unconstrained subtype, use this syntax:</p><pre class="oac_no_warn" dir="ltr">SUBTYPE <span class="italic">subtype_name</span> IS <span class="italic">base_type</span>
</pre><p>For information about <span class="italic"><code class="codeph">subtype_name</code></span> and <span class="italic"><code class="codeph">base_type</code></span>, see <span class="bold"><a href="block.html#GUID-9ACEB9ED-567E-4E1A-A16A-B8B35214FC9D__CHDECJAH">subtype</a></span>.
                     </p>
                     <p>An example of an unconstrained subtype, which PL/SQL predefines for compatibility with ANSI, is:</p><pre class="oac_no_warn" dir="ltr">SUBTYPE "DOUBLE PRECISION" IS FLOAT
</pre><div class="example" id="GUID-31F465A3-F8F7-413A-AB6F-7EF422D052E0__BABEDFGH">
                        <p class="titleinexample">Example 3-7 User-Defined Unconstrained Subtypes Show Intended Use</p>
                        <p>In this example, the unconstrained subtypes <code class="codeph">Balance</code> and <code class="codeph">Counter</code> show the intended uses of data items of their types.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  <span class="bold">SUBTYPE Balance IS NUMBER</span>;

  checking_account        Balance(6,2);
  savings_account         Balance(8,2);
  certificate_of_deposit  Balance(8,2);
  max_insured  CONSTANT   Balance(8,2) := 250000.00;

  <span class="bold">SUBTYPE Counter IS NATURAL</span>;

  accounts     Counter := 1;
  deposits     Counter := 0;
  withdrawals  Counter := 0;
  overdrafts   Counter := 0;

  PROCEDURE deposit (
    account  IN OUT Balance,
    amount   IN     Balance
  ) IS
  BEGIN
    account  := account + amount;
    deposits := deposits + 1;
  END;
  
BEGIN
  NULL;
END;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS374"></a><a id="LNPLS317"></a><a id="LNPLS99933"></a><div class="props_rev_3"><a id="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" name="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F"></a><h4 id="LNPLS-GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" class="sect4"><span class="enumeration_section">3.4.2 </span>Constrained Subtypes
                  </h4>
                  <div>
                     <p>A <span class="bold">constrained subtype</span> has only a subset of the values of its base type.
                     </p>
                     <p>If the base type lets you specify size, precision and scale, or a range of values, then you can specify them for its subtypes. The subtype definition syntax is:</p><pre class="oac_no_warn" dir="ltr">SUBTYPE <span class="italic">subtype_name</span> IS <span class="italic">base_type</span>
  { <span class="italic">precision</span> [, <span class="italic">scale</span> ] | RANGE <span class="italic">low_value</span> .. <span class="italic">high_value</span> } [ NOT NULL ]
</pre><p>Otherwise, the only constraint that you can put on its subtypes is <code class="codeph">NOT</code> <code class="codeph">NULL</code>:
                     </p><pre class="oac_no_warn" dir="ltr">SUBTYPE <span class="italic">subtype_name</span> IS <span class="italic">base_type</span> [ NOT NULL ]</pre><div class="infoboxnote" id="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F__GUID-73884108-CAE5-4155-843C-49CC4C829F3E">
                        <p class="notep1">Note:</p>
                        <p>The only base types for which you can specify a range of values are <code class="codeph">PLS_INTEGER</code> and its subtypes (both predefined and user-defined).
                        </p>
                     </div>
                     <p>A constrained subtype can be implicitly converted to its base type, but the base type can be implicitly converted to the constrained subtype only if the value does not violate a constraint of the subtype.</p>
                     <p>A constrained subtype can be implicitly converted to another constrained subtype with the same base type only if the source value does not violate a constraint of the target subtype.</p>
                     <div class="infoboxnotealso" id="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F__GUID-059627C8-295E-49E9-B269-0C81BFB2B55F">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="block.html#GUID-9ACEB9ED-567E-4E1A-A16A-B8B35214FC9D__CHDCIGAD">subtype_definition ::=</a>"</span> syntax diagram
                              </p> 
                           </li>
                           <li>
                              <p><span class="q">"<a href="block.html#GUID-9ACEB9ED-567E-4E1A-A16A-B8B35214FC9D__CHDECJAH">subtype</a>"</span> semantic description 
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="plsql-data-types.html#GUID-00859F04-85FC-422D-B35B-93F5B5F4B912__CHDBJFJE">Example 3-6</a>"</span>, <span class="q">"Violating Constraint of SIMPLE_INTEGER Subtype"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253">Formal Parameters of Constrained Subtypes</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="plsql-language-fundamentals.html#GUID-6705CC7D-470A-4B4A-BCAD-6843F227C012" title="You can impose the NOT NULL constraint on a scalar variable or constant (or scalar component of a composite variable or constant).">NOT NULL Constraint</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F__CJABHGBG">
                        <p class="titleinexample">Example 3-8 User-Defined Constrained Subtype Detects Out-of-Range Values</p>
                        <p>In this example, the constrained subtype <code class="codeph">Balance</code> detects out-of-range values.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  <span class="bold">SUBTYPE Balance IS NUMBER(8,2)</span>;
 
  checking_account  Balance;
  <span class="bold">savings_account   Balance</span>;
 
BEGIN
  checking_account := 2000.00;
  <span class="bold">savings_account  := 1000000.00</span>;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
<span class="bold">ORA-06502: PL/SQL: numeric or value error: number precision too large</span>
ORA-06512: at line 9
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F__CHDDEEJC">
                        <p class="titleinexample">Example 3-9 Implicit Conversion Between Constrained Subtypes with Same Base Type</p>
                        <p>In this example, the three constrained subtypes have the same base type. The first two subtypes can be implicitly converted to the third subtype, but not to each other.</p><pre class="oac_no_warn" dir="ltr">DECLARE
  SUBTYPE Digit        IS PLS_INTEGER RANGE 0..9;
  SUBTYPE Double_digit IS PLS_INTEGER RANGE 10..99;
  SUBTYPE Under_100    IS PLS_INTEGER RANGE 0..99;
 
  d   Digit        :=  4;
  dd  Double_digit := 35;
  u   Under_100;
BEGIN
  u := d;   -- Succeeds; Under_100 range includes Digit range
  u := dd;  -- Succeeds; Under_100 range includes Double_digit range
  dd := d;  -- Raises error; Double_digit range does not include Digit range
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error
ORA-06512: at line 12</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS318"></a><a id="LNPLS99932"></a><div class="props_rev_3"><a id="GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7" name="GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7"></a><h4 id="LNPLS-GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7" class="sect4"><span class="enumeration_section">3.4.3 </span>Subtypes with Base Types in Same Data Type Family
                  </h4>
                  <div>
                     <p>If two subtypes have different base types in the same data type family, then one subtype can be implicitly converted to the other only if the source value does not violate a constraint of the target subtype.</p>
                     <p>For the predefined PL/SQL data types and subtypes, grouped by data type family, see <a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL/SQL Predefined Data Types</a>.
                     </p>
                     <div class="example" id="GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7__CHDIIGEA">
                        <p class="titleinexample">Example 3-10 Implicit Conversion Between Subtypes with Base Types in Same Family</p>
                        <p>In this example, the subtypes <code class="codeph">Word</code> and <code class="codeph">Text</code> have different base types in the same data type family. The first assignment statement implicitly converts a <code class="codeph">Word</code> value to <code class="codeph">Text</code>. The second assignment statement implicitly converts a <code class="codeph">Text</code> value to <code class="codeph">Word</code>. The third assignment statement cannot implicitly convert the <code class="codeph">Text</code> value to <code class="codeph">Word</code>, because the value is too long.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  SUBTYPE Word IS CHAR(6);
  SUBTYPE Text IS VARCHAR2(15);
 
  verb       Word := 'run';
  sentence1  Text;
  sentence2  Text := 'Hurry!';
  sentence3  Text := 'See Tom run.';
 
BEGIN
  sentence1 := verb;  -- 3-character value, 15-character limit
  verb := sentence2;  -- 6-character value, 6-character limit
  verb := sentence3;  -- 12-character value, 6-character limit
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">DECLARE
*
ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error: character string buffer too small
ORA-06512: at line 13</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>