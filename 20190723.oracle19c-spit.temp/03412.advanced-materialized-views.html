<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Advanced Materialized Views</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="basic-materialized-views.html" title="Previous" type="text/html">
      <link rel="next" href="refreshing-materialized-views.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="basic-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="refreshing-materialized-views.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">Optimizing Data Warehouses</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Advanced Materialized Views</li>
            </ol>
            <a id="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" name="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B"></a>
            
            <h2 id="DWHSG-GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" class="sect2"><span class="enumeration_chapter">6 </span>Advanced Materialized Views
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses advanced topics in using materialized views. It contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-43FA865F-8C02-4B99-9202-49728BAA7687">About Partitioning and Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" title="Creating a materialized view over queries of an analytic view or a hierarchy is not supported.">About Materialized Views in Analytic Processing Environments</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A">About Materialized Views and Models</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-BC3675D3-C925-4D72-B953-34E7C818EB91">About Security Issues with Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">Invalidating Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E">Altering Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-0702359B-D379-4299-86C4-2958BCD4381D" title="Real-time materialized views provide fresh data to user queries even when the materialized view is marked as stale.">Using Real-time Materialized Views</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8227"></a><div class="props_rev_3"><a id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687" name="GUID-43FA865F-8C02-4B99-9202-49728BAA7687"></a><h3 id="DWHSG-GUID-43FA865F-8C02-4B99-9202-49728BAA7687" class="sect3"><span class="enumeration_section">6.1 </span>About Partitioning and Materialized Views
               </h3>
               <div>
                  <p><a id="d25854e81" class="indexterm-anchor"></a><a id="d25854e85" class="indexterm-anchor"></a>Because of the large volume of data held in a data warehouse, partitioning is an extremely useful option when designing a database. Partitioning the fact tables improves scalability, simplifies system administration, and makes it possible to define local indexes that can be efficiently rebuilt. Partitioning the fact tables also improves the opportunity of fast refreshing the materialized view because this may enable partition change tracking (PCT) refresh on the materialized view. Partitioning a materialized view also has benefits for refresh, because the refresh procedure can then use parallel DML in more scenarios and PCT-based refresh can use truncate partition to efficiently maintain the materialized view.
                  </p>
                  <div class="infoboxnotealso" id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687__GUID-C0A88051-183F-4068-9B28-5A058CE6B1FD">
                     <p class="notep1">See Also:</p>
                     <p><a href="../vldbg/partition-concepts.html#VLDBG002" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for further details about partitioning
                     </p>
                  </div>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0661E251-15FA-4845-A358-7209D9B22096">Partitioning a Materialized View</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-B609252D-DD65-4617-8F38-B1AB52473AA5">Partitioning a Prebuilt Table</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-5AC25C22-427B-45B8-B949-B05AC8853310">Rolling Materialized Views</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG00324"></a><div class="props_rev_3"><a id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" name="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1"></a><h4 id="DWHSG-GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" class="sect4"><span class="enumeration_section">6.1.1 </span>About Partition Change Tracking
                  </h4>
                  <div>
                     <p>It is <a id="d25854e143" class="indexterm-anchor"></a><a id="d25854e145" class="indexterm-anchor"></a>possible and advantageous to track freshness to a finer grain than the entire materialized view. You can achieve this through <a href="glossary.html#GUID-32BF9E11-2C90-446A-9C66-4D0BA8DF7798"><span class="xrefglossterm">partition change tracking (PCT)</span></a>, which is a method to identify which rows in a materialized view are affected by a certain detail table partition. When one or more of the detail tables are partitioned, it may be possible to identify the specific rows in the materialized view that correspond to a modified detail partition(s); those rows become stale when a partition is modified while all other rows remain fresh.
                     </p>
                     <p>You can use PCT to identify which materialized view rows correspond to a particular partition. PCT is also used to support fast refresh after partition maintenance operations on detail tables. For instance, if a detail table partition is truncated or dropped, the affected rows in the materialized view are identified and deleted.</p>
                     <p>Identifying which materialized view rows are fresh or stale, rather than considering the entire materialized view as stale, allows query rewrite to use those rows that are fresh while in <code class="codeph">QUERY_REWRITE_INTEGRITY </code>= <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> modes. Several views, such as <code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code>, detail which partitions are stale or fresh. Oracle does not rewrite against partial stale materialized views if partition change tracking on the changed table is enabled by the presence of join dependent expressions in the materialized view.
                     </p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-C6E771CD-21C4-42DC-871F-C18680BECA1D">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">About Join Dependent Expression and Partition Change Tracking</a>"</span> for more information
                        </p>
                     </div>
                     <p>Note that, while partition change tracking tracks the staleness on a partition and subpartition level (for composite partitioned tables), the level of granularity for PCT refresh is only the top-level partitioning strategy. Consequently, any change to data in one of the subpartitions of a composite partitioned-table will only mark the single impacted subpartition as stale and have the rest of the table available for rewrite, but the PCT refresh will refresh the whole partition that contains the impacted subpartition.</p>
                     <p>To support PCT, a materialized view must satisfy the following requirements:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>At least one of the detail tables referenced by the materialized view must be partitioned.</p>
                        </li>
                        <li>
                           <p>Partitioned tables must use either range, list or composite partitioning with range or list as the top-level partitioning strategy.</p>
                        </li>
                        <li>
                           <p>The top level partition key must consist of only a single column.</p>
                        </li>
                        <li>
                           <p>The materialized view must contain either the partition key column or a partition marker or <code class="codeph">ROWID</code> or join dependent expression of the detail table.
                           </p>
                        </li>
                        <li>
                           <p>If you use a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, the partition key column or the partition marker or <code class="codeph">ROWID</code> or join dependent expression must be present in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. 
                           </p>
                        </li>
                        <li>
                           <p>If you use an analytic window function or the <code class="codeph">MODEL</code> clause, the partition key column or the partition marker or <code class="codeph">ROWID</code> or join dependent expression must be present in their respective <code class="codeph">PARTITION</code> <code class="codeph">BY</code> subclauses.
                           </p>
                        </li>
                        <li>
                           <p>Data modifications can only occur on the partitioned table. If PCT refresh is being done for a table which has join dependent expression in the materialized view, then data modifications should not have occurred in any of the join dependent tables.</p>
                        </li>
                        <li>
                           <p>The <code class="codeph">COMPATIBILITY</code> initialization parameter must be a minimum of 9.0.0.0.0.
                           </p>
                        </li>
                     </ul>
                     <p>PCT is not supported for a materialized view that refers to views, remote tables, or outer joins.</p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-13A32E69-2B80-4385-A3E8-F5B10B9991C0">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/DBMS_MVIEW.html#ARPLS027" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for details regarding the <code class="codeph">DBMS_MVIEW.PMARKER</code> function and partition markers
                        </p>
                     </div>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BDF063E9-7769-4272-A54E-C5E199476C46">About Partition Key and Partition Change Tracking</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">About Join Dependent Expression and Partition Change Tracking</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79">About Partition Markers and Partition Change Tracking</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-462D637E-27E2-4581-BD50-6CA79A854000">About Partial Rewrite in Partition Change Tracking</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8229"></a><a id="DWHSG8228"></a><div class="props_rev_3"><a id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46" name="GUID-BDF063E9-7769-4272-A54E-C5E199476C46"></a><h5 id="DWHSG-GUID-BDF063E9-7769-4272-A54E-C5E199476C46" class="sect5"><span class="enumeration_section">6.1.1.1 </span>About Partition Key and Partition Change Tracking
                     </h5>
                     <div>
                        <p>Partition change tracking requires sufficient information in the materialized view to be able to correlate a detail row in the source partitioned detail table to the corresponding materialized view row. This can be accomplished by including the detail table partition key columns in the <code class="codeph">SELECT</code> list and, if <code class="codeph">GROUP</code> <code class="codeph">BY</code> is used, in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> list.
                        </p>
                        <p>Consider an example of a materialized view storing daily customer sales. The following example uses the <code class="codeph">sh</code> sample schema and the three detail tables <code class="codeph">sales</code>, <code class="codeph">products</code>, and <code class="codeph">times</code> to create the materialized view. <code class="codeph">sales</code> table is partitioned by <code class="codeph">time_id</code> column and <code class="codeph">products</code> is partitioned by the <code class="codeph">prod_id</code> column. <code class="codeph">times</code> is not a partitioned table.
                        </p>
                        <div class="example" id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46__GUID-57C843AC-0CA8-4C49-92D3-5B9D7964F9ED">
                           <p class="titleinexample">Example 6-1 Materialized View with Partition Key</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON SALES WITH ROWID
   (prod_id, time_id, quantity_sold, amount_sold) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON PRODUCTS WITH ROWID
   (prod_id, prod_name, prod_desc) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON TIMES WITH ROWID
   (time_id, calendar_month_name, calendar_year) INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW cust_dly_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.time_id, p.prod_id, p.prod_name, COUNT(*),
         SUM(s.quantity_sold), SUM(s.amount_sold),
         COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY s.time_id, p.prod_id, p.prod_name;
</pre><p>For <code class="codeph">cust_dly_sales_mv</code>, PCT is enabled on the <code class="codeph">sales</code> table because the partitioning key column <code class="codeph">time_id</code> is in the materialized view.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8231"></a><a id="DWHSG8230"></a><div class="props_rev_3"><a id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" name="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697"></a><h5 id="DWHSG-GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" class="sect5"><span class="enumeration_section">6.1.1.2 </span>About Join Dependent Expression and Partition Change Tracking
                     </h5>
                     <div>
                        <p>An expression consisting of columns from tables directly or indirectly joined through equijoins to the partitioned detail table on the partitioning key and which is either a dimensional attribute or a dimension hierarchical parent of the joining key is called a join dependent expression. The set of tables in the path to detail table are called join dependent tables. Consider the following:</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, t.calendar_month_name 
FROM sales s, times t WHERE s.time_id = t.time_id;
</pre><p>In this query, <code class="codeph">times</code> table is a join dependent table because it is joined to <code class="codeph">sales</code> table on the partitioning key column <code class="codeph">time_id</code>. Moreover, <code class="codeph">calendar_month_name</code> is a dimension hierarchical attribute of <code class="codeph">times.time_id</code>, because <code class="codeph">calendar_month_name</code> is an attribute of <code class="codeph">times.mon_id</code> and <code class="codeph">times.mon_id</code> is a dimension hierarchical parent of <code class="codeph">times.time_id</code>. Hence, the expression <code class="codeph">calendar_month_name</code> from <code class="codeph">times</code> tables is a join dependent expression. Let's consider another example:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, y.calendar_year_name
FROM sales s, times_d d, times_m m, times_y y
WHERE s.time_id = d.time_id AND d.day_id = m.day_id AND m.mon_id = y.mon_id;
</pre><p>Here, <code class="codeph">times</code> table is denormalized into <code class="codeph">times_d</code>, <code class="codeph">times_m</code> and <code class="codeph">times_y</code> tables. The expression <code class="codeph">calendar_year_name</code> from <code class="codeph">times_y</code> table is a join dependent expression and the tables <code class="codeph">times_d</code>, <code class="codeph">times_m</code> and <code class="codeph">times_y</code> are join dependent tables. This is because <code class="codeph">times_y</code> table is joined indirectly through <code class="codeph">times_m</code> and <code class="codeph">times_d</code> tables to sales table on its partitioning key column <code class="codeph">time_id</code>.
                        </p>
                        <p>This lets users create materialized views containing aggregates on some level higher than the partitioning key of the detail table. Consider the following example of materialized view storing monthly customer sales.</p>
                        <div class="example" id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697__GUID-88E6DF64-A0B7-4343-BF7A-CEAADF171F4A">
                           <p class="titleinexample">Example 6-2 Creating a Materialized View: Join Dependent Expression</p>
                           <p>Assuming the presence of materialized view logs defined earlier, the materialized view can be created using the following DDL:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_name, p.prod_id, p.prod_name, COUNT(*),
    SUM(s.quantity_sold), SUM(s.amount_sold),
    COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY t.calendar_month_name, p.prod_id, p.prod_name;
</pre><p>Here, you can correlate a detail table row to its corresponding materialized view row using the join dependent table <code class="codeph">times</code> and the relationship that <code class="codeph">times.calendar_month_name</code> is a dimensional attribute determined by <code class="codeph">times.time_id</code>. This enables partition change tracking on <code class="codeph">sales</code> table. In addition to this, PCT is enabled on products table because of presence of its partitioning key column <code class="codeph">prod_id</code> in the materialized view.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8233"></a><a id="DWHSG8232"></a><div class="props_rev_3"><a id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" name="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79"></a><h5 id="DWHSG-GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" class="sect5"><span class="enumeration_section">6.1.1.3 </span>About Partition Markers and Partition Change Tracking
                     </h5>
                     <div>
                        <p>The <code class="codeph">DBMS_MVIEW.PMARKER</code> function is designed to significantly reduce the cardinality (the ratio of distinct values to the number of table rows) of the materialized view (see <a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">Example 6-3</a> for an example). The function returns a partition identifier that uniquely identifies the partition or subpartition for a specified row within a specified partitioned table. Therefore, the <code class="codeph">DBMS_MVIEW.PMARKER</code> function is used instead of the partition key column in the <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses.
                        </p>
                        <p>Unlike the general case of a PL/SQL function in a materialized view, use of the <code class="codeph">DBMS_MVIEW.PMARKER</code> does not prevent rewrite with that materialized view even when the rewrite mode is <code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code>.
                        </p>
                        <p>As an example of using the <code class="codeph">PMARKER</code> function, consider calculating a typical number, such as revenue generated by a product category during a given year. If there were 1000 different products sold each month, it would result in 12,000 rows in the materialized view.
                        </p>
                        <div class="example" id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">
                           <p class="titleinexample">Example 6-3 Using Partition Markers in a Materialized View</p>
                           <p>Consider an example of a materialized view storing the yearly sales revenue for each product category. With approximately hundreds of different products in each product category, including the partitioning key column <code class="codeph">prod_id</code> of the <code class="codeph">products</code> table in the materialized view would substantially increase the cardinality. Instead, this materialized view uses the <code class="codeph">DBMS_MVIEW.PMARKER</code> function, which increases the cardinality of materialized view by a factor of the number of partitions in the <code class="codeph">products</code> table.
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW prod_yr_sales_mv
BUILD DEFERRED
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(p.rowid), p.prod_category, t.calendar_year, COUNT(*),
       SUM(s.amount_sold), SUM(s.quantity_sold),
       COUNT(s.amount_sold), COUNT(s.quantity_sold)
FROM   sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY  DBMS_MVIEW.PMARKER (p.rowid), p.prod_category, t.calendar_year;
</pre><p><code class="codeph">prod_yr_sales_mv</code> includes the <code class="codeph">DBMS_MVIEW.PMARKER</code> function on the <code class="codeph">products</code> table in its <code class="codeph">SELECT</code> list. This enables partition change tracking on <code class="codeph">products</code> table with significantly less cardinality impact than grouping by the partition key column <code class="codeph">prod_id</code>. In this example, the desired level of aggregation for the <code class="codeph">prod_yr_sales_mv</code> is to group by <code class="codeph">products.prod_category</code>. Using the <code class="codeph">DBMS_MVIEW.PMARKER</code> function, the materialized view cardinality is increased only by a factor of the number of partitions in the <code class="codeph">products</code> table. This would generally be significantly less than the cardinality impact of including the partition key columns.
                           </p>
                           <p>Note that partition change tracking is enabled on <code class="codeph">sales</code> table because of presence of join dependent expression <code class="codeph">calendar_year</code> in the <code class="codeph">SELECT</code> list.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8234"></a><div class="props_rev_3"><a id="GUID-462D637E-27E2-4581-BD50-6CA79A854000" name="GUID-462D637E-27E2-4581-BD50-6CA79A854000"></a><h5 id="DWHSG-GUID-462D637E-27E2-4581-BD50-6CA79A854000" class="sect5"><span class="enumeration_section">6.1.1.4 </span>About Partial Rewrite in Partition Change Tracking
                     </h5>
                     <div>
                        <p>A subsequent <code class="codeph">INSERT</code> statement adds a new row to the <code class="codeph">sales_part3</code> partition of table <code class="codeph">sales</code>. At this point, because <code class="codeph">cust_dly_sales_mv</code> has PCT available on table <code class="codeph">sales</code> using a partition key, Oracle can identify the stale rows in the materialized view <code class="codeph">cust_dly_sales_mv</code> corresponding to <code class="codeph">sales_part3</code> partition (The other rows are unchanged in their freshness state). Query rewrite cannot identify the fresh portion of materialized views <code class="codeph">cust_mth_sales_mv</code> and <code class="codeph">prod_yr_sales_mv</code> because PCT is available on table sales using join dependent expressions. Query rewrite can determine the fresh portion of a materialized view on changes to a detail table only if PCT is available on the detail table using a partition key or partition marker.
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8235"></a><div class="props_rev_3"><a id="GUID-0661E251-15FA-4845-A358-7209D9B22096" name="GUID-0661E251-15FA-4845-A358-7209D9B22096"></a><h4 id="DWHSG-GUID-0661E251-15FA-4845-A358-7209D9B22096" class="sect4"><span class="enumeration_section">6.1.2 </span>Partitioning a Materialized View
                  </h4>
                  <div>
                     <div class="section">
                        <p>Partitioning a materialized view involves defining the materialized view with the standard Oracle partitioning clauses, as illustrated in the following example. This statement creates a materialized view called <code class="codeph">part_sales_mv</code>, which uses three partitions, can be fast refreshed, and is eligible for query rewrite:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW part_sales_mv
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE('31-12-1998', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE('31-12-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
 PARTITION month3
      VALUES LESS THAN (TO_DATE('31-12-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)
BUILD DEFERRED
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT s.cust_id, s.time_id,
  SUM(s.amount_sold) AS sum_dol_sales, SUM(s.quantity_sold) AS sum_unit_sales
  FROM sales s GROUP BY s.time_id, s.cust_id;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8236"></a><div class="props_rev_3"><a id="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" name="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5"></a><h4 id="DWHSG-GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" class="sect4"><span class="enumeration_section">6.1.3 </span>Partitioning a Prebuilt Table
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d25854e709" class="indexterm-anchor"></a>Alternatively, a materialized view can be registered to a partitioned prebuilt table. <span class="q">"<a href="advanced-materialized-views.html#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">Benefits of Partitioning a Materialized View</a>"</span> describes the benefits of partitioning a prebuilt table. The following example illustrates this:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_sales_tab_mv(time_id, cust_id, sum_dollar_sales, sum_unit_sale)
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE('31-12-1998', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE('31-12-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
PARTITION month3
      VALUES LESS THAN (TO_DATE('31-12-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)  AS
SELECT s.time_id, s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
  SUM(s.quantity_sold) AS sum_unit_sales
FROM sales s GROUP BY s.time_id, s.cust_id;

CREATE MATERIALIZED VIEW part_sales_tab_mv
ON PREBUILT TABLE
ENABLE QUERY REWRITE AS 
SELECT s.time_id,  s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
     SUM(s.quantity_sold) AS sum_unit_sales 
FROM sales s GROUP BY s.time_id, s.cust_id;
</pre><p>In this example, the table <code class="codeph">part_sales_tab_mv</code> has been partitioned over three months and then the materialized view was registered to use the prebuilt table. This materialized view is eligible for query rewrite because the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause has been included.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8237"></a><div class="props_rev_3"><a id="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" name="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA"></a><h5 id="DWHSG-GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" class="sect5"><span class="enumeration_section">6.1.3.1 </span>Benefits of Partitioning a Materialized View
                     </h5>
                     <div>
                        <p>When a materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table, it is more efficient to use a <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement to remove one or more partitions of the materialized view during refresh and then repopulate the partition with new data. Oracle Database uses this variant of fast refresh (called PCT refresh) with partition truncation if the following conditions are satisfied in addition to other conditions described in <span class="q">"<a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>"</span>.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table.</p>
                           </li>
                           <li>
                              <p>If PCT is enabled using either the partitioning key column or join expressions, the materialized view should be range or list partitioned.</p>
                           </li>
                           <li>
                              <p>PCT refresh is nonatomic.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8238"></a><div class="props_rev_3"><a id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310" name="GUID-5AC25C22-427B-45B8-B949-B05AC8853310"></a><h4 id="DWHSG-GUID-5AC25C22-427B-45B8-B949-B05AC8853310" class="sect4"><span class="enumeration_section">6.1.4 </span>Rolling Materialized Views
                  </h4>
                  <div>
                     <p>When a data warehouse or data mart contains a time dimension, it is often desirable to archive the oldest information and then reuse the storage for new information. This is called the rolling window scenario. If the fact tables or materialized views include a time dimension and are horizontally partitioned by the time attribute, then management of rolling materialized views can be reduced to a few fast partition maintenance operations provided the unit of data that is rolled out equals, or is at least aligned with, the range partitions.</p>
                     <p>If you plan to have rolling materialized views in your data warehouse, you should determine how frequently you plan to perform partition maintenance operations, and you should plan to partition fact tables and materialized views to reduce the amount of system administration overhead required when old data is aged out. An additional consideration is that you might want to use data compression on your infrequently updated partitions.</p>
                     <p>You are not restricted to using range partitions. For example, a composite partition using both a time value and a key value could result in a good partition solution for your data.</p>
                     <div class="infoboxnotealso" id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310__GUID-8BAE7F52-08F0-4A6B-A4A1-864208143D3D">
                        <p class="notep1">See Also:</p>
                        <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="A materialized view that uses the ON STATEMENT refresh mode is automatically refreshed every time a DML operation is performed on any of the materialized view’s base tables. Oracle Database performs fast refresh for materialized views that are defined using approximate queries.While redefining a table online using the DBMS_REDEFINITION package, you can perform incremental refresh of fast refreshable materialized views that are dependent on the table being redefined.You can use the complete, fast, or PCT refresh methods to refresh a materialized view that is based on a hybrid partitioned table.">Refreshing Materialized Views</a> for further details regarding <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> and for details regarding compression
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8239"></a><div class="props_rev_3"><a id="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" name="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A"></a><h3 id="DWHSG-GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" class="sect3"><span class="enumeration_section">6.2 </span>About Materialized Views in Analytic Processing Environments
               </h3>
               <div>
                  <p>This section discusses the concepts used by analytic SQL and how relational databases can handle these types of queries. It also illustrates the best approach for creating materialized views using a common scenario.</p>
                  <p>The following topics contain additional information about materialized views in different environments:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-97D76353-0B1A-4685-868E-CAC915FDE194" title="Creating a materialized view over queries of an analytic view or a hierarchy is not supported.">About Materialized Views and Analytic Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A">About Materialized Views and Hierarchical Cubes</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D">Benefits of Partitioning Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444">About Compressing Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39">About Materialized Views with Set Operators</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-97D76353-0B1A-4685-868E-CAC915FDE194" name="GUID-97D76353-0B1A-4685-868E-CAC915FDE194"></a><h4 id="DWHSG-GUID-97D76353-0B1A-4685-868E-CAC915FDE194" class="sect4"><span class="enumeration_section">6.2.1 </span>About Materialized Views and Analytic Views
                  </h4>
                  <div>
                     <p>Creating a materialized view over queries of an analytic view or a hierarchy is not supported.</p>
                  </div>
               </div><a id="DWHSG8241"></a><a id="DWHSG8242"></a><a id="DWHSG8240"></a><div class="props_rev_3"><a id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" name="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A"></a><h4 id="DWHSG-GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" class="sect4"><span class="enumeration_section">6.2.2 </span>About Materialized Views and Hierarchical Cubes
                  </h4>
                  <div>
                     <p>While data warehouse environments typically view data in the form of a star schema, for analytical SQL queries, data is held in the form of a hierarchical cube. A hierarchical cube includes the data aggregated along the rollup hierarchy of each of its dimensions and these aggregations are combined across dimensions. It includes the typical set of aggregations needed for business intelligence queries.</p>
                     <div class="example" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__GUID-C915B982-A86F-4A53-8A1E-68BB537E1152">
                        <p class="titleinexample">Example 6-4 Hierarchical Cube</p>
                        <p>Consider a sales data set with two dimensions, each of which has a four-level hierarchy:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Time, which contains (all times), year, quarter, and month.</p>
                           </li>
                           <li>
                              <p>Product, which contains (all products), division, brand, and item.</p>
                           </li>
                        </ul>
                        <p>This means there are 16 aggregate groups in the hierarchical cube. This is because the four levels of time are multiplied by four levels of product to produce the cube. <a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832" title="This table illustrates the hierarchies for the Time and Product dimensions.">Table 6-1</a> shows the four levels of each dimension.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="tblformal" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832">
                           <p class="titleintable">Table 6-1 ROLLUP By Time and Product</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="ROLLUP By Time and Product" summary="This table illustrates the hierarchies for the Time and Product dimensions." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d25854e984">ROLLUP By Time</th>
                                    <th align="left" valign="bottom" width="70%" id="d25854e987">ROLLUP By Product</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e992" headers="d25854e984 ">
                                       <p>year, quarter, month</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e992 d25854e987 ">
                                       <p>division, brand, item</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e999" headers="d25854e984 ">
                                       <p>year, quarter</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e999 d25854e987 ">
                                       <p>division, brand</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1006" headers="d25854e984 ">
                                       <p>year</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1006 d25854e987 ">
                                       <p>division</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1013" headers="d25854e984 ">
                                       <p>all times</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1013 d25854e987 ">
                                       <p>all products</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Note that as you increase the number of dimensions and levels, the number of groups to calculate increases dramatically. This example involves 16 groups, but if you were to add just two more dimensions with the same number of levels, you would have 4 x 4 x 4 x 4 = 256 different groups. Also, consider that a similar increase in groups occurs if you have multiple hierarchies in your dimensions. For example, the time dimension might have an additional hierarchy of fiscal month rolling up to fiscal quarter and then fiscal year. Handling the explosion of groups has historically been the major challenge in data storage for online analytical processing systems.</p>
                        <p>Typical online analytical queries <a href="glossary.html#GUID-F7CC0204-822C-4C1F-AE7D-A7CC609C05C0"><span class="xrefglossterm">slice and dice</span></a> different parts of the cube comparing aggregations from one level to aggregation from another level. For instance, a query might find sales of the grocery division for the month of January, 2002 and compare them with total sales of the grocery division for all of 2001.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8243"></a><div class="props_rev_3"><a id="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" name="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D"></a><h4 id="DWHSG-GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" class="sect4"><span class="enumeration_section">6.2.3 </span>Benefits of Partitioning Materialized Views
                  </h4>
                  <div>
                     <p>Materialized views with multiple aggregate groups give their best performance for refresh and query rewrite when partitioned appropriately.</p>
                     <p>PCT refresh in a rolling window scenario requires partitioning at the top level on some level from the time dimension. And, partition pruning for queries rewritten against this materialized view requires partitioning on <code class="codeph">GROUPING_ID</code> column. Hence, the most effective partitioning scheme for these materialized views is to use composite partitioning (range-list on (<code class="codeph">time</code>, <code class="codeph">GROUPING_ID</code>) columns). By partitioning the materialized views this way, you enable:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>PCT refresh, thereby improving refresh performance.</p>
                        </li>
                        <li>
                           <p>Partition pruning: only relevant aggregate groups are accessed, thereby greatly reducing the query processing cost.</p>
                        </li>
                     </ul>
                     <p>If you do not want to use PCT refresh, you can just partition by list on <code class="codeph">GROUPING_ID</code> column.
                     </p>
                  </div>
               </div><a id="DWHSG8244"></a><div class="props_rev_3"><a id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" name="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444"></a><h4 id="DWHSG-GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" class="sect4"><span class="enumeration_section">6.2.4 </span>About Compressing Materialized Views
                  </h4>
                  <div>
                     <p>You should consider data compression when using highly redundant data, such as tables with many foreign keys. In particular, materialized views created with the <code class="codeph">ROLLUP</code> clause are likely candidates.
                     </p>
                     <div class="infoboxnotealso" id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444__GUID-D26EC127-092A-4EA1-A934-D93A63CA2951">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/ALTER-MATERIALIZED-VIEW.html#SQLRF52876" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for data compression syntax and restrictions
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="basic-materialized-views.html#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">About Storage And Table Compression for Materialized Views</a>"</span> for details regarding compression
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8245"></a><div class="props_rev_3"><a id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" name="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39"></a><h4 id="DWHSG-GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" class="sect4"><span class="enumeration_section">6.2.5 </span>About Materialized Views with Set Operators
                  </h4>
                  <div>
                     <p>Oracle Database provides support for <a id="d25854e1136" class="indexterm-anchor"></a><a id="d25854e1140" class="indexterm-anchor"></a>materialized views whose defining query involves set operators. Materialized views with set operators can now be created enabled for query rewrite. You can refresh the materialized view using either <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code> refresh.
                     </p>
                     <p>Fast refresh is supported if the defining query has the <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator at the top level and each query block in the <code class="codeph">UNION</code> <code class="codeph">ALL</code>, meets the requirements of a materialized view with aggregates or materialized view with joins only. Further, the materialized view must include a constant column (known as a <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker) that has a distinct value in each query block, which, in the following example, is columns <code class="codeph">1 marker</code> and <code class="codeph">2 marker</code>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39__GUID-B5D588FD-4A69-47CE-984B-DAEDF545DA81">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="basic-materialized-views.html#GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6">Restrictions on Fast Refresh on Materialized Views with UNION ALL</a>"</span> for detailed restrictions on fast refresh for materialized views with <code class="codeph">UNION</code> <code class="codeph">ALL</code>.
                        </p>
                     </div>
                  </div><a id="DWHSG8247"></a><a id="DWHSG8248"></a><a id="DWHSG8246"></a><div class="props_rev_3"><a id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" name="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E"></a><h5 id="DWHSG-GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" class="sect5"><span class="enumeration_section">6.2.5.1 </span>Examples of Materialized Views Using UNION ALL
                     </h5>
                     <div>
                        <div class="section">
                           <p>The following examples illustrate creation of fast refreshable materialized views involving <code class="codeph">UNION</code> <code class="codeph">ALL</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-0AAA7B44-0790-4B59-98E4-5D47DC0BC6B1">
                           <p class="titleinexample">Example 6-5 Materialized View Using UNION ALL with Two Join Views</p>
                           <p>To create a <code class="codeph">UNION</code> <code class="codeph">ALL</code> materialized view with two join views, the materialized view logs must have the rowid column and, in the following example, the <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker is the columns, <code class="codeph">1 marker</code> and <code class="codeph">2 marker</code>.
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;

CREATE MATERIALIZED VIEW unionall_sales_cust_joins_mv
REFRESH FAST ON COMMIT 
ENABLE QUERY REWRITE AS
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 1 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = 'Smith')
UNION ALL
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 2 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = 'Brown');</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-CE59DA03-7059-4C7B-A5E4-25C2341C64DC">
                           <p class="titleinexample">Example 6-6 Materialized View Using UNION ALL with Joins and Aggregates</p>
                           <p>The following example shows a <code class="codeph">UNION</code> <code class="codeph">ALL</code> of a materialized view with joins and a materialized view with aggregates. A couple of things can be noted in this example. Nulls or constants can be used to ensure that the data types of the corresponding <code class="codeph">SELECT</code> list columns match. Also, the <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker column can be a string literal, which is <code class="codeph">'Year' umarker</code>, <code class="codeph">'Quarter' umarker</code>, or <code class="codeph">'Daily' umarker</code> in the following example:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID, SEQUENCE
(amount_sold, time_id)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON times WITH ROWID, SEQUENCE 
  (time_id, fiscal_year, fiscal_quarter_number, day_number_in_week) 
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW unionall_sales_mix_mv
REFRESH FAST ON DEMAND AS
(SELECT 'Year' umarker, NULL, NULL, t.fiscal_year, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
 FROM sales s, times t
 WHERE s.time_id = t.time_id 
 GROUP BY t.fiscal_year)
UNION ALL
(SELECT 'Quarter' umarker, NULL, NULL, t.fiscal_quarter_number, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
FROM sales s, times t 
WHERE s.time_id = t.time_id and t.fiscal_year = 2001
GROUP BY t.fiscal_quarter_number)
UNION ALL
(SELECT 'Daily' umarker, s.rowid rid, t.rowid rid2, t.day_number_in_week,
        s.amount_sold amt, 1, 1
FROM sales s, times t
WHERE s.time_id = t.time_id 
AND t.time_id between '01-Jan-01' AND '01-Dec-31');</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8249"></a><div class="props_rev_3"><a id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" name="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A"></a><h3 id="DWHSG-GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" class="sect3"><span class="enumeration_section">6.3 </span>About Materialized Views and Models
               </h3>
               <div>
                  <p>Models, which provide array-based computations in SQL, can be used in materialized views. Because the <code class="codeph">MODEL</code> clause calculations can be expensive, you may want to use two separate materialized views: one for the model calculations and one for the <code class="codeph">SELECT</code> ... <code class="codeph">GROUP</code> <code class="codeph">BY</code> query. For example, instead of using one, long materialized view, you could create the following materialized views:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW my_groupby_mv
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT country_name country, prod_name prod, calendar_year year,
  SUM(amount_sold) sale, COUNT(amount_sold) cnt, COUNT(*) cntstr 
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND
      sales.prod_id = products.prod_id AND
      sales.cust_id = customers.cust_id AND
      customers.country_id = countries.country_id
GROUP BY country_name, prod_name, calendar_year;

CREATE MATERIALIZED VIEW my_model_mv
ENABLE QUERY REWRITE AS
SELECT country, prod, year, sale, cnt
FROM my_groupby_mv
MODEL PARTITION BY(country) DIMENSION BY(prod, year)
   MEASURES(sale s) IGNORE NAV
(s['Shorts', 2000] =  0.2 * AVG(s)[CV(), year BETWEEN 1996 AND 1999],
s['Kids Pajama', 2000] = 0.5 * AVG(s)[CV(), year BETWEEN 1995 AND 1999],
s['Boys Pajama', 2000] = 0.6 * AVG(s)[CV(), year BETWEEN 1994 AND 1999],
...
&lt;hundreds of other update rules&gt;);
</pre><p>By using two materialized views, you can incrementally maintain the materialized view <code class="codeph">my_groupby_mv</code>. The materialized view <code class="codeph">my_model_mv</code> is on a much smaller data set because it is built on <code class="codeph">my_groupby_mv</code> and can be maintained by a complete refresh.
                  </p>
                  <p>Materialized views with models can use complete refresh or PCT refresh only, and are available for partial text query rewrite only.</p>
                  <div class="infoboxnotealso" id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A__GUID-A8CBF5AB-82C5-4793-BF59-F7C8E7C4F82B">
                     <p class="notep1">See Also:</p>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a> for further details about model calculations
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG8251"></a><div class="props_rev_3"><a id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" name="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91"></a><h3 id="DWHSG-GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" class="sect3"><span class="enumeration_section">6.4 </span>About Security Issues with Materialized Views
               </h3>
               <div>
                  <p><a id="d25854e1363" class="indexterm-anchor"></a>To create a <a id="d25854e1368" class="indexterm-anchor"></a>materialized view in your own schema, you must have the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> privilege and the <code class="codeph">SELECT</code> or <code class="codeph">READ</code> privilege to any tables referenced that are in another schema. To create a materialized view in another schema, you must have the <code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> privilege and the owner of the materialized view needs <code class="codeph">SELECT</code> or <code class="codeph">READ</code> privileges to the tables referenced if they are from another schema. Moreover, if you enable query rewrite on a materialized view that references tables outside your schema, you must have the <code class="codeph">GLOBAL</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> privilege or the <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> object privilege on each table outside your schema.
                  </p>
                  <p>If the materialized view is on a prebuilt container, the creator, if different from the owner, must have the <code class="codeph">READ WITH GRANT</code> or <code class="codeph">SELECT</code> <code class="codeph">WITH</code> <code class="codeph">GRANT</code> privilege on the container table.
                  </p>
                  <p>If you continue to get a privilege error while trying to create a materialized view and you believe that all the required privileges have been granted, then the problem is most likely due to a privilege not being granted explicitly and trying to inherit the privilege from a role instead. The owner of the materialized view must have explicitly been granted <code class="codeph">SELECT</code> or <code class="codeph">READ</code> access to the referenced tables if the tables are in a different schema.
                  </p>
                  <p>If the materialized view is being created with <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> specified, then the owner of the materialized view requires an additional privilege if any of the tables in the defining query are outside the owner's schema. In that case, the owner requires the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> system privilege or the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> object privilege on each table outside the owner's schema.
                  </p>
                  <div class="infoboxnotealso" id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91__GUID-1F2568A6-4F99-40D4-9C11-24AE6998C303">
                     <p class="notep1">See Also:</p>
                     <p><a href="advanced-materialized-views.html#GUID-B0671C37-8287-46D6-A3D9-236DC7917775">Querying Materialized Views with Virtual Private Database (VPD)</a></p>
                  </div>
               </div><a id="DWHSG8252"></a><div class="props_rev_3"><a id="GUID-B0671C37-8287-46D6-A3D9-236DC7917775" name="GUID-B0671C37-8287-46D6-A3D9-236DC7917775"></a><h4 id="DWHSG-GUID-B0671C37-8287-46D6-A3D9-236DC7917775" class="sect4"><span class="enumeration_section">6.4.1 </span>Querying Materialized Views with Virtual Private Database (VPD)
                  </h4>
                  <div>
                     <p>For all security concerns, a materialized view serves as a view that happens to be materialized when you are directly querying the materialized view. When creating a view or materialized view, the owner must have the necessary permissions to access the underlying base relations of the view or materialized view that they are creating. With these permissions, the owner can publish a view or materialized view that other users can access, assuming they have been granted access to the view or materialized view.</p>
                     <p>Using materialized views with Virtual Private Database is similar. When you create a materialized view, there must not be any VPD policies in effect against the base relations of the materialized view for the owner of the materialized view. If any VPD policies exist, then you must use the <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause when creating the materialized view. The owner of the materialized view may establish a VPD policy on the new materialized view. Users who access the materialized view are subject to the VPD policy on the materialized view. However, they are not additionally subject to the VPD policies of the underlying base relations of the materialized view, because security processing of the underlying base relations is performed against the owner of the materialized view.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE">Using Query Rewrite with Virtual Private Database</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034">Restrictions with Materialized Views and Virtual Private Database</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8253"></a><div class="props_rev_3"><a id="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" name="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE"></a><h5 id="DWHSG-GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" class="sect5"><span class="enumeration_section">6.4.1.1 </span>Using Query Rewrite with Virtual Private Database
                     </h5>
                     <div>
                        <p>When you <a id="d25854e1550" class="indexterm-anchor"></a>access a materialized view using query rewrite, the materialized view serves as an access structure much like an index. As such, the security implications for materialized views accessed in this way are much the same as for indexes: all security checks are performed against the relations specified in the request query. The index or materialized view is used to speed the performance of accessing the data, not provide any additional security checks. Thus, the presence of the index or materialized view presents no additional security checking.
                        </p>
                        <p>This holds true when you are accessing a materialized view using query rewrite in the presence of VPD. The request query is subject to any VPD policies that are present against the relations specified in the query. Query rewrite may rewrite the query to use a materialize view instead of accessing the detail relations, but only if it can guarantee to deliver exactly the same rows as if the rewrite had not occurred. Specifically, query rewrite must retain and respect any VPD policies against the relations specified in the request query. However, any VPD policies against the materialized view itself do not have effect when the materialized view is accessed using query rewrite. This is because the data is already protected by the VPD policies against the relations in the request query.</p>
                     </div>
                  </div><a id="DWHSG8254"></a><div class="props_rev_3"><a id="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" name="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034"></a><h5 id="DWHSG-GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" class="sect5"><span class="enumeration_section">6.4.1.2 </span>Restrictions with Materialized Views and Virtual Private Database
                     </h5>
                     <div>
                        <div class="section">
                           <p>Query <a id="d25854e1580" class="indexterm-anchor"></a>rewrite does not use its full and partial text match modes with request queries that include relations with active VPD policies, but it does use general rewrite methods. This is because VPD transparently transforms the request query to affect the VPD policy. If query rewrite were to perform a text match transformation against a request query with a VPD policy, the effect would be to negate the VPD policy.
                           </p>
                           <p>In addition, when you create or refresh a materialized view, the owner of the materialized view must not have any active VPD policies in effect against the base relations of the materialized view, or an error is returned. The materialized view owner must either have no such VPD policies, or any such policy must return <code class="codeph">NULL</code>. This is because VPD would transparently modify the defining query of the materialized view such that the set of rows contained by the materialized view would not match the set of rows indicated by the materialized view definition.
                           </p>
                           <p>One way to work around this restriction yet still create a materialized view containing the desired VPD-specified subset of rows is to create the materialized view in a user account that has no active VPD policies against the detail relations of the materialized view. In addition, you can include a predicate in the <code class="codeph">WHERE</code> clause of the materialized view that embodies the effect of the VPD policy. When query rewrite attempts to rewrite a request query that has that VPD policy, it matches up the VPD-generated predicate on the request query with the predicate you directly specify when you create the materialized view.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8250"></a><div class="props_rev_3"><a id="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" name="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF"></a><h3 id="DWHSG-GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" class="sect3"><span class="enumeration_section">6.5 </span>Invalidating Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1617" class="indexterm-anchor"></a><a id="d25854e1621" class="indexterm-anchor"></a>Dependencies related to materialized views are automatically maintained to ensure correct operation. When a materialized view is created, the materialized view depends on the detail tables referenced in its definition. Any DML operation, such as an <code class="codeph">INSERT</code>, or <code class="codeph">DELETE</code>, <code class="codeph">UPDATE</code>, or DDL operation on any dependency in the materialized view will cause it to become invalid. To revalidate a materialized view, use the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">COMPILE</code> statement.
                     </p>
                     <p>A materialized view is automatically revalidated when it is referenced. In many cases, the materialized view will be successfully and transparently revalidated. However, if a column has been dropped in a table referenced by a materialized view or the owner of the materialized view did not have one of the query rewrite privileges and that privilege has now been granted to the owner, you should use the following statement to revalidate the materialized view:</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW mview_name COMPILE;
</pre><p>The state of a materialized view can be checked by querying the data dictionary views <code class="codeph">USER_MVIEWS</code> or <code class="codeph">ALL_MVIEWS</code>. The column <code class="codeph">STALENESS</code> will show one of the values <code class="codeph">FRESH</code>, <code class="codeph">STALE</code>, <code class="codeph">UNUSABLE</code>, <code class="codeph">UNKNOWN</code>, <code class="codeph">UNDEFINED</code>, or <code class="codeph">NEEDS_COMPILE</code> to indicate whether the materialized view can be used. The state is maintained automatically. However, if the staleness of a materialized view is marked as <code class="codeph">NEEDS_COMPILE</code>, you could issue an <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ... <code class="codeph">COMPILE</code> statement to validate the materialized view and get the correct staleness state. If the state of a materialized view is <code class="codeph">UNUSABLE</code>, you must perform a complete refresh to bring the materialized view back to the <code class="codeph">FRESH</code> state. If the materialized view is based on a prebuilt table that you never refresh, you must drop and re-create the materialized view. The staleness of remote materialized views is not tracked. Thus, if you use remote materialized views for rewrite, they are considered to be trusted.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8255"></a><div class="props_rev_3"><a id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" name="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E"></a><h3 id="DWHSG-GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" class="sect3"><span class="enumeration_section">6.6 </span>Altering Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1727" class="indexterm-anchor"></a>The following modifications can be made to a materialized view:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Change its refresh option (<code class="codeph">FAST/FORCE/COMPLETE/NEVER</code>).
                           </p>
                        </li>
                        <li>
                           <p>Change its refresh mode (<code class="codeph">ON</code> <code class="codeph">COMMIT/ON</code> <code class="codeph">DEMAND</code>).
                           </p>
                        </li>
                        <li>
                           <p>Recompile it.</p>
                        </li>
                        <li>
                           <p>Enable or disable its use for query rewrite.</p>
                        </li>
                        <li>
                           <p>Consider it fresh.</p>
                        </li>
                        <li>
                           <p>Partition maintenance operations.</p>
                        </li>
                        <li>
                           <p>Enable on-query computation</p>
                        </li>
                     </ul>
                     <p>All other changes are achieved by dropping and then re-creating the materialized view. The success of a modification operation depends on whether the requirement for the change is satisfied. For example, a fast refresh succeeds if materialized view logs exist on all the base tables.</p>
                     <p>The <code class="codeph">COMPILE</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement can be used when the materialized view has been invalidated. This compile process is quick, and allows the materialized view to be used by query rewrite again.
                     </p>
                     <div class="infoboxnotealso" id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E__GUID-FE37E5E9-CD02-4786-BA38-AE9F48C02595">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/SQL-Statements-ALTER-LIBRARY-to-ALTER-SESSION.html#SQLRF009" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for further information about the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">Invalidating Materialized Views</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0702359B-D379-4299-86C4-2958BCD4381D" name="GUID-0702359B-D379-4299-86C4-2958BCD4381D"></a><h3 id="DWHSG-GUID-0702359B-D379-4299-86C4-2958BCD4381D" class="sect3"><span class="enumeration_section">6.7 </span>Using Real-time Materialized Views
               </h3>
               <div>
                  <p>Real-time materialized views provide fresh data to user queries even when the materialized view is marked as stale.</p>
                  <div class="infoboxnotealso" id="GUID-0702359B-D379-4299-86C4-2958BCD4381D__GUID-5884C45D-BD87-448E-AED6-E780C02360AD">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" title="A real-time materialized view is a type of materialized view that provides fresh data to user queries even when the materialized view is not in sync with its base tables because of data changes.">Overview of Real-time Materialized Views</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" title="To create a real-time materialized view, use the ON QUERY COMPUTATION clause in the CREATE MATERIALIZED VIEW statement.">Creating Real-time Materialized Views</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" title="If the prerequisites for a real-time materialized view are met, then an existing materialized view can be converted into a real-time materialized view by altering its definition and enabling on-query computation.">Converting an Existing Materialized View into a Real-time Materialized View</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" title="For the query rewrite mechanism to rewrite a user query to use real-time materialized views, query rewrite must be enabled for the real-time materialized view.">Enabling Query Rewrite to Use Real-time Materialized Views</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="Query rewrite can use a real-time materialized view to provide results to user queries, even if the real-time materialized view is stale, if query rewrite is enabled for the real-time materialized view. A nested real-time materialized view is eligible for query rewrite only if all its base real-time materialized views are fresh.">Using Real-time Materialized Views During Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="You can access a real-time materialized view directly by referencing the name of the real-time materialized view in a query.">Using Real-time Materialized Views for Direct Query Access</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-84838620-20F6-4929-85BD-FCB2D9603710" title="The ON_QUERY_COMPUTATION column in the data dictionary views ALL_MVIEWS, DBA_MVIEWS, and USER_MVIEWS indicates if a materialized view is a real-time materialized view.">Listing Real-time Materialized Views</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" title="To obtain better performance for user queries that use a real-time materialized view, you can follow certain guidelines.">Improving Real-time Materialized Views Performance</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" name="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E"></a><h4 id="DWHSG-GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" class="sect4"><span class="enumeration_section">6.7.1 </span>Overview of Real-time Materialized Views
                  </h4>
                  <div>
                     <p>A real-time materialized view is a type of materialized view that provides fresh data to user queries even when the materialized view is not in sync with its base tables because of data changes.</p>
                     <p>Unless a SQL session is set to stale tolerated mode, a materialized view that is marked stale cannot be used for query rewrite. Organizations that require real-time data typically use the <code class="codeph">ON COMMIT</code> refresh mode to ensure that the materialized view is updated with changes made to the base tables. However, when DML changes to the base tables are huge and very frequent, this mode may result in resource contention and reduced refresh performance. Real-time materialized views provide a lightweight solution for obtaining fresh data from stale materialized views by recomputing the data on the fly.
                     </p>
                     <p>Real-time materialized views can use any available out-of-place refresh method including log-based or PCT based refresh. They can be used either with on demand or scheduled automatic refresh, but not with automatic refresh specified using the <code class="codeph">ON COMMIT</code> clause.  
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-7BF29E2F-BE91-44CD-B756-77D8C564D819">Advantages of Real-time Materialized Views</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Provides improved availability for materialized views</p>
                           </li>
                           <li>
                              <p>Provides fresh data for user queries that access a materialized view that may be stale</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-3A57CD0F-6878-4803-A912-F175BA445E66">How Do Real-time Materialized Views Work?</p>
                        <p>Real-time materialized views use a technique called <span class="italic">on-query computation</span> to provide fresh data with stale materialized views. When a query accesses a real-time materialized view, Oracle Database first checks if the real-time materialized view is marked as stale. If it is not stale, then the required data is provided using the real-time materialized view as it is. If the real-time materialized view is marked as stale, then the on-query computation technique is used to generate the fresh data and return the correct query result.
                        </p>
                        <p>Real-time materialized views use a technique that is similar log-based refresh to provide fresh data with stale materialized view. They combine the existing data with the changes that are recorded in change logs to obtain the latest data. However, unlike log-based refresh, real-time materialized views do not use the materialized view logs to update the data in the real-time materialized view. Instead, when a query accesses a stale real-time materialized view, the data that is recomputed using on-query computation is used directly to answer the query.</p>
                        <p>A real-time materialized view is created by using the <code class="codeph">ON QUERY COMPUTATION</code> clause in the materialized view definition.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" name="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA"></a><h5 id="DWHSG-GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" class="sect5"><span class="enumeration_section">6.7.1.1 </span>Restrictions on Using Real-time Materialized Views
                     </h5>
                     <div>
                        <p>Using real-time materialized views is subject to certain restrictions.</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Real-time materialized views cannot be used when:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>one or more materialized view logs created on the base tables are either unusable or nonexistent.</p>
                                 </li>
                                 <li>
                                    <p>out-of-place, log-based or PCT refresh is not feasible for the change scenarios.</p>
                                 </li>
                                 <li>
                                    <p>automatic refresh is specified using the <code class="codeph">ON COMMIT</code> clause.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>If a real-time materialized view is a nested materialized view that is defined on top of one or more base materialized views, then query rewrite occurs only if all the base materialized views are fresh. If one or more base materialized views are stale, then query rewrite is not performed using this real-time materialized view.</p>
                           </li>
                        </ul>
                        <p>The cursors of queries that directly access real-time materialized views are not shared.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" name="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0"></a><h5 id="DWHSG-GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" class="sect5"><span class="enumeration_section">6.7.1.2 </span>About Accessing Real-time Materialized Views
                     </h5>
                     <div>
                        <p>As with materialized views, multiple methods exist to access data stored in real-time materialized views.</p>
                        <p></p>
                        <p>Data stored in real-time materialized views can be accessed in one of the following ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Query rewrite</p>
                              <p>A user query that is similar to the real-time materialized view definition is rewritten to use the real-time materialized view.</p>
                           </li>
                           <li>
                              <p>Direct access of real-time materialized views</p>
                              <p>A user query directly references the real-time materialized view by using its name.</p>
                           </li>
                        </ul>
                        <p>In both scenarios, the content of a real-time materialized view can be accessed as stale data or can trigger an on-query computation of the correct result. Whether or not on-query computation is triggered depends on the environment and the actual SQL statement.</p>
                        <p>The output of the <code class="codeph">EXPLAIN PLAN</code> statement contains messages indicating if on-query computation was used for a particular user query.
                        </p>
                        <div class="infoboxnotealso" id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0__GUID-35FE7EF7-6975-4FC2-9FCC-A76DB3984952">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="You can access a real-time materialized view directly by referencing the name of the real-time materialized view in a query.">Using Real-time Materialized Views for Direct Query Access</a></p>
                              </li>
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="Query rewrite can use a real-time materialized view to provide results to user queries, even if the real-time materialized view is stale, if query rewrite is enabled for the real-time materialized view. A nested real-time materialized view is eligible for query rewrite only if all its base real-time materialized views are fresh.">Using Real-time Materialized Views During Query Rewrite</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" name="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92"></a><h4 id="DWHSG-GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" class="sect4"><span class="enumeration_section">6.7.2 </span>Creating Real-time Materialized Views
                  </h4>
                  <div>
                     <p>To create a real-time materialized view, use the<code class="codeph"> ON QUERY COMPUTATION</code> clause in the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement.
                     </p>
                     <div class="section">
                        <p>You can create real-time materialized views even if they are not applicable for on-query computation for all change scenarios. The minimum requirement to create a real-time materialized view is that it supports out-of-place refresh for <code class="codeph">INSERT</code> operations. If other change scenarios, such as mixed DML operations, are encountered, then on-query computation may not be feasible for all types of real-time materialized views.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>Real-time materialized view must use an out-of-place log-based refresh mechanism (including PCT refresh). The <code class="codeph">ON COMMIT</code> refresh mode cannot be used for real-time materialized views.
                        </p>
                        <p><span class="bold">To create a real-time materialized view:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>Ensure that materialized view logs exist on all the base tables of the real-time materialized view.</span></li>
                        <li><span>Create materialized view logs for all the tables on which the real-time materialized view is based.</span></li>
                        <li><span>Create the real-time materialized view by including the <code class="codeph">ENABLE ON QUERY COMPUTATION</code> clause in the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement.</span></li>
                     </ol>
                     <div class="example" id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92__GUID-31E0354C-A993-43AF-949B-961571DF5243">
                        <p class="titleinexample">Example 6-7 Creating a Real-time Materialized View</p>
                        <p>This example creates a real-time materialized view called <code class="codeph">SUM_SALES_RTMV</code> which is based on data aggregated from the <code class="codeph">SALES</code> and <code class="codeph">PRODUCTS</code> tables in the <code class="codeph">SH</code> schema. Before you create the real-time materialized view ensure that the required prerequisites are met.
                        </p>
                        <ol>
                           <li>
                              <p>Create materialized view logs on the base tables <code class="codeph">SALES</code> and <code class="codeph">PRODUCTS</code>.
                              </p>
                              <p>The following command creates a materialized view log on the <code class="codeph">SALES</code> table:
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW LOG ON sales
WITH SEQUENCE, ROWID
(prod_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</code></pre><p>The following command creates a materialized view log on the <code class="codeph">PRODUCTS</code> table. 
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW LOG ON products 
WITH ROWID
(prod_id, prod_name, prod_category, prod_subcategory)
INCLUDING NEW VALUES;
</code></pre></li>
                           <li>
                              <p>Create a real-time materialized view by including the <code class="codeph">ON QUERY COMPUTATION</code> clause in the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement. The fast refresh method is used for this real-time materialized view and the <code class="codeph">ENABLE QUERY REWRITE</code> clause indicates that query rewrite must be enabled. 
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW sum_sales_rtmv
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE
ENABLE ON QUERY COMPUTATION
AS
SELECT prod_name, SUM(quantity_sold) AS sum_qty, COUNT(quantity_sold) AS cnt_qty, SUM(amount_sold) AS sum_amt, 
     COUNT(amount_sold) AS cnt_amt, COUNT(*) AS cnt_star
FROM sales, products
WHERE sales.prod_id = products.prod_id
GROUP BY prod_name;
</code></pre></li>
                        </ol>
                        <p>After the <code class="codeph">SUM_SALES_RTMV</code> real-time materialized view is created, assume that the following query is run.
                        </p><pre class="pre codeblock"><code>SELECT prod_name, SUM(quantity_sold), SUM(amount_sold)
FROM sales, products
WHERE sales.prod_id = products.prod_id
GROUP BY prod_name;</code></pre><p>If <code class="codeph">SUM_SALES_RTMV</code> is not stale, then the query result is returned using the data stored in this real-time materialized view. However, if <code class="codeph">SUM_SALES_RTMV</code> is stale and the cost of rewriting the query using the materialized view with on-query computation is lower than the base table access, then the query is answered by combining the delta changes in the materialized view logs on the <code class="codeph">SALES</code> and <code class="codeph">PRODUCTS</code> tables with the data in the real-time materialized view <code class="codeph">SUM_SALES_RTMV</code>.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" name="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0"></a><h4 id="DWHSG-GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" class="sect4"><span class="enumeration_section">6.7.3 </span>Converting an Existing Materialized View into a Real-time Materialized View
                  </h4>
                  <div>
                     <p>If the prerequisites for a real-time materialized view are met, then an existing materialized view can be converted into a real-time materialized view by altering its definition and enabling on-query computation.</p>
                     <div class="section">
                        <p><span class="bold">To convert a materialized view into a real-time materialized view:</span> 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>Modify the materialized view definition and enable on-query computation by using the <code class="codeph">ON QUERY COMPUTATION</code> clause in the <code class="codeph">ALTER MATERIALIZED VIEW</code> statement.</span></li>
                     </ul>
                     <div class="section">
                        <p>You can convert a real-time materialized view into a regular materialized view by disabling on-query computation using the <code class="codeph">DISABLE ON QUERY COMPUTATION</code> clause in the <code class="codeph">ALTER MATERIALIZED VIEW</code> statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0__GUID-5DD6FF33-5D45-416B-946C-CA44A3772F37">
                        <p class="titleinexample">Example 6-8 Converting a Materialized View into a Real-time Materialized View</p>
                        <p>The materialized view <code class="codeph">SALES_RTMV</code> is based on the <code class="codeph">SALES</code>, <code class="codeph">TIMES</code>, and <code class="codeph">PRODUCTS</code> tables and uses fast refresh. Materialized view logs exist on all three base tables. You want to modify this materialized view and convert it into a real-time materialized view.
                        </p>
                        <ol>
                           <li>
                              <p>Modify the materialized view definition and include the <code class="codeph">ON QUERY COMPUTATION</code> clause to change it into a real-time materialized view.
                              </p><pre class="pre codeblock"><code>ALTER MATERIALIZED VIEW sales_rtmv ENABLE ON QUERY COMPUTATION;</code></pre></li>
                           <li>
                              <p>Query the <code class="codeph">DBA_MVIEWS</code> view to determine if on-query computation is enabled for <code class="codeph">SALES_RTMV</code>.
                              </p><pre class="pre codeblock"><code><code class="codeph">SELECT mview_name, on_query_computation</code><code class="codeph">
FROM dba_mviews
WHERE mview_name = 'SALES_RTMV';</code></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" name="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73"></a><h4 id="DWHSG-GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" class="sect4"><span class="enumeration_section">6.7.4 </span>Enabling Query Rewrite to Use Real-time Materialized Views
                  </h4>
                  <div>
                     <p>For the query rewrite mechanism to rewrite a user query to use real-time materialized views, query rewrite must be enabled for the real-time materialized view.</p>
                     <div class="section">
                        <p>You can enable query rewrite for a real-time materialized view either at creation time or subsequently, by modifying the definition of the real-time materialized view. The <code class="codeph">ENABLE QUERY REWRITE</code> clause is used to enable query rewrite.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>To enable query rewrite for an existing real-time materialized view:</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>Run the <code class="codeph">ALTER MATERIALIZED VIEW</code> command and include the <code class="codeph">ENABLE QUERY REWRITE</code> clause.</span></li>
                     </ul>
                     <div class="example" id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73__GUID-38AD3618-6915-4945-93AE-EC59DBF517BC">
                        <p class="titleinexample">Example 6-9 Enabling Query Rewrite for Real-time Materialized Views</p>
                        <p>The real-time materialized view <code class="codeph">my_rtmv</code> uses the fast refresh mechanism. You want to modify the definition of this real-time materialized view and specify that the query rewrite mechanism must consider this real-time materialized view while rewriting queries.
                        </p>
                        <p>The following command enables query rewrite for <code class="codeph">my_rtmv</code>:
                        </p><code class="codeph">ALTER MATERIALIZED VIEW my_rtmv ENABLE QUERY REWRITE;</code></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" name="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4"></a><h4 id="DWHSG-GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" class="sect4"><span class="enumeration_section">6.7.5 </span>Using Real-time Materialized Views During Query Rewrite
                  </h4>
                  <div>
                     <p>Query rewrite can use a real-time materialized view to provide results to user queries, even if the real-time materialized view is stale, if query rewrite is enabled for the real-time materialized view. A nested real-time materialized view is eligible for query rewrite only if all its base real-time materialized views are fresh.</p>
                     <div class="section">
                        <p>When a user query is run, query rewrite first checks if a fresh materialized view is available to provide the required data. If a suitable materialized view does not exist, then query rewrite looks for a real-time materialized view that can be used to rewrite the user query. A fresh materialized view is preferred over a real-time materialized view because some overhead is incurred in computing fresh data for real-time materialized view. Next, the cost based optimizer determines the cost of the SQL query with on-query computation and then decides if the real-time materialized view will be used to answer this user query. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>If the <code class="codeph">QUERY_REWRITE_INTEGRITY</code> mode of the current SQL session is set to <code class="codeph">STALE_TOLERATED</code>, then on-query computation will not be used during query rewrite. The <code class="codeph">STALE_TOLERATED</code> rewrite mode indicates that fresh results are not required to satisfy a query, so on-query computation is not necessary.
                        </p>
                        <p><span class="bold">For query rewrite to use a real-time materialized view:</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Ensure that <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is set to either <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> mode. <code class="codeph">QUERY_REWRITE_INTEGRITY</code> mode should not be set to <code class="codeph">STALE_TOLERATED</code> mode.</span></li>
                        <li class="stepexpand"><span>Run a user query that matches the SQL query that was used to define the real-time materialized view.</span><div>
                              <p>Any query that can be rewritten to take advantage of a real-time materialized view will use the real-time materialized view with on-query computation. </p>
                              <p>Use <code class="codeph">EXPLAIN PLAN</code> to verify that the query was rewritten using the real-time materialized view.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4__GUID-B4B383C0-0ACF-4E5E-B4EC-08DEBD4A43B1">
                        <p class="titleinexample">Example 6-10 Using Real-time Materialized Views During Query Rewrite</p>
                        <p>This example creates a real-time materialized view with query rewrite enabled and then demonstrates that it was used by query rewrite to provide data for a user query.</p>
                        <ol>
                           <li>
                              <p>Create a materialized view log on the <code class="codeph">SALES</code> table, which is the base table for the real-time materialized view being created.
                              </p>
                           </li>
                           <li>
                              <p>Create a real-time materialized view <code class="codeph">mav_sum_sales</code> with query rewrite enabled.
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW mav_sum_sales
REFRESH FAST ON DEMAND
ENABLE ON QUERY COMPUTATION
ENABLE QUERY REWRITE
AS 
SELECT prod_id, sum(quantity_sold) as sum_qty, count(quantity_sold) as cnt_qty, 
       sum(amount_sold) sum_amt, count(amount_sold) cnt_amt, count(*) as cnt_star
FROM sales
GROUP BY prod_id;</code></pre></li>
                           <li>
                              <p>Run the following query:</p><pre class="pre codeblock"><code>SELECT prod_id, sum(quantity_sold), sum(amount_sold)
FROM  sales
WHERE prod_id &lt; 1000
GROUP BY prod_id;
</code></pre><p>Observe that the query is similar to the one used to define the real-time materialized view <code class="codeph">mav_sum_sales</code>. Because no other materialized view with a definition that is similar to the query exists, query rewrite can use the <code class="codeph">mav_sum_sales</code> real-time materialized view to determine the query result. You can verify that query rewrite has taken place by checking the SQL cursor cache (for example, with <code class="codeph">DBMS_XPLAN</code>), using SQL Monitor, or using <code class="codeph">EXPLAIN PLAN</code>.
                              </p>
                              <p>The internally rewritten query that uses <code class="codeph">mav_sum_sales</code> is analogous to the following statement:
                              </p><pre class="pre codeblock"><code>SELECT prod_id, sum_qty, sum_amt
FROM  mav_sum_sales
WHERE prod_id &lt; 1000;</code></pre></li>
                           <li>
                              <p>Verify that the real-time materialized view was used to provide the query result. Use the <code class="codeph">EXPLAIN PLAN</code> statement to view the execution plan for the query.
                              </p>
                              <p>The following execution plan shows direct access to the real-time materialized view. If the materialized view is stale, then the execution plan will become more complex and include access to other objects (for example, the materialized view logs), depending on the outstanding DML operations.</p><pre class="pre codeblock"><code>EXPLAIN PLAN for SELECT prod_id, sum(quantity_sold), sum(amount_sold) FROM sales WHERE prod_id &lt; 1000 GROUP BY prod_id;
SELECT plan_table_output FROM table(dbms_xplan.display('plan_table',null,'serial'));

PLAN_TABLE_OUTPUT
-----------------------------------------------------------------------------------------------
Plan hash value: 13616844
-----------------------------------------------------------------------------------------------
| Id  | Operation             | Name          | Rows  | Bytes | Cost (%CPU) | Time      |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT      |               | 92    | 3588  | 3  (0)      | 00:00:01  |
| *1  | MAT_VIEW ACCESS FULL  | MAV_SUM_SALES | 92    | 3588  | 3  (0)      | 00:00:01  |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("PROD_ID"&lt;1000)

Note
-----
   - dynamic statistics used: dynamic sampling (level=2)

17 rows selected.</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" name="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E"></a><h4 id="DWHSG-GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" class="sect4"><span class="enumeration_section">6.7.6 </span>Using Real-time Materialized Views for Direct Query Access 
                  </h4>
                  <div>
                     <p>You can access a real-time materialized view directly by referencing the name of the real-time materialized view in a query. </p>
                     <div class="section">
                        <p>If the real-time materialized view specified in a user query is fresh, then the required data is directly fetched from the real-time materialized view. If the real-time materialized view is stale, then you must use the <code class="codeph">FRESH_MV</code> hint to perform on-query computation and obtain fresh data. Oracle Database does not automatically perform on-query computation for a real-time materialized view that is accessed directly in a user query.
                        </p>
                        <p>To obtain fresh data from a stale real-time materialized view when directly accessing the real-time materialized view:</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>Use the <code class="codeph">FRESH_MV</code> hint in the user query to indicate that on-query computation must be performed.</span></li>
                     </ul>
                     <div class="example" id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E__GUID-6D715D37-9A73-4C5C-8AA7-5EC1892DA477">
                        <p class="titleinexample">Example 6-11 Creating a Real-Time Materialized View and Using it in Queries</p>
                        <p>This example creates a real-time materialized view <code class="codeph">MY_RTMV</code> that is based on the <code class="codeph">SALES_NEW</code> table. The <code class="codeph">SALES_NEW</code> table is created as a copy of the <code class="codeph">SH.SALES</code> table. A row is inserted into the base table after the real-time materialized view is created. Next the <code class="codeph">fresh_mv</code> hint is used to access fresh data from the real-time materialized view by using the materialized view name in a user query.
                        </p>
                        <ol>
                           <li>
                              <p>Create a materialized view log on the base table <code class="codeph">sales_new</code>.
                              </p>
                              <p>Materialized view logs on the base table are mandatory for creating real-time materialized views. </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW LOG on sales_new 
WITH sequence, ROWID (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold) 
INCLUDING NEW VALUES;</code></pre></li>
                           <li>
                              <p>Create a real-time materialized view called <code class="codeph">my_rtmv</code> with <code class="codeph">sales_new</code> as the base table.
                              </p>
                              <p>The <code class="codeph">ON QUERY COMPUTATION</code> clause indicates that a real-time materialized view is created. The refresh mode specified is log-based fast refresh. Query rewrite is enabled for the real-time materialized view.
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW my_rtmv 
REFRESH FAST 
ENABLE ON QUERY COMPUTATION
ENABLE QUERY REWRITE 
AS  
SELECT prod_id, cust_id, channel_id, sum(quantity_sold) sum_q, count(quantity_sold) cnt_q, avg(quantity_sold) avg_q, 
		sum(amount_sold) sum_a, count(amount_sold) cnt_a, avg(amount_sold) avg_a 
FROM sales_new
GROUP BY prod_id, cust_id, channel_id;</code></pre></li>
                           <li>
                              <p>Insert a row into <code class="codeph">sales_new</code>, the base table of the real-time materialized view and commit this change.
                              </p><pre class="pre codeblock"><code>INSERT INTO sales_new (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold) 
	VALUES (116,100450, sysdate,9,9999,10,350);

COMMIT;</code></pre></li>
                           <li>
                              <p>Query the real-time materialized view directly to display data for the row that was added to the real-time materialized view’s base table in the previous step.</p><pre class="pre codeblock"><code>SELECT * from my_rtmv 
WHERE prod_id = 116 AND cust_id=100450 AND channel_id = 9;

PROD_ID   CUST_ID   CHANNEL_ID   SUM_Q   CNT_Q    AVG_Q    SUM_A    CNT_A    AVG_A
-------   -------   ----------   -----   -----    -----    -----    -----    ------
116       100450    9            1       1        1        11.99    1        11.99

</code></pre><p>Note that the query result does not display the updated value for this data. This is because the real-time materialized view has not yet been refreshed with the changes made to its base table.</p>
                           </li>
                           <li>
                              <p>Include the <code class="codeph">FRESH_MV</code> hint while querying the real-time materialized view to display the row updated in the base table. 
                              </p><pre class="pre codeblock"><code>SELECT /*+ fresh_mv */ * FROM my_rtmv 
WHERE prod_id = 116 AND cust_id=100450 AND channel_id = 9;

PROD_ID   CUST_ID   CHANNEL_ID  SUM_Q   CNT_Q   AVG_Q    SUM_A    CNT_A    AVG_A
-------   -------   ----------  -----   -----   -----    -----    -----    ------
116       100450    9           11      2       5.5      361.99   2        180.995
</code></pre><p>Notice that this time the updated row is displayed. This is because the <code class="codeph">FRESH_MV</code> hint triggers on-query computation for the real-time materialized view and recomputed the fresh data.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-84838620-20F6-4929-85BD-FCB2D9603710" name="GUID-84838620-20F6-4929-85BD-FCB2D9603710"></a><h4 id="DWHSG-GUID-84838620-20F6-4929-85BD-FCB2D9603710" class="sect4"><span class="enumeration_section">6.7.7 </span>Listing Real-time Materialized Views
                  </h4>
                  <div>
                     <p>The <code class="codeph">ON_QUERY_COMPUTATION</code> column in the data dictionary views <code class="codeph">ALL_MVIEWS</code>, <code class="codeph">DBA_MVIEWS</code>, and <code class="codeph">USER_MVIEWS</code> indicates if a materialized view is a real-time materialized view. 
                     </p>
                     <div class="section">
                        <p>A value of Y in the <code class="codeph">ON_QUERY_COMPUTATION</code> column indicates a real-time materialized view.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">To list all real-time materialized views in your user schema:</div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>Query the <code class="codeph">USER_MVIEWS</code> view and display details of the materialized view with the <code class="codeph">ON_QUERY_COMPUTATION</code> column set to Y.</span></li>
                     </ul>
                     <div class="example" id="GUID-84838620-20F6-4929-85BD-FCB2D9603710__GUID-3E8E705C-34BC-4668-9B9E-9CDD71FD5227">
                        <p class="titleinexample">Example 6-12 Listing Real-time Materialized Views in the Current User’s Schema</p><pre class="pre codeblock"><code>SELECT owner, mview_name, rewrite_enabled, staleness
FROM user_mviews
WHERE on_query_computation = 'Y';

OWNER   MVIEW_NAME        REWRITE_ENABLED   STALENESS
------  ------------    ------------------- ------------
SH      SALES_RTMV          N               FRESH
SH      MAV_SUM_SALES       Y               FRESH
SH      MY_SUM_SALES_RTMV   Y               FRESH
SH      NEW_SALES_RTMV      Y               STALE</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" name="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5"></a><h4 id="DWHSG-GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" class="sect4"><span class="enumeration_section">6.7.8 </span>Improving Real-time Materialized Views Performance
                  </h4>
                  <div>
                     <p>To obtain better performance for user queries that use a real-time materialized view, you can follow certain guidelines.</p>
                     <p></p>
                     <p>Use the following guidelines with real-time materialized views:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Frequently refresh real-time materialized views to enhance the performance of queries that may use these real-time materialized views.</p>
                           <p>Since real-time materialized views work by combining the delta changes to the base tables with the existing materialized view data, query response time is enhanced when the delta changes to be computed are small. With more outstanding DML operations, on-query computation can become more complex (and expensive), up to the point where direct base table access can become more efficient (in case of query rewrite).</p>
                        </li>
                        <li>
                           <p>Collect statistics for the base tables, the real-time materialized view, and the materialized view logs to enable the optimizer to accurately determine the cost of a query.</p>
                           <p>For query rewrite, the cost-based rewrite mechanism uses the optimizer to determine whether the rewritten query should be used. The optimizer uses statistics to determine the cost.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>