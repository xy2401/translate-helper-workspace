<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Database Concepts</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96466-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="precompiler-concepts.html" title="Previous" type="text/html">
      <link rel="next" href="datatypes-and-host-variables.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="precompiler-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="datatypes-and-host-variables.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name"> Introduction and Concepts </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Database Concepts</li>
            </ol>
            <a id="GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2" name="GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2"></a><a id="LNPCB003"></a>
            
            <h2 id="LNPCB-GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2" class="sect2"><span class="enumeration_chapter">3 </span> Database Concepts
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter explains the CONNECT statement and its options, Oracle Net Services, and related network connection statements. Transaction processing is presented. You learn the basic techniques that safeguard the consistency of your database, including how to control whether changes to Oracle data are made permanent or undone. </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="database-concepts.html#GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304">Connecting to Oracle</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C">Default Databases and Connections</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-E1177148-D3CD-4BD8-9410-960476A6617C">Key Terms</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65">How Transactions Guard a Database</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-B7317C1E-9549-4ACD-884C-35F3628CA825">Beginning and Ending Transactions</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339">Using the COMMIT Statement</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D">Using the ROLLBACK Statement</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B">Using the SAVEPOINT Statement</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4">Using the RELEASE Option</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627">Using the SET TRANSACTION Statement</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC">Overriding Default Locking</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8">Fetching Across Commits</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-123F9392-C594-46DB-A2BB-92A92953C08A">Handling Distributed Transactions</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12">Guidelines for Transaction Processing</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB203"></a><div class="props_rev_3"><a id="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304" name="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304"></a><h3 id="LNPCB-GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304" class="sect3"><span class="enumeration_section">3.1 </span>Connecting to Oracle
               </h3>
               <div>
                  <p>Your Pro*COBOL program must log on to Oracle before querying or manipulating data. To log on, you use the CONNECT statement, as in<a id="d10894e119" class="indexterm-anchor"></a><a id="d10894e121" class="indexterm-anchor"></a><a id="d10894e125" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
         CONNECT :USERNAME IDENTIFIED BY :PASSWD
     END-EXEC. 
</pre><p>where USERNAME and PASSWD are PIC X(<span class="italic">n</span>) or PIC X(<span class="italic">n</span>) VARYING host variables. Alternatively, you can use the statement: 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
         CONNECT :USR-PWD 
     END-EXEC. 
</pre><p>where the host variable USR-PWD contains your username and password separated by a slash (/) followed by an optional tnsnames.ora alias (@TNSALIAS). </p>
                  <p>The syntax for the CONNECT statement has an optional ALTER AUTHORIZATION clause. The complete syntax for CONNECT is shown here:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
        CONNECT { :user IDENTIFIED BY :oldpswd | :usr_psw }
        [[AT { dbname | :host_variable }] USING :connect_string ]
        [ {ALTER AUTHORIZATION :newpswd  | IN {SYSDBA | SYSOPER} MODE} ]
     END-EXEC.
</pre><p>The CONNECT statement must be the first SQL statement executed by the program. That is, other executable SQL statements can positionally, but not logically, precede the CONNECT statement. If the precompiler option AUTO_CONNECT=YES, a CONNECT statement is not needed.)<a id="d10894e149" class="indexterm-anchor"></a><a id="d10894e153" class="indexterm-anchor"></a></p>
                  <p>To supply the username and password separately, you define two host variables as character strings or VARCHAR variables. If you supply a userid containing both username and password, only one host variable is needed.<a id="d10894e159" class="indexterm-anchor"></a><a id="d10894e163" class="indexterm-anchor"></a><a id="d10894e167" class="indexterm-anchor"></a></p>
                  <p>Make sure to set the username and password variables before the CONNECT is executed or it will fail. Your program can prompt for the values or you can hard-code them, as follows:<a id="d10894e173" class="indexterm-anchor"></a><a id="d10894e177" class="indexterm-anchor"></a><a id="d10894e181" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> WORKING STORAGE SECTION. 
     ... 
 01  USERNAME  PIC X(10). 
 01  PASSWD    PIC X(10). 
         ... 
     ... 
 PROCEDURE DIVISION. 
 LOGON. 
     EXEC SQL WHENEVER SQLERROR GOTO LOGON-ERROR END-EXEC. 
     MOVE "SCOTT" TO USERNAME. 
     MOVE "TIGER" TO PASSWD. 
     EXEC SQL 
         CONNECT :USERNAME IDENTIFIED BY :PASSWD 
     END-EXEC. 
</pre><p>However, you cannot hard-code a username and password into the CONNECT statement or use quoted literals. For example, the following statements are <span class="italic">invalid</span>: 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
         CONNECT SCOTT IDENTIFIED BY TIGER 
     END-EXEC. 

     EXEC SQL 
         CONNECT "SCOTT" IDENTIFIED BY "TIGER" 
     END-EXEC.</pre><div class="infoboxnotealso" id="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304__GUID-77CFF8AA-BF7B-499F-9777-FA1EA490138B">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="database-concepts.html#GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3">Changing Passwords at Runtime</a>"</span> for more information about ALTER AUTHORIZATION clause.
                           </p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="database-concepts.html#GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1">SYSDBA or SYSOPER Privileges</a>"</span> for more information about SYSDBA and SYSOPER.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCB204"></a><div class="props_rev_3"><a id="GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C" name="GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C"></a><h3 id="LNPCB-GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C" class="sect3"><span class="enumeration_section">3.2 </span>Default Databases and Connections
               </h3>
               <div>
                  <p>It is possible within a Pro*COBOL program to maintain more than one database connection at the same time. </p>
               </div><a id="LNPCB206"></a><a id="LNPCB205"></a><div class="props_rev_3"><a id="GUID-EE843C17-8881-494C-85CE-8EE4D0833065" name="GUID-EE843C17-8881-494C-85CE-8EE4D0833065"></a><h4 id="LNPCB-GUID-EE843C17-8881-494C-85CE-8EE4D0833065" class="sect4"><span class="enumeration_section">3.2.1 </span>Concurrent Logons
                  </h4>
                  <div>
                     <p><a id="d10894e259" class="indexterm-anchor"></a>Pro*COBOL supports distributed processing through Oracle Net Services. Your application can concurrently access any combination of local and remote databases or make multiple connections to the same database. In <a href="database-concepts.html#GUID-EE843C17-8881-494C-85CE-8EE4D0833065__BHCBICDF">Figure 3-1</a>, an application program communicates with one local and three remote Oracle databases. ORA2, ORA3, and ORA4 are logical names used in CONNECT statements. <a id="d10894e266" class="indexterm-anchor"></a><a id="d10894e270" class="indexterm-anchor"></a><a id="d10894e274" class="indexterm-anchor"></a><a id="d10894e278" class="indexterm-anchor"></a></p>
                     <div class="figure" id="GUID-EE843C17-8881-494C-85CE-8EE4D0833065__BHCBICDF">
                        <p class="titleinfigure">Figure 3-1 Connecting Through Oracle</p><img src="img/pco81045.gif" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" longdesc="img_text/pco81045.html"><br><a href="img_text/pco81045.html">Description of "Figure 3-1 Connecting Through Oracle"</a></div>
                     <!-- class="figure" -->
                     <p>By eliminating the boundaries in a network between different machines and operating systems, Oracle Net Services provides a distributed processing environment for Oracle tools. This section shows you how the Pro*COBOL supports distributed processing through Oracle Net Services. You learn how your application can<a id="d10894e287" class="indexterm-anchor"></a><a id="d10894e291" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Access other databases directly or indirectly </p>
                        </li>
                        <li>
                           <p>Concurrently access any combination of local and remote databases </p>
                        </li>
                        <li>
                           <p>Make multiple connections to the same database</p>
                        </li>
                     </ul>
                     <p>Normally you would need only a single connection, achieved by <code class="codeph">EXEC SQL CONNECT :USR-PWD END-EXEC</code>.   The database that is connected to is determined by what USR-PWD contains. If it contains the username and password for the default database, it will connect to the database defined as the default for the session. If it contains <span class="italic">username</span>/<span class="italic">password</span>@REMDB" it will connect through Oracle Net Services to the REMDB database as defined by your Oracle Net Services configuration. (An alternative is to use the USING clause to specify the Oracle Net Services connection string.) This is the default connection.
                     </p>
                     <p>To make further concurrent connections to either the same or different databases you make use of the AT clause, that is, <code class="codeph">EXEC SQL AT DB1 CONNECT :USR-PWD END-EXEC</code>.   The name after the AT clause uniquely identifies a "nondefault" connection, and any SQL statements with the same name after the AT clause are executed against that connection. If the AT clause is omitted in an SQL statement then the statement is executed against the default connection.<a id="d10894e319" class="indexterm-anchor"></a><a id="d10894e321" class="indexterm-anchor"></a></p>
                     <p>All database names must be unique, but two or more database names can specify the same connection. That is, you can have multiple connections to any database on any node.<a id="d10894e327" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB207"></a><div class="props_rev_3"><a id="GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E" name="GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E"></a><h4 id="LNPCB-GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E" class="sect4"><span class="enumeration_section">3.2.2 </span>Using Username/Password
                  </h4>
                  <div>
                     <p>Usually, you establish a connection to Oracle as follows:<a id="d10894e355" class="indexterm-anchor"></a><a id="d10894e357" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD END-EXEC.
</pre><p>Or you can use: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CONNECT :USR-PWD END-EXEC.<span class="bold"> </span>
</pre><p>where <span class="italic">USR-PWD</span> contains any valid Oracle connect string.
                     </p>
                     <p>These are simplified subsets of the CONNECT statement. For all details, read the next sections in this chapter<a id="d10894e377" class="indexterm-anchor"></a>.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="database-concepts.html#GUID-056EC81F-F05C-4C33-9393-856EF3FADA89">Automatic Logons</a></li>
                           <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-8E024106-6BB5-434C-99A6-1A55839D8316">CONNECT (Executable Embedded SQL Extension)</a></li>
                        </ul>
                     </div>
                  </div><a id="LNPCB208"></a><div class="props_rev_3"><a id="GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9" name="GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9"></a><h5 id="LNPCB-GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9" class="sect5"><span class="enumeration_section">3.2.2.1 </span>Named Database Connections
                     </h5>
                     <div>
                        <p>In the following example, you connect to a named database. Normally you use a named database connection only for multiple concurrent connections. The following example shows the syntax for a single connection:<a id="d10894e415" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">* --  Declare necessary host variables
 WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  USERNAME  PIC X(10) .
 01  PASSWORD  PIC X(10) .
 01  DB-STRING PIC X(20) .
        ...
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...
 PROCEDURE DIVISION.
     MOVE "scott" TO USERNAME.
     MOVE "tiger" TO PASSSWORD.
     MOVE "nyremote" TO DB-STRING.
      ... 
* --  Assign a unique name to the database connection.
     EXEC SQL DECLARE DBNAME DATABASE<span class="bold"> </span>END-EXEC.
* --  Connect to the nondefault database
     EXEC SQL
     CONNECT :USERNAME IDENTIFIED BY :PASSWORD 
     AT DBNAME USING :DB-STRING
     END-EXEC.
</pre><p>The identifiers in this example serve the following purposes: </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The host variables <span class="italic">USERNAME</span> and <span class="italic">PASSWORD</span> identify a valid user. 
                              </p>
                           </li>
                           <li>
                              <p>The host variable <span class="italic">DB-STRING</span> contains the Oracle Net Services syntax for logging on to a nondefault database at a remote node. 
                              </p>
                           </li>
                           <li>
                              <p>The undeclared identifier <span class="italic">DBNAME</span> names a nondefault connection; it is an identifier used by Oracle, <span class="italic">not</span> a host or program variable. 
                              </p>
                           </li>
                        </ul>
                        <p>The USING clause specifies the network, machine, and database to be associated with <span class="italic">DBNAME</span>. Later, SQL statements using the AT clause (with <span class="italic">DBNAME</span>) are executed at the database specified by <span class="italic">DB-STRING</span>.<a id="d10894e462" class="indexterm-anchor"></a><a id="d10894e466" class="indexterm-anchor"></a><a id="d10894e470" class="indexterm-anchor"></a><a id="d10894e474" class="indexterm-anchor"></a> 
                        </p>
                        <p>Alternatively, you can use a character host variable in the AT clause, as the following example shows: </p><pre class="oac_no_warn" dir="ltr">* --  Declare necessary host variables
 WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  USERNAME  PIC X(10).
 01  PASSWORD  PIC X(10).
 01  DB-NAME   PIC X(10).
 01  DB-STRING PIC X(20).
        ...
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...
 PROCEDURE DIVISION.
     MOVE "scott" TO USERNAME.
     MOVE "tiger" TO PASSSWORD.
     MOVE "oracle1" TO DB-NAME.
     MOVE "nyremote" TO DB-STRING.
     ... 
* --  Connect to the nondefault database
     EXEC SQL
     CONNECT :USERNAME IDENTIFIED BY :PASSWORD 
     AT :DB-NAME USING :DB-STRING
     END-EXEC.
</pre><p>If <span class="italic">DB-NAME</span> is a host variable, the DECLARE DATABASE statement is not needed. Only if <span class="italic">DBNAME</span> is an undeclared identifier must you execute a DECLARE <span class="italic">DBNAME</span> DATABASE statement before executing a CONNECT ... AT <span class="italic">DBNAME</span> statement. 
                        </p>
                        <p><span class="bold">SQL Operations. </span>If granted the privilege, you can execute any SQL data manipulation statement at the nondefault connection. For example, you might execute the following sequence of statements: 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT DBNAME SELECT ... 
     EXEC SQL AT DBNAME INSERT ... 
     EXEC SQL AT DBNAME UPDATE ... 
</pre><p>In the next example, <span class="italic">DB-NAME</span> is a host variable: 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME DELETE ... 
</pre><p><span class="bold">Cursor Control. </span>Cursor control statements such as OPEN, FETCH, and CLOSE are exceptionsâ€”they never use an AT clause. If you want to associate a cursor with an explicitly identified database, use the AT clause in the DECLARE CURSOR statement, as follows:<a id="d10894e515" class="indexterm-anchor"></a><a id="d10894e519" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME DECLARE emp_cursor CURSOR FOR ... 
     EXEC SQL OPEN emp_cursor ... 
     EXEC SQL FETCH emp_cursor ... 
     EXEC SQL CLOSE emp_cursor END-EXEC.
</pre><p>If <span class="italic">DB-NAME</span> is a host variable, its declaration must be within the scope of all SQL statements that refer to the declared cursor. For example, if you open the cursor in one subprogram, then fetch from it in another, you must declare <span class="italic">DB-NAME</span> globally or pass it to each subprogram. 
                        </p>
                        <p>When opening, closing, or fetching from the cursor, you do not use the AT clause. The SQL statements are executed at the database named in the AT clause of the DECLARE CURSOR statement or at the default database if no AT clause is used in the cursor declaration. </p>
                        <p>The AT <span class="italic">:host-variable</span> clause enables you to change the connection associated with a cursor. However, you cannot change the association while the cursor is open. Consider the following example:<a id="d10894e541" class="indexterm-anchor"></a><a id="d10894e545" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME DECLARE emp_cursor CURSOR FOR ... 
     MOVE "oracle1" TO DB-NAME.
     EXEC SQL OPEN emp_cursor END-EXEC. 
     EXEC SQL FETCH emp_cursor INTO ... 
     MOVE "oracle2" TO DB-NAME.
* -- illegal, cursor still open 
     EXEC SQL OPEN emp_cursor END-EXEC.
     EXEC SQL FETCH emp_cursor INTO ... 
</pre><p>This is illegal because <span class="italic">emp_cursor</span>  is still open when you try to execute the second OPEN statement. Separate cursors are not maintained for different connections; there is only one <span class="italic">emp_cursor</span>, which must be closed before it can be reopened for another connection. To debug the last example, simply close the cursor before reopening it, as follows: 
                        </p><pre class="oac_no_warn" dir="ltr">* -- close cursor first 
     EXEC SQL CLOSE emp_cursor END-EXEC.
     MOVE "oracle2" TO DB-NAME.
     EXEC SQL OPEN EMP-CUROR END-EXEC. 
     EXEC SQL FETCH emp_cursor INTO ... 
</pre><p><span class="bold">Dynamic SQL</span>. Dynamic SQL statements are similar to cursor control statements in that some never use the AT clause. For dynamic SQL Method 1, you must use the AT clause if you want to execute the statement at a nondefault connection. An example follows:<a id="d10894e566" class="indexterm-anchor"></a><a id="d10894e570" class="indexterm-anchor"></a><a id="d10894e574" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME EXECUTE IMMEDIATE :SQL-STMT END-EXEC.
 </pre><p>For Methods 2, 3, and 4, you use the AT clause only in the DECLARE STATEMENT statement if you want to execute the statement at a nondefault connection. All other dynamic SQL statements such as PREPARE, DESCRIBE, OPEN, FETCH, and CLOSE never use the AT clause. The next example shows Method 2:<a id="d10894e584" class="indexterm-anchor"></a><a id="d10894e588" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC. 
     EXEC SQL PREPARE SQL-STMT FROM :SQL-STRING END-EXEC. 
     EXEC SQL EXECUTE SQL-STMT END-EXEC. 
</pre><p>The following example shows Method 3: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL AT :DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC. 
     EXEC SQL PREPARE SQL-STMT FROM :SQL-STRING END-EXEC. 
     EXEC SQL DECLARE emp_cursor CURSOR FOR SQL-STMT END-EXEC. 
     EXEC SQL OPEN emp_cursor ... 
     EXEC SQL FETCH emp_cursor INTO ... 
     EXEC SQL CLOSE emp_cursor END-EXEC. 
</pre><p>You need not use the AT clause when connecting to a remote database unless you open two or more connections simultaneously (in which case the AT clause is needed to identify the active connection). To make the default connection to a remote database, use the following syntax:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
        CONNECT :USERNAME IDENTIFIED BY :PASSWORD USING :DB-STRING
     END-EXEC.</pre></div>
                  </div>
               </div><a id="LNPCB209"></a><div class="props_rev_3"><a id="GUID-056EC81F-F05C-4C33-9393-856EF3FADA89" name="GUID-056EC81F-F05C-4C33-9393-856EF3FADA89"></a><h4 id="LNPCB-GUID-056EC81F-F05C-4C33-9393-856EF3FADA89" class="sect4"><span class="enumeration_section">3.2.3 </span>Automatic Logons
                  </h4>
                  <div>
                     <p>You can log on to Oracle automatically with the userid:<a id="d10894e628" class="indexterm-anchor"></a><a id="d10894e632" class="indexterm-anchor"></a><a id="d10894e634" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">&lt;prefix&gt;&lt;username&gt; 
</pre><p>where <span class="italic">prefix</span> is the value of the Oracle initialization parameter OS_AUTHENT_PREFIX (the default value is OPS$) and <span class="italic">username</span> is your operating system user or task name. For example, if the prefix is OPS$, your user name is TBARNES, and OPS$TBARNES is a valid Oracle userid, then you log on to Oracle as user OPS$TBARNES. 
                     </p>
                     <p>To take advantage of the automatic logon feature, you simply pass a slash (/) character to Pro*COBOL, as follows: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 ORACLEID   PIC X.
     ...
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
     MOVE '/' TO ORACLEID.
     EXEC SQL CONNECT :ORACLEID END-EXEC. 
</pre><p>This automatically connects you as user OPS$<span class="italic">username</span>. For example, if your operating system username is RHILL, and OPS$RHILL is a valid Oracle username, connecting with a slash (/) automatically logs you on to Oracle as user OPS$RHILL. 
                     </p>
                     <p>You can also pass a character string to Pro*COBOL. However, the string cannot contain trailing blanks. For example, the following CONNECT statement will fail: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
           01 ORACLEID   PIC X(5).
     ...
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
     MOVE '/    ' TO ORACLEID.
     EXEC SQL CONNECT :ORACLEID END-EXEC.</pre></div><a id="LNPCB210"></a><div class="props_rev_3"><a id="GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D" name="GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D"></a><h5 id="LNPCB-GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D" class="sect5"><span class="enumeration_section">3.2.3.1 </span>The AUTO_CONNECT Precompiler Option
                     </h5>
                     <div>
                        <p>Pro*COBOL lets your program log on to the default database without using the CONNECT statement. Simply specify the precompiler option AUTO_CONNECT on the command line.<a id="d10894e685" class="indexterm-anchor"></a><a id="d10894e689" class="indexterm-anchor"></a><a id="d10894e693" class="indexterm-anchor"></a></p>
                        <p>Assume that the default value of OS_AUTHENT_PREFIX is OPS$, your username is TBARNES, and OPS$TBARNES is a valid Oracle userid. When AUTO_CONNECT=YES, as soon as Pro*COBOL encounters an executable SQL statement, your program logs on to Oracle automatically with the userid OPS$TBARNES.</p>
                        <p>When AUTO_CONNECT=NO (the default), you must use the CONNECT statement to log on to Oracle.</p>
                     </div>
                  </div>
               </div><a id="LNPCB211"></a><div class="props_rev_3"><a id="GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3" name="GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3"></a><h4 id="LNPCB-GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3" class="sect4"><span class="enumeration_section">3.2.4 </span>Changing Passwords at Runtime
                  </h4>
                  <div>
                     <p>Pro*COBOL provides client applications with a convenient way to change a user password at runtime through the optional ALTER AUTHORIZATION clause.</p>
                     <p>The syntax for the ALTER AUTHORIZATION clause is shown here:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CONNECT .. ALTER AUTHORIZATION :<span class="italic">NEWPSWD</span> END-EXEC.
</pre><p>Using this clause indicates that you want to change the account password to the value indicated by NEWPSWD. After the change is made, an attempt is made to connect as <code class="codeph">USER</code>/<code class="codeph">NEWPSWD</code>. This can have the following results:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The application will connect without issue.</p>
                        </li>
                        <li>
                           <p>The application will fail to connect. This could be due to either of the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Password verification failed for some reason. In this case the password remains unchanged.</p>
                              </li>
                              <li>
                                 <p>The account is locked. Changes to the password are not permitted.</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCB212"></a><div class="props_rev_3"><a id="GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96" name="GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96"></a><h4 id="LNPCB-GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96" class="sect4"><span class="enumeration_section">3.2.5 </span>Connect Without Alter Authorization
                  </h4>
                  <div>
                     <p>This section describes the possible outcomes of different variations of the CONNECT statement.</p>
                  </div><a id="LNPCB213"></a><div class="props_rev_3"><a id="GUID-61346520-A069-4C41-8BA2-F3140A2C26AC" name="GUID-61346520-A069-4C41-8BA2-F3140A2C26AC"></a><h5 id="LNPCB-GUID-61346520-A069-4C41-8BA2-F3140A2C26AC" class="sect5"><span class="enumeration_section">3.2.5.1 </span>Standard CONNECT
                     </h5>
                     <div>
                        <p>If an application issues the following statement:</p><pre class="oac_no_warn" dir="ltr">      EXEC SQL CONNECT ...   /* No ALTER AUTHORIZATION clause */
</pre><p>it performs a normal connection attempt. The possible results include the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The application will connect without issue.</p>
                           </li>
                           <li>
                              <p>The application will connect, but will receive a password warning. The warning indicates that the password has expired but is in a grace period which will allow logons. At this point, the user is encouraged to change the password before the account becomes locked.</p>
                           </li>
                           <li>
                              <p>The application will fail to connect. Possible causes include the following:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The password is incorrect.</p>
                                 </li>
                                 <li>
                                    <p>The account has expired, and is possibly in a locked state.</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPCB214"></a><div class="props_rev_3"><a id="GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1" name="GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1"></a><h5 id="LNPCB-GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1" class="sect5"><span class="enumeration_section">3.2.5.2 </span>SYSDBA or SYSOPER Privileges
                     </h5>
                     <div>
                        <p>Before Oracle release 8.1 you did not have to use this clause to have the SYSOPER or SYSDBA system privilege, but now you must.</p>
                        <p>Append the following optional string to the CONNECT statement after all other clauses if you want to log on with either SYSDBA or SYSOPER system privileges:</p><pre class="oac_no_warn" dir="ltr">IN { SYSDBA | SYSOPER } MODE
</pre><p>For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ... IN SYSDBA MODE END-EXEC.
</pre><p>Here are the restrictions that apply to this option:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>This option is not supported when using the AUTO_CONNECT=YES precompiler option setting.</p>
                           </li>
                           <li>
                              <p>The option is not permitted when using the ALTER AUTHORIZATION keywords in the CONNECT statement.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB215"></a><div class="props_rev_3"><a id="GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51" name="GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51"></a><h4 id="LNPCB-GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51" class="sect4"><span class="enumeration_section">3.2.6 </span>Using Links
                  </h4>
                  <div>
                     <p>Database links are supported through the Oracle distributed database option. For example, a distributed query allows a single SELECT statement to access data on one or more nondefault databases. <a id="d10894e907" class="indexterm-anchor"></a><a id="d10894e909" class="indexterm-anchor"></a></p>
                     <p>The distributed query facility depends on database links, which assign a name to a CONNECT statement rather than to the connection itself. At runtime, the embedded SELECT statement is executed by the specified database server, which connects implicitly to the nondefault database(s) to get the required data. </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../netag/identifying-and-accessing-database.html#NETAG-GUID-2BDF9E52-4147-4F46-84E2-A5AE1018A373" target="_blank">Connecting to a Database Service</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB216"></a><div class="props_rev_3"><a id="GUID-E1177148-D3CD-4BD8-9410-960476A6617C" name="GUID-E1177148-D3CD-4BD8-9410-960476A6617C"></a><h3 id="LNPCB-GUID-E1177148-D3CD-4BD8-9410-960476A6617C" class="sect3"><span class="enumeration_section">3.3 </span>Key Terms
               </h3>
               <div>
                  <p>Before delving into the subject of transactions, you should know the terms defined in this section.</p>
                  <p>The jobs or tasks that the database manages are called <span class="italic"><span class="bold">sessions</span></span>. A <span class="italic"><span class="bold">user session</span></span> is started when you run an application program or a tool such as Oracle Forms and connect to the database. Oracle enables user sessions to work simultaneously and share computer resources. To do this, Oracle must control <span class="italic"><span class="bold">concurrence</span></span>, the accessing of the same data by many users. Without adequate concurrence controls, there might be a loss of <span class="italic"><span class="bold">data integrity</span></span>. That is, changes to data or structures might be made in the wrong order.<a id="d10894e963" class="indexterm-anchor"></a><a id="d10894e965" class="indexterm-anchor"></a><a id="d10894e968" class="indexterm-anchor"></a><a id="d10894e970" class="indexterm-anchor"></a></p>
                  <p>Oracle uses<span class="italic"><span class="bold"> locks </span></span>to control concurrent access to data. A lock gives you temporary ownership of a database resource such as a table or row of data. Thus, data cannot be changed by other users until you finish with it. You need never explicitly lock a resource, because default locking mechanisms protect table data and structures. However, you can request <span class="italic"><span class="bold">data locks</span></span> on tables or rows when it is to your advantage to override default locking. You can choose from several <span class="italic"><span class="bold">modes</span></span> of locking such as <span class="italic"><span class="bold">row share</span></span> and <span class="italic"><span class="bold">exclusive</span></span>.<a id="d10894e995" class="indexterm-anchor"></a><a id="d10894e997" class="indexterm-anchor"></a><a id="d10894e999" class="indexterm-anchor"></a></p>
                  <p>A <span class="italic"><span class="bold">deadlock</span></span> can occur when two or more users try to access the same database object. For example, two users updating the same table might wait if each tries to update a row currently locked by the other. Because each user is waiting for resources held by another user, neither can continue until the server breaks the deadlock. The server signals an error to the participating transaction that had completed the least amount of work, and the "deadlock detected while waiting for resource" error code is returned to SQLCODE in the SQLCA.<a id="d10894e1009" class="indexterm-anchor"></a></p>
                  <p>When a table is queried by one user and updated by another at the same time, the database generates a <span class="italic"><span class="bold">read consistent</span></span> view of the table's data for the query. That is, once a query begins (and proceeds), the data read by the query does not change. As update activity continues, the database takes <span class="italic"><span class="bold">snapshots</span></span> of the table's data and records changes in a <span class="italic"><span class="bold">rollback segment</span></span>. The database uses information in the rollback segment to build read consistent query results and to undo changes if necessary.<a id="d10894e1025" class="indexterm-anchor"></a><a id="d10894e1027" class="indexterm-anchor"></a><a id="d10894e1029" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB217"></a><div class="props_rev_3"><a id="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65" name="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65"></a><h3 id="LNPCB-GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65" class="sect3"><span class="enumeration_section">3.4 </span>How Transactions Guard a Database
               </h3>
               <div>
                  <p>The database is transaction oriented; it uses transactions to ensure data integrity. A transaction is a series of one or more logically related SQL statements you define to accomplish some task. The database treats the series of SQL statements as a unit so that all the changes brought about by the statements are either <span class="italic">committed</span> (made permanent) or <span class="italic">rolled back</span> (undone) at the same time. If your application program fails in the middle of a transaction, the database is automatically restored to its former (pre-transaction) state.<a id="d10894e1061" class="indexterm-anchor"></a><a id="d10894e1063" class="indexterm-anchor"></a><a id="d10894e1067" class="indexterm-anchor"></a> 
                  </p>
                  <p>The coming sections show you how to define and control transactions. Specifically, it shows how to<a id="d10894e1072" class="indexterm-anchor"></a>: 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Begin and end transactions </p>
                     </li>
                     <li>
                        <p>Use the COMMIT statement to make transactions permanent </p>
                     </li>
                     <li>
                        <p>Use the SAVEPOINT statement with the ROLLBACK TO statement to undo parts of transactions </p>
                     </li>
                     <li>
                        <p>Use the ROLLBACK statement to undo whole transactions </p>
                     </li>
                     <li>
                        <p>Specify the RELEASE option to free resources and log off the database </p>
                     </li>
                     <li>
                        <p>Use the SET TRANSACTION statement to set read-only transactions </p>
                     </li>
                     <li>
                        <p>Use the FOR UPDATE clause or LOCK TABLE statement to override default locking </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65__GUID-0A3729FB-B70B-4196-9660-31542BB8E084">
                     <p class="notep1">See Also:</p><a href="../sqlrf/index.html" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for details about the SQL statements.
                  </div>
               </div>
            </div><a id="LNPCB218"></a><div class="props_rev_3"><a id="GUID-B7317C1E-9549-4ACD-884C-35F3628CA825" name="GUID-B7317C1E-9549-4ACD-884C-35F3628CA825"></a><h3 id="LNPCB-GUID-B7317C1E-9549-4ACD-884C-35F3628CA825" class="sect3"><span class="enumeration_section">3.5 </span>Beginning and Ending Transactions
               </h3>
               <div>
                  <p>You begin a transaction with the first executable SQL statement (other than CONNECT) in your program. When one transaction ends, the next executable SQL statement automatically begins another transaction. Thus, every executable statement is part of a transaction. Because they cannot be rolled back and need not be committed, declarative SQL statements are not considered part of a transaction.<a id="d10894e1129" class="indexterm-anchor"></a><a id="d10894e1133" class="indexterm-anchor"></a><a id="d10894e1137" class="indexterm-anchor"></a> 
                  </p>
                  <p>You end a transaction in one of the following ways:<a id="d10894e1144" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Code a COMMIT or ROLLBACK statement, with or without the RELEASE option. This <span class="italic">explicitly</span> makes permanent or undoes changes to the database.
                        </p>
                     </li>
                     <li>
                        <p>Code a data definition statement (ALTER, CREATE, or GRANT, for example) that issues an automatic commit before <span class="italic">and</span> after executing. This <span class="italic">implicitly</span> makes permanent changes to the database.<a id="d10894e1164" class="indexterm-anchor"></a><a id="d10894e1168" class="indexterm-anchor"></a></p>
                     </li>
                  </ul>
                  <p>A transaction also ends when there is a system failure or your user session stops unexpectedly because of software problems, hardware problems, or a forced interrupt.<a id="d10894e1174" class="indexterm-anchor"></a></p>
                  <p>If your program fails in the middle of a transaction, Oracle detects the error and rolls back the transaction. If your operating system fails, Oracle restores the database to its former (pre-transaction) state.<a id="d10894e1180" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB219"></a><div class="props_rev_3"><a id="GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339" name="GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339"></a><h3 id="LNPCB-GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339" class="sect3"><span class="enumeration_section">3.6 </span>Using the COMMIT Statement
               </h3>
               <div>
                  <p>The COMMIT statement is used to make changes to the database permanent. Until changes are committed, other users cannot access the changed data; they see it as it was before your transaction began. The COMMIT statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the COMMIT statement:<a id="d10894e1209" class="indexterm-anchor"></a><a id="d10894e1211" class="indexterm-anchor"></a><a id="d10894e1215" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Makes permanent all changes made to the database during the current transaction.</p>
                     </li>
                     <li>
                        <p>Makes these changes visible to other users.</p>
                     </li>
                     <li>
                        <p>Erases all savepoints (see the next section).</p>
                     </li>
                     <li>
                        <p>Releases all row and table locks, but not parse locks.</p>
                     </li>
                     <li>
                        <p>Closes cursors declared using the FOR UPDATE clause or referenced elsewhere in the code with the CURRENT OF clause. If MODE=ANSI | ANSI14 or CLOSE_ON_COMMIT=YES is used, then all explicit cursors are closed.</p>
                     </li>
                     <li>
                        <p>Ends the transaction.</p>
                     </li>
                  </ul>
                  <p>When MODE={ANSI13 | ORACLE}, explicit cursors not referenced in a CURRENT OF clause remain open across commits. This can boost performance. For an example, see <span class="q">"<a href="database-concepts.html#GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8">Fetching Across Commits</a>"</span>.
                  </p>
                  <p>Because they are part of normal processing, COMMIT statements should be placed inline, on the main path through your program. Before your program terminates, it must explicitly commit pending changes. Otherwise, Oracle rolls them back. In the following example, you commit your transaction and disconnect:<a id="d10894e1247" class="indexterm-anchor"></a><a id="d10894e1251" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">    EXEC SQL COMMIT WORK RELEASE END-EXEC.
</pre><p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all resources (locks and cursors) held by your program and logs off the database.<a id="d10894e1259" class="indexterm-anchor"></a><a id="d10894e1263" class="indexterm-anchor"></a><a id="d10894e1267" class="indexterm-anchor"></a></p>
                  <p>You need not follow a data definition statement with a COMMIT statement because data definition statements issue an automatic commit before <span class="italic">and</span> after executing. So, whether they succeed or fail, the prior transaction is committed.
                  </p>
               </div><a id="LNPCB220"></a><div class="props_rev_3"><a id="GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06" name="GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06"></a><h4 id="LNPCB-GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06" class="sect4"><span class="enumeration_section">3.6.1 </span>WITH HOLD Clause in DECLARE CURSOR Statements
                  </h4>
                  <div>
                     <p>Any cursor that has been declared with the clause WITH HOLD after the word CURSOR remains open after a COMMIT. The following example shows how to use this clause:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL 
         DECLARE C1 CURSOR WITH HOLD
         FOR SELECT ENAME FROM EMP
         WHERE EMPNO BETWEEN 7600 AND 7700
     END-EXEC.
</pre><p>The cursor must not be declared for UPDATE. The WITH HOLD clause is used in DB2 to override the default, which is to close all cursors on commit. Pro*COBOL provides this clause in order to ease migrations of applications from DB2 to Oracle. When MODE=ANSI, Oracle uses the DB2 default, but all host variables must be declared in a Declare Section. To avoid having a Declare Section, use the precompiler option <span class="italic">CLOSE_ON_COMMIT</span> described next.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-2D17E92E-5215-4BF2-9196-A5B1170C5C81">DECLARE CURSOR (Embedded SQL Directive)</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB221"></a><div class="props_rev_3"><a id="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A" name="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A"></a><h4 id="LNPCB-GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A" class="sect4"><span class="enumeration_section">3.6.2 </span>CLOSE_ON_COMMIT Precompiler Option
                  </h4>
                  <div>
                     <p>The precompiler option CLOSE_ON_COMMIT<span class="italic"> </span>is available to override the default behavior of MODE=ANSI (if you specify MODE=ANSI on the command line, any cursors not declared with the WITH HOLD clause are closed on commit):
                     </p><pre class="oac_no_warn" dir="ltr">CLOSE_ON_COMMIT = {YES | NO} 
</pre><p>The default is NO. This option must be entered only on the command line or in a configuration file. </p>
                     <div class="infoboxnote" id="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A__GUID-1FAA8AAC-AF1F-4C59-AC48-6D9B9D759165">
                        <p class="notep1">Note:</p>
                        <p>Use this option carefully; applications may be slowed if cursors are opened and closed many times because of the need to re-parse for each OPEN statement. See <span class="q">"<a href="precompiler-options.html#GUID-839B1E64-B28C-41BF-9355-783B003C0D81">CLOSE_ON_COMMIT</a>"</span>. 
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB222"></a><div class="props_rev_3"><a id="GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D" name="GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D"></a><h3 id="LNPCB-GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D" class="sect3"><span class="enumeration_section">3.7 </span>Using the ROLLBACK Statement
               </h3>
               <div>
                  <p>You use the ROLLBACK statement to undo pending changes made to the database. For example, if you make a mistake, such as deleting the wrong row from a table, you can use ROLLBACK to restore the original data. The ROLLBACK statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the ROLLBACK statement<a id="d10894e1379" class="indexterm-anchor"></a><a id="d10894e1381" class="indexterm-anchor"></a><a id="d10894e1385" class="indexterm-anchor"></a><a id="d10894e1387" class="indexterm-anchor"></a><a id="d10894e1391" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Undoes all changes made to the database during the current transaction</p>
                     </li>
                     <li>
                        <p>Erases all savepoints</p>
                     </li>
                     <li>
                        <p>Ends the transaction</p>
                     </li>
                     <li>
                        <p>Releases all row and table locks, but not parse locks</p>
                     </li>
                     <li>
                        <p>Closes cursors declared using the FOR UPDATE clause or referenced elsewhere in the code with the CURRENT OF clause. If MODE={ANSI | ANSI14}, then <span class="italic">all</span> explicit cursors are closed.
                        </p>
                     </li>
                  </ul>
                  <p>When MODE={ANSI13 | ORACLE}, explicit cursors not referenced in a CURRENT OF clause remain open across rollbacks.</p>
                  <p>Because they are part of exception processing, ROLLBACK statements should be placed in error handling routines, off the main path through your program. In the following example, you roll back your transaction and disconnect:<a id="d10894e1418" class="indexterm-anchor"></a><a id="d10894e1422" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">    EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
</pre><p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all resources held by your program and logs off the database.<a id="d10894e1430" class="indexterm-anchor"></a><a id="d10894e1434" class="indexterm-anchor"></a></p>
                  <p>If a WHENEVER SQLERROR GOTO statement branches to an error handling routine that includes a ROLLBACK statement, your program might enter an infinite loop if the rollback fails with an error. You can avoid this by coding WHENEVER SQLERROR CONTINUE before the ROLLBACK statement.</p>
                  <p>For example, consider the following:<a id="d10894e1442" class="indexterm-anchor"></a><a id="d10894e1446" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL
         WHENEVER SQLERROR GOTO SQL-ERROR
     END-EXEC.
     ...
     DISPLAY 'Employee number? '.
     ACCEPT EMP-NUMBER.
     DISPLAY 'Employee name? '.
     ACCEPT EMP-NAME.
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME)
        VALUES (:EMP-NUMBER, :EMP-NAME)
     END-EXEC.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     DISPLAY 'PROCESSING ERROR.'.
     DISPLAY 'ERROR CODE : ', SQLCODE.
     DISPLAY 'MESSAGE :', SQLERRMC.
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
     STOP RUN.
</pre><p>Oracle rolls back transactions if your program terminates abnormally.<a id="d10894e1454" class="indexterm-anchor"></a><a id="d10894e1458" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB223"></a><div class="props_rev_3"><a id="GUID-47069C13-2E08-48D0-A139-939BB719055F" name="GUID-47069C13-2E08-48D0-A139-939BB719055F"></a><h4 id="LNPCB-GUID-47069C13-2E08-48D0-A139-939BB719055F" class="sect4"><span class="enumeration_section">3.7.1 </span>Statement-Level Rollbacks
                  </h4>
                  <div>
                     <p>Before executing any SQL statement, Oracle marks an implicit savepoint (not available to you). Then, if the statement fails, Oracle rolls it back automatically and returns the applicable error code to SQLCODE in the SQLCA. For example, if an INSERT statement causes an error by trying to insert a duplicate value in a unique index, the statement is rolled back.<a id="d10894e1486" class="indexterm-anchor"></a><a id="d10894e1488" class="indexterm-anchor"></a></p>
                     <p>Only work started by the failed SQL statement is lost; work done before that statement in the current transaction is kept. Thus, if a data definition statement fails, the automatic commit that precedes it is not undone.</p>
                     <div class="infoboxnote" id="GUID-47069C13-2E08-48D0-A139-939BB719055F__GUID-D11340DC-C168-49C3-B1B6-8681D78F0000">
                        <p class="notep1">Note:</p>
                        <p>Before executing a SQL statement, Oracle must parse it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. Errors detected while executing a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
                     </div>
                     <p>Oracle can also roll back single SQL statements to break deadlocks. Oracle signals an error to one of the participating transactions and rolls back the current statement in that transaction.<a id="d10894e1499" class="indexterm-anchor"></a><a id="d10894e1503" class="indexterm-anchor"></a><a id="d10894e1507" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCB224"></a><div class="props_rev_3"><a id="GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B" name="GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B"></a><h3 id="LNPCB-GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B" class="sect3"><span class="enumeration_section">3.8 </span>Using the SAVEPOINT Statement
               </h3>
               <div>
                  <p>The SAVEPOINT embedded SQL statement marks and names the current point in processing a transaction. Each marked point is called a <span class="italic">savepoint</span>. For example, the following statement marks a savepoint named <span class="italic">start_delete</span>:<a id="d10894e1547" class="indexterm-anchor"></a><a id="d10894e1549" class="indexterm-anchor"></a><a id="d10894e1551" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">    EXEC SQL SAVEPOINT start_delete END-EXEC.
</pre><p>Savepoints let you divide long transactions, giving you more control over complex procedures. For example, if a transaction performs several functions, you can mark a savepoint before each function. Then, if a function fails, you can easily restore the data to its former state, recover, and then reexecute the function.<a id="d10894e1559" class="indexterm-anchor"></a></p>
                  <p>To undo part of a transaction, you can use savepoints with the ROLLBACK statement and its TO SAVEPOINT clause. The TO SAVEPOINT clause lets you roll back to an intermediate statement in the current transaction. With it, you do not have to undo all your changes. Specifically, the ROLLBACK TO SAVEPOINT statement:<a id="d10894e1565" class="indexterm-anchor"></a><a id="d10894e1569" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Undoes changes made to the database since the specified savepoint was marked</p>
                     </li>
                     <li>
                        <p>Erases all savepoints marked after the specified savepoint</p>
                     </li>
                     <li>
                        <p>Releases all row and table locks acquired since the specified savepoint was marked</p>
                     </li>
                  </ul>
                  <p>In the following example, you access the table MAIL_LIST to insert new listings, update old listings, and delete (a few) inactive listings. After the delete, you check SQLERRD(3) in the SQLCA for the number of rows deleted. If the number is unexpectedly large, you roll back to the savepoint <span class="italic">start_delete</span>, undoing just the delete.<a id="d10894e1586" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">* -- For each new customer
     DISPLAY 'New customer number? '.
     ACCEPT CUST-NUMBER.
     IF CUST-NUMBER = 0
          GO TO REV-STATUS
     END-IF.
     DISPLAY 'New customer name? '.
          ACCEPT  CUST-NAME.
     EXEC SQL INSERT INTO MAIL-LIST (CUSTNO, CNAME, STAT)
         VALUES (:CUST-NUMBER, :CUST-NAME, 'ACTIVE').
     END-EXEC.
     ...
* -- For each revised status
 REV-STATUS.
     DISPLAY 'Customer number to revise status? '.
     ACCEPT CUST-NUMBER.
     IF CUST-NUMBER = 0
         GO TO SAVE-POINT
     END-IF.
     DISPLAY 'New status? '.
     ACCEPT NEW-STATUS.
     EXEC SQL UPDATE MAIL-LIST
        SET STAT = :NEW-STATUS WHERE CUSTNO = :CUST-NUMBER
     END-EXEC.
     ...
* -- mark savepoint
 SAVE-POINT.
     EXEC SQL SAVEPOINT START-DELETE END-EXEC.
     EXEC SQL DELETE FROM MAIL-LIST WHERE STAT = 'INACTIVE'
     END-EXEC.
     IF SQLERRD(3) &lt; 25 
* -- check number of rows deleted
         DISPLAY 'Number of rows deleted is ', SQLERRD(3)
     ELSE
         DISPLAY 'Undoing deletion of ', SQLERRD(3), ' rows'
         EXEC SQL
             WHENEVER SQLERROR GOTO SQL-ERROR
         END-EXEC
         EXEC SQL
             ROLLBACK TO SAVEPOINT START-DELETE
         END-EXEC
     END-IF.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     EXEC SQL COMMIT WORK RELEASE END-EXEC.
     STOP RUN.
* -- exit program.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
     DISPLAY 'Processing error'.
* -- exit program with an error.
     STOP RUN.
</pre><p>Note that you cannot specify the RELEASE option in a ROLLBACK TO SAVEPOINT statement.<a id="d10894e1594" class="indexterm-anchor"></a><a id="d10894e1598" class="indexterm-anchor"></a><a id="d10894e1602" class="indexterm-anchor"></a><a id="d10894e1606" class="indexterm-anchor"></a></p>
                  <p>Rolling back to a savepoint erases any savepoints marked after that savepoint. The savepoint to which you roll back, however, is not erased. For example, if you mark five savepoints, then roll back to the third, only the fourth and fifth are erased. A COMMIT or ROLLBACK statement erases all savepoints.<a id="d10894e1612" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB225"></a><div class="props_rev_3"><a id="GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4" name="GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4"></a><h3 id="LNPCB-GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4" class="sect3"><span class="enumeration_section">3.9 </span>Using the RELEASE Option
               </h3>
               <div>
                  <p>Oracle rolls back changes automatically if your program terminates abnormally. Abnormal termination occurs when your program does not explicitly commit or roll back work and disconnect using the RELEASE embedded SQL statement. </p>
                  <p>Normal termination occurs when your program runs its course, closes open cursors, explicitly commits or rolls back work, disconnects, and returns control to the user. Your program will exit gracefully if the last SQL statement it executes is either<a id="d10894e1643" class="indexterm-anchor"></a><a id="d10894e1645" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL COMMIT WORK RELEASE END-EXEC. 
</pre><p>or </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
 </pre><p>where the token WORK is optional. Otherwise, locks and cursors acquired by your user session are held after program termination until Oracle recognizes that the user session is no longer active. This might cause other users in a multiuser environment to wait longer than necessary for the locked resources.<a id="d10894e1656" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCB226"></a><div class="props_rev_3"><a id="GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627" name="GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627"></a><h3 id="LNPCB-GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627" class="sect3"><span class="enumeration_section">3.10 </span>Using the SET TRANSACTION Statement
               </h3>
               <div>
                  <p>You can use the SET TRANSACTION statement to begin a read-only or read/write transaction, or to assign your current transaction to a specified rollback segment. A COMMIT, ROLLBACK, or data definition statement ends a read-only transaction. </p>
                  <p>Because they allow "repeatable reads," read-only transactions are useful for running multiple queries against one or more tables while other users update the same tables. During a read-only transaction, all queries refer to the same snapshot of the database, providing a multitable, multiquery, read-consistent view. Other users can continue to query or update data as usual. An example of the SET TRANSACTION statement follows: <a id="d10894e1687" class="indexterm-anchor"></a><a id="d10894e1691" class="indexterm-anchor"></a><a id="d10894e1695" class="indexterm-anchor"></a><a id="d10894e1697" class="indexterm-anchor"></a>  
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SET TRANSACTION READ ONLY END-EXEC.
 </pre><p>The SET TRANSACTION statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. The READ ONLY parameter is required. Its use does not affect other transactions. Only the SELECT (without FOR UPDATE), LOCK TABLE, SET ROLE, ALTER SESSION, ALTER SYSTEM, COMMIT, and ROLLBACK statements are allowed in a read-only transaction.<a id="d10894e1706" class="indexterm-anchor"></a><a id="d10894e1710" class="indexterm-anchor"></a><a id="d10894e1714" class="indexterm-anchor"></a><a id="d10894e1718" class="indexterm-anchor"></a><a id="d10894e1722" class="indexterm-anchor"></a> 
                  </p>
                  <p>In the following example, a store manager checks sales activity for the day, the past week, and the past month by using a read-only transaction to generate a summary report. The report is unaffected by other users updating the database during the transaction.<a id="d10894e1729" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL SET TRANSACTION READ ONLY END-EXEC. 
     EXEC SQL SELECT SUM(SALEAMT) INTO :DAILY FROM SALES 
         WHERE SALEDATE = SYSDATE END-EXEC.
     EXEC SQL SELECT SUM(SALEAMT) INTO :WEEKLY FROM SALES
         WHERE SALEDATE &gt; SYSDATE - 7 END-EXEC.
     EXEC SQL SELECT SUM(SALEAMT) INTO :MONTHLY FROM SALES 
         WHERE SALEDATE &gt; SYSDATE - 30 END-EXEC. 
     EXEC SQL COMMIT WORK END-EXEC. 
* --  simply ends the transaction since there are no changes 
* --  to make permanent 
* --  format and print report </pre></div>
            </div><a id="LNPCB227"></a><div class="props_rev_3"><a id="GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC" name="GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC"></a><h3 id="LNPCB-GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC" class="sect3"><span class="enumeration_section">3.11 </span>Overriding Default Locking
               </h3>
               <div>
                  <p>By default, Oracle implicitly (automatically) locks many data structures for you. However, you can request specific data locks on rows or tables when it is to your advantage to override default locking. Explicit locking lets you share or deny access to a table for the duration of a transaction or ensure multitable and multiquery read consistency.<a id="d10894e1760" class="indexterm-anchor"></a><a id="d10894e1764" class="indexterm-anchor"></a><a id="d10894e1768" class="indexterm-anchor"></a></p>
                  <p>With the SELECT FOR UPDATE OF statement, you can explicitly lock specific rows of a table to make sure they do not change before an update or delete is executed. However, Oracle automatically obtains row-level locks at update or delete time. So, use the FOR UPDATE OF clause only if you want to lock the rows <span class="italic">before</span> the update or delete.<a id="d10894e1775" class="indexterm-anchor"></a></p>
                  <p>You can explicitly lock entire tables using the LOCK TABLE statement. </p>
               </div><a id="LNPCB228"></a><div class="props_rev_3"><a id="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21" name="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21"></a><h4 id="LNPCB-GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21" class="sect4"><span class="enumeration_section">3.11.1 </span>Using the FOR UPDATE OF Clause
                  </h4>
                  <div>
                     <p>When you DECLARE a cursor, you can meanwhile optionally specify the FOR UPDATE clause, which has the effect of acquiring an exclusive lock on all rows defined by the cursor. This is useful, for example, when you want to base an update on existing rows in a table and want to ensure that they are not meanwhile changed by anyone else.</p>
                     <p>Note that if you refer to a cursor with the CURRENT OF clause, that the precompiler will automatically add the FOR UPDATE clause to the cursor definition and the word OF is optional.<a id="d10894e1807" class="indexterm-anchor"></a><a id="d10894e1811" class="indexterm-anchor"></a> For instance, instead of:
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL DECLARE emp_cursor CURSOR FOR 
         SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
            FOR UPDATE OF SAL
     END-EXEC.
 </pre><p>you can drop the OF part of the clause and simply code:</p><pre class="oac_no_warn" dir="ltr">    EXEC SQL DECLARE emp_cursor CURSOR FOR 
        SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
           FOR UPDATE
    END-EXEC.
</pre><div class="infoboxnotealso" id="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21__GUID-5DFA3243-112E-4E79-A575-E210BC80640E">
                        <p class="notep1">See Also:</p><span class="q">"<a href="embedded-SQL.html#GUID-E0B72EA2-521D-4604-BD41-0B2B1BC59381">Using the CURRENT OF Clause </a>"</span> for an example.
                     </div>
                  </div><a id="LNPCB229"></a><div class="props_rev_3"><a id="GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2" name="GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2"></a><h5 id="LNPCB-GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2" class="sect5"><span class="enumeration_section">3.11.1.1 </span>Restrictions
                     </h5>
                     <div>
                        <p>You cannot use FOR UPDATE with multiple tables, but you must use FOR UPDATE OF to identify a column in the table that you want locked. Row locks obtained by a FOR UPDATE statement are cleared by a COMMIT, which explains why the cursor is closed for you. If you try to fetch from a FOR UPDATE cursor after a commit, Oracle generates a Fetch out of Sequence error.<a id="d10894e1850" class="indexterm-anchor"></a><a id="d10894e1854" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB230"></a><div class="props_rev_3"><a id="GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8" name="GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8"></a><h3 id="LNPCB-GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8" class="sect3"><span class="enumeration_section">3.12 </span>Fetching Across Commits
               </h3>
               <div>
                  <p>If you want to mix commits and fetches, do not use the CURRENT OF clause. Instead, select the ROWID of each row, and then use that value to identify the current row during the update or delete. Consider the following example:<a id="d10894e1883" class="indexterm-anchor"></a><a id="d10894e1887" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL DECLARE emp_cursor CURSOR FOR
         SELECT ENAME, SAL, ROWID FROM EMP WHERE JOB = 'CLERK'
     END-EXEC.
     ...
     EXEC SQL OPEN emp_cursor END-EXEC.
     EXEC SQL WHENEVER NOT FOUND GOTO ...
     PERFORM
     EXEC SQL
         FETCH emp_cursor INTO :EMP_NAME, :SALARY, :ROW-ID
     END-EXEC
     ... 
         EXEC SQL UPDATE EMP SET SAL = :NEW-SALARY
             WHERE ROWID = :ROW-ID
         END-EXEC
         EXEC SQL COMMIT END-EXEC
     END-PERFORM.
</pre><p>Note, however, that the fetched rows are <span class="italic">not</span> locked. So, you can receive inconsistent results if another user modifies a row after you read it but before you update or delete it.
                  </p>
               </div><a id="LNPCB231"></a><div class="props_rev_3"><a id="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0" name="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0"></a><h4 id="LNPCB-GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0" class="sect4"><span class="enumeration_section">3.12.1 </span>Using the LOCK TABLE Statement
                  </h4>
                  <div>
                     <p>Use the LOCK TABLE statement locks one or more tables in a specified lock mode. For example, the following statement locks the EMP table in <span class="italic">row share</span> mode. Row share locks allow concurrent access to a table. They prevent other users from locking the entire table for exclusive use.<a id="d10894e1925" class="indexterm-anchor"></a><a id="d10894e1929" class="indexterm-anchor"></a><a id="d10894e1933" class="indexterm-anchor"></a><a id="d10894e1935" class="indexterm-anchor"></a><a id="d10894e1939" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL
         LOCK TABLE EMP IN ROW SHARE MODE NOWAIT
     END-EXEC.
</pre><p>The lock mode determines what other locks can be placed on the table. For example, many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an <span class="italic">exclusive</span> lock. While one user has an exclusive lock on a table, no other users can insert, update, or delete rows in that table.
                     </p>
                     <p>The optional keyword NOWAIT tells Oracle not to wait for a table if it has been locked by another user. Control is immediately returned to your program so that it can do other work before trying again to acquire the lock. (You can check SQLCODE in the SQLCA to see if the table lock failed.) If you omit NOWAIT, Oracle waits until the table is available; the wait has no set limit.<a id="d10894e1952" class="indexterm-anchor"></a><a id="d10894e1956" class="indexterm-anchor"></a><a id="d10894e1960" class="indexterm-anchor"></a></p>
                     <p>A table lock never keeps other users from querying a table, and a query never acquires a table lock. Consequently, a query never blocks another query or an update, and an update never blocks a query. Only if two different transactions try to update the same row will one transaction wait for the other to complete. Table locks are released when your transaction issues a COMMIT or ROLLBACK.<a id="d10894e1964" class="indexterm-anchor"></a></p>
                     <div class="infoboxnotealso" id="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0__GUID-22418AB6-5109-4545-B365-5EE970E7E725">
                        <p class="notep1">See Also:</p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-57365E45-5F85-471B-81D9-F52EA16F1E85" target="_blank">Using Oracle Lock Management Services</a> for more information about lock modes.
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB232"></a><div class="props_rev_3"><a id="GUID-123F9392-C594-46DB-A2BB-92A92953C08A" name="GUID-123F9392-C594-46DB-A2BB-92A92953C08A"></a><h3 id="LNPCB-GUID-123F9392-C594-46DB-A2BB-92A92953C08A" class="sect3"><span class="enumeration_section">3.13 </span>Handling Distributed Transactions
               </h3>
               <div>
                  <p>A <span class="italic">distributed database</span> is a single logical database comprising multiple physical databases at different nodes. A <span class="italic">distributed statement</span> is any SQL statement that accesses a remote node using a database link. A <span class="italic">distributed transaction</span> includes at least one distributed statement that updates data at multiple nodes of a distributed database. If the update affects only one node, the transaction is non-distributed.
                  </p>
                  <p>When you issue a commit, changes to each database affected by the distributed transaction are made permanent. If instead you issue a rollback, all the changes are undone. However, if a network or machine fails during the commit or rollback, the state of the distributed transaction might be unknown or <span class="italic">in doubt</span>. In such cases, if you have FORCE TRANSACTION system privileges, you can manually commit or roll back the transaction at your local database by using the FORCE clause. The transaction must be identified by a quoted literal containing the transaction ID, which can be found in the data dictionary view DBA_2PC_PENDING. Some examples follow:<a id="d10894e2011" class="indexterm-anchor"></a><a id="d10894e2013" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL COMMIT FORCE '22.31.83' END-EXEC.
     ...
     EXEC SQL ROLLBACK FORCE '25.33.86'END-EXEC.
</pre><p>FORCE commits or rolls back only the specified transaction and does not affect your current transaction. Note that you cannot manually roll back in-doubt transactions to a savepoint.</p>
                  <p>The COMMENT clause in the COMMIT statement lets you specify a Comment to be associated with a distributed transaction. If ever the transaction is in doubt, the server stores the text specified by COMMENT in the data dictionary view DBA_2PC_PENDING along with the transaction ID. The text must be a quoted literal of no more than â€‰50 characters in length. An example follows:</p><pre class="oac_no_warn" dir="ltr">     EXEC SQL
         COMMIT COMMENT 'In-doubt trans; notify Order Entry'
     END-EXEC.
</pre><div class="infoboxnotealso" id="GUID-123F9392-C594-46DB-A2BB-92A92953C08A__GUID-F56F1844-B750-4D2F-9764-82354401F4DA">
                     <p class="notep1">See Also:</p><a href="../cncpt/transactions.html#CNCPT1125" target="_blank"><span class="italic">Oracle Database Concepts.</span></a> for more information about distributed transactions.
                  </div>
               </div>
            </div><a id="LNPCB233"></a><div class="props_rev_3"><a id="GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12" name="GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12"></a><h3 id="LNPCB-GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12" class="sect3"><span class="enumeration_section">3.14 </span>Guidelines for Transaction Processing
               </h3>
               <div>
                  <p>The following guidelines will help you avoid some common problems.</p>
               </div><a id="LNPCB234"></a><div class="props_rev_3"><a id="GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1" name="GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1"></a><h4 id="LNPCB-GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1" class="sect4"><span class="enumeration_section">3.14.1 </span>Designing Applications
                  </h4>
                  <div>
                     <p>When designing your application, group logically related actions together in one transaction. A well-designed transaction includes all the steps necessary to accomplish a given taskâ€”no more and no less.</p>
                     <p>Data in the tables you reference must be left in a consistent state. Thus, the SQL statements in a transaction should change the data in a consistent way. For example, a transfer of funds between two bank accounts should include a debit to one account and a credit to another. Both updates should either succeed or fail together. An unrelated update, such as a new deposit to one account, should not be included in the transaction.<a id="d10894e2081" class="indexterm-anchor"></a><a id="d10894e2085" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB235"></a><div class="props_rev_3"><a id="GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E" name="GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E"></a><h4 id="LNPCB-GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E" class="sect4"><span class="enumeration_section">3.14.2 </span>Obtaining Locks
                  </h4>
                  <div>
                     <p>If your application programs include SQL locking statements, make sure the users requesting locks have the privileges needed to obtain the locks. Your DBA can lock any table. Other users can lock tables they own or tables for which they have a privilege, such as ALTER, SELECT, INSERT, UPDATE, or DELETE.<a id="d10894e2113" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB236"></a><div class="props_rev_3"><a id="GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B" name="GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B"></a><h4 id="LNPCB-GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B" class="sect4"><span class="enumeration_section">3.14.3 </span>Using PL/SQL
                  </h4>
                  <div>
                     <p>If a PL/SQL block is part of a transaction, commits and rollback operations inside the block affect the whole transaction. In the following example, the rollback operation undoes changes made by the update <span class="italic">and</span> the insert:<a id="d10894e2145" class="indexterm-anchor"></a><a id="d10894e2149" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL INSERT INTO EMP ...
     EXEC SQL EXECUTE
     BEGIN        UPDATE emp 
     ...
         ...
     EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
             ROLLBACK;
     END;
     END-EXEC.
     ...</pre></div>
               </div><a id="LNPCB237"></a><div class="props_rev_3"><a id="GUID-10D56616-11FD-449A-8344-D4B20E8843E4" name="GUID-10D56616-11FD-449A-8344-D4B20E8843E4"></a><h4 id="LNPCB-GUID-10D56616-11FD-449A-8344-D4B20E8843E4" class="sect4"><span class="enumeration_section">3.14.4 </span>X/Open Applications
                  </h4>
                  <div>
                     <p>For instructions on using the XA interface in X/Open applications, see <a href="../adfns/xa.html#ADFNS-GUID-19B8285C-F8CA-4857-89E3-477C6BD1483C" target="_blank">X/Open Distributed Transaction Processing (DTP)</a>.
                     </p><pre class="oac_no_warn" dir="ltr"></pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>